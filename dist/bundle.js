(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],2:[function(require,module,exports){
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],3:[function(require,module,exports){
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],4:[function(require,module,exports){
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],5:[function(require,module,exports){
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],6:[function(require,module,exports){
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],7:[function(require,module,exports){
var superPropBase = require("./superPropBase.js");

function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get, module.exports.__esModule = true, module.exports["default"] = module.exports;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }

      return desc.value;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }

  return _get.apply(this, arguments);
}

module.exports = _get, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./superPropBase.js":16}],8:[function(require,module,exports){
function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],9:[function(require,module,exports){
var setPrototypeOf = require("./setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./setPrototypeOf.js":14}],10:[function(require,module,exports){
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],11:[function(require,module,exports){
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],12:[function(require,module,exports){
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],13:[function(require,module,exports){
var _typeof = require("./typeof.js")["default"];

var assertThisInitialized = require("./assertThisInitialized.js");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./assertThisInitialized.js":3,"./typeof.js":17}],14:[function(require,module,exports){
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],15:[function(require,module,exports){
var arrayWithHoles = require("./arrayWithHoles.js");

var iterableToArrayLimit = require("./iterableToArrayLimit.js");

var unsupportedIterableToArray = require("./unsupportedIterableToArray.js");

var nonIterableRest = require("./nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./arrayWithHoles.js":2,"./iterableToArrayLimit.js":11,"./nonIterableRest.js":12,"./unsupportedIterableToArray.js":18}],16:[function(require,module,exports){
var getPrototypeOf = require("./getPrototypeOf.js");

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

module.exports = _superPropBase, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./getPrototypeOf.js":8}],17:[function(require,module,exports){
function _typeof(obj) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
}

module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],18:[function(require,module,exports){
var arrayLikeToArray = require("./arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./arrayLikeToArray.js":1}],19:[function(require,module,exports){
module.exports = require("regenerator-runtime");

},{"regenerator-runtime":21}],20:[function(require,module,exports){
/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.dat = {})));
}(this, (function (exports) { 'use strict';

function ___$insertStyle(css) {
  if (!css) {
    return;
  }
  if (typeof window === 'undefined') {
    return;
  }

  var style = document.createElement('style');

  style.setAttribute('type', 'text/css');
  style.innerHTML = css;
  document.head.appendChild(style);

  return css;
}

function colorToString (color, forceCSSHex) {
  var colorFormat = color.__state.conversionName.toString();
  var r = Math.round(color.r);
  var g = Math.round(color.g);
  var b = Math.round(color.b);
  var a = color.a;
  var h = Math.round(color.h);
  var s = color.s.toFixed(1);
  var v = color.v.toFixed(1);
  if (forceCSSHex || colorFormat === 'THREE_CHAR_HEX' || colorFormat === 'SIX_CHAR_HEX') {
    var str = color.hex.toString(16);
    while (str.length < 6) {
      str = '0' + str;
    }
    return '#' + str;
  } else if (colorFormat === 'CSS_RGB') {
    return 'rgb(' + r + ',' + g + ',' + b + ')';
  } else if (colorFormat === 'CSS_RGBA') {
    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  } else if (colorFormat === 'HEX') {
    return '0x' + color.hex.toString(16);
  } else if (colorFormat === 'RGB_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ']';
  } else if (colorFormat === 'RGBA_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ',' + a + ']';
  } else if (colorFormat === 'RGB_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + '}';
  } else if (colorFormat === 'RGBA_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}';
  } else if (colorFormat === 'HSV_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + '}';
  } else if (colorFormat === 'HSVA_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + ',a:' + a + '}';
  }
  return 'unknown format';
}

var ARR_EACH = Array.prototype.forEach;
var ARR_SLICE = Array.prototype.slice;
var Common = {
  BREAK: {},
  extend: function extend(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (!this.isUndefined(obj[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  defaults: function defaults(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (this.isUndefined(target[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  compose: function compose() {
    var toCall = ARR_SLICE.call(arguments);
    return function () {
      var args = ARR_SLICE.call(arguments);
      for (var i = toCall.length - 1; i >= 0; i--) {
        args = [toCall[i].apply(this, args)];
      }
      return args[0];
    };
  },
  each: function each(obj, itr, scope) {
    if (!obj) {
      return;
    }
    if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {
      obj.forEach(itr, scope);
    } else if (obj.length === obj.length + 0) {
      var key = void 0;
      var l = void 0;
      for (key = 0, l = obj.length; key < l; key++) {
        if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {
          return;
        }
      }
    } else {
      for (var _key in obj) {
        if (itr.call(scope, obj[_key], _key) === this.BREAK) {
          return;
        }
      }
    }
  },
  defer: function defer(fnc) {
    setTimeout(fnc, 0);
  },
  debounce: function debounce(func, threshold, callImmediately) {
    var timeout = void 0;
    return function () {
      var obj = this;
      var args = arguments;
      function delayed() {
        timeout = null;
        if (!callImmediately) func.apply(obj, args);
      }
      var callNow = callImmediately || !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(delayed, threshold);
      if (callNow) {
        func.apply(obj, args);
      }
    };
  },
  toArray: function toArray(obj) {
    if (obj.toArray) return obj.toArray();
    return ARR_SLICE.call(obj);
  },
  isUndefined: function isUndefined(obj) {
    return obj === undefined;
  },
  isNull: function isNull(obj) {
    return obj === null;
  },
  isNaN: function (_isNaN) {
    function isNaN(_x) {
      return _isNaN.apply(this, arguments);
    }
    isNaN.toString = function () {
      return _isNaN.toString();
    };
    return isNaN;
  }(function (obj) {
    return isNaN(obj);
  }),
  isArray: Array.isArray || function (obj) {
    return obj.constructor === Array;
  },
  isObject: function isObject(obj) {
    return obj === Object(obj);
  },
  isNumber: function isNumber(obj) {
    return obj === obj + 0;
  },
  isString: function isString(obj) {
    return obj === obj + '';
  },
  isBoolean: function isBoolean(obj) {
    return obj === false || obj === true;
  },
  isFunction: function isFunction(obj) {
    return obj instanceof Function;
  }
};

var INTERPRETATIONS = [
{
  litmus: Common.isString,
  conversions: {
    THREE_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)
        };
      },
      write: colorToString
    },
    SIX_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9]{6})$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString(), 0)
        };
      },
      write: colorToString
    },
    CSS_RGB: {
      read: function read(original) {
        var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3])
        };
      },
      write: colorToString
    },
    CSS_RGBA: {
      read: function read(original) {
        var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3]),
          a: parseFloat(test[4])
        };
      },
      write: colorToString
    }
  }
},
{
  litmus: Common.isNumber,
  conversions: {
    HEX: {
      read: function read(original) {
        return {
          space: 'HEX',
          hex: original,
          conversionName: 'HEX'
        };
      },
      write: function write(color) {
        return color.hex;
      }
    }
  }
},
{
  litmus: Common.isArray,
  conversions: {
    RGB_ARRAY: {
      read: function read(original) {
        if (original.length !== 3) {
          return false;
        }
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b];
      }
    },
    RGBA_ARRAY: {
      read: function read(original) {
        if (original.length !== 4) return false;
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2],
          a: original[3]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b, color.a];
      }
    }
  }
},
{
  litmus: Common.isObject,
  conversions: {
    RGBA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b,
          a: color.a
        };
      }
    },
    RGB_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b
        };
      }
    },
    HSVA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v,
          a: color.a
        };
      }
    },
    HSV_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v
        };
      }
    }
  }
}];
var result = void 0;
var toReturn = void 0;
var interpret = function interpret() {
  toReturn = false;
  var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];
  Common.each(INTERPRETATIONS, function (family) {
    if (family.litmus(original)) {
      Common.each(family.conversions, function (conversion, conversionName) {
        result = conversion.read(original);
        if (toReturn === false && result !== false) {
          toReturn = result;
          result.conversionName = conversionName;
          result.conversion = conversion;
          return Common.BREAK;
        }
      });
      return Common.BREAK;
    }
  });
  return toReturn;
};

var tmpComponent = void 0;
var ColorMath = {
  hsv_to_rgb: function hsv_to_rgb(h, s, v) {
    var hi = Math.floor(h / 60) % 6;
    var f = h / 60 - Math.floor(h / 60);
    var p = v * (1.0 - s);
    var q = v * (1.0 - f * s);
    var t = v * (1.0 - (1.0 - f) * s);
    var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];
    return {
      r: c[0] * 255,
      g: c[1] * 255,
      b: c[2] * 255
    };
  },
  rgb_to_hsv: function rgb_to_hsv(r, g, b) {
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h = void 0;
    var s = void 0;
    if (max !== 0) {
      s = delta / max;
    } else {
      return {
        h: NaN,
        s: 0,
        v: 0
      };
    }
    if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else {
      h = 4 + (r - g) / delta;
    }
    h /= 6;
    if (h < 0) {
      h += 1;
    }
    return {
      h: h * 360,
      s: s,
      v: max / 255
    };
  },
  rgb_to_hex: function rgb_to_hex(r, g, b) {
    var hex = this.hex_with_component(0, 2, r);
    hex = this.hex_with_component(hex, 1, g);
    hex = this.hex_with_component(hex, 0, b);
    return hex;
  },
  component_from_hex: function component_from_hex(hex, componentIndex) {
    return hex >> componentIndex * 8 & 0xFF;
  },
  hex_with_component: function hex_with_component(hex, componentIndex, value) {
    return value << (tmpComponent = componentIndex * 8) | hex & ~(0xFF << tmpComponent);
  }
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var Color = function () {
  function Color() {
    classCallCheck(this, Color);
    this.__state = interpret.apply(this, arguments);
    if (this.__state === false) {
      throw new Error('Failed to interpret color arguments');
    }
    this.__state.a = this.__state.a || 1;
  }
  createClass(Color, [{
    key: 'toString',
    value: function toString() {
      return colorToString(this);
    }
  }, {
    key: 'toHexString',
    value: function toHexString() {
      return colorToString(this, true);
    }
  }, {
    key: 'toOriginal',
    value: function toOriginal() {
      return this.__state.conversion.write(this);
    }
  }]);
  return Color;
}();
function defineRGBComponent(target, component, componentHexIndex) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'RGB') {
        return this.__state[component];
      }
      Color.recalculateRGB(this, component, componentHexIndex);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'RGB') {
        Color.recalculateRGB(this, component, componentHexIndex);
        this.__state.space = 'RGB';
      }
      this.__state[component] = v;
    }
  });
}
function defineHSVComponent(target, component) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'HSV') {
        return this.__state[component];
      }
      Color.recalculateHSV(this);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'HSV') {
        Color.recalculateHSV(this);
        this.__state.space = 'HSV';
      }
      this.__state[component] = v;
    }
  });
}
Color.recalculateRGB = function (color, component, componentHexIndex) {
  if (color.__state.space === 'HEX') {
    color.__state[component] = ColorMath.component_from_hex(color.__state.hex, componentHexIndex);
  } else if (color.__state.space === 'HSV') {
    Common.extend(color.__state, ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));
  } else {
    throw new Error('Corrupted color state');
  }
};
Color.recalculateHSV = function (color) {
  var result = ColorMath.rgb_to_hsv(color.r, color.g, color.b);
  Common.extend(color.__state, {
    s: result.s,
    v: result.v
  });
  if (!Common.isNaN(result.h)) {
    color.__state.h = result.h;
  } else if (Common.isUndefined(color.__state.h)) {
    color.__state.h = 0;
  }
};
Color.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a'];
defineRGBComponent(Color.prototype, 'r', 2);
defineRGBComponent(Color.prototype, 'g', 1);
defineRGBComponent(Color.prototype, 'b', 0);
defineHSVComponent(Color.prototype, 'h');
defineHSVComponent(Color.prototype, 's');
defineHSVComponent(Color.prototype, 'v');
Object.defineProperty(Color.prototype, 'a', {
  get: function get$$1() {
    return this.__state.a;
  },
  set: function set$$1(v) {
    this.__state.a = v;
  }
});
Object.defineProperty(Color.prototype, 'hex', {
  get: function get$$1() {
    if (this.__state.space !== 'HEX') {
      this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);
      this.__state.space = 'HEX';
    }
    return this.__state.hex;
  },
  set: function set$$1(v) {
    this.__state.space = 'HEX';
    this.__state.hex = v;
  }
});

var Controller = function () {
  function Controller(object, property) {
    classCallCheck(this, Controller);
    this.initialValue = object[property];
    this.domElement = document.createElement('div');
    this.object = object;
    this.property = property;
    this.__onChange = undefined;
    this.__onFinishChange = undefined;
  }
  createClass(Controller, [{
    key: 'onChange',
    value: function onChange(fnc) {
      this.__onChange = fnc;
      return this;
    }
  }, {
    key: 'onFinishChange',
    value: function onFinishChange(fnc) {
      this.__onFinishChange = fnc;
      return this;
    }
  }, {
    key: 'setValue',
    value: function setValue(newValue) {
      this.object[this.property] = newValue;
      if (this.__onChange) {
        this.__onChange.call(this, newValue);
      }
      this.updateDisplay();
      return this;
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return this.object[this.property];
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      return this;
    }
  }, {
    key: 'isModified',
    value: function isModified() {
      return this.initialValue !== this.getValue();
    }
  }]);
  return Controller;
}();

var EVENT_MAP = {
  HTMLEvents: ['change'],
  MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'],
  KeyboardEvents: ['keydown']
};
var EVENT_MAP_INV = {};
Common.each(EVENT_MAP, function (v, k) {
  Common.each(v, function (e) {
    EVENT_MAP_INV[e] = k;
  });
});
var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;
function cssValueToPixels(val) {
  if (val === '0' || Common.isUndefined(val)) {
    return 0;
  }
  var match = val.match(CSS_VALUE_PIXELS);
  if (!Common.isNull(match)) {
    return parseFloat(match[1]);
  }
  return 0;
}
var dom = {
  makeSelectable: function makeSelectable(elem, selectable) {
    if (elem === undefined || elem.style === undefined) return;
    elem.onselectstart = selectable ? function () {
      return false;
    } : function () {};
    elem.style.MozUserSelect = selectable ? 'auto' : 'none';
    elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
    elem.unselectable = selectable ? 'on' : 'off';
  },
  makeFullscreen: function makeFullscreen(elem, hor, vert) {
    var vertical = vert;
    var horizontal = hor;
    if (Common.isUndefined(horizontal)) {
      horizontal = true;
    }
    if (Common.isUndefined(vertical)) {
      vertical = true;
    }
    elem.style.position = 'absolute';
    if (horizontal) {
      elem.style.left = 0;
      elem.style.right = 0;
    }
    if (vertical) {
      elem.style.top = 0;
      elem.style.bottom = 0;
    }
  },
  fakeEvent: function fakeEvent(elem, eventType, pars, aux) {
    var params = pars || {};
    var className = EVENT_MAP_INV[eventType];
    if (!className) {
      throw new Error('Event type ' + eventType + ' not supported.');
    }
    var evt = document.createEvent(className);
    switch (className) {
      case 'MouseEvents':
        {
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0,
          0,
          clientX,
          clientY,
          false, false, false, false, 0, null);
          break;
        }
      case 'KeyboardEvents':
        {
          var init = evt.initKeyboardEvent || evt.initKeyEvent;
          Common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);
          break;
        }
      default:
        {
          evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);
          break;
        }
    }
    Common.defaults(evt, aux);
    elem.dispatchEvent(evt);
  },
  bind: function bind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.addEventListener) {
      elem.addEventListener(event, func, bool);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + event, func);
    }
    return dom;
  },
  unbind: function unbind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.removeEventListener) {
      elem.removeEventListener(event, func, bool);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + event, func);
    }
    return dom;
  },
  addClass: function addClass(elem, className) {
    if (elem.className === undefined) {
      elem.className = className;
    } else if (elem.className !== className) {
      var classes = elem.className.split(/ +/);
      if (classes.indexOf(className) === -1) {
        classes.push(className);
        elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
      }
    }
    return dom;
  },
  removeClass: function removeClass(elem, className) {
    if (className) {
      if (elem.className === className) {
        elem.removeAttribute('class');
      } else {
        var classes = elem.className.split(/ +/);
        var index = classes.indexOf(className);
        if (index !== -1) {
          classes.splice(index, 1);
          elem.className = classes.join(' ');
        }
      }
    } else {
      elem.className = undefined;
    }
    return dom;
  },
  hasClass: function hasClass(elem, className) {
    return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
  },
  getWidth: function getWidth(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-left-width']) + cssValueToPixels(style['border-right-width']) + cssValueToPixels(style['padding-left']) + cssValueToPixels(style['padding-right']) + cssValueToPixels(style.width);
  },
  getHeight: function getHeight(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-top-width']) + cssValueToPixels(style['border-bottom-width']) + cssValueToPixels(style['padding-top']) + cssValueToPixels(style['padding-bottom']) + cssValueToPixels(style.height);
  },
  getOffset: function getOffset(el) {
    var elem = el;
    var offset = { left: 0, top: 0 };
    if (elem.offsetParent) {
      do {
        offset.left += elem.offsetLeft;
        offset.top += elem.offsetTop;
        elem = elem.offsetParent;
      } while (elem);
    }
    return offset;
  },
  isActive: function isActive(elem) {
    return elem === document.activeElement && (elem.type || elem.href);
  }
};

var BooleanController = function (_Controller) {
  inherits(BooleanController, _Controller);
  function BooleanController(object, property) {
    classCallCheck(this, BooleanController);
    var _this2 = possibleConstructorReturn(this, (BooleanController.__proto__ || Object.getPrototypeOf(BooleanController)).call(this, object, property));
    var _this = _this2;
    _this2.__prev = _this2.getValue();
    _this2.__checkbox = document.createElement('input');
    _this2.__checkbox.setAttribute('type', 'checkbox');
    function onChange() {
      _this.setValue(!_this.__prev);
    }
    dom.bind(_this2.__checkbox, 'change', onChange, false);
    _this2.domElement.appendChild(_this2.__checkbox);
    _this2.updateDisplay();
    return _this2;
  }
  createClass(BooleanController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      this.__prev = this.getValue();
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (this.getValue() === true) {
        this.__checkbox.setAttribute('checked', 'checked');
        this.__checkbox.checked = true;
        this.__prev = true;
      } else {
        this.__checkbox.checked = false;
        this.__prev = false;
      }
      return get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return BooleanController;
}(Controller);

var OptionController = function (_Controller) {
  inherits(OptionController, _Controller);
  function OptionController(object, property, opts) {
    classCallCheck(this, OptionController);
    var _this2 = possibleConstructorReturn(this, (OptionController.__proto__ || Object.getPrototypeOf(OptionController)).call(this, object, property));
    var options = opts;
    var _this = _this2;
    _this2.__select = document.createElement('select');
    if (Common.isArray(options)) {
      var map = {};
      Common.each(options, function (element) {
        map[element] = element;
      });
      options = map;
    }
    Common.each(options, function (value, key) {
      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);
    });
    _this2.updateDisplay();
    dom.bind(_this2.__select, 'change', function () {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });
    _this2.domElement.appendChild(_this2.__select);
    return _this2;
  }
  createClass(OptionController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (dom.isActive(this.__select)) return this;
      this.__select.value = this.getValue();
      return get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return OptionController;
}(Controller);

var StringController = function (_Controller) {
  inherits(StringController, _Controller);
  function StringController(object, property) {
    classCallCheck(this, StringController);
    var _this2 = possibleConstructorReturn(this, (StringController.__proto__ || Object.getPrototypeOf(StringController)).call(this, object, property));
    var _this = _this2;
    function onChange() {
      _this.setValue(_this.__input.value);
    }
    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'keyup', onChange);
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(StringController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (!dom.isActive(this.__input)) {
        this.__input.value = this.getValue();
      }
      return get(StringController.prototype.__proto__ || Object.getPrototypeOf(StringController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return StringController;
}(Controller);

function numDecimals(x) {
  var _x = x.toString();
  if (_x.indexOf('.') > -1) {
    return _x.length - _x.indexOf('.') - 1;
  }
  return 0;
}
var NumberController = function (_Controller) {
  inherits(NumberController, _Controller);
  function NumberController(object, property, params) {
    classCallCheck(this, NumberController);
    var _this = possibleConstructorReturn(this, (NumberController.__proto__ || Object.getPrototypeOf(NumberController)).call(this, object, property));
    var _params = params || {};
    _this.__min = _params.min;
    _this.__max = _params.max;
    _this.__step = _params.step;
    if (Common.isUndefined(_this.__step)) {
      if (_this.initialValue === 0) {
        _this.__impliedStep = 1;
      } else {
        _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;
      }
    } else {
      _this.__impliedStep = _this.__step;
    }
    _this.__precision = numDecimals(_this.__impliedStep);
    return _this;
  }
  createClass(NumberController, [{
    key: 'setValue',
    value: function setValue(v) {
      var _v = v;
      if (this.__min !== undefined && _v < this.__min) {
        _v = this.__min;
      } else if (this.__max !== undefined && _v > this.__max) {
        _v = this.__max;
      }
      if (this.__step !== undefined && _v % this.__step !== 0) {
        _v = Math.round(_v / this.__step) * this.__step;
      }
      return get(NumberController.prototype.__proto__ || Object.getPrototypeOf(NumberController.prototype), 'setValue', this).call(this, _v);
    }
  }, {
    key: 'min',
    value: function min(minValue) {
      this.__min = minValue;
      return this;
    }
  }, {
    key: 'max',
    value: function max(maxValue) {
      this.__max = maxValue;
      return this;
    }
  }, {
    key: 'step',
    value: function step(stepValue) {
      this.__step = stepValue;
      this.__impliedStep = stepValue;
      this.__precision = numDecimals(stepValue);
      return this;
    }
  }]);
  return NumberController;
}(Controller);

function roundToDecimal(value, decimals) {
  var tenTo = Math.pow(10, decimals);
  return Math.round(value * tenTo) / tenTo;
}
var NumberControllerBox = function (_NumberController) {
  inherits(NumberControllerBox, _NumberController);
  function NumberControllerBox(object, property, params) {
    classCallCheck(this, NumberControllerBox);
    var _this2 = possibleConstructorReturn(this, (NumberControllerBox.__proto__ || Object.getPrototypeOf(NumberControllerBox)).call(this, object, property, params));
    _this2.__truncationSuspended = false;
    var _this = _this2;
    var prevY = void 0;
    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!Common.isNaN(attempted)) {
        _this.setValue(attempted);
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onBlur() {
      onFinish();
    }
    function onMouseDrag(e) {
      var diff = prevY - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);
      prevY = e.clientY;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      onFinish();
    }
    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prevY = e.clientY;
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'mousedown', onMouseDown);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
        onFinish();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(NumberControllerBox, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
      return get(NumberControllerBox.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerBox;
}(NumberController);

function map(v, i1, i2, o1, o2) {
  return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
}
var NumberControllerSlider = function (_NumberController) {
  inherits(NumberControllerSlider, _NumberController);
  function NumberControllerSlider(object, property, min, max, step) {
    classCallCheck(this, NumberControllerSlider);
    var _this2 = possibleConstructorReturn(this, (NumberControllerSlider.__proto__ || Object.getPrototypeOf(NumberControllerSlider)).call(this, object, property, { min: min, max: max, step: step }));
    var _this = _this2;
    _this2.__background = document.createElement('div');
    _this2.__foreground = document.createElement('div');
    dom.bind(_this2.__background, 'mousedown', onMouseDown);
    dom.bind(_this2.__background, 'touchstart', onTouchStart);
    dom.addClass(_this2.__background, 'slider');
    dom.addClass(_this2.__foreground, 'slider-fg');
    function onMouseDown(e) {
      document.activeElement.blur();
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      onMouseDrag(e);
    }
    function onMouseDrag(e) {
      e.preventDefault();
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
      return false;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onTouchStart(e) {
      if (e.touches.length !== 1) {
        return;
      }
      dom.bind(window, 'touchmove', onTouchMove);
      dom.bind(window, 'touchend', onTouchEnd);
      onTouchMove(e);
    }
    function onTouchMove(e) {
      var clientX = e.touches[0].clientX;
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
    }
    function onTouchEnd() {
      dom.unbind(window, 'touchmove', onTouchMove);
      dom.unbind(window, 'touchend', onTouchEnd);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.updateDisplay();
    _this2.__background.appendChild(_this2.__foreground);
    _this2.domElement.appendChild(_this2.__background);
    return _this2;
  }
  createClass(NumberControllerSlider, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var pct = (this.getValue() - this.__min) / (this.__max - this.__min);
      this.__foreground.style.width = pct * 100 + '%';
      return get(NumberControllerSlider.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerSlider;
}(NumberController);

var FunctionController = function (_Controller) {
  inherits(FunctionController, _Controller);
  function FunctionController(object, property, text) {
    classCallCheck(this, FunctionController);
    var _this2 = possibleConstructorReturn(this, (FunctionController.__proto__ || Object.getPrototypeOf(FunctionController)).call(this, object, property));
    var _this = _this2;
    _this2.__button = document.createElement('div');
    _this2.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(_this2.__button, 'click', function (e) {
      e.preventDefault();
      _this.fire();
      return false;
    });
    dom.addClass(_this2.__button, 'button');
    _this2.domElement.appendChild(_this2.__button);
    return _this2;
  }
  createClass(FunctionController, [{
    key: 'fire',
    value: function fire() {
      if (this.__onChange) {
        this.__onChange.call(this);
      }
      this.getValue().call(this.object);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
    }
  }]);
  return FunctionController;
}(Controller);

var ColorController = function (_Controller) {
  inherits(ColorController, _Controller);
  function ColorController(object, property) {
    classCallCheck(this, ColorController);
    var _this2 = possibleConstructorReturn(this, (ColorController.__proto__ || Object.getPrototypeOf(ColorController)).call(this, object, property));
    _this2.__color = new Color(_this2.getValue());
    _this2.__temp = new Color(0);
    var _this = _this2;
    _this2.domElement = document.createElement('div');
    dom.makeSelectable(_this2.domElement, false);
    _this2.__selector = document.createElement('div');
    _this2.__selector.className = 'selector';
    _this2.__saturation_field = document.createElement('div');
    _this2.__saturation_field.className = 'saturation-field';
    _this2.__field_knob = document.createElement('div');
    _this2.__field_knob.className = 'field-knob';
    _this2.__field_knob_border = '2px solid ';
    _this2.__hue_knob = document.createElement('div');
    _this2.__hue_knob.className = 'hue-knob';
    _this2.__hue_field = document.createElement('div');
    _this2.__hue_field.className = 'hue-field';
    _this2.__input = document.createElement('input');
    _this2.__input.type = 'text';
    _this2.__input_textShadow = '0 1px 1px ';
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        onBlur.call(this);
      }
    });
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__selector, 'mousedown', function ()        {
      dom.addClass(this, 'drag').bind(window, 'mouseup', function ()        {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    dom.bind(_this2.__selector, 'touchstart', function ()        {
      dom.addClass(this, 'drag').bind(window, 'touchend', function ()        {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    var valueField = document.createElement('div');
    Common.extend(_this2.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });
    Common.extend(_this2.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    Common.extend(_this2.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });
    Common.extend(_this2.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });
    Common.extend(valueField.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    linearGradient(valueField, 'top', 'rgba(0,0,0,0)', '#000');
    Common.extend(_this2.__hue_field.style, {
      width: '15px',
      height: '100px',
      border: '1px solid #555',
      cursor: 'ns-resize',
      position: 'absolute',
      top: '3px',
      right: '3px'
    });
    hueGradient(_this2.__hue_field);
    Common.extend(_this2.__input.style, {
      outline: 'none',
      textAlign: 'center',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)'
    });
    dom.bind(_this2.__saturation_field, 'mousedown', fieldDown);
    dom.bind(_this2.__saturation_field, 'touchstart', fieldDown);
    dom.bind(_this2.__field_knob, 'mousedown', fieldDown);
    dom.bind(_this2.__field_knob, 'touchstart', fieldDown);
    dom.bind(_this2.__hue_field, 'mousedown', fieldDownH);
    dom.bind(_this2.__hue_field, 'touchstart', fieldDownH);
    function fieldDown(e) {
      setSV(e);
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'touchmove', setSV);
      dom.bind(window, 'mouseup', fieldUpSV);
      dom.bind(window, 'touchend', fieldUpSV);
    }
    function fieldDownH(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'touchmove', setH);
      dom.bind(window, 'mouseup', fieldUpH);
      dom.bind(window, 'touchend', fieldUpH);
    }
    function fieldUpSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'touchmove', setSV);
      dom.unbind(window, 'mouseup', fieldUpSV);
      dom.unbind(window, 'touchend', fieldUpSV);
      onFinish();
    }
    function fieldUpH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'touchmove', setH);
      dom.unbind(window, 'mouseup', fieldUpH);
      dom.unbind(window, 'touchend', fieldUpH);
      onFinish();
    }
    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.__color.toOriginal());
      }
    }
    _this2.__saturation_field.appendChild(valueField);
    _this2.__selector.appendChild(_this2.__field_knob);
    _this2.__selector.appendChild(_this2.__saturation_field);
    _this2.__selector.appendChild(_this2.__hue_field);
    _this2.__hue_field.appendChild(_this2.__hue_knob);
    _this2.domElement.appendChild(_this2.__input);
    _this2.domElement.appendChild(_this2.__selector);
    _this2.updateDisplay();
    function setSV(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__saturation_field.getBoundingClientRect();
      var _ref = e.touches && e.touches[0] || e,
          clientX = _ref.clientX,
          clientY = _ref.clientY;
      var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);
      var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (v > 1) {
        v = 1;
      } else if (v < 0) {
        v = 0;
      }
      if (s > 1) {
        s = 1;
      } else if (s < 0) {
        s = 0;
      }
      _this.__color.v = v;
      _this.__color.s = s;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    function setH(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__hue_field.getBoundingClientRect();
      var _ref2 = e.touches && e.touches[0] || e,
          clientY = _ref2.clientY;
      var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (h > 1) {
        h = 1;
      } else if (h < 0) {
        h = 0;
      }
      _this.__color.h = h * 360;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    return _this2;
  }
  createClass(ColorController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var i = interpret(this.getValue());
      if (i !== false) {
        var mismatch = false;
        Common.each(Color.COMPONENTS, function (component) {
          if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {
            mismatch = true;
            return {};
          }
        }, this);
        if (mismatch) {
          Common.extend(this.__color.__state, i);
        }
      }
      Common.extend(this.__temp.__state, this.__color.__state);
      this.__temp.a = 1;
      var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;
      var _flip = 255 - flip;
      Common.extend(this.__field_knob.style, {
        marginLeft: 100 * this.__color.s - 7 + 'px',
        marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
        backgroundColor: this.__temp.toHexString(),
        border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'
      });
      this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px';
      this.__temp.s = 1;
      this.__temp.v = 1;
      linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toHexString());
      this.__input.value = this.__color.toString();
      Common.extend(this.__input.style, {
        backgroundColor: this.__color.toHexString(),
        color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',
        textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'
      });
    }
  }]);
  return ColorController;
}(Controller);
var vendors = ['-moz-', '-o-', '-webkit-', '-ms-', ''];
function linearGradient(elem, x, a, b) {
  elem.style.background = '';
  Common.each(vendors, function (vendor) {
    elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';
  });
}
function hueGradient(elem) {
  elem.style.background = '';
  elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';
  elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
}

var css = {
  load: function load(url, indoc) {
    var doc = indoc || document;
    var link = doc.createElement('link');
    link.type = 'text/css';
    link.rel = 'stylesheet';
    link.href = url;
    doc.getElementsByTagName('head')[0].appendChild(link);
  },
  inject: function inject(cssContent, indoc) {
    var doc = indoc || document;
    var injected = document.createElement('style');
    injected.type = 'text/css';
    injected.innerHTML = cssContent;
    var head = doc.getElementsByTagName('head')[0];
    try {
      head.appendChild(injected);
    } catch (e) {
    }
  }
};

var saveDialogContents = "<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>";

var ControllerFactory = function ControllerFactory(object, property) {
  var initialValue = object[property];
  if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {
    return new OptionController(object, property, arguments[2]);
  }
  if (Common.isNumber(initialValue)) {
    if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {
      if (Common.isNumber(arguments[4])) {
        return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);
      }
      return new NumberControllerSlider(object, property, arguments[2], arguments[3]);
    }
    if (Common.isNumber(arguments[4])) {
      return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3], step: arguments[4] });
    }
    return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });
  }
  if (Common.isString(initialValue)) {
    return new StringController(object, property);
  }
  if (Common.isFunction(initialValue)) {
    return new FunctionController(object, property, '');
  }
  if (Common.isBoolean(initialValue)) {
    return new BooleanController(object, property);
  }
  return null;
};

function requestAnimationFrame(callback) {
  setTimeout(callback, 1000 / 60);
}
var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame;

var CenteredDiv = function () {
  function CenteredDiv() {
    classCallCheck(this, CenteredDiv);
    this.backgroundElement = document.createElement('div');
    Common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear',
      transition: 'opacity 0.2s linear'
    });
    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';
    this.domElement = document.createElement('div');
    Common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',
      transition: 'transform 0.2s ease-out, opacity 0.2s linear'
    });
    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);
    var _this = this;
    dom.bind(this.backgroundElement, 'click', function () {
      _this.hide();
    });
  }
  createClass(CenteredDiv, [{
    key: 'show',
    value: function show() {
      var _this = this;
      this.backgroundElement.style.display = 'block';
      this.domElement.style.display = 'block';
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
      this.layout();
      Common.defer(function () {
        _this.backgroundElement.style.opacity = 1;
        _this.domElement.style.opacity = 1;
        _this.domElement.style.webkitTransform = 'scale(1)';
      });
    }
  }, {
    key: 'hide',
    value: function hide() {
      var _this = this;
      var hide = function hide() {
        _this.domElement.style.display = 'none';
        _this.backgroundElement.style.display = 'none';
        dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
        dom.unbind(_this.domElement, 'transitionend', hide);
        dom.unbind(_this.domElement, 'oTransitionEnd', hide);
      };
      dom.bind(this.domElement, 'webkitTransitionEnd', hide);
      dom.bind(this.domElement, 'transitionend', hide);
      dom.bind(this.domElement, 'oTransitionEnd', hide);
      this.backgroundElement.style.opacity = 0;
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
    }
  }, {
    key: 'layout',
    value: function layout() {
      this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + 'px';
      this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + 'px';
    }
  }]);
  return CenteredDiv;
}();

var styleSheet = ___$insertStyle(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");

css.inject(styleSheet);
var CSS_NAMESPACE = 'dg';
var HIDE_KEY_CODE = 72;
var CLOSE_BUTTON_HEIGHT = 20;
var DEFAULT_DEFAULT_PRESET_NAME = 'Default';
var SUPPORTS_LOCAL_STORAGE = function () {
  try {
    return !!window.localStorage;
  } catch (e) {
    return false;
  }
}();
var SAVE_DIALOGUE = void 0;
var autoPlaceVirgin = true;
var autoPlaceContainer = void 0;
var hide = false;
var hideableGuis = [];
var GUI = function GUI(pars) {
  var _this = this;
  var params = pars || {};
  this.domElement = document.createElement('div');
  this.__ul = document.createElement('ul');
  this.domElement.appendChild(this.__ul);
  dom.addClass(this.domElement, CSS_NAMESPACE);
  this.__folders = {};
  this.__controllers = [];
  this.__rememberedObjects = [];
  this.__rememberedObjectIndecesToControllers = [];
  this.__listening = [];
  params = Common.defaults(params, {
    closeOnTop: false,
    autoPlace: true,
    width: GUI.DEFAULT_WIDTH
  });
  params = Common.defaults(params, {
    resizable: params.autoPlace,
    hideable: params.autoPlace
  });
  if (!Common.isUndefined(params.load)) {
    if (params.preset) {
      params.load.preset = params.preset;
    }
  } else {
    params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };
  }
  if (Common.isUndefined(params.parent) && params.hideable) {
    hideableGuis.push(this);
  }
  params.resizable = Common.isUndefined(params.parent) && params.resizable;
  if (params.autoPlace && Common.isUndefined(params.scrollable)) {
    params.scrollable = true;
  }
  var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';
  var saveToLocalStorage = void 0;
  var titleRow = void 0;
  Object.defineProperties(this,
  {
    parent: {
      get: function get$$1() {
        return params.parent;
      }
    },
    scrollable: {
      get: function get$$1() {
        return params.scrollable;
      }
    },
    autoPlace: {
      get: function get$$1() {
        return params.autoPlace;
      }
    },
    closeOnTop: {
      get: function get$$1() {
        return params.closeOnTop;
      }
    },
    preset: {
      get: function get$$1() {
        if (_this.parent) {
          return _this.getRoot().preset;
        }
        return params.load.preset;
      },
      set: function set$$1(v) {
        if (_this.parent) {
          _this.getRoot().preset = v;
        } else {
          params.load.preset = v;
        }
        setPresetSelectIndex(this);
        _this.revert();
      }
    },
    width: {
      get: function get$$1() {
        return params.width;
      },
      set: function set$$1(v) {
        params.width = v;
        setWidth(_this, v);
      }
    },
    name: {
      get: function get$$1() {
        return params.name;
      },
      set: function set$$1(v) {
        params.name = v;
        if (titleRow) {
          titleRow.innerHTML = params.name;
        }
      }
    },
    closed: {
      get: function get$$1() {
        return params.closed;
      },
      set: function set$$1(v) {
        params.closed = v;
        if (params.closed) {
          dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
        } else {
          dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
        }
        this.onResize();
        if (_this.__closeButton) {
          _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
        }
      }
    },
    load: {
      get: function get$$1() {
        return params.load;
      }
    },
    useLocalStorage: {
      get: function get$$1() {
        return useLocalStorage;
      },
      set: function set$$1(bool) {
        if (SUPPORTS_LOCAL_STORAGE) {
          useLocalStorage = bool;
          if (bool) {
            dom.bind(window, 'unload', saveToLocalStorage);
          } else {
            dom.unbind(window, 'unload', saveToLocalStorage);
          }
          localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
        }
      }
    }
  });
  if (Common.isUndefined(params.parent)) {
    this.closed = params.closed || false;
    dom.addClass(this.domElement, GUI.CLASS_MAIN);
    dom.makeSelectable(this.domElement, false);
    if (SUPPORTS_LOCAL_STORAGE) {
      if (useLocalStorage) {
        _this.useLocalStorage = true;
        var savedGui = localStorage.getItem(getLocalStorageHash(this, 'gui'));
        if (savedGui) {
          params.load = JSON.parse(savedGui);
        }
      }
    }
    this.__closeButton = document.createElement('div');
    this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
    dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
    if (params.closeOnTop) {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_TOP);
      this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);
    } else {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BOTTOM);
      this.domElement.appendChild(this.__closeButton);
    }
    dom.bind(this.__closeButton, 'click', function () {
      _this.closed = !_this.closed;
    });
  } else {
    if (params.closed === undefined) {
      params.closed = true;
    }
    var titleRowName = document.createTextNode(params.name);
    dom.addClass(titleRowName, 'controller-name');
    titleRow = addRow(_this, titleRowName);
    var onClickTitle = function onClickTitle(e) {
      e.preventDefault();
      _this.closed = !_this.closed;
      return false;
    };
    dom.addClass(this.__ul, GUI.CLASS_CLOSED);
    dom.addClass(titleRow, 'title');
    dom.bind(titleRow, 'click', onClickTitle);
    if (!params.closed) {
      this.closed = false;
    }
  }
  if (params.autoPlace) {
    if (Common.isUndefined(params.parent)) {
      if (autoPlaceVirgin) {
        autoPlaceContainer = document.createElement('div');
        dom.addClass(autoPlaceContainer, CSS_NAMESPACE);
        dom.addClass(autoPlaceContainer, GUI.CLASS_AUTO_PLACE_CONTAINER);
        document.body.appendChild(autoPlaceContainer);
        autoPlaceVirgin = false;
      }
      autoPlaceContainer.appendChild(this.domElement);
      dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);
    }
    if (!this.parent) {
      setWidth(_this, params.width);
    }
  }
  this.__resizeHandler = function () {
    _this.onResizeDebounced();
  };
  dom.bind(window, 'resize', this.__resizeHandler);
  dom.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler);
  dom.bind(this.__ul, 'transitionend', this.__resizeHandler);
  dom.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler);
  this.onResize();
  if (params.resizable) {
    addResizeHandle(this);
  }
  saveToLocalStorage = function saveToLocalStorage() {
    if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true') {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }
  };
  this.saveToLocalStorageIfPossible = saveToLocalStorage;
  function resetWidth() {
    var root = _this.getRoot();
    root.width += 1;
    Common.defer(function () {
      root.width -= 1;
    });
  }
  if (!params.parent) {
    resetWidth();
  }
};
GUI.toggleHide = function () {
  hide = !hide;
  Common.each(hideableGuis, function (gui) {
    gui.domElement.style.display = hide ? 'none' : '';
  });
};
GUI.CLASS_AUTO_PLACE = 'a';
GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
GUI.CLASS_MAIN = 'main';
GUI.CLASS_CONTROLLER_ROW = 'cr';
GUI.CLASS_TOO_TALL = 'taller-than-window';
GUI.CLASS_CLOSED = 'closed';
GUI.CLASS_CLOSE_BUTTON = 'close-button';
GUI.CLASS_CLOSE_TOP = 'close-top';
GUI.CLASS_CLOSE_BOTTOM = 'close-bottom';
GUI.CLASS_DRAG = 'drag';
GUI.DEFAULT_WIDTH = 245;
GUI.TEXT_CLOSED = 'Close Controls';
GUI.TEXT_OPEN = 'Open Controls';
GUI._keydownHandler = function (e) {
  if (document.activeElement.type !== 'text' && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {
    GUI.toggleHide();
  }
};
dom.bind(window, 'keydown', GUI._keydownHandler, false);
Common.extend(GUI.prototype,
{
  add: function add(object, property) {
    return _add(this, object, property, {
      factoryArgs: Array.prototype.slice.call(arguments, 2)
    });
  },
  addColor: function addColor(object, property) {
    return _add(this, object, property, {
      color: true
    });
  },
  remove: function remove(controller) {
    this.__ul.removeChild(controller.__li);
    this.__controllers.splice(this.__controllers.indexOf(controller), 1);
    var _this = this;
    Common.defer(function () {
      _this.onResize();
    });
  },
  destroy: function destroy() {
    if (this.parent) {
      throw new Error('Only the root GUI should be removed with .destroy(). ' + 'For subfolders, use gui.removeFolder(folder) instead.');
    }
    if (this.autoPlace) {
      autoPlaceContainer.removeChild(this.domElement);
    }
    var _this = this;
    Common.each(this.__folders, function (subfolder) {
      _this.removeFolder(subfolder);
    });
    dom.unbind(window, 'keydown', GUI._keydownHandler, false);
    removeListeners(this);
  },
  addFolder: function addFolder(name) {
    if (this.__folders[name] !== undefined) {
      throw new Error('You already have a folder in this GUI by the' + ' name "' + name + '"');
    }
    var newGuiParams = { name: name, parent: this };
    newGuiParams.autoPlace = this.autoPlace;
    if (this.load &&
    this.load.folders &&
    this.load.folders[name]) {
      newGuiParams.closed = this.load.folders[name].closed;
      newGuiParams.load = this.load.folders[name];
    }
    var gui = new GUI(newGuiParams);
    this.__folders[name] = gui;
    var li = addRow(this, gui.domElement);
    dom.addClass(li, 'folder');
    return gui;
  },
  removeFolder: function removeFolder(folder) {
    this.__ul.removeChild(folder.domElement.parentElement);
    delete this.__folders[folder.name];
    if (this.load &&
    this.load.folders &&
    this.load.folders[folder.name]) {
      delete this.load.folders[folder.name];
    }
    removeListeners(folder);
    var _this = this;
    Common.each(folder.__folders, function (subfolder) {
      folder.removeFolder(subfolder);
    });
    Common.defer(function () {
      _this.onResize();
    });
  },
  open: function open() {
    this.closed = false;
  },
  close: function close() {
    this.closed = true;
  },
  hide: function hide() {
    this.domElement.style.display = 'none';
  },
  show: function show() {
    this.domElement.style.display = '';
  },
  onResize: function onResize() {
    var root = this.getRoot();
    if (root.scrollable) {
      var top = dom.getOffset(root.__ul).top;
      var h = 0;
      Common.each(root.__ul.childNodes, function (node) {
        if (!(root.autoPlace && node === root.__save_row)) {
          h += dom.getHeight(node);
        }
      });
      if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
        dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
      } else {
        dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = 'auto';
      }
    }
    if (root.__resize_handle) {
      Common.defer(function () {
        root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
      });
    }
    if (root.__closeButton) {
      root.__closeButton.style.width = root.width + 'px';
    }
  },
  onResizeDebounced: Common.debounce(function () {
    this.onResize();
  }, 50),
  remember: function remember() {
    if (Common.isUndefined(SAVE_DIALOGUE)) {
      SAVE_DIALOGUE = new CenteredDiv();
      SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;
    }
    if (this.parent) {
      throw new Error('You can only call remember on a top level GUI.');
    }
    var _this = this;
    Common.each(Array.prototype.slice.call(arguments), function (object) {
      if (_this.__rememberedObjects.length === 0) {
        addSaveMenu(_this);
      }
      if (_this.__rememberedObjects.indexOf(object) === -1) {
        _this.__rememberedObjects.push(object);
      }
    });
    if (this.autoPlace) {
      setWidth(this, this.width);
    }
  },
  getRoot: function getRoot() {
    var gui = this;
    while (gui.parent) {
      gui = gui.parent;
    }
    return gui;
  },
  getSaveObject: function getSaveObject() {
    var toReturn = this.load;
    toReturn.closed = this.closed;
    if (this.__rememberedObjects.length > 0) {
      toReturn.preset = this.preset;
      if (!toReturn.remembered) {
        toReturn.remembered = {};
      }
      toReturn.remembered[this.preset] = getCurrentPreset(this);
    }
    toReturn.folders = {};
    Common.each(this.__folders, function (element, key) {
      toReturn.folders[key] = element.getSaveObject();
    });
    return toReturn;
  },
  save: function save() {
    if (!this.load.remembered) {
      this.load.remembered = {};
    }
    this.load.remembered[this.preset] = getCurrentPreset(this);
    markPresetModified(this, false);
    this.saveToLocalStorageIfPossible();
  },
  saveAs: function saveAs(presetName) {
    if (!this.load.remembered) {
      this.load.remembered = {};
      this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);
    }
    this.load.remembered[presetName] = getCurrentPreset(this);
    this.preset = presetName;
    addPresetOption(this, presetName, true);
    this.saveToLocalStorageIfPossible();
  },
  revert: function revert(gui) {
    Common.each(this.__controllers, function (controller) {
      if (!this.getRoot().load.remembered) {
        controller.setValue(controller.initialValue);
      } else {
        recallSavedValue(gui || this.getRoot(), controller);
      }
      if (controller.__onFinishChange) {
        controller.__onFinishChange.call(controller, controller.getValue());
      }
    }, this);
    Common.each(this.__folders, function (folder) {
      folder.revert(folder);
    });
    if (!gui) {
      markPresetModified(this.getRoot(), false);
    }
  },
  listen: function listen(controller) {
    var init = this.__listening.length === 0;
    this.__listening.push(controller);
    if (init) {
      updateDisplays(this.__listening);
    }
  },
  updateDisplay: function updateDisplay() {
    Common.each(this.__controllers, function (controller) {
      controller.updateDisplay();
    });
    Common.each(this.__folders, function (folder) {
      folder.updateDisplay();
    });
  }
});
function addRow(gui, newDom, liBefore) {
  var li = document.createElement('li');
  if (newDom) {
    li.appendChild(newDom);
  }
  if (liBefore) {
    gui.__ul.insertBefore(li, liBefore);
  } else {
    gui.__ul.appendChild(li);
  }
  gui.onResize();
  return li;
}
function removeListeners(gui) {
  dom.unbind(window, 'resize', gui.__resizeHandler);
  if (gui.saveToLocalStorageIfPossible) {
    dom.unbind(window, 'unload', gui.saveToLocalStorageIfPossible);
  }
}
function markPresetModified(gui, modified) {
  var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
  if (modified) {
    opt.innerHTML = opt.value + '*';
  } else {
    opt.innerHTML = opt.value;
  }
}
function augmentController(gui, li, controller) {
  controller.__li = li;
  controller.__gui = gui;
  Common.extend(controller,                                   {
    options: function options(_options) {
      if (arguments.length > 1) {
        var nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: nextSibling,
          factoryArgs: [Common.toArray(arguments)]
        });
      }
      if (Common.isArray(_options) || Common.isObject(_options)) {
        var _nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: _nextSibling,
          factoryArgs: [_options]
        });
      }
    },
    name: function name(_name) {
      controller.__li.firstElementChild.firstElementChild.innerHTML = _name;
      return controller;
    },
    listen: function listen() {
      controller.__gui.listen(controller);
      return controller;
    },
    remove: function remove() {
      controller.__gui.remove(controller);
      return controller;
    }
  });
  if (controller instanceof NumberControllerSlider) {
    var box = new NumberControllerBox(controller.object, controller.property, { min: controller.__min, max: controller.__max, step: controller.__step });
    Common.each(['updateDisplay', 'onChange', 'onFinishChange', 'step', 'min', 'max'], function (method) {
      var pc = controller[method];
      var pb = box[method];
      controller[method] = box[method] = function () {
        var args = Array.prototype.slice.call(arguments);
        pb.apply(box, args);
        return pc.apply(controller, args);
      };
    });
    dom.addClass(li, 'has-slider');
    controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);
  } else if (controller instanceof NumberControllerBox) {
    var r = function r(returned) {
      if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {
        var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;
        var wasListening = controller.__gui.__listening.indexOf(controller) > -1;
        controller.remove();
        var newController = _add(gui, controller.object, controller.property, {
          before: controller.__li.nextElementSibling,
          factoryArgs: [controller.__min, controller.__max, controller.__step]
        });
        newController.name(oldName);
        if (wasListening) newController.listen();
        return newController;
      }
      return returned;
    };
    controller.min = Common.compose(r, controller.min);
    controller.max = Common.compose(r, controller.max);
  } else if (controller instanceof BooleanController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__checkbox, 'click');
    });
    dom.bind(controller.__checkbox, 'click', function (e) {
      e.stopPropagation();
    });
  } else if (controller instanceof FunctionController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__button, 'click');
    });
    dom.bind(li, 'mouseover', function () {
      dom.addClass(controller.__button, 'hover');
    });
    dom.bind(li, 'mouseout', function () {
      dom.removeClass(controller.__button, 'hover');
    });
  } else if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
    controller.updateDisplay = Common.compose(function (val) {
      li.style.borderLeftColor = controller.__color.toString();
      return val;
    }, controller.updateDisplay);
    controller.updateDisplay();
  }
  controller.setValue = Common.compose(function (val) {
    if (gui.getRoot().__preset_select && controller.isModified()) {
      markPresetModified(gui.getRoot(), true);
    }
    return val;
  }, controller.setValue);
}
function recallSavedValue(gui, controller) {
  var root = gui.getRoot();
  var matchedIndex = root.__rememberedObjects.indexOf(controller.object);
  if (matchedIndex !== -1) {
    var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];
    if (controllerMap === undefined) {
      controllerMap = {};
      root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;
    }
    controllerMap[controller.property] = controller;
    if (root.load && root.load.remembered) {
      var presetMap = root.load.remembered;
      var preset = void 0;
      if (presetMap[gui.preset]) {
        preset = presetMap[gui.preset];
      } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {
        preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];
      } else {
        return;
      }
      if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== undefined) {
        var value = preset[matchedIndex][controller.property];
        controller.initialValue = value;
        controller.setValue(value);
      }
    }
  }
}
function _add(gui, object, property, params) {
  if (object[property] === undefined) {
    throw new Error('Object "' + object + '" has no property "' + property + '"');
  }
  var controller = void 0;
  if (params.color) {
    controller = new ColorController(object, property);
  } else {
    var factoryArgs = [object, property].concat(params.factoryArgs);
    controller = ControllerFactory.apply(gui, factoryArgs);
  }
  if (params.before instanceof Controller) {
    params.before = params.before.__li;
  }
  recallSavedValue(gui, controller);
  dom.addClass(controller.domElement, 'c');
  var name = document.createElement('span');
  dom.addClass(name, 'property-name');
  name.innerHTML = controller.property;
  var container = document.createElement('div');
  container.appendChild(name);
  container.appendChild(controller.domElement);
  var li = addRow(gui, container, params.before);
  dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
  if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
  } else {
    dom.addClass(li, _typeof(controller.getValue()));
  }
  augmentController(gui, li, controller);
  gui.__controllers.push(controller);
  return controller;
}
function getLocalStorageHash(gui, key) {
  return document.location.href + '.' + key;
}
function addPresetOption(gui, name, setSelected) {
  var opt = document.createElement('option');
  opt.innerHTML = name;
  opt.value = name;
  gui.__preset_select.appendChild(opt);
  if (setSelected) {
    gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
  }
}
function showHideExplain(gui, explain) {
  explain.style.display = gui.useLocalStorage ? 'block' : 'none';
}
function addSaveMenu(gui) {
  var div = gui.__save_row = document.createElement('li');
  dom.addClass(gui.domElement, 'has-save');
  gui.__ul.insertBefore(div, gui.__ul.firstChild);
  dom.addClass(div, 'save-row');
  var gears = document.createElement('span');
  gears.innerHTML = '&nbsp;';
  dom.addClass(gears, 'button gears');
  var button = document.createElement('span');
  button.innerHTML = 'Save';
  dom.addClass(button, 'button');
  dom.addClass(button, 'save');
  var button2 = document.createElement('span');
  button2.innerHTML = 'New';
  dom.addClass(button2, 'button');
  dom.addClass(button2, 'save-as');
  var button3 = document.createElement('span');
  button3.innerHTML = 'Revert';
  dom.addClass(button3, 'button');
  dom.addClass(button3, 'revert');
  var select = gui.__preset_select = document.createElement('select');
  if (gui.load && gui.load.remembered) {
    Common.each(gui.load.remembered, function (value, key) {
      addPresetOption(gui, key, key === gui.preset);
    });
  } else {
    addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
  }
  dom.bind(select, 'change', function () {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
    }
    gui.preset = this.value;
  });
  div.appendChild(select);
  div.appendChild(gears);
  div.appendChild(button);
  div.appendChild(button2);
  div.appendChild(button3);
  if (SUPPORTS_LOCAL_STORAGE) {
    var explain = document.getElementById('dg-local-explain');
    var localStorageCheckBox = document.getElementById('dg-local-storage');
    var saveLocally = document.getElementById('dg-save-locally');
    saveLocally.style.display = 'block';
    if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
      localStorageCheckBox.setAttribute('checked', 'checked');
    }
    showHideExplain(gui, explain);
    dom.bind(localStorageCheckBox, 'change', function () {
      gui.useLocalStorage = !gui.useLocalStorage;
      showHideExplain(gui, explain);
    });
  }
  var newConstructorTextArea = document.getElementById('dg-new-constructor');
  dom.bind(newConstructorTextArea, 'keydown', function (e) {
    if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {
      SAVE_DIALOGUE.hide();
    }
  });
  dom.bind(gears, 'click', function () {
    newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
    SAVE_DIALOGUE.show();
    newConstructorTextArea.focus();
    newConstructorTextArea.select();
  });
  dom.bind(button, 'click', function () {
    gui.save();
  });
  dom.bind(button2, 'click', function () {
    var presetName = prompt('Enter a new preset name.');
    if (presetName) {
      gui.saveAs(presetName);
    }
  });
  dom.bind(button3, 'click', function () {
    gui.revert();
  });
}
function addResizeHandle(gui) {
  var pmouseX = void 0;
  gui.__resize_handle = document.createElement('div');
  Common.extend(gui.__resize_handle.style, {
    width: '6px',
    marginLeft: '-3px',
    height: '200px',
    cursor: 'ew-resize',
    position: 'absolute'
  });
  function drag(e) {
    e.preventDefault();
    gui.width += pmouseX - e.clientX;
    gui.onResize();
    pmouseX = e.clientX;
    return false;
  }
  function dragStop() {
    dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.unbind(window, 'mousemove', drag);
    dom.unbind(window, 'mouseup', dragStop);
  }
  function dragStart(e) {
    e.preventDefault();
    pmouseX = e.clientX;
    dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.bind(window, 'mousemove', drag);
    dom.bind(window, 'mouseup', dragStop);
    return false;
  }
  dom.bind(gui.__resize_handle, 'mousedown', dragStart);
  dom.bind(gui.__closeButton, 'mousedown', dragStart);
  gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);
}
function setWidth(gui, w) {
  gui.domElement.style.width = w + 'px';
  if (gui.__save_row && gui.autoPlace) {
    gui.__save_row.style.width = w + 'px';
  }
  if (gui.__closeButton) {
    gui.__closeButton.style.width = w + 'px';
  }
}
function getCurrentPreset(gui, useInitialValues) {
  var toReturn = {};
  Common.each(gui.__rememberedObjects, function (val, index) {
    var savedValues = {};
    var controllerMap = gui.__rememberedObjectIndecesToControllers[index];
    Common.each(controllerMap, function (controller, property) {
      savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();
    });
    toReturn[index] = savedValues;
  });
  return toReturn;
}
function setPresetSelectIndex(gui) {
  for (var index = 0; index < gui.__preset_select.length; index++) {
    if (gui.__preset_select[index].value === gui.preset) {
      gui.__preset_select.selectedIndex = index;
    }
  }
}
function updateDisplays(controllerArray) {
  if (controllerArray.length !== 0) {
    requestAnimationFrame$1.call(window, function () {
      updateDisplays(controllerArray);
    });
  }
  Common.each(controllerArray, function (c) {
    c.updateDisplay();
  });
}

var color = {
  Color: Color,
  math: ColorMath,
  interpret: interpret
};
var controllers = {
  Controller: Controller,
  BooleanController: BooleanController,
  OptionController: OptionController,
  StringController: StringController,
  NumberController: NumberController,
  NumberControllerBox: NumberControllerBox,
  NumberControllerSlider: NumberControllerSlider,
  FunctionController: FunctionController,
  ColorController: ColorController
};
var dom$1 = { dom: dom };
var gui = { GUI: GUI };
var GUI$1 = GUI;
var index = {
  color: color,
  controllers: controllers,
  dom: dom$1,
  gui: gui,
  GUI: GUI$1
};

exports.color = color;
exports.controllers = controllers;
exports.dom = dom$1;
exports.gui = gui;
exports.GUI = GUI$1;
exports['default'] = index;

Object.defineProperty(exports, '__esModule', { value: true });

})));


},{}],21:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}

},{}],22:[function(require,module,exports){
/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.THREE = {}));
})(this, (function (exports) { 'use strict';

	const REVISION = '135';
	const MOUSE = {
		LEFT: 0,
		MIDDLE: 1,
		RIGHT: 2,
		ROTATE: 0,
		DOLLY: 1,
		PAN: 2
	};
	const TOUCH = {
		ROTATE: 0,
		PAN: 1,
		DOLLY_PAN: 2,
		DOLLY_ROTATE: 3
	};
	const CullFaceNone = 0;
	const CullFaceBack = 1;
	const CullFaceFront = 2;
	const CullFaceFrontBack = 3;
	const BasicShadowMap = 0;
	const PCFShadowMap = 1;
	const PCFSoftShadowMap = 2;
	const VSMShadowMap = 3;
	const FrontSide = 0;
	const BackSide = 1;
	const DoubleSide = 2;
	const FlatShading = 1;
	const SmoothShading = 2;
	const NoBlending = 0;
	const NormalBlending = 1;
	const AdditiveBlending = 2;
	const SubtractiveBlending = 3;
	const MultiplyBlending = 4;
	const CustomBlending = 5;
	const AddEquation = 100;
	const SubtractEquation = 101;
	const ReverseSubtractEquation = 102;
	const MinEquation = 103;
	const MaxEquation = 104;
	const ZeroFactor = 200;
	const OneFactor = 201;
	const SrcColorFactor = 202;
	const OneMinusSrcColorFactor = 203;
	const SrcAlphaFactor = 204;
	const OneMinusSrcAlphaFactor = 205;
	const DstAlphaFactor = 206;
	const OneMinusDstAlphaFactor = 207;
	const DstColorFactor = 208;
	const OneMinusDstColorFactor = 209;
	const SrcAlphaSaturateFactor = 210;
	const NeverDepth = 0;
	const AlwaysDepth = 1;
	const LessDepth = 2;
	const LessEqualDepth = 3;
	const EqualDepth = 4;
	const GreaterEqualDepth = 5;
	const GreaterDepth = 6;
	const NotEqualDepth = 7;
	const MultiplyOperation = 0;
	const MixOperation = 1;
	const AddOperation = 2;
	const NoToneMapping = 0;
	const LinearToneMapping = 1;
	const ReinhardToneMapping = 2;
	const CineonToneMapping = 3;
	const ACESFilmicToneMapping = 4;
	const CustomToneMapping = 5;
	const UVMapping = 300;
	const CubeReflectionMapping = 301;
	const CubeRefractionMapping = 302;
	const EquirectangularReflectionMapping = 303;
	const EquirectangularRefractionMapping = 304;
	const CubeUVReflectionMapping = 306;
	const CubeUVRefractionMapping = 307;
	const RepeatWrapping = 1000;
	const ClampToEdgeWrapping = 1001;
	const MirroredRepeatWrapping = 1002;
	const NearestFilter = 1003;
	const NearestMipmapNearestFilter = 1004;
	const NearestMipMapNearestFilter = 1004;
	const NearestMipmapLinearFilter = 1005;
	const NearestMipMapLinearFilter = 1005;
	const LinearFilter = 1006;
	const LinearMipmapNearestFilter = 1007;
	const LinearMipMapNearestFilter = 1007;
	const LinearMipmapLinearFilter = 1008;
	const LinearMipMapLinearFilter = 1008;
	const UnsignedByteType = 1009;
	const ByteType = 1010;
	const ShortType = 1011;
	const UnsignedShortType = 1012;
	const IntType = 1013;
	const UnsignedIntType = 1014;
	const FloatType = 1015;
	const HalfFloatType = 1016;
	const UnsignedShort4444Type = 1017;
	const UnsignedShort5551Type = 1018;
	const UnsignedShort565Type = 1019;
	const UnsignedInt248Type = 1020;
	const AlphaFormat = 1021;
	const RGBFormat = 1022;
	const RGBAFormat = 1023;
	const LuminanceFormat = 1024;
	const LuminanceAlphaFormat = 1025;
	const RGBEFormat = RGBAFormat;
	const DepthFormat = 1026;
	const DepthStencilFormat = 1027;
	const RedFormat = 1028;
	const RedIntegerFormat = 1029;
	const RGFormat = 1030;
	const RGIntegerFormat = 1031;
	const RGBIntegerFormat = 1032;
	const RGBAIntegerFormat = 1033;
	const RGB_S3TC_DXT1_Format = 33776;
	const RGBA_S3TC_DXT1_Format = 33777;
	const RGBA_S3TC_DXT3_Format = 33778;
	const RGBA_S3TC_DXT5_Format = 33779;
	const RGB_PVRTC_4BPPV1_Format = 35840;
	const RGB_PVRTC_2BPPV1_Format = 35841;
	const RGBA_PVRTC_4BPPV1_Format = 35842;
	const RGBA_PVRTC_2BPPV1_Format = 35843;
	const RGB_ETC1_Format = 36196;
	const RGB_ETC2_Format = 37492;
	const RGBA_ETC2_EAC_Format = 37496;
	const RGBA_ASTC_4x4_Format = 37808;
	const RGBA_ASTC_5x4_Format = 37809;
	const RGBA_ASTC_5x5_Format = 37810;
	const RGBA_ASTC_6x5_Format = 37811;
	const RGBA_ASTC_6x6_Format = 37812;
	const RGBA_ASTC_8x5_Format = 37813;
	const RGBA_ASTC_8x6_Format = 37814;
	const RGBA_ASTC_8x8_Format = 37815;
	const RGBA_ASTC_10x5_Format = 37816;
	const RGBA_ASTC_10x6_Format = 37817;
	const RGBA_ASTC_10x8_Format = 37818;
	const RGBA_ASTC_10x10_Format = 37819;
	const RGBA_ASTC_12x10_Format = 37820;
	const RGBA_ASTC_12x12_Format = 37821;
	const RGBA_BPTC_Format = 36492;
	const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
	const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
	const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
	const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
	const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
	const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
	const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
	const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
	const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
	const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
	const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
	const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
	const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
	const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
	const LoopOnce = 2200;
	const LoopRepeat = 2201;
	const LoopPingPong = 2202;
	const InterpolateDiscrete = 2300;
	const InterpolateLinear = 2301;
	const InterpolateSmooth = 2302;
	const ZeroCurvatureEnding = 2400;
	const ZeroSlopeEnding = 2401;
	const WrapAroundEnding = 2402;
	const NormalAnimationBlendMode = 2500;
	const AdditiveAnimationBlendMode = 2501;
	const TrianglesDrawMode = 0;
	const TriangleStripDrawMode = 1;
	const TriangleFanDrawMode = 2;
	const LinearEncoding = 3000;
	const sRGBEncoding = 3001;
	const GammaEncoding = 3007;
	const RGBEEncoding = 3002;
	const RGBM7Encoding = 3004;
	const RGBM16Encoding = 3005;
	const RGBDEncoding = 3006;
	const BasicDepthPacking = 3200;
	const RGBADepthPacking = 3201;
	const TangentSpaceNormalMap = 0;
	const ObjectSpaceNormalMap = 1;
	const ZeroStencilOp = 0;
	const KeepStencilOp = 7680;
	const ReplaceStencilOp = 7681;
	const IncrementStencilOp = 7682;
	const DecrementStencilOp = 7683;
	const IncrementWrapStencilOp = 34055;
	const DecrementWrapStencilOp = 34056;
	const InvertStencilOp = 5386;
	const NeverStencilFunc = 512;
	const LessStencilFunc = 513;
	const EqualStencilFunc = 514;
	const LessEqualStencilFunc = 515;
	const GreaterStencilFunc = 516;
	const NotEqualStencilFunc = 517;
	const GreaterEqualStencilFunc = 518;
	const AlwaysStencilFunc = 519;
	const StaticDrawUsage = 35044;
	const DynamicDrawUsage = 35048;
	const StreamDrawUsage = 35040;
	const StaticReadUsage = 35045;
	const DynamicReadUsage = 35049;
	const StreamReadUsage = 35041;
	const StaticCopyUsage = 35046;
	const DynamicCopyUsage = 35050;
	const StreamCopyUsage = 35042;
	const GLSL1 = '100';
	const GLSL3 = '300 es';

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */
	class EventDispatcher {
		addEventListener(type, listener) {
			if (this._listeners === undefined) this._listeners = {};
			const listeners = this._listeners;

			if (listeners[type] === undefined) {
				listeners[type] = [];
			}

			if (listeners[type].indexOf(listener) === -1) {
				listeners[type].push(listener);
			}
		}

		hasEventListener(type, listener) {
			if (this._listeners === undefined) return false;
			const listeners = this._listeners;
			return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
		}

		removeEventListener(type, listener) {
			if (this._listeners === undefined) return;
			const listeners = this._listeners;
			const listenerArray = listeners[type];

			if (listenerArray !== undefined) {
				const index = listenerArray.indexOf(listener);

				if (index !== -1) {
					listenerArray.splice(index, 1);
				}
			}
		}

		dispatchEvent(event) {
			if (this._listeners === undefined) return;
			const listeners = this._listeners;
			const listenerArray = listeners[event.type];

			if (listenerArray !== undefined) {
				event.target = this; // Make a copy, in case listeners are removed while iterating.

				const array = listenerArray.slice(0);

				for (let i = 0, l = array.length; i < l; i++) {
					array[i].call(this, event);
				}

				event.target = null;
			}
		}

	}

	const _lut = [];

	for (let i = 0; i < 256; i++) {
		_lut[i] = (i < 16 ? '0' : '') + i.toString(16);
	}

	let _seed = 1234567;
	const DEG2RAD = Math.PI / 180;
	const RAD2DEG = 180 / Math.PI; // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

	function generateUUID() {
		const d0 = Math.random() * 0xffffffff | 0;
		const d1 = Math.random() * 0xffffffff | 0;
		const d2 = Math.random() * 0xffffffff | 0;
		const d3 = Math.random() * 0xffffffff | 0;
		const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toUpperCase() here flattens concatenated strings to save heap memory space.

		return uuid.toUpperCase();
	}

	function clamp(value, min, max) {
		return Math.max(min, Math.min(max, value));
	} // compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation


	function euclideanModulo(n, m) {
		return (n % m + m) % m;
	} // Linear mapping from range <a1, a2> to range <b1, b2>


	function mapLinear(x, a1, a2, b1, b2) {
		return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
	} // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/


	function inverseLerp(x, y, value) {
		if (x !== y) {
			return (value - x) / (y - x);
		} else {
			return 0;
		}
	} // https://en.wikipedia.org/wiki/Linear_interpolation


	function lerp(x, y, t) {
		return (1 - t) * x + t * y;
	} // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/


	function damp(x, y, lambda, dt) {
		return lerp(x, y, 1 - Math.exp(-lambda * dt));
	} // https://www.desmos.com/calculator/vcsjnyz7x4


	function pingpong(x, length = 1) {
		return length - Math.abs(euclideanModulo(x, length * 2) - length);
	} // http://en.wikipedia.org/wiki/Smoothstep


	function smoothstep(x, min, max) {
		if (x <= min) return 0;
		if (x >= max) return 1;
		x = (x - min) / (max - min);
		return x * x * (3 - 2 * x);
	}

	function smootherstep(x, min, max) {
		if (x <= min) return 0;
		if (x >= max) return 1;
		x = (x - min) / (max - min);
		return x * x * x * (x * (x * 6 - 15) + 10);
	} // Random integer from <low, high> interval


	function randInt(low, high) {
		return low + Math.floor(Math.random() * (high - low + 1));
	} // Random float from <low, high> interval


	function randFloat(low, high) {
		return low + Math.random() * (high - low);
	} // Random float from <-range/2, range/2> interval


	function randFloatSpread(range) {
		return range * (0.5 - Math.random());
	} // Deterministic pseudo-random float in the interval [ 0, 1 ]


	function seededRandom(s) {
		if (s !== undefined) _seed = s % 2147483647; // Park-Miller algorithm

		_seed = _seed * 16807 % 2147483647;
		return (_seed - 1) / 2147483646;
	}

	function degToRad(degrees) {
		return degrees * DEG2RAD;
	}

	function radToDeg(radians) {
		return radians * RAD2DEG;
	}

	function isPowerOfTwo(value) {
		return (value & value - 1) === 0 && value !== 0;
	}

	function ceilPowerOfTwo(value) {
		return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
	}

	function floorPowerOfTwo(value) {
		return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
	}

	function setQuaternionFromProperEuler(q, a, b, c, order) {
		// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
		// rotations are applied to the axes in the order specified by 'order'
		// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
		// angles are in radians
		const cos = Math.cos;
		const sin = Math.sin;
		const c2 = cos(b / 2);
		const s2 = sin(b / 2);
		const c13 = cos((a + c) / 2);
		const s13 = sin((a + c) / 2);
		const c1_3 = cos((a - c) / 2);
		const s1_3 = sin((a - c) / 2);
		const c3_1 = cos((c - a) / 2);
		const s3_1 = sin((c - a) / 2);

		switch (order) {
			case 'XYX':
				q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
				break;

			case 'YZY':
				q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
				break;

			case 'ZXZ':
				q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
				break;

			case 'XZX':
				q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
				break;

			case 'YXY':
				q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
				break;

			case 'ZYZ':
				q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
				break;

			default:
				console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
		}
	}

	var MathUtils = /*#__PURE__*/Object.freeze({
		__proto__: null,
		DEG2RAD: DEG2RAD,
		RAD2DEG: RAD2DEG,
		generateUUID: generateUUID,
		clamp: clamp,
		euclideanModulo: euclideanModulo,
		mapLinear: mapLinear,
		inverseLerp: inverseLerp,
		lerp: lerp,
		damp: damp,
		pingpong: pingpong,
		smoothstep: smoothstep,
		smootherstep: smootherstep,
		randInt: randInt,
		randFloat: randFloat,
		randFloatSpread: randFloatSpread,
		seededRandom: seededRandom,
		degToRad: degToRad,
		radToDeg: radToDeg,
		isPowerOfTwo: isPowerOfTwo,
		ceilPowerOfTwo: ceilPowerOfTwo,
		floorPowerOfTwo: floorPowerOfTwo,
		setQuaternionFromProperEuler: setQuaternionFromProperEuler
	});

	class Vector2 {
		constructor(x = 0, y = 0) {
			this.x = x;
			this.y = y;
		}

		get width() {
			return this.x;
		}

		set width(value) {
			this.x = value;
		}

		get height() {
			return this.y;
		}

		set height(value) {
			this.y = value;
		}

		set(x, y) {
			this.x = x;
			this.y = y;
			return this;
		}

		setScalar(scalar) {
			this.x = scalar;
			this.y = scalar;
			return this;
		}

		setX(x) {
			this.x = x;
			return this;
		}

		setY(y) {
			this.y = y;
			return this;
		}

		setComponent(index, value) {
			switch (index) {
				case 0:
					this.x = value;
					break;

				case 1:
					this.y = value;
					break;

				default:
					throw new Error('index is out of range: ' + index);
			}

			return this;
		}

		getComponent(index) {
			switch (index) {
				case 0:
					return this.x;

				case 1:
					return this.y;

				default:
					throw new Error('index is out of range: ' + index);
			}
		}

		clone() {
			return new this.constructor(this.x, this.y);
		}

		copy(v) {
			this.x = v.x;
			this.y = v.y;
			return this;
		}

		add(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
				return this.addVectors(v, w);
			}

			this.x += v.x;
			this.y += v.y;
			return this;
		}

		addScalar(s) {
			this.x += s;
			this.y += s;
			return this;
		}

		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			return this;
		}

		addScaledVector(v, s) {
			this.x += v.x * s;
			this.y += v.y * s;
			return this;
		}

		sub(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
				return this.subVectors(v, w);
			}

			this.x -= v.x;
			this.y -= v.y;
			return this;
		}

		subScalar(s) {
			this.x -= s;
			this.y -= s;
			return this;
		}

		subVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			return this;
		}

		multiply(v) {
			this.x *= v.x;
			this.y *= v.y;
			return this;
		}

		multiplyScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			return this;
		}

		divide(v) {
			this.x /= v.x;
			this.y /= v.y;
			return this;
		}

		divideScalar(scalar) {
			return this.multiplyScalar(1 / scalar);
		}

		applyMatrix3(m) {
			const x = this.x,
						y = this.y;
			const e = m.elements;
			this.x = e[0] * x + e[3] * y + e[6];
			this.y = e[1] * x + e[4] * y + e[7];
			return this;
		}

		min(v) {
			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			return this;
		}

		max(v) {
			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			return this;
		}

		clamp(min, max) {
			// assumes min < max, componentwise
			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			return this;
		}

		clampScalar(minVal, maxVal) {
			this.x = Math.max(minVal, Math.min(maxVal, this.x));
			this.y = Math.max(minVal, Math.min(maxVal, this.y));
			return this;
		}

		clampLength(min, max) {
			const length = this.length();
			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		}

		floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			return this;
		}

		ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			return this;
		}

		round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			return this;
		}

		roundToZero() {
			this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
			return this;
		}

		negate() {
			this.x = -this.x;
			this.y = -this.y;
			return this;
		}

		dot(v) {
			return this.x * v.x + this.y * v.y;
		}

		cross(v) {
			return this.x * v.y - this.y * v.x;
		}

		lengthSq() {
			return this.x * this.x + this.y * this.y;
		}

		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		}

		manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y);
		}

		normalize() {
			return this.divideScalar(this.length() || 1);
		}

		angle() {
			// computes the angle in radians with respect to the positive x-axis
			const angle = Math.atan2(-this.y, -this.x) + Math.PI;
			return angle;
		}

		distanceTo(v) {
			return Math.sqrt(this.distanceToSquared(v));
		}

		distanceToSquared(v) {
			const dx = this.x - v.x,
						dy = this.y - v.y;
			return dx * dx + dy * dy;
		}

		manhattanDistanceTo(v) {
			return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
		}

		setLength(length) {
			return this.normalize().multiplyScalar(length);
		}

		lerp(v, alpha) {
			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			return this;
		}

		lerpVectors(v1, v2, alpha) {
			this.x = v1.x + (v2.x - v1.x) * alpha;
			this.y = v1.y + (v2.y - v1.y) * alpha;
			return this;
		}

		equals(v) {
			return v.x === this.x && v.y === this.y;
		}

		fromArray(array, offset = 0) {
			this.x = array[offset];
			this.y = array[offset + 1];
			return this;
		}

		toArray(array = [], offset = 0) {
			array[offset] = this.x;
			array[offset + 1] = this.y;
			return array;
		}

		fromBufferAttribute(attribute, index, offset) {
			if (offset !== undefined) {
				console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
			}

			this.x = attribute.getX(index);
			this.y = attribute.getY(index);
			return this;
		}

		rotateAround(center, angle) {
			const c = Math.cos(angle),
						s = Math.sin(angle);
			const x = this.x - center.x;
			const y = this.y - center.y;
			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;
			return this;
		}

		random() {
			this.x = Math.random();
			this.y = Math.random();
			return this;
		}

		*[Symbol.iterator]() {
			yield this.x;
			yield this.y;
		}

	}

	Vector2.prototype.isVector2 = true;

	class Matrix3 {
		constructor() {
			this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];

			if (arguments.length > 0) {
				console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
			}
		}

		set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
			const te = this.elements;
			te[0] = n11;
			te[1] = n21;
			te[2] = n31;
			te[3] = n12;
			te[4] = n22;
			te[5] = n32;
			te[6] = n13;
			te[7] = n23;
			te[8] = n33;
			return this;
		}

		identity() {
			this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
			return this;
		}

		copy(m) {
			const te = this.elements;
			const me = m.elements;
			te[0] = me[0];
			te[1] = me[1];
			te[2] = me[2];
			te[3] = me[3];
			te[4] = me[4];
			te[5] = me[5];
			te[6] = me[6];
			te[7] = me[7];
			te[8] = me[8];
			return this;
		}

		extractBasis(xAxis, yAxis, zAxis) {
			xAxis.setFromMatrix3Column(this, 0);
			yAxis.setFromMatrix3Column(this, 1);
			zAxis.setFromMatrix3Column(this, 2);
			return this;
		}

		setFromMatrix4(m) {
			const me = m.elements;
			this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
			return this;
		}

		multiply(m) {
			return this.multiplyMatrices(this, m);
		}

		premultiply(m) {
			return this.multiplyMatrices(m, this);
		}

		multiplyMatrices(a, b) {
			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;
			const a11 = ae[0],
						a12 = ae[3],
						a13 = ae[6];
			const a21 = ae[1],
						a22 = ae[4],
						a23 = ae[7];
			const a31 = ae[2],
						a32 = ae[5],
						a33 = ae[8];
			const b11 = be[0],
						b12 = be[3],
						b13 = be[6];
			const b21 = be[1],
						b22 = be[4],
						b23 = be[7];
			const b31 = be[2],
						b32 = be[5],
						b33 = be[8];
			te[0] = a11 * b11 + a12 * b21 + a13 * b31;
			te[3] = a11 * b12 + a12 * b22 + a13 * b32;
			te[6] = a11 * b13 + a12 * b23 + a13 * b33;
			te[1] = a21 * b11 + a22 * b21 + a23 * b31;
			te[4] = a21 * b12 + a22 * b22 + a23 * b32;
			te[7] = a21 * b13 + a22 * b23 + a23 * b33;
			te[2] = a31 * b11 + a32 * b21 + a33 * b31;
			te[5] = a31 * b12 + a32 * b22 + a33 * b32;
			te[8] = a31 * b13 + a32 * b23 + a33 * b33;
			return this;
		}

		multiplyScalar(s) {
			const te = this.elements;
			te[0] *= s;
			te[3] *= s;
			te[6] *= s;
			te[1] *= s;
			te[4] *= s;
			te[7] *= s;
			te[2] *= s;
			te[5] *= s;
			te[8] *= s;
			return this;
		}

		determinant() {
			const te = this.elements;
			const a = te[0],
						b = te[1],
						c = te[2],
						d = te[3],
						e = te[4],
						f = te[5],
						g = te[6],
						h = te[7],
						i = te[8];
			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
		}

		invert() {
			const te = this.elements,
						n11 = te[0],
						n21 = te[1],
						n31 = te[2],
						n12 = te[3],
						n22 = te[4],
						n32 = te[5],
						n13 = te[6],
						n23 = te[7],
						n33 = te[8],
						t11 = n33 * n22 - n32 * n23,
						t12 = n32 * n13 - n33 * n12,
						t13 = n23 * n12 - n22 * n13,
						det = n11 * t11 + n21 * t12 + n31 * t13;
			if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
			const detInv = 1 / det;
			te[0] = t11 * detInv;
			te[1] = (n31 * n23 - n33 * n21) * detInv;
			te[2] = (n32 * n21 - n31 * n22) * detInv;
			te[3] = t12 * detInv;
			te[4] = (n33 * n11 - n31 * n13) * detInv;
			te[5] = (n31 * n12 - n32 * n11) * detInv;
			te[6] = t13 * detInv;
			te[7] = (n21 * n13 - n23 * n11) * detInv;
			te[8] = (n22 * n11 - n21 * n12) * detInv;
			return this;
		}

		transpose() {
			let tmp;
			const m = this.elements;
			tmp = m[1];
			m[1] = m[3];
			m[3] = tmp;
			tmp = m[2];
			m[2] = m[6];
			m[6] = tmp;
			tmp = m[5];
			m[5] = m[7];
			m[7] = tmp;
			return this;
		}

		getNormalMatrix(matrix4) {
			return this.setFromMatrix4(matrix4).invert().transpose();
		}

		transposeIntoArray(r) {
			const m = this.elements;
			r[0] = m[0];
			r[1] = m[3];
			r[2] = m[6];
			r[3] = m[1];
			r[4] = m[4];
			r[5] = m[7];
			r[6] = m[2];
			r[7] = m[5];
			r[8] = m[8];
			return this;
		}

		setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
			const c = Math.cos(rotation);
			const s = Math.sin(rotation);
			this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
			return this;
		}

		scale(sx, sy) {
			const te = this.elements;
			te[0] *= sx;
			te[3] *= sx;
			te[6] *= sx;
			te[1] *= sy;
			te[4] *= sy;
			te[7] *= sy;
			return this;
		}

		rotate(theta) {
			const c = Math.cos(theta);
			const s = Math.sin(theta);
			const te = this.elements;
			const a11 = te[0],
						a12 = te[3],
						a13 = te[6];
			const a21 = te[1],
						a22 = te[4],
						a23 = te[7];
			te[0] = c * a11 + s * a21;
			te[3] = c * a12 + s * a22;
			te[6] = c * a13 + s * a23;
			te[1] = -s * a11 + c * a21;
			te[4] = -s * a12 + c * a22;
			te[7] = -s * a13 + c * a23;
			return this;
		}

		translate(tx, ty) {
			const te = this.elements;
			te[0] += tx * te[2];
			te[3] += tx * te[5];
			te[6] += tx * te[8];
			te[1] += ty * te[2];
			te[4] += ty * te[5];
			te[7] += ty * te[8];
			return this;
		}

		equals(matrix) {
			const te = this.elements;
			const me = matrix.elements;

			for (let i = 0; i < 9; i++) {
				if (te[i] !== me[i]) return false;
			}

			return true;
		}

		fromArray(array, offset = 0) {
			for (let i = 0; i < 9; i++) {
				this.elements[i] = array[i + offset];
			}

			return this;
		}

		toArray(array = [], offset = 0) {
			const te = this.elements;
			array[offset] = te[0];
			array[offset + 1] = te[1];
			array[offset + 2] = te[2];
			array[offset + 3] = te[3];
			array[offset + 4] = te[4];
			array[offset + 5] = te[5];
			array[offset + 6] = te[6];
			array[offset + 7] = te[7];
			array[offset + 8] = te[8];
			return array;
		}

		clone() {
			return new this.constructor().fromArray(this.elements);
		}

	}

	Matrix3.prototype.isMatrix3 = true;

	function arrayMax(array) {
		if (array.length === 0) return -Infinity;
		let max = array[0];

		for (let i = 1, l = array.length; i < l; ++i) {
			if (array[i] > max) max = array[i];
		}

		return max;
	}

	const TYPED_ARRAYS = {
		Int8Array: Int8Array,
		Uint8Array: Uint8Array,
		Uint8ClampedArray: Uint8ClampedArray,
		Int16Array: Int16Array,
		Uint16Array: Uint16Array,
		Int32Array: Int32Array,
		Uint32Array: Uint32Array,
		Float32Array: Float32Array,
		Float64Array: Float64Array
	};

	function getTypedArray(type, buffer) {
		return new TYPED_ARRAYS[type](buffer);
	}

	function createElementNS(name) {
		return document.createElementNS('http://www.w3.org/1999/xhtml', name);
	}
	/**
		* cyrb53 hash for string from: https://stackoverflow.com/a/52171480
		*
		* Public Domain, @bryc - https://stackoverflow.com/users/815680/bryc
		*
		* It is roughly similar to the well-known MurmurHash/xxHash algorithms. It uses a combination
		* of multiplication and Xorshift to generate the hash, but not as thorough. As a result it's
		* faster than either would be in JavaScript and significantly simpler to implement. Keep in
		* mind this is not a secure algorithm, if privacy/security is a concern, this is not for you.
		*
		* @param {string} str
		* @param {number} seed, default 0
		* @returns number
		*/


	function hashString(str, seed = 0) {
		let h1 = 0xdeadbeef ^ seed,
				h2 = 0x41c6ce57 ^ seed;

		for (let i = 0, ch; i < str.length; i++) {
			ch = str.charCodeAt(i);
			h1 = Math.imul(h1 ^ ch, 2654435761);
			h2 = Math.imul(h2 ^ ch, 1597334677);
		}

		h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);
		h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h1 ^ h1 >>> 13, 3266489909);
		return 4294967296 * (2097151 & h2) + (h1 >>> 0);
	}

	let _canvas;

	class ImageUtils {
		static getDataURL(image) {
			if (/^data:/i.test(image.src)) {
				return image.src;
			}

			if (typeof HTMLCanvasElement == 'undefined') {
				return image.src;
			}

			let canvas;

			if (image instanceof HTMLCanvasElement) {
				canvas = image;
			} else {
				if (_canvas === undefined) _canvas = createElementNS('canvas');
				_canvas.width = image.width;
				_canvas.height = image.height;

				const context = _canvas.getContext('2d');

				if (image instanceof ImageData) {
					context.putImageData(image, 0, 0);
				} else {
					context.drawImage(image, 0, 0, image.width, image.height);
				}

				canvas = _canvas;
			}

			if (canvas.width > 2048 || canvas.height > 2048) {
				console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image);
				return canvas.toDataURL('image/jpeg', 0.6);
			} else {
				return canvas.toDataURL('image/png');
			}
		}

	}

	let textureId = 0;

	class Texture extends EventDispatcher {
		constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
			super();
			Object.defineProperty(this, 'id', {
				value: textureId++
			});
			this.uuid = generateUUID();
			this.name = '';
			this.image = image;
			this.mipmaps = [];
			this.mapping = mapping;
			this.wrapS = wrapS;
			this.wrapT = wrapT;
			this.magFilter = magFilter;
			this.minFilter = minFilter;
			this.anisotropy = anisotropy;
			this.format = format;
			this.internalFormat = null;
			this.type = type;
			this.offset = new Vector2(0, 0);
			this.repeat = new Vector2(1, 1);
			this.center = new Vector2(0, 0);
			this.rotation = 0;
			this.matrixAutoUpdate = true;
			this.matrix = new Matrix3();
			this.generateMipmaps = true;
			this.premultiplyAlpha = false;
			this.flipY = true;
			this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
			// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
			//
			// Also changing the encoding after already used by a Material will not automatically make the Material
			// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.

			this.encoding = encoding;
			this.userData = {};
			this.version = 0;
			this.onUpdate = null;
			this.isRenderTargetTexture = false;
		}

		updateMatrix() {
			this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(source) {
			this.name = source.name;
			this.image = source.image;
			this.mipmaps = source.mipmaps.slice(0);
			this.mapping = source.mapping;
			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;
			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;
			this.anisotropy = source.anisotropy;
			this.format = source.format;
			this.internalFormat = source.internalFormat;
			this.type = source.type;
			this.offset.copy(source.offset);
			this.repeat.copy(source.repeat);
			this.center.copy(source.center);
			this.rotation = source.rotation;
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy(source.matrix);
			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.encoding = source.encoding;
			this.userData = JSON.parse(JSON.stringify(source.userData));
			return this;
		}

		toJSON(meta) {
			const isRootObject = meta === undefined || typeof meta === 'string';

			if (!isRootObject && meta.textures[this.uuid] !== undefined) {
				return meta.textures[this.uuid];
			}

			const output = {
				metadata: {
					version: 4.5,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},
				uuid: this.uuid,
				name: this.name,
				mapping: this.mapping,
				repeat: [this.repeat.x, this.repeat.y],
				offset: [this.offset.x, this.offset.y],
				center: [this.center.x, this.center.y],
				rotation: this.rotation,
				wrap: [this.wrapS, this.wrapT],
				format: this.format,
				type: this.type,
				encoding: this.encoding,
				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,
				flipY: this.flipY,
				premultiplyAlpha: this.premultiplyAlpha,
				unpackAlignment: this.unpackAlignment
			};

			if (this.image !== undefined) {
				// TODO: Move to THREE.Image
				const image = this.image;

				if (image.uuid === undefined) {
					image.uuid = generateUUID(); // UGH
				}

				if (!isRootObject && meta.images[image.uuid] === undefined) {
					let url;

					if (Array.isArray(image)) {
						// process array of images e.g. CubeTexture
						url = [];

						for (let i = 0, l = image.length; i < l; i++) {
							// check cube texture with data textures
							if (image[i].isDataTexture) {
								url.push(serializeImage(image[i].image));
							} else {
								url.push(serializeImage(image[i]));
							}
						}
					} else {
						// process single image
						url = serializeImage(image);
					}

					meta.images[image.uuid] = {
						uuid: image.uuid,
						url: url
					};
				}

				output.image = image.uuid;
			}

			if (JSON.stringify(this.userData) !== '{}') output.userData = this.userData;

			if (!isRootObject) {
				meta.textures[this.uuid] = output;
			}

			return output;
		}

		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}

		transformUv(uv) {
			if (this.mapping !== UVMapping) return uv;
			uv.applyMatrix3(this.matrix);

			if (uv.x < 0 || uv.x > 1) {
				switch (this.wrapS) {
					case RepeatWrapping:
						uv.x = uv.x - Math.floor(uv.x);
						break;

					case ClampToEdgeWrapping:
						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:
						if (Math.abs(Math.floor(uv.x) % 2) === 1) {
							uv.x = Math.ceil(uv.x) - uv.x;
						} else {
							uv.x = uv.x - Math.floor(uv.x);
						}

						break;
				}
			}

			if (uv.y < 0 || uv.y > 1) {
				switch (this.wrapT) {
					case RepeatWrapping:
						uv.y = uv.y - Math.floor(uv.y);
						break;

					case ClampToEdgeWrapping:
						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:
						if (Math.abs(Math.floor(uv.y) % 2) === 1) {
							uv.y = Math.ceil(uv.y) - uv.y;
						} else {
							uv.y = uv.y - Math.floor(uv.y);
						}

						break;
				}
			}

			if (this.flipY) {
				uv.y = 1 - uv.y;
			}

			return uv;
		}

		set needsUpdate(value) {
			if (value === true) this.version++;
		}

	}

	Texture.DEFAULT_IMAGE = undefined;
	Texture.DEFAULT_MAPPING = UVMapping;
	Texture.prototype.isTexture = true;

	function serializeImage(image) {
		if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
			// default images
			return ImageUtils.getDataURL(image);
		} else {
			if (image.data) {
				// images of DataTexture
				return {
					data: Array.prototype.slice.call(image.data),
					width: image.width,
					height: image.height,
					type: image.data.constructor.name
				};
			} else {
				console.warn('THREE.Texture: Unable to serialize Texture.');
				return {};
			}
		}
	}

	class Vector4 {
		constructor(x = 0, y = 0, z = 0, w = 1) {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
		}

		get width() {
			return this.z;
		}

		set width(value) {
			this.z = value;
		}

		get height() {
			return this.w;
		}

		set height(value) {
			this.w = value;
		}

		set(x, y, z, w) {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
			return this;
		}

		setScalar(scalar) {
			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;
			return this;
		}

		setX(x) {
			this.x = x;
			return this;
		}

		setY(y) {
			this.y = y;
			return this;
		}

		setZ(z) {
			this.z = z;
			return this;
		}

		setW(w) {
			this.w = w;
			return this;
		}

		setComponent(index, value) {
			switch (index) {
				case 0:
					this.x = value;
					break;

				case 1:
					this.y = value;
					break;

				case 2:
					this.z = value;
					break;

				case 3:
					this.w = value;
					break;

				default:
					throw new Error('index is out of range: ' + index);
			}

			return this;
		}

		getComponent(index) {
			switch (index) {
				case 0:
					return this.x;

				case 1:
					return this.y;

				case 2:
					return this.z;

				case 3:
					return this.w;

				default:
					throw new Error('index is out of range: ' + index);
			}
		}

		clone() {
			return new this.constructor(this.x, this.y, this.z, this.w);
		}

		copy(v) {
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = v.w !== undefined ? v.w : 1;
			return this;
		}

		add(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
				return this.addVectors(v, w);
			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;
			return this;
		}

		addScalar(s) {
			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;
			return this;
		}

		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;
			return this;
		}

		addScaledVector(v, s) {
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;
			return this;
		}

		sub(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
				return this.subVectors(v, w);
			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;
			return this;
		}

		subScalar(s) {
			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;
			return this;
		}

		subVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;
			return this;
		}

		multiply(v) {
			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
			this.w *= v.w;
			return this;
		}

		multiplyScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;
			return this;
		}

		applyMatrix4(m) {
			const x = this.x,
						y = this.y,
						z = this.z,
						w = this.w;
			const e = m.elements;
			this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
			this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
			this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
			this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
			return this;
		}

		divideScalar(scalar) {
			return this.multiplyScalar(1 / scalar);
		}

		setAxisAngleFromQuaternion(q) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
			// q is assumed to be normalized
			this.w = 2 * Math.acos(q.w);
			const s = Math.sqrt(1 - q.w * q.w);

			if (s < 0.0001) {
				this.x = 1;
				this.y = 0;
				this.z = 0;
			} else {
				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;
			}

			return this;
		}

		setAxisAngleFromRotationMatrix(m) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			let angle, x, y, z; // variables for result

			const epsilon = 0.01,
						// margin to allow for rounding errors
			epsilon2 = 0.1,
						// margin to distinguish between 0 and 180 degrees
			te = m.elements,
						m11 = te[0],
						m12 = te[4],
						m13 = te[8],
						m21 = te[1],
						m22 = te[5],
						m23 = te[9],
						m31 = te[2],
						m32 = te[6],
						m33 = te[10];

			if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms
				if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
					// this singularity is identity matrix so angle = 0
					this.set(1, 0, 0, 0);
					return this; // zero angle, arbitrary axis
				} // otherwise this singularity is angle = 180


				angle = Math.PI;
				const xx = (m11 + 1) / 2;
				const yy = (m22 + 1) / 2;
				const zz = (m33 + 1) / 2;
				const xy = (m12 + m21) / 4;
				const xz = (m13 + m31) / 4;
				const yz = (m23 + m32) / 4;

				if (xx > yy && xx > zz) {
					// m11 is the largest diagonal term
					if (xx < epsilon) {
						x = 0;
						y = 0.707106781;
						z = 0.707106781;
					} else {
						x = Math.sqrt(xx);
						y = xy / x;
						z = xz / x;
					}
				} else if (yy > zz) {
					// m22 is the largest diagonal term
					if (yy < epsilon) {
						x = 0.707106781;
						y = 0;
						z = 0.707106781;
					} else {
						y = Math.sqrt(yy);
						x = xy / y;
						z = yz / y;
					}
				} else {
					// m33 is the largest diagonal term so base result on this
					if (zz < epsilon) {
						x = 0.707106781;
						y = 0.707106781;
						z = 0;
					} else {
						z = Math.sqrt(zz);
						x = xz / z;
						y = yz / z;
					}
				}

				this.set(x, y, z, angle);
				return this; // return 180 deg rotation
			} // as we have reached here there are no singularities so we can handle normally


			let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize

			if (Math.abs(s) < 0.001) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = (m32 - m23) / s;
			this.y = (m13 - m31) / s;
			this.z = (m21 - m12) / s;
			this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
			return this;
		}

		min(v) {
			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			this.z = Math.min(this.z, v.z);
			this.w = Math.min(this.w, v.w);
			return this;
		}

		max(v) {
			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			this.z = Math.max(this.z, v.z);
			this.w = Math.max(this.w, v.w);
			return this;
		}

		clamp(min, max) {
			// assumes min < max, componentwise
			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			this.z = Math.max(min.z, Math.min(max.z, this.z));
			this.w = Math.max(min.w, Math.min(max.w, this.w));
			return this;
		}

		clampScalar(minVal, maxVal) {
			this.x = Math.max(minVal, Math.min(maxVal, this.x));
			this.y = Math.max(minVal, Math.min(maxVal, this.y));
			this.z = Math.max(minVal, Math.min(maxVal, this.z));
			this.w = Math.max(minVal, Math.min(maxVal, this.w));
			return this;
		}

		clampLength(min, max) {
			const length = this.length();
			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		}

		floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			this.z = Math.floor(this.z);
			this.w = Math.floor(this.w);
			return this;
		}

		ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			this.z = Math.ceil(this.z);
			this.w = Math.ceil(this.w);
			return this;
		}

		round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			this.z = Math.round(this.z);
			this.w = Math.round(this.w);
			return this;
		}

		roundToZero() {
			this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
			this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
			this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
			return this;
		}

		negate() {
			this.x = -this.x;
			this.y = -this.y;
			this.z = -this.z;
			this.w = -this.w;
			return this;
		}

		dot(v) {
			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
		}

		lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		}

		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
		}

		manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
		}

		normalize() {
			return this.divideScalar(this.length() || 1);
		}

		setLength(length) {
			return this.normalize().multiplyScalar(length);
		}

		lerp(v, alpha) {
			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			this.z += (v.z - this.z) * alpha;
			this.w += (v.w - this.w) * alpha;
			return this;
		}

		lerpVectors(v1, v2, alpha) {
			this.x = v1.x + (v2.x - v1.x) * alpha;
			this.y = v1.y + (v2.y - v1.y) * alpha;
			this.z = v1.z + (v2.z - v1.z) * alpha;
			this.w = v1.w + (v2.w - v1.w) * alpha;
			return this;
		}

		equals(v) {
			return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
		}

		fromArray(array, offset = 0) {
			this.x = array[offset];
			this.y = array[offset + 1];
			this.z = array[offset + 2];
			this.w = array[offset + 3];
			return this;
		}

		toArray(array = [], offset = 0) {
			array[offset] = this.x;
			array[offset + 1] = this.y;
			array[offset + 2] = this.z;
			array[offset + 3] = this.w;
			return array;
		}

		fromBufferAttribute(attribute, index, offset) {
			if (offset !== undefined) {
				console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
			}

			this.x = attribute.getX(index);
			this.y = attribute.getY(index);
			this.z = attribute.getZ(index);
			this.w = attribute.getW(index);
			return this;
		}

		random() {
			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();
			this.w = Math.random();
			return this;
		}

		*[Symbol.iterator]() {
			yield this.x;
			yield this.y;
			yield this.z;
			yield this.w;
		}

	}

	Vector4.prototype.isVector4 = true;

	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/

	class WebGLRenderTarget extends EventDispatcher {
		constructor(width, height, options = {}) {
			super();
			this.width = width;
			this.height = height;
			this.depth = 1;
			this.scissor = new Vector4(0, 0, width, height);
			this.scissorTest = false;
			this.viewport = new Vector4(0, 0, width, height);
			this.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
			this.texture.isRenderTargetTexture = true;
			this.texture.image = {
				width: width,
				height: height,
				depth: 1
			};
			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			this.texture.internalFormat = options.internalFormat !== undefined ? options.internalFormat : null;
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
			this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
			this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
			this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
		}

		setTexture(texture) {
			texture.image = {
				width: this.width,
				height: this.height,
				depth: this.depth
			};
			this.texture = texture;
		}

		setSize(width, height, depth = 1) {
			if (this.width !== width || this.height !== height || this.depth !== depth) {
				this.width = width;
				this.height = height;
				this.depth = depth;
				this.texture.image.width = width;
				this.texture.image.height = height;
				this.texture.image.depth = depth;
				this.dispose();
			}

			this.viewport.set(0, 0, width, height);
			this.scissor.set(0, 0, width, height);
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(source) {
			this.width = source.width;
			this.height = source.height;
			this.depth = source.depth;
			this.viewport.copy(source.viewport);
			this.texture = source.texture.clone();
			this.texture.image = { ...this.texture.image
			}; // See #20328.

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;
			return this;
		}

		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}

	}

	WebGLRenderTarget.prototype.isWebGLRenderTarget = true;

	class WebGLMultipleRenderTargets extends WebGLRenderTarget {
		constructor(width, height, count) {
			super(width, height);
			const texture = this.texture;
			this.texture = [];

			for (let i = 0; i < count; i++) {
				this.texture[i] = texture.clone();
			}
		}

		setSize(width, height, depth = 1) {
			if (this.width !== width || this.height !== height || this.depth !== depth) {
				this.width = width;
				this.height = height;
				this.depth = depth;

				for (let i = 0, il = this.texture.length; i < il; i++) {
					this.texture[i].image.width = width;
					this.texture[i].image.height = height;
					this.texture[i].image.depth = depth;
				}

				this.dispose();
			}

			this.viewport.set(0, 0, width, height);
			this.scissor.set(0, 0, width, height);
			return this;
		}

		copy(source) {
			this.dispose();
			this.width = source.width;
			this.height = source.height;
			this.depth = source.depth;
			this.viewport.set(0, 0, this.width, this.height);
			this.scissor.set(0, 0, this.width, this.height);
			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;
			this.texture.length = 0;

			for (let i = 0, il = source.texture.length; i < il; i++) {
				this.texture[i] = source.texture[i].clone();
			}

			return this;
		}

	}

	WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;

	class WebGLMultisampleRenderTarget extends WebGLRenderTarget {
		constructor(width, height, options = {}) {
			super(width, height, options);
			this.samples = 4;
			this.ignoreDepthForMultisampleCopy = options.ignoreDepth !== undefined ? options.ignoreDepth : true;
			this.useRenderToTexture = options.useRenderToTexture !== undefined ? options.useRenderToTexture : false;
			this.useRenderbuffer = this.useRenderToTexture === false;
		}

		copy(source) {
			super.copy.call(this, source);
			this.samples = source.samples;
			this.useRenderToTexture = source.useRenderToTexture;
			this.useRenderbuffer = source.useRenderbuffer;
			return this;
		}

	}

	WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;

	class Quaternion {
		constructor(x = 0, y = 0, z = 0, w = 1) {
			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;
		}

		static slerp(qa, qb, qm, t) {
			console.warn('THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.');
			return qm.slerpQuaternions(qa, qb, t);
		}

		static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
			// fuzz-free, array-based Quaternion SLERP operation
			let x0 = src0[srcOffset0 + 0],
					y0 = src0[srcOffset0 + 1],
					z0 = src0[srcOffset0 + 2],
					w0 = src0[srcOffset0 + 3];
			const x1 = src1[srcOffset1 + 0],
						y1 = src1[srcOffset1 + 1],
						z1 = src1[srcOffset1 + 2],
						w1 = src1[srcOffset1 + 3];

			if (t === 0) {
				dst[dstOffset + 0] = x0;
				dst[dstOffset + 1] = y0;
				dst[dstOffset + 2] = z0;
				dst[dstOffset + 3] = w0;
				return;
			}

			if (t === 1) {
				dst[dstOffset + 0] = x1;
				dst[dstOffset + 1] = y1;
				dst[dstOffset + 2] = z1;
				dst[dstOffset + 3] = w1;
				return;
			}

			if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
				let s = 1 - t;
				const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
							dir = cos >= 0 ? 1 : -1,
							sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:

				if (sqrSin > Number.EPSILON) {
					const sin = Math.sqrt(sqrSin),
								len = Math.atan2(sin, cos * dir);
					s = Math.sin(s * len) / sin;
					t = Math.sin(t * len) / sin;
				}

				const tDir = t * dir;
				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:

				if (s === 1 - t) {
					const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;
				}
			}

			dst[dstOffset] = x0;
			dst[dstOffset + 1] = y0;
			dst[dstOffset + 2] = z0;
			dst[dstOffset + 3] = w0;
		}

		static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
			const x0 = src0[srcOffset0];
			const y0 = src0[srcOffset0 + 1];
			const z0 = src0[srcOffset0 + 2];
			const w0 = src0[srcOffset0 + 3];
			const x1 = src1[srcOffset1];
			const y1 = src1[srcOffset1 + 1];
			const z1 = src1[srcOffset1 + 2];
			const w1 = src1[srcOffset1 + 3];
			dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
			dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
			dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
			dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
			return dst;
		}

		get x() {
			return this._x;
		}

		set x(value) {
			this._x = value;

			this._onChangeCallback();
		}

		get y() {
			return this._y;
		}

		set y(value) {
			this._y = value;

			this._onChangeCallback();
		}

		get z() {
			return this._z;
		}

		set z(value) {
			this._z = value;

			this._onChangeCallback();
		}

		get w() {
			return this._w;
		}

		set w(value) {
			this._w = value;

			this._onChangeCallback();
		}

		set(x, y, z, w) {
			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this._onChangeCallback();

			return this;
		}

		clone() {
			return new this.constructor(this._x, this._y, this._z, this._w);
		}

		copy(quaternion) {
			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this._onChangeCallback();

			return this;
		}

		setFromEuler(euler, update) {
			if (!(euler && euler.isEuler)) {
				throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
			}

			const x = euler._x,
						y = euler._y,
						z = euler._z,
						order = euler._order; // http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			const cos = Math.cos;
			const sin = Math.sin;
			const c1 = cos(x / 2);
			const c2 = cos(y / 2);
			const c3 = cos(z / 2);
			const s1 = sin(x / 2);
			const s2 = sin(y / 2);
			const s3 = sin(z / 2);

			switch (order) {
				case 'XYZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'YXZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'ZXY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'ZYX':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'YZX':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'XZY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				default:
					console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
			}

			if (update !== false) this._onChangeCallback();
			return this;
		}

		setFromAxisAngle(axis, angle) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
			// assumes axis is normalized
			const halfAngle = angle / 2,
						s = Math.sin(halfAngle);
			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos(halfAngle);

			this._onChangeCallback();

			return this;
		}

		setFromRotationMatrix(m) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			const te = m.elements,
						m11 = te[0],
						m12 = te[4],
						m13 = te[8],
						m21 = te[1],
						m22 = te[5],
						m23 = te[9],
						m31 = te[2],
						m32 = te[6],
						m33 = te[10],
						trace = m11 + m22 + m33;

			if (trace > 0) {
				const s = 0.5 / Math.sqrt(trace + 1.0);
				this._w = 0.25 / s;
				this._x = (m32 - m23) * s;
				this._y = (m13 - m31) * s;
				this._z = (m21 - m12) * s;
			} else if (m11 > m22 && m11 > m33) {
				const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
				this._w = (m32 - m23) / s;
				this._x = 0.25 * s;
				this._y = (m12 + m21) / s;
				this._z = (m13 + m31) / s;
			} else if (m22 > m33) {
				const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
				this._w = (m13 - m31) / s;
				this._x = (m12 + m21) / s;
				this._y = 0.25 * s;
				this._z = (m23 + m32) / s;
			} else {
				const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
				this._w = (m21 - m12) / s;
				this._x = (m13 + m31) / s;
				this._y = (m23 + m32) / s;
				this._z = 0.25 * s;
			}

			this._onChangeCallback();

			return this;
		}

		setFromUnitVectors(vFrom, vTo) {
			// assumes direction vectors vFrom and vTo are normalized
			let r = vFrom.dot(vTo) + 1;

			if (r < Number.EPSILON) {
				// vFrom and vTo point in opposite directions
				r = 0;

				if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
					this._x = -vFrom.y;
					this._y = vFrom.x;
					this._z = 0;
					this._w = r;
				} else {
					this._x = 0;
					this._y = -vFrom.z;
					this._z = vFrom.y;
					this._w = r;
				}
			} else {
				// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
				this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
				this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
				this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
				this._w = r;
			}

			return this.normalize();
		}

		angleTo(q) {
			return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
		}

		rotateTowards(q, step) {
			const angle = this.angleTo(q);
			if (angle === 0) return this;
			const t = Math.min(1, step / angle);
			this.slerp(q, t);
			return this;
		}

		identity() {
			return this.set(0, 0, 0, 1);
		}

		invert() {
			// quaternion is assumed to have unit length
			return this.conjugate();
		}

		conjugate() {
			this._x *= -1;
			this._y *= -1;
			this._z *= -1;

			this._onChangeCallback();

			return this;
		}

		dot(v) {
			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
		}

		lengthSq() {
			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
		}

		length() {
			return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
		}

		normalize() {
			let l = this.length();

			if (l === 0) {
				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;
			} else {
				l = 1 / l;
				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;
			}

			this._onChangeCallback();

			return this;
		}

		multiply(q, p) {
			if (p !== undefined) {
				console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
				return this.multiplyQuaternions(q, p);
			}

			return this.multiplyQuaternions(this, q);
		}

		premultiply(q) {
			return this.multiplyQuaternions(q, this);
		}

		multiplyQuaternions(a, b) {
			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
			const qax = a._x,
						qay = a._y,
						qaz = a._z,
						qaw = a._w;
			const qbx = b._x,
						qby = b._y,
						qbz = b._z,
						qbw = b._w;
			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this._onChangeCallback();

			return this;
		}

		slerp(qb, t) {
			if (t === 0) return this;
			if (t === 1) return this.copy(qb);
			const x = this._x,
						y = this._y,
						z = this._z,
						w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if (cosHalfTheta < 0) {
				this._w = -qb._w;
				this._x = -qb._x;
				this._y = -qb._y;
				this._z = -qb._z;
				cosHalfTheta = -cosHalfTheta;
			} else {
				this.copy(qb);
			}

			if (cosHalfTheta >= 1.0) {
				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;
				return this;
			}

			const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

			if (sqrSinHalfTheta <= Number.EPSILON) {
				const s = 1 - t;
				this._w = s * w + t * this._w;
				this._x = s * x + t * this._x;
				this._y = s * y + t * this._y;
				this._z = s * z + t * this._z;
				this.normalize();

				this._onChangeCallback();

				return this;
			}

			const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
			const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
			const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
						ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
			this._w = w * ratioA + this._w * ratioB;
			this._x = x * ratioA + this._x * ratioB;
			this._y = y * ratioA + this._y * ratioB;
			this._z = z * ratioA + this._z * ratioB;

			this._onChangeCallback();

			return this;
		}

		slerpQuaternions(qa, qb, t) {
			this.copy(qa).slerp(qb, t);
		}

		random() {
			// Derived from http://planning.cs.uiuc.edu/node198.html
			// Note, this source uses w, x, y, z ordering,
			// so we swap the order below.
			const u1 = Math.random();
			const sqrt1u1 = Math.sqrt(1 - u1);
			const sqrtu1 = Math.sqrt(u1);
			const u2 = 2 * Math.PI * Math.random();
			const u3 = 2 * Math.PI * Math.random();
			return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
		}

		equals(quaternion) {
			return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
		}

		fromArray(array, offset = 0) {
			this._x = array[offset];
			this._y = array[offset + 1];
			this._z = array[offset + 2];
			this._w = array[offset + 3];

			this._onChangeCallback();

			return this;
		}

		toArray(array = [], offset = 0) {
			array[offset] = this._x;
			array[offset + 1] = this._y;
			array[offset + 2] = this._z;
			array[offset + 3] = this._w;
			return array;
		}

		fromBufferAttribute(attribute, index) {
			this._x = attribute.getX(index);
			this._y = attribute.getY(index);
			this._z = attribute.getZ(index);
			this._w = attribute.getW(index);
			return this;
		}

		_onChange(callback) {
			this._onChangeCallback = callback;
			return this;
		}

		_onChangeCallback() {}

	}

	Quaternion.prototype.isQuaternion = true;

	class Vector3 {
		constructor(x = 0, y = 0, z = 0) {
			this.x = x;
			this.y = y;
			this.z = z;
		}

		set(x, y, z) {
			if (z === undefined) z = this.z; // sprite.scale.set(x,y)

			this.x = x;
			this.y = y;
			this.z = z;
			return this;
		}

		setScalar(scalar) {
			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			return this;
		}

		setX(x) {
			this.x = x;
			return this;
		}

		setY(y) {
			this.y = y;
			return this;
		}

		setZ(z) {
			this.z = z;
			return this;
		}

		setComponent(index, value) {
			switch (index) {
				case 0:
					this.x = value;
					break;

				case 1:
					this.y = value;
					break;

				case 2:
					this.z = value;
					break;

				default:
					throw new Error('index is out of range: ' + index);
			}

			return this;
		}

		getComponent(index) {
			switch (index) {
				case 0:
					return this.x;

				case 1:
					return this.y;

				case 2:
					return this.z;

				default:
					throw new Error('index is out of range: ' + index);
			}
		}

		clone() {
			return new this.constructor(this.x, this.y, this.z);
		}

		copy(v) {
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			return this;
		}

		add(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
				return this.addVectors(v, w);
			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			return this;
		}

		addScalar(s) {
			this.x += s;
			this.y += s;
			this.z += s;
			return this;
		}

		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			return this;
		}

		addScaledVector(v, s) {
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			return this;
		}

		sub(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
				return this.subVectors(v, w);
			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			return this;
		}

		subScalar(s) {
			this.x -= s;
			this.y -= s;
			this.z -= s;
			return this;
		}

		subVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			return this;
		}

		multiply(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
				return this.multiplyVectors(v, w);
			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
			return this;
		}

		multiplyScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			return this;
		}

		multiplyVectors(a, b) {
			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;
			return this;
		}

		applyEuler(euler) {
			if (!(euler && euler.isEuler)) {
				console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
			}

			return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
		}

		applyAxisAngle(axis, angle) {
			return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
		}

		applyMatrix3(m) {
			const x = this.x,
						y = this.y,
						z = this.z;
			const e = m.elements;
			this.x = e[0] * x + e[3] * y + e[6] * z;
			this.y = e[1] * x + e[4] * y + e[7] * z;
			this.z = e[2] * x + e[5] * y + e[8] * z;
			return this;
		}

		applyNormalMatrix(m) {
			return this.applyMatrix3(m).normalize();
		}

		applyMatrix4(m) {
			const x = this.x,
						y = this.y,
						z = this.z;
			const e = m.elements;
			const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
			this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
			this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
			this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
			return this;
		}

		applyQuaternion(q) {
			const x = this.x,
						y = this.y,
						z = this.z;
			const qx = q.x,
						qy = q.y,
						qz = q.z,
						qw = q.w; // calculate quat * vector

			const ix = qw * x + qy * z - qz * y;
			const iy = qw * y + qz * x - qx * z;
			const iz = qw * z + qx * y - qy * x;
			const iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

			this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
			this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
			this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
			return this;
		}

		project(camera) {
			return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
		}

		unproject(camera) {
			return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
		}

		transformDirection(m) {
			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction
			const x = this.x,
						y = this.y,
						z = this.z;
			const e = m.elements;
			this.x = e[0] * x + e[4] * y + e[8] * z;
			this.y = e[1] * x + e[5] * y + e[9] * z;
			this.z = e[2] * x + e[6] * y + e[10] * z;
			return this.normalize();
		}

		divide(v) {
			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;
			return this;
		}

		divideScalar(scalar) {
			return this.multiplyScalar(1 / scalar);
		}

		min(v) {
			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			this.z = Math.min(this.z, v.z);
			return this;
		}

		max(v) {
			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			this.z = Math.max(this.z, v.z);
			return this;
		}

		clamp(min, max) {
			// assumes min < max, componentwise
			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			this.z = Math.max(min.z, Math.min(max.z, this.z));
			return this;
		}

		clampScalar(minVal, maxVal) {
			this.x = Math.max(minVal, Math.min(maxVal, this.x));
			this.y = Math.max(minVal, Math.min(maxVal, this.y));
			this.z = Math.max(minVal, Math.min(maxVal, this.z));
			return this;
		}

		clampLength(min, max) {
			const length = this.length();
			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		}

		floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			this.z = Math.floor(this.z);
			return this;
		}

		ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			this.z = Math.ceil(this.z);
			return this;
		}

		round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			this.z = Math.round(this.z);
			return this;
		}

		roundToZero() {
			this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
			this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
			return this;
		}

		negate() {
			this.x = -this.x;
			this.y = -this.y;
			this.z = -this.z;
			return this;
		}

		dot(v) {
			return this.x * v.x + this.y * v.y + this.z * v.z;
		} // TODO lengthSquared?


		lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z;
		}

		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
		}

		manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
		}

		normalize() {
			return this.divideScalar(this.length() || 1);
		}

		setLength(length) {
			return this.normalize().multiplyScalar(length);
		}

		lerp(v, alpha) {
			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			this.z += (v.z - this.z) * alpha;
			return this;
		}

		lerpVectors(v1, v2, alpha) {
			this.x = v1.x + (v2.x - v1.x) * alpha;
			this.y = v1.y + (v2.y - v1.y) * alpha;
			this.z = v1.z + (v2.z - v1.z) * alpha;
			return this;
		}

		cross(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
				return this.crossVectors(v, w);
			}

			return this.crossVectors(this, v);
		}

		crossVectors(a, b) {
			const ax = a.x,
						ay = a.y,
						az = a.z;
			const bx = b.x,
						by = b.y,
						bz = b.z;
			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;
			return this;
		}

		projectOnVector(v) {
			const denominator = v.lengthSq();
			if (denominator === 0) return this.set(0, 0, 0);
			const scalar = v.dot(this) / denominator;
			return this.copy(v).multiplyScalar(scalar);
		}

		projectOnPlane(planeNormal) {
			_vector$c.copy(this).projectOnVector(planeNormal);

			return this.sub(_vector$c);
		}

		reflect(normal) {
			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length
			return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
		}

		angleTo(v) {
			const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
			if (denominator === 0) return Math.PI / 2;
			const theta = this.dot(v) / denominator; // clamp, to handle numerical problems

			return Math.acos(clamp(theta, -1, 1));
		}

		distanceTo(v) {
			return Math.sqrt(this.distanceToSquared(v));
		}

		distanceToSquared(v) {
			const dx = this.x - v.x,
						dy = this.y - v.y,
						dz = this.z - v.z;
			return dx * dx + dy * dy + dz * dz;
		}

		manhattanDistanceTo(v) {
			return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
		}

		setFromSpherical(s) {
			return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
		}

		setFromSphericalCoords(radius, phi, theta) {
			const sinPhiRadius = Math.sin(phi) * radius;
			this.x = sinPhiRadius * Math.sin(theta);
			this.y = Math.cos(phi) * radius;
			this.z = sinPhiRadius * Math.cos(theta);
			return this;
		}

		setFromCylindrical(c) {
			return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
		}

		setFromCylindricalCoords(radius, theta, y) {
			this.x = radius * Math.sin(theta);
			this.y = y;
			this.z = radius * Math.cos(theta);
			return this;
		}

		setFromMatrixPosition(m) {
			const e = m.elements;
			this.x = e[12];
			this.y = e[13];
			this.z = e[14];
			return this;
		}

		setFromMatrixScale(m) {
			const sx = this.setFromMatrixColumn(m, 0).length();
			const sy = this.setFromMatrixColumn(m, 1).length();
			const sz = this.setFromMatrixColumn(m, 2).length();
			this.x = sx;
			this.y = sy;
			this.z = sz;
			return this;
		}

		setFromMatrixColumn(m, index) {
			return this.fromArray(m.elements, index * 4);
		}

		setFromMatrix3Column(m, index) {
			return this.fromArray(m.elements, index * 3);
		}

		equals(v) {
			return v.x === this.x && v.y === this.y && v.z === this.z;
		}

		fromArray(array, offset = 0) {
			this.x = array[offset];
			this.y = array[offset + 1];
			this.z = array[offset + 2];
			return this;
		}

		toArray(array = [], offset = 0) {
			array[offset] = this.x;
			array[offset + 1] = this.y;
			array[offset + 2] = this.z;
			return array;
		}

		fromBufferAttribute(attribute, index, offset) {
			if (offset !== undefined) {
				console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
			}

			this.x = attribute.getX(index);
			this.y = attribute.getY(index);
			this.z = attribute.getZ(index);
			return this;
		}

		random() {
			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();
			return this;
		}

		randomDirection() {
			// Derived from https://mathworld.wolfram.com/SpherePointPicking.html
			const u = (Math.random() - 0.5) * 2;
			const t = Math.random() * Math.PI * 2;
			const f = Math.sqrt(1 - u ** 2);
			this.x = f * Math.cos(t);
			this.y = f * Math.sin(t);
			this.z = u;
			return this;
		}

		*[Symbol.iterator]() {
			yield this.x;
			yield this.y;
			yield this.z;
		}

	}

	Vector3.prototype.isVector3 = true;

	const _vector$c = /*@__PURE__*/new Vector3();

	const _quaternion$4 = /*@__PURE__*/new Quaternion();

	class Box3 {
		constructor(min = new Vector3(+Infinity, +Infinity, +Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
			this.min = min;
			this.max = max;
		}

		set(min, max) {
			this.min.copy(min);
			this.max.copy(max);
			return this;
		}

		setFromArray(array) {
			let minX = +Infinity;
			let minY = +Infinity;
			let minZ = +Infinity;
			let maxX = -Infinity;
			let maxY = -Infinity;
			let maxZ = -Infinity;

			for (let i = 0, l = array.length; i < l; i += 3) {
				const x = array[i];
				const y = array[i + 1];
				const z = array[i + 2];
				if (x < minX) minX = x;
				if (y < minY) minY = y;
				if (z < minZ) minZ = z;
				if (x > maxX) maxX = x;
				if (y > maxY) maxY = y;
				if (z > maxZ) maxZ = z;
			}

			this.min.set(minX, minY, minZ);
			this.max.set(maxX, maxY, maxZ);
			return this;
		}

		setFromBufferAttribute(attribute) {
			let minX = +Infinity;
			let minY = +Infinity;
			let minZ = +Infinity;
			let maxX = -Infinity;
			let maxY = -Infinity;
			let maxZ = -Infinity;

			for (let i = 0, l = attribute.count; i < l; i++) {
				const x = attribute.getX(i);
				const y = attribute.getY(i);
				const z = attribute.getZ(i);
				if (x < minX) minX = x;
				if (y < minY) minY = y;
				if (z < minZ) minZ = z;
				if (x > maxX) maxX = x;
				if (y > maxY) maxY = y;
				if (z > maxZ) maxZ = z;
			}

			this.min.set(minX, minY, minZ);
			this.max.set(maxX, maxY, maxZ);
			return this;
		}

		setFromPoints(points) {
			this.makeEmpty();

			for (let i = 0, il = points.length; i < il; i++) {
				this.expandByPoint(points[i]);
			}

			return this;
		}

		setFromCenterAndSize(center, size) {
			const halfSize = _vector$b.copy(size).multiplyScalar(0.5);

			this.min.copy(center).sub(halfSize);
			this.max.copy(center).add(halfSize);
			return this;
		}

		setFromObject(object) {
			this.makeEmpty();
			return this.expandByObject(object);
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(box) {
			this.min.copy(box.min);
			this.max.copy(box.max);
			return this;
		}

		makeEmpty() {
			this.min.x = this.min.y = this.min.z = +Infinity;
			this.max.x = this.max.y = this.max.z = -Infinity;
			return this;
		}

		isEmpty() {
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
			return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
		}

		getCenter(target) {
			return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
		}

		getSize(target) {
			return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
		}

		expandByPoint(point) {
			this.min.min(point);
			this.max.max(point);
			return this;
		}

		expandByVector(vector) {
			this.min.sub(vector);
			this.max.add(vector);
			return this;
		}

		expandByScalar(scalar) {
			this.min.addScalar(-scalar);
			this.max.addScalar(scalar);
			return this;
		}

		expandByObject(object) {
			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms
			object.updateWorldMatrix(false, false);
			const geometry = object.geometry;

			if (geometry !== undefined) {
				if (geometry.boundingBox === null) {
					geometry.computeBoundingBox();
				}

				_box$3.copy(geometry.boundingBox);

				_box$3.applyMatrix4(object.matrixWorld);

				this.union(_box$3);
			}

			const children = object.children;

			for (let i = 0, l = children.length; i < l; i++) {
				this.expandByObject(children[i]);
			}

			return this;
		}

		containsPoint(point) {
			return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
		}

		containsBox(box) {
			return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
		}

		getParameter(point, target) {
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
			return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
		}

		intersectsBox(box) {
			// using 6 splitting planes to rule out intersections.
			return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
		}

		intersectsSphere(sphere) {
			// Find the point on the AABB closest to the sphere center.
			this.clampPoint(sphere.center, _vector$b); // If that point is inside the sphere, the AABB and sphere intersect.

			return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
		}

		intersectsPlane(plane) {
			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.
			let min, max;

			if (plane.normal.x > 0) {
				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;
			} else {
				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;
			}

			if (plane.normal.y > 0) {
				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;
			} else {
				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;
			}

			if (plane.normal.z > 0) {
				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;
			} else {
				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;
			}

			return min <= -plane.constant && max >= -plane.constant;
		}

		intersectsTriangle(triangle) {
			if (this.isEmpty()) {
				return false;
			} // compute box center and extents


			this.getCenter(_center);

			_extents.subVectors(this.max, _center); // translate triangle to aabb origin


			_v0$2.subVectors(triangle.a, _center);

			_v1$7.subVectors(triangle.b, _center);

			_v2$3.subVectors(triangle.c, _center); // compute edge vectors for triangle


			_f0.subVectors(_v1$7, _v0$2);

			_f1.subVectors(_v2$3, _v1$7);

			_f2.subVectors(_v0$2, _v2$3); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
			// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
			// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)


			let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];

			if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
				return false;
			} // test 3 face normals from the aabb


			axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];

			if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
				return false;
			} // finally testing the face normal of the triangle
			// use already existing triangle edge vectors here


			_triangleNormal.crossVectors(_f0, _f1);

			axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
			return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
		}

		clampPoint(point, target) {
			return target.copy(point).clamp(this.min, this.max);
		}

		distanceToPoint(point) {
			const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);

			return clampedPoint.sub(point).length();
		}

		getBoundingSphere(target) {
			this.getCenter(target.center);
			target.radius = this.getSize(_vector$b).length() * 0.5;
			return target;
		}

		intersect(box) {
			this.min.max(box.min);
			this.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.

			if (this.isEmpty()) this.makeEmpty();
			return this;
		}

		union(box) {
			this.min.min(box.min);
			this.max.max(box.max);
			return this;
		}

		applyMatrix4(matrix) {
			// transform of empty box is an empty box.
			if (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below

			_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000


			_points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001


			_points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010


			_points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011


			_points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100


			_points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101


			_points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110


			_points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111


			this.setFromPoints(_points);
			return this;
		}

		translate(offset) {
			this.min.add(offset);
			this.max.add(offset);
			return this;
		}

		equals(box) {
			return box.min.equals(this.min) && box.max.equals(this.max);
		}

	}

	Box3.prototype.isBox3 = true;
	const _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];

	const _vector$b = /*@__PURE__*/new Vector3();

	const _box$3 = /*@__PURE__*/new Box3(); // triangle centered vertices


	const _v0$2 = /*@__PURE__*/new Vector3();

	const _v1$7 = /*@__PURE__*/new Vector3();

	const _v2$3 = /*@__PURE__*/new Vector3(); // triangle edge vectors


	const _f0 = /*@__PURE__*/new Vector3();

	const _f1 = /*@__PURE__*/new Vector3();

	const _f2 = /*@__PURE__*/new Vector3();

	const _center = /*@__PURE__*/new Vector3();

	const _extents = /*@__PURE__*/new Vector3();

	const _triangleNormal = /*@__PURE__*/new Vector3();

	const _testAxis = /*@__PURE__*/new Vector3();

	function satForAxes(axes, v0, v1, v2, extents) {
		for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
			_testAxis.fromArray(axes, i); // project the aabb onto the seperating axis


			const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z); // project all 3 vertices of the triangle onto the seperating axis

			const p0 = v0.dot(_testAxis);
			const p1 = v1.dot(_testAxis);
			const p2 = v2.dot(_testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r

			if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
				// points of the projected triangle are outside the projected half-length of the aabb
				// the axis is seperating and we can exit
				return false;
			}
		}

		return true;
	}

	const _box$2 = /*@__PURE__*/new Box3();

	const _v1$6 = /*@__PURE__*/new Vector3();

	const _toFarthestPoint = /*@__PURE__*/new Vector3();

	const _toPoint = /*@__PURE__*/new Vector3();

	class Sphere {
		constructor(center = new Vector3(), radius = -1) {
			this.center = center;
			this.radius = radius;
		}

		set(center, radius) {
			this.center.copy(center);
			this.radius = radius;
			return this;
		}

		setFromPoints(points, optionalCenter) {
			const center = this.center;

			if (optionalCenter !== undefined) {
				center.copy(optionalCenter);
			} else {
				_box$2.setFromPoints(points).getCenter(center);
			}

			let maxRadiusSq = 0;

			for (let i = 0, il = points.length; i < il; i++) {
				maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
			}

			this.radius = Math.sqrt(maxRadiusSq);
			return this;
		}

		copy(sphere) {
			this.center.copy(sphere.center);
			this.radius = sphere.radius;
			return this;
		}

		isEmpty() {
			return this.radius < 0;
		}

		makeEmpty() {
			this.center.set(0, 0, 0);
			this.radius = -1;
			return this;
		}

		containsPoint(point) {
			return point.distanceToSquared(this.center) <= this.radius * this.radius;
		}

		distanceToPoint(point) {
			return point.distanceTo(this.center) - this.radius;
		}

		intersectsSphere(sphere) {
			const radiusSum = this.radius + sphere.radius;
			return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
		}

		intersectsBox(box) {
			return box.intersectsSphere(this);
		}

		intersectsPlane(plane) {
			return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
		}

		clampPoint(point, target) {
			const deltaLengthSq = this.center.distanceToSquared(point);
			target.copy(point);

			if (deltaLengthSq > this.radius * this.radius) {
				target.sub(this.center).normalize();
				target.multiplyScalar(this.radius).add(this.center);
			}

			return target;
		}

		getBoundingBox(target) {
			if (this.isEmpty()) {
				// Empty sphere produces empty bounding box
				target.makeEmpty();
				return target;
			}

			target.set(this.center, this.center);
			target.expandByScalar(this.radius);
			return target;
		}

		applyMatrix4(matrix) {
			this.center.applyMatrix4(matrix);
			this.radius = this.radius * matrix.getMaxScaleOnAxis();
			return this;
		}

		translate(offset) {
			this.center.add(offset);
			return this;
		}

		expandByPoint(point) {
			// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671
			_toPoint.subVectors(point, this.center);

			const lengthSq = _toPoint.lengthSq();

			if (lengthSq > this.radius * this.radius) {
				const length = Math.sqrt(lengthSq);
				const missingRadiusHalf = (length - this.radius) * 0.5; // Nudge this sphere towards the target point. Add half the missing distance to radius,
				// and the other half to position. This gives a tighter enclosure, instead of if
				// the whole missing distance were just added to radius.

				this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
				this.radius += missingRadiusHalf;
			}

			return this;
		}

		union(sphere) {
			// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769
			// To enclose another sphere into this sphere, we only need to enclose two points:
			// 1) Enclose the farthest point on the other sphere into this sphere.
			// 2) Enclose the opposite point of the farthest point into this sphere.
			_toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);

			this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
			this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
			return this;
		}

		equals(sphere) {
			return sphere.center.equals(this.center) && sphere.radius === this.radius;
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	const _vector$a = /*@__PURE__*/new Vector3();

	const _segCenter = /*@__PURE__*/new Vector3();

	const _segDir = /*@__PURE__*/new Vector3();

	const _diff = /*@__PURE__*/new Vector3();

	const _edge1 = /*@__PURE__*/new Vector3();

	const _edge2 = /*@__PURE__*/new Vector3();

	const _normal$1 = /*@__PURE__*/new Vector3();

	class Ray {
		constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
			this.origin = origin;
			this.direction = direction;
		}

		set(origin, direction) {
			this.origin.copy(origin);
			this.direction.copy(direction);
			return this;
		}

		copy(ray) {
			this.origin.copy(ray.origin);
			this.direction.copy(ray.direction);
			return this;
		}

		at(t, target) {
			return target.copy(this.direction).multiplyScalar(t).add(this.origin);
		}

		lookAt(v) {
			this.direction.copy(v).sub(this.origin).normalize();
			return this;
		}

		recast(t) {
			this.origin.copy(this.at(t, _vector$a));
			return this;
		}

		closestPointToPoint(point, target) {
			target.subVectors(point, this.origin);
			const directionDistance = target.dot(this.direction);

			if (directionDistance < 0) {
				return target.copy(this.origin);
			}

			return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
		}

		distanceToPoint(point) {
			return Math.sqrt(this.distanceSqToPoint(point));
		}

		distanceSqToPoint(point) {
			const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction); // point behind the ray


			if (directionDistance < 0) {
				return this.origin.distanceToSquared(point);
			}

			_vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

			return _vector$a.distanceToSquared(point);
		}

		distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment
			_segCenter.copy(v0).add(v1).multiplyScalar(0.5);

			_segDir.copy(v1).sub(v0).normalize();

			_diff.copy(this.origin).sub(_segCenter);

			const segExtent = v0.distanceTo(v1) * 0.5;
			const a01 = -this.direction.dot(_segDir);

			const b0 = _diff.dot(this.direction);

			const b1 = -_diff.dot(_segDir);

			const c = _diff.lengthSq();

			const det = Math.abs(1 - a01 * a01);
			let s0, s1, sqrDist, extDet;

			if (det > 0) {
				// The ray and segment are not parallel.
				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;

				if (s0 >= 0) {
					if (s1 >= -extDet) {
						if (s1 <= extDet) {
							// region 0
							// Minimum at interior points of ray and segment.
							const invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
						} else {
							// region 1
							s1 = segExtent;
							s0 = Math.max(0, -(a01 * s1 + b0));
							sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
						}
					} else {
						// region 5
						s1 = -segExtent;
						s0 = Math.max(0, -(a01 * s1 + b0));
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					}
				} else {
					if (s1 <= -extDet) {
						// region 4
						s0 = Math.max(0, -(-a01 * segExtent + b0));
						s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					} else if (s1 <= extDet) {
						// region 3
						s0 = 0;
						s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
						sqrDist = s1 * (s1 + 2 * b1) + c;
					} else {
						// region 2
						s0 = Math.max(0, -(a01 * segExtent + b0));
						s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					}
				}
			} else {
				// Ray and segment are parallel.
				s1 = a01 > 0 ? -segExtent : segExtent;
				s0 = Math.max(0, -(a01 * s1 + b0));
				sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
			}

			if (optionalPointOnRay) {
				optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
			}

			if (optionalPointOnSegment) {
				optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
			}

			return sqrDist;
		}

		intersectSphere(sphere, target) {
			_vector$a.subVectors(sphere.center, this.origin);

			const tca = _vector$a.dot(this.direction);

			const d2 = _vector$a.dot(_vector$a) - tca * tca;
			const radius2 = sphere.radius * sphere.radius;
			if (d2 > radius2) return null;
			const thc = Math.sqrt(radius2 - d2); // t0 = first intersect point - entrance on front of sphere

			const t0 = tca - thc; // t1 = second intersect point - exit point on back of sphere

			const t1 = tca + thc; // test to see if both t0 and t1 are behind the ray - if so, return null

			if (t0 < 0 && t1 < 0) return null; // test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.

			if (t0 < 0) return this.at(t1, target); // else t0 is in front of the ray, so return the first collision point scaled by t0

			return this.at(t0, target);
		}

		intersectsSphere(sphere) {
			return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
		}

		distanceToPlane(plane) {
			const denominator = plane.normal.dot(this.direction);

			if (denominator === 0) {
				// line is coplanar, return origin
				if (plane.distanceToPoint(this.origin) === 0) {
					return 0;
				} // Null is preferable to undefined since undefined means.... it is undefined


				return null;
			}

			const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator; // Return if the ray never intersects the plane

			return t >= 0 ? t : null;
		}

		intersectPlane(plane, target) {
			const t = this.distanceToPlane(plane);

			if (t === null) {
				return null;
			}

			return this.at(t, target);
		}

		intersectsPlane(plane) {
			// check if the ray lies on the plane first
			const distToPoint = plane.distanceToPoint(this.origin);

			if (distToPoint === 0) {
				return true;
			}

			const denominator = plane.normal.dot(this.direction);

			if (denominator * distToPoint < 0) {
				return true;
			} // ray origin is behind the plane (and is pointing behind it)


			return false;
		}

		intersectBox(box, target) {
			let tmin, tmax, tymin, tymax, tzmin, tzmax;
			const invdirx = 1 / this.direction.x,
						invdiry = 1 / this.direction.y,
						invdirz = 1 / this.direction.z;
			const origin = this.origin;

			if (invdirx >= 0) {
				tmin = (box.min.x - origin.x) * invdirx;
				tmax = (box.max.x - origin.x) * invdirx;
			} else {
				tmin = (box.max.x - origin.x) * invdirx;
				tmax = (box.min.x - origin.x) * invdirx;
			}

			if (invdiry >= 0) {
				tymin = (box.min.y - origin.y) * invdiry;
				tymax = (box.max.y - origin.y) * invdiry;
			} else {
				tymin = (box.max.y - origin.y) * invdiry;
				tymax = (box.min.y - origin.y) * invdiry;
			}

			if (tmin > tymax || tymin > tmax) return null; // These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if (tymin > tmin || tmin !== tmin) tmin = tymin;
			if (tymax < tmax || tmax !== tmax) tmax = tymax;

			if (invdirz >= 0) {
				tzmin = (box.min.z - origin.z) * invdirz;
				tzmax = (box.max.z - origin.z) * invdirz;
			} else {
				tzmin = (box.max.z - origin.z) * invdirz;
				tzmax = (box.min.z - origin.z) * invdirz;
			}

			if (tmin > tzmax || tzmin > tmax) return null;
			if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
			if (tzmax < tmax || tmax !== tmax) tmax = tzmax; //return point closest to the ray (positive side)

			if (tmax < 0) return null;
			return this.at(tmin >= 0 ? tmin : tmax, target);
		}

		intersectsBox(box) {
			return this.intersectBox(box, _vector$a) !== null;
		}

		intersectTriangle(a, b, c, backfaceCulling, target) {
			// Compute the offset origin, edges, and normal.
			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
			_edge1.subVectors(b, a);

			_edge2.subVectors(c, a);

			_normal$1.crossVectors(_edge1, _edge2); // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//	 |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//	 |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//	 |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)


			let DdN = this.direction.dot(_normal$1);
			let sign;

			if (DdN > 0) {
				if (backfaceCulling) return null;
				sign = 1;
			} else if (DdN < 0) {
				sign = -1;
				DdN = -DdN;
			} else {
				return null;
			}

			_diff.subVectors(this.origin, a);

			const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2)); // b1 < 0, no intersection

			if (DdQxE2 < 0) {
				return null;
			}

			const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff)); // b2 < 0, no intersection

			if (DdE1xQ < 0) {
				return null;
			} // b1+b2 > 1, no intersection


			if (DdQxE2 + DdE1xQ > DdN) {
				return null;
			} // Line intersects triangle, check if ray does.


			const QdN = -sign * _diff.dot(_normal$1); // t < 0, no intersection


			if (QdN < 0) {
				return null;
			} // Ray intersects triangle.


			return this.at(QdN / DdN, target);
		}

		applyMatrix4(matrix4) {
			this.origin.applyMatrix4(matrix4);
			this.direction.transformDirection(matrix4);
			return this;
		}

		equals(ray) {
			return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	class Matrix4 {
		constructor() {
			this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

			if (arguments.length > 0) {
				console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
			}
		}

		set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
			const te = this.elements;
			te[0] = n11;
			te[4] = n12;
			te[8] = n13;
			te[12] = n14;
			te[1] = n21;
			te[5] = n22;
			te[9] = n23;
			te[13] = n24;
			te[2] = n31;
			te[6] = n32;
			te[10] = n33;
			te[14] = n34;
			te[3] = n41;
			te[7] = n42;
			te[11] = n43;
			te[15] = n44;
			return this;
		}

		identity() {
			this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
			return this;
		}

		clone() {
			return new Matrix4().fromArray(this.elements);
		}

		copy(m) {
			const te = this.elements;
			const me = m.elements;
			te[0] = me[0];
			te[1] = me[1];
			te[2] = me[2];
			te[3] = me[3];
			te[4] = me[4];
			te[5] = me[5];
			te[6] = me[6];
			te[7] = me[7];
			te[8] = me[8];
			te[9] = me[9];
			te[10] = me[10];
			te[11] = me[11];
			te[12] = me[12];
			te[13] = me[13];
			te[14] = me[14];
			te[15] = me[15];
			return this;
		}

		copyPosition(m) {
			const te = this.elements,
						me = m.elements;
			te[12] = me[12];
			te[13] = me[13];
			te[14] = me[14];
			return this;
		}

		setFromMatrix3(m) {
			const me = m.elements;
			this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
			return this;
		}

		extractBasis(xAxis, yAxis, zAxis) {
			xAxis.setFromMatrixColumn(this, 0);
			yAxis.setFromMatrixColumn(this, 1);
			zAxis.setFromMatrixColumn(this, 2);
			return this;
		}

		makeBasis(xAxis, yAxis, zAxis) {
			this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
			return this;
		}

		extractRotation(m) {
			// this method does not support reflection matrices
			const te = this.elements;
			const me = m.elements;

			const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();

			const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();

			const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();

			te[0] = me[0] * scaleX;
			te[1] = me[1] * scaleX;
			te[2] = me[2] * scaleX;
			te[3] = 0;
			te[4] = me[4] * scaleY;
			te[5] = me[5] * scaleY;
			te[6] = me[6] * scaleY;
			te[7] = 0;
			te[8] = me[8] * scaleZ;
			te[9] = me[9] * scaleZ;
			te[10] = me[10] * scaleZ;
			te[11] = 0;
			te[12] = 0;
			te[13] = 0;
			te[14] = 0;
			te[15] = 1;
			return this;
		}

		makeRotationFromEuler(euler) {
			if (!(euler && euler.isEuler)) {
				console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
			}

			const te = this.elements;
			const x = euler.x,
						y = euler.y,
						z = euler.z;
			const a = Math.cos(x),
						b = Math.sin(x);
			const c = Math.cos(y),
						d = Math.sin(y);
			const e = Math.cos(z),
						f = Math.sin(z);

			if (euler.order === 'XYZ') {
				const ae = a * e,
							af = a * f,
							be = b * e,
							bf = b * f;
				te[0] = c * e;
				te[4] = -c * f;
				te[8] = d;
				te[1] = af + be * d;
				te[5] = ae - bf * d;
				te[9] = -b * c;
				te[2] = bf - ae * d;
				te[6] = be + af * d;
				te[10] = a * c;
			} else if (euler.order === 'YXZ') {
				const ce = c * e,
							cf = c * f,
							de = d * e,
							df = d * f;
				te[0] = ce + df * b;
				te[4] = de * b - cf;
				te[8] = a * d;
				te[1] = a * f;
				te[5] = a * e;
				te[9] = -b;
				te[2] = cf * b - de;
				te[6] = df + ce * b;
				te[10] = a * c;
			} else if (euler.order === 'ZXY') {
				const ce = c * e,
							cf = c * f,
							de = d * e,
							df = d * f;
				te[0] = ce - df * b;
				te[4] = -a * f;
				te[8] = de + cf * b;
				te[1] = cf + de * b;
				te[5] = a * e;
				te[9] = df - ce * b;
				te[2] = -a * d;
				te[6] = b;
				te[10] = a * c;
			} else if (euler.order === 'ZYX') {
				const ae = a * e,
							af = a * f,
							be = b * e,
							bf = b * f;
				te[0] = c * e;
				te[4] = be * d - af;
				te[8] = ae * d + bf;
				te[1] = c * f;
				te[5] = bf * d + ae;
				te[9] = af * d - be;
				te[2] = -d;
				te[6] = b * c;
				te[10] = a * c;
			} else if (euler.order === 'YZX') {
				const ac = a * c,
							ad = a * d,
							bc = b * c,
							bd = b * d;
				te[0] = c * e;
				te[4] = bd - ac * f;
				te[8] = bc * f + ad;
				te[1] = f;
				te[5] = a * e;
				te[9] = -b * e;
				te[2] = -d * e;
				te[6] = ad * f + bc;
				te[10] = ac - bd * f;
			} else if (euler.order === 'XZY') {
				const ac = a * c,
							ad = a * d,
							bc = b * c,
							bd = b * d;
				te[0] = c * e;
				te[4] = -f;
				te[8] = d * e;
				te[1] = ac * f + bd;
				te[5] = a * e;
				te[9] = ad * f - bc;
				te[2] = bc * f - ad;
				te[6] = b * e;
				te[10] = bd * f + ac;
			} // bottom row


			te[3] = 0;
			te[7] = 0;
			te[11] = 0; // last column

			te[12] = 0;
			te[13] = 0;
			te[14] = 0;
			te[15] = 1;
			return this;
		}

		makeRotationFromQuaternion(q) {
			return this.compose(_zero, q, _one);
		}

		lookAt(eye, target, up) {
			const te = this.elements;

			_z.subVectors(eye, target);

			if (_z.lengthSq() === 0) {
				// eye and target are in the same position
				_z.z = 1;
			}

			_z.normalize();

			_x.crossVectors(up, _z);

			if (_x.lengthSq() === 0) {
				// up and z are parallel
				if (Math.abs(up.z) === 1) {
					_z.x += 0.0001;
				} else {
					_z.z += 0.0001;
				}

				_z.normalize();

				_x.crossVectors(up, _z);
			}

			_x.normalize();

			_y.crossVectors(_z, _x);

			te[0] = _x.x;
			te[4] = _y.x;
			te[8] = _z.x;
			te[1] = _x.y;
			te[5] = _y.y;
			te[9] = _z.y;
			te[2] = _x.z;
			te[6] = _y.z;
			te[10] = _z.z;
			return this;
		}

		multiply(m, n) {
			if (n !== undefined) {
				console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
				return this.multiplyMatrices(m, n);
			}

			return this.multiplyMatrices(this, m);
		}

		premultiply(m) {
			return this.multiplyMatrices(m, this);
		}

		multiplyMatrices(a, b) {
			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;
			const a11 = ae[0],
						a12 = ae[4],
						a13 = ae[8],
						a14 = ae[12];
			const a21 = ae[1],
						a22 = ae[5],
						a23 = ae[9],
						a24 = ae[13];
			const a31 = ae[2],
						a32 = ae[6],
						a33 = ae[10],
						a34 = ae[14];
			const a41 = ae[3],
						a42 = ae[7],
						a43 = ae[11],
						a44 = ae[15];
			const b11 = be[0],
						b12 = be[4],
						b13 = be[8],
						b14 = be[12];
			const b21 = be[1],
						b22 = be[5],
						b23 = be[9],
						b24 = be[13];
			const b31 = be[2],
						b32 = be[6],
						b33 = be[10],
						b34 = be[14];
			const b41 = be[3],
						b42 = be[7],
						b43 = be[11],
						b44 = be[15];
			te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
			te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
			te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
			te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
			return this;
		}

		multiplyScalar(s) {
			const te = this.elements;
			te[0] *= s;
			te[4] *= s;
			te[8] *= s;
			te[12] *= s;
			te[1] *= s;
			te[5] *= s;
			te[9] *= s;
			te[13] *= s;
			te[2] *= s;
			te[6] *= s;
			te[10] *= s;
			te[14] *= s;
			te[3] *= s;
			te[7] *= s;
			te[11] *= s;
			te[15] *= s;
			return this;
		}

		determinant() {
			const te = this.elements;
			const n11 = te[0],
						n12 = te[4],
						n13 = te[8],
						n14 = te[12];
			const n21 = te[1],
						n22 = te[5],
						n23 = te[9],
						n24 = te[13];
			const n31 = te[2],
						n32 = te[6],
						n33 = te[10],
						n34 = te[14];
			const n41 = te[3],
						n42 = te[7],
						n43 = te[11],
						n44 = te[15]; //TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
		}

		transpose() {
			const te = this.elements;
			let tmp;
			tmp = te[1];
			te[1] = te[4];
			te[4] = tmp;
			tmp = te[2];
			te[2] = te[8];
			te[8] = tmp;
			tmp = te[6];
			te[6] = te[9];
			te[9] = tmp;
			tmp = te[3];
			te[3] = te[12];
			te[12] = tmp;
			tmp = te[7];
			te[7] = te[13];
			te[13] = tmp;
			tmp = te[11];
			te[11] = te[14];
			te[14] = tmp;
			return this;
		}

		setPosition(x, y, z) {
			const te = this.elements;

			if (x.isVector3) {
				te[12] = x.x;
				te[13] = x.y;
				te[14] = x.z;
			} else {
				te[12] = x;
				te[13] = y;
				te[14] = z;
			}

			return this;
		}

		invert() {
			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			const te = this.elements,
						n11 = te[0],
						n21 = te[1],
						n31 = te[2],
						n41 = te[3],
						n12 = te[4],
						n22 = te[5],
						n32 = te[6],
						n42 = te[7],
						n13 = te[8],
						n23 = te[9],
						n33 = te[10],
						n43 = te[11],
						n14 = te[12],
						n24 = te[13],
						n34 = te[14],
						n44 = te[15],
						t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
						t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
						t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
						t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
			const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
			if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
			const detInv = 1 / det;
			te[0] = t11 * detInv;
			te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
			te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
			te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
			te[4] = t12 * detInv;
			te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
			te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
			te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
			te[8] = t13 * detInv;
			te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
			te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
			te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
			te[12] = t14 * detInv;
			te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
			te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
			te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
			return this;
		}

		scale(v) {
			const te = this.elements;
			const x = v.x,
						y = v.y,
						z = v.z;
			te[0] *= x;
			te[4] *= y;
			te[8] *= z;
			te[1] *= x;
			te[5] *= y;
			te[9] *= z;
			te[2] *= x;
			te[6] *= y;
			te[10] *= z;
			te[3] *= x;
			te[7] *= y;
			te[11] *= z;
			return this;
		}

		getMaxScaleOnAxis() {
			const te = this.elements;
			const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
			const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
			const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
			return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
		}

		makeTranslation(x, y, z) {
			this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
			return this;
		}

		makeRotationX(theta) {
			const c = Math.cos(theta),
						s = Math.sin(theta);
			this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
			return this;
		}

		makeRotationY(theta) {
			const c = Math.cos(theta),
						s = Math.sin(theta);
			this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
			return this;
		}

		makeRotationZ(theta) {
			const c = Math.cos(theta),
						s = Math.sin(theta);
			this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
			return this;
		}

		makeRotationAxis(axis, angle) {
			// Based on http://www.gamedev.net/reference/articles/article1199.asp
			const c = Math.cos(angle);
			const s = Math.sin(angle);
			const t = 1 - c;
			const x = axis.x,
						y = axis.y,
						z = axis.z;
			const tx = t * x,
						ty = t * y;
			this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
			return this;
		}

		makeScale(x, y, z) {
			this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
			return this;
		}

		makeShear(xy, xz, yx, yz, zx, zy) {
			this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
			return this;
		}

		compose(position, quaternion, scale) {
			const te = this.elements;
			const x = quaternion._x,
						y = quaternion._y,
						z = quaternion._z,
						w = quaternion._w;
			const x2 = x + x,
						y2 = y + y,
						z2 = z + z;
			const xx = x * x2,
						xy = x * y2,
						xz = x * z2;
			const yy = y * y2,
						yz = y * z2,
						zz = z * z2;
			const wx = w * x2,
						wy = w * y2,
						wz = w * z2;
			const sx = scale.x,
						sy = scale.y,
						sz = scale.z;
			te[0] = (1 - (yy + zz)) * sx;
			te[1] = (xy + wz) * sx;
			te[2] = (xz - wy) * sx;
			te[3] = 0;
			te[4] = (xy - wz) * sy;
			te[5] = (1 - (xx + zz)) * sy;
			te[6] = (yz + wx) * sy;
			te[7] = 0;
			te[8] = (xz + wy) * sz;
			te[9] = (yz - wx) * sz;
			te[10] = (1 - (xx + yy)) * sz;
			te[11] = 0;
			te[12] = position.x;
			te[13] = position.y;
			te[14] = position.z;
			te[15] = 1;
			return this;
		}

		decompose(position, quaternion, scale) {
			const te = this.elements;

			let sx = _v1$5.set(te[0], te[1], te[2]).length();

			const sy = _v1$5.set(te[4], te[5], te[6]).length();

			const sz = _v1$5.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale


			const det = this.determinant();
			if (det < 0) sx = -sx;
			position.x = te[12];
			position.y = te[13];
			position.z = te[14]; // scale the rotation part

			_m1$2.copy(this);

			const invSX = 1 / sx;
			const invSY = 1 / sy;
			const invSZ = 1 / sz;
			_m1$2.elements[0] *= invSX;
			_m1$2.elements[1] *= invSX;
			_m1$2.elements[2] *= invSX;
			_m1$2.elements[4] *= invSY;
			_m1$2.elements[5] *= invSY;
			_m1$2.elements[6] *= invSY;
			_m1$2.elements[8] *= invSZ;
			_m1$2.elements[9] *= invSZ;
			_m1$2.elements[10] *= invSZ;
			quaternion.setFromRotationMatrix(_m1$2);
			scale.x = sx;
			scale.y = sy;
			scale.z = sz;
			return this;
		}

		makePerspective(left, right, top, bottom, near, far) {
			if (far === undefined) {
				console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
			}

			const te = this.elements;
			const x = 2 * near / (right - left);
			const y = 2 * near / (top - bottom);
			const a = (right + left) / (right - left);
			const b = (top + bottom) / (top - bottom);
			const c = -(far + near) / (far - near);
			const d = -2 * far * near / (far - near);
			te[0] = x;
			te[4] = 0;
			te[8] = a;
			te[12] = 0;
			te[1] = 0;
			te[5] = y;
			te[9] = b;
			te[13] = 0;
			te[2] = 0;
			te[6] = 0;
			te[10] = c;
			te[14] = d;
			te[3] = 0;
			te[7] = 0;
			te[11] = -1;
			te[15] = 0;
			return this;
		}

		makeOrthographic(left, right, top, bottom, near, far) {
			const te = this.elements;
			const w = 1.0 / (right - left);
			const h = 1.0 / (top - bottom);
			const p = 1.0 / (far - near);
			const x = (right + left) * w;
			const y = (top + bottom) * h;
			const z = (far + near) * p;
			te[0] = 2 * w;
			te[4] = 0;
			te[8] = 0;
			te[12] = -x;
			te[1] = 0;
			te[5] = 2 * h;
			te[9] = 0;
			te[13] = -y;
			te[2] = 0;
			te[6] = 0;
			te[10] = -2 * p;
			te[14] = -z;
			te[3] = 0;
			te[7] = 0;
			te[11] = 0;
			te[15] = 1;
			return this;
		}

		equals(matrix) {
			const te = this.elements;
			const me = matrix.elements;

			for (let i = 0; i < 16; i++) {
				if (te[i] !== me[i]) return false;
			}

			return true;
		}

		fromArray(array, offset = 0) {
			for (let i = 0; i < 16; i++) {
				this.elements[i] = array[i + offset];
			}

			return this;
		}

		toArray(array = [], offset = 0) {
			const te = this.elements;
			array[offset] = te[0];
			array[offset + 1] = te[1];
			array[offset + 2] = te[2];
			array[offset + 3] = te[3];
			array[offset + 4] = te[4];
			array[offset + 5] = te[5];
			array[offset + 6] = te[6];
			array[offset + 7] = te[7];
			array[offset + 8] = te[8];
			array[offset + 9] = te[9];
			array[offset + 10] = te[10];
			array[offset + 11] = te[11];
			array[offset + 12] = te[12];
			array[offset + 13] = te[13];
			array[offset + 14] = te[14];
			array[offset + 15] = te[15];
			return array;
		}

	}

	Matrix4.prototype.isMatrix4 = true;

	const _v1$5 = /*@__PURE__*/new Vector3();

	const _m1$2 = /*@__PURE__*/new Matrix4();

	const _zero = /*@__PURE__*/new Vector3(0, 0, 0);

	const _one = /*@__PURE__*/new Vector3(1, 1, 1);

	const _x = /*@__PURE__*/new Vector3();

	const _y = /*@__PURE__*/new Vector3();

	const _z = /*@__PURE__*/new Vector3();

	const _matrix$1 = /*@__PURE__*/new Matrix4();

	const _quaternion$3 = /*@__PURE__*/new Quaternion();

	class Euler {
		constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order;
		}

		get x() {
			return this._x;
		}

		set x(value) {
			this._x = value;

			this._onChangeCallback();
		}

		get y() {
			return this._y;
		}

		set y(value) {
			this._y = value;

			this._onChangeCallback();
		}

		get z() {
			return this._z;
		}

		set z(value) {
			this._z = value;

			this._onChangeCallback();
		}

		get order() {
			return this._order;
		}

		set order(value) {
			this._order = value;

			this._onChangeCallback();
		}

		set(x, y, z, order = this._order) {
			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order;

			this._onChangeCallback();

			return this;
		}

		clone() {
			return new this.constructor(this._x, this._y, this._z, this._order);
		}

		copy(euler) {
			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this._onChangeCallback();

			return this;
		}

		setFromRotationMatrix(m, order = this._order, update = true) {
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			const te = m.elements;
			const m11 = te[0],
						m12 = te[4],
						m13 = te[8];
			const m21 = te[1],
						m22 = te[5],
						m23 = te[9];
			const m31 = te[2],
						m32 = te[6],
						m33 = te[10];

			switch (order) {
				case 'XYZ':
					this._y = Math.asin(clamp(m13, -1, 1));

					if (Math.abs(m13) < 0.9999999) {
						this._x = Math.atan2(-m23, m33);
						this._z = Math.atan2(-m12, m11);
					} else {
						this._x = Math.atan2(m32, m22);
						this._z = 0;
					}

					break;

				case 'YXZ':
					this._x = Math.asin(-clamp(m23, -1, 1));

					if (Math.abs(m23) < 0.9999999) {
						this._y = Math.atan2(m13, m33);
						this._z = Math.atan2(m21, m22);
					} else {
						this._y = Math.atan2(-m31, m11);
						this._z = 0;
					}

					break;

				case 'ZXY':
					this._x = Math.asin(clamp(m32, -1, 1));

					if (Math.abs(m32) < 0.9999999) {
						this._y = Math.atan2(-m31, m33);
						this._z = Math.atan2(-m12, m22);
					} else {
						this._y = 0;
						this._z = Math.atan2(m21, m11);
					}

					break;

				case 'ZYX':
					this._y = Math.asin(-clamp(m31, -1, 1));

					if (Math.abs(m31) < 0.9999999) {
						this._x = Math.atan2(m32, m33);
						this._z = Math.atan2(m21, m11);
					} else {
						this._x = 0;
						this._z = Math.atan2(-m12, m22);
					}

					break;

				case 'YZX':
					this._z = Math.asin(clamp(m21, -1, 1));

					if (Math.abs(m21) < 0.9999999) {
						this._x = Math.atan2(-m23, m22);
						this._y = Math.atan2(-m31, m11);
					} else {
						this._x = 0;
						this._y = Math.atan2(m13, m33);
					}

					break;

				case 'XZY':
					this._z = Math.asin(-clamp(m12, -1, 1));

					if (Math.abs(m12) < 0.9999999) {
						this._x = Math.atan2(m32, m22);
						this._y = Math.atan2(m13, m11);
					} else {
						this._x = Math.atan2(-m23, m33);
						this._y = 0;
					}

					break;

				default:
					console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
			}

			this._order = order;
			if (update === true) this._onChangeCallback();
			return this;
		}

		setFromQuaternion(q, order, update) {
			_matrix$1.makeRotationFromQuaternion(q);

			return this.setFromRotationMatrix(_matrix$1, order, update);
		}

		setFromVector3(v, order = this._order) {
			return this.set(v.x, v.y, v.z, order);
		}

		reorder(newOrder) {
			// WARNING: this discards revolution information -bhouston
			_quaternion$3.setFromEuler(this);

			return this.setFromQuaternion(_quaternion$3, newOrder);
		}

		equals(euler) {
			return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
		}

		fromArray(array) {
			this._x = array[0];
			this._y = array[1];
			this._z = array[2];
			if (array[3] !== undefined) this._order = array[3];

			this._onChangeCallback();

			return this;
		}

		toArray(array = [], offset = 0) {
			array[offset] = this._x;
			array[offset + 1] = this._y;
			array[offset + 2] = this._z;
			array[offset + 3] = this._order;
			return array;
		}

		toVector3(optionalResult) {
			if (optionalResult) {
				return optionalResult.set(this._x, this._y, this._z);
			} else {
				return new Vector3(this._x, this._y, this._z);
			}
		}

		_onChange(callback) {
			this._onChangeCallback = callback;
			return this;
		}

		_onChangeCallback() {}

	}

	Euler.prototype.isEuler = true;
	Euler.DefaultOrder = 'XYZ';
	Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];

	class Layers {
		constructor() {
			this.mask = 1 | 0;
		}

		set(channel) {
			this.mask = (1 << channel | 0) >>> 0;
		}

		enable(channel) {
			this.mask |= 1 << channel | 0;
		}

		enableAll() {
			this.mask = 0xffffffff | 0;
		}

		toggle(channel) {
			this.mask ^= 1 << channel | 0;
		}

		disable(channel) {
			this.mask &= ~(1 << channel | 0);
		}

		disableAll() {
			this.mask = 0;
		}

		test(layers) {
			return (this.mask & layers.mask) !== 0;
		}

		isEnabled(channel) {
			return (this.mask & (1 << channel | 0)) !== 0;
		}

	}

	let _object3DId = 0;

	const _v1$4 = /*@__PURE__*/new Vector3();

	const _q1 = /*@__PURE__*/new Quaternion();

	const _m1$1 = /*@__PURE__*/new Matrix4();

	const _target = /*@__PURE__*/new Vector3();

	const _position$3 = /*@__PURE__*/new Vector3();

	const _scale$2 = /*@__PURE__*/new Vector3();

	const _quaternion$2 = /*@__PURE__*/new Quaternion();

	const _xAxis = /*@__PURE__*/new Vector3(1, 0, 0);

	const _yAxis = /*@__PURE__*/new Vector3(0, 1, 0);

	const _zAxis = /*@__PURE__*/new Vector3(0, 0, 1);

	const _addedEvent = {
		type: 'added'
	};
	const _removedEvent = {
		type: 'removed'
	};

	class Object3D extends EventDispatcher {
		constructor() {
			super();
			Object.defineProperty(this, 'id', {
				value: _object3DId++
			});
			this.uuid = generateUUID();
			this.name = '';
			this.type = 'Object3D';
			this.parent = null;
			this.children = [];
			this.up = Object3D.DefaultUp.clone();
			const position = new Vector3();
			const rotation = new Euler();
			const quaternion = new Quaternion();
			const scale = new Vector3(1, 1, 1);

			function onRotationChange() {
				quaternion.setFromEuler(rotation, false);
			}

			function onQuaternionChange() {
				rotation.setFromQuaternion(quaternion, undefined, false);
			}

			rotation._onChange(onRotationChange);

			quaternion._onChange(onQuaternionChange);

			Object.defineProperties(this, {
				position: {
					configurable: true,
					enumerable: true,
					value: position
				},
				rotation: {
					configurable: true,
					enumerable: true,
					value: rotation
				},
				quaternion: {
					configurable: true,
					enumerable: true,
					value: quaternion
				},
				scale: {
					configurable: true,
					enumerable: true,
					value: scale
				},
				modelViewMatrix: {
					value: new Matrix4()
				},
				normalMatrix: {
					value: new Matrix3()
				}
			});
			this.matrix = new Matrix4();
			this.matrixWorld = new Matrix4();
			this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
			this.matrixWorldNeedsUpdate = false;
			this.layers = new Layers();
			this.visible = true;
			this.castShadow = false;
			this.receiveShadow = false;
			this.frustumCulled = true;
			this.renderOrder = 0;
			this.animations = [];
			this.userData = {};
		}

		onBeforeRender() {}

		onAfterRender() {}

		applyMatrix4(matrix) {
			if (this.matrixAutoUpdate) this.updateMatrix();
			this.matrix.premultiply(matrix);
			this.matrix.decompose(this.position, this.quaternion, this.scale);
		}

		applyQuaternion(q) {
			this.quaternion.premultiply(q);
			return this;
		}

		setRotationFromAxisAngle(axis, angle) {
			// assumes axis is normalized
			this.quaternion.setFromAxisAngle(axis, angle);
		}

		setRotationFromEuler(euler) {
			this.quaternion.setFromEuler(euler, true);
		}

		setRotationFromMatrix(m) {
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			this.quaternion.setFromRotationMatrix(m);
		}

		setRotationFromQuaternion(q) {
			// assumes q is normalized
			this.quaternion.copy(q);
		}

		rotateOnAxis(axis, angle) {
			// rotate object on axis in object space
			// axis is assumed to be normalized
			_q1.setFromAxisAngle(axis, angle);

			this.quaternion.multiply(_q1);
			return this;
		}

		rotateOnWorldAxis(axis, angle) {
			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent
			_q1.setFromAxisAngle(axis, angle);

			this.quaternion.premultiply(_q1);
			return this;
		}

		rotateX(angle) {
			return this.rotateOnAxis(_xAxis, angle);
		}

		rotateY(angle) {
			return this.rotateOnAxis(_yAxis, angle);
		}

		rotateZ(angle) {
			return this.rotateOnAxis(_zAxis, angle);
		}

		translateOnAxis(axis, distance) {
			// translate object by distance along axis in object space
			// axis is assumed to be normalized
			_v1$4.copy(axis).applyQuaternion(this.quaternion);

			this.position.add(_v1$4.multiplyScalar(distance));
			return this;
		}

		translateX(distance) {
			return this.translateOnAxis(_xAxis, distance);
		}

		translateY(distance) {
			return this.translateOnAxis(_yAxis, distance);
		}

		translateZ(distance) {
			return this.translateOnAxis(_zAxis, distance);
		}

		localToWorld(vector) {
			return vector.applyMatrix4(this.matrixWorld);
		}

		worldToLocal(vector) {
			return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
		}

		lookAt(x, y, z) {
			// This method does not support objects having non-uniformly-scaled parent(s)
			if (x.isVector3) {
				_target.copy(x);
			} else {
				_target.set(x, y, z);
			}

			const parent = this.parent;
			this.updateWorldMatrix(true, false);

			_position$3.setFromMatrixPosition(this.matrixWorld);

			if (this.isCamera || this.isLight) {
				_m1$1.lookAt(_position$3, _target, this.up);
			} else {
				_m1$1.lookAt(_target, _position$3, this.up);
			}

			this.quaternion.setFromRotationMatrix(_m1$1);

			if (parent) {
				_m1$1.extractRotation(parent.matrixWorld);

				_q1.setFromRotationMatrix(_m1$1);

				this.quaternion.premultiply(_q1.invert());
			}
		}

		add(object) {
			if (arguments.length > 1) {
				for (let i = 0; i < arguments.length; i++) {
					this.add(arguments[i]);
				}

				return this;
			}

			if (object === this) {
				console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
				return this;
			}

			if (object && object.isObject3D) {
				if (object.parent !== null) {
					object.parent.remove(object);
				}

				object.parent = this;
				this.children.push(object);
				object.dispatchEvent(_addedEvent);
			} else {
				console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
			}

			return this;
		}

		remove(object) {
			if (arguments.length > 1) {
				for (let i = 0; i < arguments.length; i++) {
					this.remove(arguments[i]);
				}

				return this;
			}

			const index = this.children.indexOf(object);

			if (index !== -1) {
				object.parent = null;
				this.children.splice(index, 1);
				object.dispatchEvent(_removedEvent);
			}

			return this;
		}

		removeFromParent() {
			const parent = this.parent;

			if (parent !== null) {
				parent.remove(this);
			}

			return this;
		}

		clear() {
			for (let i = 0; i < this.children.length; i++) {
				const object = this.children[i];
				object.parent = null;
				object.dispatchEvent(_removedEvent);
			}

			this.children.length = 0;
			return this;
		}

		attach(object) {
			// adds object as a child of this, while maintaining the object's world transform
			// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)
			this.updateWorldMatrix(true, false);

			_m1$1.copy(this.matrixWorld).invert();

			if (object.parent !== null) {
				object.parent.updateWorldMatrix(true, false);

				_m1$1.multiply(object.parent.matrixWorld);
			}

			object.applyMatrix4(_m1$1);
			this.add(object);
			object.updateWorldMatrix(false, true);
			return this;
		}

		getObjectById(id) {
			return this.getObjectByProperty('id', id);
		}

		getObjectByName(name) {
			return this.getObjectByProperty('name', name);
		}

		getObjectByProperty(name, value) {
			if (this[name] === value) return this;

			for (let i = 0, l = this.children.length; i < l; i++) {
				const child = this.children[i];
				const object = child.getObjectByProperty(name, value);

				if (object !== undefined) {
					return object;
				}
			}

			return undefined;
		}

		getWorldPosition(target) {
			this.updateWorldMatrix(true, false);
			return target.setFromMatrixPosition(this.matrixWorld);
		}

		getWorldQuaternion(target) {
			this.updateWorldMatrix(true, false);
			this.matrixWorld.decompose(_position$3, target, _scale$2);
			return target;
		}

		getWorldScale(target) {
			this.updateWorldMatrix(true, false);
			this.matrixWorld.decompose(_position$3, _quaternion$2, target);
			return target;
		}

		getWorldDirection(target) {
			this.updateWorldMatrix(true, false);
			const e = this.matrixWorld.elements;
			return target.set(e[8], e[9], e[10]).normalize();
		}

		raycast() {}

		traverse(callback) {
			callback(this);
			const children = this.children;

			for (let i = 0, l = children.length; i < l; i++) {
				children[i].traverse(callback);
			}
		}

		traverseVisible(callback) {
			if (this.visible === false) return;
			callback(this);
			const children = this.children;

			for (let i = 0, l = children.length; i < l; i++) {
				children[i].traverseVisible(callback);
			}
		}

		traverseAncestors(callback) {
			const parent = this.parent;

			if (parent !== null) {
				callback(parent);
				parent.traverseAncestors(callback);
			}
		}

		updateMatrix() {
			this.matrix.compose(this.position, this.quaternion, this.scale);
			this.matrixWorldNeedsUpdate = true;
		}

		updateMatrixWorld(force) {
			if (this.matrixAutoUpdate) this.updateMatrix();

			if (this.matrixWorldNeedsUpdate || force) {
				if (this.parent === null) {
					this.matrixWorld.copy(this.matrix);
				} else {
					this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
				}

				this.matrixWorldNeedsUpdate = false;
				force = true;
			} // update children


			const children = this.children;

			for (let i = 0, l = children.length; i < l; i++) {
				children[i].updateMatrixWorld(force);
			}
		}

		updateWorldMatrix(updateParents, updateChildren) {
			const parent = this.parent;

			if (updateParents === true && parent !== null) {
				parent.updateWorldMatrix(true, false);
			}

			if (this.matrixAutoUpdate) this.updateMatrix();

			if (this.parent === null) {
				this.matrixWorld.copy(this.matrix);
			} else {
				this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
			} // update children


			if (updateChildren === true) {
				const children = this.children;

				for (let i = 0, l = children.length; i < l; i++) {
					children[i].updateWorldMatrix(false, true);
				}
			}
		}

		toJSON(meta) {
			// meta is a string when called from JSON.stringify
			const isRootObject = meta === undefined || typeof meta === 'string';
			const output = {}; // meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.

			if (isRootObject) {
				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {},
					skeletons: {},
					animations: {}
				};
				output.metadata = {
					version: 4.5,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};
			} // standard Object3D serialization


			const object = {};
			object.uuid = this.uuid;
			object.type = this.type;
			if (this.name !== '') object.name = this.name;
			if (this.castShadow === true) object.castShadow = true;
			if (this.receiveShadow === true) object.receiveShadow = true;
			if (this.visible === false) object.visible = false;
			if (this.frustumCulled === false) object.frustumCulled = false;
			if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
			if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
			object.layers = this.layers.mask;
			object.matrix = this.matrix.toArray();
			if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties

			if (this.isInstancedMesh) {
				object.type = 'InstancedMesh';
				object.count = this.count;
				object.instanceMatrix = this.instanceMatrix.toJSON();
				if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
			} //


			function serialize(library, element) {
				if (library[element.uuid] === undefined) {
					library[element.uuid] = element.toJSON(meta);
				}

				return element.uuid;
			}

			if (this.isScene) {
				if (this.background) {
					if (this.background.isColor) {
						object.background = this.background.toJSON();
					} else if (this.background.isTexture) {
						object.background = this.background.toJSON(meta).uuid;
					}
				}

				if (this.environment && this.environment.isTexture) {
					object.environment = this.environment.toJSON(meta).uuid;
				}
			} else if (this.isMesh || this.isLine || this.isPoints) {
				object.geometry = serialize(meta.geometries, this.geometry);
				const parameters = this.geometry.parameters;

				if (parameters !== undefined && parameters.shapes !== undefined) {
					const shapes = parameters.shapes;

					if (Array.isArray(shapes)) {
						for (let i = 0, l = shapes.length; i < l; i++) {
							const shape = shapes[i];
							serialize(meta.shapes, shape);
						}
					} else {
						serialize(meta.shapes, shapes);
					}
				}
			}

			if (this.isSkinnedMesh) {
				object.bindMode = this.bindMode;
				object.bindMatrix = this.bindMatrix.toArray();

				if (this.skeleton !== undefined) {
					serialize(meta.skeletons, this.skeleton);
					object.skeleton = this.skeleton.uuid;
				}
			}

			if (this.material !== undefined) {
				if (Array.isArray(this.material)) {
					const uuids = [];

					for (let i = 0, l = this.material.length; i < l; i++) {
						uuids.push(serialize(meta.materials, this.material[i]));
					}

					object.material = uuids;
				} else {
					object.material = serialize(meta.materials, this.material);
				}
			} //


			if (this.children.length > 0) {
				object.children = [];

				for (let i = 0; i < this.children.length; i++) {
					object.children.push(this.children[i].toJSON(meta).object);
				}
			} //


			if (this.animations.length > 0) {
				object.animations = [];

				for (let i = 0; i < this.animations.length; i++) {
					const animation = this.animations[i];
					object.animations.push(serialize(meta.animations, animation));
				}
			}

			if (isRootObject) {
				const geometries = extractFromCache(meta.geometries);
				const materials = extractFromCache(meta.materials);
				const textures = extractFromCache(meta.textures);
				const images = extractFromCache(meta.images);
				const shapes = extractFromCache(meta.shapes);
				const skeletons = extractFromCache(meta.skeletons);
				const animations = extractFromCache(meta.animations);
				if (geometries.length > 0) output.geometries = geometries;
				if (materials.length > 0) output.materials = materials;
				if (textures.length > 0) output.textures = textures;
				if (images.length > 0) output.images = images;
				if (shapes.length > 0) output.shapes = shapes;
				if (skeletons.length > 0) output.skeletons = skeletons;
				if (animations.length > 0) output.animations = animations;
			}

			output.object = object;
			return output; // extract data from the cache hash
			// remove metadata on each item
			// and return as array

			function extractFromCache(cache) {
				const values = [];

				for (const key in cache) {
					const data = cache[key];
					delete data.metadata;
					values.push(data);
				}

				return values;
			}
		}

		clone(recursive) {
			return new this.constructor().copy(this, recursive);
		}

		copy(source, recursive = true) {
			this.name = source.name;
			this.up.copy(source.up);
			this.position.copy(source.position);
			this.rotation.order = source.rotation.order;
			this.quaternion.copy(source.quaternion);
			this.scale.copy(source.scale);
			this.matrix.copy(source.matrix);
			this.matrixWorld.copy(source.matrixWorld);
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
			this.layers.mask = source.layers.mask;
			this.visible = source.visible;
			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;
			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;
			this.userData = JSON.parse(JSON.stringify(source.userData));

			if (recursive === true) {
				for (let i = 0; i < source.children.length; i++) {
					const child = source.children[i];
					this.add(child.clone());
				}
			}

			return this;
		}

	}

	Object3D.DefaultUp = new Vector3(0, 1, 0);
	Object3D.DefaultMatrixAutoUpdate = true;
	Object3D.prototype.isObject3D = true;

	const _v0$1 = /*@__PURE__*/new Vector3();

	const _v1$3 = /*@__PURE__*/new Vector3();

	const _v2$2 = /*@__PURE__*/new Vector3();

	const _v3$1 = /*@__PURE__*/new Vector3();

	const _vab = /*@__PURE__*/new Vector3();

	const _vac = /*@__PURE__*/new Vector3();

	const _vbc = /*@__PURE__*/new Vector3();

	const _vap = /*@__PURE__*/new Vector3();

	const _vbp = /*@__PURE__*/new Vector3();

	const _vcp = /*@__PURE__*/new Vector3();

	class Triangle {
		constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
			this.a = a;
			this.b = b;
			this.c = c;
		}

		static getNormal(a, b, c, target) {
			target.subVectors(c, b);

			_v0$1.subVectors(a, b);

			target.cross(_v0$1);
			const targetLengthSq = target.lengthSq();

			if (targetLengthSq > 0) {
				return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
			}

			return target.set(0, 0, 0);
		} // static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html


		static getBarycoord(point, a, b, c, target) {
			_v0$1.subVectors(c, a);

			_v1$3.subVectors(b, a);

			_v2$2.subVectors(point, a);

			const dot00 = _v0$1.dot(_v0$1);

			const dot01 = _v0$1.dot(_v1$3);

			const dot02 = _v0$1.dot(_v2$2);

			const dot11 = _v1$3.dot(_v1$3);

			const dot12 = _v1$3.dot(_v2$2);

			const denom = dot00 * dot11 - dot01 * dot01; // collinear or singular triangle

			if (denom === 0) {
				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return target.set(-2, -1, -1);
			}

			const invDenom = 1 / denom;
			const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
			const v = (dot00 * dot12 - dot01 * dot02) * invDenom; // barycentric coordinates must always sum to 1

			return target.set(1 - u - v, v, u);
		}

		static containsPoint(point, a, b, c) {
			this.getBarycoord(point, a, b, c, _v3$1);
			return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
		}

		static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
			this.getBarycoord(point, p1, p2, p3, _v3$1);
			target.set(0, 0);
			target.addScaledVector(uv1, _v3$1.x);
			target.addScaledVector(uv2, _v3$1.y);
			target.addScaledVector(uv3, _v3$1.z);
			return target;
		}

		static isFrontFacing(a, b, c, direction) {
			_v0$1.subVectors(c, b);

			_v1$3.subVectors(a, b); // strictly front facing


			return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
		}

		set(a, b, c) {
			this.a.copy(a);
			this.b.copy(b);
			this.c.copy(c);
			return this;
		}

		setFromPointsAndIndices(points, i0, i1, i2) {
			this.a.copy(points[i0]);
			this.b.copy(points[i1]);
			this.c.copy(points[i2]);
			return this;
		}

		setFromAttributeAndIndices(attribute, i0, i1, i2) {
			this.a.fromBufferAttribute(attribute, i0);
			this.b.fromBufferAttribute(attribute, i1);
			this.c.fromBufferAttribute(attribute, i2);
			return this;
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(triangle) {
			this.a.copy(triangle.a);
			this.b.copy(triangle.b);
			this.c.copy(triangle.c);
			return this;
		}

		getArea() {
			_v0$1.subVectors(this.c, this.b);

			_v1$3.subVectors(this.a, this.b);

			return _v0$1.cross(_v1$3).length() * 0.5;
		}

		getMidpoint(target) {
			return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
		}

		getNormal(target) {
			return Triangle.getNormal(this.a, this.b, this.c, target);
		}

		getPlane(target) {
			return target.setFromCoplanarPoints(this.a, this.b, this.c);
		}

		getBarycoord(point, target) {
			return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
		}

		getUV(point, uv1, uv2, uv3, target) {
			return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
		}

		containsPoint(point) {
			return Triangle.containsPoint(point, this.a, this.b, this.c);
		}

		isFrontFacing(direction) {
			return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
		}

		intersectsBox(box) {
			return box.intersectsTriangle(this);
		}

		closestPointToPoint(p, target) {
			const a = this.a,
						b = this.b,
						c = this.c;
			let v, w; // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
			// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
			// under the accompanying license; see chapter 5.1.5 for detailed explanation.
			// basically, we're distinguishing which of the voronoi regions of the triangle
			// the point lies in with the minimum amount of redundant computation.

			_vab.subVectors(b, a);

			_vac.subVectors(c, a);

			_vap.subVectors(p, a);

			const d1 = _vab.dot(_vap);

			const d2 = _vac.dot(_vap);

			if (d1 <= 0 && d2 <= 0) {
				// vertex region of A; barycentric coords (1, 0, 0)
				return target.copy(a);
			}

			_vbp.subVectors(p, b);

			const d3 = _vab.dot(_vbp);

			const d4 = _vac.dot(_vbp);

			if (d3 >= 0 && d4 <= d3) {
				// vertex region of B; barycentric coords (0, 1, 0)
				return target.copy(b);
			}

			const vc = d1 * d4 - d3 * d2;

			if (vc <= 0 && d1 >= 0 && d3 <= 0) {
				v = d1 / (d1 - d3); // edge region of AB; barycentric coords (1-v, v, 0)

				return target.copy(a).addScaledVector(_vab, v);
			}

			_vcp.subVectors(p, c);

			const d5 = _vab.dot(_vcp);

			const d6 = _vac.dot(_vcp);

			if (d6 >= 0 && d5 <= d6) {
				// vertex region of C; barycentric coords (0, 0, 1)
				return target.copy(c);
			}

			const vb = d5 * d2 - d1 * d6;

			if (vb <= 0 && d2 >= 0 && d6 <= 0) {
				w = d2 / (d2 - d6); // edge region of AC; barycentric coords (1-w, 0, w)

				return target.copy(a).addScaledVector(_vac, w);
			}

			const va = d3 * d6 - d5 * d4;

			if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
				_vbc.subVectors(c, b);

				w = (d4 - d3) / (d4 - d3 + (d5 - d6)); // edge region of BC; barycentric coords (0, 1-w, w)

				return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
			} // face region


			const denom = 1 / (va + vb + vc); // u = va * denom

			v = vb * denom;
			w = vc * denom;
			return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
		}

		equals(triangle) {
			return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
		}

	}

	let materialId = 0;

	class Material extends EventDispatcher {
		constructor() {
			super();
			Object.defineProperty(this, 'id', {
				value: materialId++
			});
			this.uuid = generateUUID();
			this.name = '';
			this.type = 'Material';
			this.fog = true;
			this.blending = NormalBlending;
			this.side = FrontSide;
			this.vertexColors = false;
			this.opacity = 1;
			this.format = RGBAFormat;
			this.transparent = false;
			this.blendSrc = SrcAlphaFactor;
			this.blendDst = OneMinusSrcAlphaFactor;
			this.blendEquation = AddEquation;
			this.blendSrcAlpha = null;
			this.blendDstAlpha = null;
			this.blendEquationAlpha = null;
			this.depthFunc = LessEqualDepth;
			this.depthTest = true;
			this.depthWrite = true;
			this.stencilWriteMask = 0xff;
			this.stencilFunc = AlwaysStencilFunc;
			this.stencilRef = 0;
			this.stencilFuncMask = 0xff;
			this.stencilFail = KeepStencilOp;
			this.stencilZFail = KeepStencilOp;
			this.stencilZPass = KeepStencilOp;
			this.stencilWrite = false;
			this.clippingPlanes = null;
			this.clipIntersection = false;
			this.clipShadows = false;
			this.shadowSide = null;
			this.colorWrite = true;
			this.precision = null; // override the renderer's default precision for this material

			this.polygonOffset = false;
			this.polygonOffsetFactor = 0;
			this.polygonOffsetUnits = 0;
			this.dithering = false;
			this.alphaToCoverage = false;
			this.premultipliedAlpha = false;
			this.visible = true;
			this.toneMapped = true;
			this.userData = {};
			this.version = 0;
			this._alphaTest = 0;
		}

		get alphaTest() {
			return this._alphaTest;
		}

		set alphaTest(value) {
			if (this._alphaTest > 0 !== value > 0) {
				this.version++;
			}

			this._alphaTest = value;
		}

		onBuild() {}

		onBeforeRender() {}

		onBeforeCompile() {}

		customProgramCacheKey() {
			return this.onBeforeCompile.toString();
		}

		setValues(values) {
			if (values === undefined) return;

			for (const key in values) {
				const newValue = values[key];

				if (newValue === undefined) {
					console.warn('THREE.Material: \'' + key + '\' parameter is undefined.');
					continue;
				} // for backward compatability if shading is set in the constructor


				if (key === 'shading') {
					console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
					this.flatShading = newValue === FlatShading ? true : false;
					continue;
				}

				const currentValue = this[key];

				if (currentValue === undefined) {
					console.warn('THREE.' + this.type + ': \'' + key + '\' is not a property of this material.');
					continue;
				}

				if (currentValue && currentValue.isColor) {
					currentValue.set(newValue);
				} else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
					currentValue.copy(newValue);
				} else {
					this[key] = newValue;
				}
			}
		}

		toJSON(meta) {
			const isRoot = meta === undefined || typeof meta === 'string';

			if (isRoot) {
				meta = {
					textures: {},
					images: {}
				};
			}

			const data = {
				metadata: {
					version: 4.5,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			}; // standard Material serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if (this.name !== '') data.name = this.name;
			if (this.color && this.color.isColor) data.color = this.color.getHex();
			if (this.roughness !== undefined) data.roughness = this.roughness;
			if (this.metalness !== undefined) data.metalness = this.metalness;
			if (this.sheen !== undefined) data.sheen = this.sheen;
			if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();
			if (this.sheenRoughness !== undefined) data.sheenRoughness = this.sheenRoughness;
			if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
			if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
			if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
			if (this.specularIntensity !== undefined) data.specularIntensity = this.specularIntensity;
			if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();
			if (this.shininess !== undefined) data.shininess = this.shininess;
			if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
			if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;

			if (this.clearcoatMap && this.clearcoatMap.isTexture) {
				data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
			}

			if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
				data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
			}

			if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
				data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
				data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
			}

			if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
			if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
			if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;

			if (this.lightMap && this.lightMap.isTexture) {
				data.lightMap = this.lightMap.toJSON(meta).uuid;
				data.lightMapIntensity = this.lightMapIntensity;
			}

			if (this.aoMap && this.aoMap.isTexture) {
				data.aoMap = this.aoMap.toJSON(meta).uuid;
				data.aoMapIntensity = this.aoMapIntensity;
			}

			if (this.bumpMap && this.bumpMap.isTexture) {
				data.bumpMap = this.bumpMap.toJSON(meta).uuid;
				data.bumpScale = this.bumpScale;
			}

			if (this.normalMap && this.normalMap.isTexture) {
				data.normalMap = this.normalMap.toJSON(meta).uuid;
				data.normalMapType = this.normalMapType;
				data.normalScale = this.normalScale.toArray();
			}

			if (this.displacementMap && this.displacementMap.isTexture) {
				data.displacementMap = this.displacementMap.toJSON(meta).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;
			}

			if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
			if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
			if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
			if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
			if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
			if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;

			if (this.envMap && this.envMap.isTexture) {
				data.envMap = this.envMap.toJSON(meta).uuid;
				if (this.combine !== undefined) data.combine = this.combine;
			}

			if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
			if (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;
			if (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio;

			if (this.gradientMap && this.gradientMap.isTexture) {
				data.gradientMap = this.gradientMap.toJSON(meta).uuid;
			}

			if (this.transmission !== undefined) data.transmission = this.transmission;
			if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
			if (this.thickness !== undefined) data.thickness = this.thickness;
			if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
			if (this.attenuationDistance !== undefined) data.attenuationDistance = this.attenuationDistance;
			if (this.attenuationColor !== undefined) data.attenuationColor = this.attenuationColor.getHex();
			if (this.size !== undefined) data.size = this.size;
			if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
			if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
			if (this.blending !== NormalBlending) data.blending = this.blending;
			if (this.side !== FrontSide) data.side = this.side;
			if (this.vertexColors) data.vertexColors = true;
			if (this.opacity < 1) data.opacity = this.opacity;
			if (this.format !== RGBAFormat) data.format = this.format;
			if (this.transparent === true) data.transparent = this.transparent;
			data.depthFunc = this.depthFunc;
			data.depthTest = this.depthTest;
			data.depthWrite = this.depthWrite;
			data.colorWrite = this.colorWrite;
			data.stencilWrite = this.stencilWrite;
			data.stencilWriteMask = this.stencilWriteMask;
			data.stencilFunc = this.stencilFunc;
			data.stencilRef = this.stencilRef;
			data.stencilFuncMask = this.stencilFuncMask;
			data.stencilFail = this.stencilFail;
			data.stencilZFail = this.stencilZFail;
			data.stencilZPass = this.stencilZPass; // rotation (SpriteMaterial)

			if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;
			if (this.polygonOffset === true) data.polygonOffset = true;
			if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
			if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
			if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
			if (this.dashSize !== undefined) data.dashSize = this.dashSize;
			if (this.gapSize !== undefined) data.gapSize = this.gapSize;
			if (this.scale !== undefined) data.scale = this.scale;
			if (this.dithering === true) data.dithering = true;
			if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
			if (this.alphaToCoverage === true) data.alphaToCoverage = this.alphaToCoverage;
			if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
			if (this.wireframe === true) data.wireframe = this.wireframe;
			if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
			if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
			if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
			if (this.flatShading === true) data.flatShading = this.flatShading;
			if (this.visible === false) data.visible = false;
			if (this.toneMapped === false) data.toneMapped = false;
			if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData; // TODO: Copied from Object3D.toJSON

			function extractFromCache(cache) {
				const values = [];

				for (const key in cache) {
					const data = cache[key];
					delete data.metadata;
					values.push(data);
				}

				return values;
			}

			if (isRoot) {
				const textures = extractFromCache(meta.textures);
				const images = extractFromCache(meta.images);
				if (textures.length > 0) data.textures = textures;
				if (images.length > 0) data.images = images;
			}

			return data;
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(source) {
			this.name = source.name;
			this.fog = source.fog;
			this.blending = source.blending;
			this.side = source.side;
			this.vertexColors = source.vertexColors;
			this.opacity = source.opacity;
			this.format = source.format;
			this.transparent = source.transparent;
			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;
			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;
			this.stencilWriteMask = source.stencilWriteMask;
			this.stencilFunc = source.stencilFunc;
			this.stencilRef = source.stencilRef;
			this.stencilFuncMask = source.stencilFuncMask;
			this.stencilFail = source.stencilFail;
			this.stencilZFail = source.stencilZFail;
			this.stencilZPass = source.stencilZPass;
			this.stencilWrite = source.stencilWrite;
			const srcPlanes = source.clippingPlanes;
			let dstPlanes = null;

			if (srcPlanes !== null) {
				const n = srcPlanes.length;
				dstPlanes = new Array(n);

				for (let i = 0; i !== n; ++i) {
					dstPlanes[i] = srcPlanes[i].clone();
				}
			}

			this.clippingPlanes = dstPlanes;
			this.clipIntersection = source.clipIntersection;
			this.clipShadows = source.clipShadows;
			this.shadowSide = source.shadowSide;
			this.colorWrite = source.colorWrite;
			this.precision = source.precision;
			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;
			this.dithering = source.dithering;
			this.alphaTest = source.alphaTest;
			this.alphaToCoverage = source.alphaToCoverage;
			this.premultipliedAlpha = source.premultipliedAlpha;
			this.visible = source.visible;
			this.toneMapped = source.toneMapped;
			this.userData = JSON.parse(JSON.stringify(source.userData));
			return this;
		}

		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}

		set needsUpdate(value) {
			if (value === true) this.version++;
		}

	}

	Material.prototype.isMaterial = true;

	const _colorKeywords = {
		'aliceblue': 0xF0F8FF,
		'antiquewhite': 0xFAEBD7,
		'aqua': 0x00FFFF,
		'aquamarine': 0x7FFFD4,
		'azure': 0xF0FFFF,
		'beige': 0xF5F5DC,
		'bisque': 0xFFE4C4,
		'black': 0x000000,
		'blanchedalmond': 0xFFEBCD,
		'blue': 0x0000FF,
		'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A,
		'burlywood': 0xDEB887,
		'cadetblue': 0x5F9EA0,
		'chartreuse': 0x7FFF00,
		'chocolate': 0xD2691E,
		'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED,
		'cornsilk': 0xFFF8DC,
		'crimson': 0xDC143C,
		'cyan': 0x00FFFF,
		'darkblue': 0x00008B,
		'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B,
		'darkgray': 0xA9A9A9,
		'darkgreen': 0x006400,
		'darkgrey': 0xA9A9A9,
		'darkkhaki': 0xBDB76B,
		'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F,
		'darkorange': 0xFF8C00,
		'darkorchid': 0x9932CC,
		'darkred': 0x8B0000,
		'darksalmon': 0xE9967A,
		'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B,
		'darkslategray': 0x2F4F4F,
		'darkslategrey': 0x2F4F4F,
		'darkturquoise': 0x00CED1,
		'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493,
		'deepskyblue': 0x00BFFF,
		'dimgray': 0x696969,
		'dimgrey': 0x696969,
		'dodgerblue': 0x1E90FF,
		'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0,
		'forestgreen': 0x228B22,
		'fuchsia': 0xFF00FF,
		'gainsboro': 0xDCDCDC,
		'ghostwhite': 0xF8F8FF,
		'gold': 0xFFD700,
		'goldenrod': 0xDAA520,
		'gray': 0x808080,
		'green': 0x008000,
		'greenyellow': 0xADFF2F,
		'grey': 0x808080,
		'honeydew': 0xF0FFF0,
		'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C,
		'indigo': 0x4B0082,
		'ivory': 0xFFFFF0,
		'khaki': 0xF0E68C,
		'lavender': 0xE6E6FA,
		'lavenderblush': 0xFFF0F5,
		'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD,
		'lightblue': 0xADD8E6,
		'lightcoral': 0xF08080,
		'lightcyan': 0xE0FFFF,
		'lightgoldenrodyellow': 0xFAFAD2,
		'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90,
		'lightgrey': 0xD3D3D3,
		'lightpink': 0xFFB6C1,
		'lightsalmon': 0xFFA07A,
		'lightseagreen': 0x20B2AA,
		'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899,
		'lightslategrey': 0x778899,
		'lightsteelblue': 0xB0C4DE,
		'lightyellow': 0xFFFFE0,
		'lime': 0x00FF00,
		'limegreen': 0x32CD32,
		'linen': 0xFAF0E6,
		'magenta': 0xFF00FF,
		'maroon': 0x800000,
		'mediumaquamarine': 0x66CDAA,
		'mediumblue': 0x0000CD,
		'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB,
		'mediumseagreen': 0x3CB371,
		'mediumslateblue': 0x7B68EE,
		'mediumspringgreen': 0x00FA9A,
		'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585,
		'midnightblue': 0x191970,
		'mintcream': 0xF5FFFA,
		'mistyrose': 0xFFE4E1,
		'moccasin': 0xFFE4B5,
		'navajowhite': 0xFFDEAD,
		'navy': 0x000080,
		'oldlace': 0xFDF5E6,
		'olive': 0x808000,
		'olivedrab': 0x6B8E23,
		'orange': 0xFFA500,
		'orangered': 0xFF4500,
		'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA,
		'palegreen': 0x98FB98,
		'paleturquoise': 0xAFEEEE,
		'palevioletred': 0xDB7093,
		'papayawhip': 0xFFEFD5,
		'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F,
		'pink': 0xFFC0CB,
		'plum': 0xDDA0DD,
		'powderblue': 0xB0E0E6,
		'purple': 0x800080,
		'rebeccapurple': 0x663399,
		'red': 0xFF0000,
		'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1,
		'saddlebrown': 0x8B4513,
		'salmon': 0xFA8072,
		'sandybrown': 0xF4A460,
		'seagreen': 0x2E8B57,
		'seashell': 0xFFF5EE,
		'sienna': 0xA0522D,
		'silver': 0xC0C0C0,
		'skyblue': 0x87CEEB,
		'slateblue': 0x6A5ACD,
		'slategray': 0x708090,
		'slategrey': 0x708090,
		'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F,
		'steelblue': 0x4682B4,
		'tan': 0xD2B48C,
		'teal': 0x008080,
		'thistle': 0xD8BFD8,
		'tomato': 0xFF6347,
		'turquoise': 0x40E0D0,
		'violet': 0xEE82EE,
		'wheat': 0xF5DEB3,
		'white': 0xFFFFFF,
		'whitesmoke': 0xF5F5F5,
		'yellow': 0xFFFF00,
		'yellowgreen': 0x9ACD32
	};
	const _hslA = {
		h: 0,
		s: 0,
		l: 0
	};
	const _hslB = {
		h: 0,
		s: 0,
		l: 0
	};

	function hue2rgb(p, q, t) {
		if (t < 0) t += 1;
		if (t > 1) t -= 1;
		if (t < 1 / 6) return p + (q - p) * 6 * t;
		if (t < 1 / 2) return q;
		if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
		return p;
	}

	function SRGBToLinear(c) {
		return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
	}

	function LinearToSRGB(c) {
		return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
	}

	class Color {
		constructor(r, g, b) {
			if (g === undefined && b === undefined) {
				// r is THREE.Color, hex or string
				return this.set(r);
			}

			return this.setRGB(r, g, b);
		}

		set(value) {
			if (value && value.isColor) {
				this.copy(value);
			} else if (typeof value === 'number') {
				this.setHex(value);
			} else if (typeof value === 'string') {
				this.setStyle(value);
			}

			return this;
		}

		setScalar(scalar) {
			this.r = scalar;
			this.g = scalar;
			this.b = scalar;
			return this;
		}

		setHex(hex) {
			hex = Math.floor(hex);
			this.r = (hex >> 16 & 255) / 255;
			this.g = (hex >> 8 & 255) / 255;
			this.b = (hex & 255) / 255;
			return this;
		}

		setRGB(r, g, b) {
			this.r = r;
			this.g = g;
			this.b = b;
			return this;
		}

		setHSL(h, s, l) {
			// h,s,l ranges are in 0.0 - 1.0
			h = euclideanModulo(h, 1);
			s = clamp(s, 0, 1);
			l = clamp(l, 0, 1);

			if (s === 0) {
				this.r = this.g = this.b = l;
			} else {
				const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
				const q = 2 * l - p;
				this.r = hue2rgb(q, p, h + 1 / 3);
				this.g = hue2rgb(q, p, h);
				this.b = hue2rgb(q, p, h - 1 / 3);
			}

			return this;
		}

		setStyle(style) {
			function handleAlpha(string) {
				if (string === undefined) return;

				if (parseFloat(string) < 1) {
					console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
				}
			}

			let m;

			if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
				// rgb / hsl
				let color;
				const name = m[1];
				const components = m[2];

				switch (name) {
					case 'rgb':
					case 'rgba':
						if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min(255, parseInt(color[1], 10)) / 255;
							this.g = Math.min(255, parseInt(color[2], 10)) / 255;
							this.b = Math.min(255, parseInt(color[3], 10)) / 255;
							handleAlpha(color[4]);
							return this;
						}

						if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min(100, parseInt(color[1], 10)) / 100;
							this.g = Math.min(100, parseInt(color[2], 10)) / 100;
							this.b = Math.min(100, parseInt(color[3], 10)) / 100;
							handleAlpha(color[4]);
							return this;
						}

						break;

					case 'hsl':
					case 'hsla':
						if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							const h = parseFloat(color[1]) / 360;
							const s = parseInt(color[2], 10) / 100;
							const l = parseInt(color[3], 10) / 100;
							handleAlpha(color[4]);
							return this.setHSL(h, s, l);
						}

						break;
				}
			} else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
				// hex color
				const hex = m[1];
				const size = hex.length;

				if (size === 3) {
					// #ff0
					this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
					this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
					this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
					return this;
				} else if (size === 6) {
					// #ff0000
					this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
					this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
					this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
					return this;
				}
			}

			if (style && style.length > 0) {
				return this.setColorName(style);
			}

			return this;
		}

		setColorName(style) {
			// color keywords
			const hex = _colorKeywords[style.toLowerCase()];

			if (hex !== undefined) {
				// red
				this.setHex(hex);
			} else {
				// unknown color
				console.warn('THREE.Color: Unknown color ' + style);
			}

			return this;
		}

		clone() {
			return new this.constructor(this.r, this.g, this.b);
		}

		copy(color) {
			this.r = color.r;
			this.g = color.g;
			this.b = color.b;
			return this;
		}

		copyGammaToLinear(color, gammaFactor = 2.0) {
			this.r = Math.pow(color.r, gammaFactor);
			this.g = Math.pow(color.g, gammaFactor);
			this.b = Math.pow(color.b, gammaFactor);
			return this;
		}

		copyLinearToGamma(color, gammaFactor = 2.0) {
			const safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;
			this.r = Math.pow(color.r, safeInverse);
			this.g = Math.pow(color.g, safeInverse);
			this.b = Math.pow(color.b, safeInverse);
			return this;
		}

		convertGammaToLinear(gammaFactor) {
			this.copyGammaToLinear(this, gammaFactor);
			return this;
		}

		convertLinearToGamma(gammaFactor) {
			this.copyLinearToGamma(this, gammaFactor);
			return this;
		}

		copySRGBToLinear(color) {
			this.r = SRGBToLinear(color.r);
			this.g = SRGBToLinear(color.g);
			this.b = SRGBToLinear(color.b);
			return this;
		}

		copyLinearToSRGB(color) {
			this.r = LinearToSRGB(color.r);
			this.g = LinearToSRGB(color.g);
			this.b = LinearToSRGB(color.b);
			return this;
		}

		convertSRGBToLinear() {
			this.copySRGBToLinear(this);
			return this;
		}

		convertLinearToSRGB() {
			this.copyLinearToSRGB(this);
			return this;
		}

		getHex() {
			return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
		}

		getHexString() {
			return ('000000' + this.getHex().toString(16)).slice(-6);
		}

		getHSL(target) {
			// h,s,l ranges are in 0.0 - 1.0
			const r = this.r,
						g = this.g,
						b = this.b;
			const max = Math.max(r, g, b);
			const min = Math.min(r, g, b);
			let hue, saturation;
			const lightness = (min + max) / 2.0;

			if (min === max) {
				hue = 0;
				saturation = 0;
			} else {
				const delta = max - min;
				saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);

				switch (max) {
					case r:
						hue = (g - b) / delta + (g < b ? 6 : 0);
						break;

					case g:
						hue = (b - r) / delta + 2;
						break;

					case b:
						hue = (r - g) / delta + 4;
						break;
				}

				hue /= 6;
			}

			target.h = hue;
			target.s = saturation;
			target.l = lightness;
			return target;
		}

		getStyle() {
			return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
		}

		offsetHSL(h, s, l) {
			this.getHSL(_hslA);
			_hslA.h += h;
			_hslA.s += s;
			_hslA.l += l;
			this.setHSL(_hslA.h, _hslA.s, _hslA.l);
			return this;
		}

		add(color) {
			this.r += color.r;
			this.g += color.g;
			this.b += color.b;
			return this;
		}

		addColors(color1, color2) {
			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;
			return this;
		}

		addScalar(s) {
			this.r += s;
			this.g += s;
			this.b += s;
			return this;
		}

		sub(color) {
			this.r = Math.max(0, this.r - color.r);
			this.g = Math.max(0, this.g - color.g);
			this.b = Math.max(0, this.b - color.b);
			return this;
		}

		multiply(color) {
			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;
			return this;
		}

		multiplyScalar(s) {
			this.r *= s;
			this.g *= s;
			this.b *= s;
			return this;
		}

		lerp(color, alpha) {
			this.r += (color.r - this.r) * alpha;
			this.g += (color.g - this.g) * alpha;
			this.b += (color.b - this.b) * alpha;
			return this;
		}

		lerpColors(color1, color2, alpha) {
			this.r = color1.r + (color2.r - color1.r) * alpha;
			this.g = color1.g + (color2.g - color1.g) * alpha;
			this.b = color1.b + (color2.b - color1.b) * alpha;
			return this;
		}

		lerpHSL(color, alpha) {
			this.getHSL(_hslA);
			color.getHSL(_hslB);
			const h = lerp(_hslA.h, _hslB.h, alpha);
			const s = lerp(_hslA.s, _hslB.s, alpha);
			const l = lerp(_hslA.l, _hslB.l, alpha);
			this.setHSL(h, s, l);
			return this;
		}

		equals(c) {
			return c.r === this.r && c.g === this.g && c.b === this.b;
		}

		fromArray(array, offset = 0) {
			this.r = array[offset];
			this.g = array[offset + 1];
			this.b = array[offset + 2];
			return this;
		}

		toArray(array = [], offset = 0) {
			array[offset] = this.r;
			array[offset + 1] = this.g;
			array[offset + 2] = this.b;
			return array;
		}

		fromBufferAttribute(attribute, index) {
			this.r = attribute.getX(index);
			this.g = attribute.getY(index);
			this.b = attribute.getZ(index);

			if (attribute.normalized === true) {
				// assuming Uint8Array
				this.r /= 255;
				this.g /= 255;
				this.b /= 255;
			}

			return this;
		}

		toJSON() {
			return this.getHex();
		}

	}

	Color.NAMES = _colorKeywords;
	Color.prototype.isColor = true;
	Color.prototype.r = 1;
	Color.prototype.g = 1;
	Color.prototype.b = 1;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	specularMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	combine: THREE.Multiply,
	 *	reflectivity: <float>,
	 *	refractionRatio: <float>,
	 *
	 *	depthTest: <bool>,
	 *	depthWrite: <bool>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 * }
	 */

	class MeshBasicMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'MeshBasicMaterial';
			this.color = new Color(0xffffff); // emissive

			this.map = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.specularMap = null;
			this.alphaMap = null;
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.specularMap = source.specularMap;
			this.alphaMap = source.alphaMap;
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			return this;
		}

	}

	MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

	const _vector$9 = /*@__PURE__*/new Vector3();

	const _vector2$1 = /*@__PURE__*/new Vector2();

	class BufferAttribute {
		constructor(array, itemSize, normalized) {
			if (Array.isArray(array)) {
				throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
			}

			this.name = '';
			this.array = array;
			this.itemSize = itemSize;
			this.count = array !== undefined ? array.length / itemSize : 0;
			this.normalized = normalized === true;
			this.usage = StaticDrawUsage;
			this.updateRange = {
				offset: 0,
				count: -1
			};
			this.version = 0;
		}

		onUploadCallback() {}

		set needsUpdate(value) {
			if (value === true) this.version++;
		}

		setUsage(value) {
			this.usage = value;
			return this;
		}

		copy(source) {
			this.name = source.name;
			this.array = new source.array.constructor(source.array);
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;
			this.usage = source.usage;
			return this;
		}

		copyAt(index1, attribute, index2) {
			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for (let i = 0, l = this.itemSize; i < l; i++) {
				this.array[index1 + i] = attribute.array[index2 + i];
			}

			return this;
		}

		copyArray(array) {
			this.array.set(array);
			return this;
		}

		copyColorsArray(colors) {
			const array = this.array;
			let offset = 0;

			for (let i = 0, l = colors.length; i < l; i++) {
				let color = colors[i];

				if (color === undefined) {
					console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
					color = new Color();
				}

				array[offset++] = color.r;
				array[offset++] = color.g;
				array[offset++] = color.b;
			}

			return this;
		}

		copyVector2sArray(vectors) {
			const array = this.array;
			let offset = 0;

			for (let i = 0, l = vectors.length; i < l; i++) {
				let vector = vectors[i];

				if (vector === undefined) {
					console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
					vector = new Vector2();
				}

				array[offset++] = vector.x;
				array[offset++] = vector.y;
			}

			return this;
		}

		copyVector3sArray(vectors) {
			const array = this.array;
			let offset = 0;

			for (let i = 0, l = vectors.length; i < l; i++) {
				let vector = vectors[i];

				if (vector === undefined) {
					console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
					vector = new Vector3();
				}

				array[offset++] = vector.x;
				array[offset++] = vector.y;
				array[offset++] = vector.z;
			}

			return this;
		}

		copyVector4sArray(vectors) {
			const array = this.array;
			let offset = 0;

			for (let i = 0, l = vectors.length; i < l; i++) {
				let vector = vectors[i];

				if (vector === undefined) {
					console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
					vector = new Vector4();
				}

				array[offset++] = vector.x;
				array[offset++] = vector.y;
				array[offset++] = vector.z;
				array[offset++] = vector.w;
			}

			return this;
		}

		applyMatrix3(m) {
			if (this.itemSize === 2) {
				for (let i = 0, l = this.count; i < l; i++) {
					_vector2$1.fromBufferAttribute(this, i);

					_vector2$1.applyMatrix3(m);

					this.setXY(i, _vector2$1.x, _vector2$1.y);
				}
			} else if (this.itemSize === 3) {
				for (let i = 0, l = this.count; i < l; i++) {
					_vector$9.fromBufferAttribute(this, i);

					_vector$9.applyMatrix3(m);

					this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
				}
			}

			return this;
		}

		applyMatrix4(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$9.x = this.getX(i);
				_vector$9.y = this.getY(i);
				_vector$9.z = this.getZ(i);

				_vector$9.applyMatrix4(m);

				this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
			}

			return this;
		}

		applyNormalMatrix(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$9.x = this.getX(i);
				_vector$9.y = this.getY(i);
				_vector$9.z = this.getZ(i);

				_vector$9.applyNormalMatrix(m);

				this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
			}

			return this;
		}

		transformDirection(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$9.x = this.getX(i);
				_vector$9.y = this.getY(i);
				_vector$9.z = this.getZ(i);

				_vector$9.transformDirection(m);

				this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
			}

			return this;
		}

		set(value, offset = 0) {
			this.array.set(value, offset);
			return this;
		}

		getX(index) {
			return this.array[index * this.itemSize];
		}

		setX(index, x) {
			this.array[index * this.itemSize] = x;
			return this;
		}

		getY(index) {
			return this.array[index * this.itemSize + 1];
		}

		setY(index, y) {
			this.array[index * this.itemSize + 1] = y;
			return this;
		}

		getZ(index) {
			return this.array[index * this.itemSize + 2];
		}

		setZ(index, z) {
			this.array[index * this.itemSize + 2] = z;
			return this;
		}

		getW(index) {
			return this.array[index * this.itemSize + 3];
		}

		setW(index, w) {
			this.array[index * this.itemSize + 3] = w;
			return this;
		}

		setXY(index, x, y) {
			index *= this.itemSize;
			this.array[index + 0] = x;
			this.array[index + 1] = y;
			return this;
		}

		setXYZ(index, x, y, z) {
			index *= this.itemSize;
			this.array[index + 0] = x;
			this.array[index + 1] = y;
			this.array[index + 2] = z;
			return this;
		}

		setXYZW(index, x, y, z, w) {
			index *= this.itemSize;
			this.array[index + 0] = x;
			this.array[index + 1] = y;
			this.array[index + 2] = z;
			this.array[index + 3] = w;
			return this;
		}

		onUpload(callback) {
			this.onUploadCallback = callback;
			return this;
		}

		clone() {
			return new this.constructor(this.array, this.itemSize).copy(this);
		}

		toJSON() {
			const data = {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: Array.prototype.slice.call(this.array),
				normalized: this.normalized
			};
			if (this.name !== '') data.name = this.name;
			if (this.usage !== StaticDrawUsage) data.usage = this.usage;
			if (this.updateRange.offset !== 0 || this.updateRange.count !== -1) data.updateRange = this.updateRange;
			return data;
		}

	}

	BufferAttribute.prototype.isBufferAttribute = true; //

	class Int8BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Int8Array(array), itemSize, normalized);
		}

	}

	class Uint8BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint8Array(array), itemSize, normalized);
		}

	}

	class Uint8ClampedBufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint8ClampedArray(array), itemSize, normalized);
		}

	}

	class Int16BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Int16Array(array), itemSize, normalized);
		}

	}

	class Uint16BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint16Array(array), itemSize, normalized);
		}

	}

	class Int32BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Int32Array(array), itemSize, normalized);
		}

	}

	class Uint32BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint32Array(array), itemSize, normalized);
		}

	}

	class Float16BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint16Array(array), itemSize, normalized);
		}

	}

	Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;

	class Float32BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Float32Array(array), itemSize, normalized);
		}

	}

	class Float64BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Float64Array(array), itemSize, normalized);
		}

	} //

	let _id = 0;

	const _m1 = /*@__PURE__*/new Matrix4();

	const _obj = /*@__PURE__*/new Object3D();

	const _offset = /*@__PURE__*/new Vector3();

	const _box$1 = /*@__PURE__*/new Box3();

	const _boxMorphTargets = /*@__PURE__*/new Box3();

	const _vector$8 = /*@__PURE__*/new Vector3();

	class BufferGeometry extends EventDispatcher {
		constructor() {
			super();
			Object.defineProperty(this, 'id', {
				value: _id++
			});
			this.uuid = generateUUID();
			this.name = '';
			this.type = 'BufferGeometry';
			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.morphTargetsRelative = false;
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null;
			this.drawRange = {
				start: 0,
				count: Infinity
			};
			this.userData = {};
		}

		getIndex() {
			return this.index;
		}

		setIndex(index) {
			if (Array.isArray(index)) {
				this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
			} else {
				this.index = index;
			}

			return this;
		}

		getAttribute(name) {
			return this.attributes[name];
		}

		setAttribute(name, attribute) {
			this.attributes[name] = attribute;
			return this;
		}

		deleteAttribute(name) {
			delete this.attributes[name];
			return this;
		}

		hasAttribute(name) {
			return this.attributes[name] !== undefined;
		}

		addGroup(start, count, materialIndex = 0) {
			this.groups.push({
				start: start,
				count: count,
				materialIndex: materialIndex
			});
		}

		clearGroups() {
			this.groups = [];
		}

		setDrawRange(start, count) {
			this.drawRange.start = start;
			this.drawRange.count = count;
		}

		applyMatrix4(matrix) {
			const position = this.attributes.position;

			if (position !== undefined) {
				position.applyMatrix4(matrix);
				position.needsUpdate = true;
			}

			const normal = this.attributes.normal;

			if (normal !== undefined) {
				const normalMatrix = new Matrix3().getNormalMatrix(matrix);
				normal.applyNormalMatrix(normalMatrix);
				normal.needsUpdate = true;
			}

			const tangent = this.attributes.tangent;

			if (tangent !== undefined) {
				tangent.transformDirection(matrix);
				tangent.needsUpdate = true;
			}

			if (this.boundingBox !== null) {
				this.computeBoundingBox();
			}

			if (this.boundingSphere !== null) {
				this.computeBoundingSphere();
			}

			return this;
		}

		applyQuaternion(q) {
			_m1.makeRotationFromQuaternion(q);

			this.applyMatrix4(_m1);
			return this;
		}

		rotateX(angle) {
			// rotate geometry around world x-axis
			_m1.makeRotationX(angle);

			this.applyMatrix4(_m1);
			return this;
		}

		rotateY(angle) {
			// rotate geometry around world y-axis
			_m1.makeRotationY(angle);

			this.applyMatrix4(_m1);
			return this;
		}

		rotateZ(angle) {
			// rotate geometry around world z-axis
			_m1.makeRotationZ(angle);

			this.applyMatrix4(_m1);
			return this;
		}

		translate(x, y, z) {
			// translate geometry
			_m1.makeTranslation(x, y, z);

			this.applyMatrix4(_m1);
			return this;
		}

		scale(x, y, z) {
			// scale geometry
			_m1.makeScale(x, y, z);

			this.applyMatrix4(_m1);
			return this;
		}

		lookAt(vector) {
			_obj.lookAt(vector);

			_obj.updateMatrix();

			this.applyMatrix4(_obj.matrix);
			return this;
		}

		center() {
			this.computeBoundingBox();
			this.boundingBox.getCenter(_offset).negate();
			this.translate(_offset.x, _offset.y, _offset.z);
			return this;
		}

		setFromPoints(points) {
			const position = [];

			for (let i = 0, l = points.length; i < l; i++) {
				const point = points[i];
				position.push(point.x, point.y, point.z || 0);
			}

			this.setAttribute('position', new Float32BufferAttribute(position, 3));
			return this;
		}

		computeBoundingBox() {
			if (this.boundingBox === null) {
				this.boundingBox = new Box3();
			}

			const position = this.attributes.position;
			const morphAttributesPosition = this.morphAttributes.position;

			if (position && position.isGLBufferAttribute) {
				console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
				this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));
				return;
			}

			if (position !== undefined) {
				this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present

				if (morphAttributesPosition) {
					for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
						const morphAttribute = morphAttributesPosition[i];

						_box$1.setFromBufferAttribute(morphAttribute);

						if (this.morphTargetsRelative) {
							_vector$8.addVectors(this.boundingBox.min, _box$1.min);

							this.boundingBox.expandByPoint(_vector$8);

							_vector$8.addVectors(this.boundingBox.max, _box$1.max);

							this.boundingBox.expandByPoint(_vector$8);
						} else {
							this.boundingBox.expandByPoint(_box$1.min);
							this.boundingBox.expandByPoint(_box$1.max);
						}
					}
				}
			} else {
				this.boundingBox.makeEmpty();
			}

			if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
				console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
			}
		}

		computeBoundingSphere() {
			if (this.boundingSphere === null) {
				this.boundingSphere = new Sphere();
			}

			const position = this.attributes.position;
			const morphAttributesPosition = this.morphAttributes.position;

			if (position && position.isGLBufferAttribute) {
				console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
				this.boundingSphere.set(new Vector3(), Infinity);
				return;
			}

			if (position) {
				// first, find the center of the bounding sphere
				const center = this.boundingSphere.center;

				_box$1.setFromBufferAttribute(position); // process morph attributes if present


				if (morphAttributesPosition) {
					for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
						const morphAttribute = morphAttributesPosition[i];

						_boxMorphTargets.setFromBufferAttribute(morphAttribute);

						if (this.morphTargetsRelative) {
							_vector$8.addVectors(_box$1.min, _boxMorphTargets.min);

							_box$1.expandByPoint(_vector$8);

							_vector$8.addVectors(_box$1.max, _boxMorphTargets.max);

							_box$1.expandByPoint(_vector$8);
						} else {
							_box$1.expandByPoint(_boxMorphTargets.min);

							_box$1.expandByPoint(_boxMorphTargets.max);
						}
					}
				}

				_box$1.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case


				let maxRadiusSq = 0;

				for (let i = 0, il = position.count; i < il; i++) {
					_vector$8.fromBufferAttribute(position, i);

					maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
				} // process morph attributes if present


				if (morphAttributesPosition) {
					for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
						const morphAttribute = morphAttributesPosition[i];
						const morphTargetsRelative = this.morphTargetsRelative;

						for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
							_vector$8.fromBufferAttribute(morphAttribute, j);

							if (morphTargetsRelative) {
								_offset.fromBufferAttribute(position, j);

								_vector$8.add(_offset);
							}

							maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
						}
					}
				}

				this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

				if (isNaN(this.boundingSphere.radius)) {
					console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
				}
			}
		}

		computeTangents() {
			const index = this.index;
			const attributes = this.attributes; // based on http://www.terathon.com/code/tangent.html
			// (per vertex tangents)

			if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
				console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
				return;
			}

			const indices = index.array;
			const positions = attributes.position.array;
			const normals = attributes.normal.array;
			const uvs = attributes.uv.array;
			const nVertices = positions.length / 3;

			if (attributes.tangent === undefined) {
				this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));
			}

			const tangents = attributes.tangent.array;
			const tan1 = [],
						tan2 = [];

			for (let i = 0; i < nVertices; i++) {
				tan1[i] = new Vector3();
				tan2[i] = new Vector3();
			}

			const vA = new Vector3(),
						vB = new Vector3(),
						vC = new Vector3(),
						uvA = new Vector2(),
						uvB = new Vector2(),
						uvC = new Vector2(),
						sdir = new Vector3(),
						tdir = new Vector3();

			function handleTriangle(a, b, c) {
				vA.fromArray(positions, a * 3);
				vB.fromArray(positions, b * 3);
				vC.fromArray(positions, c * 3);
				uvA.fromArray(uvs, a * 2);
				uvB.fromArray(uvs, b * 2);
				uvC.fromArray(uvs, c * 2);
				vB.sub(vA);
				vC.sub(vA);
				uvB.sub(uvA);
				uvC.sub(uvA);
				const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices

				if (!isFinite(r)) return;
				sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
				tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
				tan1[a].add(sdir);
				tan1[b].add(sdir);
				tan1[c].add(sdir);
				tan2[a].add(tdir);
				tan2[b].add(tdir);
				tan2[c].add(tdir);
			}

			let groups = this.groups;

			if (groups.length === 0) {
				groups = [{
					start: 0,
					count: indices.length
				}];
			}

			for (let i = 0, il = groups.length; i < il; ++i) {
				const group = groups[i];
				const start = group.start;
				const count = group.count;

				for (let j = start, jl = start + count; j < jl; j += 3) {
					handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
				}
			}

			const tmp = new Vector3(),
						tmp2 = new Vector3();
			const n = new Vector3(),
						n2 = new Vector3();

			function handleVertex(v) {
				n.fromArray(normals, v * 3);
				n2.copy(n);
				const t = tan1[v]; // Gram-Schmidt orthogonalize

				tmp.copy(t);
				tmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness

				tmp2.crossVectors(n2, t);
				const test = tmp2.dot(tan2[v]);
				const w = test < 0.0 ? -1.0 : 1.0;
				tangents[v * 4] = tmp.x;
				tangents[v * 4 + 1] = tmp.y;
				tangents[v * 4 + 2] = tmp.z;
				tangents[v * 4 + 3] = w;
			}

			for (let i = 0, il = groups.length; i < il; ++i) {
				const group = groups[i];
				const start = group.start;
				const count = group.count;

				for (let j = start, jl = start + count; j < jl; j += 3) {
					handleVertex(indices[j + 0]);
					handleVertex(indices[j + 1]);
					handleVertex(indices[j + 2]);
				}
			}
		}

		computeVertexNormals() {
			const index = this.index;
			const positionAttribute = this.getAttribute('position');

			if (positionAttribute !== undefined) {
				let normalAttribute = this.getAttribute('normal');

				if (normalAttribute === undefined) {
					normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
					this.setAttribute('normal', normalAttribute);
				} else {
					// reset existing normals to zero
					for (let i = 0, il = normalAttribute.count; i < il; i++) {
						normalAttribute.setXYZ(i, 0, 0, 0);
					}
				}

				const pA = new Vector3(),
							pB = new Vector3(),
							pC = new Vector3();
				const nA = new Vector3(),
							nB = new Vector3(),
							nC = new Vector3();
				const cb = new Vector3(),
							ab = new Vector3(); // indexed elements

				if (index) {
					for (let i = 0, il = index.count; i < il; i += 3) {
						const vA = index.getX(i + 0);
						const vB = index.getX(i + 1);
						const vC = index.getX(i + 2);
						pA.fromBufferAttribute(positionAttribute, vA);
						pB.fromBufferAttribute(positionAttribute, vB);
						pC.fromBufferAttribute(positionAttribute, vC);
						cb.subVectors(pC, pB);
						ab.subVectors(pA, pB);
						cb.cross(ab);
						nA.fromBufferAttribute(normalAttribute, vA);
						nB.fromBufferAttribute(normalAttribute, vB);
						nC.fromBufferAttribute(normalAttribute, vC);
						nA.add(cb);
						nB.add(cb);
						nC.add(cb);
						normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
						normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
						normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
					}
				} else {
					// non-indexed elements (unconnected triangle soup)
					for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
						pA.fromBufferAttribute(positionAttribute, i + 0);
						pB.fromBufferAttribute(positionAttribute, i + 1);
						pC.fromBufferAttribute(positionAttribute, i + 2);
						cb.subVectors(pC, pB);
						ab.subVectors(pA, pB);
						cb.cross(ab);
						normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
						normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
						normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
					}
				}

				this.normalizeNormals();
				normalAttribute.needsUpdate = true;
			}
		}

		merge(geometry, offset) {
			if (!(geometry && geometry.isBufferGeometry)) {
				console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
				return;
			}

			if (offset === undefined) {
				offset = 0;
				console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');
			}

			const attributes = this.attributes;

			for (const key in attributes) {
				if (geometry.attributes[key] === undefined) continue;
				const attribute1 = attributes[key];
				const attributeArray1 = attribute1.array;
				const attribute2 = geometry.attributes[key];
				const attributeArray2 = attribute2.array;
				const attributeOffset = attribute2.itemSize * offset;
				const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);

				for (let i = 0, j = attributeOffset; i < length; i++, j++) {
					attributeArray1[j] = attributeArray2[i];
				}
			}

			return this;
		}

		normalizeNormals() {
			const normals = this.attributes.normal;

			for (let i = 0, il = normals.count; i < il; i++) {
				_vector$8.fromBufferAttribute(normals, i);

				_vector$8.normalize();

				normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
			}
		}

		toNonIndexed() {
			function convertBufferAttribute(attribute, indices) {
				const array = attribute.array;
				const itemSize = attribute.itemSize;
				const normalized = attribute.normalized;
				const array2 = new array.constructor(indices.length * itemSize);
				let index = 0,
						index2 = 0;

				for (let i = 0, l = indices.length; i < l; i++) {
					if (attribute.isInterleavedBufferAttribute) {
						index = indices[i] * attribute.data.stride + attribute.offset;
					} else {
						index = indices[i] * itemSize;
					}

					for (let j = 0; j < itemSize; j++) {
						array2[index2++] = array[index++];
					}
				}

				return new BufferAttribute(array2, itemSize, normalized);
			} //


			if (this.index === null) {
				console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
				return this;
			}

			const geometry2 = new BufferGeometry();
			const indices = this.index.array;
			const attributes = this.attributes; // attributes

			for (const name in attributes) {
				const attribute = attributes[name];
				const newAttribute = convertBufferAttribute(attribute, indices);
				geometry2.setAttribute(name, newAttribute);
			} // morph attributes


			const morphAttributes = this.morphAttributes;

			for (const name in morphAttributes) {
				const morphArray = [];
				const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

				for (let i = 0, il = morphAttribute.length; i < il; i++) {
					const attribute = morphAttribute[i];
					const newAttribute = convertBufferAttribute(attribute, indices);
					morphArray.push(newAttribute);
				}

				geometry2.morphAttributes[name] = morphArray;
			}

			geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups

			const groups = this.groups;

			for (let i = 0, l = groups.length; i < l; i++) {
				const group = groups[i];
				geometry2.addGroup(group.start, group.count, group.materialIndex);
			}

			return geometry2;
		}

		toJSON() {
			const data = {
				metadata: {
					version: 4.5,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			}; // standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if (this.name !== '') data.name = this.name;
			if (Object.keys(this.userData).length > 0) data.userData = this.userData;

			if (this.parameters !== undefined) {
				const parameters = this.parameters;

				for (const key in parameters) {
					if (parameters[key] !== undefined) data[key] = parameters[key];
				}

				return data;
			} // for simplicity the code assumes attributes are not shared across geometries, see #15811


			data.data = {
				attributes: {}
			};
			const index = this.index;

			if (index !== null) {
				data.data.index = {
					type: index.array.constructor.name,
					array: Array.prototype.slice.call(index.array)
				};
			}

			const attributes = this.attributes;

			for (const key in attributes) {
				const attribute = attributes[key];
				data.data.attributes[key] = attribute.toJSON(data.data);
			}

			const morphAttributes = {};
			let hasMorphAttributes = false;

			for (const key in this.morphAttributes) {
				const attributeArray = this.morphAttributes[key];
				const array = [];

				for (let i = 0, il = attributeArray.length; i < il; i++) {
					const attribute = attributeArray[i];
					array.push(attribute.toJSON(data.data));
				}

				if (array.length > 0) {
					morphAttributes[key] = array;
					hasMorphAttributes = true;
				}
			}

			if (hasMorphAttributes) {
				data.data.morphAttributes = morphAttributes;
				data.data.morphTargetsRelative = this.morphTargetsRelative;
			}

			const groups = this.groups;

			if (groups.length > 0) {
				data.data.groups = JSON.parse(JSON.stringify(groups));
			}

			const boundingSphere = this.boundingSphere;

			if (boundingSphere !== null) {
				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};
			}

			return data;
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(source) {
			// reset
			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null; // used for storing cloned, shared data

			const data = {}; // name

			this.name = source.name; // index

			const index = source.index;

			if (index !== null) {
				this.setIndex(index.clone(data));
			} // attributes


			const attributes = source.attributes;

			for (const name in attributes) {
				const attribute = attributes[name];
				this.setAttribute(name, attribute.clone(data));
			} // morph attributes


			const morphAttributes = source.morphAttributes;

			for (const name in morphAttributes) {
				const array = [];
				const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

				for (let i = 0, l = morphAttribute.length; i < l; i++) {
					array.push(morphAttribute[i].clone(data));
				}

				this.morphAttributes[name] = array;
			}

			this.morphTargetsRelative = source.morphTargetsRelative; // groups

			const groups = source.groups;

			for (let i = 0, l = groups.length; i < l; i++) {
				const group = groups[i];
				this.addGroup(group.start, group.count, group.materialIndex);
			} // bounding box


			const boundingBox = source.boundingBox;

			if (boundingBox !== null) {
				this.boundingBox = boundingBox.clone();
			} // bounding sphere


			const boundingSphere = source.boundingSphere;

			if (boundingSphere !== null) {
				this.boundingSphere = boundingSphere.clone();
			} // draw range


			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count; // user data

			this.userData = source.userData; // geometry generator parameters

			if (source.parameters !== undefined) this.parameters = Object.assign({}, source.parameters);
			return this;
		}

		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}

	}

	BufferGeometry.prototype.isBufferGeometry = true;

	const _inverseMatrix$2 = /*@__PURE__*/new Matrix4();

	const _ray$2 = /*@__PURE__*/new Ray();

	const _sphere$3 = /*@__PURE__*/new Sphere();

	const _vA$1 = /*@__PURE__*/new Vector3();

	const _vB$1 = /*@__PURE__*/new Vector3();

	const _vC$1 = /*@__PURE__*/new Vector3();

	const _tempA = /*@__PURE__*/new Vector3();

	const _tempB = /*@__PURE__*/new Vector3();

	const _tempC = /*@__PURE__*/new Vector3();

	const _morphA = /*@__PURE__*/new Vector3();

	const _morphB = /*@__PURE__*/new Vector3();

	const _morphC = /*@__PURE__*/new Vector3();

	const _uvA$1 = /*@__PURE__*/new Vector2();

	const _uvB$1 = /*@__PURE__*/new Vector2();

	const _uvC$1 = /*@__PURE__*/new Vector2();

	const _intersectionPoint = /*@__PURE__*/new Vector3();

	const _intersectionPointWorld = /*@__PURE__*/new Vector3();

	class Mesh extends Object3D {
		constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
			super();
			this.type = 'Mesh';
			this.geometry = geometry;
			this.material = material;
			this.updateMorphTargets();
		}

		copy(source) {
			super.copy(source);

			if (source.morphTargetInfluences !== undefined) {
				this.morphTargetInfluences = source.morphTargetInfluences.slice();
			}

			if (source.morphTargetDictionary !== undefined) {
				this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
			}

			this.material = source.material;
			this.geometry = source.geometry;
			return this;
		}

		updateMorphTargets() {
			const geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				const morphAttributes = geometry.morphAttributes;
				const keys = Object.keys(morphAttributes);

				if (keys.length > 0) {
					const morphAttribute = morphAttributes[keys[0]];

					if (morphAttribute !== undefined) {
						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
							const name = morphAttribute[m].name || String(m);
							this.morphTargetInfluences.push(0);
							this.morphTargetDictionary[name] = m;
						}
					}
				}
			} else {
				const morphTargets = geometry.morphTargets;

				if (morphTargets !== undefined && morphTargets.length > 0) {
					console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
				}
			}
		}

		raycast(raycaster, intersects) {
			const geometry = this.geometry;
			const material = this.material;
			const matrixWorld = this.matrixWorld;
			if (material === undefined) return; // Checking boundingSphere distance to ray

			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			_sphere$3.copy(geometry.boundingSphere);

			_sphere$3.applyMatrix4(matrixWorld);

			if (raycaster.ray.intersectsSphere(_sphere$3) === false) return; //

			_inverseMatrix$2.copy(matrixWorld).invert();

			_ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2); // Check boundingBox before continuing


			if (geometry.boundingBox !== null) {
				if (_ray$2.intersectsBox(geometry.boundingBox) === false) return;
			}

			let intersection;

			if (geometry.isBufferGeometry) {
				const index = geometry.index;
				const position = geometry.attributes.position;
				const morphPosition = geometry.morphAttributes.position;
				const morphTargetsRelative = geometry.morphTargetsRelative;
				const uv = geometry.attributes.uv;
				const uv2 = geometry.attributes.uv2;
				const groups = geometry.groups;
				const drawRange = geometry.drawRange;

				if (index !== null) {
					// indexed buffer geometry
					if (Array.isArray(material)) {
						for (let i = 0, il = groups.length; i < il; i++) {
							const group = groups[i];
							const groupMaterial = material[group.materialIndex];
							const start = Math.max(group.start, drawRange.start);
							const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));

							for (let j = start, jl = end; j < jl; j += 3) {
								const a = index.getX(j);
								const b = index.getX(j + 1);
								const c = index.getX(j + 2);
								intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

								if (intersection) {
									intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics

									intersection.face.materialIndex = group.materialIndex;
									intersects.push(intersection);
								}
							}
						}
					} else {
						const start = Math.max(0, drawRange.start);
						const end = Math.min(index.count, drawRange.start + drawRange.count);

						for (let i = start, il = end; i < il; i += 3) {
							const a = index.getX(i);
							const b = index.getX(i + 1);
							const c = index.getX(i + 2);
							intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

							if (intersection) {
								intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics

								intersects.push(intersection);
							}
						}
					}
				} else if (position !== undefined) {
					// non-indexed buffer geometry
					if (Array.isArray(material)) {
						for (let i = 0, il = groups.length; i < il; i++) {
							const group = groups[i];
							const groupMaterial = material[group.materialIndex];
							const start = Math.max(group.start, drawRange.start);
							const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));

							for (let j = start, jl = end; j < jl; j += 3) {
								const a = j;
								const b = j + 1;
								const c = j + 2;
								intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

								if (intersection) {
									intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics

									intersection.face.materialIndex = group.materialIndex;
									intersects.push(intersection);
								}
							}
						}
					} else {
						const start = Math.max(0, drawRange.start);
						const end = Math.min(position.count, drawRange.start + drawRange.count);

						for (let i = start, il = end; i < il; i += 3) {
							const a = i;
							const b = i + 1;
							const c = i + 2;
							intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

							if (intersection) {
								intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics

								intersects.push(intersection);
							}
						}
					}
				}
			} else if (geometry.isGeometry) {
				console.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}
		}

	}

	Mesh.prototype.isMesh = true;

	function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
		let intersect;

		if (material.side === BackSide) {
			intersect = ray.intersectTriangle(pC, pB, pA, true, point);
		} else {
			intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
		}

		if (intersect === null) return null;

		_intersectionPointWorld.copy(point);

		_intersectionPointWorld.applyMatrix4(object.matrixWorld);

		const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
		if (distance < raycaster.near || distance > raycaster.far) return null;
		return {
			distance: distance,
			point: _intersectionPointWorld.clone(),
			object: object
		};
	}

	function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
		_vA$1.fromBufferAttribute(position, a);

		_vB$1.fromBufferAttribute(position, b);

		_vC$1.fromBufferAttribute(position, c);

		const morphInfluences = object.morphTargetInfluences;

		if (morphPosition && morphInfluences) {
			_morphA.set(0, 0, 0);

			_morphB.set(0, 0, 0);

			_morphC.set(0, 0, 0);

			for (let i = 0, il = morphPosition.length; i < il; i++) {
				const influence = morphInfluences[i];
				const morphAttribute = morphPosition[i];
				if (influence === 0) continue;

				_tempA.fromBufferAttribute(morphAttribute, a);

				_tempB.fromBufferAttribute(morphAttribute, b);

				_tempC.fromBufferAttribute(morphAttribute, c);

				if (morphTargetsRelative) {
					_morphA.addScaledVector(_tempA, influence);

					_morphB.addScaledVector(_tempB, influence);

					_morphC.addScaledVector(_tempC, influence);
				} else {
					_morphA.addScaledVector(_tempA.sub(_vA$1), influence);

					_morphB.addScaledVector(_tempB.sub(_vB$1), influence);

					_morphC.addScaledVector(_tempC.sub(_vC$1), influence);
				}
			}

			_vA$1.add(_morphA);

			_vB$1.add(_morphB);

			_vC$1.add(_morphC);
		}

		if (object.isSkinnedMesh) {
			object.boneTransform(a, _vA$1);
			object.boneTransform(b, _vB$1);
			object.boneTransform(c, _vC$1);
		}

		const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);

		if (intersection) {
			if (uv) {
				_uvA$1.fromBufferAttribute(uv, a);

				_uvB$1.fromBufferAttribute(uv, b);

				_uvC$1.fromBufferAttribute(uv, c);

				intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
			}

			if (uv2) {
				_uvA$1.fromBufferAttribute(uv2, a);

				_uvB$1.fromBufferAttribute(uv2, b);

				_uvC$1.fromBufferAttribute(uv2, c);

				intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
			}

			const face = {
				a: a,
				b: b,
				c: c,
				normal: new Vector3(),
				materialIndex: 0
			};
			Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
			intersection.face = face;
		}

		return intersection;
	}

	class BoxGeometry extends BufferGeometry {
		constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
			super();
			this.type = 'BoxGeometry';
			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};
			const scope = this; // segments

			widthSegments = Math.floor(widthSegments);
			heightSegments = Math.floor(heightSegments);
			depthSegments = Math.floor(depthSegments); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // helper variables

			let numberOfVertices = 0;
			let groupStart = 0; // build each side of the box geometry

			buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px

			buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx

			buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py

			buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny

			buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz

			buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
			// build geometry

			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

			function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
				const segmentWidth = width / gridX;
				const segmentHeight = height / gridY;
				const widthHalf = width / 2;
				const heightHalf = height / 2;
				const depthHalf = depth / 2;
				const gridX1 = gridX + 1;
				const gridY1 = gridY + 1;
				let vertexCounter = 0;
				let groupCount = 0;
				const vector = new Vector3(); // generate vertices, normals and uvs

				for (let iy = 0; iy < gridY1; iy++) {
					const y = iy * segmentHeight - heightHalf;

					for (let ix = 0; ix < gridX1; ix++) {
						const x = ix * segmentWidth - widthHalf; // set values to correct vector component

						vector[u] = x * udir;
						vector[v] = y * vdir;
						vector[w] = depthHalf; // now apply vector to vertex buffer

						vertices.push(vector.x, vector.y, vector.z); // set values to correct vector component

						vector[u] = 0;
						vector[v] = 0;
						vector[w] = depth > 0 ? 1 : -1; // now apply vector to normal buffer

						normals.push(vector.x, vector.y, vector.z); // uvs

						uvs.push(ix / gridX);
						uvs.push(1 - iy / gridY); // counters

						vertexCounter += 1;
					}
				} // indices
				// 1. you need three indices to draw a single face
				// 2. a single segment consists of two faces
				// 3. so we need to generate six (2*3) indices per segment


				for (let iy = 0; iy < gridY; iy++) {
					for (let ix = 0; ix < gridX; ix++) {
						const a = numberOfVertices + ix + gridX1 * iy;
						const b = numberOfVertices + ix + gridX1 * (iy + 1);
						const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
						const d = numberOfVertices + (ix + 1) + gridX1 * iy; // faces

						indices.push(a, b, d);
						indices.push(b, c, d); // increase counter

						groupCount += 6;
					}
				} // add a group to the geometry. this will ensure multi material support


				scope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups

				groupStart += groupCount; // update total number of vertices

				numberOfVertices += vertexCounter;
			}
		}

		static fromJSON(data) {
			return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
		}

	}

	/**
	 * Uniform Utilities
	 */
	function cloneUniforms(src) {
		const dst = {};

		for (const u in src) {
			dst[u] = {};

			for (const p in src[u]) {
				const property = src[u][p];

				if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
					dst[u][p] = property.clone();
				} else if (Array.isArray(property)) {
					dst[u][p] = property.slice();
				} else {
					dst[u][p] = property;
				}
			}
		}

		return dst;
	}
	function mergeUniforms(uniforms) {
		const merged = {};

		for (let u = 0; u < uniforms.length; u++) {
			const tmp = cloneUniforms(uniforms[u]);

			for (const p in tmp) {
				merged[p] = tmp[p];
			}
		}

		return merged;
	} // Legacy

	const UniformsUtils = {
		clone: cloneUniforms,
		merge: mergeUniforms
	};

	var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

	var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

	/**
	 * parameters = {
	 *	defines: { "label" : "value" },
	 *	uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *	fragmentShader: <string>,
	 *	vertexShader: <string>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	lights: <bool>
	 * }
	 */

	class ShaderMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'ShaderMaterial';
			this.defines = {};
			this.uniforms = {};
			this.vertexShader = default_vertex;
			this.fragmentShader = default_fragment;
			this.linewidth = 1;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.fog = false; // set to use scene fog

			this.lights = false; // set to use scene lights

			this.clipping = false; // set to use user-defined clipping planes

			this.extensions = {
				derivatives: false,
				// set to use derivatives
				fragDepth: false,
				// set to use fragment depth values
				drawBuffers: false,
				// set to use draw buffers
				shaderTextureLOD: false // set to use shader texture LOD

			}; // When rendered geometry doesn't include these attributes but the material does,
			// use these default values in WebGL. This avoids errors when buffer data is missing.

			this.defaultAttributeValues = {
				'color': [1, 1, 1],
				'uv': [0, 0],
				'uv2': [0, 0]
			};
			this.index0AttributeName = undefined;
			this.uniformsNeedUpdate = false;
			this.glslVersion = null;

			if (parameters !== undefined) {
				if (parameters.attributes !== undefined) {
					console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
				}

				this.setValues(parameters);
			}
		}

		copy(source) {
			super.copy(source);
			this.fragmentShader = source.fragmentShader;
			this.vertexShader = source.vertexShader;
			this.uniforms = cloneUniforms(source.uniforms);
			this.defines = Object.assign({}, source.defines);
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.lights = source.lights;
			this.clipping = source.clipping;
			this.extensions = Object.assign({}, source.extensions);
			this.glslVersion = source.glslVersion;
			return this;
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			data.glslVersion = this.glslVersion;
			data.uniforms = {};

			for (const name in this.uniforms) {
				const uniform = this.uniforms[name];
				const value = uniform.value;

				if (value && value.isTexture) {
					data.uniforms[name] = {
						type: 't',
						value: value.toJSON(meta).uuid
					};
				} else if (value && value.isColor) {
					data.uniforms[name] = {
						type: 'c',
						value: value.getHex()
					};
				} else if (value && value.isVector2) {
					data.uniforms[name] = {
						type: 'v2',
						value: value.toArray()
					};
				} else if (value && value.isVector3) {
					data.uniforms[name] = {
						type: 'v3',
						value: value.toArray()
					};
				} else if (value && value.isVector4) {
					data.uniforms[name] = {
						type: 'v4',
						value: value.toArray()
					};
				} else if (value && value.isMatrix3) {
					data.uniforms[name] = {
						type: 'm3',
						value: value.toArray()
					};
				} else if (value && value.isMatrix4) {
					data.uniforms[name] = {
						type: 'm4',
						value: value.toArray()
					};
				} else {
					data.uniforms[name] = {
						value: value
					}; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
				}
			}

			if (Object.keys(this.defines).length > 0) data.defines = this.defines;
			data.vertexShader = this.vertexShader;
			data.fragmentShader = this.fragmentShader;
			const extensions = {};

			for (const key in this.extensions) {
				if (this.extensions[key] === true) extensions[key] = true;
			}

			if (Object.keys(extensions).length > 0) data.extensions = extensions;
			return data;
		}

	}

	ShaderMaterial.prototype.isShaderMaterial = true;

	class Camera extends Object3D {
		constructor() {
			super();
			this.type = 'Camera';
			this.matrixWorldInverse = new Matrix4();
			this.projectionMatrix = new Matrix4();
			this.projectionMatrixInverse = new Matrix4();
		}

		copy(source, recursive) {
			super.copy(source, recursive);
			this.matrixWorldInverse.copy(source.matrixWorldInverse);
			this.projectionMatrix.copy(source.projectionMatrix);
			this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
			return this;
		}

		getWorldDirection(target) {
			this.updateWorldMatrix(true, false);
			const e = this.matrixWorld.elements;
			return target.set(-e[8], -e[9], -e[10]).normalize();
		}

		updateMatrixWorld(force) {
			super.updateMatrixWorld(force);
			this.matrixWorldInverse.copy(this.matrixWorld).invert();
		}

		updateWorldMatrix(updateParents, updateChildren) {
			super.updateWorldMatrix(updateParents, updateChildren);
			this.matrixWorldInverse.copy(this.matrixWorld).invert();
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	Camera.prototype.isCamera = true;

	class PerspectiveCamera extends Camera {
		constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {
			super();
			this.type = 'PerspectiveCamera';
			this.fov = fov;
			this.zoom = 1;
			this.near = near;
			this.far = far;
			this.focus = 10;
			this.aspect = aspect;
			this.view = null;
			this.filmGauge = 35; // width of the film (default in millimeters)

			this.filmOffset = 0; // horizontal film offset (same unit as gauge)

			this.updateProjectionMatrix();
		}

		copy(source, recursive) {
			super.copy(source, recursive);
			this.fov = source.fov;
			this.zoom = source.zoom;
			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;
			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign({}, source.view);
			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;
			return this;
		}
		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */


		setFocalLength(focalLength) {
			/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
			const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
			this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
			this.updateProjectionMatrix();
		}
		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */


		getFocalLength() {
			const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
			return 0.5 * this.getFilmHeight() / vExtentSlope;
		}

		getEffectiveFOV() {
			return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
		}

		getFilmWidth() {
			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min(this.aspect, 1);
		}

		getFilmHeight() {
			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max(this.aspect, 1);
		}
		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *	 +---+---+---+
		 *	 | A | B | C |
		 *	 +---+---+---+
		 *	 | D | E | F |
		 *	 +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *	 const w = 1920;
		 *	 const h = 1080;
		 *	 const fullWidth = w * 3;
		 *	 const fullHeight = h * 2;
		 *
		 *	 --A--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *	 --B--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *	 --C--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *	 --D--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *	 --E--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *	 --F--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *	 Note there is no reason monitors have to be the same size or in a grid.
		 */


		setViewOffset(fullWidth, fullHeight, x, y, width, height) {
			this.aspect = fullWidth / fullHeight;

			if (this.view === null) {
				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};
			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;
			this.updateProjectionMatrix();
		}

		clearViewOffset() {
			if (this.view !== null) {
				this.view.enabled = false;
			}

			this.updateProjectionMatrix();
		}

		updateProjectionMatrix() {
			const near = this.near;
			let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
			let height = 2 * top;
			let width = this.aspect * height;
			let left = -0.5 * width;
			const view = this.view;

			if (this.view !== null && this.view.enabled) {
				const fullWidth = view.fullWidth,
							fullHeight = view.fullHeight;
				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;
			}

			const skew = this.filmOffset;
			if (skew !== 0) left += near * skew / this.getFilmWidth();
			this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
			this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.fov = this.fov;
			data.object.zoom = this.zoom;
			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;
			data.object.aspect = this.aspect;
			if (this.view !== null) data.object.view = Object.assign({}, this.view);
			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;
			return data;
		}

	}

	PerspectiveCamera.prototype.isPerspectiveCamera = true;

	const fov = 90,
				aspect = 1;

	class CubeCamera extends Object3D {
		constructor(near, far, renderTarget) {
			super();
			this.type = 'CubeCamera';

			if (renderTarget.isWebGLCubeRenderTarget !== true) {
				console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');
				return;
			}

			this.renderTarget = renderTarget;
			const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
			cameraPX.layers = this.layers;
			cameraPX.up.set(0, -1, 0);
			cameraPX.lookAt(new Vector3(1, 0, 0));
			this.add(cameraPX);
			const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
			cameraNX.layers = this.layers;
			cameraNX.up.set(0, -1, 0);
			cameraNX.lookAt(new Vector3(-1, 0, 0));
			this.add(cameraNX);
			const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
			cameraPY.layers = this.layers;
			cameraPY.up.set(0, 0, 1);
			cameraPY.lookAt(new Vector3(0, 1, 0));
			this.add(cameraPY);
			const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
			cameraNY.layers = this.layers;
			cameraNY.up.set(0, 0, -1);
			cameraNY.lookAt(new Vector3(0, -1, 0));
			this.add(cameraNY);
			const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
			cameraPZ.layers = this.layers;
			cameraPZ.up.set(0, -1, 0);
			cameraPZ.lookAt(new Vector3(0, 0, 1));
			this.add(cameraPZ);
			const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
			cameraNZ.layers = this.layers;
			cameraNZ.up.set(0, -1, 0);
			cameraNZ.lookAt(new Vector3(0, 0, -1));
			this.add(cameraNZ);
		}

		update(renderer, scene) {
			if (this.parent === null) this.updateMatrixWorld();
			const renderTarget = this.renderTarget;
			const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
			const currentXrEnabled = renderer.xr.enabled;
			const currentRenderTarget = renderer.getRenderTarget();
			renderer.xr.enabled = false;
			const generateMipmaps = renderTarget.texture.generateMipmaps;
			renderTarget.texture.generateMipmaps = false;
			renderer.setRenderTarget(renderTarget, 0);
			renderer.render(scene, cameraPX);
			renderer.setRenderTarget(renderTarget, 1);
			renderer.render(scene, cameraNX);
			renderer.setRenderTarget(renderTarget, 2);
			renderer.render(scene, cameraPY);
			renderer.setRenderTarget(renderTarget, 3);
			renderer.render(scene, cameraNY);
			renderer.setRenderTarget(renderTarget, 4);
			renderer.render(scene, cameraPZ);
			renderTarget.texture.generateMipmaps = generateMipmaps;
			renderer.setRenderTarget(renderTarget, 5);
			renderer.render(scene, cameraNZ);
			renderer.setRenderTarget(currentRenderTarget);
			renderer.xr.enabled = currentXrEnabled;
		}

	}

	class CubeTexture extends Texture {
		constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
			images = images !== undefined ? images : [];
			mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
			super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
			this.flipY = false;
		}

		get images() {
			return this.image;
		}

		set images(value) {
			this.image = value;
		}

	}

	CubeTexture.prototype.isCubeTexture = true;

	class WebGLCubeRenderTarget extends WebGLRenderTarget {
		constructor(size, options, dummy) {
			if (Number.isInteger(options)) {
				console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');
				options = dummy;
			}

			super(size, size, options);
			options = options || {}; // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
			// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
			// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
			// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
			// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
			// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

			this.texture = new CubeTexture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
			this.texture.isRenderTargetTexture = true;
			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
			this.texture._needsFlipEnvMap = false;
		}

		fromEquirectangularTexture(renderer, texture) {
			this.texture.type = texture.type;
			this.texture.format = RGBAFormat; // see #18859

			this.texture.encoding = texture.encoding;
			this.texture.generateMipmaps = texture.generateMipmaps;
			this.texture.minFilter = texture.minFilter;
			this.texture.magFilter = texture.magFilter;
			const shader = {
				uniforms: {
					tEquirect: {
						value: null
					}
				},
				vertexShader:
				/* glsl */
				`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
				fragmentShader:
				/* glsl */
				`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
			};
			const geometry = new BoxGeometry(5, 5, 5);
			const material = new ShaderMaterial({
				name: 'CubemapFromEquirect',
				uniforms: cloneUniforms(shader.uniforms),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader,
				side: BackSide,
				blending: NoBlending
			});
			material.uniforms.tEquirect.value = texture;
			const mesh = new Mesh(geometry, material);
			const currentMinFilter = texture.minFilter; // Avoid blurred poles

			if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
			const camera = new CubeCamera(1, 10, this);
			camera.update(renderer, mesh);
			texture.minFilter = currentMinFilter;
			mesh.geometry.dispose();
			mesh.material.dispose();
			return this;
		}

		clear(renderer, color, depth, stencil) {
			const currentRenderTarget = renderer.getRenderTarget();

			for (let i = 0; i < 6; i++) {
				renderer.setRenderTarget(this, i);
				renderer.clear(color, depth, stencil);
			}

			renderer.setRenderTarget(currentRenderTarget);
		}

	}

	WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

	const _vector1 = /*@__PURE__*/new Vector3();

	const _vector2 = /*@__PURE__*/new Vector3();

	const _normalMatrix = /*@__PURE__*/new Matrix3();

	class Plane {
		constructor(normal = new Vector3(1, 0, 0), constant = 0) {
			// normal is assumed to be normalized
			this.normal = normal;
			this.constant = constant;
		}

		set(normal, constant) {
			this.normal.copy(normal);
			this.constant = constant;
			return this;
		}

		setComponents(x, y, z, w) {
			this.normal.set(x, y, z);
			this.constant = w;
			return this;
		}

		setFromNormalAndCoplanarPoint(normal, point) {
			this.normal.copy(normal);
			this.constant = -point.dot(this.normal);
			return this;
		}

		setFromCoplanarPoints(a, b, c) {
			const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?


			this.setFromNormalAndCoplanarPoint(normal, a);
			return this;
		}

		copy(plane) {
			this.normal.copy(plane.normal);
			this.constant = plane.constant;
			return this;
		}

		normalize() {
			// Note: will lead to a divide by zero if the plane is invalid.
			const inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar(inverseNormalLength);
			this.constant *= inverseNormalLength;
			return this;
		}

		negate() {
			this.constant *= -1;
			this.normal.negate();
			return this;
		}

		distanceToPoint(point) {
			return this.normal.dot(point) + this.constant;
		}

		distanceToSphere(sphere) {
			return this.distanceToPoint(sphere.center) - sphere.radius;
		}

		projectPoint(point, target) {
			return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
		}

		intersectLine(line, target) {
			const direction = line.delta(_vector1);
			const denominator = this.normal.dot(direction);

			if (denominator === 0) {
				// line is coplanar, return origin
				if (this.distanceToPoint(line.start) === 0) {
					return target.copy(line.start);
				} // Unsure if this is the correct method to handle this case.


				return null;
			}

			const t = -(line.start.dot(this.normal) + this.constant) / denominator;

			if (t < 0 || t > 1) {
				return null;
			}

			return target.copy(direction).multiplyScalar(t).add(line.start);
		}

		intersectsLine(line) {
			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
			const startSign = this.distanceToPoint(line.start);
			const endSign = this.distanceToPoint(line.end);
			return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
		}

		intersectsBox(box) {
			return box.intersectsPlane(this);
		}

		intersectsSphere(sphere) {
			return sphere.intersectsPlane(this);
		}

		coplanarPoint(target) {
			return target.copy(this.normal).multiplyScalar(-this.constant);
		}

		applyMatrix4(matrix, optionalNormalMatrix) {
			const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);

			const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
			const normal = this.normal.applyMatrix3(normalMatrix).normalize();
			this.constant = -referencePoint.dot(normal);
			return this;
		}

		translate(offset) {
			this.constant -= offset.dot(this.normal);
			return this;
		}

		equals(plane) {
			return plane.normal.equals(this.normal) && plane.constant === this.constant;
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	Plane.prototype.isPlane = true;

	const _sphere$2 = /*@__PURE__*/new Sphere();

	const _vector$7 = /*@__PURE__*/new Vector3();

	class Frustum {
		constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
			this.planes = [p0, p1, p2, p3, p4, p5];
		}

		set(p0, p1, p2, p3, p4, p5) {
			const planes = this.planes;
			planes[0].copy(p0);
			planes[1].copy(p1);
			planes[2].copy(p2);
			planes[3].copy(p3);
			planes[4].copy(p4);
			planes[5].copy(p5);
			return this;
		}

		copy(frustum) {
			const planes = this.planes;

			for (let i = 0; i < 6; i++) {
				planes[i].copy(frustum.planes[i]);
			}

			return this;
		}

		setFromProjectionMatrix(m) {
			const planes = this.planes;
			const me = m.elements;
			const me0 = me[0],
						me1 = me[1],
						me2 = me[2],
						me3 = me[3];
			const me4 = me[4],
						me5 = me[5],
						me6 = me[6],
						me7 = me[7];
			const me8 = me[8],
						me9 = me[9],
						me10 = me[10],
						me11 = me[11];
			const me12 = me[12],
						me13 = me[13],
						me14 = me[14],
						me15 = me[15];
			planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
			planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
			planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
			planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
			planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
			planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
			return this;
		}

		intersectsObject(object) {
			const geometry = object.geometry;
			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			_sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);

			return this.intersectsSphere(_sphere$2);
		}

		intersectsSprite(sprite) {
			_sphere$2.center.set(0, 0, 0);

			_sphere$2.radius = 0.7071067811865476;

			_sphere$2.applyMatrix4(sprite.matrixWorld);

			return this.intersectsSphere(_sphere$2);
		}

		intersectsSphere(sphere) {
			const planes = this.planes;
			const center = sphere.center;
			const negRadius = -sphere.radius;

			for (let i = 0; i < 6; i++) {
				const distance = planes[i].distanceToPoint(center);

				if (distance < negRadius) {
					return false;
				}
			}

			return true;
		}

		intersectsBox(box) {
			const planes = this.planes;

			for (let i = 0; i < 6; i++) {
				const plane = planes[i]; // corner at max distance

				_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				if (plane.distanceToPoint(_vector$7) < 0) {
					return false;
				}
			}

			return true;
		}

		containsPoint(point) {
			const planes = this.planes;

			for (let i = 0; i < 6; i++) {
				if (planes[i].distanceToPoint(point) < 0) {
					return false;
				}
			}

			return true;
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	function WebGLAnimation() {
		let context = null;
		let isAnimating = false;
		let animationLoop = null;
		let requestId = null;

		function onAnimationFrame(time, frame) {
			animationLoop(time, frame);
			requestId = context.requestAnimationFrame(onAnimationFrame);
		}

		return {
			start: function () {
				if (isAnimating === true) return;
				if (animationLoop === null) return;
				requestId = context.requestAnimationFrame(onAnimationFrame);
				isAnimating = true;
			},
			stop: function () {
				context.cancelAnimationFrame(requestId);
				isAnimating = false;
			},
			setAnimationLoop: function (callback) {
				animationLoop = callback;
			},
			setContext: function (value) {
				context = value;
			}
		};
	}

	function WebGLAttributes(gl, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;
		const buffers = new WeakMap();

		function createBuffer(attribute, bufferType) {
			const array = attribute.array;
			const usage = attribute.usage;
			const buffer = gl.createBuffer();
			gl.bindBuffer(bufferType, buffer);
			gl.bufferData(bufferType, array, usage);
			attribute.onUploadCallback();
			let type = gl.FLOAT;

			if (array instanceof Float32Array) {
				type = gl.FLOAT;
			} else if (array instanceof Float64Array) {
				console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
			} else if (array instanceof Uint16Array) {
				if (attribute.isFloat16BufferAttribute) {
					if (isWebGL2) {
						type = gl.HALF_FLOAT;
					} else {
						console.warn('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');
					}
				} else {
					type = gl.UNSIGNED_SHORT;
				}
			} else if (array instanceof Int16Array) {
				type = gl.SHORT;
			} else if (array instanceof Uint32Array) {
				type = gl.UNSIGNED_INT;
			} else if (array instanceof Int32Array) {
				type = gl.INT;
			} else if (array instanceof Int8Array) {
				type = gl.BYTE;
			} else if (array instanceof Uint8Array) {
				type = gl.UNSIGNED_BYTE;
			} else if (array instanceof Uint8ClampedArray) {
				type = gl.UNSIGNED_BYTE;
			}

			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			};
		}

		function updateBuffer(buffer, attribute, bufferType) {
			const array = attribute.array;
			const updateRange = attribute.updateRange;
			gl.bindBuffer(bufferType, buffer);

			if (updateRange.count === -1) {
				// Not using update ranges
				gl.bufferSubData(bufferType, 0, array);
			} else {
				if (isWebGL2) {
					gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
				} else {
					gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
				}

				updateRange.count = -1; // reset range
			}
		} //


		function get(attribute) {
			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
			return buffers.get(attribute);
		}

		function remove(attribute) {
			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
			const data = buffers.get(attribute);

			if (data) {
				gl.deleteBuffer(data.buffer);
				buffers.delete(attribute);
			}
		}

		function update(attribute, bufferType) {
			if (attribute.isGLBufferAttribute) {
				const cached = buffers.get(attribute);

				if (!cached || cached.version < attribute.version) {
					buffers.set(attribute, {
						buffer: attribute.buffer,
						type: attribute.type,
						bytesPerElement: attribute.elementSize,
						version: attribute.version
					});
				}

				return;
			}

			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
			const data = buffers.get(attribute);

			if (data === undefined) {
				buffers.set(attribute, createBuffer(attribute, bufferType));
			} else if (data.version < attribute.version) {
				updateBuffer(data.buffer, attribute, bufferType);
				data.version = attribute.version;
			}
		}

		return {
			get: get,
			remove: remove,
			update: update
		};
	}

	class PlaneGeometry extends BufferGeometry {
		constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
			super();
			this.type = 'PlaneGeometry';
			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};
			const width_half = width / 2;
			const height_half = height / 2;
			const gridX = Math.floor(widthSegments);
			const gridY = Math.floor(heightSegments);
			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;
			const segment_width = width / gridX;
			const segment_height = height / gridY; //

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			for (let iy = 0; iy < gridY1; iy++) {
				const y = iy * segment_height - height_half;

				for (let ix = 0; ix < gridX1; ix++) {
					const x = ix * segment_width - width_half;
					vertices.push(x, -y, 0);
					normals.push(0, 0, 1);
					uvs.push(ix / gridX);
					uvs.push(1 - iy / gridY);
				}
			}

			for (let iy = 0; iy < gridY; iy++) {
				for (let ix = 0; ix < gridX; ix++) {
					const a = ix + gridX1 * iy;
					const b = ix + gridX1 * (iy + 1);
					const c = ix + 1 + gridX1 * (iy + 1);
					const d = ix + 1 + gridX1 * iy;
					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			}

			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}

		static fromJSON(data) {
			return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
		}

	}

	var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

	var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var alphatest_fragment = "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif";

	var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";

	var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";

	var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

	var begin_vertex = "vec3 transformed = vec3( position );";

	var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

	var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif";

	var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

	var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

	var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

	var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

	var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

	var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

	var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

	var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

	var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

	var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

	var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

	var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

	var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

	var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

	var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

	var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

	var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

	var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}";

	var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

	var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

	var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

	var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

	var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

	var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";

	var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";

	var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

	var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

	var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";

	var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";

	var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

	var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";

	var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";

	var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif";

	var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

	var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

	var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

	var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

	var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif";

	var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(		0, 1,		0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

	var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

	var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";

	var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

	var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

	var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

	var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

	var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

	var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";

	var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

	var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

	var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

	var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

	var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";

	var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";

	var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";

	var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

	var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

	var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

	var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

	var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";

	var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";

	var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

	var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";

	var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

	var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";

	var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

	var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

	var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

	var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

	var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

	var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

	var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

	var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t	texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t	f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t	texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t	f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

	var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

	var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

	var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

	var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

	var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

	var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

	var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

	var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

	var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

	var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

	var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(	1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,	1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,	1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

	var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";

	var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif";

	var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

	var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

	var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

	var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

	var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

	var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

	var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

	const vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
	const fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
	const fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	const vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";
	const fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

	const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
	const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

	const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
	const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
	const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	const vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
	const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
	const fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
	const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
	const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";

	const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
	const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";
	const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
	const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
	const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	const vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
	const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
	const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	const ShaderChunk = {
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		alphatest_pars_fragment: alphatest_pars_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		encodings_fragment: encodings_fragment,
		encodings_pars_fragment: encodings_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_common_pars_fragment: envmap_common_pars_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_physical_pars_fragment: envmap_physical_pars_fragment,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_fragment: lightmap_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_vertex: lights_lambert_vertex,
		lights_pars_begin: lights_pars_begin,
		lights_toon_fragment: lights_toon_fragment,
		lights_toon_pars_fragment: lights_toon_pars_fragment,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_fragment_begin: lights_fragment_begin,
		lights_fragment_maps: lights_fragment_maps,
		lights_fragment_end: lights_fragment_end,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment_begin: normal_fragment_begin,
		normal_fragment_maps: normal_fragment_maps,
		normal_pars_fragment: normal_pars_fragment,
		normal_pars_vertex: normal_pars_vertex,
		normal_vertex: normal_vertex,
		normalmap_pars_fragment: normalmap_pars_fragment,
		clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
		clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
		clearcoat_pars_fragment: clearcoat_pars_fragment,
		output_fragment: output_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		transmission_fragment: transmission_fragment,
		transmission_pars_fragment: transmission_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		uv2_pars_fragment: uv2_pars_fragment,
		uv2_pars_vertex: uv2_pars_vertex,
		uv2_vertex: uv2_vertex,
		worldpos_vertex: worldpos_vertex,
		background_vert: vertex$g,
		background_frag: fragment$g,
		cube_vert: vertex$f,
		cube_frag: fragment$f,
		depth_vert: vertex$e,
		depth_frag: fragment$e,
		distanceRGBA_vert: vertex$d,
		distanceRGBA_frag: fragment$d,
		equirect_vert: vertex$c,
		equirect_frag: fragment$c,
		linedashed_vert: vertex$b,
		linedashed_frag: fragment$b,
		meshbasic_vert: vertex$a,
		meshbasic_frag: fragment$a,
		meshlambert_vert: vertex$9,
		meshlambert_frag: fragment$9,
		meshmatcap_vert: vertex$8,
		meshmatcap_frag: fragment$8,
		meshnormal_vert: vertex$7,
		meshnormal_frag: fragment$7,
		meshphong_vert: vertex$6,
		meshphong_frag: fragment$6,
		meshphysical_vert: vertex$5,
		meshphysical_frag: fragment$5,
		meshtoon_vert: vertex$4,
		meshtoon_frag: fragment$4,
		points_vert: vertex$3,
		points_frag: fragment$3,
		shadow_vert: vertex$2,
		shadow_frag: fragment$2,
		sprite_vert: vertex$1,
		sprite_frag: fragment$1
	};

	/**
	 * Uniforms library for shared webgl shaders
	 */

	const UniformsLib = {
		common: {
			diffuse: {
				value: new Color(0xffffff)
			},
			opacity: {
				value: 1.0
			},
			map: {
				value: null
			},
			uvTransform: {
				value: new Matrix3()
			},
			uv2Transform: {
				value: new Matrix3()
			},
			alphaMap: {
				value: null
			},
			alphaTest: {
				value: 0
			}
		},
		specularmap: {
			specularMap: {
				value: null
			}
		},
		envmap: {
			envMap: {
				value: null
			},
			flipEnvMap: {
				value: -1
			},
			reflectivity: {
				value: 1.0
			},
			// basic, lambert, phong
			ior: {
				value: 1.5
			},
			// standard, physical
			refractionRatio: {
				value: 0.98
			}
		},
		aomap: {
			aoMap: {
				value: null
			},
			aoMapIntensity: {
				value: 1
			}
		},
		lightmap: {
			lightMap: {
				value: null
			},
			lightMapIntensity: {
				value: 1
			}
		},
		emissivemap: {
			emissiveMap: {
				value: null
			}
		},
		bumpmap: {
			bumpMap: {
				value: null
			},
			bumpScale: {
				value: 1
			}
		},
		normalmap: {
			normalMap: {
				value: null
			},
			normalScale: {
				value: new Vector2(1, 1)
			}
		},
		displacementmap: {
			displacementMap: {
				value: null
			},
			displacementScale: {
				value: 1
			},
			displacementBias: {
				value: 0
			}
		},
		roughnessmap: {
			roughnessMap: {
				value: null
			}
		},
		metalnessmap: {
			metalnessMap: {
				value: null
			}
		},
		gradientmap: {
			gradientMap: {
				value: null
			}
		},
		fog: {
			fogDensity: {
				value: 0.00025
			},
			fogNear: {
				value: 1
			},
			fogFar: {
				value: 2000
			},
			fogColor: {
				value: new Color(0xffffff)
			}
		},
		lights: {
			ambientLightColor: {
				value: []
			},
			lightProbe: {
				value: []
			},
			directionalLights: {
				value: [],
				properties: {
					direction: {},
					color: {}
				}
			},
			directionalLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},
			directionalShadowMap: {
				value: []
			},
			directionalShadowMatrix: {
				value: []
			},
			spotLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					direction: {},
					distance: {},
					coneCos: {},
					penumbraCos: {},
					decay: {}
				}
			},
			spotLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},
			spotShadowMap: {
				value: []
			},
			spotShadowMatrix: {
				value: []
			},
			pointLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					decay: {},
					distance: {}
				}
			},
			pointLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {},
					shadowCameraNear: {},
					shadowCameraFar: {}
				}
			},
			pointShadowMap: {
				value: []
			},
			pointShadowMatrix: {
				value: []
			},
			hemisphereLights: {
				value: [],
				properties: {
					direction: {},
					skyColor: {},
					groundColor: {}
				}
			},
			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					width: {},
					height: {}
				}
			},
			ltc_1: {
				value: null
			},
			ltc_2: {
				value: null
			}
		},
		points: {
			diffuse: {
				value: new Color(0xffffff)
			},
			opacity: {
				value: 1.0
			},
			size: {
				value: 1.0
			},
			scale: {
				value: 1.0
			},
			map: {
				value: null
			},
			alphaMap: {
				value: null
			},
			alphaTest: {
				value: 0
			},
			uvTransform: {
				value: new Matrix3()
			}
		},
		sprite: {
			diffuse: {
				value: new Color(0xffffff)
			},
			opacity: {
				value: 1.0
			},
			center: {
				value: new Vector2(0.5, 0.5)
			},
			rotation: {
				value: 0.0
			},
			map: {
				value: null
			},
			alphaMap: {
				value: null
			},
			alphaTest: {
				value: 0
			},
			uvTransform: {
				value: new Matrix3()
			}
		}
	};

	const ShaderLib = {
		basic: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag
		},
		lambert: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0x000000)
				}
			}]),
			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag
		},
		phong: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0x000000)
				},
				specular: {
					value: new Color(0x111111)
				},
				shininess: {
					value: 30
				}
			}]),
			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag
		},
		standard: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0x000000)
				},
				roughness: {
					value: 1.0
				},
				metalness: {
					value: 0.0
				},
				envMapIntensity: {
					value: 1
				} // temporary

			}]),
			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag
		},
		toon: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0x000000)
				}
			}]),
			vertexShader: ShaderChunk.meshtoon_vert,
			fragmentShader: ShaderChunk.meshtoon_frag
		},
		matcap: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
				matcap: {
					value: null
				}
			}]),
			vertexShader: ShaderChunk.meshmatcap_vert,
			fragmentShader: ShaderChunk.meshmatcap_frag
		},
		points: {
			uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag
		},
		dashed: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
				scale: {
					value: 1
				},
				dashSize: {
					value: 1
				},
				totalSize: {
					value: 2
				}
			}]),
			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag
		},
		depth: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag
		},
		normal: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
				opacity: {
					value: 1.0
				}
			}]),
			vertexShader: ShaderChunk.meshnormal_vert,
			fragmentShader: ShaderChunk.meshnormal_frag
		},
		sprite: {
			uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag
		},
		background: {
			uniforms: {
				uvTransform: {
					value: new Matrix3()
				},
				t2D: {
					value: null
				}
			},
			vertexShader: ShaderChunk.background_vert,
			fragmentShader: ShaderChunk.background_frag
		},

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */
		cube: {
			uniforms: mergeUniforms([UniformsLib.envmap, {
				opacity: {
					value: 1.0
				}
			}]),
			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag
		},
		equirect: {
			uniforms: {
				tEquirect: {
					value: null
				}
			},
			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag
		},
		distanceRGBA: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
				referencePosition: {
					value: new Vector3()
				},
				nearDistance: {
					value: 1
				},
				farDistance: {
					value: 1000
				}
			}]),
			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag
		},
		shadow: {
			uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
				color: {
					value: new Color(0x00000)
				},
				opacity: {
					value: 1.0
				}
			}]),
			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag
		}
	};
	ShaderLib.physical = {
		uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
			clearcoat: {
				value: 0
			},
			clearcoatMap: {
				value: null
			},
			clearcoatRoughness: {
				value: 0
			},
			clearcoatRoughnessMap: {
				value: null
			},
			clearcoatNormalScale: {
				value: new Vector2(1, 1)
			},
			clearcoatNormalMap: {
				value: null
			},
			sheen: {
				value: 0
			},
			sheenColor: {
				value: new Color(0x000000)
			},
			sheenColorMap: {
				value: null
			},
			sheenRoughness: {
				value: 0
			},
			sheenRoughnessMap: {
				value: null
			},
			transmission: {
				value: 0
			},
			transmissionMap: {
				value: null
			},
			transmissionSamplerSize: {
				value: new Vector2()
			},
			transmissionSamplerMap: {
				value: null
			},
			thickness: {
				value: 0
			},
			thicknessMap: {
				value: null
			},
			attenuationDistance: {
				value: 0
			},
			attenuationColor: {
				value: new Color(0x000000)
			},
			specularIntensity: {
				value: 0
			},
			specularIntensityMap: {
				value: null
			},
			specularColor: {
				value: new Color(1, 1, 1)
			},
			specularColorMap: {
				value: null
			}
		}]),
		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag
	};

	function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
		const clearColor = new Color(0x000000);
		let clearAlpha = 0;
		let planeMesh;
		let boxMesh;
		let currentBackground = null;
		let currentBackgroundVersion = 0;
		let currentTonemapping = null;

		function render(renderList, scene) {
			let forceClear = false;
			let background = scene.isScene === true ? scene.background : null;

			if (background && background.isTexture) {
				background = cubemaps.get(background);
			} // Ignore background in AR
			// TODO: Reconsider this.


			const xr = renderer.xr;
			const session = xr.getSession && xr.getSession();

			if (session && session.environmentBlendMode === 'additive') {
				background = null;
			}

			if (background === null) {
				setClear(clearColor, clearAlpha);
			} else if (background && background.isColor) {
				setClear(background, 1);
				forceClear = true;
			}

			if (renderer.autoClear || forceClear) {
				renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
			}

			if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
				if (boxMesh === undefined) {
					boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
						name: 'BackgroundCubeMaterial',
						uniforms: cloneUniforms(ShaderLib.cube.uniforms),
						vertexShader: ShaderLib.cube.vertexShader,
						fragmentShader: ShaderLib.cube.fragmentShader,
						side: BackSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					}));
					boxMesh.geometry.deleteAttribute('normal');
					boxMesh.geometry.deleteAttribute('uv');

					boxMesh.onBeforeRender = function (renderer, scene, camera) {
						this.matrixWorld.copyPosition(camera.matrixWorld);
					}; // enable code injection for non-built-in material


					Object.defineProperty(boxMesh.material, 'envMap', {
						get: function () {
							return this.uniforms.envMap.value;
						}
					});
					objects.update(boxMesh);
				}

				boxMesh.material.uniforms.envMap.value = background;
				boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;

				if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
					boxMesh.material.needsUpdate = true;
					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;
				} // push to the pre-sorted opaque render list


				renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
			} else if (background && background.isTexture) {
				if (planeMesh === undefined) {
					planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
						name: 'BackgroundMaterial',
						uniforms: cloneUniforms(ShaderLib.background.uniforms),
						vertexShader: ShaderLib.background.vertexShader,
						fragmentShader: ShaderLib.background.fragmentShader,
						side: FrontSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					}));
					planeMesh.geometry.deleteAttribute('normal'); // enable code injection for non-built-in material

					Object.defineProperty(planeMesh.material, 'map', {
						get: function () {
							return this.uniforms.t2D.value;
						}
					});
					objects.update(planeMesh);
				}

				planeMesh.material.uniforms.t2D.value = background;

				if (background.matrixAutoUpdate === true) {
					background.updateMatrix();
				}

				planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);

				if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
					planeMesh.material.needsUpdate = true;
					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;
				} // push to the pre-sorted opaque render list


				renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
			}
		}

		function setClear(color, alpha) {
			state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
		}

		return {
			getClearColor: function () {
				return clearColor;
			},
			setClearColor: function (color, alpha = 1) {
				clearColor.set(color);
				clearAlpha = alpha;
				setClear(clearColor, clearAlpha);
			},
			getClearAlpha: function () {
				return clearAlpha;
			},
			setClearAlpha: function (alpha) {
				clearAlpha = alpha;
				setClear(clearColor, clearAlpha);
			},
			render: render
		};
	}

	function WebGLBindingStates(gl, extensions, attributes, capabilities) {
		const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
		const extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');
		const vaoAvailable = capabilities.isWebGL2 || extension !== null;
		const bindingStates = {};
		const defaultState = createBindingState(null);
		let currentState = defaultState;

		function setup(object, material, program, geometry, index) {
			let updateBuffers = false;

			if (vaoAvailable) {
				const state = getBindingState(geometry, program, material);

				if (currentState !== state) {
					currentState = state;
					bindVertexArrayObject(currentState.object);
				}

				updateBuffers = needsUpdate(geometry, index);
				if (updateBuffers) saveCache(geometry, index);
			} else {
				const wireframe = material.wireframe === true;

				if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
					currentState.geometry = geometry.id;
					currentState.program = program.id;
					currentState.wireframe = wireframe;
					updateBuffers = true;
				}
			}

			if (object.isInstancedMesh === true) {
				updateBuffers = true;
			}

			if (index !== null) {
				attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
			}

			if (updateBuffers) {
				setupVertexAttributes(object, material, program, geometry);

				if (index !== null) {
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
				}
			}
		}

		function createVertexArrayObject() {
			if (capabilities.isWebGL2) return gl.createVertexArray();
			return extension.createVertexArrayOES();
		}

		function bindVertexArrayObject(vao) {
			if (capabilities.isWebGL2) return gl.bindVertexArray(vao);
			return extension.bindVertexArrayOES(vao);
		}

		function deleteVertexArrayObject(vao) {
			if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);
			return extension.deleteVertexArrayOES(vao);
		}

		function getBindingState(geometry, program, material) {
			const wireframe = material.wireframe === true;
			let programMap = bindingStates[geometry.id];

			if (programMap === undefined) {
				programMap = {};
				bindingStates[geometry.id] = programMap;
			}

			let stateMap = programMap[program.id];

			if (stateMap === undefined) {
				stateMap = {};
				programMap[program.id] = stateMap;
			}

			let state = stateMap[wireframe];

			if (state === undefined) {
				state = createBindingState(createVertexArrayObject());
				stateMap[wireframe] = state;
			}

			return state;
		}

		function createBindingState(vao) {
			const newAttributes = [];
			const enabledAttributes = [];
			const attributeDivisors = [];

			for (let i = 0; i < maxVertexAttributes; i++) {
				newAttributes[i] = 0;
				enabledAttributes[i] = 0;
				attributeDivisors[i] = 0;
			}

			return {
				// for backward compatibility on non-VAO support browser
				geometry: null,
				program: null,
				wireframe: false,
				newAttributes: newAttributes,
				enabledAttributes: enabledAttributes,
				attributeDivisors: attributeDivisors,
				object: vao,
				attributes: {},
				index: null
			};
		}

		function needsUpdate(geometry, index) {
			const cachedAttributes = currentState.attributes;
			const geometryAttributes = geometry.attributes;
			let attributesNum = 0;

			for (const key in geometryAttributes) {
				const cachedAttribute = cachedAttributes[key];
				const geometryAttribute = geometryAttributes[key];
				if (cachedAttribute === undefined) return true;
				if (cachedAttribute.attribute !== geometryAttribute) return true;
				if (cachedAttribute.data !== geometryAttribute.data) return true;
				attributesNum++;
			}

			if (currentState.attributesNum !== attributesNum) return true;
			if (currentState.index !== index) return true;
			return false;
		}

		function saveCache(geometry, index) {
			const cache = {};
			const attributes = geometry.attributes;
			let attributesNum = 0;

			for (const key in attributes) {
				const attribute = attributes[key];
				const data = {};
				data.attribute = attribute;

				if (attribute.data) {
					data.data = attribute.data;
				}

				cache[key] = data;
				attributesNum++;
			}

			currentState.attributes = cache;
			currentState.attributesNum = attributesNum;
			currentState.index = index;
		}

		function initAttributes() {
			const newAttributes = currentState.newAttributes;

			for (let i = 0, il = newAttributes.length; i < il; i++) {
				newAttributes[i] = 0;
			}
		}

		function enableAttribute(attribute) {
			enableAttributeAndDivisor(attribute, 0);
		}

		function enableAttributeAndDivisor(attribute, meshPerAttribute) {
			const newAttributes = currentState.newAttributes;
			const enabledAttributes = currentState.enabledAttributes;
			const attributeDivisors = currentState.attributeDivisors;
			newAttributes[attribute] = 1;

			if (enabledAttributes[attribute] === 0) {
				gl.enableVertexAttribArray(attribute);
				enabledAttributes[attribute] = 1;
			}

			if (attributeDivisors[attribute] !== meshPerAttribute) {
				const extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
				extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
				attributeDivisors[attribute] = meshPerAttribute;
			}
		}

		function disableUnusedAttributes() {
			const newAttributes = currentState.newAttributes;
			const enabledAttributes = currentState.enabledAttributes;

			for (let i = 0, il = enabledAttributes.length; i < il; i++) {
				if (enabledAttributes[i] !== newAttributes[i]) {
					gl.disableVertexAttribArray(i);
					enabledAttributes[i] = 0;
				}
			}
		}

		function vertexAttribPointer(index, size, type, normalized, stride, offset) {
			if (capabilities.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT)) {
				gl.vertexAttribIPointer(index, size, type, stride, offset);
			} else {
				gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
			}
		}

		function setupVertexAttributes(object, material, program, geometry) {
			if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
				if (extensions.get('ANGLE_instanced_arrays') === null) return;
			}

			initAttributes();
			const geometryAttributes = geometry.attributes;
			const programAttributes = program.getAttributes();
			const materialDefaultAttributeValues = material.defaultAttributeValues;

			for (const name in programAttributes) {
				const programAttribute = programAttributes[name];

				if (programAttribute.location >= 0) {
					let geometryAttribute = geometryAttributes[name];

					if (geometryAttribute === undefined) {
						if (name === 'instanceMatrix' && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
						if (name === 'instanceColor' && object.instanceColor) geometryAttribute = object.instanceColor;
					}

					if (geometryAttribute !== undefined) {
						const normalized = geometryAttribute.normalized;
						const size = geometryAttribute.itemSize;
						const attribute = attributes.get(geometryAttribute); // TODO Attribute may not be available on context restore

						if (attribute === undefined) continue;
						const buffer = attribute.buffer;
						const type = attribute.type;
						const bytesPerElement = attribute.bytesPerElement;

						if (geometryAttribute.isInterleavedBufferAttribute) {
							const data = geometryAttribute.data;
							const stride = data.stride;
							const offset = geometryAttribute.offset;

							if (data && data.isInstancedInterleavedBuffer) {
								for (let i = 0; i < programAttribute.locationSize; i++) {
									enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);
								}

								if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {
									geometry._maxInstanceCount = data.meshPerAttribute * data.count;
								}
							} else {
								for (let i = 0; i < programAttribute.locationSize; i++) {
									enableAttribute(programAttribute.location + i);
								}
							}

							gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

							for (let i = 0; i < programAttribute.locationSize; i++) {
								vertexAttribPointer(programAttribute.location + i, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * i) * bytesPerElement);
							}
						} else {
							if (geometryAttribute.isInstancedBufferAttribute) {
								for (let i = 0; i < programAttribute.locationSize; i++) {
									enableAttributeAndDivisor(programAttribute.location + i, geometryAttribute.meshPerAttribute);
								}

								if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {
									geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
								}
							} else {
								for (let i = 0; i < programAttribute.locationSize; i++) {
									enableAttribute(programAttribute.location + i);
								}
							}

							gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

							for (let i = 0; i < programAttribute.locationSize; i++) {
								vertexAttribPointer(programAttribute.location + i, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * i * bytesPerElement);
							}
						}
					} else if (materialDefaultAttributeValues !== undefined) {
						const value = materialDefaultAttributeValues[name];

						if (value !== undefined) {
							switch (value.length) {
								case 2:
									gl.vertexAttrib2fv(programAttribute.location, value);
									break;

								case 3:
									gl.vertexAttrib3fv(programAttribute.location, value);
									break;

								case 4:
									gl.vertexAttrib4fv(programAttribute.location, value);
									break;

								default:
									gl.vertexAttrib1fv(programAttribute.location, value);
							}
						}
					}
				}
			}

			disableUnusedAttributes();
		}

		function dispose() {
			reset();

			for (const geometryId in bindingStates) {
				const programMap = bindingStates[geometryId];

				for (const programId in programMap) {
					const stateMap = programMap[programId];

					for (const wireframe in stateMap) {
						deleteVertexArrayObject(stateMap[wireframe].object);
						delete stateMap[wireframe];
					}

					delete programMap[programId];
				}

				delete bindingStates[geometryId];
			}
		}

		function releaseStatesOfGeometry(geometry) {
			if (bindingStates[geometry.id] === undefined) return;
			const programMap = bindingStates[geometry.id];

			for (const programId in programMap) {
				const stateMap = programMap[programId];

				for (const wireframe in stateMap) {
					deleteVertexArrayObject(stateMap[wireframe].object);
					delete stateMap[wireframe];
				}

				delete programMap[programId];
			}

			delete bindingStates[geometry.id];
		}

		function releaseStatesOfProgram(program) {
			for (const geometryId in bindingStates) {
				const programMap = bindingStates[geometryId];
				if (programMap[program.id] === undefined) continue;
				const stateMap = programMap[program.id];

				for (const wireframe in stateMap) {
					deleteVertexArrayObject(stateMap[wireframe].object);
					delete stateMap[wireframe];
				}

				delete programMap[program.id];
			}
		}

		function reset() {
			resetDefaultState();
			if (currentState === defaultState) return;
			currentState = defaultState;
			bindVertexArrayObject(currentState.object);
		} // for backward-compatilibity


		function resetDefaultState() {
			defaultState.geometry = null;
			defaultState.program = null;
			defaultState.wireframe = false;
		}

		return {
			setup: setup,
			reset: reset,
			resetDefaultState: resetDefaultState,
			dispose: dispose,
			releaseStatesOfGeometry: releaseStatesOfGeometry,
			releaseStatesOfProgram: releaseStatesOfProgram,
			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			disableUnusedAttributes: disableUnusedAttributes
		};
	}

	function WebGLBufferRenderer(gl, extensions, info, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;
		let mode;

		function setMode(value) {
			mode = value;
		}

		function render(start, count) {
			gl.drawArrays(mode, start, count);
			info.update(count, mode, 1);
		}

		function renderInstances(start, count, primcount) {
			if (primcount === 0) return;
			let extension, methodName;

			if (isWebGL2) {
				extension = gl;
				methodName = 'drawArraysInstanced';
			} else {
				extension = extensions.get('ANGLE_instanced_arrays');
				methodName = 'drawArraysInstancedANGLE';

				if (extension === null) {
					console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
					return;
				}
			}

			extension[methodName](mode, start, count, primcount);
			info.update(count, mode, primcount);
		} //


		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;
	}

	function WebGLCapabilities(gl, extensions, parameters) {
		let maxAnisotropy;

		function getMaxAnisotropy() {
			if (maxAnisotropy !== undefined) return maxAnisotropy;

			if (extensions.has('EXT_texture_filter_anisotropic') === true) {
				const extension = extensions.get('EXT_texture_filter_anisotropic');
				maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
			} else {
				maxAnisotropy = 0;
			}

			return maxAnisotropy;
		}

		function getMaxPrecision(precision) {
			if (precision === 'highp') {
				if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
					return 'highp';
				}

				precision = 'mediump';
			}

			if (precision === 'mediump') {
				if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
					return 'mediump';
				}
			}

			return 'lowp';
		}
		/* eslint-disable no-undef */


		const isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;
		/* eslint-enable no-undef */

		let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		const maxPrecision = getMaxPrecision(precision);

		if (maxPrecision !== precision) {
			console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
			precision = maxPrecision;
		}

		const drawBuffers = isWebGL2 || extensions.has('WEBGL_draw_buffers');
		const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
		const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
		const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
		const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
		const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
		const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
		const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
		const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
		const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
		const vertexTextures = maxVertexTextures > 0;
		const floatFragmentTextures = isWebGL2 || extensions.has('OES_texture_float');
		const floatVertexTextures = vertexTextures && floatFragmentTextures;
		const maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;
		return {
			isWebGL2: isWebGL2,
			drawBuffers: drawBuffers,
			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,
			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,
			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,
			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,
			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures,
			maxSamples: maxSamples
		};
	}

	function WebGLClipping(properties) {
		const scope = this;
		let globalState = null,
				numGlobalPlanes = 0,
				localClippingEnabled = false,
				renderingShadows = false;
		const plane = new Plane(),
					viewNormalMatrix = new Matrix3(),
					uniform = {
			value: null,
			needsUpdate: false
		};
		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;

		this.init = function (planes, enableLocalClipping, camera) {
			const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
			// run another frame in order to reset the state:
			numGlobalPlanes !== 0 || localClippingEnabled;
			localClippingEnabled = enableLocalClipping;
			globalState = projectPlanes(planes, camera, 0);
			numGlobalPlanes = planes.length;
			return enabled;
		};

		this.beginShadows = function () {
			renderingShadows = true;
			projectPlanes(null);
		};

		this.endShadows = function () {
			renderingShadows = false;
			resetGlobalState();
		};

		this.setState = function (material, camera, useCache) {
			const planes = material.clippingPlanes,
						clipIntersection = material.clipIntersection,
						clipShadows = material.clipShadows;
			const materialProperties = properties.get(material);

			if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
				// there's no local clipping
				if (renderingShadows) {
					// there's no global clipping
					projectPlanes(null);
				} else {
					resetGlobalState();
				}
			} else {
				const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
							lGlobal = nGlobal * 4;
				let dstArray = materialProperties.clippingState || null;
				uniform.value = dstArray; // ensure unique state

				dstArray = projectPlanes(planes, camera, lGlobal, useCache);

				for (let i = 0; i !== lGlobal; ++i) {
					dstArray[i] = globalState[i];
				}

				materialProperties.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;
			}
		};

		function resetGlobalState() {
			if (uniform.value !== globalState) {
				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;
			}

			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;
		}

		function projectPlanes(planes, camera, dstOffset, skipTransform) {
			const nPlanes = planes !== null ? planes.length : 0;
			let dstArray = null;

			if (nPlanes !== 0) {
				dstArray = uniform.value;

				if (skipTransform !== true || dstArray === null) {
					const flatSize = dstOffset + nPlanes * 4,
								viewMatrix = camera.matrixWorldInverse;
					viewNormalMatrix.getNormalMatrix(viewMatrix);

					if (dstArray === null || dstArray.length < flatSize) {
						dstArray = new Float32Array(flatSize);
					}

					for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
						plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
						plane.normal.toArray(dstArray, i4);
						dstArray[i4 + 3] = plane.constant;
					}
				}

				uniform.value = dstArray;
				uniform.needsUpdate = true;
			}

			scope.numPlanes = nPlanes;
			scope.numIntersection = 0;
			return dstArray;
		}
	}

	function WebGLCubeMaps(renderer) {
		let cubemaps = new WeakMap();

		function mapTextureMapping(texture, mapping) {
			if (mapping === EquirectangularReflectionMapping) {
				texture.mapping = CubeReflectionMapping;
			} else if (mapping === EquirectangularRefractionMapping) {
				texture.mapping = CubeRefractionMapping;
			}

			return texture;
		}

		function get(texture) {
			if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
				const mapping = texture.mapping;

				if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
					if (cubemaps.has(texture)) {
						const cubemap = cubemaps.get(texture).texture;
						return mapTextureMapping(cubemap, texture.mapping);
					} else {
						const image = texture.image;

						if (image && image.height > 0) {
							const currentRenderTarget = renderer.getRenderTarget();
							const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
							renderTarget.fromEquirectangularTexture(renderer, texture);
							cubemaps.set(texture, renderTarget);
							renderer.setRenderTarget(currentRenderTarget);
							texture.addEventListener('dispose', onTextureDispose);
							return mapTextureMapping(renderTarget.texture, texture.mapping);
						} else {
							// image not yet ready. try the conversion next frame
							return null;
						}
					}
				}
			}

			return texture;
		}

		function onTextureDispose(event) {
			const texture = event.target;
			texture.removeEventListener('dispose', onTextureDispose);
			const cubemap = cubemaps.get(texture);

			if (cubemap !== undefined) {
				cubemaps.delete(texture);
				cubemap.dispose();
			}
		}

		function dispose() {
			cubemaps = new WeakMap();
		}

		return {
			get: get,
			dispose: dispose
		};
	}

	class OrthographicCamera extends Camera {
		constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000) {
			super();
			this.type = 'OrthographicCamera';
			this.zoom = 1;
			this.view = null;
			this.left = left;
			this.right = right;
			this.top = top;
			this.bottom = bottom;
			this.near = near;
			this.far = far;
			this.updateProjectionMatrix();
		}

		copy(source, recursive) {
			super.copy(source, recursive);
			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;
			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign({}, source.view);
			return this;
		}

		setViewOffset(fullWidth, fullHeight, x, y, width, height) {
			if (this.view === null) {
				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};
			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;
			this.updateProjectionMatrix();
		}

		clearViewOffset() {
			if (this.view !== null) {
				this.view.enabled = false;
			}

			this.updateProjectionMatrix();
		}

		updateProjectionMatrix() {
			const dx = (this.right - this.left) / (2 * this.zoom);
			const dy = (this.top - this.bottom) / (2 * this.zoom);
			const cx = (this.right + this.left) / 2;
			const cy = (this.top + this.bottom) / 2;
			let left = cx - dx;
			let right = cx + dx;
			let top = cy + dy;
			let bottom = cy - dy;

			if (this.view !== null && this.view.enabled) {
				const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
				const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
				left += scaleW * this.view.offsetX;
				right = left + scaleW * this.view.width;
				top -= scaleH * this.view.offsetY;
				bottom = top - scaleH * this.view.height;
			}

			this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
			this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;
			if (this.view !== null) data.object.view = Object.assign({}, this.view);
			return data;
		}

	}

	OrthographicCamera.prototype.isOrthographicCamera = true;

	class RawShaderMaterial extends ShaderMaterial {
		constructor(parameters) {
			super(parameters);
			this.type = 'RawShaderMaterial';
		}

	}

	RawShaderMaterial.prototype.isRawShaderMaterial = true;

	const LOD_MIN = 4;
	const LOD_MAX = 8;
	const SIZE_MAX = Math.pow(2, LOD_MAX); // The standard deviations (radians) associated with the extra mips. These are
	// chosen to approximate a Trowbridge-Reitz distribution function times the
	// geometric shadowing function. These sigma values squared must match the
	// variance #defines in cube_uv_reflection_fragment.glsl.js.

	const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
	const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length; // The maximum length of the blur for loop. Smaller sigmas will use fewer
	// samples and exit early, but not recompile the shader.

	const MAX_SAMPLES = 20;
	const ENCODINGS = {
		[LinearEncoding]: 0,
		[sRGBEncoding]: 1,
		[RGBEEncoding]: 2,
		[RGBM7Encoding]: 3,
		[RGBM16Encoding]: 4,
		[RGBDEncoding]: 5,
		[GammaEncoding]: 6
	};

	const _flatCamera = /*@__PURE__*/new OrthographicCamera();

	const {
		_lodPlanes,
		_sizeLods,
		_sigmas
	} = /*@__PURE__*/_createPlanes();

	const _clearColor = /*@__PURE__*/new Color();

	let _oldTarget = null; // Golden Ratio

	const PHI = (1 + Math.sqrt(5)) / 2;
	const INV_PHI = 1 / PHI; // Vertices of a dodecahedron (except the opposites, which represent the
	// same axis), used as axis directions evenly spread on a sphere.

	const _axisDirections = [/*@__PURE__*/new Vector3(1, 1, 1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-PHI, INV_PHI, 0)];
	/**
	 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
	 * (PMREM) from a cubeMap environment texture. This allows different levels of
	 * blur to be quickly accessed based on material roughness. It is packed into a
	 * special CubeUV format that allows us to perform custom interpolation so that
	 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
	 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
	 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
	 * higher roughness levels. In this way we maintain resolution to smoothly
	 * interpolate diffuse lighting while limiting sampling computation.
	 *
	 * Paper: Fast, Accurate Image-Based Lighting
	 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
	*/

	class PMREMGenerator {
		constructor(renderer) {
			this._renderer = renderer;
			this._pingPongRenderTarget = null;
			this._blurMaterial = _getBlurShader(MAX_SAMPLES);
			this._equirectShader = null;
			this._cubemapShader = null;

			this._compileMaterial(this._blurMaterial);
		}
		/**
		 * Generates a PMREM from a supplied Scene, which can be faster than using an
		 * image if networking bandwidth is low. Optional sigma specifies a blur radius
		 * in radians to be applied to the scene before PMREM generation. Optional near
		 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
		 * is placed at the origin).
		 */


		fromScene(scene, sigma = 0, near = 0.1, far = 100) {
			_oldTarget = this._renderer.getRenderTarget();

			const cubeUVRenderTarget = this._allocateTargets();

			this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);

			if (sigma > 0) {
				this._blur(cubeUVRenderTarget, 0, 0, sigma);
			}

			this._applyPMREM(cubeUVRenderTarget);

			this._cleanup(cubeUVRenderTarget);

			return cubeUVRenderTarget;
		}
		/**
		 * Generates a PMREM from an equirectangular texture, which can be either LDR
		 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
		 * as this matches best with the 256 x 256 cubemap output.
		 */


		fromEquirectangular(equirectangular) {
			return this._fromTexture(equirectangular);
		}
		/**
		 * Generates a PMREM from an cubemap texture, which can be either LDR
		 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
		 * as this matches best with the 256 x 256 cubemap output.
		 */


		fromCubemap(cubemap) {
			return this._fromTexture(cubemap);
		}
		/**
		 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */


		compileCubemapShader() {
			if (this._cubemapShader === null) {
				this._cubemapShader = _getCubemapShader();

				this._compileMaterial(this._cubemapShader);
			}
		}
		/**
		 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */


		compileEquirectangularShader() {
			if (this._equirectShader === null) {
				this._equirectShader = _getEquirectShader();

				this._compileMaterial(this._equirectShader);
			}
		}
		/**
		 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
		 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
		 * one of them will cause any others to also become unusable.
		 */


		dispose() {
			this._blurMaterial.dispose();

			if (this._cubemapShader !== null) this._cubemapShader.dispose();
			if (this._equirectShader !== null) this._equirectShader.dispose();

			for (let i = 0; i < _lodPlanes.length; i++) {
				_lodPlanes[i].dispose();
			}
		} // private interface


		_cleanup(outputTarget) {
			this._pingPongRenderTarget.dispose();

			this._renderer.setRenderTarget(_oldTarget);

			outputTarget.scissorTest = false;

			_setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
		}

		_fromTexture(texture) {
			_oldTarget = this._renderer.getRenderTarget();

			const cubeUVRenderTarget = this._allocateTargets(texture);

			this._textureToCubeUV(texture, cubeUVRenderTarget);

			this._applyPMREM(cubeUVRenderTarget);

			this._cleanup(cubeUVRenderTarget);

			return cubeUVRenderTarget;
		}

		_allocateTargets(texture) {
			// warning: null texture is valid
			const params = {
				magFilter: NearestFilter,
				minFilter: NearestFilter,
				generateMipmaps: false,
				type: UnsignedByteType,
				format: RGBEFormat,
				encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
				depthBuffer: false
			};

			const cubeUVRenderTarget = _createRenderTarget(params);

			cubeUVRenderTarget.depthBuffer = texture ? false : true;
			this._pingPongRenderTarget = _createRenderTarget(params);
			return cubeUVRenderTarget;
		}

		_compileMaterial(material) {
			const tmpMesh = new Mesh(_lodPlanes[0], material);

			this._renderer.compile(tmpMesh, _flatCamera);
		}

		_sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
			const fov = 90;
			const aspect = 1;
			const cubeCamera = new PerspectiveCamera(fov, aspect, near, far);
			const upSign = [1, -1, 1, 1, 1, 1];
			const forwardSign = [1, 1, 1, -1, -1, -1];
			const renderer = this._renderer;
			const originalAutoClear = renderer.autoClear;
			const outputEncoding = renderer.outputEncoding;
			const toneMapping = renderer.toneMapping;
			renderer.getClearColor(_clearColor);
			renderer.toneMapping = NoToneMapping;
			renderer.outputEncoding = LinearEncoding;
			renderer.autoClear = false;
			const backgroundMaterial = new MeshBasicMaterial({
				name: 'PMREM.Background',
				side: BackSide,
				depthWrite: false,
				depthTest: false
			});
			const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
			let useSolidColor = false;
			const background = scene.background;

			if (background) {
				if (background.isColor) {
					backgroundMaterial.color.copy(background);
					scene.background = null;
					useSolidColor = true;
				}
			} else {
				backgroundMaterial.color.copy(_clearColor);
				useSolidColor = true;
			}

			for (let i = 0; i < 6; i++) {
				const col = i % 3;

				if (col == 0) {
					cubeCamera.up.set(0, upSign[i], 0);
					cubeCamera.lookAt(forwardSign[i], 0, 0);
				} else if (col == 1) {
					cubeCamera.up.set(0, 0, upSign[i]);
					cubeCamera.lookAt(0, forwardSign[i], 0);
				} else {
					cubeCamera.up.set(0, upSign[i], 0);
					cubeCamera.lookAt(0, 0, forwardSign[i]);
				}

				_setViewport(cubeUVRenderTarget, col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);

				renderer.setRenderTarget(cubeUVRenderTarget);

				if (useSolidColor) {
					renderer.render(backgroundBox, cubeCamera);
				}

				renderer.render(scene, cubeCamera);
			}

			backgroundBox.geometry.dispose();
			backgroundBox.material.dispose();
			renderer.toneMapping = toneMapping;
			renderer.outputEncoding = outputEncoding;
			renderer.autoClear = originalAutoClear;
			scene.background = background;
		}

		_setEncoding(uniform, texture) {
			/* if ( this._renderer.capabilities.isWebGL2 === true && texture.format === RGBAFormat && texture.type === UnsignedByteType && texture.encoding === sRGBEncoding ) {
					uniform.value = ENCODINGS[ LinearEncoding ];
				} else {
					uniform.value = ENCODINGS[ texture.encoding ];
				} */
			uniform.value = ENCODINGS[texture.encoding];
		}

		_textureToCubeUV(texture, cubeUVRenderTarget) {
			const renderer = this._renderer;
			const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;

			if (isCubeTexture) {
				if (this._cubemapShader == null) {
					this._cubemapShader = _getCubemapShader();
				}
			} else {
				if (this._equirectShader == null) {
					this._equirectShader = _getEquirectShader();
				}
			}

			const material = isCubeTexture ? this._cubemapShader : this._equirectShader;
			const mesh = new Mesh(_lodPlanes[0], material);
			const uniforms = material.uniforms;
			uniforms['envMap'].value = texture;

			if (!isCubeTexture) {
				uniforms['texelSize'].value.set(1.0 / texture.image.width, 1.0 / texture.image.height);
			}

			this._setEncoding(uniforms['inputEncoding'], texture);

			this._setEncoding(uniforms['outputEncoding'], cubeUVRenderTarget.texture);

			_setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);

			renderer.setRenderTarget(cubeUVRenderTarget);
			renderer.render(mesh, _flatCamera);
		}

		_applyPMREM(cubeUVRenderTarget) {
			const renderer = this._renderer;
			const autoClear = renderer.autoClear;
			renderer.autoClear = false;

			for (let i = 1; i < TOTAL_LODS; i++) {
				const sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);
				const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];

				this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
			}

			renderer.autoClear = autoClear;
		}
		/**
		 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
		 * vertically and horizontally, but this breaks down on a cube. Here we apply
		 * the blur latitudinally (around the poles), and then longitudinally (towards
		 * the poles) to approximate the orthogonally-separable blur. It is least
		 * accurate at the poles, but still does a decent job.
		 */


		_blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
			const pingPongRenderTarget = this._pingPongRenderTarget;

			this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);

			this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
		}

		_halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
			const renderer = this._renderer;
			const blurMaterial = this._blurMaterial;

			if (direction !== 'latitudinal' && direction !== 'longitudinal') {
				console.error('blur direction must be either latitudinal or longitudinal!');
			} // Number of standard deviations at which to cut off the discrete approximation.


			const STANDARD_DEVIATIONS = 3;
			const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
			const blurUniforms = blurMaterial.uniforms;
			const pixels = _sizeLods[lodIn] - 1;
			const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
			const sigmaPixels = sigmaRadians / radiansPerPixel;
			const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;

			if (samples > MAX_SAMPLES) {
				console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
			}

			const weights = [];
			let sum = 0;

			for (let i = 0; i < MAX_SAMPLES; ++i) {
				const x = i / sigmaPixels;
				const weight = Math.exp(-x * x / 2);
				weights.push(weight);

				if (i == 0) {
					sum += weight;
				} else if (i < samples) {
					sum += 2 * weight;
				}
			}

			for (let i = 0; i < weights.length; i++) {
				weights[i] = weights[i] / sum;
			}

			blurUniforms['envMap'].value = targetIn.texture;
			blurUniforms['samples'].value = samples;
			blurUniforms['weights'].value = weights;
			blurUniforms['latitudinal'].value = direction === 'latitudinal';

			if (poleAxis) {
				blurUniforms['poleAxis'].value = poleAxis;
			}

			blurUniforms['dTheta'].value = radiansPerPixel;
			blurUniforms['mipInt'].value = LOD_MAX - lodIn;

			this._setEncoding(blurUniforms['inputEncoding'], targetIn.texture);

			this._setEncoding(blurUniforms['outputEncoding'], targetIn.texture);

			const outputSize = _sizeLods[lodOut];
			const x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
			const y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);

			_setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);

			renderer.setRenderTarget(targetOut);
			renderer.render(blurMesh, _flatCamera);
		}

	}

	function _isLDR(texture) {
		if (texture === undefined || texture.type !== UnsignedByteType) return false;
		return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
	}

	function _createPlanes() {
		const _lodPlanes = [];
		const _sizeLods = [];
		const _sigmas = [];
		let lod = LOD_MAX;

		for (let i = 0; i < TOTAL_LODS; i++) {
			const sizeLod = Math.pow(2, lod);

			_sizeLods.push(sizeLod);

			let sigma = 1.0 / sizeLod;

			if (i > LOD_MAX - LOD_MIN) {
				sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];
			} else if (i == 0) {
				sigma = 0;
			}

			_sigmas.push(sigma);

			const texelSize = 1.0 / (sizeLod - 1);
			const min = -texelSize / 2;
			const max = 1 + texelSize / 2;
			const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
			const cubeFaces = 6;
			const vertices = 6;
			const positionSize = 3;
			const uvSize = 2;
			const faceIndexSize = 1;
			const position = new Float32Array(positionSize * vertices * cubeFaces);
			const uv = new Float32Array(uvSize * vertices * cubeFaces);
			const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);

			for (let face = 0; face < cubeFaces; face++) {
				const x = face % 3 * 2 / 3 - 1;
				const y = face > 2 ? 0 : -1;
				const coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];
				position.set(coordinates, positionSize * vertices * face);
				uv.set(uv1, uvSize * vertices * face);
				const fill = [face, face, face, face, face, face];
				faceIndex.set(fill, faceIndexSize * vertices * face);
			}

			const planes = new BufferGeometry();
			planes.setAttribute('position', new BufferAttribute(position, positionSize));
			planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
			planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));

			_lodPlanes.push(planes);

			if (lod > LOD_MIN) {
				lod--;
			}
		}

		return {
			_lodPlanes,
			_sizeLods,
			_sigmas
		};
	}

	function _createRenderTarget(params) {
		const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
		cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
		cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
		cubeUVRenderTarget.scissorTest = true;
		return cubeUVRenderTarget;
	}

	function _setViewport(target, x, y, width, height) {
		target.viewport.set(x, y, width, height);
		target.scissor.set(x, y, width, height);
	}

	function _getBlurShader(maxSamples) {
		const weights = new Float32Array(maxSamples);
		const poleAxis = new Vector3(0, 1, 0);
		const shaderMaterial = new RawShaderMaterial({
			name: 'SphericalGaussianBlur',
			defines: {
				'n': maxSamples
			},
			uniforms: {
				'envMap': {
					value: null
				},
				'samples': {
					value: 1
				},
				'weights': {
					value: weights
				},
				'latitudinal': {
					value: false
				},
				'dTheta': {
					value: 0
				},
				'mipInt': {
					value: 0
				},
				'poleAxis': {
					value: poleAxis
				},
				'inputEncoding': {
					value: ENCODINGS[LinearEncoding]
				},
				'outputEncoding': {
					value: ENCODINGS[LinearEncoding]
				}
			},
			vertexShader: _getCommonVertexShader(),
			fragmentShader:
			/* glsl */
			`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${_getEncodings()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
			blending: NoBlending,
			depthTest: false,
			depthWrite: false
		});
		return shaderMaterial;
	}

	function _getEquirectShader() {
		const texelSize = new Vector2(1, 1);
		const shaderMaterial = new RawShaderMaterial({
			name: 'EquirectangularToCubeUV',
			uniforms: {
				'envMap': {
					value: null
				},
				'texelSize': {
					value: texelSize
				},
				'inputEncoding': {
					value: ENCODINGS[LinearEncoding]
				},
				'outputEncoding': {
					value: ENCODINGS[LinearEncoding]
				}
			},
			vertexShader: _getCommonVertexShader(),
			fragmentShader:
			/* glsl */
			`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${_getEncodings()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
			blending: NoBlending,
			depthTest: false,
			depthWrite: false
		});
		return shaderMaterial;
	}

	function _getCubemapShader() {
		const shaderMaterial = new RawShaderMaterial({
			name: 'CubemapToCubeUV',
			uniforms: {
				'envMap': {
					value: null
				},
				'inputEncoding': {
					value: ENCODINGS[LinearEncoding]
				},
				'outputEncoding': {
					value: ENCODINGS[LinearEncoding]
				}
			},
			vertexShader: _getCommonVertexShader(),
			fragmentShader:
			/* glsl */
			`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${_getEncodings()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
			blending: NoBlending,
			depthTest: false,
			depthWrite: false
		});
		return shaderMaterial;
	}

	function _getCommonVertexShader() {
		return (
			/* glsl */
			`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
		);
	}

	function _getEncodings() {
		return (
			/* glsl */
			`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`
		);
	}

	function WebGLCubeUVMaps(renderer) {
		let cubeUVmaps = new WeakMap();
		let pmremGenerator = null;

		function get(texture) {
			if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
				const mapping = texture.mapping;
				const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
				const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;

				if (isEquirectMap || isCubeMap) {
					// equirect/cube map to cubeUV conversion
					if (cubeUVmaps.has(texture)) {
						return cubeUVmaps.get(texture).texture;
					} else {
						const image = texture.image;

						if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
							const currentRenderTarget = renderer.getRenderTarget();
							if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
							const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
							cubeUVmaps.set(texture, renderTarget);
							renderer.setRenderTarget(currentRenderTarget);
							texture.addEventListener('dispose', onTextureDispose);
							return renderTarget.texture;
						} else {
							// image not yet ready. try the conversion next frame
							return null;
						}
					}
				}
			}

			return texture;
		}

		function isCubeTextureComplete(image) {
			let count = 0;
			const length = 6;

			for (let i = 0; i < length; i++) {
				if (image[i] !== undefined) count++;
			}

			return count === length;
		}

		function onTextureDispose(event) {
			const texture = event.target;
			texture.removeEventListener('dispose', onTextureDispose);
			const cubemapUV = cubeUVmaps.get(texture);

			if (cubemapUV !== undefined) {
				cubeUVmaps.delete(texture);
				cubemapUV.dispose();
			}
		}

		function dispose() {
			cubeUVmaps = new WeakMap();

			if (pmremGenerator !== null) {
				pmremGenerator.dispose();
				pmremGenerator = null;
			}
		}

		return {
			get: get,
			dispose: dispose
		};
	}

	function WebGLExtensions(gl) {
		const extensions = {};

		function getExtension(name) {
			if (extensions[name] !== undefined) {
				return extensions[name];
			}

			let extension;

			switch (name) {
				case 'WEBGL_depth_texture':
					extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
					break;

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
					break;

				default:
					extension = gl.getExtension(name);
			}

			extensions[name] = extension;
			return extension;
		}

		return {
			has: function (name) {
				return getExtension(name) !== null;
			},
			init: function (capabilities) {
				if (capabilities.isWebGL2) {
					getExtension('EXT_color_buffer_float');
				} else {
					getExtension('WEBGL_depth_texture');
					getExtension('OES_texture_float');
					getExtension('OES_texture_half_float');
					getExtension('OES_texture_half_float_linear');
					getExtension('OES_standard_derivatives');
					getExtension('OES_element_index_uint');
					getExtension('OES_vertex_array_object');
					getExtension('ANGLE_instanced_arrays');
				}

				getExtension('OES_texture_float_linear');
				getExtension('EXT_color_buffer_half_float');
				getExtension('WEBGL_multisampled_render_to_texture');
			},
			get: function (name) {
				const extension = getExtension(name);

				if (extension === null) {
					console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
				}

				return extension;
			}
		};
	}

	function WebGLGeometries(gl, attributes, info, bindingStates) {
		const geometries = {};
		const wireframeAttributes = new WeakMap();

		function onGeometryDispose(event) {
			const geometry = event.target;

			if (geometry.index !== null) {
				attributes.remove(geometry.index);
			}

			for (const name in geometry.attributes) {
				attributes.remove(geometry.attributes[name]);
			}

			geometry.removeEventListener('dispose', onGeometryDispose);
			delete geometries[geometry.id];
			const attribute = wireframeAttributes.get(geometry);

			if (attribute) {
				attributes.remove(attribute);
				wireframeAttributes.delete(geometry);
			}

			bindingStates.releaseStatesOfGeometry(geometry);

			if (geometry.isInstancedBufferGeometry === true) {
				delete geometry._maxInstanceCount;
			} //


			info.memory.geometries--;
		}

		function get(object, geometry) {
			if (geometries[geometry.id] === true) return geometry;
			geometry.addEventListener('dispose', onGeometryDispose);
			geometries[geometry.id] = true;
			info.memory.geometries++;
			return geometry;
		}

		function update(geometry) {
			const geometryAttributes = geometry.attributes; // Updating index buffer in VAO now. See WebGLBindingStates.

			for (const name in geometryAttributes) {
				attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
			} // morph targets


			const morphAttributes = geometry.morphAttributes;

			for (const name in morphAttributes) {
				const array = morphAttributes[name];

				for (let i = 0, l = array.length; i < l; i++) {
					attributes.update(array[i], gl.ARRAY_BUFFER);
				}
			}
		}

		function updateWireframeAttribute(geometry) {
			const indices = [];
			const geometryIndex = geometry.index;
			const geometryPosition = geometry.attributes.position;
			let version = 0;

			if (geometryIndex !== null) {
				const array = geometryIndex.array;
				version = geometryIndex.version;

				for (let i = 0, l = array.length; i < l; i += 3) {
					const a = array[i + 0];
					const b = array[i + 1];
					const c = array[i + 2];
					indices.push(a, b, b, c, c, a);
				}
			} else {
				const array = geometryPosition.array;
				version = geometryPosition.version;

				for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
					const a = i + 0;
					const b = i + 1;
					const c = i + 2;
					indices.push(a, b, b, c, c, a);
				}
			}

			const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
			attribute.version = version; // Updating index buffer in VAO now. See WebGLBindingStates
			//

			const previousAttribute = wireframeAttributes.get(geometry);
			if (previousAttribute) attributes.remove(previousAttribute); //

			wireframeAttributes.set(geometry, attribute);
		}

		function getWireframeAttribute(geometry) {
			const currentAttribute = wireframeAttributes.get(geometry);

			if (currentAttribute) {
				const geometryIndex = geometry.index;

				if (geometryIndex !== null) {
					// if the attribute is obsolete, create a new one
					if (currentAttribute.version < geometryIndex.version) {
						updateWireframeAttribute(geometry);
					}
				}
			} else {
				updateWireframeAttribute(geometry);
			}

			return wireframeAttributes.get(geometry);
		}

		return {
			get: get,
			update: update,
			getWireframeAttribute: getWireframeAttribute
		};
	}

	function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;
		let mode;

		function setMode(value) {
			mode = value;
		}

		let type, bytesPerElement;

		function setIndex(value) {
			type = value.type;
			bytesPerElement = value.bytesPerElement;
		}

		function render(start, count) {
			gl.drawElements(mode, count, type, start * bytesPerElement);
			info.update(count, mode, 1);
		}

		function renderInstances(start, count, primcount) {
			if (primcount === 0) return;
			let extension, methodName;

			if (isWebGL2) {
				extension = gl;
				methodName = 'drawElementsInstanced';
			} else {
				extension = extensions.get('ANGLE_instanced_arrays');
				methodName = 'drawElementsInstancedANGLE';

				if (extension === null) {
					console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
					return;
				}
			}

			extension[methodName](mode, count, type, start * bytesPerElement, primcount);
			info.update(count, mode, primcount);
		} //


		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;
	}

	function WebGLInfo(gl) {
		const memory = {
			geometries: 0,
			textures: 0
		};
		const render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};

		function update(count, mode, instanceCount) {
			render.calls++;

			switch (mode) {
				case gl.TRIANGLES:
					render.triangles += instanceCount * (count / 3);
					break;

				case gl.LINES:
					render.lines += instanceCount * (count / 2);
					break;

				case gl.LINE_STRIP:
					render.lines += instanceCount * (count - 1);
					break;

				case gl.LINE_LOOP:
					render.lines += instanceCount * count;
					break;

				case gl.POINTS:
					render.points += instanceCount * count;
					break;

				default:
					console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
					break;
			}
		}

		function reset() {
			render.frame++;
			render.calls = 0;
			render.triangles = 0;
			render.points = 0;
			render.lines = 0;
		}

		return {
			memory: memory,
			render: render,
			programs: null,
			autoReset: true,
			reset: reset,
			update: update
		};
	}

	class DataTexture2DArray extends Texture {
		constructor(data = null, width = 1, height = 1, depth = 1) {
			super(null);
			this.image = {
				data,
				width,
				height,
				depth
			};
			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;
			this.wrapR = ClampToEdgeWrapping;
			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;
			this.needsUpdate = true;
		}

	}

	DataTexture2DArray.prototype.isDataTexture2DArray = true;

	function numericalSort(a, b) {
		return a[0] - b[0];
	}

	function absNumericalSort(a, b) {
		return Math.abs(b[1]) - Math.abs(a[1]);
	}

	function denormalize(morph, attribute) {
		let denominator = 1;
		const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;
		if (array instanceof Int8Array) denominator = 127;else if (array instanceof Int16Array) denominator = 32767;else if (array instanceof Int32Array) denominator = 2147483647;else console.error('THREE.WebGLMorphtargets: Unsupported morph attribute data type: ', array);
		morph.divideScalar(denominator);
	}

	function WebGLMorphtargets(gl, capabilities, textures) {
		const influencesList = {};
		const morphInfluences = new Float32Array(8);
		const morphTextures = new WeakMap();
		const morph = new Vector3();
		const workInfluences = [];

		for (let i = 0; i < 8; i++) {
			workInfluences[i] = [i, 0];
		}

		function update(object, geometry, material, program) {
			const objectInfluences = object.morphTargetInfluences;

			if (capabilities.isWebGL2 === true) {
				// instead of using attributes, the WebGL 2 code path encodes morph targets
				// into an array of data textures. Each layer represents a single morph target.
				const numberOfMorphTargets = geometry.morphAttributes.position.length;
				let entry = morphTextures.get(geometry);

				if (entry === undefined || entry.count !== numberOfMorphTargets) {
					if (entry !== undefined) entry.texture.dispose();
					const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
					const morphTargets = geometry.morphAttributes.position;
					const morphNormals = geometry.morphAttributes.normal || [];
					const numberOfVertices = geometry.attributes.position.count;
					const numberOfVertexData = hasMorphNormals === true ? 2 : 1; // (v,n) vs. (v)

					let width = numberOfVertices * numberOfVertexData;
					let height = 1;

					if (width > capabilities.maxTextureSize) {
						height = Math.ceil(width / capabilities.maxTextureSize);
						width = capabilities.maxTextureSize;
					}

					const buffer = new Float32Array(width * height * 4 * numberOfMorphTargets);
					const texture = new DataTexture2DArray(buffer, width, height, numberOfMorphTargets);
					texture.format = RGBAFormat; // using RGBA since RGB might be emulated (and is thus slower)

					texture.type = FloatType; // fill buffer

					const vertexDataStride = numberOfVertexData * 4;

					for (let i = 0; i < numberOfMorphTargets; i++) {
						const morphTarget = morphTargets[i];
						const morphNormal = morphNormals[i];
						const offset = width * height * 4 * i;

						for (let j = 0; j < morphTarget.count; j++) {
							morph.fromBufferAttribute(morphTarget, j);
							if (morphTarget.normalized === true) denormalize(morph, morphTarget);
							const stride = j * vertexDataStride;
							buffer[offset + stride + 0] = morph.x;
							buffer[offset + stride + 1] = morph.y;
							buffer[offset + stride + 2] = morph.z;
							buffer[offset + stride + 3] = 0;

							if (hasMorphNormals === true) {
								morph.fromBufferAttribute(morphNormal, j);
								if (morphNormal.normalized === true) denormalize(morph, morphNormal);
								buffer[offset + stride + 4] = morph.x;
								buffer[offset + stride + 5] = morph.y;
								buffer[offset + stride + 6] = morph.z;
								buffer[offset + stride + 7] = 0;
							}
						}
					}

					entry = {
						count: numberOfMorphTargets,
						texture: texture,
						size: new Vector2(width, height)
					};
					morphTextures.set(geometry, entry);
				} //


				let morphInfluencesSum = 0;

				for (let i = 0; i < objectInfluences.length; i++) {
					morphInfluencesSum += objectInfluences[i];
				}

				const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
				program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
				program.getUniforms().setValue(gl, 'morphTargetInfluences', objectInfluences);
				program.getUniforms().setValue(gl, 'morphTargetsTexture', entry.texture, textures);
				program.getUniforms().setValue(gl, 'morphTargetsTextureSize', entry.size);
			} else {
				// When object doesn't have morph target influences defined, we treat it as a 0-length array
				// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences
				const length = objectInfluences === undefined ? 0 : objectInfluences.length;
				let influences = influencesList[geometry.id];

				if (influences === undefined || influences.length !== length) {
					// initialise list
					influences = [];

					for (let i = 0; i < length; i++) {
						influences[i] = [i, 0];
					}

					influencesList[geometry.id] = influences;
				} // Collect influences


				for (let i = 0; i < length; i++) {
					const influence = influences[i];
					influence[0] = i;
					influence[1] = objectInfluences[i];
				}

				influences.sort(absNumericalSort);

				for (let i = 0; i < 8; i++) {
					if (i < length && influences[i][1]) {
						workInfluences[i][0] = influences[i][0];
						workInfluences[i][1] = influences[i][1];
					} else {
						workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
						workInfluences[i][1] = 0;
					}
				}

				workInfluences.sort(numericalSort);
				const morphTargets = geometry.morphAttributes.position;
				const morphNormals = geometry.morphAttributes.normal;
				let morphInfluencesSum = 0;

				for (let i = 0; i < 8; i++) {
					const influence = workInfluences[i];
					const index = influence[0];
					const value = influence[1];

					if (index !== Number.MAX_SAFE_INTEGER && value) {
						if (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {
							geometry.setAttribute('morphTarget' + i, morphTargets[index]);
						}

						if (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {
							geometry.setAttribute('morphNormal' + i, morphNormals[index]);
						}

						morphInfluences[i] = value;
						morphInfluencesSum += value;
					} else {
						if (morphTargets && geometry.hasAttribute('morphTarget' + i) === true) {
							geometry.deleteAttribute('morphTarget' + i);
						}

						if (morphNormals && geometry.hasAttribute('morphNormal' + i) === true) {
							geometry.deleteAttribute('morphNormal' + i);
						}

						morphInfluences[i] = 0;
					}
				} // GLSL shader uses formula baseinfluence * base + sum(target * influence)
				// This allows us to switch between absolute morphs and relative morphs without changing shader code
				// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)


				const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
				program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
				program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
			}
		}

		return {
			update: update
		};
	}

	function WebGLObjects(gl, geometries, attributes, info) {
		let updateMap = new WeakMap();

		function update(object) {
			const frame = info.render.frame;
			const geometry = object.geometry;
			const buffergeometry = geometries.get(object, geometry); // Update once per frame

			if (updateMap.get(buffergeometry) !== frame) {
				geometries.update(buffergeometry);
				updateMap.set(buffergeometry, frame);
			}

			if (object.isInstancedMesh) {
				if (object.hasEventListener('dispose', onInstancedMeshDispose) === false) {
					object.addEventListener('dispose', onInstancedMeshDispose);
				}

				attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);

				if (object.instanceColor !== null) {
					attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
				}
			}

			return buffergeometry;
		}

		function dispose() {
			updateMap = new WeakMap();
		}

		function onInstancedMeshDispose(event) {
			const instancedMesh = event.target;
			instancedMesh.removeEventListener('dispose', onInstancedMeshDispose);
			attributes.remove(instancedMesh.instanceMatrix);
			if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
		}

		return {
			update: update,
			dispose: dispose
		};
	}

	class DataTexture3D extends Texture {
		constructor(data = null, width = 1, height = 1, depth = 1) {
			// We're going to add .setXXX() methods for setting properties later.
			// Users can still set in DataTexture3D directly.
			//
			//	const texture = new THREE.DataTexture3D( data, width, height, depth );
			// 	texture.anisotropy = 16;
			//
			// See #14839
			super(null);
			this.image = {
				data,
				width,
				height,
				depth
			};
			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;
			this.wrapR = ClampToEdgeWrapping;
			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;
			this.needsUpdate = true;
		}

	}

	DataTexture3D.prototype.isDataTexture3D = true;

	/**
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [textures] )
	 *
	 * 		uploads a uniform value(s)
	 *		the 'textures' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (textures factorizations):
	 *
	 * .upload( gl, seq, values, textures )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (textures factorizations):
	 *
	 * .setValue( gl, name, value, textures )
	 *
	 * 		sets uniform with	name 'name' to 'value'
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */
	const emptyTexture = new Texture();
	const emptyTexture2dArray = new DataTexture2DArray();
	const emptyTexture3d = new DataTexture3D();
	const emptyCubeTexture = new CubeTexture(); // --- Utilities ---
	// Array Caches (provide typed arrays for temporary by size)

	const arrayCacheF32 = [];
	const arrayCacheI32 = []; // Float32Array caches used for uploading Matrix uniforms

	const mat4array = new Float32Array(16);
	const mat3array = new Float32Array(9);
	const mat2array = new Float32Array(4); // Flattening for arrays of vectors and matrices

	function flatten(array, nBlocks, blockSize) {
		const firstElem = array[0];
		if (firstElem <= 0 || firstElem > 0) return array; // unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983

		const n = nBlocks * blockSize;
		let r = arrayCacheF32[n];

		if (r === undefined) {
			r = new Float32Array(n);
			arrayCacheF32[n] = r;
		}

		if (nBlocks !== 0) {
			firstElem.toArray(r, 0);

			for (let i = 1, offset = 0; i !== nBlocks; ++i) {
				offset += blockSize;
				array[i].toArray(r, offset);
			}
		}

		return r;
	}

	function arraysEqual(a, b) {
		if (a.length !== b.length) return false;

		for (let i = 0, l = a.length; i < l; i++) {
			if (a[i] !== b[i]) return false;
		}

		return true;
	}

	function copyArray(a, b) {
		for (let i = 0, l = b.length; i < l; i++) {
			a[i] = b[i];
		}
	} // Texture unit allocation


	function allocTexUnits(textures, n) {
		let r = arrayCacheI32[n];

		if (r === undefined) {
			r = new Int32Array(n);
			arrayCacheI32[n] = r;
		}

		for (let i = 0; i !== n; ++i) {
			r[i] = textures.allocateTextureUnit();
		}

		return r;
	} // --- Setters ---
	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.
	// Single scalar


	function setValueV1f(gl, v) {
		const cache = this.cache;
		if (cache[0] === v) return;
		gl.uniform1f(this.addr, v);
		cache[0] = v;
	} // Single float vector (from flat array or THREE.VectorN)


	function setValueV2f(gl, v) {
		const cache = this.cache;

		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y) {
				gl.uniform2f(this.addr, v.x, v.y);
				cache[0] = v.x;
				cache[1] = v.y;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform2fv(this.addr, v);
			copyArray(cache, v);
		}
	}

	function setValueV3f(gl, v) {
		const cache = this.cache;

		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
				gl.uniform3f(this.addr, v.x, v.y, v.z);
				cache[0] = v.x;
				cache[1] = v.y;
				cache[2] = v.z;
			}
		} else if (v.r !== undefined) {
			if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
				gl.uniform3f(this.addr, v.r, v.g, v.b);
				cache[0] = v.r;
				cache[1] = v.g;
				cache[2] = v.b;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform3fv(this.addr, v);
			copyArray(cache, v);
		}
	}

	function setValueV4f(gl, v) {
		const cache = this.cache;

		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
				gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
				cache[0] = v.x;
				cache[1] = v.y;
				cache[2] = v.z;
				cache[3] = v.w;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform4fv(this.addr, v);
			copyArray(cache, v);
		}
	} // Single matrix (from flat array or THREE.MatrixN)


	function setValueM2(gl, v) {
		const cache = this.cache;
		const elements = v.elements;

		if (elements === undefined) {
			if (arraysEqual(cache, v)) return;
			gl.uniformMatrix2fv(this.addr, false, v);
			copyArray(cache, v);
		} else {
			if (arraysEqual(cache, elements)) return;
			mat2array.set(elements);
			gl.uniformMatrix2fv(this.addr, false, mat2array);
			copyArray(cache, elements);
		}
	}

	function setValueM3(gl, v) {
		const cache = this.cache;
		const elements = v.elements;

		if (elements === undefined) {
			if (arraysEqual(cache, v)) return;
			gl.uniformMatrix3fv(this.addr, false, v);
			copyArray(cache, v);
		} else {
			if (arraysEqual(cache, elements)) return;
			mat3array.set(elements);
			gl.uniformMatrix3fv(this.addr, false, mat3array);
			copyArray(cache, elements);
		}
	}

	function setValueM4(gl, v) {
		const cache = this.cache;
		const elements = v.elements;

		if (elements === undefined) {
			if (arraysEqual(cache, v)) return;
			gl.uniformMatrix4fv(this.addr, false, v);
			copyArray(cache, v);
		} else {
			if (arraysEqual(cache, elements)) return;
			mat4array.set(elements);
			gl.uniformMatrix4fv(this.addr, false, mat4array);
			copyArray(cache, elements);
		}
	} // Single integer / boolean


	function setValueV1i(gl, v) {
		const cache = this.cache;
		if (cache[0] === v) return;
		gl.uniform1i(this.addr, v);
		cache[0] = v;
	} // Single integer / boolean vector (from flat array)


	function setValueV2i(gl, v) {
		const cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform2iv(this.addr, v);
		copyArray(cache, v);
	}

	function setValueV3i(gl, v) {
		const cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform3iv(this.addr, v);
		copyArray(cache, v);
	}

	function setValueV4i(gl, v) {
		const cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform4iv(this.addr, v);
		copyArray(cache, v);
	} // Single unsigned integer


	function setValueV1ui(gl, v) {
		const cache = this.cache;
		if (cache[0] === v) return;
		gl.uniform1ui(this.addr, v);
		cache[0] = v;
	} // Single unsigned integer vector (from flat array)


	function setValueV2ui(gl, v) {
		const cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform2uiv(this.addr, v);
		copyArray(cache, v);
	}

	function setValueV3ui(gl, v) {
		const cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform3uiv(this.addr, v);
		copyArray(cache, v);
	}

	function setValueV4ui(gl, v) {
		const cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform4uiv(this.addr, v);
		copyArray(cache, v);
	} // Single texture (2D / Cube)


	function setValueT1(gl, v, textures) {
		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		textures.safeSetTexture2D(v || emptyTexture, unit);
	}

	function setValueT3D1(gl, v, textures) {
		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		textures.setTexture3D(v || emptyTexture3d, unit);
	}

	function setValueT6(gl, v, textures) {
		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		textures.safeSetTextureCube(v || emptyCubeTexture, unit);
	}

	function setValueT2DArray1(gl, v, textures) {
		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		textures.setTexture2DArray(v || emptyTexture2dArray, unit);
	} // Helper to pick the right setter for the singular case


	function getSingularSetter(type) {
		switch (type) {
			case 0x1406:
				return setValueV1f;
			// FLOAT

			case 0x8b50:
				return setValueV2f;
			// _VEC2

			case 0x8b51:
				return setValueV3f;
			// _VEC3

			case 0x8b52:
				return setValueV4f;
			// _VEC4

			case 0x8b5a:
				return setValueM2;
			// _MAT2

			case 0x8b5b:
				return setValueM3;
			// _MAT3

			case 0x8b5c:
				return setValueM4;
			// _MAT4

			case 0x1404:
			case 0x8b56:
				return setValueV1i;
			// INT, BOOL

			case 0x8b53:
			case 0x8b57:
				return setValueV2i;
			// _VEC2

			case 0x8b54:
			case 0x8b58:
				return setValueV3i;
			// _VEC3

			case 0x8b55:
			case 0x8b59:
				return setValueV4i;
			// _VEC4

			case 0x1405:
				return setValueV1ui;
			// UINT

			case 0x8dc6:
				return setValueV2ui;
			// _VEC2

			case 0x8dc7:
				return setValueV3ui;
			// _VEC3

			case 0x8dc8:
				return setValueV4ui;
			// _VEC4

			case 0x8b5e: // SAMPLER_2D

			case 0x8d66: // SAMPLER_EXTERNAL_OES

			case 0x8dca: // INT_SAMPLER_2D

			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D

			case 0x8b62:
				// SAMPLER_2D_SHADOW
				return setValueT1;

			case 0x8b5f: // SAMPLER_3D

			case 0x8dcb: // INT_SAMPLER_3D

			case 0x8dd3:
				// UNSIGNED_INT_SAMPLER_3D
				return setValueT3D1;

			case 0x8b60: // SAMPLER_CUBE

			case 0x8dcc: // INT_SAMPLER_CUBE

			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE

			case 0x8dc5:
				// SAMPLER_CUBE_SHADOW
				return setValueT6;

			case 0x8dc1: // SAMPLER_2D_ARRAY

			case 0x8dcf: // INT_SAMPLER_2D_ARRAY

			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY

			case 0x8dc4:
				// SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArray1;
		}
	} // Array of scalars


	function setValueV1fArray(gl, v) {
		gl.uniform1fv(this.addr, v);
	} // Array of vectors (from flat array or array of THREE.VectorN)


	function setValueV2fArray(gl, v) {
		const data = flatten(v, this.size, 2);
		gl.uniform2fv(this.addr, data);
	}

	function setValueV3fArray(gl, v) {
		const data = flatten(v, this.size, 3);
		gl.uniform3fv(this.addr, data);
	}

	function setValueV4fArray(gl, v) {
		const data = flatten(v, this.size, 4);
		gl.uniform4fv(this.addr, data);
	} // Array of matrices (from flat array or array of THREE.MatrixN)


	function setValueM2Array(gl, v) {
		const data = flatten(v, this.size, 4);
		gl.uniformMatrix2fv(this.addr, false, data);
	}

	function setValueM3Array(gl, v) {
		const data = flatten(v, this.size, 9);
		gl.uniformMatrix3fv(this.addr, false, data);
	}

	function setValueM4Array(gl, v) {
		const data = flatten(v, this.size, 16);
		gl.uniformMatrix4fv(this.addr, false, data);
	} // Array of integer / boolean


	function setValueV1iArray(gl, v) {
		gl.uniform1iv(this.addr, v);
	} // Array of integer / boolean vectors (from flat array)


	function setValueV2iArray(gl, v) {
		gl.uniform2iv(this.addr, v);
	}

	function setValueV3iArray(gl, v) {
		gl.uniform3iv(this.addr, v);
	}

	function setValueV4iArray(gl, v) {
		gl.uniform4iv(this.addr, v);
	} // Array of unsigned integer


	function setValueV1uiArray(gl, v) {
		gl.uniform1uiv(this.addr, v);
	} // Array of unsigned integer vectors (from flat array)


	function setValueV2uiArray(gl, v) {
		gl.uniform2uiv(this.addr, v);
	}

	function setValueV3uiArray(gl, v) {
		gl.uniform3uiv(this.addr, v);
	}

	function setValueV4uiArray(gl, v) {
		gl.uniform4uiv(this.addr, v);
	} // Array of textures (2D / 3D / Cube / 2DArray)


	function setValueT1Array(gl, v, textures) {
		const n = v.length;
		const units = allocTexUnits(textures, n);
		gl.uniform1iv(this.addr, units);

		for (let i = 0; i !== n; ++i) {
			textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);
		}
	}

	function setValueT3DArray(gl, v, textures) {
		const n = v.length;
		const units = allocTexUnits(textures, n);
		gl.uniform1iv(this.addr, units);

		for (let i = 0; i !== n; ++i) {
			textures.setTexture3D(v[i] || emptyTexture3d, units[i]);
		}
	}

	function setValueT6Array(gl, v, textures) {
		const n = v.length;
		const units = allocTexUnits(textures, n);
		gl.uniform1iv(this.addr, units);

		for (let i = 0; i !== n; ++i) {
			textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);
		}
	}

	function setValueT2DArrayArray(gl, v, textures) {
		const n = v.length;
		const units = allocTexUnits(textures, n);
		gl.uniform1iv(this.addr, units);

		for (let i = 0; i !== n; ++i) {
			textures.setTexture2DArray(v[i] || emptyTexture2dArray, units[i]);
		}
	} // Helper to pick the right setter for a pure (bottom-level) array


	function getPureArraySetter(type) {
		switch (type) {
			case 0x1406:
				return setValueV1fArray;
			// FLOAT

			case 0x8b50:
				return setValueV2fArray;
			// _VEC2

			case 0x8b51:
				return setValueV3fArray;
			// _VEC3

			case 0x8b52:
				return setValueV4fArray;
			// _VEC4

			case 0x8b5a:
				return setValueM2Array;
			// _MAT2

			case 0x8b5b:
				return setValueM3Array;
			// _MAT3

			case 0x8b5c:
				return setValueM4Array;
			// _MAT4

			case 0x1404:
			case 0x8b56:
				return setValueV1iArray;
			// INT, BOOL

			case 0x8b53:
			case 0x8b57:
				return setValueV2iArray;
			// _VEC2

			case 0x8b54:
			case 0x8b58:
				return setValueV3iArray;
			// _VEC3

			case 0x8b55:
			case 0x8b59:
				return setValueV4iArray;
			// _VEC4

			case 0x1405:
				return setValueV1uiArray;
			// UINT

			case 0x8dc6:
				return setValueV2uiArray;
			// _VEC2

			case 0x8dc7:
				return setValueV3uiArray;
			// _VEC3

			case 0x8dc8:
				return setValueV4uiArray;
			// _VEC4

			case 0x8b5e: // SAMPLER_2D

			case 0x8d66: // SAMPLER_EXTERNAL_OES

			case 0x8dca: // INT_SAMPLER_2D

			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D

			case 0x8b62:
				// SAMPLER_2D_SHADOW
				return setValueT1Array;

			case 0x8b5f: // SAMPLER_3D

			case 0x8dcb: // INT_SAMPLER_3D

			case 0x8dd3:
				// UNSIGNED_INT_SAMPLER_3D
				return setValueT3DArray;

			case 0x8b60: // SAMPLER_CUBE

			case 0x8dcc: // INT_SAMPLER_CUBE

			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE

			case 0x8dc5:
				// SAMPLER_CUBE_SHADOW
				return setValueT6Array;

			case 0x8dc1: // SAMPLER_2D_ARRAY

			case 0x8dcf: // INT_SAMPLER_2D_ARRAY

			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY

			case 0x8dc4:
				// SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArrayArray;
		}
	} // --- Uniform Classes ---


	function SingleUniform(id, activeInfo, addr) {
		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.setValue = getSingularSetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
	}

	function PureArrayUniform(id, activeInfo, addr) {
		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
	}

	PureArrayUniform.prototype.updateCache = function (data) {
		const cache = this.cache;

		if (data instanceof Float32Array && cache.length !== data.length) {
			this.cache = new Float32Array(data.length);
		}

		copyArray(cache, data);
	};

	function StructuredUniform(id) {
		this.id = id;
		this.seq = [];
		this.map = {};
	}

	StructuredUniform.prototype.setValue = function (gl, value, textures) {
		const seq = this.seq;

		for (let i = 0, n = seq.length; i !== n; ++i) {
			const u = seq[i];
			u.setValue(gl, value[u.id], textures);
		}
	}; // --- Top-level ---
	// Parser - builds up the property tree from the path strings


	const RePathPart = /(\w+)(\])?(\[|\.)?/g; // extracts
	// 	- the identifier (member name or array index)
	//	- followed by an optional right bracket (found when array index)
	//	- followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.

	function addUniform(container, uniformObject) {
		container.seq.push(uniformObject);
		container.map[uniformObject.id] = uniformObject;
	}

	function parseUniform(activeInfo, addr, container) {
		const path = activeInfo.name,
					pathLength = path.length; // reset RegExp object, because of the early exit of a previous run

		RePathPart.lastIndex = 0;

		while (true) {
			const match = RePathPart.exec(path),
						matchEnd = RePathPart.lastIndex;
			let id = match[1];
			const idIsIndex = match[2] === ']',
						subscript = match[3];
			if (idIsIndex) id = id | 0; // convert to integer

			if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
				// bare name or "pure" bottom-level array "[0]" suffix
				addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
				break;
			} else {
				// step into inner node / create it in case it doesn't exist
				const map = container.map;
				let next = map[id];

				if (next === undefined) {
					next = new StructuredUniform(id);
					addUniform(container, next);
				}

				container = next;
			}
		}
	} // Root Container


	function WebGLUniforms(gl, program) {
		this.seq = [];
		this.map = {};
		const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

		for (let i = 0; i < n; ++i) {
			const info = gl.getActiveUniform(program, i),
						addr = gl.getUniformLocation(program, info.name);
			parseUniform(info, addr, this);
		}
	}

	WebGLUniforms.prototype.setValue = function (gl, name, value, textures) {
		const u = this.map[name];
		if (u !== undefined) u.setValue(gl, value, textures);
	};

	WebGLUniforms.prototype.setOptional = function (gl, object, name) {
		const v = object[name];
		if (v !== undefined) this.setValue(gl, name, v);
	}; // Static interface


	WebGLUniforms.upload = function (gl, seq, values, textures) {
		for (let i = 0, n = seq.length; i !== n; ++i) {
			const u = seq[i],
						v = values[u.id];

			if (v.needsUpdate !== false) {
				// note: always updating when .needsUpdate is undefined
				u.setValue(gl, v.value, textures);
			}
		}
	};

	WebGLUniforms.seqWithValue = function (seq, values) {
		const r = [];

		for (let i = 0, n = seq.length; i !== n; ++i) {
			const u = seq[i];
			if (u.id in values) r.push(u);
		}

		return r;
	};

	function WebGLShader(gl, type, string) {
		const shader = gl.createShader(type);
		gl.shaderSource(shader, string);
		gl.compileShader(shader);
		return shader;
	}

	let programIdCount = 0;

	function addLineNumbers(string) {
		const lines = string.split('\n');

		for (let i = 0; i < lines.length; i++) {
			lines[i] = i + 1 + ': ' + lines[i];
		}

		return lines.join('\n');
	}

	function getEncodingComponents(encoding) {
		switch (encoding) {
			case LinearEncoding:
				return ['Linear', '( value )'];

			case sRGBEncoding:
				return ['sRGB', '( value )'];

			case RGBEEncoding:
				return ['RGBE', '( value )'];

			case RGBM7Encoding:
				return ['RGBM', '( value, 7.0 )'];

			case RGBM16Encoding:
				return ['RGBM', '( value, 16.0 )'];

			case RGBDEncoding:
				return ['RGBD', '( value, 256.0 )'];

			case GammaEncoding:
				return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];

			default:
				console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);
				return ['Linear', '( value )'];
		}
	}

	function getShaderErrors(gl, shader, type) {
		const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
		const errors = gl.getShaderInfoLog(shader).trim();
		if (status && errors === '') return ''; // --enable-privileged-webgl-extension
		// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		return type.toUpperCase() + '\n\n' + errors + '\n\n' + addLineNumbers(gl.getShaderSource(shader));
	}

	function getTexelDecodingFunction(functionName, encoding) {
		const components = getEncodingComponents(encoding);
		return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
	}

	function getTexelEncodingFunction(functionName, encoding) {
		const components = getEncodingComponents(encoding);
		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
	}

	function getToneMappingFunction(functionName, toneMapping) {
		let toneMappingName;

		switch (toneMapping) {
			case LinearToneMapping:
				toneMappingName = 'Linear';
				break;

			case ReinhardToneMapping:
				toneMappingName = 'Reinhard';
				break;

			case CineonToneMapping:
				toneMappingName = 'OptimizedCineon';
				break;

			case ACESFilmicToneMapping:
				toneMappingName = 'ACESFilmic';
				break;

			case CustomToneMapping:
				toneMappingName = 'Custom';
				break;

			default:
				console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
				toneMappingName = 'Linear';
		}

		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
	}

	function generateExtensions(parameters) {
		const chunks = [parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '', (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '', parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '', (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''];
		return chunks.filter(filterEmptyLine).join('\n');
	}

	function generateDefines(defines) {
		const chunks = [];

		for (const name in defines) {
			const value = defines[name];
			if (value === false) continue;
			chunks.push('#define ' + name + ' ' + value);
		}

		return chunks.join('\n');
	}

	function fetchAttributeLocations(gl, program) {
		const attributes = {};
		const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

		for (let i = 0; i < n; i++) {
			const info = gl.getActiveAttrib(program, i);
			const name = info.name;
			let locationSize = 1;
			if (info.type === gl.FLOAT_MAT2) locationSize = 2;
			if (info.type === gl.FLOAT_MAT3) locationSize = 3;
			if (info.type === gl.FLOAT_MAT4) locationSize = 4; // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

			attributes[name] = {
				type: info.type,
				location: gl.getAttribLocation(program, name),
				locationSize: locationSize
			};
		}

		return attributes;
	}

	function filterEmptyLine(string) {
		return string !== '';
	}

	function replaceLightNums(string, parameters) {
		return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
	}

	function replaceClippingPlaneNums(string, parameters) {
		return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
	} // Resolve Includes


	const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

	function resolveIncludes(string) {
		return string.replace(includePattern, includeReplacer);
	}

	function includeReplacer(match, include) {
		const string = ShaderChunk[include];

		if (string === undefined) {
			throw new Error('Can not resolve #include <' + include + '>');
		}

		return resolveIncludes(string);
	} // Unroll Loops


	const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
	const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

	function unrollLoops(string) {
		return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
	}

	function deprecatedLoopReplacer(match, start, end, snippet) {
		console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');
		return loopReplacer(match, start, end, snippet);
	}

	function loopReplacer(match, start, end, snippet) {
		let string = '';

		for (let i = parseInt(start); i < parseInt(end); i++) {
			string += snippet.replace(/\[\s*i\s*\]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i);
		}

		return string;
	} //


	function generatePrecision(parameters) {
		let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

		if (parameters.precision === 'highp') {
			precisionstring += '\n#define HIGH_PRECISION';
		} else if (parameters.precision === 'mediump') {
			precisionstring += '\n#define MEDIUM_PRECISION';
		} else if (parameters.precision === 'lowp') {
			precisionstring += '\n#define LOW_PRECISION';
		}

		return precisionstring;
	}

	function generateShadowMapTypeDefine(parameters) {
		let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if (parameters.shadowMapType === PCFShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
		} else if (parameters.shadowMapType === PCFSoftShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
		} else if (parameters.shadowMapType === VSMShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
		}

		return shadowMapTypeDefine;
	}

	function generateEnvMapTypeDefine(parameters) {
		let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

		if (parameters.envMap) {
			switch (parameters.envMapMode) {
				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case CubeUVReflectionMapping:
				case CubeUVRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;
			}
		}

		return envMapTypeDefine;
	}

	function generateEnvMapModeDefine(parameters) {
		let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

		if (parameters.envMap) {
			switch (parameters.envMapMode) {
				case CubeRefractionMapping:
				case CubeUVRefractionMapping:
					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;
			}
		}

		return envMapModeDefine;
	}

	function generateEnvMapBlendingDefine(parameters) {
		let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

		if (parameters.envMap) {
			switch (parameters.combine) {
				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;
			}
		}

		return envMapBlendingDefine;
	}

	function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
		// TODO Send this event to Three.js DevTools
		// console.log( 'WebGLProgram', cacheKey );
		const gl = renderer.getContext();
		const defines = parameters.defines;
		let vertexShader = parameters.vertexShader;
		let fragmentShader = parameters.fragmentShader;
		const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
		const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
		const envMapModeDefine = generateEnvMapModeDefine(parameters);
		const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
		const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0;
		const customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
		const customDefines = generateDefines(defines);
		const program = gl.createProgram();
		let prefixVertex, prefixFragment;
		let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

		if (parameters.isRawShaderMaterial) {
			prefixVertex = [customDefines].filter(filterEmptyLine).join('\n');

			if (prefixVertex.length > 0) {
				prefixVertex += '\n';
			}

			prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\n');

			if (prefixFragment.length > 0) {
				prefixFragment += '\n';
			}
		} else {
			prefixVertex = [generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.instancing ? '#define USE_INSTANCING' : '', parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '', parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_BONES ' + parameters.maxBones, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '', parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '', parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.morphTargets && parameters.isWebGL2 ? '#define MORPHTARGETS_TEXTURE' : '', parameters.morphTargets && parameters.isWebGL2 ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', '	attribute mat4 instanceMatrix;', '#endif', '#ifdef USE_INSTANCING_COLOR', '	attribute vec3 instanceColor;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '	attribute vec4 tangent;', '#endif', '#if defined( USE_COLOR_ALPHA )', '	attribute vec4 color;', '#elif defined( USE_COLOR )', '	attribute vec3 color;', '#endif', '#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
			prefixFragment = [customExtensions, generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, '#define GAMMA_FACTOR ' + gammaFactorDefine, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoat ? '#define USE_CLEARCOAT' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '', parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.alphaTest ? '#define USE_ALPHATEST' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '', parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below
			parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', parameters.format === RGBFormat ? '#define OPAQUE' : '', ShaderChunk['encodings_pars_fragment'], // this code is required here because it is used by the various encoding/decoding function defined below
			parameters.map ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '', parameters.matcap ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '', parameters.envMap ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '', parameters.emissiveMap ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '', parameters.specularColorMap ? getTexelDecodingFunction('specularColorMapTexelToLinear', parameters.specularColorMapEncoding) : '', parameters.sheenColorMap ? getTexelDecodingFunction('sheenColorMapTexelToLinear', parameters.sheenColorMapEncoding) : '', parameters.lightMap ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '', getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding), parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n');
		}

		vertexShader = resolveIncludes(vertexShader);
		vertexShader = replaceLightNums(vertexShader, parameters);
		vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
		fragmentShader = resolveIncludes(fragmentShader);
		fragmentShader = replaceLightNums(fragmentShader, parameters);
		fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
		vertexShader = unrollLoops(vertexShader);
		fragmentShader = unrollLoops(fragmentShader);

		if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
			// GLSL 3.0 conversion for built-in materials and ShaderMaterial
			versionString = '#version 300 es\n';
			prefixVertex = ['precision mediump sampler2DArray;', '#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + prefixVertex;
			prefixFragment = ['#define varying in', parameters.glslVersion === GLSL3 ? '' : 'out highp vec4 pc_fragColor;', parameters.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\n') + '\n' + prefixFragment;
		}

		const vertexGlsl = versionString + prefixVertex + vertexShader;
		const fragmentGlsl = versionString + prefixFragment + fragmentShader; // console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
		const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
		gl.attachShader(program, glVertexShader);
		gl.attachShader(program, glFragmentShader); // Force a particular attribute to index 0.

		if (parameters.index0AttributeName !== undefined) {
			gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
		} else if (parameters.morphTargets === true) {
			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation(program, 0, 'position');
		}

		gl.linkProgram(program); // check for link errors

		if (renderer.debug.checkShaderErrors) {
			const programLog = gl.getProgramInfoLog(program).trim();
			const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
			const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
			let runnable = true;
			let haveDiagnostics = true;

			if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
				runnable = false;
				const vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
				const fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
				console.error('THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' + 'VALIDATE_STATUS ' + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + '\n\n' + 'Program Info Log: ' + programLog + '\n' + vertexErrors + '\n' + fragmentErrors);
			} else if (programLog !== '') {
				console.warn('THREE.WebGLProgram: Program Info Log:', programLog);
			} else if (vertexLog === '' || fragmentLog === '') {
				haveDiagnostics = false;
			}

			if (haveDiagnostics) {
				this.diagnostics = {
					runnable: runnable,
					programLog: programLog,
					vertexShader: {
						log: vertexLog,
						prefix: prefixVertex
					},
					fragmentShader: {
						log: fragmentLog,
						prefix: prefixFragment
					}
				};
			}
		} // Clean up
		// Crashes in iOS9 and iOS10. #18402
		// gl.detachShader( program, glVertexShader );
		// gl.detachShader( program, glFragmentShader );


		gl.deleteShader(glVertexShader);
		gl.deleteShader(glFragmentShader); // set up caching for uniform locations

		let cachedUniforms;

		this.getUniforms = function () {
			if (cachedUniforms === undefined) {
				cachedUniforms = new WebGLUniforms(gl, program);
			}

			return cachedUniforms;
		}; // set up caching for attribute locations


		let cachedAttributes;

		this.getAttributes = function () {
			if (cachedAttributes === undefined) {
				cachedAttributes = fetchAttributeLocations(gl, program);
			}

			return cachedAttributes;
		}; // free resource


		this.destroy = function () {
			bindingStates.releaseStatesOfProgram(this);
			gl.deleteProgram(program);
			this.program = undefined;
		}; //


		this.name = parameters.shaderName;
		this.id = programIdCount++;
		this.cacheKey = cacheKey;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;
		return this;
	}

	function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
		const programs = [];
		const isWebGL2 = capabilities.isWebGL2;
		const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
		const floatVertexTextures = capabilities.floatVertexTextures;
		const maxVertexUniforms = capabilities.maxVertexUniforms;
		const vertexTextures = capabilities.vertexTextures;
		let precision = capabilities.precision;
		const shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'toon',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			MeshMatcapMaterial: 'matcap',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow',
			SpriteMaterial: 'sprite'
		};
		const parameterNames = ['precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor', 'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV', 'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoat', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap',, 'roughnessMap', 'metalnessMap', 'gradientMap', 'alphaMap', 'alphaTest', 'combine', 'vertexColors', 'vertexAlphas', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2', 'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning', 'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals', 'morphTargetsCount', 'premultipliedAlpha', 'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights', 'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows', 'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering', 'format', 'specularIntensityMap', 'specularColorMap', 'specularColorMapEncoding', 'transmission', 'transmissionMap', 'thicknessMap', 'sheen', 'sheenColorMap', 'sheenColorMapEncoding', 'sheenRoughnessMap'];

		function getMaxBones(object) {
			const skeleton = object.skeleton;
			const bones = skeleton.bones;

			if (floatVertexTextures) {
				return 1024;
			} else {
				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//	- leave some extra space for other uniforms
				//	- limit here is ANGLE's 254 max uniform vectors
				//		(up to 54 should be safe)
				const nVertexUniforms = maxVertexUniforms;
				const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
				const maxBones = Math.min(nVertexMatrices, bones.length);

				if (maxBones < bones.length) {
					console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
					return 0;
				}

				return maxBones;
			}
		}

		function getTextureEncodingFromMap(map) {
			let encoding;

			if (map && map.isTexture) {
				encoding = map.encoding;
			} else if (map && map.isWebGLRenderTarget) {
				console.warn('THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.');
				encoding = map.texture.encoding;
			} else {
				encoding = LinearEncoding;
			}
			/* if ( isWebGL2 && map && map.isTexture && map.format === RGBAFormat && map.type === UnsignedByteType && map.encoding === sRGBEncoding ) {
					encoding = LinearEncoding; // disable inline decode for sRGB textures in WebGL 2
				} */


			return encoding;
		}

		function getParameters(material, lights, shadows, scene, object) {
			const fog = scene.fog;
			const environment = material.isMeshStandardMaterial ? scene.environment : null;
			const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
			const shaderID = shaderIDs[material.type]; // heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;

			if (material.precision !== null) {
				precision = capabilities.getMaxPrecision(material.precision);

				if (precision !== material.precision) {
					console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
				}
			}

			let vertexShader, fragmentShader;

			if (shaderID) {
				const shader = ShaderLib[shaderID];
				vertexShader = shader.vertexShader;
				fragmentShader = shader.fragmentShader;
			} else {
				vertexShader = material.vertexShader;
				fragmentShader = material.fragmentShader;
			}

			const currentRenderTarget = renderer.getRenderTarget();
			const useAlphaTest = material.alphaTest > 0;
			const useClearcoat = material.clearcoat > 0;
			const parameters = {
				isWebGL2: isWebGL2,
				shaderID: shaderID,
				shaderName: material.type,
				vertexShader: vertexShader,
				fragmentShader: fragmentShader,
				defines: material.defines,
				isRawShaderMaterial: material.isRawShaderMaterial === true,
				glslVersion: material.glslVersion,
				precision: precision,
				instancing: object.isInstancedMesh === true,
				instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
				supportsVertexTextures: vertexTextures,
				outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
				map: !!material.map,
				mapEncoding: getTextureEncodingFromMap(material.map),
				matcap: !!material.matcap,
				matcapEncoding: getTextureEncodingFromMap(material.matcap),
				envMap: !!envMap,
				envMapMode: envMap && envMap.mapping,
				envMapEncoding: getTextureEncodingFromMap(envMap),
				envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
				lightMap: !!material.lightMap,
				lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
				aoMap: !!material.aoMap,
				emissiveMap: !!material.emissiveMap,
				emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
				bumpMap: !!material.bumpMap,
				normalMap: !!material.normalMap,
				objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
				tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
				clearcoat: useClearcoat,
				clearcoatMap: useClearcoat && !!material.clearcoatMap,
				clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
				clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
				displacementMap: !!material.displacementMap,
				roughnessMap: !!material.roughnessMap,
				metalnessMap: !!material.metalnessMap,
				specularMap: !!material.specularMap,
				specularIntensityMap: !!material.specularIntensityMap,
				specularColorMap: !!material.specularColorMap,
				specularColorMapEncoding: getTextureEncodingFromMap(material.specularColorMap),
				alphaMap: !!material.alphaMap,
				alphaTest: useAlphaTest,
				gradientMap: !!material.gradientMap,
				sheen: material.sheen > 0,
				sheenColorMap: !!material.sheenColorMap,
				sheenColorMapEncoding: getTextureEncodingFromMap(material.sheenColorMap),
				sheenRoughnessMap: !!material.sheenRoughnessMap,
				transmission: material.transmission > 0,
				transmissionMap: !!material.transmissionMap,
				thicknessMap: !!material.thicknessMap,
				combine: material.combine,
				vertexTangents: !!material.normalMap && !!object.geometry && !!object.geometry.attributes.tangent,
				vertexColors: material.vertexColors,
				vertexAlphas: material.vertexColors === true && !!object.geometry && !!object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
				vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || material.sheenRoughnessMap,
				uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || material.sheen > 0 || !!material.sheenColorMap || !!material.sheenRoughnessMap) && !!material.displacementMap,
				fog: !!fog,
				useFog: material.fog,
				fogExp2: fog && fog.isFogExp2,
				flatShading: !!material.flatShading,
				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: logarithmicDepthBuffer,
				skinning: object.isSkinnedMesh === true && maxBones > 0,
				maxBones: maxBones,
				useVertexTexture: floatVertexTextures,
				morphTargets: !!object.geometry && !!object.geometry.morphAttributes.position,
				morphNormals: !!object.geometry && !!object.geometry.morphAttributes.normal,
				morphTargetsCount: !!object.geometry && !!object.geometry.morphAttributes.position ? object.geometry.morphAttributes.position.length : 0,
				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,
				numDirLightShadows: lights.directionalShadowMap.length,
				numPointLightShadows: lights.pointShadowMap.length,
				numSpotLightShadows: lights.spotShadowMap.length,
				numClippingPlanes: clipping.numPlanes,
				numClipIntersection: clipping.numIntersection,
				format: material.format,
				dithering: material.dithering,
				shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,
				toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,
				premultipliedAlpha: material.premultipliedAlpha,
				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,
				depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,
				index0AttributeName: material.index0AttributeName,
				extensionDerivatives: material.extensions && material.extensions.derivatives,
				extensionFragDepth: material.extensions && material.extensions.fragDepth,
				extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
				extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
				rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),
				rendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),
				rendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),
				customProgramCacheKey: material.customProgramCacheKey()
			};
			return parameters;
		}

		function getProgramCacheKey(parameters) {
			const array = [];

			if (parameters.shaderID) {
				array.push(parameters.shaderID);
			} else {
				array.push(hashString(parameters.fragmentShader));
				array.push(hashString(parameters.vertexShader));
			}

			if (parameters.defines !== undefined) {
				for (const name in parameters.defines) {
					array.push(name);
					array.push(parameters.defines[name]);
				}
			}

			if (parameters.isRawShaderMaterial === false) {
				for (let i = 0; i < parameterNames.length; i++) {
					array.push(parameters[parameterNames[i]]);
				}

				array.push(renderer.outputEncoding);
				array.push(renderer.gammaFactor);
			}

			array.push(parameters.customProgramCacheKey);
			return array.join();
		}

		function getUniforms(material) {
			const shaderID = shaderIDs[material.type];
			let uniforms;

			if (shaderID) {
				const shader = ShaderLib[shaderID];
				uniforms = UniformsUtils.clone(shader.uniforms);
			} else {
				uniforms = material.uniforms;
			}

			return uniforms;
		}

		function acquireProgram(parameters, cacheKey) {
			let program; // Check if code has been already compiled

			for (let p = 0, pl = programs.length; p < pl; p++) {
				const preexistingProgram = programs[p];

				if (preexistingProgram.cacheKey === cacheKey) {
					program = preexistingProgram;
					++program.usedTimes;
					break;
				}
			}

			if (program === undefined) {
				program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
				programs.push(program);
			}

			return program;
		}

		function releaseProgram(program) {
			if (--program.usedTimes === 0) {
				// Remove from unordered set
				const i = programs.indexOf(program);
				programs[i] = programs[programs.length - 1];
				programs.pop(); // Free WebGL resources

				program.destroy();
			}
		}

		return {
			getParameters: getParameters,
			getProgramCacheKey: getProgramCacheKey,
			getUniforms: getUniforms,
			acquireProgram: acquireProgram,
			releaseProgram: releaseProgram,
			// Exposed for resource monitoring & error feedback via renderer.info:
			programs: programs
		};
	}

	function WebGLProperties() {
		let properties = new WeakMap();

		function get(object) {
			let map = properties.get(object);

			if (map === undefined) {
				map = {};
				properties.set(object, map);
			}

			return map;
		}

		function remove(object) {
			properties.delete(object);
		}

		function update(object, key, value) {
			properties.get(object)[key] = value;
		}

		function dispose() {
			properties = new WeakMap();
		}

		return {
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		};
	}

	function painterSortStable(a, b) {
		if (a.groupOrder !== b.groupOrder) {
			return a.groupOrder - b.groupOrder;
		} else if (a.renderOrder !== b.renderOrder) {
			return a.renderOrder - b.renderOrder;
		} else if (a.program !== b.program) {
			return a.program.id - b.program.id;
		} else if (a.material.id !== b.material.id) {
			return a.material.id - b.material.id;
		} else if (a.z !== b.z) {
			return a.z - b.z;
		} else {
			return a.id - b.id;
		}
	}

	function reversePainterSortStable(a, b) {
		if (a.groupOrder !== b.groupOrder) {
			return a.groupOrder - b.groupOrder;
		} else if (a.renderOrder !== b.renderOrder) {
			return a.renderOrder - b.renderOrder;
		} else if (a.z !== b.z) {
			return b.z - a.z;
		} else {
			return a.id - b.id;
		}
	}

	function WebGLRenderList(properties) {
		const renderItems = [];
		let renderItemsIndex = 0;
		const opaque = [];
		const transmissive = [];
		const transparent = [];
		const defaultProgram = {
			id: -1
		};

		function init() {
			renderItemsIndex = 0;
			opaque.length = 0;
			transmissive.length = 0;
			transparent.length = 0;
		}

		function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
			let renderItem = renderItems[renderItemsIndex];
			const materialProperties = properties.get(material);

			if (renderItem === undefined) {
				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					program: materialProperties.program || defaultProgram,
					groupOrder: groupOrder,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};
				renderItems[renderItemsIndex] = renderItem;
			} else {
				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.program = materialProperties.program || defaultProgram;
				renderItem.groupOrder = groupOrder;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;
			}

			renderItemsIndex++;
			return renderItem;
		}

		function push(object, geometry, material, groupOrder, z, group) {
			const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);

			if (material.transmission > 0.0) {
				transmissive.push(renderItem);
			} else if (material.transparent === true) {
				transparent.push(renderItem);
			} else {
				opaque.push(renderItem);
			}
		}

		function unshift(object, geometry, material, groupOrder, z, group) {
			const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);

			if (material.transmission > 0.0) {
				transmissive.unshift(renderItem);
			} else if (material.transparent === true) {
				transparent.unshift(renderItem);
			} else {
				opaque.unshift(renderItem);
			}
		}

		function sort(customOpaqueSort, customTransparentSort) {
			if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
			if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);
			if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
		}

		function finish() {
			// Clear references from inactive renderItems in the list
			for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
				const renderItem = renderItems[i];
				if (renderItem.id === null) break;
				renderItem.id = null;
				renderItem.object = null;
				renderItem.geometry = null;
				renderItem.material = null;
				renderItem.program = null;
				renderItem.group = null;
			}
		}

		return {
			opaque: opaque,
			transmissive: transmissive,
			transparent: transparent,
			init: init,
			push: push,
			unshift: unshift,
			finish: finish,
			sort: sort
		};
	}

	function WebGLRenderLists(properties) {
		let lists = new WeakMap();

		function get(scene, renderCallDepth) {
			let list;

			if (lists.has(scene) === false) {
				list = new WebGLRenderList(properties);
				lists.set(scene, [list]);
			} else {
				if (renderCallDepth >= lists.get(scene).length) {
					list = new WebGLRenderList(properties);
					lists.get(scene).push(list);
				} else {
					list = lists.get(scene)[renderCallDepth];
				}
			}

			return list;
		}

		function dispose() {
			lists = new WeakMap();
		}

		return {
			get: get,
			dispose: dispose
		};
	}

	function UniformsCache() {
		const lights = {};
		return {
			get: function (light) {
				if (lights[light.id] !== undefined) {
					return lights[light.id];
				}

				let uniforms;

				switch (light.type) {
					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color()
						};
						break;

					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0
						};
						break;

					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0
						};
						break;

					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						};
						break;

					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
						};
						break;
				}

				lights[light.id] = uniforms;
				return uniforms;
			}
		};
	}

	function ShadowUniformsCache() {
		const lights = {};
		return {
			get: function (light) {
				if (lights[light.id] !== undefined) {
					return lights[light.id];
				}

				let uniforms;

				switch (light.type) {
					case 'DirectionalLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'SpotLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'PointLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						};
						break;
					// TODO (abelnation): set RectAreaLight shadow uniforms
				}

				lights[light.id] = uniforms;
				return uniforms;
			}
		};
	}

	let nextVersion = 0;

	function shadowCastingLightsFirst(lightA, lightB) {
		return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
	}

	function WebGLLights(extensions, capabilities) {
		const cache = new UniformsCache();
		const shadowCache = ShadowUniformsCache();
		const state = {
			version: 0,
			hash: {
				directionalLength: -1,
				pointLength: -1,
				spotLength: -1,
				rectAreaLength: -1,
				hemiLength: -1,
				numDirectionalShadows: -1,
				numPointShadows: -1,
				numSpotShadows: -1
			},
			ambient: [0, 0, 0],
			probe: [],
			directional: [],
			directionalShadow: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadow: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			rectAreaLTC1: null,
			rectAreaLTC2: null,
			point: [],
			pointShadow: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: []
		};

		for (let i = 0; i < 9; i++) state.probe.push(new Vector3());

		const vector3 = new Vector3();
		const matrix4 = new Matrix4();
		const matrix42 = new Matrix4();

		function setup(lights, physicallyCorrectLights) {
			let r = 0,
					g = 0,
					b = 0;

			for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);

			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;
			let numDirectionalShadows = 0;
			let numPointShadows = 0;
			let numSpotShadows = 0;
			lights.sort(shadowCastingLightsFirst); // artist-friendly light intensity scaling factor

			const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;

			for (let i = 0, l = lights.length; i < l; i++) {
				const light = lights[i];
				const color = light.color;
				const intensity = light.intensity;
				const distance = light.distance;
				const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;

				if (light.isAmbientLight) {
					r += color.r * intensity * scaleFactor;
					g += color.g * intensity * scaleFactor;
					b += color.b * intensity * scaleFactor;
				} else if (light.isLightProbe) {
					for (let j = 0; j < 9; j++) {
						state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
					}
				} else if (light.isDirectionalLight) {
					const uniforms = cache.get(light);
					uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);

					if (light.castShadow) {
						const shadow = light.shadow;
						const shadowUniforms = shadowCache.get(light);
						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;
						state.directionalShadow[directionalLength] = shadowUniforms;
						state.directionalShadowMap[directionalLength] = shadowMap;
						state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
						numDirectionalShadows++;
					}

					state.directional[directionalLength] = uniforms;
					directionalLength++;
				} else if (light.isSpotLight) {
					const uniforms = cache.get(light);
					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
					uniforms.distance = distance;
					uniforms.coneCos = Math.cos(light.angle);
					uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
					uniforms.decay = light.decay;

					if (light.castShadow) {
						const shadow = light.shadow;
						const shadowUniforms = shadowCache.get(light);
						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;
						state.spotShadow[spotLength] = shadowUniforms;
						state.spotShadowMap[spotLength] = shadowMap;
						state.spotShadowMatrix[spotLength] = light.shadow.matrix;
						numSpotShadows++;
					}

					state.spot[spotLength] = uniforms;
					spotLength++;
				} else if (light.isRectAreaLight) {
					const uniforms = cache.get(light); // (a) intensity is the total visible light emitted
					//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
					// (b) intensity is the brightness of the light

					uniforms.color.copy(color).multiplyScalar(intensity);
					uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
					uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
					state.rectArea[rectAreaLength] = uniforms;
					rectAreaLength++;
				} else if (light.isPointLight) {
					const uniforms = cache.get(light);
					uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
					uniforms.distance = light.distance;
					uniforms.decay = light.decay;

					if (light.castShadow) {
						const shadow = light.shadow;
						const shadowUniforms = shadowCache.get(light);
						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;
						shadowUniforms.shadowCameraNear = shadow.camera.near;
						shadowUniforms.shadowCameraFar = shadow.camera.far;
						state.pointShadow[pointLength] = shadowUniforms;
						state.pointShadowMap[pointLength] = shadowMap;
						state.pointShadowMatrix[pointLength] = light.shadow.matrix;
						numPointShadows++;
					}

					state.point[pointLength] = uniforms;
					pointLength++;
				} else if (light.isHemisphereLight) {
					const uniforms = cache.get(light);
					uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
					uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
					state.hemi[hemiLength] = uniforms;
					hemiLength++;
				}
			}

			if (rectAreaLength > 0) {
				if (capabilities.isWebGL2) {
					// WebGL 2
					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
				} else {
					// WebGL 1
					if (extensions.has('OES_texture_float_linear') === true) {
						state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
						state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
					} else if (extensions.has('OES_texture_half_float_linear') === true) {
						state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
						state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
					} else {
						console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');
					}
				}
			}

			state.ambient[0] = r;
			state.ambient[1] = g;
			state.ambient[2] = b;
			const hash = state.hash;

			if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
				state.directional.length = directionalLength;
				state.spot.length = spotLength;
				state.rectArea.length = rectAreaLength;
				state.point.length = pointLength;
				state.hemi.length = hemiLength;
				state.directionalShadow.length = numDirectionalShadows;
				state.directionalShadowMap.length = numDirectionalShadows;
				state.pointShadow.length = numPointShadows;
				state.pointShadowMap.length = numPointShadows;
				state.spotShadow.length = numSpotShadows;
				state.spotShadowMap.length = numSpotShadows;
				state.directionalShadowMatrix.length = numDirectionalShadows;
				state.pointShadowMatrix.length = numPointShadows;
				state.spotShadowMatrix.length = numSpotShadows;
				hash.directionalLength = directionalLength;
				hash.pointLength = pointLength;
				hash.spotLength = spotLength;
				hash.rectAreaLength = rectAreaLength;
				hash.hemiLength = hemiLength;
				hash.numDirectionalShadows = numDirectionalShadows;
				hash.numPointShadows = numPointShadows;
				hash.numSpotShadows = numSpotShadows;
				state.version = nextVersion++;
			}
		}

		function setupView(lights, camera) {
			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;
			const viewMatrix = camera.matrixWorldInverse;

			for (let i = 0, l = lights.length; i < l; i++) {
				const light = lights[i];

				if (light.isDirectionalLight) {
					const uniforms = state.directional[directionalLength];
					uniforms.direction.setFromMatrixPosition(light.matrixWorld);
					vector3.setFromMatrixPosition(light.target.matrixWorld);
					uniforms.direction.sub(vector3);
					uniforms.direction.transformDirection(viewMatrix);
					directionalLength++;
				} else if (light.isSpotLight) {
					const uniforms = state.spot[spotLength];
					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.position.applyMatrix4(viewMatrix);
					uniforms.direction.setFromMatrixPosition(light.matrixWorld);
					vector3.setFromMatrixPosition(light.target.matrixWorld);
					uniforms.direction.sub(vector3);
					uniforms.direction.transformDirection(viewMatrix);
					spotLength++;
				} else if (light.isRectAreaLight) {
					const uniforms = state.rectArea[rectAreaLength];
					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.position.applyMatrix4(viewMatrix); // extract local rotation of light to derive width/height half vectors

					matrix42.identity();
					matrix4.copy(light.matrixWorld);
					matrix4.premultiply(viewMatrix);
					matrix42.extractRotation(matrix4);
					uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
					uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
					uniforms.halfWidth.applyMatrix4(matrix42);
					uniforms.halfHeight.applyMatrix4(matrix42);
					rectAreaLength++;
				} else if (light.isPointLight) {
					const uniforms = state.point[pointLength];
					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.position.applyMatrix4(viewMatrix);
					pointLength++;
				} else if (light.isHemisphereLight) {
					const uniforms = state.hemi[hemiLength];
					uniforms.direction.setFromMatrixPosition(light.matrixWorld);
					uniforms.direction.transformDirection(viewMatrix);
					uniforms.direction.normalize();
					hemiLength++;
				}
			}
		}

		return {
			setup: setup,
			setupView: setupView,
			state: state
		};
	}

	function WebGLRenderState(extensions, capabilities) {
		const lights = new WebGLLights(extensions, capabilities);
		const lightsArray = [];
		const shadowsArray = [];

		function init() {
			lightsArray.length = 0;
			shadowsArray.length = 0;
		}

		function pushLight(light) {
			lightsArray.push(light);
		}

		function pushShadow(shadowLight) {
			shadowsArray.push(shadowLight);
		}

		function setupLights(physicallyCorrectLights) {
			lights.setup(lightsArray, physicallyCorrectLights);
		}

		function setupLightsView(camera) {
			lights.setupView(lightsArray, camera);
		}

		const state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,
			lights: lights
		};
		return {
			init: init,
			state: state,
			setupLights: setupLights,
			setupLightsView: setupLightsView,
			pushLight: pushLight,
			pushShadow: pushShadow
		};
	}

	function WebGLRenderStates(extensions, capabilities) {
		let renderStates = new WeakMap();

		function get(scene, renderCallDepth = 0) {
			let renderState;

			if (renderStates.has(scene) === false) {
				renderState = new WebGLRenderState(extensions, capabilities);
				renderStates.set(scene, [renderState]);
			} else {
				if (renderCallDepth >= renderStates.get(scene).length) {
					renderState = new WebGLRenderState(extensions, capabilities);
					renderStates.get(scene).push(renderState);
				} else {
					renderState = renderStates.get(scene)[renderCallDepth];
				}
			}

			return renderState;
		}

		function dispose() {
			renderStates = new WeakMap();
		}

		return {
			get: get,
			dispose: dispose
		};
	}

	/**
	 * parameters = {
	 *
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>
	 * }
	 */

	class MeshDepthMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'MeshDepthMaterial';
			this.depthPacking = BasicDepthPacking;
			this.map = null;
			this.alphaMap = null;
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.fog = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.depthPacking = source.depthPacking;
			this.map = source.map;
			this.alphaMap = source.alphaMap;
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			return this;
		}

	}

	MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

	/**
	 * parameters = {
	 *
	 *	referencePosition: <float>,
	 *	nearDistance: <float>,
	 *	farDistance: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>
	 *
	 * }
	 */

	class MeshDistanceMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'MeshDistanceMaterial';
			this.referencePosition = new Vector3();
			this.nearDistance = 1;
			this.farDistance = 1000;
			this.map = null;
			this.alphaMap = null;
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.fog = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.referencePosition.copy(source.referencePosition);
			this.nearDistance = source.nearDistance;
			this.farDistance = source.farDistance;
			this.map = source.map;
			this.alphaMap = source.alphaMap;
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			return this;
		}

	}

	MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

	const vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
	const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

	function WebGLShadowMap(_renderer, _objects, _capabilities) {
		let _frustum = new Frustum();

		const _shadowMapSize = new Vector2(),
					_viewportSize = new Vector2(),
					_viewport = new Vector4(),
					_depthMaterial = new MeshDepthMaterial({
			depthPacking: RGBADepthPacking
		}),
					_distanceMaterial = new MeshDistanceMaterial(),
					_materialCache = {},
					_maxTextureSize = _capabilities.maxTextureSize;

		const shadowSide = {
			0: BackSide,
			1: FrontSide,
			2: DoubleSide
		};
		const shadowMaterialVertical = new ShaderMaterial({
			defines: {
				VSM_SAMPLES: 8
			},
			uniforms: {
				shadow_pass: {
					value: null
				},
				resolution: {
					value: new Vector2()
				},
				radius: {
					value: 4.0
				}
			},
			vertexShader: vertex,
			fragmentShader: fragment
		});
		const shadowMaterialHorizontal = shadowMaterialVertical.clone();
		shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
		const fullScreenTri = new BufferGeometry();
		fullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
		const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
		const scope = this;
		this.enabled = false;
		this.autoUpdate = true;
		this.needsUpdate = false;
		this.type = PCFShadowMap;

		this.render = function (lights, scene, camera) {
			if (scope.enabled === false) return;
			if (scope.autoUpdate === false && scope.needsUpdate === false) return;
			if (lights.length === 0) return;

			const currentRenderTarget = _renderer.getRenderTarget();

			const activeCubeFace = _renderer.getActiveCubeFace();

			const activeMipmapLevel = _renderer.getActiveMipmapLevel();

			const _state = _renderer.state; // Set GL state for depth map.

			_state.setBlending(NoBlending);

			_state.buffers.color.setClear(1, 1, 1, 1);

			_state.buffers.depth.setTest(true);

			_state.setScissorTest(false); // render depth map


			for (let i = 0, il = lights.length; i < il; i++) {
				const light = lights[i];
				const shadow = light.shadow;

				if (shadow === undefined) {
					console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
					continue;
				}

				if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;

				_shadowMapSize.copy(shadow.mapSize);

				const shadowFrameExtents = shadow.getFrameExtents();

				_shadowMapSize.multiply(shadowFrameExtents);

				_viewportSize.copy(shadow.mapSize);

				if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
					if (_shadowMapSize.x > _maxTextureSize) {
						_viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
						_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
						shadow.mapSize.x = _viewportSize.x;
					}

					if (_shadowMapSize.y > _maxTextureSize) {
						_viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
						_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
						shadow.mapSize.y = _viewportSize.y;
					}
				}

				if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
					const pars = {
						minFilter: LinearFilter,
						magFilter: LinearFilter,
						format: RGBAFormat
					};
					shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
					shadow.map.texture.name = light.name + '.shadowMap';
					shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
					shadow.camera.updateProjectionMatrix();
				}

				if (shadow.map === null) {
					const pars = {
						minFilter: NearestFilter,
						magFilter: NearestFilter,
						format: RGBAFormat
					};
					shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
					shadow.map.texture.name = light.name + '.shadowMap';
					shadow.camera.updateProjectionMatrix();
				}

				_renderer.setRenderTarget(shadow.map);

				_renderer.clear();

				const viewportCount = shadow.getViewportCount();

				for (let vp = 0; vp < viewportCount; vp++) {
					const viewport = shadow.getViewport(vp);

					_viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);

					_state.viewport(_viewport);

					shadow.updateMatrices(light, vp);
					_frustum = shadow.getFrustum();
					renderObject(scene, camera, shadow.camera, light, this.type);
				} // do blur pass for VSM


				if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
					VSMPass(shadow, camera);
				}

				shadow.needsUpdate = false;
			}

			scope.needsUpdate = false;

			_renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
		};

		function VSMPass(shadow, camera) {
			const geometry = _objects.update(fullScreenMesh);

			if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
				shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
				shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
				shadowMaterialVertical.needsUpdate = true;
				shadowMaterialHorizontal.needsUpdate = true;
			} // vertical pass


			shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
			shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialVertical.uniforms.radius.value = shadow.radius;

			_renderer.setRenderTarget(shadow.mapPass);

			_renderer.clear();

			_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null); // horizontal pass


			shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
			shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;

			_renderer.setRenderTarget(shadow.map);

			_renderer.clear();

			_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
		}

		function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
			let result = null;
			const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;

			if (customMaterial !== undefined) {
				result = customMaterial;
			} else {
				result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
			}

			if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0) {
				// in this case we need a unique material instance reflecting the
				// appropriate state
				const keyA = result.uuid,
							keyB = material.uuid;
				let materialsForVariant = _materialCache[keyA];

				if (materialsForVariant === undefined) {
					materialsForVariant = {};
					_materialCache[keyA] = materialsForVariant;
				}

				let cachedMaterial = materialsForVariant[keyB];

				if (cachedMaterial === undefined) {
					cachedMaterial = result.clone();
					materialsForVariant[keyB] = cachedMaterial;
				}

				result = cachedMaterial;
			}

			result.visible = material.visible;
			result.wireframe = material.wireframe;

			if (type === VSMShadowMap) {
				result.side = material.shadowSide !== null ? material.shadowSide : material.side;
			} else {
				result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
			}

			result.alphaMap = material.alphaMap;
			result.alphaTest = material.alphaTest;
			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
			result.clipIntersection = material.clipIntersection;
			result.displacementMap = material.displacementMap;
			result.displacementScale = material.displacementScale;
			result.displacementBias = material.displacementBias;
			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;

			if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
				result.referencePosition.setFromMatrixPosition(light.matrixWorld);
				result.nearDistance = shadowCameraNear;
				result.farDistance = shadowCameraFar;
			}

			return result;
		}

		function renderObject(object, camera, shadowCamera, light, type) {
			if (object.visible === false) return;
			const visible = object.layers.test(camera.layers);

			if (visible && (object.isMesh || object.isLine || object.isPoints)) {
				if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
					object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);

					const geometry = _objects.update(object);

					const material = object.material;

					if (Array.isArray(material)) {
						const groups = geometry.groups;

						for (let k = 0, kl = groups.length; k < kl; k++) {
							const group = groups[k];
							const groupMaterial = material[group.materialIndex];

							if (groupMaterial && groupMaterial.visible) {
								const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);

								_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
							}
						}
					} else if (material.visible) {
						const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);

						_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
					}
				}
			}

			const children = object.children;

			for (let i = 0, l = children.length; i < l; i++) {
				renderObject(children[i], camera, shadowCamera, light, type);
			}
		}
	}

	function WebGLState(gl, extensions, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;

		function ColorBuffer() {
			let locked = false;
			const color = new Vector4();
			let currentColorMask = null;
			const currentColorClear = new Vector4(0, 0, 0, 0);
			return {
				setMask: function (colorMask) {
					if (currentColorMask !== colorMask && !locked) {
						gl.colorMask(colorMask, colorMask, colorMask, colorMask);
						currentColorMask = colorMask;
					}
				},
				setLocked: function (lock) {
					locked = lock;
				},
				setClear: function (r, g, b, a, premultipliedAlpha) {
					if (premultipliedAlpha === true) {
						r *= a;
						g *= a;
						b *= a;
					}

					color.set(r, g, b, a);

					if (currentColorClear.equals(color) === false) {
						gl.clearColor(r, g, b, a);
						currentColorClear.copy(color);
					}
				},
				reset: function () {
					locked = false;
					currentColorMask = null;
					currentColorClear.set(-1, 0, 0, 0); // set to invalid state
				}
			};
		}

		function DepthBuffer() {
			let locked = false;
			let currentDepthMask = null;
			let currentDepthFunc = null;
			let currentDepthClear = null;
			return {
				setTest: function (depthTest) {
					if (depthTest) {
						enable(gl.DEPTH_TEST);
					} else {
						disable(gl.DEPTH_TEST);
					}
				},
				setMask: function (depthMask) {
					if (currentDepthMask !== depthMask && !locked) {
						gl.depthMask(depthMask);
						currentDepthMask = depthMask;
					}
				},
				setFunc: function (depthFunc) {
					if (currentDepthFunc !== depthFunc) {
						if (depthFunc) {
							switch (depthFunc) {
								case NeverDepth:
									gl.depthFunc(gl.NEVER);
									break;

								case AlwaysDepth:
									gl.depthFunc(gl.ALWAYS);
									break;

								case LessDepth:
									gl.depthFunc(gl.LESS);
									break;

								case LessEqualDepth:
									gl.depthFunc(gl.LEQUAL);
									break;

								case EqualDepth:
									gl.depthFunc(gl.EQUAL);
									break;

								case GreaterEqualDepth:
									gl.depthFunc(gl.GEQUAL);
									break;

								case GreaterDepth:
									gl.depthFunc(gl.GREATER);
									break;

								case NotEqualDepth:
									gl.depthFunc(gl.NOTEQUAL);
									break;

								default:
									gl.depthFunc(gl.LEQUAL);
							}
						} else {
							gl.depthFunc(gl.LEQUAL);
						}

						currentDepthFunc = depthFunc;
					}
				},
				setLocked: function (lock) {
					locked = lock;
				},
				setClear: function (depth) {
					if (currentDepthClear !== depth) {
						gl.clearDepth(depth);
						currentDepthClear = depth;
					}
				},
				reset: function () {
					locked = false;
					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;
				}
			};
		}

		function StencilBuffer() {
			let locked = false;
			let currentStencilMask = null;
			let currentStencilFunc = null;
			let currentStencilRef = null;
			let currentStencilFuncMask = null;
			let currentStencilFail = null;
			let currentStencilZFail = null;
			let currentStencilZPass = null;
			let currentStencilClear = null;
			return {
				setTest: function (stencilTest) {
					if (!locked) {
						if (stencilTest) {
							enable(gl.STENCIL_TEST);
						} else {
							disable(gl.STENCIL_TEST);
						}
					}
				},
				setMask: function (stencilMask) {
					if (currentStencilMask !== stencilMask && !locked) {
						gl.stencilMask(stencilMask);
						currentStencilMask = stencilMask;
					}
				},
				setFunc: function (stencilFunc, stencilRef, stencilMask) {
					if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
						gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;
					}
				},
				setOp: function (stencilFail, stencilZFail, stencilZPass) {
					if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
						gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;
					}
				},
				setLocked: function (lock) {
					locked = lock;
				},
				setClear: function (stencil) {
					if (currentStencilClear !== stencil) {
						gl.clearStencil(stencil);
						currentStencilClear = stencil;
					}
				},
				reset: function () {
					locked = false;
					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;
				}
			};
		} //


		const colorBuffer = new ColorBuffer();
		const depthBuffer = new DepthBuffer();
		const stencilBuffer = new StencilBuffer();
		let enabledCapabilities = {};
		let currentBoundFramebuffers = {};
		let currentProgram = null;
		let currentBlendingEnabled = false;
		let currentBlending = null;
		let currentBlendEquation = null;
		let currentBlendSrc = null;
		let currentBlendDst = null;
		let currentBlendEquationAlpha = null;
		let currentBlendSrcAlpha = null;
		let currentBlendDstAlpha = null;
		let currentPremultipledAlpha = false;
		let currentFlipSided = null;
		let currentCullFace = null;
		let currentLineWidth = null;
		let currentPolygonOffsetFactor = null;
		let currentPolygonOffsetUnits = null;
		const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
		let lineWidthAvailable = false;
		let version = 0;
		const glVersion = gl.getParameter(gl.VERSION);

		if (glVersion.indexOf('WebGL') !== -1) {
			version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
			lineWidthAvailable = version >= 1.0;
		} else if (glVersion.indexOf('OpenGL ES') !== -1) {
			version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
			lineWidthAvailable = version >= 2.0;
		}

		let currentTextureSlot = null;
		let currentBoundTextures = {};
		const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
		const viewportParam = gl.getParameter(gl.VIEWPORT);
		const currentScissor = new Vector4().fromArray(scissorParam);
		const currentViewport = new Vector4().fromArray(viewportParam);

		function createTexture(type, target, count) {
			const data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.

			const texture = gl.createTexture();
			gl.bindTexture(type, texture);
			gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

			for (let i = 0; i < count; i++) {
				gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
			}

			return texture;
		}

		const emptyTextures = {};
		emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
		emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6); // init

		colorBuffer.setClear(0, 0, 0, 1);
		depthBuffer.setClear(1);
		stencilBuffer.setClear(0);
		enable(gl.DEPTH_TEST);
		depthBuffer.setFunc(LessEqualDepth);
		setFlipSided(false);
		setCullFace(CullFaceBack);
		enable(gl.CULL_FACE);
		setBlending(NoBlending); //

		function enable(id) {
			if (enabledCapabilities[id] !== true) {
				gl.enable(id);
				enabledCapabilities[id] = true;
			}
		}

		function disable(id) {
			if (enabledCapabilities[id] !== false) {
				gl.disable(id);
				enabledCapabilities[id] = false;
			}
		}

		function bindFramebuffer(target, framebuffer) {
			if (currentBoundFramebuffers[target] !== framebuffer) {
				gl.bindFramebuffer(target, framebuffer);
				currentBoundFramebuffers[target] = framebuffer;

				if (isWebGL2) {
					// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER
					if (target === gl.DRAW_FRAMEBUFFER) {
						currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
					}

					if (target === gl.FRAMEBUFFER) {
						currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
					}
				}

				return true;
			}

			return false;
		}

		function useProgram(program) {
			if (currentProgram !== program) {
				gl.useProgram(program);
				currentProgram = program;
				return true;
			}

			return false;
		}

		const equationToGL = {
			[AddEquation]: gl.FUNC_ADD,
			[SubtractEquation]: gl.FUNC_SUBTRACT,
			[ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
		};

		if (isWebGL2) {
			equationToGL[MinEquation] = gl.MIN;
			equationToGL[MaxEquation] = gl.MAX;
		} else {
			const extension = extensions.get('EXT_blend_minmax');

			if (extension !== null) {
				equationToGL[MinEquation] = extension.MIN_EXT;
				equationToGL[MaxEquation] = extension.MAX_EXT;
			}
		}

		const factorToGL = {
			[ZeroFactor]: gl.ZERO,
			[OneFactor]: gl.ONE,
			[SrcColorFactor]: gl.SRC_COLOR,
			[SrcAlphaFactor]: gl.SRC_ALPHA,
			[SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
			[DstColorFactor]: gl.DST_COLOR,
			[DstAlphaFactor]: gl.DST_ALPHA,
			[OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
			[OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
			[OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
			[OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA
		};

		function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
			if (blending === NoBlending) {
				if (currentBlendingEnabled === true) {
					disable(gl.BLEND);
					currentBlendingEnabled = false;
				}

				return;
			}

			if (currentBlendingEnabled === false) {
				enable(gl.BLEND);
				currentBlendingEnabled = true;
			}

			if (blending !== CustomBlending) {
				if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
					if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
						gl.blendEquation(gl.FUNC_ADD);
						currentBlendEquation = AddEquation;
						currentBlendEquationAlpha = AddEquation;
					}

					if (premultipliedAlpha) {
						switch (blending) {
							case NormalBlending:
								gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
								break;

							case AdditiveBlending:
								gl.blendFunc(gl.ONE, gl.ONE);
								break;

							case SubtractiveBlending:
								gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
								break;

							case MultiplyBlending:
								gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
								break;

							default:
								console.error('THREE.WebGLState: Invalid blending: ', blending);
								break;
						}
					} else {
						switch (blending) {
							case NormalBlending:
								gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
								break;

							case AdditiveBlending:
								gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
								break;

							case SubtractiveBlending:
								gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
								break;

							case MultiplyBlending:
								gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
								break;

							default:
								console.error('THREE.WebGLState: Invalid blending: ', blending);
								break;
						}
					}

					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;
					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;
				}

				return;
			} // custom blending


			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
				gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;
			}

			if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
				gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;
			}

			currentBlending = blending;
			currentPremultipledAlpha = null;
		}

		function setMaterial(material, frontFaceCW) {
			material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
			let flipSided = material.side === BackSide;
			if (frontFaceCW) flipSided = !flipSided;
			setFlipSided(flipSided);
			material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
			depthBuffer.setFunc(material.depthFunc);
			depthBuffer.setTest(material.depthTest);
			depthBuffer.setMask(material.depthWrite);
			colorBuffer.setMask(material.colorWrite);
			const stencilWrite = material.stencilWrite;
			stencilBuffer.setTest(stencilWrite);

			if (stencilWrite) {
				stencilBuffer.setMask(material.stencilWriteMask);
				stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
				stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
			}

			setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
			material.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
		} //


		function setFlipSided(flipSided) {
			if (currentFlipSided !== flipSided) {
				if (flipSided) {
					gl.frontFace(gl.CW);
				} else {
					gl.frontFace(gl.CCW);
				}

				currentFlipSided = flipSided;
			}
		}

		function setCullFace(cullFace) {
			if (cullFace !== CullFaceNone) {
				enable(gl.CULL_FACE);

				if (cullFace !== currentCullFace) {
					if (cullFace === CullFaceBack) {
						gl.cullFace(gl.BACK);
					} else if (cullFace === CullFaceFront) {
						gl.cullFace(gl.FRONT);
					} else {
						gl.cullFace(gl.FRONT_AND_BACK);
					}
				}
			} else {
				disable(gl.CULL_FACE);
			}

			currentCullFace = cullFace;
		}

		function setLineWidth(width) {
			if (width !== currentLineWidth) {
				if (lineWidthAvailable) gl.lineWidth(width);
				currentLineWidth = width;
			}
		}

		function setPolygonOffset(polygonOffset, factor, units) {
			if (polygonOffset) {
				enable(gl.POLYGON_OFFSET_FILL);

				if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
					gl.polygonOffset(factor, units);
					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;
				}
			} else {
				disable(gl.POLYGON_OFFSET_FILL);
			}
		}

		function setScissorTest(scissorTest) {
			if (scissorTest) {
				enable(gl.SCISSOR_TEST);
			} else {
				disable(gl.SCISSOR_TEST);
			}
		} // texture


		function activeTexture(webglSlot) {
			if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;

			if (currentTextureSlot !== webglSlot) {
				gl.activeTexture(webglSlot);
				currentTextureSlot = webglSlot;
			}
		}

		function bindTexture(webglType, webglTexture) {
			if (currentTextureSlot === null) {
				activeTexture();
			}

			let boundTexture = currentBoundTextures[currentTextureSlot];

			if (boundTexture === undefined) {
				boundTexture = {
					type: undefined,
					texture: undefined
				};
				currentBoundTextures[currentTextureSlot] = boundTexture;
			}

			if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
				gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;
			}
		}

		function unbindTexture() {
			const boundTexture = currentBoundTextures[currentTextureSlot];

			if (boundTexture !== undefined && boundTexture.type !== undefined) {
				gl.bindTexture(boundTexture.type, null);
				boundTexture.type = undefined;
				boundTexture.texture = undefined;
			}
		}

		function compressedTexImage2D() {
			try {
				gl.compressedTexImage2D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function texSubImage2D() {
			try {
				gl.texSubImage2D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function texStorage2D() {
			try {
				gl.texStorage2D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function texImage2D() {
			try {
				gl.texImage2D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function texImage3D() {
			try {
				gl.texImage3D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		} //


		function scissor(scissor) {
			if (currentScissor.equals(scissor) === false) {
				gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
				currentScissor.copy(scissor);
			}
		}

		function viewport(viewport) {
			if (currentViewport.equals(viewport) === false) {
				gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
				currentViewport.copy(viewport);
			}
		} //


		function reset() {
			// reset state
			gl.disable(gl.BLEND);
			gl.disable(gl.CULL_FACE);
			gl.disable(gl.DEPTH_TEST);
			gl.disable(gl.POLYGON_OFFSET_FILL);
			gl.disable(gl.SCISSOR_TEST);
			gl.disable(gl.STENCIL_TEST);
			gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
			gl.blendEquation(gl.FUNC_ADD);
			gl.blendFunc(gl.ONE, gl.ZERO);
			gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
			gl.colorMask(true, true, true, true);
			gl.clearColor(0, 0, 0, 0);
			gl.depthMask(true);
			gl.depthFunc(gl.LESS);
			gl.clearDepth(1);
			gl.stencilMask(0xffffffff);
			gl.stencilFunc(gl.ALWAYS, 0, 0xffffffff);
			gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
			gl.clearStencil(0);
			gl.cullFace(gl.BACK);
			gl.frontFace(gl.CCW);
			gl.polygonOffset(0, 0);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			if (isWebGL2 === true) {
				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
				gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
			}

			gl.useProgram(null);
			gl.lineWidth(1);
			gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); // reset internals

			enabledCapabilities = {};
			currentTextureSlot = null;
			currentBoundTextures = {};
			currentBoundFramebuffers = {};
			currentProgram = null;
			currentBlendingEnabled = false;
			currentBlending = null;
			currentBlendEquation = null;
			currentBlendSrc = null;
			currentBlendDst = null;
			currentBlendEquationAlpha = null;
			currentBlendSrcAlpha = null;
			currentBlendDstAlpha = null;
			currentPremultipledAlpha = false;
			currentFlipSided = null;
			currentCullFace = null;
			currentLineWidth = null;
			currentPolygonOffsetFactor = null;
			currentPolygonOffsetUnits = null;
			currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
			currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();
		}

		return {
			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},
			enable: enable,
			disable: disable,
			bindFramebuffer: bindFramebuffer,
			useProgram: useProgram,
			setBlending: setBlending,
			setMaterial: setMaterial,
			setFlipSided: setFlipSided,
			setCullFace: setCullFace,
			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,
			setScissorTest: setScissorTest,
			activeTexture: activeTexture,
			bindTexture: bindTexture,
			unbindTexture: unbindTexture,
			compressedTexImage2D: compressedTexImage2D,
			texImage2D: texImage2D,
			texImage3D: texImage3D,
			texStorage2D: texStorage2D,
			texSubImage2D: texSubImage2D,
			scissor: scissor,
			viewport: viewport,
			reset: reset
		};
	}

	function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
		const isWebGL2 = capabilities.isWebGL2;
		const maxTextures = capabilities.maxTextures;
		const maxCubemapSize = capabilities.maxCubemapSize;
		const maxTextureSize = capabilities.maxTextureSize;
		const maxSamples = capabilities.maxSamples;
		const hasMultisampledRenderToTexture = extensions.has('WEBGL_multisampled_render_to_texture');
		const MultisampledRenderToTextureExtension = hasMultisampledRenderToTexture ? extensions.get('WEBGL_multisampled_render_to_texture') : undefined;

		const _videoTextures = new WeakMap();

		let _canvas; // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
		// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
		// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).


		let useOffscreenCanvas = false;

		try {
			useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext('2d') !== null;
		} catch (err) {// Ignore any errors
		}

		function createCanvas(width, height) {
			// Use OffscreenCanvas when available. Specially needed in web workers
			return useOffscreenCanvas ? new OffscreenCanvas(width, height) : createElementNS('canvas');
		}

		function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
			let scale = 1; // handle case if texture exceeds max size

			if (image.width > maxSize || image.height > maxSize) {
				scale = maxSize / Math.max(image.width, image.height);
			} // only perform resize if necessary


			if (scale < 1 || needsPowerOfTwo === true) {
				// only perform resize for certain image types
				if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
					const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
					const width = floor(scale * image.width);
					const height = floor(scale * image.height);
					if (_canvas === undefined) _canvas = createCanvas(width, height); // cube textures can't reuse the same canvas

					const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
					canvas.width = width;
					canvas.height = height;
					const context = canvas.getContext('2d');
					context.drawImage(image, 0, 0, width, height);
					console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');
					return canvas;
				} else {
					if ('data' in image) {
						console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
					}

					return image;
				}
			}

			return image;
		}

		function isPowerOfTwo$1(image) {
			return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
		}

		function textureNeedsPowerOfTwo(texture) {
			if (isWebGL2) return false;
			return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
		}

		function textureNeedsGenerateMipmaps(texture, supportsMips) {
			return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
		}

		function generateMipmap(target) {
			_gl.generateMipmap(target);
		}

		function getInternalFormat(internalFormatName, glFormat, glType
		/*, encoding*/
		) {
			if (isWebGL2 === false) return glFormat;

			if (internalFormatName !== null) {
				if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
				console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
			}

			let internalFormat = glFormat;

			if (glFormat === _gl.RED) {
				if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
				if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
				if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
			}

			if (glFormat === _gl.RGB) {
				if (glType === _gl.FLOAT) internalFormat = _gl.RGB32F;
				if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGB16F;
				if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGB8;
			}

			if (glFormat === _gl.RGBA) {
				if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
				if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F; //if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = ( encoding === sRGBEncoding ) ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;

				if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGBA8;
			}

			if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
				extensions.get('EXT_color_buffer_float');
			}

			return internalFormat;
		}

		function getMipLevels(texture, image, supportsMips) {
			if (textureNeedsGenerateMipmaps(texture, supportsMips) === true) {
				// generated mipmaps via gl.generateMipmap()
				return Math.log2(Math.max(image.width, image.height)) + 1;
			} else if (texture.mipmaps.length > 0) {
				// user-defined mipmaps
				return texture.mipmaps.length;
			} else {
				// texture without mipmaps (only base level)
				return 1;
			}
		} // Fallback filters for non-power-of-2 textures


		function filterFallback(f) {
			if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
				return _gl.NEAREST;
			}

			return _gl.LINEAR;
		} //


		function onTextureDispose(event) {
			const texture = event.target;
			texture.removeEventListener('dispose', onTextureDispose);
			deallocateTexture(texture);

			if (texture.isVideoTexture) {
				_videoTextures.delete(texture);
			}

			info.memory.textures--;
		}

		function onRenderTargetDispose(event) {
			const renderTarget = event.target;
			renderTarget.removeEventListener('dispose', onRenderTargetDispose);
			deallocateRenderTarget(renderTarget);
		} //


		function deallocateTexture(texture) {
			const textureProperties = properties.get(texture);
			if (textureProperties.__webglInit === undefined) return;

			_gl.deleteTexture(textureProperties.__webglTexture);

			properties.remove(texture);
		}

		function deallocateRenderTarget(renderTarget) {
			const texture = renderTarget.texture;
			const renderTargetProperties = properties.get(renderTarget);
			const textureProperties = properties.get(texture);
			if (!renderTarget) return;

			if (textureProperties.__webglTexture !== undefined) {
				_gl.deleteTexture(textureProperties.__webglTexture);

				info.memory.textures--;
			}

			if (renderTarget.depthTexture) {
				renderTarget.depthTexture.dispose();
			}

			if (renderTarget.isWebGLCubeRenderTarget) {
				for (let i = 0; i < 6; i++) {
					_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);

					if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
				}
			} else {
				_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);

				if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
				if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
				if (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
				if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
			}

			if (renderTarget.isWebGLMultipleRenderTargets) {
				for (let i = 0, il = texture.length; i < il; i++) {
					const attachmentProperties = properties.get(texture[i]);

					if (attachmentProperties.__webglTexture) {
						_gl.deleteTexture(attachmentProperties.__webglTexture);

						info.memory.textures--;
					}

					properties.remove(texture[i]);
				}
			}

			properties.remove(texture);
			properties.remove(renderTarget);
		} //


		let textureUnits = 0;

		function resetTextureUnits() {
			textureUnits = 0;
		}

		function allocateTextureUnit() {
			const textureUnit = textureUnits;

			if (textureUnit >= maxTextures) {
				console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
			}

			textureUnits += 1;
			return textureUnit;
		} //


		function setTexture2D(texture, slot) {
			const textureProperties = properties.get(texture);
			if (texture.isVideoTexture) updateVideoTexture(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				const image = texture.image;

				if (image === undefined) {
					console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
				} else if (image.complete === false) {
					console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
				} else {
					uploadTexture(textureProperties, texture, slot);
					return;
				}
			}

			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
		}

		function setTexture2DArray(texture, slot) {
			const textureProperties = properties.get(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadTexture(textureProperties, texture, slot);
				return;
			}

			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture);
		}

		function setTexture3D(texture, slot) {
			const textureProperties = properties.get(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadTexture(textureProperties, texture, slot);
				return;
			}

			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture);
		}

		function setTextureCube(texture, slot) {
			const textureProperties = properties.get(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadCubeTexture(textureProperties, texture, slot);
				return;
			}

			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
		}

		const wrappingToGL = {
			[RepeatWrapping]: _gl.REPEAT,
			[ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
			[MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
		};
		const filterToGL = {
			[NearestFilter]: _gl.NEAREST,
			[NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
			[NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
			[LinearFilter]: _gl.LINEAR,
			[LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
			[LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
		};

		function setTextureParameters(textureType, texture, supportsMips) {
			if (supportsMips) {
				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);

				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);

				if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
					_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
				}

				_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);

				_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
			} else {
				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);

				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);

				if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
					_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
				}

				if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
					console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
				}

				_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));

				_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));

				if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
					console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
				}
			}

			if (extensions.has('EXT_texture_filter_anisotropic') === true) {
				const extension = extensions.get('EXT_texture_filter_anisotropic');
				if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false) return; // verify extension for WebGL 1 and WebGL 2

				if (isWebGL2 === false && texture.type === HalfFloatType && extensions.has('OES_texture_half_float_linear') === false) return; // verify extension for WebGL 1 only

				if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
					_gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));

					properties.get(texture).__currentAnisotropy = texture.anisotropy;
				}
			}
		}

		function initTexture(textureProperties, texture) {
			if (textureProperties.__webglInit === undefined) {
				textureProperties.__webglInit = true;
				texture.addEventListener('dispose', onTextureDispose);
				textureProperties.__webglTexture = _gl.createTexture();
				info.memory.textures++;
			}
		}

		function uploadTexture(textureProperties, texture, slot) {
			let textureType = _gl.TEXTURE_2D;
			if (texture.isDataTexture2DArray) textureType = _gl.TEXTURE_2D_ARRAY;
			if (texture.isDataTexture3D) textureType = _gl.TEXTURE_3D;
			initTexture(textureProperties, texture);
			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(textureType, textureProperties.__webglTexture);

			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);

			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);

			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);

			_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);

			const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
			const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
			const supportsMips = isPowerOfTwo$1(image) || isWebGL2,
						glFormat = utils.convert(texture.format);
			let glType = utils.convert(texture.type),
					glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
			setTextureParameters(textureType, texture, supportsMips);
			let mipmap;
			const mipmaps = texture.mipmaps;

			if (texture.isDepthTexture) {
				// populate depth texture with dummy data
				glInternalFormat = _gl.DEPTH_COMPONENT;

				if (isWebGL2) {
					if (texture.type === FloatType) {
						glInternalFormat = _gl.DEPTH_COMPONENT32F;
					} else if (texture.type === UnsignedIntType) {
						glInternalFormat = _gl.DEPTH_COMPONENT24;
					} else if (texture.type === UnsignedInt248Type) {
						glInternalFormat = _gl.DEPTH24_STENCIL8;
					} else {
						glInternalFormat = _gl.DEPTH_COMPONENT16; // WebGL2 requires sized internalformat for glTexImage2D
					}
				} else {
					if (texture.type === FloatType) {
						console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');
					}
				} // validation checks for WebGL 1


				if (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
						console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
						texture.type = UnsignedShortType;
						glType = utils.convert(texture.type);
					}
				}

				if (texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
					// Depth stencil textures need the DEPTH_STENCIL internal format
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					glInternalFormat = _gl.DEPTH_STENCIL; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)

					if (texture.type !== UnsignedInt248Type) {
						console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
						texture.type = UnsignedInt248Type;
						glType = utils.convert(texture.type);
					}
				} //


				state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
			} else if (texture.isDataTexture) {
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
				if (mipmaps.length > 0 && supportsMips) {
					for (let i = 0, il = mipmaps.length; i < il; i++) {
						mipmap = mipmaps[i];
						state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
					}

					texture.generateMipmaps = false;
				} else {
					state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
				}
			} else if (texture.isCompressedTexture) {
				for (let i = 0, il = mipmaps.length; i < il; i++) {
					mipmap = mipmaps[i];

					if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
						if (glFormat !== null) {
							state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
						} else {
							console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
						}
					} else {
						state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
					}
				}
			} else if (texture.isDataTexture2DArray) {
				state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
			} else if (texture.isDataTexture3D) {
				state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
			} else {
				// regular Texture (image, video, canvas)
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
				const levels = getMipLevels(texture, image, supportsMips);
				const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
				const allocateMemory = textureProperties.__version === undefined;

				if (mipmaps.length > 0 && supportsMips) {
					if (useTexStorage && allocateMemory) {
						state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
					}

					for (let i = 0, il = mipmaps.length; i < il; i++) {
						mipmap = mipmaps[i];

						if (useTexStorage) {
							state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap);
						} else {
							state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);
						}
					}

					texture.generateMipmaps = false;
				} else {
					if (useTexStorage) {
						if (allocateMemory) {
							state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
						}

						state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image);
					} else {
						state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
					}
				}
			}

			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				generateMipmap(textureType);
			}

			textureProperties.__version = texture.version;
			if (texture.onUpdate) texture.onUpdate(texture);
		}

		function uploadCubeTexture(textureProperties, texture, slot) {
			if (texture.image.length !== 6) return;
			initTexture(textureProperties, texture);
			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);

			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);

			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);

			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);

			_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);

			const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
			const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
			const cubeImage = [];

			for (let i = 0; i < 6; i++) {
				if (!isCompressed && !isDataTexture) {
					cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
				} else {
					cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
				}
			}

			const image = cubeImage[0],
						supportsMips = isPowerOfTwo$1(image) || isWebGL2,
						glFormat = utils.convert(texture.format),
						glType = utils.convert(texture.type),
						glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
			setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
			let mipmaps;

			if (isCompressed) {
				for (let i = 0; i < 6; i++) {
					mipmaps = cubeImage[i].mipmaps;

					for (let j = 0; j < mipmaps.length; j++) {
						const mipmap = mipmaps[j];

						if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
							if (glFormat !== null) {
								state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
							} else {
								console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
							}
						} else {
							state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
						}
					}
				}
			} else {
				mipmaps = texture.mipmaps;

				for (let i = 0; i < 6; i++) {
					if (isDataTexture) {
						state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);

						for (let j = 0; j < mipmaps.length; j++) {
							const mipmap = mipmaps[j];
							const mipmapImage = mipmap.image[i].image;
							state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
						}
					} else {
						state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);

						for (let j = 0; j < mipmaps.length; j++) {
							const mipmap = mipmaps[j];
							state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
						}
					}
				}
			}

			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				// We assume images for cube map have the same size.
				generateMipmap(_gl.TEXTURE_CUBE_MAP);
			}

			textureProperties.__version = texture.version;
			if (texture.onUpdate) texture.onUpdate(texture);
		} // Render targets
		// Setup storage for target texture and bind it to correct framebuffer


		function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
			const glFormat = utils.convert(texture.format);
			const glType = utils.convert(texture.type);
			const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
			const renderTargetProperties = properties.get(renderTarget);

			if (!renderTargetProperties.__hasExternalTextures) {
				if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
					state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
				} else {
					state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
				}
			}

			state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

			if (renderTarget.useRenderToTexture) {
				MultisampledRenderToTextureExtension.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
			} else {
				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
			}

			state.bindFramebuffer(_gl.FRAMEBUFFER, null);
		} // Setup storage for internal depth/stencil buffers and bind to correct framebuffer


		function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
			_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);

			if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
				let glInternalFormat = _gl.DEPTH_COMPONENT16;

				if (isMultisample || renderTarget.useRenderToTexture) {
					const depthTexture = renderTarget.depthTexture;

					if (depthTexture && depthTexture.isDepthTexture) {
						if (depthTexture.type === FloatType) {
							glInternalFormat = _gl.DEPTH_COMPONENT32F;
						} else if (depthTexture.type === UnsignedIntType) {
							glInternalFormat = _gl.DEPTH_COMPONENT24;
						}
					}

					const samples = getRenderTargetSamples(renderTarget);

					if (renderTarget.useRenderToTexture) {
						MultisampledRenderToTextureExtension.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
					} else {
						_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
					}
				} else {
					_gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
				}

				_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
			} else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
				const samples = getRenderTargetSamples(renderTarget);

				if (isMultisample && renderTarget.useRenderbuffer) {
					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
				} else if (renderTarget.useRenderToTexture) {
					MultisampledRenderToTextureExtension.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
				} else {
					_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
				}

				_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
			} else {
				// Use the first texture for MRT so far
				const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;
				const glFormat = utils.convert(texture.format);
				const glType = utils.convert(texture.type);
				const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
				const samples = getRenderTargetSamples(renderTarget);

				if (isMultisample && renderTarget.useRenderbuffer) {
					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
				} else if (renderTarget.useRenderToTexture) {
					MultisampledRenderToTextureExtension.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
				} else {
					_gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
				}
			}

			_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
		} // Setup resources for a Depth Texture for a FBO (needs an extension)


		function setupDepthTexture(framebuffer, renderTarget) {
			const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
			if (isCube) throw new Error('Depth Texture with cube render targets is not supported');
			state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

			if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
				throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
			} // upload an empty depth texture with framebuffer size


			if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;
			}

			setTexture2D(renderTarget.depthTexture, 0);

			const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;

			const samples = getRenderTargetSamples(renderTarget);

			if (renderTarget.depthTexture.format === DepthFormat) {
				if (renderTarget.useRenderToTexture) {
					MultisampledRenderToTextureExtension.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
				} else {
					_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
				}
			} else if (renderTarget.depthTexture.format === DepthStencilFormat) {
				if (renderTarget.useRenderToTexture) {
					MultisampledRenderToTextureExtension.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
				} else {
					_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
				}
			} else {
				throw new Error('Unknown depthTexture format');
			}
		} // Setup GL resources for a non-texture depth buffer


		function setupDepthRenderbuffer(renderTarget) {
			const renderTargetProperties = properties.get(renderTarget);
			const isCube = renderTarget.isWebGLCubeRenderTarget === true;

			if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
				if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
				setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
			} else {
				if (isCube) {
					renderTargetProperties.__webglDepthbuffer = [];

					for (let i = 0; i < 6; i++) {
						state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
						renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
						setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
					}
				} else {
					state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
				}
			}

			state.bindFramebuffer(_gl.FRAMEBUFFER, null);
		} // rebind framebuffer with external textures


		function rebindTextures(renderTarget, colorTexture, depthTexture) {
			const renderTargetProperties = properties.get(renderTarget);

			if (colorTexture !== undefined) {
				setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
			}

			if (depthTexture !== undefined) {
				setupDepthRenderbuffer(renderTarget);
			}
		} // Set up GL resources for the render target


		function setupRenderTarget(renderTarget) {
			const texture = renderTarget.texture;
			const renderTargetProperties = properties.get(renderTarget);
			const textureProperties = properties.get(texture);
			renderTarget.addEventListener('dispose', onRenderTargetDispose);

			if (renderTarget.isWebGLMultipleRenderTargets !== true) {
				if (textureProperties.__webglTexture === undefined) {
					textureProperties.__webglTexture = _gl.createTexture();
				}

				textureProperties.__version = texture.version;
				info.memory.textures++;
			}

			const isCube = renderTarget.isWebGLCubeRenderTarget === true;
			const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
			const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
			const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2; // Handles WebGL2 RGBFormat fallback - #18858

			if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {
				texture.format = RGBAFormat;
				console.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');
			} // Setup framebuffer


			if (isCube) {
				renderTargetProperties.__webglFramebuffer = [];

				for (let i = 0; i < 6; i++) {
					renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
				}
			} else {
				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

				if (isMultipleRenderTargets) {
					if (capabilities.drawBuffers) {
						const textures = renderTarget.texture;

						for (let i = 0, il = textures.length; i < il; i++) {
							const attachmentProperties = properties.get(textures[i]);

							if (attachmentProperties.__webglTexture === undefined) {
								attachmentProperties.__webglTexture = _gl.createTexture();
								info.memory.textures++;
							}
						}
					} else {
						console.warn('THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.');
					}
				} else if (renderTarget.useRenderbuffer) {
					if (isWebGL2) {
						renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
						renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

						_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);

						const glFormat = utils.convert(texture.format);
						const glType = utils.convert(texture.type);
						const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
						const samples = getRenderTargetSamples(renderTarget);

						_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);

						state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);

						_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);

						_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);

						if (renderTarget.depthBuffer) {
							renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
							setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
						}

						state.bindFramebuffer(_gl.FRAMEBUFFER, null);
					} else {
						console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
					}
				}
			} // Setup color buffer


			if (isCube) {
				state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
				setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);

				for (let i = 0; i < 6; i++) {
					setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
				}

				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
					generateMipmap(_gl.TEXTURE_CUBE_MAP);
				}

				state.unbindTexture();
			} else if (isMultipleRenderTargets) {
				const textures = renderTarget.texture;

				for (let i = 0, il = textures.length; i < il; i++) {
					const attachment = textures[i];
					const attachmentProperties = properties.get(attachment);
					state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
					setTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips);
					setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D);

					if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
						generateMipmap(_gl.TEXTURE_2D);
					}
				}

				state.unbindTexture();
			} else {
				let glTextureType = _gl.TEXTURE_2D;

				if (isRenderTarget3D) {
					// Render targets containing layers, i.e: Texture 3D and 2d arrays
					if (isWebGL2) {
						const isTexture3D = texture.isDataTexture3D;
						glTextureType = isTexture3D ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
					} else {
						console.warn('THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.');
					}
				}

				state.bindTexture(glTextureType, textureProperties.__webglTexture);
				setTextureParameters(glTextureType, texture, supportsMips);
				setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType);

				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
					generateMipmap(glTextureType);
				}

				state.unbindTexture();
			} // Setup depth and stencil buffers


			if (renderTarget.depthBuffer) {
				setupDepthRenderbuffer(renderTarget);
			}
		}

		function updateRenderTargetMipmap(renderTarget) {
			const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
			const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];

			for (let i = 0, il = textures.length; i < il; i++) {
				const texture = textures[i];

				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
					const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;

					const webglTexture = properties.get(texture).__webglTexture;

					state.bindTexture(target, webglTexture);
					generateMipmap(target);
					state.unbindTexture();
				}
			}
		}

		function updateMultisampleRenderTarget(renderTarget) {
			if (renderTarget.useRenderbuffer) {
				if (isWebGL2) {
					const width = renderTarget.width;
					const height = renderTarget.height;
					let mask = _gl.COLOR_BUFFER_BIT;
					const invalidationArray = [_gl.COLOR_ATTACHMENT0];
					const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;

					if (renderTarget.depthBuffer) {
						invalidationArray.push(depthStyle);
					}

					if (!renderTarget.ignoreDepthForMultisampleCopy) {
						if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
						if (renderTarget.stencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;
					}

					const renderTargetProperties = properties.get(renderTarget);
					state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
					state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);

					if (renderTarget.ignoreDepthForMultisampleCopy) {
						_gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, [depthStyle]);

						_gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);
					}

					_gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);

					_gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArray);

					state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
					state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
				} else {
					console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
				}
			}
		}

		function getRenderTargetSamples(renderTarget) {
			return isWebGL2 && (renderTarget.useRenderbuffer || renderTarget.useRenderToTexture) ? Math.min(maxSamples, renderTarget.samples) : 0;
		}

		function updateVideoTexture(texture) {
			const frame = info.render.frame; // Check the last frame we updated the VideoTexture

			if (_videoTextures.get(texture) !== frame) {
				_videoTextures.set(texture, frame);

				texture.update();
			}
		} // backwards compatibility


		let warnedTexture2D = false;
		let warnedTextureCube = false;

		function safeSetTexture2D(texture, slot) {
			if (texture && texture.isWebGLRenderTarget) {
				if (warnedTexture2D === false) {
					console.warn('THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.');
					warnedTexture2D = true;
				}

				texture = texture.texture;
			}

			setTexture2D(texture, slot);
		}

		function safeSetTextureCube(texture, slot) {
			if (texture && texture.isWebGLCubeRenderTarget) {
				if (warnedTextureCube === false) {
					console.warn('THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.');
					warnedTextureCube = true;
				}

				texture = texture.texture;
			}

			setTextureCube(texture, slot);
		} //


		this.allocateTextureUnit = allocateTextureUnit;
		this.resetTextureUnits = resetTextureUnits;
		this.setTexture2D = setTexture2D;
		this.setTexture2DArray = setTexture2DArray;
		this.setTexture3D = setTexture3D;
		this.setTextureCube = setTextureCube;
		this.rebindTextures = rebindTextures;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;
		this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
		this.setupDepthRenderbuffer = setupDepthRenderbuffer;
		this.setupFrameBufferTexture = setupFrameBufferTexture;
		this.safeSetTexture2D = safeSetTexture2D;
		this.safeSetTextureCube = safeSetTextureCube;
	}

	function WebGLUtils(gl, extensions, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;

		function convert(p) {
			let extension;
			if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
			if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
			if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
			if (p === UnsignedShort565Type) return gl.UNSIGNED_SHORT_5_6_5;
			if (p === ByteType) return gl.BYTE;
			if (p === ShortType) return gl.SHORT;
			if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
			if (p === IntType) return gl.INT;
			if (p === UnsignedIntType) return gl.UNSIGNED_INT;
			if (p === FloatType) return gl.FLOAT;

			if (p === HalfFloatType) {
				if (isWebGL2) return gl.HALF_FLOAT;
				extension = extensions.get('OES_texture_half_float');

				if (extension !== null) {
					return extension.HALF_FLOAT_OES;
				} else {
					return null;
				}
			}

			if (p === AlphaFormat) return gl.ALPHA;
			if (p === RGBFormat) return gl.RGB;
			if (p === RGBAFormat) return gl.RGBA;
			if (p === LuminanceFormat) return gl.LUMINANCE;
			if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
			if (p === DepthFormat) return gl.DEPTH_COMPONENT;
			if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;
			if (p === RedFormat) return gl.RED; // WebGL2 formats.

			if (p === RedIntegerFormat) return gl.RED_INTEGER;
			if (p === RGFormat) return gl.RG;
			if (p === RGIntegerFormat) return gl.RG_INTEGER;
			if (p === RGBIntegerFormat) return gl.RGB_INTEGER;
			if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;

			if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
				extension = extensions.get('WEBGL_compressed_texture_s3tc');

				if (extension !== null) {
					if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
				} else {
					return null;
				}
			}

			if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
				extension = extensions.get('WEBGL_compressed_texture_pvrtc');

				if (extension !== null) {
					if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
				} else {
					return null;
				}
			}

			if (p === RGB_ETC1_Format) {
				extension = extensions.get('WEBGL_compressed_texture_etc1');

				if (extension !== null) {
					return extension.COMPRESSED_RGB_ETC1_WEBGL;
				} else {
					return null;
				}
			}

			if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
				extension = extensions.get('WEBGL_compressed_texture_etc');

				if (extension !== null) {
					if (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;
					if (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;
				}
			}

			if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
				extension = extensions.get('WEBGL_compressed_texture_astc');

				if (extension !== null) {
					// TODO Complete?
					return p;
				} else {
					return null;
				}
			}

			if (p === RGBA_BPTC_Format) {
				extension = extensions.get('EXT_texture_compression_bptc');

				if (extension !== null) {
					// TODO Complete?
					return p;
				} else {
					return null;
				}
			}

			if (p === UnsignedInt248Type) {
				if (isWebGL2) return gl.UNSIGNED_INT_24_8;
				extension = extensions.get('WEBGL_depth_texture');

				if (extension !== null) {
					return extension.UNSIGNED_INT_24_8_WEBGL;
				} else {
					return null;
				}
			}
		}

		return {
			convert: convert
		};
	}

	class ArrayCamera extends PerspectiveCamera {
		constructor(array = []) {
			super();
			this.cameras = array;
		}

	}

	ArrayCamera.prototype.isArrayCamera = true;

	class Group extends Object3D {
		constructor() {
			super();
			this.type = 'Group';
		}

	}

	Group.prototype.isGroup = true;

	const _moveEvent = {
		type: 'move'
	};

	class WebXRController {
		constructor() {
			this._targetRay = null;
			this._grip = null;
			this._hand = null;
		}

		getHandSpace() {
			if (this._hand === null) {
				this._hand = new Group();
				this._hand.matrixAutoUpdate = false;
				this._hand.visible = false;
				this._hand.joints = {};
				this._hand.inputState = {
					pinching: false
				};
			}

			return this._hand;
		}

		getTargetRaySpace() {
			if (this._targetRay === null) {
				this._targetRay = new Group();
				this._targetRay.matrixAutoUpdate = false;
				this._targetRay.visible = false;
				this._targetRay.hasLinearVelocity = false;
				this._targetRay.linearVelocity = new Vector3();
				this._targetRay.hasAngularVelocity = false;
				this._targetRay.angularVelocity = new Vector3();
			}

			return this._targetRay;
		}

		getGripSpace() {
			if (this._grip === null) {
				this._grip = new Group();
				this._grip.matrixAutoUpdate = false;
				this._grip.visible = false;
				this._grip.hasLinearVelocity = false;
				this._grip.linearVelocity = new Vector3();
				this._grip.hasAngularVelocity = false;
				this._grip.angularVelocity = new Vector3();
			}

			return this._grip;
		}

		dispatchEvent(event) {
			if (this._targetRay !== null) {
				this._targetRay.dispatchEvent(event);
			}

			if (this._grip !== null) {
				this._grip.dispatchEvent(event);
			}

			if (this._hand !== null) {
				this._hand.dispatchEvent(event);
			}

			return this;
		}

		disconnect(inputSource) {
			this.dispatchEvent({
				type: 'disconnected',
				data: inputSource
			});

			if (this._targetRay !== null) {
				this._targetRay.visible = false;
			}

			if (this._grip !== null) {
				this._grip.visible = false;
			}

			if (this._hand !== null) {
				this._hand.visible = false;
			}

			return this;
		}

		update(inputSource, frame, referenceSpace) {
			let inputPose = null;
			let gripPose = null;
			let handPose = null;
			const targetRay = this._targetRay;
			const grip = this._grip;
			const hand = this._hand;

			if (inputSource && frame.session.visibilityState !== 'visible-blurred') {
				if (targetRay !== null) {
					inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);

					if (inputPose !== null) {
						targetRay.matrix.fromArray(inputPose.transform.matrix);
						targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);

						if (inputPose.linearVelocity) {
							targetRay.hasLinearVelocity = true;
							targetRay.linearVelocity.copy(inputPose.linearVelocity);
						} else {
							targetRay.hasLinearVelocity = false;
						}

						if (inputPose.angularVelocity) {
							targetRay.hasAngularVelocity = true;
							targetRay.angularVelocity.copy(inputPose.angularVelocity);
						} else {
							targetRay.hasAngularVelocity = false;
						}

						this.dispatchEvent(_moveEvent);
					}
				}

				if (hand && inputSource.hand) {
					handPose = true;

					for (const inputjoint of inputSource.hand.values()) {
						// Update the joints groups with the XRJoint poses
						const jointPose = frame.getJointPose(inputjoint, referenceSpace);

						if (hand.joints[inputjoint.jointName] === undefined) {
							// The transform of this joint will be updated with the joint pose on each frame
							const joint = new Group();
							joint.matrixAutoUpdate = false;
							joint.visible = false;
							hand.joints[inputjoint.jointName] = joint; // ??

							hand.add(joint);
						}

						const joint = hand.joints[inputjoint.jointName];

						if (jointPose !== null) {
							joint.matrix.fromArray(jointPose.transform.matrix);
							joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
							joint.jointRadius = jointPose.radius;
						}

						joint.visible = jointPose !== null;
					} // Custom events
					// Check pinchz


					const indexTip = hand.joints['index-finger-tip'];
					const thumbTip = hand.joints['thumb-tip'];
					const distance = indexTip.position.distanceTo(thumbTip.position);
					const distanceToPinch = 0.02;
					const threshold = 0.005;

					if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
						hand.inputState.pinching = false;
						this.dispatchEvent({
							type: 'pinchend',
							handedness: inputSource.handedness,
							target: this
						});
					} else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
						hand.inputState.pinching = true;
						this.dispatchEvent({
							type: 'pinchstart',
							handedness: inputSource.handedness,
							target: this
						});
					}
				} else {
					if (grip !== null && inputSource.gripSpace) {
						gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);

						if (gripPose !== null) {
							grip.matrix.fromArray(gripPose.transform.matrix);
							grip.matrix.decompose(grip.position, grip.rotation, grip.scale);

							if (gripPose.linearVelocity) {
								grip.hasLinearVelocity = true;
								grip.linearVelocity.copy(gripPose.linearVelocity);
							} else {
								grip.hasLinearVelocity = false;
							}

							if (gripPose.angularVelocity) {
								grip.hasAngularVelocity = true;
								grip.angularVelocity.copy(gripPose.angularVelocity);
							} else {
								grip.hasAngularVelocity = false;
							}
						}
					}
				}
			}

			if (targetRay !== null) {
				targetRay.visible = inputPose !== null;
			}

			if (grip !== null) {
				grip.visible = gripPose !== null;
			}

			if (hand !== null) {
				hand.visible = handPose !== null;
			}

			return this;
		}

	}

	class DepthTexture extends Texture {
		constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
			format = format !== undefined ? format : DepthFormat;

			if (format !== DepthFormat && format !== DepthStencilFormat) {
				throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
			}

			if (type === undefined && format === DepthFormat) type = UnsignedShortType;
			if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
			super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
			this.image = {
				width: width,
				height: height
			};
			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
			this.flipY = false;
			this.generateMipmaps = false;
		}

	}

	DepthTexture.prototype.isDepthTexture = true;

	class WebXRManager extends EventDispatcher {
		constructor(renderer, gl) {
			super();
			const scope = this;
			let session = null;
			let framebufferScaleFactor = 1.0;
			let referenceSpace = null;
			let referenceSpaceType = 'local-floor';
			const hasMultisampledRenderToTexture = renderer.extensions.has('WEBGL_multisampled_render_to_texture');
			let pose = null;
			let glBinding = null;
			let glProjLayer = null;
			let glBaseLayer = null;
			let isMultisample = false;
			let xrFrame = null;
			const attributes = gl.getContextAttributes();
			let initialRenderTarget = null;
			let newRenderTarget = null;
			const controllers = [];
			const inputSourcesMap = new Map(); //

			const cameraL = new PerspectiveCamera();
			cameraL.layers.enable(1);
			cameraL.viewport = new Vector4();
			const cameraR = new PerspectiveCamera();
			cameraR.layers.enable(2);
			cameraR.viewport = new Vector4();
			const cameras = [cameraL, cameraR];
			const cameraVR = new ArrayCamera();
			cameraVR.layers.enable(1);
			cameraVR.layers.enable(2);
			let _currentDepthNear = null;
			let _currentDepthFar = null; //

			this.cameraAutoUpdate = true;
			this.enabled = false;
			this.isPresenting = false;

			this.getController = function (index) {
				let controller = controllers[index];

				if (controller === undefined) {
					controller = new WebXRController();
					controllers[index] = controller;
				}

				return controller.getTargetRaySpace();
			};

			this.getControllerGrip = function (index) {
				let controller = controllers[index];

				if (controller === undefined) {
					controller = new WebXRController();
					controllers[index] = controller;
				}

				return controller.getGripSpace();
			};

			this.getHand = function (index) {
				let controller = controllers[index];

				if (controller === undefined) {
					controller = new WebXRController();
					controllers[index] = controller;
				}

				return controller.getHandSpace();
			}; //


			function onSessionEvent(event) {
				const controller = inputSourcesMap.get(event.inputSource);

				if (controller) {
					controller.dispatchEvent({
						type: event.type,
						data: event.inputSource
					});
				}
			}

			function onSessionEnd() {
				inputSourcesMap.forEach(function (controller, inputSource) {
					controller.disconnect(inputSource);
				});
				inputSourcesMap.clear();
				_currentDepthNear = null;
				_currentDepthFar = null; // restore framebuffer/rendering state

				renderer.setRenderTarget(initialRenderTarget);
				glBaseLayer = null;
				glProjLayer = null;
				glBinding = null;
				session = null;
				newRenderTarget = null; //

				animation.stop();
				scope.isPresenting = false;
				scope.dispatchEvent({
					type: 'sessionend'
				});
			}

			this.setFramebufferScaleFactor = function (value) {
				framebufferScaleFactor = value;

				if (scope.isPresenting === true) {
					console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
				}
			};

			this.setReferenceSpaceType = function (value) {
				referenceSpaceType = value;

				if (scope.isPresenting === true) {
					console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
				}
			};

			this.getReferenceSpace = function () {
				return referenceSpace;
			};

			this.getBaseLayer = function () {
				return glProjLayer !== null ? glProjLayer : glBaseLayer;
			};

			this.getBinding = function () {
				return glBinding;
			};

			this.getFrame = function () {
				return xrFrame;
			};

			this.getSession = function () {
				return session;
			};

			this.setSession = async function (value) {
				session = value;

				if (session !== null) {
					initialRenderTarget = renderer.getRenderTarget();
					session.addEventListener('select', onSessionEvent);
					session.addEventListener('selectstart', onSessionEvent);
					session.addEventListener('selectend', onSessionEvent);
					session.addEventListener('squeeze', onSessionEvent);
					session.addEventListener('squeezestart', onSessionEvent);
					session.addEventListener('squeezeend', onSessionEvent);
					session.addEventListener('end', onSessionEnd);
					session.addEventListener('inputsourceschange', onInputSourcesChange);

					if (attributes.xrCompatible !== true) {
						await gl.makeXRCompatible();
					}

					if (session.renderState.layers === undefined || renderer.capabilities.isWebGL2 === false) {
						const layerInit = {
							antialias: session.renderState.layers === undefined ? attributes.antialias : true,
							alpha: attributes.alpha,
							depth: attributes.depth,
							stencil: attributes.stencil,
							framebufferScaleFactor: framebufferScaleFactor
						};
						glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
						session.updateRenderState({
							baseLayer: glBaseLayer
						});
						newRenderTarget = new WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight);
					} else {
						isMultisample = attributes.antialias;
						let depthFormat = null;
						let depthType = null;
						let glDepthFormat = null;

						if (attributes.depth) {
							glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT16;
							depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
							depthType = attributes.stencil ? UnsignedInt248Type : UnsignedShortType;
						}

						const projectionlayerInit = {
							colorFormat: attributes.alpha || isMultisample ? gl.RGBA8 : gl.RGB8,
							depthFormat: glDepthFormat,
							scaleFactor: framebufferScaleFactor
						};
						glBinding = new XRWebGLBinding(session, gl);
						glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
						session.updateRenderState({
							layers: [glProjLayer]
						});

						if (isMultisample) {
							newRenderTarget = new WebGLMultisampleRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {
								format: RGBAFormat,
								type: UnsignedByteType,
								depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat),
								stencilBuffer: attributes.stencil,
								ignoreDepth: glProjLayer.ignoreDepthValues,
								useRenderToTexture: hasMultisampledRenderToTexture
							});
						} else {
							newRenderTarget = new WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {
								format: attributes.alpha ? RGBAFormat : RGBFormat,
								type: UnsignedByteType,
								depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat),
								stencilBuffer: attributes.stencil,
								ignoreDepth: glProjLayer.ignoreDepthValues
							});
						}
					} // Set foveation to maximum.


					this.setFoveation(0);
					referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
					animation.setContext(session);
					animation.start();
					scope.isPresenting = true;
					scope.dispatchEvent({
						type: 'sessionstart'
					});
				}
			};

			function onInputSourcesChange(event) {
				const inputSources = session.inputSources; // Assign inputSources to available controllers

				for (let i = 0; i < controllers.length; i++) {
					inputSourcesMap.set(inputSources[i], controllers[i]);
				} // Notify disconnected


				for (let i = 0; i < event.removed.length; i++) {
					const inputSource = event.removed[i];
					const controller = inputSourcesMap.get(inputSource);

					if (controller) {
						controller.dispatchEvent({
							type: 'disconnected',
							data: inputSource
						});
						inputSourcesMap.delete(inputSource);
					}
				} // Notify connected


				for (let i = 0; i < event.added.length; i++) {
					const inputSource = event.added[i];
					const controller = inputSourcesMap.get(inputSource);

					if (controller) {
						controller.dispatchEvent({
							type: 'connected',
							data: inputSource
						});
					}
				}
			} //


			const cameraLPos = new Vector3();
			const cameraRPos = new Vector3();
			/**
			 * Assumes 2 cameras that are parallel and share an X-axis, and that
			 * the cameras' projection and world matrices have already been set.
			 * And that near and far planes are identical for both cameras.
			 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
			 */

			function setProjectionFromUnion(camera, cameraL, cameraR) {
				cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
				cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
				const ipd = cameraLPos.distanceTo(cameraRPos);
				const projL = cameraL.projectionMatrix.elements;
				const projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and
				// most likely identical top and bottom frustum extents.
				// Use the left camera for these values.

				const near = projL[14] / (projL[10] - 1);
				const far = projL[14] / (projL[10] + 1);
				const topFov = (projL[9] + 1) / projL[5];
				const bottomFov = (projL[9] - 1) / projL[5];
				const leftFov = (projL[8] - 1) / projL[0];
				const rightFov = (projR[8] + 1) / projR[0];
				const left = near * leftFov;
				const right = near * rightFov; // Calculate the new camera's position offset from the
				// left camera. xOffset should be roughly half `ipd`.

				const zOffset = ipd / (-leftFov + rightFov);
				const xOffset = zOffset * -leftFov; // TODO: Better way to apply this offset?

				cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
				camera.translateX(xOffset);
				camera.translateZ(zOffset);
				camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
				camera.matrixWorldInverse.copy(camera.matrixWorld).invert(); // Find the union of the frustum values of the cameras and scale
				// the values so that the near plane's position does not change in world space,
				// although must now be relative to the new union camera.

				const near2 = near + zOffset;
				const far2 = far + zOffset;
				const left2 = left - xOffset;
				const right2 = right + (ipd - xOffset);
				const top2 = topFov * far / far2 * near2;
				const bottom2 = bottomFov * far / far2 * near2;
				camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
			}

			function updateCamera(camera, parent) {
				if (parent === null) {
					camera.matrixWorld.copy(camera.matrix);
				} else {
					camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
				}

				camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
			}

			this.updateCamera = function (camera) {
				if (session === null) return;
				cameraVR.near = cameraR.near = cameraL.near = camera.near;
				cameraVR.far = cameraR.far = cameraL.far = camera.far;

				if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
					// Note that the new renderState won't apply until the next frame. See #18320
					session.updateRenderState({
						depthNear: cameraVR.near,
						depthFar: cameraVR.far
					});
					_currentDepthNear = cameraVR.near;
					_currentDepthFar = cameraVR.far;
				}

				const parent = camera.parent;
				const cameras = cameraVR.cameras;
				updateCamera(cameraVR, parent);

				for (let i = 0; i < cameras.length; i++) {
					updateCamera(cameras[i], parent);
				}

				cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale); // update user camera and its children

				camera.position.copy(cameraVR.position);
				camera.quaternion.copy(cameraVR.quaternion);
				camera.scale.copy(cameraVR.scale);
				camera.matrix.copy(cameraVR.matrix);
				camera.matrixWorld.copy(cameraVR.matrixWorld);
				const children = camera.children;

				for (let i = 0, l = children.length; i < l; i++) {
					children[i].updateMatrixWorld(true);
				} // update projection matrix for proper view frustum culling


				if (cameras.length === 2) {
					setProjectionFromUnion(cameraVR, cameraL, cameraR);
				} else {
					// assume single camera setup (AR)
					cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
				}
			};

			this.getCamera = function () {
				return cameraVR;
			};

			this.getFoveation = function () {
				if (glProjLayer !== null) {
					return glProjLayer.fixedFoveation;
				}

				if (glBaseLayer !== null) {
					return glBaseLayer.fixedFoveation;
				}

				return undefined;
			};

			this.setFoveation = function (foveation) {
				// 0 = no foveation = full resolution
				// 1 = maximum foveation = the edges render at lower resolution
				if (glProjLayer !== null) {
					glProjLayer.fixedFoveation = foveation;
				}

				if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined) {
					glBaseLayer.fixedFoveation = foveation;
				}
			}; // Animation Loop


			let onAnimationFrameCallback = null;

			function onAnimationFrame(time, frame) {
				pose = frame.getViewerPose(referenceSpace);
				xrFrame = frame;

				if (pose !== null) {
					const views = pose.views;

					if (glBaseLayer !== null) {
						renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
						renderer.setRenderTarget(newRenderTarget);
					}

					let cameraVRNeedsUpdate = false; // check if it's necessary to rebuild cameraVR's camera list

					if (views.length !== cameraVR.cameras.length) {
						cameraVR.cameras.length = 0;
						cameraVRNeedsUpdate = true;
					}

					for (let i = 0; i < views.length; i++) {
						const view = views[i];
						let viewport = null;

						if (glBaseLayer !== null) {
							viewport = glBaseLayer.getViewport(view);
						} else {
							const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
							viewport = glSubImage.viewport; // For side-by-side projection, we only produce a single texture for both eyes.

							if (i === 0) {
								renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture);
								renderer.setRenderTarget(newRenderTarget);
							}
						}

						const camera = cameras[i];
						camera.matrix.fromArray(view.transform.matrix);
						camera.projectionMatrix.fromArray(view.projectionMatrix);
						camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);

						if (i === 0) {
							cameraVR.matrix.copy(camera.matrix);
						}

						if (cameraVRNeedsUpdate === true) {
							cameraVR.cameras.push(camera);
						}
					}
				} //


				const inputSources = session.inputSources;

				for (let i = 0; i < controllers.length; i++) {
					const controller = controllers[i];
					const inputSource = inputSources[i];
					controller.update(inputSource, frame, referenceSpace);
				}

				if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
				xrFrame = null;
			}

			const animation = new WebGLAnimation();
			animation.setAnimationLoop(onAnimationFrame);

			this.setAnimationLoop = function (callback) {
				onAnimationFrameCallback = callback;
			};

			this.dispose = function () {};
		}

	}

	function WebGLMaterials(properties) {
		function refreshFogUniforms(uniforms, fog) {
			uniforms.fogColor.value.copy(fog.color);

			if (fog.isFog) {
				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;
			} else if (fog.isFogExp2) {
				uniforms.fogDensity.value = fog.density;
			}
		}

		function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
			if (material.isMeshBasicMaterial) {
				refreshUniformsCommon(uniforms, material);
			} else if (material.isMeshLambertMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsLambert(uniforms, material);
			} else if (material.isMeshToonMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsToon(uniforms, material);
			} else if (material.isMeshPhongMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsPhong(uniforms, material);
			} else if (material.isMeshStandardMaterial) {
				refreshUniformsCommon(uniforms, material);

				if (material.isMeshPhysicalMaterial) {
					refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
				} else {
					refreshUniformsStandard(uniforms, material);
				}
			} else if (material.isMeshMatcapMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsMatcap(uniforms, material);
			} else if (material.isMeshDepthMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsDepth(uniforms, material);
			} else if (material.isMeshDistanceMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsDistance(uniforms, material);
			} else if (material.isMeshNormalMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsNormal(uniforms, material);
			} else if (material.isLineBasicMaterial) {
				refreshUniformsLine(uniforms, material);

				if (material.isLineDashedMaterial) {
					refreshUniformsDash(uniforms, material);
				}
			} else if (material.isPointsMaterial) {
				refreshUniformsPoints(uniforms, material, pixelRatio, height);
			} else if (material.isSpriteMaterial) {
				refreshUniformsSprites(uniforms, material);
			} else if (material.isShadowMaterial) {
				uniforms.color.value.copy(material.color);
				uniforms.opacity.value = material.opacity;
			} else if (material.isShaderMaterial) {
				material.uniformsNeedUpdate = false; // #15581
			}
		}

		function refreshUniformsCommon(uniforms, material) {
			uniforms.opacity.value = material.opacity;

			if (material.color) {
				uniforms.diffuse.value.copy(material.color);
			}

			if (material.emissive) {
				uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
			}

			if (material.map) {
				uniforms.map.value = material.map;
			}

			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap;
			}

			if (material.specularMap) {
				uniforms.specularMap.value = material.specularMap;
			}

			if (material.alphaTest > 0) {
				uniforms.alphaTest.value = material.alphaTest;
			}

			const envMap = properties.get(material).envMap;

			if (envMap) {
				uniforms.envMap.value = envMap;
				uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
				uniforms.reflectivity.value = material.reflectivity;
				uniforms.ior.value = material.ior;
				uniforms.refractionRatio.value = material.refractionRatio;
			}

			if (material.lightMap) {
				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;
			}

			if (material.aoMap) {
				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;
			} // uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. displacementMap map
			// 4. normal map
			// 5. bump map
			// 6. roughnessMap map
			// 7. metalnessMap map
			// 8. alphaMap map
			// 9. emissiveMap map
			// 10. clearcoat map
			// 11. clearcoat normal map
			// 12. clearcoat roughnessMap map
			// 13. specular intensity map
			// 14. specular tint map
			// 15. transmission map
			// 16. thickness map


			let uvScaleMap;

			if (material.map) {
				uvScaleMap = material.map;
			} else if (material.specularMap) {
				uvScaleMap = material.specularMap;
			} else if (material.displacementMap) {
				uvScaleMap = material.displacementMap;
			} else if (material.normalMap) {
				uvScaleMap = material.normalMap;
			} else if (material.bumpMap) {
				uvScaleMap = material.bumpMap;
			} else if (material.roughnessMap) {
				uvScaleMap = material.roughnessMap;
			} else if (material.metalnessMap) {
				uvScaleMap = material.metalnessMap;
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap;
			} else if (material.emissiveMap) {
				uvScaleMap = material.emissiveMap;
			} else if (material.clearcoatMap) {
				uvScaleMap = material.clearcoatMap;
			} else if (material.clearcoatNormalMap) {
				uvScaleMap = material.clearcoatNormalMap;
			} else if (material.clearcoatRoughnessMap) {
				uvScaleMap = material.clearcoatRoughnessMap;
			} else if (material.specularIntensityMap) {
				uvScaleMap = material.specularIntensityMap;
			} else if (material.specularColorMap) {
				uvScaleMap = material.specularColorMap;
			} else if (material.transmissionMap) {
				uvScaleMap = material.transmissionMap;
			} else if (material.thicknessMap) {
				uvScaleMap = material.thicknessMap;
			} else if (material.sheenColorMap) {
				uvScaleMap = material.sheenColorMap;
			} else if (material.sheenRoughnessMap) {
				uvScaleMap = material.sheenRoughnessMap;
			}

			if (uvScaleMap !== undefined) {
				// backwards compatibility
				if (uvScaleMap.isWebGLRenderTarget) {
					uvScaleMap = uvScaleMap.texture;
				}

				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix();
				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix);
			} // uv repeat and offset setting priorities for uv2
			// 1. ao map
			// 2. light map


			let uv2ScaleMap;

			if (material.aoMap) {
				uv2ScaleMap = material.aoMap;
			} else if (material.lightMap) {
				uv2ScaleMap = material.lightMap;
			}

			if (uv2ScaleMap !== undefined) {
				// backwards compatibility
				if (uv2ScaleMap.isWebGLRenderTarget) {
					uv2ScaleMap = uv2ScaleMap.texture;
				}

				if (uv2ScaleMap.matrixAutoUpdate === true) {
					uv2ScaleMap.updateMatrix();
				}

				uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
			}
		}

		function refreshUniformsLine(uniforms, material) {
			uniforms.diffuse.value.copy(material.color);
			uniforms.opacity.value = material.opacity;
		}

		function refreshUniformsDash(uniforms, material) {
			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;
		}

		function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
			uniforms.diffuse.value.copy(material.color);
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * pixelRatio;
			uniforms.scale.value = height * 0.5;

			if (material.map) {
				uniforms.map.value = material.map;
			}

			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap;
			}

			if (material.alphaTest > 0) {
				uniforms.alphaTest.value = material.alphaTest;
			} // uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map


			let uvScaleMap;

			if (material.map) {
				uvScaleMap = material.map;
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap;
			}

			if (uvScaleMap !== undefined) {
				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix();
				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix);
			}
		}

		function refreshUniformsSprites(uniforms, material) {
			uniforms.diffuse.value.copy(material.color);
			uniforms.opacity.value = material.opacity;
			uniforms.rotation.value = material.rotation;

			if (material.map) {
				uniforms.map.value = material.map;
			}

			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap;
			}

			if (material.alphaTest > 0) {
				uniforms.alphaTest.value = material.alphaTest;
			} // uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map


			let uvScaleMap;

			if (material.map) {
				uvScaleMap = material.map;
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap;
			}

			if (uvScaleMap !== undefined) {
				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix();
				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix);
			}
		}

		function refreshUniformsLambert(uniforms, material) {
			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}
		}

		function refreshUniformsPhong(uniforms, material) {
			uniforms.specular.value.copy(material.specular);
			uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )

			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsToon(uniforms, material) {
			if (material.gradientMap) {
				uniforms.gradientMap.value = material.gradientMap;
			}

			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsStandard(uniforms, material) {
			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;

			if (material.roughnessMap) {
				uniforms.roughnessMap.value = material.roughnessMap;
			}

			if (material.metalnessMap) {
				uniforms.metalnessMap.value = material.metalnessMap;
			}

			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}

			const envMap = properties.get(material).envMap;

			if (envMap) {
				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;
			}
		}

		function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
			refreshUniformsStandard(uniforms, material);
			uniforms.ior.value = material.ior; // also part of uniforms common

			if (material.sheen > 0) {
				uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
				uniforms.sheenRoughness.value = material.sheenRoughness;

				if (material.sheenColorMap) {
					uniforms.sheenColorMap.value = material.sheenColorMap;
				}

				if (material.sheenRoughnessMap) {
					uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
				}
			}

			if (material.clearcoat > 0) {
				uniforms.clearcoat.value = material.clearcoat;
				uniforms.clearcoatRoughness.value = material.clearcoatRoughness;

				if (material.clearcoatMap) {
					uniforms.clearcoatMap.value = material.clearcoatMap;
				}

				if (material.clearcoatRoughnessMap) {
					uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
				}

				if (material.clearcoatNormalMap) {
					uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
					uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

					if (material.side === BackSide) {
						uniforms.clearcoatNormalScale.value.negate();
					}
				}
			}

			if (material.transmission > 0) {
				uniforms.transmission.value = material.transmission;
				uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
				uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);

				if (material.transmissionMap) {
					uniforms.transmissionMap.value = material.transmissionMap;
				}

				uniforms.thickness.value = material.thickness;

				if (material.thicknessMap) {
					uniforms.thicknessMap.value = material.thicknessMap;
				}

				uniforms.attenuationDistance.value = material.attenuationDistance;
				uniforms.attenuationColor.value.copy(material.attenuationColor);
			}

			uniforms.specularIntensity.value = material.specularIntensity;
			uniforms.specularColor.value.copy(material.specularColor);

			if (material.specularIntensityMap) {
				uniforms.specularIntensityMap.value = material.specularIntensityMap;
			}

			if (material.specularColorMap) {
				uniforms.specularColorMap.value = material.specularColorMap;
			}
		}

		function refreshUniformsMatcap(uniforms, material) {
			if (material.matcap) {
				uniforms.matcap.value = material.matcap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsDepth(uniforms, material) {
			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsDistance(uniforms, material) {
			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}

			uniforms.referencePosition.value.copy(material.referencePosition);
			uniforms.nearDistance.value = material.nearDistance;
			uniforms.farDistance.value = material.farDistance;
		}

		function refreshUniformsNormal(uniforms, material) {
			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		return {
			refreshFogUniforms: refreshFogUniforms,
			refreshMaterialUniforms: refreshMaterialUniforms
		};
	}

	function createCanvasElement() {
		const canvas = createElementNS('canvas');
		canvas.style.display = 'block';
		return canvas;
	}

	function WebGLRenderer(parameters = {}) {
		const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
					_context = parameters.context !== undefined ? parameters.context : null,
					_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
					_depth = parameters.depth !== undefined ? parameters.depth : true,
					_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
					_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
					_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
					_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
					_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
					_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

		let currentRenderList = null;
		let currentRenderState = null; // render() can be called from within a callback triggered by another render.
		// We track this so that the nested render call gets its list and state isolated from the parent render call.

		const renderListStack = [];
		const renderStateStack = []; // public properties

		this.domElement = _canvas; // Debug configuration container

		this.debug = {
			/**
			 * Enables error checking and reporting when shader programs are being compiled
			 * @type {boolean}
			 */
			checkShaderErrors: true
		}; // clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true; // scene graph

		this.sortObjects = true; // user-defined clipping

		this.clippingPlanes = [];
		this.localClippingEnabled = false; // physically based shading

		this.gammaFactor = 2.0; // for backwards compatibility

		this.outputEncoding = LinearEncoding; // physical lights

		this.physicallyCorrectLights = false; // tone mapping

		this.toneMapping = NoToneMapping;
		this.toneMappingExposure = 1.0; // internal properties

		const _this = this;

		let _isContextLost = false; // internal state cache

		let _currentActiveCubeFace = 0;
		let _currentActiveMipmapLevel = 0;
		let _currentRenderTarget = null;

		let _currentMaterialId = -1;

		let _currentCamera = null;

		const _currentViewport = new Vector4();

		const _currentScissor = new Vector4();

		let _currentScissorTest = null; //

		let _width = _canvas.width;
		let _height = _canvas.height;
		let _pixelRatio = 1;
		let _opaqueSort = null;
		let _transparentSort = null;

		const _viewport = new Vector4(0, 0, _width, _height);

		const _scissor = new Vector4(0, 0, _width, _height);

		let _scissorTest = false; //

		const _currentDrawBuffers = []; // frustum

		const _frustum = new Frustum(); // clipping


		let _clippingEnabled = false;
		let _localClippingEnabled = false; // transmission

		let _transmissionRenderTarget = null; // camera matrices cache

		const _projScreenMatrix = new Matrix4();

		const _vector3 = new Vector3();

		const _emptyScene = {
			background: null,
			fog: null,
			environment: null,
			overrideMaterial: null,
			isScene: true
		};

		function getTargetPixelRatio() {
			return _currentRenderTarget === null ? _pixelRatio : 1;
		} // initialize


		let _gl = _context;

		function getContext(contextNames, contextAttributes) {
			for (let i = 0; i < contextNames.length; i++) {
				const contextName = contextNames[i];

				const context = _canvas.getContext(contextName, contextAttributes);

				if (context !== null) return context;
			}

			return null;
		}

		try {
			const contextAttributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer,
				powerPreference: _powerPreference,
				failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
			}; // OffscreenCanvas does not have setAttribute, see #22811

			if ('setAttribute' in _canvas) _canvas.setAttribute('data-engine', `three.js r${REVISION}`); // event listeners must be registered before WebGL context is created, see #12753

			_canvas.addEventListener('webglcontextlost', onContextLost, false);

			_canvas.addEventListener('webglcontextrestored', onContextRestore, false);

			if (_gl === null) {
				const contextNames = ['webgl2', 'webgl', 'experimental-webgl'];

				if (_this.isWebGL1Renderer === true) {
					contextNames.shift();
				}

				_gl = getContext(contextNames, contextAttributes);

				if (_gl === null) {
					if (getContext(contextNames)) {
						throw new Error('Error creating WebGL context with your selected attributes.');
					} else {
						throw new Error('Error creating WebGL context.');
					}
				}
			} // Some experimental-webgl implementations do not have getShaderPrecisionFormat


			if (_gl.getShaderPrecisionFormat === undefined) {
				_gl.getShaderPrecisionFormat = function () {
					return {
						'rangeMin': 1,
						'rangeMax': 1,
						'precision': 1
					};
				};
			}
		} catch (error) {
			console.error('THREE.WebGLRenderer: ' + error.message);
			throw error;
		}

		let extensions, capabilities, state, info;
		let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
		let programCache, materials, renderLists, renderStates, clipping, shadowMap;
		let background, morphtargets, bufferRenderer, indexedBufferRenderer;
		let utils, bindingStates;

		function initGLContext() {
			extensions = new WebGLExtensions(_gl);
			capabilities = new WebGLCapabilities(_gl, extensions, parameters);
			extensions.init(capabilities);
			utils = new WebGLUtils(_gl, extensions, capabilities);
			state = new WebGLState(_gl, extensions, capabilities);
			_currentDrawBuffers[0] = _gl.BACK;
			info = new WebGLInfo(_gl);
			properties = new WebGLProperties();
			textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
			cubemaps = new WebGLCubeMaps(_this);
			cubeuvmaps = new WebGLCubeUVMaps(_this);
			attributes = new WebGLAttributes(_gl, capabilities);
			bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
			geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
			objects = new WebGLObjects(_gl, geometries, attributes, info);
			morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
			clipping = new WebGLClipping(properties);
			programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
			materials = new WebGLMaterials(properties);
			renderLists = new WebGLRenderLists(properties);
			renderStates = new WebGLRenderStates(extensions, capabilities);
			background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
			shadowMap = new WebGLShadowMap(_this, objects, capabilities);
			bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
			indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
			info.programs = programCache.programs;
			_this.capabilities = capabilities;
			_this.extensions = extensions;
			_this.properties = properties;
			_this.renderLists = renderLists;
			_this.shadowMap = shadowMap;
			_this.state = state;
			_this.info = info;
		}

		initGLContext(); // xr

		const xr = new WebXRManager(_this, _gl);
		this.xr = xr; // API

		this.getContext = function () {
			return _gl;
		};

		this.getContextAttributes = function () {
			return _gl.getContextAttributes();
		};

		this.forceContextLoss = function () {
			const extension = extensions.get('WEBGL_lose_context');
			if (extension) extension.loseContext();
		};

		this.forceContextRestore = function () {
			const extension = extensions.get('WEBGL_lose_context');
			if (extension) extension.restoreContext();
		};

		this.getPixelRatio = function () {
			return _pixelRatio;
		};

		this.setPixelRatio = function (value) {
			if (value === undefined) return;
			_pixelRatio = value;
			this.setSize(_width, _height, false);
		};

		this.getSize = function (target) {
			return target.set(_width, _height);
		};

		this.setSize = function (width, height, updateStyle) {
			if (xr.isPresenting) {
				console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
				return;
			}

			_width = width;
			_height = height;
			_canvas.width = Math.floor(width * _pixelRatio);
			_canvas.height = Math.floor(height * _pixelRatio);

			if (updateStyle !== false) {
				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';
			}

			this.setViewport(0, 0, width, height);
		};

		this.getDrawingBufferSize = function (target) {
			return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
		};

		this.setDrawingBufferSize = function (width, height, pixelRatio) {
			_width = width;
			_height = height;
			_pixelRatio = pixelRatio;
			_canvas.width = Math.floor(width * pixelRatio);
			_canvas.height = Math.floor(height * pixelRatio);
			this.setViewport(0, 0, width, height);
		};

		this.getCurrentViewport = function (target) {
			return target.copy(_currentViewport);
		};

		this.getViewport = function (target) {
			return target.copy(_viewport);
		};

		this.setViewport = function (x, y, width, height) {
			if (x.isVector4) {
				_viewport.set(x.x, x.y, x.z, x.w);
			} else {
				_viewport.set(x, y, width, height);
			}

			state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
		};

		this.getScissor = function (target) {
			return target.copy(_scissor);
		};

		this.setScissor = function (x, y, width, height) {
			if (x.isVector4) {
				_scissor.set(x.x, x.y, x.z, x.w);
			} else {
				_scissor.set(x, y, width, height);
			}

			state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
		};

		this.getScissorTest = function () {
			return _scissorTest;
		};

		this.setScissorTest = function (boolean) {
			state.setScissorTest(_scissorTest = boolean);
		};

		this.setOpaqueSort = function (method) {
			_opaqueSort = method;
		};

		this.setTransparentSort = function (method) {
			_transparentSort = method;
		}; // Clearing


		this.getClearColor = function (target) {
			return target.copy(background.getClearColor());
		};

		this.setClearColor = function () {
			background.setClearColor.apply(background, arguments);
		};

		this.getClearAlpha = function () {
			return background.getClearAlpha();
		};

		this.setClearAlpha = function () {
			background.setClearAlpha.apply(background, arguments);
		};

		this.clear = function (color, depth, stencil) {
			let bits = 0;
			if (color === undefined || color) bits |= _gl.COLOR_BUFFER_BIT;
			if (depth === undefined || depth) bits |= _gl.DEPTH_BUFFER_BIT;
			if (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;

			_gl.clear(bits);
		};

		this.clearColor = function () {
			this.clear(true, false, false);
		};

		this.clearDepth = function () {
			this.clear(false, true, false);
		};

		this.clearStencil = function () {
			this.clear(false, false, true);
		}; //


		this.dispose = function () {
			_canvas.removeEventListener('webglcontextlost', onContextLost, false);

			_canvas.removeEventListener('webglcontextrestored', onContextRestore, false);

			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			cubemaps.dispose();
			cubeuvmaps.dispose();
			objects.dispose();
			bindingStates.dispose();
			xr.dispose();
			xr.removeEventListener('sessionstart', onXRSessionStart);
			xr.removeEventListener('sessionend', onXRSessionEnd);

			if (_transmissionRenderTarget) {
				_transmissionRenderTarget.dispose();

				_transmissionRenderTarget = null;
			}

			animation.stop();
		}; // Events


		function onContextLost(event) {
			event.preventDefault();
			console.log('THREE.WebGLRenderer: Context Lost.');
			_isContextLost = true;
		}

		function onContextRestore() {
			console.log('THREE.WebGLRenderer: Context Restored.');
			_isContextLost = false;
			const infoAutoReset = info.autoReset;
			const shadowMapEnabled = shadowMap.enabled;
			const shadowMapAutoUpdate = shadowMap.autoUpdate;
			const shadowMapNeedsUpdate = shadowMap.needsUpdate;
			const shadowMapType = shadowMap.type;
			initGLContext();
			info.autoReset = infoAutoReset;
			shadowMap.enabled = shadowMapEnabled;
			shadowMap.autoUpdate = shadowMapAutoUpdate;
			shadowMap.needsUpdate = shadowMapNeedsUpdate;
			shadowMap.type = shadowMapType;
		}

		function onMaterialDispose(event) {
			const material = event.target;
			material.removeEventListener('dispose', onMaterialDispose);
			deallocateMaterial(material);
		} // Buffer deallocation


		function deallocateMaterial(material) {
			releaseMaterialProgramReferences(material);
			properties.remove(material);
		}

		function releaseMaterialProgramReferences(material) {
			const programs = properties.get(material).programs;

			if (programs !== undefined) {
				programs.forEach(function (program) {
					programCache.releaseProgram(program);
				});
			}
		} // Buffer rendering


		this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {
			if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

			const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
			const program = setProgram(camera, scene, geometry, material, object);
			state.setMaterial(material, frontFaceCW); //

			let index = geometry.index;
			const position = geometry.attributes.position; //

			if (index === null) {
				if (position === undefined || position.count === 0) return;
			} else if (index.count === 0) {
				return;
			} //


			let rangeFactor = 1;

			if (material.wireframe === true) {
				index = geometries.getWireframeAttribute(geometry);
				rangeFactor = 2;
			}

			bindingStates.setup(object, material, program, geometry, index);
			let attribute;
			let renderer = bufferRenderer;

			if (index !== null) {
				attribute = attributes.get(index);
				renderer = indexedBufferRenderer;
				renderer.setIndex(attribute);
			} //


			const dataCount = index !== null ? index.count : position.count;
			const rangeStart = geometry.drawRange.start * rangeFactor;
			const rangeCount = geometry.drawRange.count * rangeFactor;
			const groupStart = group !== null ? group.start * rangeFactor : 0;
			const groupCount = group !== null ? group.count * rangeFactor : Infinity;
			const drawStart = Math.max(rangeStart, groupStart);
			const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
			const drawCount = Math.max(0, drawEnd - drawStart + 1);
			if (drawCount === 0) return; //

			if (object.isMesh) {
				if (material.wireframe === true) {
					state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
					renderer.setMode(_gl.LINES);
				} else {
					renderer.setMode(_gl.TRIANGLES);
				}
			} else if (object.isLine) {
				let lineWidth = material.linewidth;
				if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

				state.setLineWidth(lineWidth * getTargetPixelRatio());

				if (object.isLineSegments) {
					renderer.setMode(_gl.LINES);
				} else if (object.isLineLoop) {
					renderer.setMode(_gl.LINE_LOOP);
				} else {
					renderer.setMode(_gl.LINE_STRIP);
				}
			} else if (object.isPoints) {
				renderer.setMode(_gl.POINTS);
			} else if (object.isSprite) {
				renderer.setMode(_gl.TRIANGLES);
			}

			if (object.isInstancedMesh) {
				renderer.renderInstances(drawStart, drawCount, object.count);
			} else if (geometry.isInstancedBufferGeometry) {
				const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
				renderer.renderInstances(drawStart, drawCount, instanceCount);
			} else {
				renderer.render(drawStart, drawCount);
			}
		}; // Compile


		this.compile = function (scene, camera) {
			currentRenderState = renderStates.get(scene);
			currentRenderState.init();
			renderStateStack.push(currentRenderState);
			scene.traverseVisible(function (object) {
				if (object.isLight && object.layers.test(camera.layers)) {
					currentRenderState.pushLight(object);

					if (object.castShadow) {
						currentRenderState.pushShadow(object);
					}
				}
			});
			currentRenderState.setupLights(_this.physicallyCorrectLights);
			scene.traverse(function (object) {
				const material = object.material;

				if (material) {
					if (Array.isArray(material)) {
						for (let i = 0; i < material.length; i++) {
							const material2 = material[i];
							getProgram(material2, scene, object);
						}
					} else {
						getProgram(material, scene, object);
					}
				}
			});
			renderStateStack.pop();
			currentRenderState = null;
		}; // Animation Loop


		let onAnimationFrameCallback = null;

		function onAnimationFrame(time) {
			if (onAnimationFrameCallback) onAnimationFrameCallback(time);
		}

		function onXRSessionStart() {
			animation.stop();
		}

		function onXRSessionEnd() {
			animation.start();
		}

		const animation = new WebGLAnimation();
		animation.setAnimationLoop(onAnimationFrame);
		if (typeof window !== 'undefined') animation.setContext(window);

		this.setAnimationLoop = function (callback) {
			onAnimationFrameCallback = callback;
			xr.setAnimationLoop(callback);
			callback === null ? animation.stop() : animation.start();
		};

		xr.addEventListener('sessionstart', onXRSessionStart);
		xr.addEventListener('sessionend', onXRSessionEnd); // Rendering

		this.render = function (scene, camera) {
			if (camera !== undefined && camera.isCamera !== true) {
				console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
				return;
			}

			if (_isContextLost === true) return; // update scene graph

			if (scene.autoUpdate === true) scene.updateMatrixWorld(); // update camera matrices and frustum

			if (camera.parent === null) camera.updateMatrixWorld();

			if (xr.enabled === true && xr.isPresenting === true) {
				if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
				camera = xr.getCamera(); // use XR camera for rendering
			} //


			if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
			currentRenderState = renderStates.get(scene, renderStateStack.length);
			currentRenderState.init();
			renderStateStack.push(currentRenderState);

			_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

			_frustum.setFromProjectionMatrix(_projScreenMatrix);

			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
			currentRenderList = renderLists.get(scene, renderListStack.length);
			currentRenderList.init();
			renderListStack.push(currentRenderList);
			projectObject(scene, camera, 0, _this.sortObjects);
			currentRenderList.finish();

			if (_this.sortObjects === true) {
				currentRenderList.sort(_opaqueSort, _transparentSort);
			} //


			if (_clippingEnabled === true) clipping.beginShadows();
			const shadowsArray = currentRenderState.state.shadowsArray;
			shadowMap.render(shadowsArray, scene, camera);
			if (_clippingEnabled === true) clipping.endShadows(); //

			if (this.info.autoReset === true) this.info.reset(); //

			background.render(currentRenderList, scene); // render scene

			currentRenderState.setupLights(_this.physicallyCorrectLights);

			if (camera.isArrayCamera) {
				const cameras = camera.cameras;

				for (let i = 0, l = cameras.length; i < l; i++) {
					const camera2 = cameras[i];
					renderScene(currentRenderList, scene, camera2, camera2.viewport);
				}
			} else {
				renderScene(currentRenderList, scene, camera);
			} //


			if (_currentRenderTarget !== null) {
				// resolve multisample renderbuffers to a single-sample texture if necessary
				textures.updateMultisampleRenderTarget(_currentRenderTarget); // Generate mipmap if we're using any kind of mipmap filtering

				textures.updateRenderTargetMipmap(_currentRenderTarget);
			} //


			if (scene.isScene === true) scene.onAfterRender(_this, scene, camera); // Ensure depth buffer writing is enabled so it can be cleared on next render

			state.buffers.depth.setTest(true);
			state.buffers.depth.setMask(true);
			state.buffers.color.setMask(true);
			state.setPolygonOffset(false); // _gl.finish();

			bindingStates.resetDefaultState();
			_currentMaterialId = -1;
			_currentCamera = null;
			renderStateStack.pop();

			if (renderStateStack.length > 0) {
				currentRenderState = renderStateStack[renderStateStack.length - 1];
			} else {
				currentRenderState = null;
			}

			renderListStack.pop();

			if (renderListStack.length > 0) {
				currentRenderList = renderListStack[renderListStack.length - 1];
			} else {
				currentRenderList = null;
			}
		};

		function projectObject(object, camera, groupOrder, sortObjects) {
			if (object.visible === false) return;
			const visible = object.layers.test(camera.layers);

			if (visible) {
				if (object.isGroup) {
					groupOrder = object.renderOrder;
				} else if (object.isLOD) {
					if (object.autoUpdate === true) object.update(camera);
				} else if (object.isLight) {
					currentRenderState.pushLight(object);

					if (object.castShadow) {
						currentRenderState.pushShadow(object);
					}
				} else if (object.isSprite) {
					if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
						if (sortObjects) {
							_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
						}

						const geometry = objects.update(object);
						const material = object.material;

						if (material.visible) {
							currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
						}
					}
				} else if (object.isMesh || object.isLine || object.isPoints) {
					if (object.isSkinnedMesh) {
						// update skeleton only once in a frame
						if (object.skeleton.frame !== info.render.frame) {
							object.skeleton.update();
							object.skeleton.frame = info.render.frame;
						}
					}

					if (!object.frustumCulled || _frustum.intersectsObject(object)) {
						if (sortObjects) {
							_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
						}

						const geometry = objects.update(object);
						const material = object.material;

						if (Array.isArray(material)) {
							const groups = geometry.groups;

							for (let i = 0, l = groups.length; i < l; i++) {
								const group = groups[i];
								const groupMaterial = material[group.materialIndex];

								if (groupMaterial && groupMaterial.visible) {
									currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
								}
							}
						} else if (material.visible) {
							currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
						}
					}
				}
			}

			const children = object.children;

			for (let i = 0, l = children.length; i < l; i++) {
				projectObject(children[i], camera, groupOrder, sortObjects);
			}
		}

		function renderScene(currentRenderList, scene, camera, viewport) {
			const opaqueObjects = currentRenderList.opaque;
			const transmissiveObjects = currentRenderList.transmissive;
			const transparentObjects = currentRenderList.transparent;
			currentRenderState.setupLightsView(camera);
			if (transmissiveObjects.length > 0) renderTransmissionPass(opaqueObjects, scene, camera);
			if (viewport) state.viewport(_currentViewport.copy(viewport));
			if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
			if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, scene, camera);
			if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);
		}

		function renderTransmissionPass(opaqueObjects, scene, camera) {
			if (_transmissionRenderTarget === null) {
				const needsAntialias = _antialias === true && capabilities.isWebGL2 === true;
				const renderTargetType = needsAntialias ? WebGLMultisampleRenderTarget : WebGLRenderTarget;
				_transmissionRenderTarget = new renderTargetType(1024, 1024, {
					generateMipmaps: true,
					type: utils.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
					minFilter: LinearMipmapLinearFilter,
					magFilter: NearestFilter,
					wrapS: ClampToEdgeWrapping,
					wrapT: ClampToEdgeWrapping,
					useRenderToTexture: extensions.has('WEBGL_multisampled_render_to_texture')
				});
			}

			const currentRenderTarget = _this.getRenderTarget();

			_this.setRenderTarget(_transmissionRenderTarget);

			_this.clear(); // Turn off the features which can affect the frag color for opaque objects pass.
			// Otherwise they are applied twice in opaque objects pass and transmission objects pass.


			const currentToneMapping = _this.toneMapping;
			_this.toneMapping = NoToneMapping;
			renderObjects(opaqueObjects, scene, camera);
			_this.toneMapping = currentToneMapping;
			textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
			textures.updateRenderTargetMipmap(_transmissionRenderTarget);

			_this.setRenderTarget(currentRenderTarget);
		}

		function renderObjects(renderList, scene, camera) {
			const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

			for (let i = 0, l = renderList.length; i < l; i++) {
				const renderItem = renderList[i];
				const object = renderItem.object;
				const geometry = renderItem.geometry;
				const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
				const group = renderItem.group;

				if (object.layers.test(camera.layers)) {
					renderObject(object, scene, camera, geometry, material, group);
				}
			}
		}

		function renderObject(object, scene, camera, geometry, material, group) {
			object.onBeforeRender(_this, scene, camera, geometry, material, group);
			object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
			object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
			material.onBeforeRender(_this, scene, camera, geometry, object, group);

			if (material.transparent === true && material.side === DoubleSide) {
				material.side = BackSide;
				material.needsUpdate = true;

				_this.renderBufferDirect(camera, scene, geometry, material, object, group);

				material.side = FrontSide;
				material.needsUpdate = true;

				_this.renderBufferDirect(camera, scene, geometry, material, object, group);

				material.side = DoubleSide;
			} else {
				_this.renderBufferDirect(camera, scene, geometry, material, object, group);
			}

			object.onAfterRender(_this, scene, camera, geometry, material, group);
		}

		function getProgram(material, scene, object) {
			if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			const materialProperties = properties.get(material);
			const lights = currentRenderState.state.lights;
			const shadowsArray = currentRenderState.state.shadowsArray;
			const lightsStateVersion = lights.state.version;
			const parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
			const programCacheKey = programCache.getProgramCacheKey(parameters);
			let programs = materialProperties.programs; // always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

			materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
			materialProperties.fog = scene.fog;
			materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);

			if (programs === undefined) {
				// new material
				material.addEventListener('dispose', onMaterialDispose);
				programs = new Map();
				materialProperties.programs = programs;
			}

			let program = programs.get(programCacheKey);

			if (program !== undefined) {
				// early out if program and light state is identical
				if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
					updateCommonMaterialProperties(material, parameters);
					return program;
				}
			} else {
				parameters.uniforms = programCache.getUniforms(material);
				material.onBuild(object, parameters, _this);
				material.onBeforeCompile(parameters, _this);
				program = programCache.acquireProgram(parameters, programCacheKey);
				programs.set(programCacheKey, program);
				materialProperties.uniforms = parameters.uniforms;
			}

			const uniforms = materialProperties.uniforms;

			if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
				uniforms.clippingPlanes = clipping.uniform;
			}

			updateCommonMaterialProperties(material, parameters); // store the light setup it was created for

			materialProperties.needsLights = materialNeedsLights(material);
			materialProperties.lightsStateVersion = lightsStateVersion;

			if (materialProperties.needsLights) {
				// wire up the material to this renderer's lighting state
				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.lightProbe.value = lights.state.probe;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.directionalLightShadows.value = lights.state.directionalShadow;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.spotLightShadows.value = lights.state.spotShadow;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.ltc_1.value = lights.state.rectAreaLTC1;
				uniforms.ltc_2.value = lights.state.rectAreaLTC2;
				uniforms.pointLights.value = lights.state.point;
				uniforms.pointLightShadows.value = lights.state.pointShadow;
				uniforms.hemisphereLights.value = lights.state.hemi;
				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms
			}

			const progUniforms = program.getUniforms();
			const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
			materialProperties.currentProgram = program;
			materialProperties.uniformsList = uniformsList;
			return program;
		}

		function updateCommonMaterialProperties(material, parameters) {
			const materialProperties = properties.get(material);
			materialProperties.outputEncoding = parameters.outputEncoding;
			materialProperties.instancing = parameters.instancing;
			materialProperties.skinning = parameters.skinning;
			materialProperties.morphTargets = parameters.morphTargets;
			materialProperties.morphNormals = parameters.morphNormals;
			materialProperties.morphTargetsCount = parameters.morphTargetsCount;
			materialProperties.numClippingPlanes = parameters.numClippingPlanes;
			materialProperties.numIntersection = parameters.numClipIntersection;
			materialProperties.vertexAlphas = parameters.vertexAlphas;
			materialProperties.vertexTangents = parameters.vertexTangents;
		}

		function setProgram(camera, scene, geometry, material, object) {
			if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			textures.resetTextureUnits();
			const fog = scene.fog;
			const environment = material.isMeshStandardMaterial ? scene.environment : null;
			const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
			const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
			const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
			const vertexTangents = !!material.normalMap && !!geometry.attributes.tangent;
			const morphTargets = !!geometry.morphAttributes.position;
			const morphNormals = !!geometry.morphAttributes.normal;
			const morphTargetsCount = !!geometry.morphAttributes.position ? geometry.morphAttributes.position.length : 0;
			const materialProperties = properties.get(material);
			const lights = currentRenderState.state.lights;

			if (_clippingEnabled === true) {
				if (_localClippingEnabled === true || camera !== _currentCamera) {
					const useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)

					clipping.setState(material, camera, useCache);
				}
			} //


			let needsProgramChange = false;

			if (material.version === materialProperties.__version) {
				if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
					needsProgramChange = true;
				} else if (materialProperties.outputEncoding !== encoding) {
					needsProgramChange = true;
				} else if (object.isInstancedMesh && materialProperties.instancing === false) {
					needsProgramChange = true;
				} else if (!object.isInstancedMesh && materialProperties.instancing === true) {
					needsProgramChange = true;
				} else if (object.isSkinnedMesh && materialProperties.skinning === false) {
					needsProgramChange = true;
				} else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
					needsProgramChange = true;
				} else if (materialProperties.envMap !== envMap) {
					needsProgramChange = true;
				} else if (material.fog && materialProperties.fog !== fog) {
					needsProgramChange = true;
				} else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
					needsProgramChange = true;
				} else if (materialProperties.vertexAlphas !== vertexAlphas) {
					needsProgramChange = true;
				} else if (materialProperties.vertexTangents !== vertexTangents) {
					needsProgramChange = true;
				} else if (materialProperties.morphTargets !== morphTargets) {
					needsProgramChange = true;
				} else if (materialProperties.morphNormals !== morphNormals) {
					needsProgramChange = true;
				} else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
					needsProgramChange = true;
				}
			} else {
				needsProgramChange = true;
				materialProperties.__version = material.version;
			} //


			let program = materialProperties.currentProgram;

			if (needsProgramChange === true) {
				program = getProgram(material, scene, object);
			}

			let refreshProgram = false;
			let refreshMaterial = false;
			let refreshLights = false;
			const p_uniforms = program.getUniforms(),
						m_uniforms = materialProperties.uniforms;

			if (state.useProgram(program.program)) {
				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;
			}

			if (material.id !== _currentMaterialId) {
				_currentMaterialId = material.id;
				refreshMaterial = true;
			}

			if (refreshProgram || _currentCamera !== camera) {
				p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);

				if (capabilities.logarithmicDepthBuffer) {
					p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
				}

				if (_currentCamera !== camera) {
					_currentCamera = camera; // lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true; // set to true on material change

					refreshLights = true; // remains set until update done
				} // load material specific uniforms
				// (shader material also gets them for the sake of genericity)


				if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
					const uCamPos = p_uniforms.map.cameraPosition;

					if (uCamPos !== undefined) {
						uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
					}
				}

				if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
					p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
				}

				if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {
					p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
				}
			} // skinning and morph target uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone and morph texture must go before other textures
			// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures


			if (object.isSkinnedMesh) {
				p_uniforms.setOptional(_gl, object, 'bindMatrix');
				p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
				const skeleton = object.skeleton;

				if (skeleton) {
					if (capabilities.floatVertexTextures) {
						if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
						p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
						p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
					} else {
						p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
					}
				}
			}

			if (!!geometry && (geometry.morphAttributes.position !== undefined || geometry.morphAttributes.normal !== undefined)) {
				morphtargets.update(object, geometry, material, program);
			}

			if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
				materialProperties.receiveShadow = object.receiveShadow;
				p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
			}

			if (refreshMaterial) {
				p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);

				if (materialProperties.needsLights) {
					// the current material requires lighting info
					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required
					markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
				} // refresh uniforms common to several materials


				if (fog && material.fog) {
					materials.refreshFogUniforms(m_uniforms, fog);
				}

				materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
				WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
			}

			if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
				WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
				material.uniformsNeedUpdate = false;
			}

			if (material.isSpriteMaterial) {
				p_uniforms.setValue(_gl, 'center', object.center);
			} // common matrices


			p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
			p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
			p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
			return program;
		} // If uniforms are marked as clean, they don't need to be loaded to the GPU.


		function markUniformsLightsNeedsUpdate(uniforms, value) {
			uniforms.ambientLightColor.needsUpdate = value;
			uniforms.lightProbe.needsUpdate = value;
			uniforms.directionalLights.needsUpdate = value;
			uniforms.directionalLightShadows.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.pointLightShadows.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.spotLightShadows.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;
		}

		function materialNeedsLights(material) {
			return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
		}

		this.getActiveCubeFace = function () {
			return _currentActiveCubeFace;
		};

		this.getActiveMipmapLevel = function () {
			return _currentActiveMipmapLevel;
		};

		this.getRenderTarget = function () {
			return _currentRenderTarget;
		};

		this.setRenderTargetTextures = function (renderTarget, colorTexture, depthTexture) {
			properties.get(renderTarget.texture).__webglTexture = colorTexture;
			properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
			const renderTargetProperties = properties.get(renderTarget);
			renderTargetProperties.__hasExternalTextures = true;

			if (renderTargetProperties.__hasExternalTextures) {
				renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;

				if (!renderTargetProperties.__autoAllocateDepthBuffer) {
					// The multisample_render_to_texture extension doesn't work properly if there
					// are midframe flushes and an external depth buffer. Disable use of the extension.
					if (renderTarget.useRenderToTexture) {
						console.warn('render-to-texture extension was disabled because an external texture was provided');
						renderTarget.useRenderToTexture = false;
						renderTarget.useRenderbuffer = true;
					}
				}
			}
		};

		this.setRenderTargetFramebuffer = function (renderTarget, defaultFramebuffer) {
			const renderTargetProperties = properties.get(renderTarget);
			renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
			renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;
		};

		this.setRenderTarget = function (renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
			_currentRenderTarget = renderTarget;
			_currentActiveCubeFace = activeCubeFace;
			_currentActiveMipmapLevel = activeMipmapLevel;
			let useDefaultFramebuffer = true;

			if (renderTarget) {
				const renderTargetProperties = properties.get(renderTarget);

				if (renderTargetProperties.__useDefaultFramebuffer !== undefined) {
					// We need to make sure to rebind the framebuffer.
					state.bindFramebuffer(_gl.FRAMEBUFFER, null);
					useDefaultFramebuffer = false;
				} else if (renderTargetProperties.__webglFramebuffer === undefined) {
					textures.setupRenderTarget(renderTarget);
				} else if (renderTargetProperties.__hasExternalTextures) {
					// Color and depth texture must be rebound in order for the swapchain to update.
					textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
				}
			}

			let framebuffer = null;
			let isCube = false;
			let isRenderTarget3D = false;

			if (renderTarget) {
				const texture = renderTarget.texture;

				if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
					isRenderTarget3D = true;
				}

				const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;

				if (renderTarget.isWebGLCubeRenderTarget) {
					framebuffer = __webglFramebuffer[activeCubeFace];
					isCube = true;
				} else if (renderTarget.useRenderbuffer) {
					framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
				} else {
					framebuffer = __webglFramebuffer;
				}

				_currentViewport.copy(renderTarget.viewport);

				_currentScissor.copy(renderTarget.scissor);

				_currentScissorTest = renderTarget.scissorTest;
			} else {
				_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();

				_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();

				_currentScissorTest = _scissorTest;
			}

			const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

			if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {
				let needsUpdate = false;

				if (renderTarget) {
					if (renderTarget.isWebGLMultipleRenderTargets) {
						const textures = renderTarget.texture;

						if (_currentDrawBuffers.length !== textures.length || _currentDrawBuffers[0] !== _gl.COLOR_ATTACHMENT0) {
							for (let i = 0, il = textures.length; i < il; i++) {
								_currentDrawBuffers[i] = _gl.COLOR_ATTACHMENT0 + i;
							}

							_currentDrawBuffers.length = textures.length;
							needsUpdate = true;
						}
					} else {
						if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== _gl.COLOR_ATTACHMENT0) {
							_currentDrawBuffers[0] = _gl.COLOR_ATTACHMENT0;
							_currentDrawBuffers.length = 1;
							needsUpdate = true;
						}
					}
				} else {
					if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== _gl.BACK) {
						_currentDrawBuffers[0] = _gl.BACK;
						_currentDrawBuffers.length = 1;
						needsUpdate = true;
					}
				}

				if (needsUpdate) {
					if (capabilities.isWebGL2) {
						_gl.drawBuffers(_currentDrawBuffers);
					} else {
						extensions.get('WEBGL_draw_buffers').drawBuffersWEBGL(_currentDrawBuffers);
					}
				}
			}

			state.viewport(_currentViewport);
			state.scissor(_currentScissor);
			state.setScissorTest(_currentScissorTest);

			if (isCube) {
				const textureProperties = properties.get(renderTarget.texture);

				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
			} else if (isRenderTarget3D) {
				const textureProperties = properties.get(renderTarget.texture);
				const layer = activeCubeFace || 0;

				_gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
			}

			_currentMaterialId = -1; // reset current material to ensure correct uniform bindings
		};

		this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
			if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
				console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
				return;
			}

			let framebuffer = properties.get(renderTarget).__webglFramebuffer;

			if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
				framebuffer = framebuffer[activeCubeFaceIndex];
			}

			if (framebuffer) {
				state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

				try {
					const texture = renderTarget.texture;
					const textureFormat = texture.format;
					const textureType = texture.type;

					if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
						return;
					}

					const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has('EXT_color_buffer_half_float') || capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float'));

					if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
					!(textureType === FloatType && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
					!halfFloatSupportedByExt) {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
						return;
					}

					if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
						if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
							_gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
						}
					} else {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
					}
				} finally {
					// restore framebuffer of current render target if necessary
					const framebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
					state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
				}
			}
		};

		this.copyFramebufferToTexture = function (position, texture, level = 0) {
			const levelScale = Math.pow(2, -level);
			const width = Math.floor(texture.image.width * levelScale);
			const height = Math.floor(texture.image.height * levelScale);
			let glFormat = utils.convert(texture.format);

			if (capabilities.isWebGL2) {
				// Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1120100
				// Not needed in Chrome 93+
				if (glFormat === _gl.RGB) glFormat = _gl.RGB8;
				if (glFormat === _gl.RGBA) glFormat = _gl.RGBA8;
			}

			textures.setTexture2D(texture, 0);

			_gl.copyTexImage2D(_gl.TEXTURE_2D, level, glFormat, position.x, position.y, width, height, 0);

			state.unbindTexture();
		};

		this.copyTextureToTexture = function (position, srcTexture, dstTexture, level = 0) {
			const width = srcTexture.image.width;
			const height = srcTexture.image.height;
			const glFormat = utils.convert(dstTexture.format);
			const glType = utils.convert(dstTexture.type);
			textures.setTexture2D(dstTexture, 0); // As another texture upload may have changed pixelStorei
			// parameters, make sure they are correct for the dstTexture

			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);

			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);

			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);

			if (srcTexture.isDataTexture) {
				_gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
			} else {
				if (srcTexture.isCompressedTexture) {
					_gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
				} else {
					_gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);
				}
			} // Generate mipmaps only when copying level 0


			if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(_gl.TEXTURE_2D);
			state.unbindTexture();
		};

		this.copyTextureToTexture3D = function (sourceBox, position, srcTexture, dstTexture, level = 0) {
			if (_this.isWebGL1Renderer) {
				console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.');
				return;
			}

			const width = sourceBox.max.x - sourceBox.min.x + 1;
			const height = sourceBox.max.y - sourceBox.min.y + 1;
			const depth = sourceBox.max.z - sourceBox.min.z + 1;
			const glFormat = utils.convert(dstTexture.format);
			const glType = utils.convert(dstTexture.type);
			let glTarget;

			if (dstTexture.isDataTexture3D) {
				textures.setTexture3D(dstTexture, 0);
				glTarget = _gl.TEXTURE_3D;
			} else if (dstTexture.isDataTexture2DArray) {
				textures.setTexture2DArray(dstTexture, 0);
				glTarget = _gl.TEXTURE_2D_ARRAY;
			} else {
				console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');
				return;
			}

			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);

			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);

			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);

			const unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);

			const unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);

			const unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);

			const unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);

			const unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);

			const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;

			_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);

			_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);

			_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);

			_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);

			_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);

			if (srcTexture.isDataTexture || srcTexture.isDataTexture3D) {
				_gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);
			} else {
				if (srcTexture.isCompressedTexture) {
					console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.');

					_gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);
				} else {
					_gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);
				}
			}

			_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);

			_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);

			_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);

			_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);

			_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages); // Generate mipmaps only when copying level 0


			if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);
			state.unbindTexture();
		};

		this.initTexture = function (texture) {
			textures.setTexture2D(texture, 0);
			state.unbindTexture();
		};

		this.resetState = function () {
			_currentActiveCubeFace = 0;
			_currentActiveMipmapLevel = 0;
			_currentRenderTarget = null;
			state.reset();
			bindingStates.reset();
		};

		if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
			__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
				detail: this
			})); // eslint-disable-line no-undef

		}
	}

	WebGLRenderer.prototype.isWebGLRenderer = true;

	class WebGL1Renderer extends WebGLRenderer {}

	WebGL1Renderer.prototype.isWebGL1Renderer = true;

	class FogExp2 {
		constructor(color, density = 0.00025) {
			this.name = '';
			this.color = new Color(color);
			this.density = density;
		}

		clone() {
			return new FogExp2(this.color, this.density);
		}

		toJSON() {
			return {
				type: 'FogExp2',
				color: this.color.getHex(),
				density: this.density
			};
		}

	}

	FogExp2.prototype.isFogExp2 = true;

	class Fog {
		constructor(color, near = 1, far = 1000) {
			this.name = '';
			this.color = new Color(color);
			this.near = near;
			this.far = far;
		}

		clone() {
			return new Fog(this.color, this.near, this.far);
		}

		toJSON() {
			return {
				type: 'Fog',
				color: this.color.getHex(),
				near: this.near,
				far: this.far
			};
		}

	}

	Fog.prototype.isFog = true;

	class Scene extends Object3D {
		constructor() {
			super();
			this.type = 'Scene';
			this.background = null;
			this.environment = null;
			this.fog = null;
			this.overrideMaterial = null;
			this.autoUpdate = true; // checked by the renderer

			if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
				__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
					detail: this
				})); // eslint-disable-line no-undef

			}
		}

		copy(source, recursive) {
			super.copy(source, recursive);
			if (source.background !== null) this.background = source.background.clone();
			if (source.environment !== null) this.environment = source.environment.clone();
			if (source.fog !== null) this.fog = source.fog.clone();
			if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			return this;
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			if (this.fog !== null) data.object.fog = this.fog.toJSON();
			return data;
		}

	}

	Scene.prototype.isScene = true;

	class InterleavedBuffer {
		constructor(array, stride) {
			this.array = array;
			this.stride = stride;
			this.count = array !== undefined ? array.length / stride : 0;
			this.usage = StaticDrawUsage;
			this.updateRange = {
				offset: 0,
				count: -1
			};
			this.version = 0;
			this.uuid = generateUUID();
		}

		onUploadCallback() {}

		set needsUpdate(value) {
			if (value === true) this.version++;
		}

		setUsage(value) {
			this.usage = value;
			return this;
		}

		copy(source) {
			this.array = new source.array.constructor(source.array);
			this.count = source.count;
			this.stride = source.stride;
			this.usage = source.usage;
			return this;
		}

		copyAt(index1, attribute, index2) {
			index1 *= this.stride;
			index2 *= attribute.stride;

			for (let i = 0, l = this.stride; i < l; i++) {
				this.array[index1 + i] = attribute.array[index2 + i];
			}

			return this;
		}

		set(value, offset = 0) {
			this.array.set(value, offset);
			return this;
		}

		clone(data) {
			if (data.arrayBuffers === undefined) {
				data.arrayBuffers = {};
			}

			if (this.array.buffer._uuid === undefined) {
				this.array.buffer._uuid = generateUUID();
			}

			if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
				data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
			}

			const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
			const ib = new this.constructor(array, this.stride);
			ib.setUsage(this.usage);
			return ib;
		}

		onUpload(callback) {
			this.onUploadCallback = callback;
			return this;
		}

		toJSON(data) {
			if (data.arrayBuffers === undefined) {
				data.arrayBuffers = {};
			} // generate UUID for array buffer if necessary


			if (this.array.buffer._uuid === undefined) {
				this.array.buffer._uuid = generateUUID();
			}

			if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
				data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
			} //


			return {
				uuid: this.uuid,
				buffer: this.array.buffer._uuid,
				type: this.array.constructor.name,
				stride: this.stride
			};
		}

	}

	InterleavedBuffer.prototype.isInterleavedBuffer = true;

	const _vector$6 = /*@__PURE__*/new Vector3();

	class InterleavedBufferAttribute {
		constructor(interleavedBuffer, itemSize, offset, normalized = false) {
			this.name = '';
			this.data = interleavedBuffer;
			this.itemSize = itemSize;
			this.offset = offset;
			this.normalized = normalized === true;
		}

		get count() {
			return this.data.count;
		}

		get array() {
			return this.data.array;
		}

		set needsUpdate(value) {
			this.data.needsUpdate = value;
		}

		applyMatrix4(m) {
			for (let i = 0, l = this.data.count; i < l; i++) {
				_vector$6.x = this.getX(i);
				_vector$6.y = this.getY(i);
				_vector$6.z = this.getZ(i);

				_vector$6.applyMatrix4(m);

				this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
			}

			return this;
		}

		applyNormalMatrix(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$6.x = this.getX(i);
				_vector$6.y = this.getY(i);
				_vector$6.z = this.getZ(i);

				_vector$6.applyNormalMatrix(m);

				this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
			}

			return this;
		}

		transformDirection(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$6.x = this.getX(i);
				_vector$6.y = this.getY(i);
				_vector$6.z = this.getZ(i);

				_vector$6.transformDirection(m);

				this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
			}

			return this;
		}

		setX(index, x) {
			this.data.array[index * this.data.stride + this.offset] = x;
			return this;
		}

		setY(index, y) {
			this.data.array[index * this.data.stride + this.offset + 1] = y;
			return this;
		}

		setZ(index, z) {
			this.data.array[index * this.data.stride + this.offset + 2] = z;
			return this;
		}

		setW(index, w) {
			this.data.array[index * this.data.stride + this.offset + 3] = w;
			return this;
		}

		getX(index) {
			return this.data.array[index * this.data.stride + this.offset];
		}

		getY(index) {
			return this.data.array[index * this.data.stride + this.offset + 1];
		}

		getZ(index) {
			return this.data.array[index * this.data.stride + this.offset + 2];
		}

		getW(index) {
			return this.data.array[index * this.data.stride + this.offset + 3];
		}

		setXY(index, x, y) {
			index = index * this.data.stride + this.offset;
			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			return this;
		}

		setXYZ(index, x, y, z) {
			index = index * this.data.stride + this.offset;
			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			this.data.array[index + 2] = z;
			return this;
		}

		setXYZW(index, x, y, z, w) {
			index = index * this.data.stride + this.offset;
			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			this.data.array[index + 2] = z;
			this.data.array[index + 3] = w;
			return this;
		}

		clone(data) {
			if (data === undefined) {
				console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');
				const array = [];

				for (let i = 0; i < this.count; i++) {
					const index = i * this.data.stride + this.offset;

					for (let j = 0; j < this.itemSize; j++) {
						array.push(this.data.array[index + j]);
					}
				}

				return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
			} else {
				if (data.interleavedBuffers === undefined) {
					data.interleavedBuffers = {};
				}

				if (data.interleavedBuffers[this.data.uuid] === undefined) {
					data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
				}

				return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
			}
		}

		toJSON(data) {
			if (data === undefined) {
				console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');
				const array = [];

				for (let i = 0; i < this.count; i++) {
					const index = i * this.data.stride + this.offset;

					for (let j = 0; j < this.itemSize; j++) {
						array.push(this.data.array[index + j]);
					}
				} // deinterleave data and save it as an ordinary buffer attribute for now


				return {
					itemSize: this.itemSize,
					type: this.array.constructor.name,
					array: array,
					normalized: this.normalized
				};
			} else {
				// save as true interlaved attribtue
				if (data.interleavedBuffers === undefined) {
					data.interleavedBuffers = {};
				}

				if (data.interleavedBuffers[this.data.uuid] === undefined) {
					data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
				}

				return {
					isInterleavedBufferAttribute: true,
					itemSize: this.itemSize,
					data: this.data.uuid,
					offset: this.offset,
					normalized: this.normalized
				};
			}
		}

	}

	InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	map: new THREE.Texture( <Image> ),
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *	rotation: <float>,
	 *	sizeAttenuation: <bool>
	 * }
	 */

	class SpriteMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'SpriteMaterial';
			this.color = new Color(0xffffff);
			this.map = null;
			this.alphaMap = null;
			this.rotation = 0;
			this.sizeAttenuation = true;
			this.transparent = true;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.alphaMap = source.alphaMap;
			this.rotation = source.rotation;
			this.sizeAttenuation = source.sizeAttenuation;
			return this;
		}

	}

	SpriteMaterial.prototype.isSpriteMaterial = true;

	let _geometry;

	const _intersectPoint = /*@__PURE__*/new Vector3();

	const _worldScale = /*@__PURE__*/new Vector3();

	const _mvPosition = /*@__PURE__*/new Vector3();

	const _alignedPosition = /*@__PURE__*/new Vector2();

	const _rotatedPosition = /*@__PURE__*/new Vector2();

	const _viewWorldMatrix = /*@__PURE__*/new Matrix4();

	const _vA = /*@__PURE__*/new Vector3();

	const _vB = /*@__PURE__*/new Vector3();

	const _vC = /*@__PURE__*/new Vector3();

	const _uvA = /*@__PURE__*/new Vector2();

	const _uvB = /*@__PURE__*/new Vector2();

	const _uvC = /*@__PURE__*/new Vector2();

	class Sprite extends Object3D {
		constructor(material) {
			super();
			this.type = 'Sprite';

			if (_geometry === undefined) {
				_geometry = new BufferGeometry();
				const float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
				const interleavedBuffer = new InterleavedBuffer(float32Array, 5);

				_geometry.setIndex([0, 1, 2, 0, 2, 3]);

				_geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));

				_geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
			}

			this.geometry = _geometry;
			this.material = material !== undefined ? material : new SpriteMaterial();
			this.center = new Vector2(0.5, 0.5);
		}

		raycast(raycaster, intersects) {
			if (raycaster.camera === null) {
				console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
			}

			_worldScale.setFromMatrixScale(this.matrixWorld);

			_viewWorldMatrix.copy(raycaster.camera.matrixWorld);

			this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);

			_mvPosition.setFromMatrixPosition(this.modelViewMatrix);

			if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
				_worldScale.multiplyScalar(-_mvPosition.z);
			}

			const rotation = this.material.rotation;
			let sin, cos;

			if (rotation !== 0) {
				cos = Math.cos(rotation);
				sin = Math.sin(rotation);
			}

			const center = this.center;
			transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
			transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
			transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

			_uvA.set(0, 0);

			_uvB.set(1, 0);

			_uvC.set(1, 1); // check first triangle


			let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);

			if (intersect === null) {
				// check second triangle
				transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

				_uvB.set(0, 1);

				intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);

				if (intersect === null) {
					return;
				}
			}

			const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
			if (distance < raycaster.near || distance > raycaster.far) return;
			intersects.push({
				distance: distance,
				point: _intersectPoint.clone(),
				uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
				face: null,
				object: this
			});
		}

		copy(source) {
			super.copy(source);
			if (source.center !== undefined) this.center.copy(source.center);
			this.material = source.material;
			return this;
		}

	}

	Sprite.prototype.isSprite = true;

	function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
		// compute position in camera space
		_alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale); // to check if rotation is not zero


		if (sin !== undefined) {
			_rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
			_rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
		} else {
			_rotatedPosition.copy(_alignedPosition);
		}

		vertexPosition.copy(mvPosition);
		vertexPosition.x += _rotatedPosition.x;
		vertexPosition.y += _rotatedPosition.y; // transform to world space

		vertexPosition.applyMatrix4(_viewWorldMatrix);
	}

	const _v1$2 = /*@__PURE__*/new Vector3();

	const _v2$1 = /*@__PURE__*/new Vector3();

	class LOD extends Object3D {
		constructor() {
			super();
			this._currentLevel = 0;
			this.type = 'LOD';
			Object.defineProperties(this, {
				levels: {
					enumerable: true,
					value: []
				},
				isLOD: {
					value: true
				}
			});
			this.autoUpdate = true;
		}

		copy(source) {
			super.copy(source, false);
			const levels = source.levels;

			for (let i = 0, l = levels.length; i < l; i++) {
				const level = levels[i];
				this.addLevel(level.object.clone(), level.distance);
			}

			this.autoUpdate = source.autoUpdate;
			return this;
		}

		addLevel(object, distance = 0) {
			distance = Math.abs(distance);
			const levels = this.levels;
			let l;

			for (l = 0; l < levels.length; l++) {
				if (distance < levels[l].distance) {
					break;
				}
			}

			levels.splice(l, 0, {
				distance: distance,
				object: object
			});
			this.add(object);
			return this;
		}

		getCurrentLevel() {
			return this._currentLevel;
		}

		getObjectForDistance(distance) {
			const levels = this.levels;

			if (levels.length > 0) {
				let i, l;

				for (i = 1, l = levels.length; i < l; i++) {
					if (distance < levels[i].distance) {
						break;
					}
				}

				return levels[i - 1].object;
			}

			return null;
		}

		raycast(raycaster, intersects) {
			const levels = this.levels;

			if (levels.length > 0) {
				_v1$2.setFromMatrixPosition(this.matrixWorld);

				const distance = raycaster.ray.origin.distanceTo(_v1$2);
				this.getObjectForDistance(distance).raycast(raycaster, intersects);
			}
		}

		update(camera) {
			const levels = this.levels;

			if (levels.length > 1) {
				_v1$2.setFromMatrixPosition(camera.matrixWorld);

				_v2$1.setFromMatrixPosition(this.matrixWorld);

				const distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
				levels[0].object.visible = true;
				let i, l;

				for (i = 1, l = levels.length; i < l; i++) {
					if (distance >= levels[i].distance) {
						levels[i - 1].object.visible = false;
						levels[i].object.visible = true;
					} else {
						break;
					}
				}

				this._currentLevel = i - 1;

				for (; i < l; i++) {
					levels[i].object.visible = false;
				}
			}
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			if (this.autoUpdate === false) data.object.autoUpdate = false;
			data.object.levels = [];
			const levels = this.levels;

			for (let i = 0, l = levels.length; i < l; i++) {
				const level = levels[i];
				data.object.levels.push({
					object: level.object.uuid,
					distance: level.distance
				});
			}

			return data;
		}

	}

	const _basePosition = /*@__PURE__*/new Vector3();

	const _skinIndex = /*@__PURE__*/new Vector4();

	const _skinWeight = /*@__PURE__*/new Vector4();

	const _vector$5 = /*@__PURE__*/new Vector3();

	const _matrix = /*@__PURE__*/new Matrix4();

	class SkinnedMesh extends Mesh {
		constructor(geometry, material) {
			super(geometry, material);
			this.type = 'SkinnedMesh';
			this.bindMode = 'attached';
			this.bindMatrix = new Matrix4();
			this.bindMatrixInverse = new Matrix4();
		}

		copy(source) {
			super.copy(source);
			this.bindMode = source.bindMode;
			this.bindMatrix.copy(source.bindMatrix);
			this.bindMatrixInverse.copy(source.bindMatrixInverse);
			this.skeleton = source.skeleton;
			return this;
		}

		bind(skeleton, bindMatrix) {
			this.skeleton = skeleton;

			if (bindMatrix === undefined) {
				this.updateMatrixWorld(true);
				this.skeleton.calculateInverses();
				bindMatrix = this.matrixWorld;
			}

			this.bindMatrix.copy(bindMatrix);
			this.bindMatrixInverse.copy(bindMatrix).invert();
		}

		pose() {
			this.skeleton.pose();
		}

		normalizeSkinWeights() {
			const vector = new Vector4();
			const skinWeight = this.geometry.attributes.skinWeight;

			for (let i = 0, l = skinWeight.count; i < l; i++) {
				vector.x = skinWeight.getX(i);
				vector.y = skinWeight.getY(i);
				vector.z = skinWeight.getZ(i);
				vector.w = skinWeight.getW(i);
				const scale = 1.0 / vector.manhattanLength();

				if (scale !== Infinity) {
					vector.multiplyScalar(scale);
				} else {
					vector.set(1, 0, 0, 0); // do something reasonable
				}

				skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
			}
		}

		updateMatrixWorld(force) {
			super.updateMatrixWorld(force);

			if (this.bindMode === 'attached') {
				this.bindMatrixInverse.copy(this.matrixWorld).invert();
			} else if (this.bindMode === 'detached') {
				this.bindMatrixInverse.copy(this.bindMatrix).invert();
			} else {
				console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
			}
		}

		boneTransform(index, target) {
			const skeleton = this.skeleton;
			const geometry = this.geometry;

			_skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);

			_skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);

			_basePosition.copy(target).applyMatrix4(this.bindMatrix);

			target.set(0, 0, 0);

			for (let i = 0; i < 4; i++) {
				const weight = _skinWeight.getComponent(i);

				if (weight !== 0) {
					const boneIndex = _skinIndex.getComponent(i);

					_matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);

					target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
				}
			}

			return target.applyMatrix4(this.bindMatrixInverse);
		}

	}

	SkinnedMesh.prototype.isSkinnedMesh = true;

	class Bone extends Object3D {
		constructor() {
			super();
			this.type = 'Bone';
		}

	}

	Bone.prototype.isBone = true;

	class DataTexture extends Texture {
		constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {
			super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
			this.image = {
				data: data,
				width: width,
				height: height
			};
			this.magFilter = magFilter;
			this.minFilter = minFilter;
			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;
			this.needsUpdate = true;
		}

	}

	DataTexture.prototype.isDataTexture = true;

	const _offsetMatrix = /*@__PURE__*/new Matrix4();

	const _identityMatrix = /*@__PURE__*/new Matrix4();

	class Skeleton {
		constructor(bones = [], boneInverses = []) {
			this.uuid = generateUUID();
			this.bones = bones.slice(0);
			this.boneInverses = boneInverses;
			this.boneMatrices = null;
			this.boneTexture = null;
			this.boneTextureSize = 0;
			this.frame = -1;
			this.init();
		}

		init() {
			const bones = this.bones;
			const boneInverses = this.boneInverses;
			this.boneMatrices = new Float32Array(bones.length * 16); // calculate inverse bone matrices if necessary

			if (boneInverses.length === 0) {
				this.calculateInverses();
			} else {
				// handle special case
				if (bones.length !== boneInverses.length) {
					console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');
					this.boneInverses = [];

					for (let i = 0, il = this.bones.length; i < il; i++) {
						this.boneInverses.push(new Matrix4());
					}
				}
			}
		}

		calculateInverses() {
			this.boneInverses.length = 0;

			for (let i = 0, il = this.bones.length; i < il; i++) {
				const inverse = new Matrix4();

				if (this.bones[i]) {
					inverse.copy(this.bones[i].matrixWorld).invert();
				}

				this.boneInverses.push(inverse);
			}
		}

		pose() {
			// recover the bind-time world matrices
			for (let i = 0, il = this.bones.length; i < il; i++) {
				const bone = this.bones[i];

				if (bone) {
					bone.matrixWorld.copy(this.boneInverses[i]).invert();
				}
			} // compute the local matrices, positions, rotations and scales


			for (let i = 0, il = this.bones.length; i < il; i++) {
				const bone = this.bones[i];

				if (bone) {
					if (bone.parent && bone.parent.isBone) {
						bone.matrix.copy(bone.parent.matrixWorld).invert();
						bone.matrix.multiply(bone.matrixWorld);
					} else {
						bone.matrix.copy(bone.matrixWorld);
					}

					bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
				}
			}
		}

		update() {
			const bones = this.bones;
			const boneInverses = this.boneInverses;
			const boneMatrices = this.boneMatrices;
			const boneTexture = this.boneTexture; // flatten bone matrices to array

			for (let i = 0, il = bones.length; i < il; i++) {
				// compute the offset between the current and the original transform
				const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;

				_offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);

				_offsetMatrix.toArray(boneMatrices, i * 16);
			}

			if (boneTexture !== null) {
				boneTexture.needsUpdate = true;
			}
		}

		clone() {
			return new Skeleton(this.bones, this.boneInverses);
		}

		computeBoneTexture() {
			// layout (1 matrix = 4 pixels)
			//			RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//	with	8x8	pixel texture max	 16 bones * 4 pixels =	(8 * 8)
			//			 16x16 pixel texture max	 64 bones * 4 pixels = (16 * 16)
			//			 32x32 pixel texture max	256 bones * 4 pixels = (32 * 32)
			//			 64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
			let size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix

			size = ceilPowerOfTwo(size);
			size = Math.max(size, 4);
			const boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel

			boneMatrices.set(this.boneMatrices); // copy current values

			const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
			this.boneMatrices = boneMatrices;
			this.boneTexture = boneTexture;
			this.boneTextureSize = size;
			return this;
		}

		getBoneByName(name) {
			for (let i = 0, il = this.bones.length; i < il; i++) {
				const bone = this.bones[i];

				if (bone.name === name) {
					return bone;
				}
			}

			return undefined;
		}

		dispose() {
			if (this.boneTexture !== null) {
				this.boneTexture.dispose();
				this.boneTexture = null;
			}
		}

		fromJSON(json, bones) {
			this.uuid = json.uuid;

			for (let i = 0, l = json.bones.length; i < l; i++) {
				const uuid = json.bones[i];
				let bone = bones[uuid];

				if (bone === undefined) {
					console.warn('THREE.Skeleton: No bone found with UUID:', uuid);
					bone = new Bone();
				}

				this.bones.push(bone);
				this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
			}

			this.init();
			return this;
		}

		toJSON() {
			const data = {
				metadata: {
					version: 4.5,
					type: 'Skeleton',
					generator: 'Skeleton.toJSON'
				},
				bones: [],
				boneInverses: []
			};
			data.uuid = this.uuid;
			const bones = this.bones;
			const boneInverses = this.boneInverses;

			for (let i = 0, l = bones.length; i < l; i++) {
				const bone = bones[i];
				data.bones.push(bone.uuid);
				const boneInverse = boneInverses[i];
				data.boneInverses.push(boneInverse.toArray());
			}

			return data;
		}

	}

	class InstancedBufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized, meshPerAttribute = 1) {
			if (typeof normalized === 'number') {
				meshPerAttribute = normalized;
				normalized = false;
				console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
			}

			super(array, itemSize, normalized);
			this.meshPerAttribute = meshPerAttribute;
		}

		copy(source) {
			super.copy(source);
			this.meshPerAttribute = source.meshPerAttribute;
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.meshPerAttribute = this.meshPerAttribute;
			data.isInstancedBufferAttribute = true;
			return data;
		}

	}

	InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;

	const _instanceLocalMatrix = /*@__PURE__*/new Matrix4();

	const _instanceWorldMatrix = /*@__PURE__*/new Matrix4();

	const _instanceIntersects = [];

	const _mesh = /*@__PURE__*/new Mesh();

	class InstancedMesh extends Mesh {
		constructor(geometry, material, count) {
			super(geometry, material);
			this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
			this.instanceColor = null;
			this.count = count;
			this.frustumCulled = false;
		}

		copy(source) {
			super.copy(source);
			this.instanceMatrix.copy(source.instanceMatrix);
			if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
			this.count = source.count;
			return this;
		}

		getColorAt(index, color) {
			color.fromArray(this.instanceColor.array, index * 3);
		}

		getMatrixAt(index, matrix) {
			matrix.fromArray(this.instanceMatrix.array, index * 16);
		}

		raycast(raycaster, intersects) {
			const matrixWorld = this.matrixWorld;
			const raycastTimes = this.count;
			_mesh.geometry = this.geometry;
			_mesh.material = this.material;
			if (_mesh.material === undefined) return;

			for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
				// calculate the world matrix for each instance
				this.getMatrixAt(instanceId, _instanceLocalMatrix);

				_instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance


				_mesh.matrixWorld = _instanceWorldMatrix;

				_mesh.raycast(raycaster, _instanceIntersects); // process the result of raycast


				for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
					const intersect = _instanceIntersects[i];
					intersect.instanceId = instanceId;
					intersect.object = this;
					intersects.push(intersect);
				}

				_instanceIntersects.length = 0;
			}
		}

		setColorAt(index, color) {
			if (this.instanceColor === null) {
				this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
			}

			color.toArray(this.instanceColor.array, index * 3);
		}

		setMatrixAt(index, matrix) {
			matrix.toArray(this.instanceMatrix.array, index * 16);
		}

		updateMorphTargets() {}

		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}

	}

	InstancedMesh.prototype.isInstancedMesh = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	linewidth: <float>,
	 *	linecap: "round",
	 *	linejoin: "round"
	 * }
	 */

	class LineBasicMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'LineBasicMaterial';
			this.color = new Color(0xffffff);
			this.linewidth = 1;
			this.linecap = 'round';
			this.linejoin = 'round';
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.linewidth = source.linewidth;
			this.linecap = source.linecap;
			this.linejoin = source.linejoin;
			return this;
		}

	}

	LineBasicMaterial.prototype.isLineBasicMaterial = true;

	const _start$1 = /*@__PURE__*/new Vector3();

	const _end$1 = /*@__PURE__*/new Vector3();

	const _inverseMatrix$1 = /*@__PURE__*/new Matrix4();

	const _ray$1 = /*@__PURE__*/new Ray();

	const _sphere$1 = /*@__PURE__*/new Sphere();

	class Line extends Object3D {
		constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
			super();
			this.type = 'Line';
			this.geometry = geometry;
			this.material = material;
			this.updateMorphTargets();
		}

		copy(source) {
			super.copy(source);
			this.material = source.material;
			this.geometry = source.geometry;
			return this;
		}

		computeLineDistances() {
			const geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				// we assume non-indexed geometry
				if (geometry.index === null) {
					const positionAttribute = geometry.attributes.position;
					const lineDistances = [0];

					for (let i = 1, l = positionAttribute.count; i < l; i++) {
						_start$1.fromBufferAttribute(positionAttribute, i - 1);

						_end$1.fromBufferAttribute(positionAttribute, i);

						lineDistances[i] = lineDistances[i - 1];
						lineDistances[i] += _start$1.distanceTo(_end$1);
					}

					geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
				} else {
					console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
				}
			} else if (geometry.isGeometry) {
				console.error('THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}

			return this;
		}

		raycast(raycaster, intersects) {
			const geometry = this.geometry;
			const matrixWorld = this.matrixWorld;
			const threshold = raycaster.params.Line.threshold;
			const drawRange = geometry.drawRange; // Checking boundingSphere distance to ray

			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			_sphere$1.copy(geometry.boundingSphere);

			_sphere$1.applyMatrix4(matrixWorld);

			_sphere$1.radius += threshold;
			if (raycaster.ray.intersectsSphere(_sphere$1) === false) return; //

			_inverseMatrix$1.copy(matrixWorld).invert();

			_ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);

			const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
			const localThresholdSq = localThreshold * localThreshold;
			const vStart = new Vector3();
			const vEnd = new Vector3();
			const interSegment = new Vector3();
			const interRay = new Vector3();
			const step = this.isLineSegments ? 2 : 1;

			if (geometry.isBufferGeometry) {
				const index = geometry.index;
				const attributes = geometry.attributes;
				const positionAttribute = attributes.position;

				if (index !== null) {
					const start = Math.max(0, drawRange.start);
					const end = Math.min(index.count, drawRange.start + drawRange.count);

					for (let i = start, l = end - 1; i < l; i += step) {
						const a = index.getX(i);
						const b = index.getX(i + 1);
						vStart.fromBufferAttribute(positionAttribute, a);
						vEnd.fromBufferAttribute(positionAttribute, b);

						const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

						if (distSq > localThresholdSq) continue;
						interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

						const distance = raycaster.ray.origin.distanceTo(interRay);
						if (distance < raycaster.near || distance > raycaster.far) continue;
						intersects.push({
							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4(this.matrixWorld),
							index: i,
							face: null,
							faceIndex: null,
							object: this
						});
					}
				} else {
					const start = Math.max(0, drawRange.start);
					const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);

					for (let i = start, l = end - 1; i < l; i += step) {
						vStart.fromBufferAttribute(positionAttribute, i);
						vEnd.fromBufferAttribute(positionAttribute, i + 1);

						const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

						if (distSq > localThresholdSq) continue;
						interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

						const distance = raycaster.ray.origin.distanceTo(interRay);
						if (distance < raycaster.near || distance > raycaster.far) continue;
						intersects.push({
							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4(this.matrixWorld),
							index: i,
							face: null,
							faceIndex: null,
							object: this
						});
					}
				}
			} else if (geometry.isGeometry) {
				console.error('THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}
		}

		updateMorphTargets() {
			const geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				const morphAttributes = geometry.morphAttributes;
				const keys = Object.keys(morphAttributes);

				if (keys.length > 0) {
					const morphAttribute = morphAttributes[keys[0]];

					if (morphAttribute !== undefined) {
						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
							const name = morphAttribute[m].name || String(m);
							this.morphTargetInfluences.push(0);
							this.morphTargetDictionary[name] = m;
						}
					}
				}
			} else {
				const morphTargets = geometry.morphTargets;

				if (morphTargets !== undefined && morphTargets.length > 0) {
					console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
				}
			}
		}

	}

	Line.prototype.isLine = true;

	const _start = /*@__PURE__*/new Vector3();

	const _end = /*@__PURE__*/new Vector3();

	class LineSegments extends Line {
		constructor(geometry, material) {
			super(geometry, material);
			this.type = 'LineSegments';
		}

		computeLineDistances() {
			const geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				// we assume non-indexed geometry
				if (geometry.index === null) {
					const positionAttribute = geometry.attributes.position;
					const lineDistances = [];

					for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
						_start.fromBufferAttribute(positionAttribute, i);

						_end.fromBufferAttribute(positionAttribute, i + 1);

						lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
						lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
					}

					geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
				} else {
					console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
				}
			} else if (geometry.isGeometry) {
				console.error('THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}

			return this;
		}

	}

	LineSegments.prototype.isLineSegments = true;

	class LineLoop extends Line {
		constructor(geometry, material) {
			super(geometry, material);
			this.type = 'LineLoop';
		}

	}

	LineLoop.prototype.isLineLoop = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *	map: new THREE.Texture( <Image> ),
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	size: <float>,
	 *	sizeAttenuation: <bool>
	 *
	 * }
	 */

	class PointsMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'PointsMaterial';
			this.color = new Color(0xffffff);
			this.map = null;
			this.alphaMap = null;
			this.size = 1;
			this.sizeAttenuation = true;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.alphaMap = source.alphaMap;
			this.size = source.size;
			this.sizeAttenuation = source.sizeAttenuation;
			return this;
		}

	}

	PointsMaterial.prototype.isPointsMaterial = true;

	const _inverseMatrix = /*@__PURE__*/new Matrix4();

	const _ray = /*@__PURE__*/new Ray();

	const _sphere = /*@__PURE__*/new Sphere();

	const _position$2 = /*@__PURE__*/new Vector3();

	class Points extends Object3D {
		constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
			super();
			this.type = 'Points';
			this.geometry = geometry;
			this.material = material;
			this.updateMorphTargets();
		}

		copy(source) {
			super.copy(source);
			this.material = source.material;
			this.geometry = source.geometry;
			return this;
		}

		raycast(raycaster, intersects) {
			const geometry = this.geometry;
			const matrixWorld = this.matrixWorld;
			const threshold = raycaster.params.Points.threshold;
			const drawRange = geometry.drawRange; // Checking boundingSphere distance to ray

			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			_sphere.copy(geometry.boundingSphere);

			_sphere.applyMatrix4(matrixWorld);

			_sphere.radius += threshold;
			if (raycaster.ray.intersectsSphere(_sphere) === false) return; //

			_inverseMatrix.copy(matrixWorld).invert();

			_ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);

			const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
			const localThresholdSq = localThreshold * localThreshold;

			if (geometry.isBufferGeometry) {
				const index = geometry.index;
				const attributes = geometry.attributes;
				const positionAttribute = attributes.position;

				if (index !== null) {
					const start = Math.max(0, drawRange.start);
					const end = Math.min(index.count, drawRange.start + drawRange.count);

					for (let i = start, il = end; i < il; i++) {
						const a = index.getX(i);

						_position$2.fromBufferAttribute(positionAttribute, a);

						testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
					}
				} else {
					const start = Math.max(0, drawRange.start);
					const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);

					for (let i = start, l = end; i < l; i++) {
						_position$2.fromBufferAttribute(positionAttribute, i);

						testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this);
					}
				}
			} else {
				console.error('THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}
		}

		updateMorphTargets() {
			const geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				const morphAttributes = geometry.morphAttributes;
				const keys = Object.keys(morphAttributes);

				if (keys.length > 0) {
					const morphAttribute = morphAttributes[keys[0]];

					if (morphAttribute !== undefined) {
						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
							const name = morphAttribute[m].name || String(m);
							this.morphTargetInfluences.push(0);
							this.morphTargetDictionary[name] = m;
						}
					}
				}
			} else {
				const morphTargets = geometry.morphTargets;

				if (morphTargets !== undefined && morphTargets.length > 0) {
					console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
				}
			}
		}

	}

	Points.prototype.isPoints = true;

	function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
		const rayPointDistanceSq = _ray.distanceSqToPoint(point);

		if (rayPointDistanceSq < localThresholdSq) {
			const intersectPoint = new Vector3();

			_ray.closestPointToPoint(point, intersectPoint);

			intersectPoint.applyMatrix4(matrixWorld);
			const distance = raycaster.ray.origin.distanceTo(intersectPoint);
			if (distance < raycaster.near || distance > raycaster.far) return;
			intersects.push({
				distance: distance,
				distanceToRay: Math.sqrt(rayPointDistanceSq),
				point: intersectPoint,
				index: index,
				face: null,
				object: object
			});
		}
	}

	class VideoTexture extends Texture {
		constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
			super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
			this.format = format !== undefined ? format : RGBFormat;
			this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
			this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
			this.generateMipmaps = false;
			const scope = this;

			function updateVideo() {
				scope.needsUpdate = true;
				video.requestVideoFrameCallback(updateVideo);
			}

			if ('requestVideoFrameCallback' in video) {
				video.requestVideoFrameCallback(updateVideo);
			}
		}

		clone() {
			return new this.constructor(this.image).copy(this);
		}

		update() {
			const video = this.image;
			const hasVideoFrameCallback = ('requestVideoFrameCallback' in video);

			if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
				this.needsUpdate = true;
			}
		}

	}

	VideoTexture.prototype.isVideoTexture = true;

	class CompressedTexture extends Texture {
		constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
			super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
			this.image = {
				width: width,
				height: height
			};
			this.mipmaps = mipmaps; // no flipping for cube textures
			// (also flipping doesn't work for compressed textures )

			this.flipY = false; // can't generate mipmaps for compressed textures
			// mips must be embedded in DDS files

			this.generateMipmaps = false;
		}

	}

	CompressedTexture.prototype.isCompressedTexture = true;

	class CanvasTexture extends Texture {
		constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
			super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
			this.needsUpdate = true;
		}

	}

	CanvasTexture.prototype.isCanvasTexture = true;

	class CircleGeometry extends BufferGeometry {
		constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {
			super();
			this.type = 'CircleGeometry';
			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			segments = Math.max(3, segments); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // helper variables

			const vertex = new Vector3();
			const uv = new Vector2(); // center point

			vertices.push(0, 0, 0);
			normals.push(0, 0, 1);
			uvs.push(0.5, 0.5);

			for (let s = 0, i = 3; s <= segments; s++, i += 3) {
				const segment = thetaStart + s / segments * thetaLength; // vertex

				vertex.x = radius * Math.cos(segment);
				vertex.y = radius * Math.sin(segment);
				vertices.push(vertex.x, vertex.y, vertex.z); // normal

				normals.push(0, 0, 1); // uvs

				uv.x = (vertices[i] / radius + 1) / 2;
				uv.y = (vertices[i + 1] / radius + 1) / 2;
				uvs.push(uv.x, uv.y);
			} // indices


			for (let i = 1; i <= segments; i++) {
				indices.push(i, i + 1, 0);
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}

		static fromJSON(data) {
			return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
		}

	}

	class CylinderGeometry extends BufferGeometry {
		constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
			super();
			this.type = 'CylinderGeometry';
			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			const scope = this;
			radialSegments = Math.floor(radialSegments);
			heightSegments = Math.floor(heightSegments); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // helper variables

			let index = 0;
			const indexArray = [];
			const halfHeight = height / 2;
			let groupStart = 0; // generate geometry

			generateTorso();

			if (openEnded === false) {
				if (radiusTop > 0) generateCap(true);
				if (radiusBottom > 0) generateCap(false);
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

			function generateTorso() {
				const normal = new Vector3();
				const vertex = new Vector3();
				let groupCount = 0; // this will be used to calculate the normal

				const slope = (radiusBottom - radiusTop) / height; // generate vertices, normals and uvs

				for (let y = 0; y <= heightSegments; y++) {
					const indexRow = [];
					const v = y / heightSegments; // calculate the radius of the current row

					const radius = v * (radiusBottom - radiusTop) + radiusTop;

					for (let x = 0; x <= radialSegments; x++) {
						const u = x / radialSegments;
						const theta = u * thetaLength + thetaStart;
						const sinTheta = Math.sin(theta);
						const cosTheta = Math.cos(theta); // vertex

						vertex.x = radius * sinTheta;
						vertex.y = -v * height + halfHeight;
						vertex.z = radius * cosTheta;
						vertices.push(vertex.x, vertex.y, vertex.z); // normal

						normal.set(sinTheta, slope, cosTheta).normalize();
						normals.push(normal.x, normal.y, normal.z); // uv

						uvs.push(u, 1 - v); // save index of vertex in respective row

						indexRow.push(index++);
					} // now save vertices of the row in our index array


					indexArray.push(indexRow);
				} // generate indices


				for (let x = 0; x < radialSegments; x++) {
					for (let y = 0; y < heightSegments; y++) {
						// we use the index array to access the correct indices
						const a = indexArray[y][x];
						const b = indexArray[y + 1][x];
						const c = indexArray[y + 1][x + 1];
						const d = indexArray[y][x + 1]; // faces

						indices.push(a, b, d);
						indices.push(b, c, d); // update group counter

						groupCount += 6;
					}
				} // add a group to the geometry. this will ensure multi material support


				scope.addGroup(groupStart, groupCount, 0); // calculate new start value for groups

				groupStart += groupCount;
			}

			function generateCap(top) {
				// save the index of the first center vertex
				const centerIndexStart = index;
				const uv = new Vector2();
				const vertex = new Vector3();
				let groupCount = 0;
				const radius = top === true ? radiusTop : radiusBottom;
				const sign = top === true ? 1 : -1; // first we generate the center vertex data of the cap.
				// because the geometry needs one set of uvs per face,
				// we must generate a center vertex per face/segment

				for (let x = 1; x <= radialSegments; x++) {
					// vertex
					vertices.push(0, halfHeight * sign, 0); // normal

					normals.push(0, sign, 0); // uv

					uvs.push(0.5, 0.5); // increase index

					index++;
				} // save the index of the last center vertex


				const centerIndexEnd = index; // now we generate the surrounding vertices, normals and uvs

				for (let x = 0; x <= radialSegments; x++) {
					const u = x / radialSegments;
					const theta = u * thetaLength + thetaStart;
					const cosTheta = Math.cos(theta);
					const sinTheta = Math.sin(theta); // vertex

					vertex.x = radius * sinTheta;
					vertex.y = halfHeight * sign;
					vertex.z = radius * cosTheta;
					vertices.push(vertex.x, vertex.y, vertex.z); // normal

					normals.push(0, sign, 0); // uv

					uv.x = cosTheta * 0.5 + 0.5;
					uv.y = sinTheta * 0.5 * sign + 0.5;
					uvs.push(uv.x, uv.y); // increase index

					index++;
				} // generate indices


				for (let x = 0; x < radialSegments; x++) {
					const c = centerIndexStart + x;
					const i = centerIndexEnd + x;

					if (top === true) {
						// face top
						indices.push(i, i + 1, c);
					} else {
						// face bottom
						indices.push(i + 1, i, c);
					}

					groupCount += 3;
				} // add a group to the geometry. this will ensure multi material support


				scope.addGroup(groupStart, groupCount, top === true ? 1 : 2); // calculate new start value for groups

				groupStart += groupCount;
			}
		}

		static fromJSON(data) {
			return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
		}

	}

	class ConeGeometry extends CylinderGeometry {
		constructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
			super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
			this.type = 'ConeGeometry';
			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
		}

		static fromJSON(data) {
			return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
		}

	}

	class PolyhedronGeometry extends BufferGeometry {
		constructor(vertices = [], indices = [], radius = 1, detail = 0) {
			super();
			this.type = 'PolyhedronGeometry';
			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			}; // default buffer data

			const vertexBuffer = [];
			const uvBuffer = []; // the subdivision creates the vertex buffer data

			subdivide(detail); // all vertices should lie on a conceptual sphere with a given radius

			applyRadius(radius); // finally, create the uv data

			generateUVs(); // build non-indexed geometry

			this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
			this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));

			if (detail === 0) {
				this.computeVertexNormals(); // flat normals
			} else {
				this.normalizeNormals(); // smooth normals
			} // helper functions


			function subdivide(detail) {
				const a = new Vector3();
				const b = new Vector3();
				const c = new Vector3(); // iterate over all faces and apply a subdivison with the given detail value

				for (let i = 0; i < indices.length; i += 3) {
					// get the vertices of the face
					getVertexByIndex(indices[i + 0], a);
					getVertexByIndex(indices[i + 1], b);
					getVertexByIndex(indices[i + 2], c); // perform subdivision

					subdivideFace(a, b, c, detail);
				}
			}

			function subdivideFace(a, b, c, detail) {
				const cols = detail + 1; // we use this multidimensional array as a data structure for creating the subdivision

				const v = []; // construct all of the vertices for this subdivision

				for (let i = 0; i <= cols; i++) {
					v[i] = [];
					const aj = a.clone().lerp(c, i / cols);
					const bj = b.clone().lerp(c, i / cols);
					const rows = cols - i;

					for (let j = 0; j <= rows; j++) {
						if (j === 0 && i === cols) {
							v[i][j] = aj;
						} else {
							v[i][j] = aj.clone().lerp(bj, j / rows);
						}
					}
				} // construct all of the faces


				for (let i = 0; i < cols; i++) {
					for (let j = 0; j < 2 * (cols - i) - 1; j++) {
						const k = Math.floor(j / 2);

						if (j % 2 === 0) {
							pushVertex(v[i][k + 1]);
							pushVertex(v[i + 1][k]);
							pushVertex(v[i][k]);
						} else {
							pushVertex(v[i][k + 1]);
							pushVertex(v[i + 1][k + 1]);
							pushVertex(v[i + 1][k]);
						}
					}
				}
			}

			function applyRadius(radius) {
				const vertex = new Vector3(); // iterate over the entire buffer and apply the radius to each vertex

				for (let i = 0; i < vertexBuffer.length; i += 3) {
					vertex.x = vertexBuffer[i + 0];
					vertex.y = vertexBuffer[i + 1];
					vertex.z = vertexBuffer[i + 2];
					vertex.normalize().multiplyScalar(radius);
					vertexBuffer[i + 0] = vertex.x;
					vertexBuffer[i + 1] = vertex.y;
					vertexBuffer[i + 2] = vertex.z;
				}
			}

			function generateUVs() {
				const vertex = new Vector3();

				for (let i = 0; i < vertexBuffer.length; i += 3) {
					vertex.x = vertexBuffer[i + 0];
					vertex.y = vertexBuffer[i + 1];
					vertex.z = vertexBuffer[i + 2];
					const u = azimuth(vertex) / 2 / Math.PI + 0.5;
					const v = inclination(vertex) / Math.PI + 0.5;
					uvBuffer.push(u, 1 - v);
				}

				correctUVs();
				correctSeam();
			}

			function correctSeam() {
				// handle case when face straddles the seam, see #3269
				for (let i = 0; i < uvBuffer.length; i += 6) {
					// uv data of a single face
					const x0 = uvBuffer[i + 0];
					const x1 = uvBuffer[i + 2];
					const x2 = uvBuffer[i + 4];
					const max = Math.max(x0, x1, x2);
					const min = Math.min(x0, x1, x2); // 0.9 is somewhat arbitrary

					if (max > 0.9 && min < 0.1) {
						if (x0 < 0.2) uvBuffer[i + 0] += 1;
						if (x1 < 0.2) uvBuffer[i + 2] += 1;
						if (x2 < 0.2) uvBuffer[i + 4] += 1;
					}
				}
			}

			function pushVertex(vertex) {
				vertexBuffer.push(vertex.x, vertex.y, vertex.z);
			}

			function getVertexByIndex(index, vertex) {
				const stride = index * 3;
				vertex.x = vertices[stride + 0];
				vertex.y = vertices[stride + 1];
				vertex.z = vertices[stride + 2];
			}

			function correctUVs() {
				const a = new Vector3();
				const b = new Vector3();
				const c = new Vector3();
				const centroid = new Vector3();
				const uvA = new Vector2();
				const uvB = new Vector2();
				const uvC = new Vector2();

				for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
					a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
					b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
					c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
					uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
					uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
					uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
					centroid.copy(a).add(b).add(c).divideScalar(3);
					const azi = azimuth(centroid);
					correctUV(uvA, j + 0, a, azi);
					correctUV(uvB, j + 2, b, azi);
					correctUV(uvC, j + 4, c, azi);
				}
			}

			function correctUV(uv, stride, vector, azimuth) {
				if (azimuth < 0 && uv.x === 1) {
					uvBuffer[stride] = uv.x - 1;
				}

				if (vector.x === 0 && vector.z === 0) {
					uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
				}
			} // Angle around the Y axis, counter-clockwise when looking from above.


			function azimuth(vector) {
				return Math.atan2(vector.z, -vector.x);
			} // Angle above the XZ plane.


			function inclination(vector) {
				return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
			}
		}

		static fromJSON(data) {
			return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
		}

	}

	class DodecahedronGeometry extends PolyhedronGeometry {
		constructor(radius = 1, detail = 0) {
			const t = (1 + Math.sqrt(5)) / 2;
			const r = 1 / t;
			const vertices = [// (±1, ±1, ±1)
			-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, // (0, ±1/φ, ±φ)
			0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, // (±1/φ, ±φ, 0)
			-r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, // (±φ, 0, ±1/φ)
			-t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
			const indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
			super(vertices, indices, radius, detail);
			this.type = 'DodecahedronGeometry';
			this.parameters = {
				radius: radius,
				detail: detail
			};
		}

		static fromJSON(data) {
			return new DodecahedronGeometry(data.radius, data.detail);
		}

	}

	const _v0 = new Vector3();

	const _v1$1 = new Vector3();

	const _normal = new Vector3();

	const _triangle = new Triangle();

	class EdgesGeometry extends BufferGeometry {
		constructor(geometry = null, thresholdAngle = 1) {
			super();
			this.type = 'EdgesGeometry';
			this.parameters = {
				geometry: geometry,
				thresholdAngle: thresholdAngle
			};

			if (geometry !== null) {
				const precisionPoints = 4;
				const precision = Math.pow(10, precisionPoints);
				const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
				const indexAttr = geometry.getIndex();
				const positionAttr = geometry.getAttribute('position');
				const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
				const indexArr = [0, 0, 0];
				const vertKeys = ['a', 'b', 'c'];
				const hashes = new Array(3);
				const edgeData = {};
				const vertices = [];

				for (let i = 0; i < indexCount; i += 3) {
					if (indexAttr) {
						indexArr[0] = indexAttr.getX(i);
						indexArr[1] = indexAttr.getX(i + 1);
						indexArr[2] = indexAttr.getX(i + 2);
					} else {
						indexArr[0] = i;
						indexArr[1] = i + 1;
						indexArr[2] = i + 2;
					}

					const {
						a,
						b,
						c
					} = _triangle;
					a.fromBufferAttribute(positionAttr, indexArr[0]);
					b.fromBufferAttribute(positionAttr, indexArr[1]);
					c.fromBufferAttribute(positionAttr, indexArr[2]);

					_triangle.getNormal(_normal); // create hashes for the edge from the vertices


					hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
					hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
					hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`; // skip degenerate triangles

					if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
						continue;
					} // iterate over every edge


					for (let j = 0; j < 3; j++) {
						// get the first and next vertex making up the edge
						const jNext = (j + 1) % 3;
						const vecHash0 = hashes[j];
						const vecHash1 = hashes[jNext];
						const v0 = _triangle[vertKeys[j]];
						const v1 = _triangle[vertKeys[jNext]];
						const hash = `${vecHash0}_${vecHash1}`;
						const reverseHash = `${vecHash1}_${vecHash0}`;

						if (reverseHash in edgeData && edgeData[reverseHash]) {
							// if we found a sibling edge add it into the vertex array if
							// it meets the angle threshold and delete the edge from the map.
							if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
								vertices.push(v0.x, v0.y, v0.z);
								vertices.push(v1.x, v1.y, v1.z);
							}

							edgeData[reverseHash] = null;
						} else if (!(hash in edgeData)) {
							// if we've already got an edge here then skip adding a new one
							edgeData[hash] = {
								index0: indexArr[j],
								index1: indexArr[jNext],
								normal: _normal.clone()
							};
						}
					}
				} // iterate over all remaining, unmatched edges and add them to the vertex array


				for (const key in edgeData) {
					if (edgeData[key]) {
						const {
							index0,
							index1
						} = edgeData[key];

						_v0.fromBufferAttribute(positionAttr, index0);

						_v1$1.fromBufferAttribute(positionAttr, index1);

						vertices.push(_v0.x, _v0.y, _v0.z);
						vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
					}
				}

				this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			}
		}

	}

	/**
	 * Extensible curve object.
	 *
	 * Some common of curve methods:
	 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
	 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following curves inherit from THREE.Curve:
	 *
	 * -- 2D curves --
	 * THREE.ArcCurve
	 * THREE.CubicBezierCurve
	 * THREE.EllipseCurve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.SplineCurve
	 *
	 * -- 3D curves --
	 * THREE.CatmullRomCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath.
	 *
	 **/

	class Curve {
		constructor() {
			this.type = 'Curve';
			this.arcLengthDivisions = 200;
		} // Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]


		getPoint() {
			console.warn('THREE.Curve: .getPoint() not implemented.');
			return null;
		} // Get point at relative position in curve according to arc length
		// - u [0 .. 1]


		getPointAt(u, optionalTarget) {
			const t = this.getUtoTmapping(u);
			return this.getPoint(t, optionalTarget);
		} // Get sequence of points using getPoint( t )


		getPoints(divisions = 5) {
			const points = [];

			for (let d = 0; d <= divisions; d++) {
				points.push(this.getPoint(d / divisions));
			}

			return points;
		} // Get sequence of points using getPointAt( u )


		getSpacedPoints(divisions = 5) {
			const points = [];

			for (let d = 0; d <= divisions; d++) {
				points.push(this.getPointAt(d / divisions));
			}

			return points;
		} // Get total curve arc length


		getLength() {
			const lengths = this.getLengths();
			return lengths[lengths.length - 1];
		} // Get list of cumulative segment lengths


		getLengths(divisions = this.arcLengthDivisions) {
			if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
				return this.cacheArcLengths;
			}

			this.needsUpdate = false;
			const cache = [];
			let current,
					last = this.getPoint(0);
			let sum = 0;
			cache.push(0);

			for (let p = 1; p <= divisions; p++) {
				current = this.getPoint(p / divisions);
				sum += current.distanceTo(last);
				cache.push(sum);
				last = current;
			}

			this.cacheArcLengths = cache;
			return cache; // { sums: cache, sum: sum }; Sum is in the last element.
		}

		updateArcLengths() {
			this.needsUpdate = true;
			this.getLengths();
		} // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant


		getUtoTmapping(u, distance) {
			const arcLengths = this.getLengths();
			let i = 0;
			const il = arcLengths.length;
			let targetArcLength; // The targeted u distance value to get

			if (distance) {
				targetArcLength = distance;
			} else {
				targetArcLength = u * arcLengths[il - 1];
			} // binary search for the index with largest value smaller than target u distance


			let low = 0,
					high = il - 1,
					comparison;

			while (low <= high) {
				i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

				comparison = arcLengths[i] - targetArcLength;

				if (comparison < 0) {
					low = i + 1;
				} else if (comparison > 0) {
					high = i - 1;
				} else {
					high = i;
					break; // DONE
				}
			}

			i = high;

			if (arcLengths[i] === targetArcLength) {
				return i / (il - 1);
			} // we could get finer grain at lengths, or use simple interpolation between two points


			const lengthBefore = arcLengths[i];
			const lengthAfter = arcLengths[i + 1];
			const segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points

			const segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t

			const t = (i + segmentFraction) / (il - 1);
			return t;
		} // Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation


		getTangent(t, optionalTarget) {
			const delta = 0.0001;
			let t1 = t - delta;
			let t2 = t + delta; // Capping in case of danger

			if (t1 < 0) t1 = 0;
			if (t2 > 1) t2 = 1;
			const pt1 = this.getPoint(t1);
			const pt2 = this.getPoint(t2);
			const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
			tangent.copy(pt2).sub(pt1).normalize();
			return tangent;
		}

		getTangentAt(u, optionalTarget) {
			const t = this.getUtoTmapping(u);
			return this.getTangent(t, optionalTarget);
		}

		computeFrenetFrames(segments, closed) {
			// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
			const normal = new Vector3();
			const tangents = [];
			const normals = [];
			const binormals = [];
			const vec = new Vector3();
			const mat = new Matrix4(); // compute the tangent vectors for each segment on the curve

			for (let i = 0; i <= segments; i++) {
				const u = i / segments;
				tangents[i] = this.getTangentAt(u, new Vector3());
			} // select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the minimum tangent xyz component


			normals[0] = new Vector3();
			binormals[0] = new Vector3();
			let min = Number.MAX_VALUE;
			const tx = Math.abs(tangents[0].x);
			const ty = Math.abs(tangents[0].y);
			const tz = Math.abs(tangents[0].z);

			if (tx <= min) {
				min = tx;
				normal.set(1, 0, 0);
			}

			if (ty <= min) {
				min = ty;
				normal.set(0, 1, 0);
			}

			if (tz <= min) {
				normal.set(0, 0, 1);
			}

			vec.crossVectors(tangents[0], normal).normalize();
			normals[0].crossVectors(tangents[0], vec);
			binormals[0].crossVectors(tangents[0], normals[0]); // compute the slowly-varying normal and binormal vectors for each segment on the curve

			for (let i = 1; i <= segments; i++) {
				normals[i] = normals[i - 1].clone();
				binormals[i] = binormals[i - 1].clone();
				vec.crossVectors(tangents[i - 1], tangents[i]);

				if (vec.length() > Number.EPSILON) {
					vec.normalize();
					const theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors

					normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
				}

				binormals[i].crossVectors(tangents[i], normals[i]);
			} // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same


			if (closed === true) {
				let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
				theta /= segments;

				if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
					theta = -theta;
				}

				for (let i = 1; i <= segments; i++) {
					// twist a little...
					normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
					binormals[i].crossVectors(tangents[i], normals[i]);
				}
			}

			return {
				tangents: tangents,
				normals: normals,
				binormals: binormals
			};
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(source) {
			this.arcLengthDivisions = source.arcLengthDivisions;
			return this;
		}

		toJSON() {
			const data = {
				metadata: {
					version: 4.5,
					type: 'Curve',
					generator: 'Curve.toJSON'
				}
			};
			data.arcLengthDivisions = this.arcLengthDivisions;
			data.type = this.type;
			return data;
		}

		fromJSON(json) {
			this.arcLengthDivisions = json.arcLengthDivisions;
			return this;
		}

	}

	class EllipseCurve extends Curve {
		constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
			super();
			this.type = 'EllipseCurve';
			this.aX = aX;
			this.aY = aY;
			this.xRadius = xRadius;
			this.yRadius = yRadius;
			this.aStartAngle = aStartAngle;
			this.aEndAngle = aEndAngle;
			this.aClockwise = aClockwise;
			this.aRotation = aRotation;
		}

		getPoint(t, optionalTarget) {
			const point = optionalTarget || new Vector2();
			const twoPi = Math.PI * 2;
			let deltaAngle = this.aEndAngle - this.aStartAngle;
			const samePoints = Math.abs(deltaAngle) < Number.EPSILON; // ensures that deltaAngle is 0 .. 2 PI

			while (deltaAngle < 0) deltaAngle += twoPi;

			while (deltaAngle > twoPi) deltaAngle -= twoPi;

			if (deltaAngle < Number.EPSILON) {
				if (samePoints) {
					deltaAngle = 0;
				} else {
					deltaAngle = twoPi;
				}
			}

			if (this.aClockwise === true && !samePoints) {
				if (deltaAngle === twoPi) {
					deltaAngle = -twoPi;
				} else {
					deltaAngle = deltaAngle - twoPi;
				}
			}

			const angle = this.aStartAngle + t * deltaAngle;
			let x = this.aX + this.xRadius * Math.cos(angle);
			let y = this.aY + this.yRadius * Math.sin(angle);

			if (this.aRotation !== 0) {
				const cos = Math.cos(this.aRotation);
				const sin = Math.sin(this.aRotation);
				const tx = x - this.aX;
				const ty = y - this.aY; // Rotate the point about the center of the ellipse.

				x = tx * cos - ty * sin + this.aX;
				y = tx * sin + ty * cos + this.aY;
			}

			return point.set(x, y);
		}

		copy(source) {
			super.copy(source);
			this.aX = source.aX;
			this.aY = source.aY;
			this.xRadius = source.xRadius;
			this.yRadius = source.yRadius;
			this.aStartAngle = source.aStartAngle;
			this.aEndAngle = source.aEndAngle;
			this.aClockwise = source.aClockwise;
			this.aRotation = source.aRotation;
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.aX = this.aX;
			data.aY = this.aY;
			data.xRadius = this.xRadius;
			data.yRadius = this.yRadius;
			data.aStartAngle = this.aStartAngle;
			data.aEndAngle = this.aEndAngle;
			data.aClockwise = this.aClockwise;
			data.aRotation = this.aRotation;
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.aX = json.aX;
			this.aY = json.aY;
			this.xRadius = json.xRadius;
			this.yRadius = json.yRadius;
			this.aStartAngle = json.aStartAngle;
			this.aEndAngle = json.aEndAngle;
			this.aClockwise = json.aClockwise;
			this.aRotation = json.aRotation;
			return this;
		}

	}

	EllipseCurve.prototype.isEllipseCurve = true;

	class ArcCurve extends EllipseCurve {
		constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
			super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
			this.type = 'ArcCurve';
		}

	}

	ArcCurve.prototype.isArcCurve = true;

	/**
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */

	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly() {
		let c0 = 0,
				c1 = 0,
				c2 = 0,
				c3 = 0;
		/*
		 * Compute coefficients for a cubic polynomial
		 *	 p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *	 p(0) = x0, p(1) = x1
		 *	and
		 *	 p'(0) = t0, p'(1) = t1.
		 */

		function init(x0, x1, t0, t1) {
			c0 = x0;
			c1 = t0;
			c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
			c3 = 2 * x0 - 2 * x1 + t0 + t1;
		}

		return {
			initCatmullRom: function (x0, x1, x2, x3, tension) {
				init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
			},
			initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {
				// compute tangents when parameterized in [t1,t2]
				let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
				let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2; // rescale tangents for parametrization in [0,1]

				t1 *= dt1;
				t2 *= dt1;
				init(x1, x2, t1, t2);
			},
			calc: function (t) {
				const t2 = t * t;
				const t3 = t2 * t;
				return c0 + c1 * t + c2 * t2 + c3 * t3;
			}
		};
	} //


	const tmp = new Vector3();
	const px = new CubicPoly(),
				py = new CubicPoly(),
				pz = new CubicPoly();

	class CatmullRomCurve3 extends Curve {
		constructor(points = [], closed = false, curveType = 'centripetal', tension = 0.5) {
			super();
			this.type = 'CatmullRomCurve3';
			this.points = points;
			this.closed = closed;
			this.curveType = curveType;
			this.tension = tension;
		}

		getPoint(t, optionalTarget = new Vector3()) {
			const point = optionalTarget;
			const points = this.points;
			const l = points.length;
			const p = (l - (this.closed ? 0 : 1)) * t;
			let intPoint = Math.floor(p);
			let weight = p - intPoint;

			if (this.closed) {
				intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
			} else if (weight === 0 && intPoint === l - 1) {
				intPoint = l - 2;
				weight = 1;
			}

			let p0, p3; // 4 points (p1 & p2 defined below)

			if (this.closed || intPoint > 0) {
				p0 = points[(intPoint - 1) % l];
			} else {
				// extrapolate first point
				tmp.subVectors(points[0], points[1]).add(points[0]);
				p0 = tmp;
			}

			const p1 = points[intPoint % l];
			const p2 = points[(intPoint + 1) % l];

			if (this.closed || intPoint + 2 < l) {
				p3 = points[(intPoint + 2) % l];
			} else {
				// extrapolate last point
				tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
				p3 = tmp;
			}

			if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
				// init Centripetal / Chordal Catmull-Rom
				const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
				let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
				let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
				let dt2 = Math.pow(p2.distanceToSquared(p3), pow); // safety check for repeated points

				if (dt1 < 1e-4) dt1 = 1.0;
				if (dt0 < 1e-4) dt0 = dt1;
				if (dt2 < 1e-4) dt2 = dt1;
				px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
				py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
				pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
			} else if (this.curveType === 'catmullrom') {
				px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
				py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
				pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
			}

			point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
			return point;
		}

		copy(source) {
			super.copy(source);
			this.points = [];

			for (let i = 0, l = source.points.length; i < l; i++) {
				const point = source.points[i];
				this.points.push(point.clone());
			}

			this.closed = source.closed;
			this.curveType = source.curveType;
			this.tension = source.tension;
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.points = [];

			for (let i = 0, l = this.points.length; i < l; i++) {
				const point = this.points[i];
				data.points.push(point.toArray());
			}

			data.closed = this.closed;
			data.curveType = this.curveType;
			data.tension = this.tension;
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.points = [];

			for (let i = 0, l = json.points.length; i < l; i++) {
				const point = json.points[i];
				this.points.push(new Vector3().fromArray(point));
			}

			this.closed = json.closed;
			this.curveType = json.curveType;
			this.tension = json.tension;
			return this;
		}

	}

	CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

	/**
	 * Bezier Curves formulas obtained from
	 * http://en.wikipedia.org/wiki/Bézier_curve
	 */
	function CatmullRom(t, p0, p1, p2, p3) {
		const v0 = (p2 - p0) * 0.5;
		const v1 = (p3 - p1) * 0.5;
		const t2 = t * t;
		const t3 = t * t2;
		return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
	} //


	function QuadraticBezierP0(t, p) {
		const k = 1 - t;
		return k * k * p;
	}

	function QuadraticBezierP1(t, p) {
		return 2 * (1 - t) * t * p;
	}

	function QuadraticBezierP2(t, p) {
		return t * t * p;
	}

	function QuadraticBezier(t, p0, p1, p2) {
		return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
	} //


	function CubicBezierP0(t, p) {
		const k = 1 - t;
		return k * k * k * p;
	}

	function CubicBezierP1(t, p) {
		const k = 1 - t;
		return 3 * k * k * t * p;
	}

	function CubicBezierP2(t, p) {
		return 3 * (1 - t) * t * t * p;
	}

	function CubicBezierP3(t, p) {
		return t * t * t * p;
	}

	function CubicBezier(t, p0, p1, p2, p3) {
		return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
	}

	class CubicBezierCurve extends Curve {
		constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
			super();
			this.type = 'CubicBezierCurve';
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
		}

		getPoint(t, optionalTarget = new Vector2()) {
			const point = optionalTarget;
			const v0 = this.v0,
						v1 = this.v1,
						v2 = this.v2,
						v3 = this.v3;
			point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
			return point;
		}

		copy(source) {
			super.copy(source);
			this.v0.copy(source.v0);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			this.v3.copy(source.v3);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			data.v3 = this.v3.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.v0.fromArray(json.v0);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			this.v3.fromArray(json.v3);
			return this;
		}

	}

	CubicBezierCurve.prototype.isCubicBezierCurve = true;

	class CubicBezierCurve3 extends Curve {
		constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
			super();
			this.type = 'CubicBezierCurve3';
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
		}

		getPoint(t, optionalTarget = new Vector3()) {
			const point = optionalTarget;
			const v0 = this.v0,
						v1 = this.v1,
						v2 = this.v2,
						v3 = this.v3;
			point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
			return point;
		}

		copy(source) {
			super.copy(source);
			this.v0.copy(source.v0);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			this.v3.copy(source.v3);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			data.v3 = this.v3.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.v0.fromArray(json.v0);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			this.v3.fromArray(json.v3);
			return this;
		}

	}

	CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

	class LineCurve extends Curve {
		constructor(v1 = new Vector2(), v2 = new Vector2()) {
			super();
			this.type = 'LineCurve';
			this.v1 = v1;
			this.v2 = v2;
		}

		getPoint(t, optionalTarget = new Vector2()) {
			const point = optionalTarget;

			if (t === 1) {
				point.copy(this.v2);
			} else {
				point.copy(this.v2).sub(this.v1);
				point.multiplyScalar(t).add(this.v1);
			}

			return point;
		} // Line curve is linear, so we can overwrite default getPointAt


		getPointAt(u, optionalTarget) {
			return this.getPoint(u, optionalTarget);
		}

		getTangent(t, optionalTarget) {
			const tangent = optionalTarget || new Vector2();
			tangent.copy(this.v2).sub(this.v1).normalize();
			return tangent;
		}

		copy(source) {
			super.copy(source);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			return this;
		}

	}

	LineCurve.prototype.isLineCurve = true;

	class LineCurve3 extends Curve {
		constructor(v1 = new Vector3(), v2 = new Vector3()) {
			super();
			this.type = 'LineCurve3';
			this.isLineCurve3 = true;
			this.v1 = v1;
			this.v2 = v2;
		}

		getPoint(t, optionalTarget = new Vector3()) {
			const point = optionalTarget;

			if (t === 1) {
				point.copy(this.v2);
			} else {
				point.copy(this.v2).sub(this.v1);
				point.multiplyScalar(t).add(this.v1);
			}

			return point;
		} // Line curve is linear, so we can overwrite default getPointAt


		getPointAt(u, optionalTarget) {
			return this.getPoint(u, optionalTarget);
		}

		copy(source) {
			super.copy(source);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			return this;
		}

	}

	class QuadraticBezierCurve extends Curve {
		constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
			super();
			this.type = 'QuadraticBezierCurve';
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
		}

		getPoint(t, optionalTarget = new Vector2()) {
			const point = optionalTarget;
			const v0 = this.v0,
						v1 = this.v1,
						v2 = this.v2;
			point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
			return point;
		}

		copy(source) {
			super.copy(source);
			this.v0.copy(source.v0);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.v0.fromArray(json.v0);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			return this;
		}

	}

	QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

	class QuadraticBezierCurve3 extends Curve {
		constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
			super();
			this.type = 'QuadraticBezierCurve3';
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
		}

		getPoint(t, optionalTarget = new Vector3()) {
			const point = optionalTarget;
			const v0 = this.v0,
						v1 = this.v1,
						v2 = this.v2;
			point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
			return point;
		}

		copy(source) {
			super.copy(source);
			this.v0.copy(source.v0);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.v0.fromArray(json.v0);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			return this;
		}

	}

	QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

	class SplineCurve extends Curve {
		constructor(points = []) {
			super();
			this.type = 'SplineCurve';
			this.points = points;
		}

		getPoint(t, optionalTarget = new Vector2()) {
			const point = optionalTarget;
			const points = this.points;
			const p = (points.length - 1) * t;
			const intPoint = Math.floor(p);
			const weight = p - intPoint;
			const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
			const p1 = points[intPoint];
			const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
			const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
			point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
			return point;
		}

		copy(source) {
			super.copy(source);
			this.points = [];

			for (let i = 0, l = source.points.length; i < l; i++) {
				const point = source.points[i];
				this.points.push(point.clone());
			}

			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.points = [];

			for (let i = 0, l = this.points.length; i < l; i++) {
				const point = this.points[i];
				data.points.push(point.toArray());
			}

			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.points = [];

			for (let i = 0, l = json.points.length; i < l; i++) {
				const point = json.points[i];
				this.points.push(new Vector2().fromArray(point));
			}

			return this;
		}

	}

	SplineCurve.prototype.isSplineCurve = true;

	var Curves = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ArcCurve: ArcCurve,
		CatmullRomCurve3: CatmullRomCurve3,
		CubicBezierCurve: CubicBezierCurve,
		CubicBezierCurve3: CubicBezierCurve3,
		EllipseCurve: EllipseCurve,
		LineCurve: LineCurve,
		LineCurve3: LineCurve3,
		QuadraticBezierCurve: QuadraticBezierCurve,
		QuadraticBezierCurve3: QuadraticBezierCurve3,
		SplineCurve: SplineCurve
	});

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *	curves, but retains the api of a curve
	 **************************************************************/

	class CurvePath extends Curve {
		constructor() {
			super();
			this.type = 'CurvePath';
			this.curves = [];
			this.autoClose = false; // Automatically closes the path
		}

		add(curve) {
			this.curves.push(curve);
		}

		closePath() {
			// Add a line curve if start and end of lines are not connected
			const startPoint = this.curves[0].getPoint(0);
			const endPoint = this.curves[this.curves.length - 1].getPoint(1);

			if (!startPoint.equals(endPoint)) {
				this.curves.push(new LineCurve(endPoint, startPoint));
			}
		} // To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:
		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')


		getPoint(t, optionalTarget) {
			const d = t * this.getLength();
			const curveLengths = this.getCurveLengths();
			let i = 0; // To think about boundaries points.

			while (i < curveLengths.length) {
				if (curveLengths[i] >= d) {
					const diff = curveLengths[i] - d;
					const curve = this.curves[i];
					const segmentLength = curve.getLength();
					const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
					return curve.getPointAt(u, optionalTarget);
				}

				i++;
			}

			return null; // loop where sum != 0, sum > d , sum+1 <d
		} // We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength


		getLength() {
			const lens = this.getCurveLengths();
			return lens[lens.length - 1];
		} // cacheLengths must be recalculated.


		updateArcLengths() {
			this.needsUpdate = true;
			this.cacheLengths = null;
			this.getCurveLengths();
		} // Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.


		getCurveLengths() {
			// We use cache values if curves and cache array are same length
			if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
				return this.cacheLengths;
			} // Get length of sub-curve
			// Push sums into cached array


			const lengths = [];
			let sums = 0;

			for (let i = 0, l = this.curves.length; i < l; i++) {
				sums += this.curves[i].getLength();
				lengths.push(sums);
			}

			this.cacheLengths = lengths;
			return lengths;
		}

		getSpacedPoints(divisions = 40) {
			const points = [];

			for (let i = 0; i <= divisions; i++) {
				points.push(this.getPoint(i / divisions));
			}

			if (this.autoClose) {
				points.push(points[0]);
			}

			return points;
		}

		getPoints(divisions = 12) {
			const points = [];
			let last;

			for (let i = 0, curves = this.curves; i < curves.length; i++) {
				const curve = curves[i];
				const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
				const pts = curve.getPoints(resolution);

				for (let j = 0; j < pts.length; j++) {
					const point = pts[j];
					if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates

					points.push(point);
					last = point;
				}
			}

			if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
				points.push(points[0]);
			}

			return points;
		}

		copy(source) {
			super.copy(source);
			this.curves = [];

			for (let i = 0, l = source.curves.length; i < l; i++) {
				const curve = source.curves[i];
				this.curves.push(curve.clone());
			}

			this.autoClose = source.autoClose;
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.autoClose = this.autoClose;
			data.curves = [];

			for (let i = 0, l = this.curves.length; i < l; i++) {
				const curve = this.curves[i];
				data.curves.push(curve.toJSON());
			}

			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.autoClose = json.autoClose;
			this.curves = [];

			for (let i = 0, l = json.curves.length; i < l; i++) {
				const curve = json.curves[i];
				this.curves.push(new Curves[curve.type]().fromJSON(curve));
			}

			return this;
		}

	}

	class Path extends CurvePath {
		constructor(points) {
			super();
			this.type = 'Path';
			this.currentPoint = new Vector2();

			if (points) {
				this.setFromPoints(points);
			}
		}

		setFromPoints(points) {
			this.moveTo(points[0].x, points[0].y);

			for (let i = 1, l = points.length; i < l; i++) {
				this.lineTo(points[i].x, points[i].y);
			}

			return this;
		}

		moveTo(x, y) {
			this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?

			return this;
		}

		lineTo(x, y) {
			const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
			this.curves.push(curve);
			this.currentPoint.set(x, y);
			return this;
		}

		quadraticCurveTo(aCPx, aCPy, aX, aY) {
			const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
			this.curves.push(curve);
			this.currentPoint.set(aX, aY);
			return this;
		}

		bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
			const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
			this.curves.push(curve);
			this.currentPoint.set(aX, aY);
			return this;
		}

		splineThru(pts
		/*Array of Vector*/
		) {
			const npts = [this.currentPoint.clone()].concat(pts);
			const curve = new SplineCurve(npts);
			this.curves.push(curve);
			this.currentPoint.copy(pts[pts.length - 1]);
			return this;
		}

		arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
			const x0 = this.currentPoint.x;
			const y0 = this.currentPoint.y;
			this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
			return this;
		}

		absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
			this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
			return this;
		}

		ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
			const x0 = this.currentPoint.x;
			const y0 = this.currentPoint.y;
			this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
			return this;
		}

		absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
			const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);

			if (this.curves.length > 0) {
				// if a previous curve is present, attempt to join
				const firstPoint = curve.getPoint(0);

				if (!firstPoint.equals(this.currentPoint)) {
					this.lineTo(firstPoint.x, firstPoint.y);
				}
			}

			this.curves.push(curve);
			const lastPoint = curve.getPoint(1);
			this.currentPoint.copy(lastPoint);
			return this;
		}

		copy(source) {
			super.copy(source);
			this.currentPoint.copy(source.currentPoint);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.currentPoint = this.currentPoint.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.currentPoint.fromArray(json.currentPoint);
			return this;
		}

	}

	class Shape extends Path {
		constructor(points) {
			super(points);
			this.uuid = generateUUID();
			this.type = 'Shape';
			this.holes = [];
		}

		getPointsHoles(divisions) {
			const holesPts = [];

			for (let i = 0, l = this.holes.length; i < l; i++) {
				holesPts[i] = this.holes[i].getPoints(divisions);
			}

			return holesPts;
		} // get points of shape and holes (keypoints based on segments parameter)


		extractPoints(divisions) {
			return {
				shape: this.getPoints(divisions),
				holes: this.getPointsHoles(divisions)
			};
		}

		copy(source) {
			super.copy(source);
			this.holes = [];

			for (let i = 0, l = source.holes.length; i < l; i++) {
				const hole = source.holes[i];
				this.holes.push(hole.clone());
			}

			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.uuid = this.uuid;
			data.holes = [];

			for (let i = 0, l = this.holes.length; i < l; i++) {
				const hole = this.holes[i];
				data.holes.push(hole.toJSON());
			}

			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.uuid = json.uuid;
			this.holes = [];

			for (let i = 0, l = json.holes.length; i < l; i++) {
				const hole = json.holes[i];
				this.holes.push(new Path().fromJSON(hole));
			}

			return this;
		}

	}

	/**
	 * Port from https://github.com/mapbox/earcut (v2.2.2)
	 */
	const Earcut = {
		triangulate: function (data, holeIndices, dim = 2) {
			const hasHoles = holeIndices && holeIndices.length;
			const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
			let outerNode = linkedList(data, 0, outerLen, dim, true);
			const triangles = [];
			if (!outerNode || outerNode.next === outerNode.prev) return triangles;
			let minX, minY, maxX, maxY, x, y, invSize;
			if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

			if (data.length > 80 * dim) {
				minX = maxX = data[0];
				minY = maxY = data[1];

				for (let i = dim; i < outerLen; i += dim) {
					x = data[i];
					y = data[i + 1];
					if (x < minX) minX = x;
					if (y < minY) minY = y;
					if (x > maxX) maxX = x;
					if (y > maxY) maxY = y;
				} // minX, minY and invSize are later used to transform coords into integers for z-order calculation


				invSize = Math.max(maxX - minX, maxY - minY);
				invSize = invSize !== 0 ? 1 / invSize : 0;
			}

			earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
			return triangles;
		}
	}; // create a circular doubly linked list from polygon points in the specified winding order

	function linkedList(data, start, end, dim, clockwise) {
		let i, last;

		if (clockwise === signedArea(data, start, end, dim) > 0) {
			for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
		} else {
			for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
		}

		if (last && equals(last, last.next)) {
			removeNode(last);
			last = last.next;
		}

		return last;
	} // eliminate colinear or duplicate points


	function filterPoints(start, end) {
		if (!start) return start;
		if (!end) end = start;
		let p = start,
				again;

		do {
			again = false;

			if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
				removeNode(p);
				p = end = p.prev;
				if (p === p.next) break;
				again = true;
			} else {
				p = p.next;
			}
		} while (again || p !== end);

		return end;
	} // main ear slicing loop which triangulates a polygon (given as a linked list)


	function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
		if (!ear) return; // interlink polygon nodes in z-order

		if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
		let stop = ear,
				prev,
				next; // iterate through ears, slicing them one by one

		while (ear.prev !== ear.next) {
			prev = ear.prev;
			next = ear.next;

			if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
				// cut off the triangle
				triangles.push(prev.i / dim);
				triangles.push(ear.i / dim);
				triangles.push(next.i / dim);
				removeNode(ear); // skipping the next vertex leads to less sliver triangles

				ear = next.next;
				stop = next.next;
				continue;
			}

			ear = next; // if we looped through the whole remaining polygon and can't find any more ears

			if (ear === stop) {
				// try filtering points and slicing again
				if (!pass) {
					earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally
				} else if (pass === 1) {
					ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
					earcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two
				} else if (pass === 2) {
					splitEarcut(ear, triangles, dim, minX, minY, invSize);
				}

				break;
			}
		}
	} // check whether a polygon node forms a valid ear with adjacent nodes


	function isEar(ear) {
		const a = ear.prev,
					b = ear,
					c = ear.next;
		if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
		// now make sure we don't have other points inside the potential ear

		let p = ear.next.next;

		while (p !== ear.prev) {
			if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
			p = p.next;
		}

		return true;
	}

	function isEarHashed(ear, minX, minY, invSize) {
		const a = ear.prev,
					b = ear,
					c = ear.next;
		if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
		// triangle bbox; min & max are calculated like this for speed

		const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,
					minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,
					maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,
					maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;

		const minZ = zOrder(minTX, minTY, minX, minY, invSize),
					maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
		let p = ear.prevZ,
				n = ear.nextZ; // look for points inside the triangle in both directions

		while (p && p.z >= minZ && n && n.z <= maxZ) {
			if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
			p = p.prevZ;
			if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
			n = n.nextZ;
		} // look for remaining points in decreasing z-order


		while (p && p.z >= minZ) {
			if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
			p = p.prevZ;
		} // look for remaining points in increasing z-order


		while (n && n.z <= maxZ) {
			if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
			n = n.nextZ;
		}

		return true;
	} // go through all polygon nodes and cure small local self-intersections


	function cureLocalIntersections(start, triangles, dim) {
		let p = start;

		do {
			const a = p.prev,
						b = p.next.next;

			if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
				triangles.push(a.i / dim);
				triangles.push(p.i / dim);
				triangles.push(b.i / dim); // remove two nodes involved

				removeNode(p);
				removeNode(p.next);
				p = start = b;
			}

			p = p.next;
		} while (p !== start);

		return filterPoints(p);
	} // try splitting polygon into two and triangulate them independently


	function splitEarcut(start, triangles, dim, minX, minY, invSize) {
		// look for a valid diagonal that divides the polygon into two
		let a = start;

		do {
			let b = a.next.next;

			while (b !== a.prev) {
				if (a.i !== b.i && isValidDiagonal(a, b)) {
					// split the polygon in two by the diagonal
					let c = splitPolygon(a, b); // filter colinear points around the cuts

					a = filterPoints(a, a.next);
					c = filterPoints(c, c.next); // run earcut on each half

					earcutLinked(a, triangles, dim, minX, minY, invSize);
					earcutLinked(c, triangles, dim, minX, minY, invSize);
					return;
				}

				b = b.next;
			}

			a = a.next;
		} while (a !== start);
	} // link every hole into the outer loop, producing a single-ring polygon without holes


	function eliminateHoles(data, holeIndices, outerNode, dim) {
		const queue = [];
		let i, len, start, end, list;

		for (i = 0, len = holeIndices.length; i < len; i++) {
			start = holeIndices[i] * dim;
			end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
			list = linkedList(data, start, end, dim, false);
			if (list === list.next) list.steiner = true;
			queue.push(getLeftmost(list));
		}

		queue.sort(compareX); // process holes from left to right

		for (i = 0; i < queue.length; i++) {
			eliminateHole(queue[i], outerNode);
			outerNode = filterPoints(outerNode, outerNode.next);
		}

		return outerNode;
	}

	function compareX(a, b) {
		return a.x - b.x;
	} // find a bridge between vertices that connects hole with an outer ring and and link it


	function eliminateHole(hole, outerNode) {
		outerNode = findHoleBridge(hole, outerNode);

		if (outerNode) {
			const b = splitPolygon(outerNode, hole); // filter collinear points around the cuts

			filterPoints(outerNode, outerNode.next);
			filterPoints(b, b.next);
		}
	} // David Eberly's algorithm for finding a bridge between hole and outer polygon


	function findHoleBridge(hole, outerNode) {
		let p = outerNode;
		const hx = hole.x;
		const hy = hole.y;
		let qx = -Infinity,
				m; // find a segment intersected by a ray from the hole's leftmost point to the left;
		// segment's endpoint with lesser x will be potential connection point

		do {
			if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
				const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

				if (x <= hx && x > qx) {
					qx = x;

					if (x === hx) {
						if (hy === p.y) return p;
						if (hy === p.next.y) return p.next;
					}

					m = p.x < p.next.x ? p : p.next;
				}
			}

			p = p.next;
		} while (p !== outerNode);

		if (!m) return null;
		if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint
		// look for points inside the triangle of hole point, segment intersection and endpoint;
		// if there are no points found, we have a valid connection;
		// otherwise choose the point of the minimum angle with the ray as connection point

		const stop = m,
					mx = m.x,
					my = m.y;
		let tanMin = Infinity,
				tan;
		p = m;

		do {
			if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
				tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

				if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
					m = p;
					tanMin = tan;
				}
			}

			p = p.next;
		} while (p !== stop);

		return m;
	} // whether sector in vertex m contains sector in vertex p in the same coordinates


	function sectorContainsSector(m, p) {
		return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
	} // interlink polygon nodes in z-order


	function indexCurve(start, minX, minY, invSize) {
		let p = start;

		do {
			if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
			p.prevZ = p.prev;
			p.nextZ = p.next;
			p = p.next;
		} while (p !== start);

		p.prevZ.nextZ = null;
		p.prevZ = null;
		sortLinked(p);
	} // Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html


	function sortLinked(list) {
		let i,
				p,
				q,
				e,
				tail,
				numMerges,
				pSize,
				qSize,
				inSize = 1;

		do {
			p = list;
			list = null;
			tail = null;
			numMerges = 0;

			while (p) {
				numMerges++;
				q = p;
				pSize = 0;

				for (i = 0; i < inSize; i++) {
					pSize++;
					q = q.nextZ;
					if (!q) break;
				}

				qSize = inSize;

				while (pSize > 0 || qSize > 0 && q) {
					if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
						e = p;
						p = p.nextZ;
						pSize--;
					} else {
						e = q;
						q = q.nextZ;
						qSize--;
					}

					if (tail) tail.nextZ = e;else list = e;
					e.prevZ = tail;
					tail = e;
				}

				p = q;
			}

			tail.nextZ = null;
			inSize *= 2;
		} while (numMerges > 1);

		return list;
	} // z-order of a point given coords and inverse of the longer side of data bbox


	function zOrder(x, y, minX, minY, invSize) {
		// coords are transformed into non-negative 15-bit integer range
		x = 32767 * (x - minX) * invSize;
		y = 32767 * (y - minY) * invSize;
		x = (x | x << 8) & 0x00FF00FF;
		x = (x | x << 4) & 0x0F0F0F0F;
		x = (x | x << 2) & 0x33333333;
		x = (x | x << 1) & 0x55555555;
		y = (y | y << 8) & 0x00FF00FF;
		y = (y | y << 4) & 0x0F0F0F0F;
		y = (y | y << 2) & 0x33333333;
		y = (y | y << 1) & 0x55555555;
		return x | y << 1;
	} // find the leftmost node of a polygon ring


	function getLeftmost(start) {
		let p = start,
				leftmost = start;

		do {
			if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
			p = p.next;
		} while (p !== start);

		return leftmost;
	} // check if a point lies within a convex triangle


	function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
		return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
	} // check if a diagonal between two polygon nodes is valid (lies in polygon interior)


	function isValidDiagonal(a, b) {
		return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && ( // dones't intersect other edges
		locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && ( // locally visible
		area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
		equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
	} // signed area of a triangle


	function area(p, q, r) {
		return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
	} // check if two points are equal


	function equals(p1, p2) {
		return p1.x === p2.x && p1.y === p2.y;
	} // check if two segments intersect


	function intersects(p1, q1, p2, q2) {
		const o1 = sign(area(p1, q1, p2));
		const o2 = sign(area(p1, q1, q2));
		const o3 = sign(area(p2, q2, p1));
		const o4 = sign(area(p2, q2, q1));
		if (o1 !== o2 && o3 !== o4) return true; // general case

		if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1

		if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1

		if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2

		if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

		return false;
	} // for collinear points p, q, r, check if point q lies on segment pr


	function onSegment(p, q, r) {
		return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
	}

	function sign(num) {
		return num > 0 ? 1 : num < 0 ? -1 : 0;
	} // check if a polygon diagonal intersects any polygon segments


	function intersectsPolygon(a, b) {
		let p = a;

		do {
			if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
			p = p.next;
		} while (p !== a);

		return false;
	} // check if a polygon diagonal is locally inside the polygon


	function locallyInside(a, b) {
		return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
	} // check if the middle point of a polygon diagonal is inside the polygon


	function middleInside(a, b) {
		let p = a,
				inside = false;
		const px = (a.x + b.x) / 2,
					py = (a.y + b.y) / 2;

		do {
			if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
			p = p.next;
		} while (p !== a);

		return inside;
	} // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring


	function splitPolygon(a, b) {
		const a2 = new Node(a.i, a.x, a.y),
					b2 = new Node(b.i, b.x, b.y),
					an = a.next,
					bp = b.prev;
		a.next = b;
		b.prev = a;
		a2.next = an;
		an.prev = a2;
		b2.next = a2;
		a2.prev = b2;
		bp.next = b2;
		b2.prev = bp;
		return b2;
	} // create a node and optionally link it with previous one (in a circular doubly linked list)


	function insertNode(i, x, y, last) {
		const p = new Node(i, x, y);

		if (!last) {
			p.prev = p;
			p.next = p;
		} else {
			p.next = last.next;
			p.prev = last;
			last.next.prev = p;
			last.next = p;
		}

		return p;
	}

	function removeNode(p) {
		p.next.prev = p.prev;
		p.prev.next = p.next;
		if (p.prevZ) p.prevZ.nextZ = p.nextZ;
		if (p.nextZ) p.nextZ.prevZ = p.prevZ;
	}

	function Node(i, x, y) {
		// vertex index in coordinates array
		this.i = i; // vertex coordinates

		this.x = x;
		this.y = y; // previous and next vertex nodes in a polygon ring

		this.prev = null;
		this.next = null; // z-order curve value

		this.z = null; // previous and next nodes in z-order

		this.prevZ = null;
		this.nextZ = null; // indicates whether this is a steiner point

		this.steiner = false;
	}

	function signedArea(data, start, end, dim) {
		let sum = 0;

		for (let i = start, j = end - dim; i < end; i += dim) {
			sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
			j = i;
		}

		return sum;
	}

	class ShapeUtils {
		// calculate area of the contour polygon
		static area(contour) {
			const n = contour.length;
			let a = 0.0;

			for (let p = n - 1, q = 0; q < n; p = q++) {
				a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
			}

			return a * 0.5;
		}

		static isClockWise(pts) {
			return ShapeUtils.area(pts) < 0;
		}

		static triangulateShape(contour, holes) {
			const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]

			const holeIndices = []; // array of hole indices

			const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

			removeDupEndPts(contour);
			addContour(vertices, contour); //

			let holeIndex = contour.length;
			holes.forEach(removeDupEndPts);

			for (let i = 0; i < holes.length; i++) {
				holeIndices.push(holeIndex);
				holeIndex += holes[i].length;
				addContour(vertices, holes[i]);
			} //


			const triangles = Earcut.triangulate(vertices, holeIndices); //

			for (let i = 0; i < triangles.length; i += 3) {
				faces.push(triangles.slice(i, i + 3));
			}

			return faces;
		}

	}

	function removeDupEndPts(points) {
		const l = points.length;

		if (l > 2 && points[l - 1].equals(points[0])) {
			points.pop();
		}
	}

	function addContour(vertices, contour) {
		for (let i = 0; i < contour.length; i++) {
			vertices.push(contour[i].x);
			vertices.push(contour[i].y);
		}
	}

	/**
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *	curveSegments: <int>, // number of points on the curves
	 *	steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *	depth: <float>, // Depth to extrude the shape
	 *
	 *	bevelEnabled: <bool>, // turn on bevel
	 *	bevelThickness: <float>, // how deep into the original shape bevel goes
	 *	bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
	 *	bevelOffset: <float>, // how far from shape outline does bevel start
	 *	bevelSegments: <int>, // number of bevel layers
	 *
	 *	extrudePath: <THREE.Curve> // curve to extrude shape along
	 *
	 *	UVGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 */

	class ExtrudeGeometry extends BufferGeometry {
		constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options = {}) {
			super();
			this.type = 'ExtrudeGeometry';
			this.parameters = {
				shapes: shapes,
				options: options
			};
			shapes = Array.isArray(shapes) ? shapes : [shapes];
			const scope = this;
			const verticesArray = [];
			const uvArray = [];

			for (let i = 0, l = shapes.length; i < l; i++) {
				const shape = shapes[i];
				addShape(shape);
			} // build geometry


			this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));
			this.computeVertexNormals(); // functions

			function addShape(shape) {
				const placeholder = []; // options

				const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
				const steps = options.steps !== undefined ? options.steps : 1;
				let depth = options.depth !== undefined ? options.depth : 1;
				let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
				let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;
				let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;
				let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
				let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
				const extrudePath = options.extrudePath;
				const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options

				if (options.amount !== undefined) {
					console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
					depth = options.amount;
				} //


				let extrudePts,
						extrudeByPath = false;
				let splineTube, binormal, normal, position2;

				if (extrudePath) {
					extrudePts = extrudePath.getSpacedPoints(steps);
					extrudeByPath = true;
					bevelEnabled = false; // bevels not supported for path extrusion
					// SETUP TNB variables
					// TODO1 - have a .isClosed in spline?

					splineTube = extrudePath.computeFrenetFrames(steps, false); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

					binormal = new Vector3();
					normal = new Vector3();
					position2 = new Vector3();
				} // Safeguards if bevels are not enabled


				if (!bevelEnabled) {
					bevelSegments = 0;
					bevelThickness = 0;
					bevelSize = 0;
					bevelOffset = 0;
				} // Variables initialization


				const shapePoints = shape.extractPoints(curveSegments);
				let vertices = shapePoints.shape;
				const holes = shapePoints.holes;
				const reverse = !ShapeUtils.isClockWise(vertices);

				if (reverse) {
					vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...

					for (let h = 0, hl = holes.length; h < hl; h++) {
						const ahole = holes[h];

						if (ShapeUtils.isClockWise(ahole)) {
							holes[h] = ahole.reverse();
						}
					}
				}

				const faces = ShapeUtils.triangulateShape(vertices, holes);
				/* Vertices */

				const contour = vertices; // vertices has all points but contour has only points of circumference

				for (let h = 0, hl = holes.length; h < hl; h++) {
					const ahole = holes[h];
					vertices = vertices.concat(ahole);
				}

				function scalePt2(pt, vec, size) {
					if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');
					return vec.clone().multiplyScalar(size).add(pt);
				}

				const vlen = vertices.length,
							flen = faces.length; // Find directions for point movement

				function getBevelVec(inPt, inPrev, inNext) {
					// computes for inPt the corresponding point inPt' on a new contour
					//	 shifted by 1 unit (length of normalized vector) to the left
					// if we walk along contour clockwise, this new contour is outside the old one
					//
					// inPt' is the intersection of the two lines parallel to the two
					//	adjacent edges of inPt at a distance of 1 unit on the left side.
					let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
					// good reading for geometry algorithms (here: line-line intersection)
					// http://geomalgorithms.com/a05-_intersect-1.html

					const v_prev_x = inPt.x - inPrev.x,
								v_prev_y = inPt.y - inPrev.y;
					const v_next_x = inNext.x - inPt.x,
								v_next_y = inNext.y - inPt.y;
					const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges

					const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;

					if (Math.abs(collinear0) > Number.EPSILON) {
						// not collinear
						// length of vectors for normalizing
						const v_prev_len = Math.sqrt(v_prev_lensq);
						const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left

						const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
						const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
						const ptNextShift_x = inNext.x - v_next_y / v_next_len;
						const ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point

						const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point

						v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
						v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don't normalize!, otherwise sharp corners become ugly
						//	but prevent crazy spikes

						const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;

						if (v_trans_lensq <= 2) {
							return new Vector2(v_trans_x, v_trans_y);
						} else {
							shrink_by = Math.sqrt(v_trans_lensq / 2);
						}
					} else {
						// handle special case of collinear edges
						let direction_eq = false; // assumes: opposite

						if (v_prev_x > Number.EPSILON) {
							if (v_next_x > Number.EPSILON) {
								direction_eq = true;
							}
						} else {
							if (v_prev_x < -Number.EPSILON) {
								if (v_next_x < -Number.EPSILON) {
									direction_eq = true;
								}
							} else {
								if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
									direction_eq = true;
								}
							}
						}

						if (direction_eq) {
							// console.log("Warning: lines are a straight sequence");
							v_trans_x = -v_prev_y;
							v_trans_y = v_prev_x;
							shrink_by = Math.sqrt(v_prev_lensq);
						} else {
							// console.log("Warning: lines are a straight spike");
							v_trans_x = v_prev_x;
							v_trans_y = v_prev_y;
							shrink_by = Math.sqrt(v_prev_lensq / 2);
						}
					}

					return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
				}

				const contourMovements = [];

				for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
					if (j === il) j = 0;
					if (k === il) k = 0; //	(j)---(i)---(k)
					// console.log('i,j,k', i, j , k)

					contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
				}

				const holesMovements = [];
				let oneHoleMovements,
						verticesMovements = contourMovements.concat();

				for (let h = 0, hl = holes.length; h < hl; h++) {
					const ahole = holes[h];
					oneHoleMovements = [];

					for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
						if (j === il) j = 0;
						if (k === il) k = 0; //	(j)---(i)---(k)

						oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
					}

					holesMovements.push(oneHoleMovements);
					verticesMovements = verticesMovements.concat(oneHoleMovements);
				} // Loop bevelSegments, 1 for the front, 1 for the back


				for (let b = 0; b < bevelSegments; b++) {
					//for ( b = bevelSegments; b > 0; b -- ) {
					const t = b / bevelSegments;
					const z = bevelThickness * Math.cos(t * Math.PI / 2);
					const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape

					for (let i = 0, il = contour.length; i < il; i++) {
						const vert = scalePt2(contour[i], contourMovements[i], bs);
						v(vert.x, vert.y, -z);
					} // expand holes


					for (let h = 0, hl = holes.length; h < hl; h++) {
						const ahole = holes[h];
						oneHoleMovements = holesMovements[h];

						for (let i = 0, il = ahole.length; i < il; i++) {
							const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
							v(vert.x, vert.y, -z);
						}
					}
				}

				const bs = bevelSize + bevelOffset; // Back facing vertices

				for (let i = 0; i < vlen; i++) {
					const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

					if (!extrudeByPath) {
						v(vert.x, vert.y, 0);
					} else {
						// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
						normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
						binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
						position2.copy(extrudePts[0]).add(normal).add(binormal);
						v(position2.x, position2.y, position2.z);
					}
				} // Add stepped vertices...
				// Including front facing vertices


				for (let s = 1; s <= steps; s++) {
					for (let i = 0; i < vlen; i++) {
						const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

						if (!extrudeByPath) {
							v(vert.x, vert.y, depth / steps * s);
						} else {
							// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
							normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
							binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
							position2.copy(extrudePts[s]).add(normal).add(binormal);
							v(position2.x, position2.y, position2.z);
						}
					}
				} // Add bevel segments planes
				//for ( b = 1; b <= bevelSegments; b ++ ) {


				for (let b = bevelSegments - 1; b >= 0; b--) {
					const t = b / bevelSegments;
					const z = bevelThickness * Math.cos(t * Math.PI / 2);
					const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape

					for (let i = 0, il = contour.length; i < il; i++) {
						const vert = scalePt2(contour[i], contourMovements[i], bs);
						v(vert.x, vert.y, depth + z);
					} // expand holes


					for (let h = 0, hl = holes.length; h < hl; h++) {
						const ahole = holes[h];
						oneHoleMovements = holesMovements[h];

						for (let i = 0, il = ahole.length; i < il; i++) {
							const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);

							if (!extrudeByPath) {
								v(vert.x, vert.y, depth + z);
							} else {
								v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
							}
						}
					}
				}
				/* Faces */
				// Top and bottom faces


				buildLidFaces(); // Sides faces

				buildSideFaces(); /////	Internal functions

				function buildLidFaces() {
					const start = verticesArray.length / 3;

					if (bevelEnabled) {
						let layer = 0; // steps + 1

						let offset = vlen * layer; // Bottom faces

						for (let i = 0; i < flen; i++) {
							const face = faces[i];
							f3(face[2] + offset, face[1] + offset, face[0] + offset);
						}

						layer = steps + bevelSegments * 2;
						offset = vlen * layer; // Top faces

						for (let i = 0; i < flen; i++) {
							const face = faces[i];
							f3(face[0] + offset, face[1] + offset, face[2] + offset);
						}
					} else {
						// Bottom faces
						for (let i = 0; i < flen; i++) {
							const face = faces[i];
							f3(face[2], face[1], face[0]);
						} // Top faces


						for (let i = 0; i < flen; i++) {
							const face = faces[i];
							f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
						}
					}

					scope.addGroup(start, verticesArray.length / 3 - start, 0);
				} // Create faces for the z-sides of the shape


				function buildSideFaces() {
					const start = verticesArray.length / 3;
					let layeroffset = 0;
					sidewalls(contour, layeroffset);
					layeroffset += contour.length;

					for (let h = 0, hl = holes.length; h < hl; h++) {
						const ahole = holes[h];
						sidewalls(ahole, layeroffset); //, true

						layeroffset += ahole.length;
					}

					scope.addGroup(start, verticesArray.length / 3 - start, 1);
				}

				function sidewalls(contour, layeroffset) {
					let i = contour.length;

					while (--i >= 0) {
						const j = i;
						let k = i - 1;
						if (k < 0) k = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length);

						for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
							const slen1 = vlen * s;
							const slen2 = vlen * (s + 1);
							const a = layeroffset + j + slen1,
										b = layeroffset + k + slen1,
										c = layeroffset + k + slen2,
										d = layeroffset + j + slen2;
							f4(a, b, c, d);
						}
					}
				}

				function v(x, y, z) {
					placeholder.push(x);
					placeholder.push(y);
					placeholder.push(z);
				}

				function f3(a, b, c) {
					addVertex(a);
					addVertex(b);
					addVertex(c);
					const nextIndex = verticesArray.length / 3;
					const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
					addUV(uvs[0]);
					addUV(uvs[1]);
					addUV(uvs[2]);
				}

				function f4(a, b, c, d) {
					addVertex(a);
					addVertex(b);
					addVertex(d);
					addVertex(b);
					addVertex(c);
					addVertex(d);
					const nextIndex = verticesArray.length / 3;
					const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
					addUV(uvs[0]);
					addUV(uvs[1]);
					addUV(uvs[3]);
					addUV(uvs[1]);
					addUV(uvs[2]);
					addUV(uvs[3]);
				}

				function addVertex(index) {
					verticesArray.push(placeholder[index * 3 + 0]);
					verticesArray.push(placeholder[index * 3 + 1]);
					verticesArray.push(placeholder[index * 3 + 2]);
				}

				function addUV(vector2) {
					uvArray.push(vector2.x);
					uvArray.push(vector2.y);
				}
			}
		}

		toJSON() {
			const data = super.toJSON();
			const shapes = this.parameters.shapes;
			const options = this.parameters.options;
			return toJSON$1(shapes, options, data);
		}

		static fromJSON(data, shapes) {
			const geometryShapes = [];

			for (let j = 0, jl = data.shapes.length; j < jl; j++) {
				const shape = shapes[data.shapes[j]];
				geometryShapes.push(shape);
			}

			const extrudePath = data.options.extrudePath;

			if (extrudePath !== undefined) {
				data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
			}

			return new ExtrudeGeometry(geometryShapes, data.options);
		}

	}

	const WorldUVGenerator = {
		generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {
			const a_x = vertices[indexA * 3];
			const a_y = vertices[indexA * 3 + 1];
			const b_x = vertices[indexB * 3];
			const b_y = vertices[indexB * 3 + 1];
			const c_x = vertices[indexC * 3];
			const c_y = vertices[indexC * 3 + 1];
			return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
		},
		generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {
			const a_x = vertices[indexA * 3];
			const a_y = vertices[indexA * 3 + 1];
			const a_z = vertices[indexA * 3 + 2];
			const b_x = vertices[indexB * 3];
			const b_y = vertices[indexB * 3 + 1];
			const b_z = vertices[indexB * 3 + 2];
			const c_x = vertices[indexC * 3];
			const c_y = vertices[indexC * 3 + 1];
			const c_z = vertices[indexC * 3 + 2];
			const d_x = vertices[indexD * 3];
			const d_y = vertices[indexD * 3 + 1];
			const d_z = vertices[indexD * 3 + 2];

			if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
				return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
			} else {
				return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
			}
		}
	};

	function toJSON$1(shapes, options, data) {
		data.shapes = [];

		if (Array.isArray(shapes)) {
			for (let i = 0, l = shapes.length; i < l; i++) {
				const shape = shapes[i];
				data.shapes.push(shape.uuid);
			}
		} else {
			data.shapes.push(shapes.uuid);
		}

		if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
		return data;
	}

	class IcosahedronGeometry extends PolyhedronGeometry {
		constructor(radius = 1, detail = 0) {
			const t = (1 + Math.sqrt(5)) / 2;
			const vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
			const indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
			super(vertices, indices, radius, detail);
			this.type = 'IcosahedronGeometry';
			this.parameters = {
				radius: radius,
				detail: detail
			};
		}

		static fromJSON(data) {
			return new IcosahedronGeometry(data.radius, data.detail);
		}

	}

	class LatheGeometry extends BufferGeometry {
		constructor(points = [new Vector2(0, 0.5), new Vector2(0.5, 0), new Vector2(0, -0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
			super();
			this.type = 'LatheGeometry';
			this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};
			segments = Math.floor(segments); // clamp phiLength so it's in range of [ 0, 2PI ]

			phiLength = clamp(phiLength, 0, Math.PI * 2); // buffers

			const indices = [];
			const vertices = [];
			const uvs = []; // helper variables

			const inverseSegments = 1.0 / segments;
			const vertex = new Vector3();
			const uv = new Vector2(); // generate vertices and uvs

			for (let i = 0; i <= segments; i++) {
				const phi = phiStart + i * inverseSegments * phiLength;
				const sin = Math.sin(phi);
				const cos = Math.cos(phi);

				for (let j = 0; j <= points.length - 1; j++) {
					// vertex
					vertex.x = points[j].x * sin;
					vertex.y = points[j].y;
					vertex.z = points[j].x * cos;
					vertices.push(vertex.x, vertex.y, vertex.z); // uv

					uv.x = i / segments;
					uv.y = j / (points.length - 1);
					uvs.push(uv.x, uv.y);
				}
			} // indices


			for (let i = 0; i < segments; i++) {
				for (let j = 0; j < points.length - 1; j++) {
					const base = j + i * points.length;
					const a = base;
					const b = base + points.length;
					const c = base + points.length + 1;
					const d = base + 1; // faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // generate normals

			this.computeVertexNormals(); // if the geometry is closed, we need to average the normals along the seam.
			// because the corresponding vertices are identical (but still have different UVs).

			if (phiLength === Math.PI * 2) {
				const normals = this.attributes.normal.array;
				const n1 = new Vector3();
				const n2 = new Vector3();
				const n = new Vector3(); // this is the buffer offset for the last line of vertices

				const base = segments * points.length * 3;

				for (let i = 0, j = 0; i < points.length; i++, j += 3) {
					// select the normal of the vertex in the first line
					n1.x = normals[j + 0];
					n1.y = normals[j + 1];
					n1.z = normals[j + 2]; // select the normal of the vertex in the last line

					n2.x = normals[base + j + 0];
					n2.y = normals[base + j + 1];
					n2.z = normals[base + j + 2]; // average normals

					n.addVectors(n1, n2).normalize(); // assign the new values to both normals

					normals[j + 0] = normals[base + j + 0] = n.x;
					normals[j + 1] = normals[base + j + 1] = n.y;
					normals[j + 2] = normals[base + j + 2] = n.z;
				}
			}
		}

		static fromJSON(data) {
			return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
		}

	}

	class OctahedronGeometry extends PolyhedronGeometry {
		constructor(radius = 1, detail = 0) {
			const vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
			const indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
			super(vertices, indices, radius, detail);
			this.type = 'OctahedronGeometry';
			this.parameters = {
				radius: radius,
				detail: detail
			};
		}

		static fromJSON(data) {
			return new OctahedronGeometry(data.radius, data.detail);
		}

	}

	class RingGeometry extends BufferGeometry {
		constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
			super();
			this.type = 'RingGeometry';
			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			thetaSegments = Math.max(3, thetaSegments);
			phiSegments = Math.max(1, phiSegments); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // some helper variables

			let radius = innerRadius;
			const radiusStep = (outerRadius - innerRadius) / phiSegments;
			const vertex = new Vector3();
			const uv = new Vector2(); // generate vertices, normals and uvs

			for (let j = 0; j <= phiSegments; j++) {
				for (let i = 0; i <= thetaSegments; i++) {
					// values are generate from the inside of the ring to the outside
					const segment = thetaStart + i / thetaSegments * thetaLength; // vertex

					vertex.x = radius * Math.cos(segment);
					vertex.y = radius * Math.sin(segment);
					vertices.push(vertex.x, vertex.y, vertex.z); // normal

					normals.push(0, 0, 1); // uv

					uv.x = (vertex.x / outerRadius + 1) / 2;
					uv.y = (vertex.y / outerRadius + 1) / 2;
					uvs.push(uv.x, uv.y);
				} // increase the radius for next row of vertices


				radius += radiusStep;
			} // indices


			for (let j = 0; j < phiSegments; j++) {
				const thetaSegmentLevel = j * (thetaSegments + 1);

				for (let i = 0; i < thetaSegments; i++) {
					const segment = i + thetaSegmentLevel;
					const a = segment;
					const b = segment + thetaSegments + 1;
					const c = segment + thetaSegments + 2;
					const d = segment + 1; // faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}

		static fromJSON(data) {
			return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
		}

	}

	class ShapeGeometry extends BufferGeometry {
		constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
			super();
			this.type = 'ShapeGeometry';
			this.parameters = {
				shapes: shapes,
				curveSegments: curveSegments
			}; // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // helper variables

			let groupStart = 0;
			let groupCount = 0; // allow single and array values for "shapes" parameter

			if (Array.isArray(shapes) === false) {
				addShape(shapes);
			} else {
				for (let i = 0; i < shapes.length; i++) {
					addShape(shapes[i]);
					this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support

					groupStart += groupCount;
					groupCount = 0;
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // helper functions

			function addShape(shape) {
				const indexOffset = vertices.length / 3;
				const points = shape.extractPoints(curveSegments);
				let shapeVertices = points.shape;
				const shapeHoles = points.holes; // check direction of vertices

				if (ShapeUtils.isClockWise(shapeVertices) === false) {
					shapeVertices = shapeVertices.reverse();
				}

				for (let i = 0, l = shapeHoles.length; i < l; i++) {
					const shapeHole = shapeHoles[i];

					if (ShapeUtils.isClockWise(shapeHole) === true) {
						shapeHoles[i] = shapeHole.reverse();
					}
				}

				const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array

				for (let i = 0, l = shapeHoles.length; i < l; i++) {
					const shapeHole = shapeHoles[i];
					shapeVertices = shapeVertices.concat(shapeHole);
				} // vertices, normals, uvs


				for (let i = 0, l = shapeVertices.length; i < l; i++) {
					const vertex = shapeVertices[i];
					vertices.push(vertex.x, vertex.y, 0);
					normals.push(0, 0, 1);
					uvs.push(vertex.x, vertex.y); // world uvs
				} // incides


				for (let i = 0, l = faces.length; i < l; i++) {
					const face = faces[i];
					const a = face[0] + indexOffset;
					const b = face[1] + indexOffset;
					const c = face[2] + indexOffset;
					indices.push(a, b, c);
					groupCount += 3;
				}
			}
		}

		toJSON() {
			const data = super.toJSON();
			const shapes = this.parameters.shapes;
			return toJSON(shapes, data);
		}

		static fromJSON(data, shapes) {
			const geometryShapes = [];

			for (let j = 0, jl = data.shapes.length; j < jl; j++) {
				const shape = shapes[data.shapes[j]];
				geometryShapes.push(shape);
			}

			return new ShapeGeometry(geometryShapes, data.curveSegments);
		}

	}

	function toJSON(shapes, data) {
		data.shapes = [];

		if (Array.isArray(shapes)) {
			for (let i = 0, l = shapes.length; i < l; i++) {
				const shape = shapes[i];
				data.shapes.push(shape.uuid);
			}
		} else {
			data.shapes.push(shapes.uuid);
		}

		return data;
	}

	class SphereGeometry extends BufferGeometry {
		constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
			super();
			this.type = 'SphereGeometry';
			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			widthSegments = Math.max(3, Math.floor(widthSegments));
			heightSegments = Math.max(2, Math.floor(heightSegments));
			const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
			let index = 0;
			const grid = [];
			const vertex = new Vector3();
			const normal = new Vector3(); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // generate vertices, normals and uvs

			for (let iy = 0; iy <= heightSegments; iy++) {
				const verticesRow = [];
				const v = iy / heightSegments; // special case for the poles

				let uOffset = 0;

				if (iy == 0 && thetaStart == 0) {
					uOffset = 0.5 / widthSegments;
				} else if (iy == heightSegments && thetaEnd == Math.PI) {
					uOffset = -0.5 / widthSegments;
				}

				for (let ix = 0; ix <= widthSegments; ix++) {
					const u = ix / widthSegments; // vertex

					vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
					vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
					vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
					vertices.push(vertex.x, vertex.y, vertex.z); // normal

					normal.copy(vertex).normalize();
					normals.push(normal.x, normal.y, normal.z); // uv

					uvs.push(u + uOffset, 1 - v);
					verticesRow.push(index++);
				}

				grid.push(verticesRow);
			} // indices


			for (let iy = 0; iy < heightSegments; iy++) {
				for (let ix = 0; ix < widthSegments; ix++) {
					const a = grid[iy][ix + 1];
					const b = grid[iy][ix];
					const c = grid[iy + 1][ix];
					const d = grid[iy + 1][ix + 1];
					if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
					if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}

		static fromJSON(data) {
			return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
		}

	}

	class TetrahedronGeometry extends PolyhedronGeometry {
		constructor(radius = 1, detail = 0) {
			const vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
			const indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
			super(vertices, indices, radius, detail);
			this.type = 'TetrahedronGeometry';
			this.parameters = {
				radius: radius,
				detail: detail
			};
		}

		static fromJSON(data) {
			return new TetrahedronGeometry(data.radius, data.detail);
		}

	}

	class TorusGeometry extends BufferGeometry {
		constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {
			super();
			this.type = 'TorusGeometry';
			this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};
			radialSegments = Math.floor(radialSegments);
			tubularSegments = Math.floor(tubularSegments); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // helper variables

			const center = new Vector3();
			const vertex = new Vector3();
			const normal = new Vector3(); // generate vertices, normals and uvs

			for (let j = 0; j <= radialSegments; j++) {
				for (let i = 0; i <= tubularSegments; i++) {
					const u = i / tubularSegments * arc;
					const v = j / radialSegments * Math.PI * 2; // vertex

					vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
					vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
					vertex.z = tube * Math.sin(v);
					vertices.push(vertex.x, vertex.y, vertex.z); // normal

					center.x = radius * Math.cos(u);
					center.y = radius * Math.sin(u);
					normal.subVectors(vertex, center).normalize();
					normals.push(normal.x, normal.y, normal.z); // uv

					uvs.push(i / tubularSegments);
					uvs.push(j / radialSegments);
				}
			} // generate indices


			for (let j = 1; j <= radialSegments; j++) {
				for (let i = 1; i <= tubularSegments; i++) {
					// indices
					const a = (tubularSegments + 1) * j + i - 1;
					const b = (tubularSegments + 1) * (j - 1) + i - 1;
					const c = (tubularSegments + 1) * (j - 1) + i;
					const d = (tubularSegments + 1) * j + i; // faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}

		static fromJSON(data) {
			return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
		}

	}

	class TorusKnotGeometry extends BufferGeometry {
		constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
			super();
			this.type = 'TorusKnotGeometry';
			this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};
			tubularSegments = Math.floor(tubularSegments);
			radialSegments = Math.floor(radialSegments); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // helper variables

			const vertex = new Vector3();
			const normal = new Vector3();
			const P1 = new Vector3();
			const P2 = new Vector3();
			const B = new Vector3();
			const T = new Vector3();
			const N = new Vector3(); // generate vertices, normals and uvs

			for (let i = 0; i <= tubularSegments; ++i) {
				// the radian "u" is used to calculate the position on the torus curve of the current tubular segement
				const u = i / tubularSegments * p * Math.PI * 2; // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
				// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

				calculatePositionOnCurve(u, p, q, radius, P1);
				calculatePositionOnCurve(u + 0.01, p, q, radius, P2); // calculate orthonormal basis

				T.subVectors(P2, P1);
				N.addVectors(P2, P1);
				B.crossVectors(T, N);
				N.crossVectors(B, T); // normalize B, N. T can be ignored, we don't use it

				B.normalize();
				N.normalize();

				for (let j = 0; j <= radialSegments; ++j) {
					// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
					// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
					const v = j / radialSegments * Math.PI * 2;
					const cx = -tube * Math.cos(v);
					const cy = tube * Math.sin(v); // now calculate the final vertex position.
					// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

					vertex.x = P1.x + (cx * N.x + cy * B.x);
					vertex.y = P1.y + (cx * N.y + cy * B.y);
					vertex.z = P1.z + (cx * N.z + cy * B.z);
					vertices.push(vertex.x, vertex.y, vertex.z); // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

					normal.subVectors(vertex, P1).normalize();
					normals.push(normal.x, normal.y, normal.z); // uv

					uvs.push(i / tubularSegments);
					uvs.push(j / radialSegments);
				}
			} // generate indices


			for (let j = 1; j <= tubularSegments; j++) {
				for (let i = 1; i <= radialSegments; i++) {
					// indices
					const a = (radialSegments + 1) * (j - 1) + (i - 1);
					const b = (radialSegments + 1) * j + (i - 1);
					const c = (radialSegments + 1) * j + i;
					const d = (radialSegments + 1) * (j - 1) + i; // faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // this function calculates the current position on the torus curve

			function calculatePositionOnCurve(u, p, q, radius, position) {
				const cu = Math.cos(u);
				const su = Math.sin(u);
				const quOverP = q / p * u;
				const cs = Math.cos(quOverP);
				position.x = radius * (2 + cs) * 0.5 * cu;
				position.y = radius * (2 + cs) * su * 0.5;
				position.z = radius * Math.sin(quOverP) * 0.5;
			}
		}

		static fromJSON(data) {
			return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
		}

	}

	class TubeGeometry extends BufferGeometry {
		constructor(path = new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
			super();
			this.type = 'TubeGeometry';
			this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};
			const frames = path.computeFrenetFrames(tubularSegments, closed); // expose internals

			this.tangents = frames.tangents;
			this.normals = frames.normals;
			this.binormals = frames.binormals; // helper variables

			const vertex = new Vector3();
			const normal = new Vector3();
			const uv = new Vector2();
			let P = new Vector3(); // buffer

			const vertices = [];
			const normals = [];
			const uvs = [];
			const indices = []; // create buffer data

			generateBufferData(); // build geometry

			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // functions

			function generateBufferData() {
				for (let i = 0; i < tubularSegments; i++) {
					generateSegment(i);
				} // if the geometry is not closed, generate the last row of vertices and normals
				// at the regular position on the given path
				//
				// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)


				generateSegment(closed === false ? tubularSegments : 0); // uvs are generated in a separate function.
				// this makes it easy compute correct values for closed geometries

				generateUVs(); // finally create faces

				generateIndices();
			}

			function generateSegment(i) {
				// we use getPointAt to sample evenly distributed points from the given path
				P = path.getPointAt(i / tubularSegments, P); // retrieve corresponding normal and binormal

				const N = frames.normals[i];
				const B = frames.binormals[i]; // generate normals and vertices for the current segment

				for (let j = 0; j <= radialSegments; j++) {
					const v = j / radialSegments * Math.PI * 2;
					const sin = Math.sin(v);
					const cos = -Math.cos(v); // normal

					normal.x = cos * N.x + sin * B.x;
					normal.y = cos * N.y + sin * B.y;
					normal.z = cos * N.z + sin * B.z;
					normal.normalize();
					normals.push(normal.x, normal.y, normal.z); // vertex

					vertex.x = P.x + radius * normal.x;
					vertex.y = P.y + radius * normal.y;
					vertex.z = P.z + radius * normal.z;
					vertices.push(vertex.x, vertex.y, vertex.z);
				}
			}

			function generateIndices() {
				for (let j = 1; j <= tubularSegments; j++) {
					for (let i = 1; i <= radialSegments; i++) {
						const a = (radialSegments + 1) * (j - 1) + (i - 1);
						const b = (radialSegments + 1) * j + (i - 1);
						const c = (radialSegments + 1) * j + i;
						const d = (radialSegments + 1) * (j - 1) + i; // faces

						indices.push(a, b, d);
						indices.push(b, c, d);
					}
				}
			}

			function generateUVs() {
				for (let i = 0; i <= tubularSegments; i++) {
					for (let j = 0; j <= radialSegments; j++) {
						uv.x = i / tubularSegments;
						uv.y = j / radialSegments;
						uvs.push(uv.x, uv.y);
					}
				}
			}
		}

		toJSON() {
			const data = super.toJSON();
			data.path = this.parameters.path.toJSON();
			return data;
		}

		static fromJSON(data) {
			// This only works for built-in curves (e.g. CatmullRomCurve3).
			// User defined curves or instances of CurvePath will not be deserialized.
			return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
		}

	}

	class WireframeGeometry extends BufferGeometry {
		constructor(geometry = null) {
			super();
			this.type = 'WireframeGeometry';
			this.parameters = {
				geometry: geometry
			};

			if (geometry !== null) {
				// buffer
				const vertices = [];
				const edges = new Set(); // helper variables

				const start = new Vector3();
				const end = new Vector3();

				if (geometry.index !== null) {
					// indexed BufferGeometry
					const position = geometry.attributes.position;
					const indices = geometry.index;
					let groups = geometry.groups;

					if (groups.length === 0) {
						groups = [{
							start: 0,
							count: indices.count,
							materialIndex: 0
						}];
					} // create a data structure that contains all eges without duplicates


					for (let o = 0, ol = groups.length; o < ol; ++o) {
						const group = groups[o];
						const groupStart = group.start;
						const groupCount = group.count;

						for (let i = groupStart, l = groupStart + groupCount; i < l; i += 3) {
							for (let j = 0; j < 3; j++) {
								const index1 = indices.getX(i + j);
								const index2 = indices.getX(i + (j + 1) % 3);
								start.fromBufferAttribute(position, index1);
								end.fromBufferAttribute(position, index2);

								if (isUniqueEdge(start, end, edges) === true) {
									vertices.push(start.x, start.y, start.z);
									vertices.push(end.x, end.y, end.z);
								}
							}
						}
					}
				} else {
					// non-indexed BufferGeometry
					const position = geometry.attributes.position;

					for (let i = 0, l = position.count / 3; i < l; i++) {
						for (let j = 0; j < 3; j++) {
							// three edges per triangle, an edge is represented as (index1, index2)
							// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
							const index1 = 3 * i + j;
							const index2 = 3 * i + (j + 1) % 3;
							start.fromBufferAttribute(position, index1);
							end.fromBufferAttribute(position, index2);

							if (isUniqueEdge(start, end, edges) === true) {
								vertices.push(start.x, start.y, start.z);
								vertices.push(end.x, end.y, end.z);
							}
						}
					}
				} // build geometry


				this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			}
		}

	}

	function isUniqueEdge(start, end, edges) {
		const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
		const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge

		if (edges.has(hash1) === true || edges.has(hash2) === true) {
			return false;
		} else {
			edges.add(hash1, hash2);
			return true;
		}
	}

	var Geometries = /*#__PURE__*/Object.freeze({
		__proto__: null,
		BoxGeometry: BoxGeometry,
		BoxBufferGeometry: BoxGeometry,
		CircleGeometry: CircleGeometry,
		CircleBufferGeometry: CircleGeometry,
		ConeGeometry: ConeGeometry,
		ConeBufferGeometry: ConeGeometry,
		CylinderGeometry: CylinderGeometry,
		CylinderBufferGeometry: CylinderGeometry,
		DodecahedronGeometry: DodecahedronGeometry,
		DodecahedronBufferGeometry: DodecahedronGeometry,
		EdgesGeometry: EdgesGeometry,
		ExtrudeGeometry: ExtrudeGeometry,
		ExtrudeBufferGeometry: ExtrudeGeometry,
		IcosahedronGeometry: IcosahedronGeometry,
		IcosahedronBufferGeometry: IcosahedronGeometry,
		LatheGeometry: LatheGeometry,
		LatheBufferGeometry: LatheGeometry,
		OctahedronGeometry: OctahedronGeometry,
		OctahedronBufferGeometry: OctahedronGeometry,
		PlaneGeometry: PlaneGeometry,
		PlaneBufferGeometry: PlaneGeometry,
		PolyhedronGeometry: PolyhedronGeometry,
		PolyhedronBufferGeometry: PolyhedronGeometry,
		RingGeometry: RingGeometry,
		RingBufferGeometry: RingGeometry,
		ShapeGeometry: ShapeGeometry,
		ShapeBufferGeometry: ShapeGeometry,
		SphereGeometry: SphereGeometry,
		SphereBufferGeometry: SphereGeometry,
		TetrahedronGeometry: TetrahedronGeometry,
		TetrahedronBufferGeometry: TetrahedronGeometry,
		TorusGeometry: TorusGeometry,
		TorusBufferGeometry: TorusGeometry,
		TorusKnotGeometry: TorusKnotGeometry,
		TorusKnotBufferGeometry: TorusKnotGeometry,
		TubeGeometry: TubeGeometry,
		TubeBufferGeometry: TubeGeometry,
		WireframeGeometry: WireframeGeometry
	});

	/**
	 * parameters = {
	 *	color: <THREE.Color>
	 * }
	 */

	class ShadowMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'ShadowMaterial';
			this.color = new Color(0x000000);
			this.transparent = true;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			return this;
		}

	}

	ShadowMaterial.prototype.isShadowMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	roughness: <float>,
	 *	metalness: <float>,
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	roughnessMap: new THREE.Texture( <Image> ),
	 *
	 *	metalnessMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	envMapIntensity: <float>
	 *
	 *	refractionRatio: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	flatShading: <bool>
	 * }
	 */

	class MeshStandardMaterial extends Material {
		constructor(parameters) {
			super();
			this.defines = {
				'STANDARD': ''
			};
			this.type = 'MeshStandardMaterial';
			this.color = new Color(0xffffff); // diffuse

			this.roughness = 1.0;
			this.metalness = 0.0;
			this.map = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.emissive = new Color(0x000000);
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.roughnessMap = null;
			this.metalnessMap = null;
			this.alphaMap = null;
			this.envMap = null;
			this.envMapIntensity = 1.0;
			this.refractionRatio = 0.98;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.flatShading = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.defines = {
				'STANDARD': ''
			};
			this.color.copy(source.color);
			this.roughness = source.roughness;
			this.metalness = source.metalness;
			this.map = source.map;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.emissive.copy(source.emissive);
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.roughnessMap = source.roughnessMap;
			this.metalnessMap = source.metalnessMap;
			this.alphaMap = source.alphaMap;
			this.envMap = source.envMap;
			this.envMapIntensity = source.envMapIntensity;
			this.refractionRatio = source.refractionRatio;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			this.flatShading = source.flatShading;
			return this;
		}

	}

	MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

	/**
	 * parameters = {
	 *	clearcoat: <float>,
	 *	clearcoatMap: new THREE.Texture( <Image> ),
	 *	clearcoatRoughness: <float>,
	 *	clearcoatRoughnessMap: new THREE.Texture( <Image> ),
	 *	clearcoatNormalScale: <Vector2>,
	 *	clearcoatNormalMap: new THREE.Texture( <Image> ),
	 *
	 *	ior: <float>,
	 *	reflectivity: <float>,
	 *
	 *	sheen: <float>,
	 *	sheenColor: <Color>,
	 *	sheenColorMap: new THREE.Texture( <Image> ),
	 *	sheenRoughness: <float>,
	 *	sheenRoughnessMap: new THREE.Texture( <Image> ),
	 *
	 *	transmission: <float>,
	 *	transmissionMap: new THREE.Texture( <Image> ),
	 *
	 *	thickness: <float>,
	 *	thicknessMap: new THREE.Texture( <Image> ),
	 *	attenuationDistance: <float>,
	 *	attenuationColor: <Color>,
	 *
	 *	specularIntensity: <float>,
	 *	specularIntensityMap: new THREE.Texture( <Image> ),
	 *	specularColor: <Color>,
	 *	specularColorMap: new THREE.Texture( <Image> )
	 * }
	 */

	class MeshPhysicalMaterial extends MeshStandardMaterial {
		constructor(parameters) {
			super();
			this.defines = {
				'STANDARD': '',
				'PHYSICAL': ''
			};
			this.type = 'MeshPhysicalMaterial';
			this.clearcoatMap = null;
			this.clearcoatRoughness = 0.0;
			this.clearcoatRoughnessMap = null;
			this.clearcoatNormalScale = new Vector2(1, 1);
			this.clearcoatNormalMap = null;
			this.ior = 1.5;
			Object.defineProperty(this, 'reflectivity', {
				get: function () {
					return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
				},
				set: function (reflectivity) {
					this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
				}
			});
			this.sheenColor = new Color(0x000000);
			this.sheenColorMap = null;
			this.sheenRoughness = 1.0;
			this.sheenRoughnessMap = null;
			this.transmissionMap = null;
			this.thickness = 0;
			this.thicknessMap = null;
			this.attenuationDistance = 0.0;
			this.attenuationColor = new Color(1, 1, 1);
			this.specularIntensity = 1.0;
			this.specularIntensityMap = null;
			this.specularColor = new Color(1, 1, 1);
			this.specularColorMap = null;
			this._sheen = 0.0;
			this._clearcoat = 0;
			this._transmission = 0;
			this.setValues(parameters);
		}

		get sheen() {
			return this._sheen;
		}

		set sheen(value) {
			if (this._sheen > 0 !== value > 0) {
				this.version++;
			}

			this._sheen = value;
		}

		get clearcoat() {
			return this._clearcoat;
		}

		set clearcoat(value) {
			if (this._clearcoat > 0 !== value > 0) {
				this.version++;
			}

			this._clearcoat = value;
		}

		get transmission() {
			return this._transmission;
		}

		set transmission(value) {
			if (this._transmission > 0 !== value > 0) {
				this.version++;
			}

			this._transmission = value;
		}

		copy(source) {
			super.copy(source);
			this.defines = {
				'STANDARD': '',
				'PHYSICAL': ''
			};
			this.clearcoat = source.clearcoat;
			this.clearcoatMap = source.clearcoatMap;
			this.clearcoatRoughness = source.clearcoatRoughness;
			this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
			this.clearcoatNormalMap = source.clearcoatNormalMap;
			this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
			this.ior = source.ior;
			this.sheen = source.sheen;
			this.sheenColor.copy(source.sheenColor);
			this.sheenColorMap = source.sheenColorMap;
			this.sheenRoughness = source.sheenRoughness;
			this.sheenRoughnessMap = source.sheenRoughnessMap;
			this.transmission = source.transmission;
			this.transmissionMap = source.transmissionMap;
			this.thickness = source.thickness;
			this.thicknessMap = source.thicknessMap;
			this.attenuationDistance = source.attenuationDistance;
			this.attenuationColor.copy(source.attenuationColor);
			this.specularIntensity = source.specularIntensity;
			this.specularIntensityMap = source.specularIntensityMap;
			this.specularColor.copy(source.specularColor);
			this.specularColorMap = source.specularColorMap;
			return this;
		}

	}

	MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	specular: <hex>,
	 *	shininess: <float>,
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	specularMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	combine: THREE.MultiplyOperation,
	 *	reflectivity: <float>,
	 *	refractionRatio: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	flatShading: <bool>
	 * }
	 */

	class MeshPhongMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'MeshPhongMaterial';
			this.color = new Color(0xffffff); // diffuse

			this.specular = new Color(0x111111);
			this.shininess = 30;
			this.map = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.emissive = new Color(0x000000);
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.specularMap = null;
			this.alphaMap = null;
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.flatShading = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.specular.copy(source.specular);
			this.shininess = source.shininess;
			this.map = source.map;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.emissive.copy(source.emissive);
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.specularMap = source.specularMap;
			this.alphaMap = source.alphaMap;
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			this.flatShading = source.flatShading;
			return this;
		}

	}

	MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *	gradientMap: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 * }
	 */

	class MeshToonMaterial extends Material {
		constructor(parameters) {
			super();
			this.defines = {
				'TOON': ''
			};
			this.type = 'MeshToonMaterial';
			this.color = new Color(0xffffff);
			this.map = null;
			this.gradientMap = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.emissive = new Color(0x000000);
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.alphaMap = null;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.gradientMap = source.gradientMap;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.emissive.copy(source.emissive);
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.alphaMap = source.alphaMap;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			return this;
		}

	}

	MeshToonMaterial.prototype.isMeshToonMaterial = true;

	/**
	 * parameters = {
	 *	opacity: <float>,
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>
	 *
	 *	flatShading: <bool>
	 * }
	 */

	class MeshNormalMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'MeshNormalMaterial';
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.fog = false;
			this.flatShading = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.flatShading = source.flatShading;
			return this;
		}

	}

	MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	specularMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	combine: THREE.Multiply,
	 *	reflectivity: <float>,
	 *	refractionRatio: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 * }
	 */

	class MeshLambertMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'MeshLambertMaterial';
			this.color = new Color(0xffffff); // diffuse

			this.map = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.emissive = new Color(0x000000);
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
			this.specularMap = null;
			this.alphaMap = null;
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.emissive.copy(source.emissive);
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
			this.specularMap = source.specularMap;
			this.alphaMap = source.alphaMap;
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			return this;
		}

	}

	MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	matcap: new THREE.Texture( <Image> ),
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	flatShading: <bool>
	 * }
	 */

	class MeshMatcapMaterial extends Material {
		constructor(parameters) {
			super();
			this.defines = {
				'MATCAP': ''
			};
			this.type = 'MeshMatcapMaterial';
			this.color = new Color(0xffffff); // diffuse

			this.matcap = null;
			this.map = null;
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.alphaMap = null;
			this.flatShading = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.defines = {
				'MATCAP': ''
			};
			this.color.copy(source.color);
			this.matcap = source.matcap;
			this.map = source.map;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.alphaMap = source.alphaMap;
			this.flatShading = source.flatShading;
			return this;
		}

	}

	MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	linewidth: <float>,
	 *
	 *	scale: <float>,
	 *	dashSize: <float>,
	 *	gapSize: <float>
	 * }
	 */

	class LineDashedMaterial extends LineBasicMaterial {
		constructor(parameters) {
			super();
			this.type = 'LineDashedMaterial';
			this.scale = 1;
			this.dashSize = 3;
			this.gapSize = 1;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.scale = source.scale;
			this.dashSize = source.dashSize;
			this.gapSize = source.gapSize;
			return this;
		}

	}

	LineDashedMaterial.prototype.isLineDashedMaterial = true;

	var Materials = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ShadowMaterial: ShadowMaterial,
		SpriteMaterial: SpriteMaterial,
		RawShaderMaterial: RawShaderMaterial,
		ShaderMaterial: ShaderMaterial,
		PointsMaterial: PointsMaterial,
		MeshPhysicalMaterial: MeshPhysicalMaterial,
		MeshStandardMaterial: MeshStandardMaterial,
		MeshPhongMaterial: MeshPhongMaterial,
		MeshToonMaterial: MeshToonMaterial,
		MeshNormalMaterial: MeshNormalMaterial,
		MeshLambertMaterial: MeshLambertMaterial,
		MeshDepthMaterial: MeshDepthMaterial,
		MeshDistanceMaterial: MeshDistanceMaterial,
		MeshBasicMaterial: MeshBasicMaterial,
		MeshMatcapMaterial: MeshMatcapMaterial,
		LineDashedMaterial: LineDashedMaterial,
		LineBasicMaterial: LineBasicMaterial,
		Material: Material
	});

	const AnimationUtils = {
		// same as Array.prototype.slice, but also works on typed arrays
		arraySlice: function (array, from, to) {
			if (AnimationUtils.isTypedArray(array)) {
				// in ios9 array.subarray(from, undefined) will return empty array
				// but array.subarray(from) or array.subarray(from, len) is correct
				return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
			}

			return array.slice(from, to);
		},
		// converts an array to a specific type
		convertArray: function (array, type, forceClone) {
			if (!array || // let 'undefined' and 'null' pass
			!forceClone && array.constructor === type) return array;

			if (typeof type.BYTES_PER_ELEMENT === 'number') {
				return new type(array); // create typed array
			}

			return Array.prototype.slice.call(array); // create Array
		},
		isTypedArray: function (object) {
			return ArrayBuffer.isView(object) && !(object instanceof DataView);
		},
		// returns an array by which times and values can be sorted
		getKeyframeOrder: function (times) {
			function compareTime(i, j) {
				return times[i] - times[j];
			}

			const n = times.length;
			const result = new Array(n);

			for (let i = 0; i !== n; ++i) result[i] = i;

			result.sort(compareTime);
			return result;
		},
		// uses the array previously returned by 'getKeyframeOrder' to sort data
		sortedArray: function (values, stride, order) {
			const nValues = values.length;
			const result = new values.constructor(nValues);

			for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
				const srcOffset = order[i] * stride;

				for (let j = 0; j !== stride; ++j) {
					result[dstOffset++] = values[srcOffset + j];
				}
			}

			return result;
		},
		// function for parsing AOS keyframe formats
		flattenJSON: function (jsonKeys, times, values, valuePropertyName) {
			let i = 1,
					key = jsonKeys[0];

			while (key !== undefined && key[valuePropertyName] === undefined) {
				key = jsonKeys[i++];
			}

			if (key === undefined) return; // no data

			let value = key[valuePropertyName];
			if (value === undefined) return; // no data

			if (Array.isArray(value)) {
				do {
					value = key[valuePropertyName];

					if (value !== undefined) {
						times.push(key.time);
						values.push.apply(values, value); // push all elements
					}

					key = jsonKeys[i++];
				} while (key !== undefined);
			} else if (value.toArray !== undefined) {
				// ...assume THREE.Math-ish
				do {
					value = key[valuePropertyName];

					if (value !== undefined) {
						times.push(key.time);
						value.toArray(values, values.length);
					}

					key = jsonKeys[i++];
				} while (key !== undefined);
			} else {
				// otherwise push as-is
				do {
					value = key[valuePropertyName];

					if (value !== undefined) {
						times.push(key.time);
						values.push(value);
					}

					key = jsonKeys[i++];
				} while (key !== undefined);
			}
		},
		subclip: function (sourceClip, name, startFrame, endFrame, fps = 30) {
			const clip = sourceClip.clone();
			clip.name = name;
			const tracks = [];

			for (let i = 0; i < clip.tracks.length; ++i) {
				const track = clip.tracks[i];
				const valueSize = track.getValueSize();
				const times = [];
				const values = [];

				for (let j = 0; j < track.times.length; ++j) {
					const frame = track.times[j] * fps;
					if (frame < startFrame || frame >= endFrame) continue;
					times.push(track.times[j]);

					for (let k = 0; k < valueSize; ++k) {
						values.push(track.values[j * valueSize + k]);
					}
				}

				if (times.length === 0) continue;
				track.times = AnimationUtils.convertArray(times, track.times.constructor);
				track.values = AnimationUtils.convertArray(values, track.values.constructor);
				tracks.push(track);
			}

			clip.tracks = tracks; // find minimum .times value across all tracks in the trimmed clip

			let minStartTime = Infinity;

			for (let i = 0; i < clip.tracks.length; ++i) {
				if (minStartTime > clip.tracks[i].times[0]) {
					minStartTime = clip.tracks[i].times[0];
				}
			} // shift all tracks such that clip begins at t=0


			for (let i = 0; i < clip.tracks.length; ++i) {
				clip.tracks[i].shift(-1 * minStartTime);
			}

			clip.resetDuration();
			return clip;
		},
		makeClipAdditive: function (targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
			if (fps <= 0) fps = 30;
			const numTracks = referenceClip.tracks.length;
			const referenceTime = referenceFrame / fps; // Make each track's values relative to the values at the reference frame

			for (let i = 0; i < numTracks; ++i) {
				const referenceTrack = referenceClip.tracks[i];
				const referenceTrackType = referenceTrack.ValueTypeName; // Skip this track if it's non-numeric

				if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue; // Find the track in the target clip whose name and type matches the reference track

				const targetTrack = targetClip.tracks.find(function (track) {
					return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
				});
				if (targetTrack === undefined) continue;
				let referenceOffset = 0;
				const referenceValueSize = referenceTrack.getValueSize();

				if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
					referenceOffset = referenceValueSize / 3;
				}

				let targetOffset = 0;
				const targetValueSize = targetTrack.getValueSize();

				if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
					targetOffset = targetValueSize / 3;
				}

				const lastIndex = referenceTrack.times.length - 1;
				let referenceValue; // Find the value to subtract out of the track

				if (referenceTime <= referenceTrack.times[0]) {
					// Reference frame is earlier than the first keyframe, so just use the first keyframe
					const startIndex = referenceOffset;
					const endIndex = referenceValueSize - referenceOffset;
					referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
				} else if (referenceTime >= referenceTrack.times[lastIndex]) {
					// Reference frame is after the last keyframe, so just use the last keyframe
					const startIndex = lastIndex * referenceValueSize + referenceOffset;
					const endIndex = startIndex + referenceValueSize - referenceOffset;
					referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
				} else {
					// Interpolate to the reference value
					const interpolant = referenceTrack.createInterpolant();
					const startIndex = referenceOffset;
					const endIndex = referenceValueSize - referenceOffset;
					interpolant.evaluate(referenceTime);
					referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
				} // Conjugate the quaternion


				if (referenceTrackType === 'quaternion') {
					const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
					referenceQuat.toArray(referenceValue);
				} // Subtract the reference value from all of the track values


				const numTimes = targetTrack.times.length;

				for (let j = 0; j < numTimes; ++j) {
					const valueStart = j * targetValueSize + targetOffset;

					if (referenceTrackType === 'quaternion') {
						// Multiply the conjugate for quaternion track types
						Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
					} else {
						const valueEnd = targetValueSize - targetOffset * 2; // Subtract each value for all other numeric track types

						for (let k = 0; k < valueEnd; ++k) {
							targetTrack.values[valueStart + k] -= referenceValue[k];
						}
					}
				}
			}

			targetClip.blendMode = AdditiveAnimationBlendMode;
			return targetClip;
		}
	};

	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 */
	class Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			this.parameterPositions = parameterPositions;
			this._cachedIndex = 0;
			this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
			this.sampleValues = sampleValues;
			this.valueSize = sampleSize;
			this.settings = null;
			this.DefaultSettings_ = {};
		}

		evaluate(t) {
			const pp = this.parameterPositions;
			let i1 = this._cachedIndex,
					t1 = pp[i1],
					t0 = pp[i1 - 1];

			validate_interval: {
				seek: {
					let right;

					linear_scan: {
						//- See http://jsperf.com/comparison-to-undefined/3
						//- slower code:
						//-
						//- 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if (!(t < t1)) {
							for (let giveUpAt = i1 + 2;;) {
								if (t1 === undefined) {
									if (t < t0) break forward_scan; // after end

									i1 = pp.length;
									this._cachedIndex = i1;
									return this.afterEnd_(i1 - 1, t, t0);
								}

								if (i1 === giveUpAt) break; // this loop

								t0 = t1;
								t1 = pp[++i1];

								if (t < t1) {
									// we have arrived at the sought interval
									break seek;
								}
							} // prepare binary search on the right side of the index


							right = pp.length;
							break linear_scan;
						} //- slower code:
						//-					if ( t < t0 || t0 === undefined ) {


						if (!(t >= t0)) {
							// looping?
							const t1global = pp[1];

							if (t < t1global) {
								i1 = 2; // + 1, using the scan for the details

								t0 = t1global;
							} // linear reverse scan


							for (let giveUpAt = i1 - 2;;) {
								if (t0 === undefined) {
									// before start
									this._cachedIndex = 0;
									return this.beforeStart_(0, t, t1);
								}

								if (i1 === giveUpAt) break; // this loop

								t1 = t0;
								t0 = pp[--i1 - 1];

								if (t >= t0) {
									// we have arrived at the sought interval
									break seek;
								}
							} // prepare binary search on the left side of the index


							right = i1;
							i1 = 0;
							break linear_scan;
						} // the interval is valid


						break validate_interval;
					} // linear scan
					// binary search


					while (i1 < right) {
						const mid = i1 + right >>> 1;

						if (t < pp[mid]) {
							right = mid;
						} else {
							i1 = mid + 1;
						}
					}

					t1 = pp[i1];
					t0 = pp[i1 - 1]; // check boundary cases, again

					if (t0 === undefined) {
						this._cachedIndex = 0;
						return this.beforeStart_(0, t, t1);
					}

					if (t1 === undefined) {
						i1 = pp.length;
						this._cachedIndex = i1;
						return this.afterEnd_(i1 - 1, t0, t);
					}
				} // seek


				this._cachedIndex = i1;
				this.intervalChanged_(i1, t0, t1);
			} // validate_interval


			return this.interpolate_(i1, t0, t, t1);
		}

		getSettings_() {
			return this.settings || this.DefaultSettings_;
		}

		copySampleValue_(index) {
			// copies a sample value to the result buffer
			const result = this.resultBuffer,
						values = this.sampleValues,
						stride = this.valueSize,
						offset = index * stride;

			for (let i = 0; i !== stride; ++i) {
				result[i] = values[offset + i];
			}

			return result;
		} // Template methods for derived classes:


		interpolate_() {
			throw new Error('call to abstract method'); // implementations shall return this.resultBuffer
		}

		intervalChanged_() {// empty
		}

	} // ALIAS DEFINITIONS


	Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
	Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;

	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 */

	class CubicInterpolant extends Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			super(parameterPositions, sampleValues, sampleSize, resultBuffer);
			this._weightPrev = -0;
			this._offsetPrev = -0;
			this._weightNext = -0;
			this._offsetNext = -0;
			this.DefaultSettings_ = {
				endingStart: ZeroCurvatureEnding,
				endingEnd: ZeroCurvatureEnding
			};
		}

		intervalChanged_(i1, t0, t1) {
			const pp = this.parameterPositions;
			let iPrev = i1 - 2,
					iNext = i1 + 1,
					tPrev = pp[iPrev],
					tNext = pp[iNext];

			if (tPrev === undefined) {
				switch (this.getSettings_().endingStart) {
					case ZeroSlopeEnding:
						// f'(t0) = 0
						iPrev = i1;
						tPrev = 2 * t0 - t1;
						break;

					case WrapAroundEnding:
						// use the other end of the curve
						iPrev = pp.length - 2;
						tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
						break;

					default:
						// ZeroCurvatureEnding
						// f''(t0) = 0 a.k.a. Natural Spline
						iPrev = i1;
						tPrev = t1;
				}
			}

			if (tNext === undefined) {
				switch (this.getSettings_().endingEnd) {
					case ZeroSlopeEnding:
						// f'(tN) = 0
						iNext = i1;
						tNext = 2 * t1 - t0;
						break;

					case WrapAroundEnding:
						// use the other end of the curve
						iNext = 1;
						tNext = t1 + pp[1] - pp[0];
						break;

					default:
						// ZeroCurvatureEnding
						// f''(tN) = 0, a.k.a. Natural Spline
						iNext = i1 - 1;
						tNext = t0;
				}
			}

			const halfDt = (t1 - t0) * 0.5,
						stride = this.valueSize;
			this._weightPrev = halfDt / (t0 - tPrev);
			this._weightNext = halfDt / (tNext - t1);
			this._offsetPrev = iPrev * stride;
			this._offsetNext = iNext * stride;
		}

		interpolate_(i1, t0, t, t1) {
			const result = this.resultBuffer,
						values = this.sampleValues,
						stride = this.valueSize,
						o1 = i1 * stride,
						o0 = o1 - stride,
						oP = this._offsetPrev,
						oN = this._offsetNext,
						wP = this._weightPrev,
						wN = this._weightNext,
						p = (t - t0) / (t1 - t0),
						pp = p * p,
						ppp = pp * p; // evaluate polynomials

			const sP = -wP * ppp + 2 * wP * pp - wP * p;
			const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
			const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
			const sN = wN * ppp - wN * pp; // combine data linearly

			for (let i = 0; i !== stride; ++i) {
				result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
			}

			return result;
		}

	}

	class LinearInterpolant extends Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			super(parameterPositions, sampleValues, sampleSize, resultBuffer);
		}

		interpolate_(i1, t0, t, t1) {
			const result = this.resultBuffer,
						values = this.sampleValues,
						stride = this.valueSize,
						offset1 = i1 * stride,
						offset0 = offset1 - stride,
						weight1 = (t - t0) / (t1 - t0),
						weight0 = 1 - weight1;

			for (let i = 0; i !== stride; ++i) {
				result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
			}

			return result;
		}

	}

	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 */

	class DiscreteInterpolant extends Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			super(parameterPositions, sampleValues, sampleSize, resultBuffer);
		}

		interpolate_(i1
		/*, t0, t, t1 */
		) {
			return this.copySampleValue_(i1 - 1);
		}

	}

	class KeyframeTrack {
		constructor(name, times, values, interpolation) {
			if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
			if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
			this.name = name;
			this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
			this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
			this.setInterpolation(interpolation || this.DefaultInterpolation);
		} // Serialization (in static context, because of constructor invocation
		// and automatic invocation of .toJSON):


		static toJSON(track) {
			const trackType = track.constructor;
			let json; // derived classes can define a static toJSON method

			if (trackType.toJSON !== this.toJSON) {
				json = trackType.toJSON(track);
			} else {
				// by default, we assume the data can be serialized as-is
				json = {
					'name': track.name,
					'times': AnimationUtils.convertArray(track.times, Array),
					'values': AnimationUtils.convertArray(track.values, Array)
				};
				const interpolation = track.getInterpolation();

				if (interpolation !== track.DefaultInterpolation) {
					json.interpolation = interpolation;
				}
			}

			json.type = track.ValueTypeName; // mandatory

			return json;
		}

		InterpolantFactoryMethodDiscrete(result) {
			return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
		}

		InterpolantFactoryMethodLinear(result) {
			return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
		}

		InterpolantFactoryMethodSmooth(result) {
			return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
		}

		setInterpolation(interpolation) {
			let factoryMethod;

			switch (interpolation) {
				case InterpolateDiscrete:
					factoryMethod = this.InterpolantFactoryMethodDiscrete;
					break;

				case InterpolateLinear:
					factoryMethod = this.InterpolantFactoryMethodLinear;
					break;

				case InterpolateSmooth:
					factoryMethod = this.InterpolantFactoryMethodSmooth;
					break;
			}

			if (factoryMethod === undefined) {
				const message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;

				if (this.createInterpolant === undefined) {
					// fall back to default, unless the default itself is messed up
					if (interpolation !== this.DefaultInterpolation) {
						this.setInterpolation(this.DefaultInterpolation);
					} else {
						throw new Error(message); // fatal, in this case
					}
				}

				console.warn('THREE.KeyframeTrack:', message);
				return this;
			}

			this.createInterpolant = factoryMethod;
			return this;
		}

		getInterpolation() {
			switch (this.createInterpolant) {
				case this.InterpolantFactoryMethodDiscrete:
					return InterpolateDiscrete;

				case this.InterpolantFactoryMethodLinear:
					return InterpolateLinear;

				case this.InterpolantFactoryMethodSmooth:
					return InterpolateSmooth;
			}
		}

		getValueSize() {
			return this.values.length / this.times.length;
		} // move all keyframes either forwards or backwards in time


		shift(timeOffset) {
			if (timeOffset !== 0.0) {
				const times = this.times;

				for (let i = 0, n = times.length; i !== n; ++i) {
					times[i] += timeOffset;
				}
			}

			return this;
		} // scale all keyframe times by a factor (useful for frame <-> seconds conversions)


		scale(timeScale) {
			if (timeScale !== 1.0) {
				const times = this.times;

				for (let i = 0, n = times.length; i !== n; ++i) {
					times[i] *= timeScale;
				}
			}

			return this;
		} // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values


		trim(startTime, endTime) {
			const times = this.times,
						nKeys = times.length;
			let from = 0,
					to = nKeys - 1;

			while (from !== nKeys && times[from] < startTime) {
				++from;
			}

			while (to !== -1 && times[to] > endTime) {
				--to;
			}

			++to; // inclusive -> exclusive bound

			if (from !== 0 || to !== nKeys) {
				// empty tracks are forbidden, so keep at least one keyframe
				if (from >= to) {
					to = Math.max(to, 1);
					from = to - 1;
				}

				const stride = this.getValueSize();
				this.times = AnimationUtils.arraySlice(times, from, to);
				this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
			}

			return this;
		} // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable


		validate() {
			let valid = true;
			const valueSize = this.getValueSize();

			if (valueSize - Math.floor(valueSize) !== 0) {
				console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
				valid = false;
			}

			const times = this.times,
						values = this.values,
						nKeys = times.length;

			if (nKeys === 0) {
				console.error('THREE.KeyframeTrack: Track is empty.', this);
				valid = false;
			}

			let prevTime = null;

			for (let i = 0; i !== nKeys; i++) {
				const currTime = times[i];

				if (typeof currTime === 'number' && isNaN(currTime)) {
					console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
					valid = false;
					break;
				}

				if (prevTime !== null && prevTime > currTime) {
					console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
					valid = false;
					break;
				}

				prevTime = currTime;
			}

			if (values !== undefined) {
				if (AnimationUtils.isTypedArray(values)) {
					for (let i = 0, n = values.length; i !== n; ++i) {
						const value = values[i];

						if (isNaN(value)) {
							console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);
							valid = false;
							break;
						}
					}
				}
			}

			return valid;
		} // removes equivalent sequential keys as common in morph target sequences
		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)


		optimize() {
			// times or values may be shared with other tracks, so overwriting is unsafe
			const times = AnimationUtils.arraySlice(this.times),
						values = AnimationUtils.arraySlice(this.values),
						stride = this.getValueSize(),
						smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
						lastIndex = times.length - 1;
			let writeIndex = 1;

			for (let i = 1; i < lastIndex; ++i) {
				let keep = false;
				const time = times[i];
				const timeNext = times[i + 1]; // remove adjacent keyframes scheduled at the same time

				if (time !== timeNext && (i !== 1 || time !== times[0])) {
					if (!smoothInterpolation) {
						// remove unnecessary keyframes same as their neighbors
						const offset = i * stride,
									offsetP = offset - stride,
									offsetN = offset + stride;

						for (let j = 0; j !== stride; ++j) {
							const value = values[offset + j];

							if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
								keep = true;
								break;
							}
						}
					} else {
						keep = true;
					}
				} // in-place compaction


				if (keep) {
					if (i !== writeIndex) {
						times[writeIndex] = times[i];
						const readOffset = i * stride,
									writeOffset = writeIndex * stride;

						for (let j = 0; j !== stride; ++j) {
							values[writeOffset + j] = values[readOffset + j];
						}
					}

					++writeIndex;
				}
			} // flush last keyframe (compaction looks ahead)


			if (lastIndex > 0) {
				times[writeIndex] = times[lastIndex];

				for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
					values[writeOffset + j] = values[readOffset + j];
				}

				++writeIndex;
			}

			if (writeIndex !== times.length) {
				this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
				this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
			} else {
				this.times = times;
				this.values = values;
			}

			return this;
		}

		clone() {
			const times = AnimationUtils.arraySlice(this.times, 0);
			const values = AnimationUtils.arraySlice(this.values, 0);
			const TypedKeyframeTrack = this.constructor;
			const track = new TypedKeyframeTrack(this.name, times, values); // Interpolant argument to constructor is not saved, so copy the factory method directly.

			track.createInterpolant = this.createInterpolant;
			return track;
		}

	}

	KeyframeTrack.prototype.TimeBufferType = Float32Array;
	KeyframeTrack.prototype.ValueBufferType = Float32Array;
	KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

	/**
	 * A Track of Boolean keyframe values.
	 */

	class BooleanKeyframeTrack extends KeyframeTrack {}

	BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
	BooleanKeyframeTrack.prototype.ValueBufferType = Array;
	BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
	BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
	BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined; // Note: Actually this track could have a optimized / compressed

	/**
	 * A Track of keyframe values that represent color.
	 */

	class ColorKeyframeTrack extends KeyframeTrack {}

	ColorKeyframeTrack.prototype.ValueTypeName = 'color'; // ValueBufferType is inherited

	/**
	 * A Track of numeric keyframe values.
	 */

	class NumberKeyframeTrack extends KeyframeTrack {}

	NumberKeyframeTrack.prototype.ValueTypeName = 'number'; // ValueBufferType is inherited

	/**
	 * Spherical linear unit quaternion interpolant.
	 */

	class QuaternionLinearInterpolant extends Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			super(parameterPositions, sampleValues, sampleSize, resultBuffer);
		}

		interpolate_(i1, t0, t, t1) {
			const result = this.resultBuffer,
						values = this.sampleValues,
						stride = this.valueSize,
						alpha = (t - t0) / (t1 - t0);
			let offset = i1 * stride;

			for (let end = offset + stride; offset !== end; offset += 4) {
				Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
			}

			return result;
		}

	}

	/**
	 * A Track of quaternion keyframe values.
	 */

	class QuaternionKeyframeTrack extends KeyframeTrack {
		InterpolantFactoryMethodLinear(result) {
			return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
		}

	}

	QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion'; // ValueBufferType is inherited

	QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
	QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

	/**
	 * A Track that interpolates Strings
	 */

	class StringKeyframeTrack extends KeyframeTrack {}

	StringKeyframeTrack.prototype.ValueTypeName = 'string';
	StringKeyframeTrack.prototype.ValueBufferType = Array;
	StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
	StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
	StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

	/**
	 * A Track of vectored keyframe values.
	 */

	class VectorKeyframeTrack extends KeyframeTrack {}

	VectorKeyframeTrack.prototype.ValueTypeName = 'vector'; // ValueBufferType is inherited

	class AnimationClip {
		constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
			this.name = name;
			this.tracks = tracks;
			this.duration = duration;
			this.blendMode = blendMode;
			this.uuid = generateUUID(); // this means it should figure out its duration by scanning the tracks

			if (this.duration < 0) {
				this.resetDuration();
			}
		}

		static parse(json) {
			const tracks = [],
						jsonTracks = json.tracks,
						frameTime = 1.0 / (json.fps || 1.0);

			for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
				tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
			}

			const clip = new this(json.name, json.duration, tracks, json.blendMode);
			clip.uuid = json.uuid;
			return clip;
		}

		static toJSON(clip) {
			const tracks = [],
						clipTracks = clip.tracks;
			const json = {
				'name': clip.name,
				'duration': clip.duration,
				'tracks': tracks,
				'uuid': clip.uuid,
				'blendMode': clip.blendMode
			};

			for (let i = 0, n = clipTracks.length; i !== n; ++i) {
				tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
			}

			return json;
		}

		static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
			const numMorphTargets = morphTargetSequence.length;
			const tracks = [];

			for (let i = 0; i < numMorphTargets; i++) {
				let times = [];
				let values = [];
				times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
				values.push(0, 1, 0);
				const order = AnimationUtils.getKeyframeOrder(times);
				times = AnimationUtils.sortedArray(times, 1, order);
				values = AnimationUtils.sortedArray(values, 1, order); // if there is a key at the first frame, duplicate it as the
				// last frame as well for perfect loop.

				if (!noLoop && times[0] === 0) {
					times.push(numMorphTargets);
					values.push(values[0]);
				}

				tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
			}

			return new this(name, -1, tracks);
		}

		static findByName(objectOrClipArray, name) {
			let clipArray = objectOrClipArray;

			if (!Array.isArray(objectOrClipArray)) {
				const o = objectOrClipArray;
				clipArray = o.geometry && o.geometry.animations || o.animations;
			}

			for (let i = 0; i < clipArray.length; i++) {
				if (clipArray[i].name === name) {
					return clipArray[i];
				}
			}

			return null;
		}

		static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
			const animationToMorphTargets = {}; // tested with https://regex101.com/ on trick sequences
			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059

			const pattern = /^([\w-]*?)([\d]+)$/; // sort morph target names into animation groups based
			// patterns like Walk_001, Walk_002, Run_001, Run_002

			for (let i = 0, il = morphTargets.length; i < il; i++) {
				const morphTarget = morphTargets[i];
				const parts = morphTarget.name.match(pattern);

				if (parts && parts.length > 1) {
					const name = parts[1];
					let animationMorphTargets = animationToMorphTargets[name];

					if (!animationMorphTargets) {
						animationToMorphTargets[name] = animationMorphTargets = [];
					}

					animationMorphTargets.push(morphTarget);
				}
			}

			const clips = [];

			for (const name in animationToMorphTargets) {
				clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
			}

			return clips;
		} // parse the animation.hierarchy format


		static parseAnimation(animation, bones) {
			if (!animation) {
				console.error('THREE.AnimationClip: No animation in JSONLoader data.');
				return null;
			}

			const addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {
				// only return track if there are actually keys.
				if (animationKeys.length !== 0) {
					const times = [];
					const values = [];
					AnimationUtils.flattenJSON(animationKeys, times, values, propertyName); // empty keys are filtered out, so check again

					if (times.length !== 0) {
						destTracks.push(new trackType(trackName, times, values));
					}
				}
			};

			const tracks = [];
			const clipName = animation.name || 'default';
			const fps = animation.fps || 30;
			const blendMode = animation.blendMode; // automatic length determination in AnimationClip.

			let duration = animation.length || -1;
			const hierarchyTracks = animation.hierarchy || [];

			for (let h = 0; h < hierarchyTracks.length; h++) {
				const animationKeys = hierarchyTracks[h].keys; // skip empty tracks

				if (!animationKeys || animationKeys.length === 0) continue; // process morph targets

				if (animationKeys[0].morphTargets) {
					// figure out all morph targets used in this track
					const morphTargetNames = {};
					let k;

					for (k = 0; k < animationKeys.length; k++) {
						if (animationKeys[k].morphTargets) {
							for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
								morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
							}
						}
					} // create a track for each morph target with all zero
					// morphTargetInfluences except for the keys in which
					// the morphTarget is named.


					for (const morphTargetName in morphTargetNames) {
						const times = [];
						const values = [];

						for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
							const animationKey = animationKeys[k];
							times.push(animationKey.time);
							values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
						}

						tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
					}

					duration = morphTargetNames.length * (fps || 1.0);
				} else {
					// ...assume skeletal animation
					const boneName = '.bones[' + bones[h].name + ']';
					addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
					addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
					addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
				}
			}

			if (tracks.length === 0) {
				return null;
			}

			const clip = new this(clipName, duration, tracks, blendMode);
			return clip;
		}

		resetDuration() {
			const tracks = this.tracks;
			let duration = 0;

			for (let i = 0, n = tracks.length; i !== n; ++i) {
				const track = this.tracks[i];
				duration = Math.max(duration, track.times[track.times.length - 1]);
			}

			this.duration = duration;
			return this;
		}

		trim() {
			for (let i = 0; i < this.tracks.length; i++) {
				this.tracks[i].trim(0, this.duration);
			}

			return this;
		}

		validate() {
			let valid = true;

			for (let i = 0; i < this.tracks.length; i++) {
				valid = valid && this.tracks[i].validate();
			}

			return valid;
		}

		optimize() {
			for (let i = 0; i < this.tracks.length; i++) {
				this.tracks[i].optimize();
			}

			return this;
		}

		clone() {
			const tracks = [];

			for (let i = 0; i < this.tracks.length; i++) {
				tracks.push(this.tracks[i].clone());
			}

			return new this.constructor(this.name, this.duration, tracks, this.blendMode);
		}

		toJSON() {
			return this.constructor.toJSON(this);
		}

	}

	function getTrackTypeForValueTypeName(typeName) {
		switch (typeName.toLowerCase()) {
			case 'scalar':
			case 'double':
			case 'float':
			case 'number':
			case 'integer':
				return NumberKeyframeTrack;

			case 'vector':
			case 'vector2':
			case 'vector3':
			case 'vector4':
				return VectorKeyframeTrack;

			case 'color':
				return ColorKeyframeTrack;

			case 'quaternion':
				return QuaternionKeyframeTrack;

			case 'bool':
			case 'boolean':
				return BooleanKeyframeTrack;

			case 'string':
				return StringKeyframeTrack;
		}

		throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
	}

	function parseKeyframeTrack(json) {
		if (json.type === undefined) {
			throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
		}

		const trackType = getTrackTypeForValueTypeName(json.type);

		if (json.times === undefined) {
			const times = [],
						values = [];
			AnimationUtils.flattenJSON(json.keys, times, values, 'value');
			json.times = times;
			json.values = values;
		} // derived classes can define a static parse method


		if (trackType.parse !== undefined) {
			return trackType.parse(json);
		} else {
			// by default, we assume a constructor compatible with the base
			return new trackType(json.name, json.times, json.values, json.interpolation);
		}
	}

	const Cache = {
		enabled: false,
		files: {},
		add: function (key, file) {
			if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[key] = file;
		},
		get: function (key) {
			if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[key];
		},
		remove: function (key) {
			delete this.files[key];
		},
		clear: function () {
			this.files = {};
		}
	};

	class LoadingManager {
		constructor(onLoad, onProgress, onError) {
			const scope = this;
			let isLoading = false;
			let itemsLoaded = 0;
			let itemsTotal = 0;
			let urlModifier = undefined;
			const handlers = []; // Refer to #5689 for the reason why we don't set .onStart
			// in the constructor

			this.onStart = undefined;
			this.onLoad = onLoad;
			this.onProgress = onProgress;
			this.onError = onError;

			this.itemStart = function (url) {
				itemsTotal++;

				if (isLoading === false) {
					if (scope.onStart !== undefined) {
						scope.onStart(url, itemsLoaded, itemsTotal);
					}
				}

				isLoading = true;
			};

			this.itemEnd = function (url) {
				itemsLoaded++;

				if (scope.onProgress !== undefined) {
					scope.onProgress(url, itemsLoaded, itemsTotal);
				}

				if (itemsLoaded === itemsTotal) {
					isLoading = false;

					if (scope.onLoad !== undefined) {
						scope.onLoad();
					}
				}
			};

			this.itemError = function (url) {
				if (scope.onError !== undefined) {
					scope.onError(url);
				}
			};

			this.resolveURL = function (url) {
				if (urlModifier) {
					return urlModifier(url);
				}

				return url;
			};

			this.setURLModifier = function (transform) {
				urlModifier = transform;
				return this;
			};

			this.addHandler = function (regex, loader) {
				handlers.push(regex, loader);
				return this;
			};

			this.removeHandler = function (regex) {
				const index = handlers.indexOf(regex);

				if (index !== -1) {
					handlers.splice(index, 2);
				}

				return this;
			};

			this.getHandler = function (file) {
				for (let i = 0, l = handlers.length; i < l; i += 2) {
					const regex = handlers[i];
					const loader = handlers[i + 1];
					if (regex.global) regex.lastIndex = 0; // see #17920

					if (regex.test(file)) {
						return loader;
					}
				}

				return null;
			};
		}

	}

	const DefaultLoadingManager = new LoadingManager();

	class Loader {
		constructor(manager) {
			this.manager = manager !== undefined ? manager : DefaultLoadingManager;
			this.crossOrigin = 'anonymous';
			this.withCredentials = false;
			this.path = '';
			this.resourcePath = '';
			this.requestHeader = {};
		}

		load() {}

		loadAsync(url, onProgress) {
			const scope = this;
			return new Promise(function (resolve, reject) {
				scope.load(url, resolve, onProgress, reject);
			});
		}

		parse() {}

		setCrossOrigin(crossOrigin) {
			this.crossOrigin = crossOrigin;
			return this;
		}

		setWithCredentials(value) {
			this.withCredentials = value;
			return this;
		}

		setPath(path) {
			this.path = path;
			return this;
		}

		setResourcePath(resourcePath) {
			this.resourcePath = resourcePath;
			return this;
		}

		setRequestHeader(requestHeader) {
			this.requestHeader = requestHeader;
			return this;
		}

	}

	const loading = {};

	class FileLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			if (url === undefined) url = '';
			if (this.path !== undefined) url = this.path + url;
			url = this.manager.resolveURL(url);
			const cached = Cache.get(url);

			if (cached !== undefined) {
				this.manager.itemStart(url);
				setTimeout(() => {
					if (onLoad) onLoad(cached);
					this.manager.itemEnd(url);
				}, 0);
				return cached;
			} // Check if request is duplicate


			if (loading[url] !== undefined) {
				loading[url].push({
					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError
				});
				return;
			} // Initialise array for duplicate requests


			loading[url] = [];
			loading[url].push({
				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError
			}); // create request

			const req = new Request(url, {
				headers: new Headers(this.requestHeader),
				credentials: this.withCredentials ? 'include' : 'same-origin' // An abort controller could be added within a future PR

			}); // start the fetch

			fetch(req).then(response => {
				if (response.status === 200 || response.status === 0) {
					// Some browsers return HTTP Status 0 when using non-http protocol
					// e.g. 'file://' or 'data://'. Handle as success.
					if (response.status === 0) {
						console.warn('THREE.FileLoader: HTTP Status 0 received.');
					}

					const callbacks = loading[url];
					const reader = response.body.getReader();
					const contentLength = response.headers.get('Content-Length');
					const total = contentLength ? parseInt(contentLength) : 0;
					const lengthComputable = total !== 0;
					let loaded = 0; // periodically read data into the new stream tracking while download progress

					return new ReadableStream({
						start(controller) {
							readData();

							function readData() {
								reader.read().then(({
									done,
									value
								}) => {
									if (done) {
										controller.close();
									} else {
										loaded += value.byteLength;
										const event = new ProgressEvent('progress', {
											lengthComputable,
											loaded,
											total
										});

										for (let i = 0, il = callbacks.length; i < il; i++) {
											const callback = callbacks[i];
											if (callback.onProgress) callback.onProgress(event);
										}

										controller.enqueue(value);
										readData();
									}
								});
							}
						}

					});
				} else {
					throw Error(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`);
				}
			}).then(stream => {
				const response = new Response(stream);

				switch (this.responseType) {
					case 'arraybuffer':
						return response.arrayBuffer();

					case 'blob':
						return response.blob();

					case 'document':
						return response.text().then(text => {
							const parser = new DOMParser();
							return parser.parseFromString(text, this.mimeType);
						});

					case 'json':
						return response.json();

					default:
						return response.text();
				}
			}).then(data => {
				// Add to cache only on HTTP success, so that we do not cache
				// error response bodies as proper responses to requests.
				Cache.add(url, data);
				const callbacks = loading[url];
				delete loading[url];

				for (let i = 0, il = callbacks.length; i < il; i++) {
					const callback = callbacks[i];
					if (callback.onLoad) callback.onLoad(data);
				}

				this.manager.itemEnd(url);
			}).catch(err => {
				// Abort errors and other errors are handled the same
				const callbacks = loading[url];
				delete loading[url];

				for (let i = 0, il = callbacks.length; i < il; i++) {
					const callback = callbacks[i];
					if (callback.onError) callback.onError(err);
				}

				this.manager.itemError(url);
				this.manager.itemEnd(url);
			});
			this.manager.itemStart(url);
		}

		setResponseType(value) {
			this.responseType = value;
			return this;
		}

		setMimeType(value) {
			this.mimeType = value;
			return this;
		}

	}

	class AnimationLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(this.withCredentials);
			loader.load(url, function (text) {
				try {
					onLoad(scope.parse(JSON.parse(text)));
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}

					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		}

		parse(json) {
			const animations = [];

			for (let i = 0; i < json.length; i++) {
				const clip = AnimationClip.parse(json[i]);
				animations.push(clip);
			}

			return animations;
		}

	}

	/**
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */

	class CompressedTextureLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const images = [];
			const texture = new CompressedTexture();
			const loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setResponseType('arraybuffer');
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			let loaded = 0;

			function loadTexture(i) {
				loader.load(url[i], function (buffer) {
					const texDatas = scope.parse(buffer, true);
					images[i] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};
					loaded += 1;

					if (loaded === 6) {
						if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
						texture.image = images;
						texture.format = texDatas.format;
						texture.needsUpdate = true;
						if (onLoad) onLoad(texture);
					}
				}, onProgress, onError);
			}

			if (Array.isArray(url)) {
				for (let i = 0, il = url.length; i < il; ++i) {
					loadTexture(i);
				}
			} else {
				// compressed cubemap texture stored in a single DDS file
				loader.load(url, function (buffer) {
					const texDatas = scope.parse(buffer, true);

					if (texDatas.isCubemap) {
						const faces = texDatas.mipmaps.length / texDatas.mipmapCount;

						for (let f = 0; f < faces; f++) {
							images[f] = {
								mipmaps: []
							};

							for (let i = 0; i < texDatas.mipmapCount; i++) {
								images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
								images[f].format = texDatas.format;
								images[f].width = texDatas.width;
								images[f].height = texDatas.height;
							}
						}

						texture.image = images;
					} else {
						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;
					}

					if (texDatas.mipmapCount === 1) {
						texture.minFilter = LinearFilter;
					}

					texture.format = texDatas.format;
					texture.needsUpdate = true;
					if (onLoad) onLoad(texture);
				}, onProgress, onError);
			}

			return texture;
		}

	}

	class ImageLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			if (this.path !== undefined) url = this.path + url;
			url = this.manager.resolveURL(url);
			const scope = this;
			const cached = Cache.get(url);

			if (cached !== undefined) {
				scope.manager.itemStart(url);
				setTimeout(function () {
					if (onLoad) onLoad(cached);
					scope.manager.itemEnd(url);
				}, 0);
				return cached;
			}

			const image = createElementNS('img');

			function onImageLoad() {
				removeEventListeners();
				Cache.add(url, this);
				if (onLoad) onLoad(this);
				scope.manager.itemEnd(url);
			}

			function onImageError(event) {
				removeEventListeners();
				if (onError) onError(event);
				scope.manager.itemError(url);
				scope.manager.itemEnd(url);
			}

			function removeEventListeners() {
				image.removeEventListener('load', onImageLoad, false);
				image.removeEventListener('error', onImageError, false);
			}

			image.addEventListener('load', onImageLoad, false);
			image.addEventListener('error', onImageError, false);

			if (url.substr(0, 5) !== 'data:') {
				if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
			}

			scope.manager.itemStart(url);
			image.src = url;
			return image;
		}

	}

	class CubeTextureLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(urls, onLoad, onProgress, onError) {
			const texture = new CubeTexture();
			const loader = new ImageLoader(this.manager);
			loader.setCrossOrigin(this.crossOrigin);
			loader.setPath(this.path);
			let loaded = 0;

			function loadTexture(i) {
				loader.load(urls[i], function (image) {
					texture.images[i] = image;
					loaded++;

					if (loaded === 6) {
						texture.needsUpdate = true;
						if (onLoad) onLoad(texture);
					}
				}, undefined, onError);
			}

			for (let i = 0; i < urls.length; ++i) {
				loadTexture(i);
			}

			return texture;
		}

	}

	/**
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */

	class DataTextureLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const texture = new DataTexture();
			const loader = new FileLoader(this.manager);
			loader.setResponseType('arraybuffer');
			loader.setRequestHeader(this.requestHeader);
			loader.setPath(this.path);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function (buffer) {
				const texData = scope.parse(buffer);
				if (!texData) return;

				if (texData.image !== undefined) {
					texture.image = texData.image;
				} else if (texData.data !== undefined) {
					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;
				}

				texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
				texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
				texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
				texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
				texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

				if (texData.encoding !== undefined) {
					texture.encoding = texData.encoding;
				}

				if (texData.flipY !== undefined) {
					texture.flipY = texData.flipY;
				}

				if (texData.format !== undefined) {
					texture.format = texData.format;
				}

				if (texData.type !== undefined) {
					texture.type = texData.type;
				}

				if (texData.mipmaps !== undefined) {
					texture.mipmaps = texData.mipmaps;
					texture.minFilter = LinearMipmapLinearFilter; // presumably...
				}

				if (texData.mipmapCount === 1) {
					texture.minFilter = LinearFilter;
				}

				if (texData.generateMipmaps !== undefined) {
					texture.generateMipmaps = texData.generateMipmaps;
				}

				texture.needsUpdate = true;
				if (onLoad) onLoad(texture, texData);
			}, onProgress, onError);
			return texture;
		}

	}

	class TextureLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const texture = new Texture();
			const loader = new ImageLoader(this.manager);
			loader.setCrossOrigin(this.crossOrigin);
			loader.setPath(this.path);
			loader.load(url, function (image) {
				texture.image = image;
				texture.needsUpdate = true;

				if (onLoad !== undefined) {
					onLoad(texture);
				}
			}, onProgress, onError);
			return texture;
		}

	}

	class Light extends Object3D {
		constructor(color, intensity = 1) {
			super();
			this.type = 'Light';
			this.color = new Color(color);
			this.intensity = intensity;
		}

		dispose() {// Empty here in base class; some subclasses override.
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.intensity = source.intensity;
			return this;
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;
			if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
			if (this.distance !== undefined) data.object.distance = this.distance;
			if (this.angle !== undefined) data.object.angle = this.angle;
			if (this.decay !== undefined) data.object.decay = this.decay;
			if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
			if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
			return data;
		}

	}

	Light.prototype.isLight = true;

	class HemisphereLight extends Light {
		constructor(skyColor, groundColor, intensity) {
			super(skyColor, intensity);
			this.type = 'HemisphereLight';
			this.position.copy(Object3D.DefaultUp);
			this.updateMatrix();
			this.groundColor = new Color(groundColor);
		}

		copy(source) {
			Light.prototype.copy.call(this, source);
			this.groundColor.copy(source.groundColor);
			return this;
		}

	}

	HemisphereLight.prototype.isHemisphereLight = true;

	const _projScreenMatrix$1 = /*@__PURE__*/new Matrix4();

	const _lightPositionWorld$1 = /*@__PURE__*/new Vector3();

	const _lookTarget$1 = /*@__PURE__*/new Vector3();

	class LightShadow {
		constructor(camera) {
			this.camera = camera;
			this.bias = 0;
			this.normalBias = 0;
			this.radius = 1;
			this.blurSamples = 8;
			this.mapSize = new Vector2(512, 512);
			this.map = null;
			this.mapPass = null;
			this.matrix = new Matrix4();
			this.autoUpdate = true;
			this.needsUpdate = false;
			this._frustum = new Frustum();
			this._frameExtents = new Vector2(1, 1);
			this._viewportCount = 1;
			this._viewports = [new Vector4(0, 0, 1, 1)];
		}

		getViewportCount() {
			return this._viewportCount;
		}

		getFrustum() {
			return this._frustum;
		}

		updateMatrices(light) {
			const shadowCamera = this.camera;
			const shadowMatrix = this.matrix;

			_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);

			shadowCamera.position.copy(_lightPositionWorld$1);

			_lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);

			shadowCamera.lookAt(_lookTarget$1);
			shadowCamera.updateMatrixWorld();

			_projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);

			this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);

			shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
			shadowMatrix.multiply(shadowCamera.projectionMatrix);
			shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
		}

		getViewport(viewportIndex) {
			return this._viewports[viewportIndex];
		}

		getFrameExtents() {
			return this._frameExtents;
		}

		dispose() {
			if (this.map) {
				this.map.dispose();
			}

			if (this.mapPass) {
				this.mapPass.dispose();
			}
		}

		copy(source) {
			this.camera = source.camera.clone();
			this.bias = source.bias;
			this.radius = source.radius;
			this.mapSize.copy(source.mapSize);
			return this;
		}

		clone() {
			return new this.constructor().copy(this);
		}

		toJSON() {
			const object = {};
			if (this.bias !== 0) object.bias = this.bias;
			if (this.normalBias !== 0) object.normalBias = this.normalBias;
			if (this.radius !== 1) object.radius = this.radius;
			if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
			object.camera = this.camera.toJSON(false).object;
			delete object.camera.matrix;
			return object;
		}

	}

	class SpotLightShadow extends LightShadow {
		constructor() {
			super(new PerspectiveCamera(50, 1, 0.5, 500));
			this.focus = 1;
		}

		updateMatrices(light) {
			const camera = this.camera;
			const fov = RAD2DEG * 2 * light.angle * this.focus;
			const aspect = this.mapSize.width / this.mapSize.height;
			const far = light.distance || camera.far;

			if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
				camera.fov = fov;
				camera.aspect = aspect;
				camera.far = far;
				camera.updateProjectionMatrix();
			}

			super.updateMatrices(light);
		}

		copy(source) {
			super.copy(source);
			this.focus = source.focus;
			return this;
		}

	}

	SpotLightShadow.prototype.isSpotLightShadow = true;

	class SpotLight extends Light {
		constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
			super(color, intensity);
			this.type = 'SpotLight';
			this.position.copy(Object3D.DefaultUp);
			this.updateMatrix();
			this.target = new Object3D();
			this.distance = distance;
			this.angle = angle;
			this.penumbra = penumbra;
			this.decay = decay; // for physically correct lights, should be 2.

			this.shadow = new SpotLightShadow();
		}

		get power() {
			// compute the light's luminous power (in lumens) from its intensity (in candela)
			// by convention for a spotlight, luminous power (lm) = π * luminous intensity (cd)
			return this.intensity * Math.PI;
		}

		set power(power) {
			// set the light's intensity (in candela) from the desired luminous power (in lumens)
			this.intensity = power / Math.PI;
		}

		dispose() {
			this.shadow.dispose();
		}

		copy(source) {
			super.copy(source);
			this.distance = source.distance;
			this.angle = source.angle;
			this.penumbra = source.penumbra;
			this.decay = source.decay;
			this.target = source.target.clone();
			this.shadow = source.shadow.clone();
			return this;
		}

	}

	SpotLight.prototype.isSpotLight = true;

	const _projScreenMatrix = /*@__PURE__*/new Matrix4();

	const _lightPositionWorld = /*@__PURE__*/new Vector3();

	const _lookTarget = /*@__PURE__*/new Vector3();

	class PointLightShadow extends LightShadow {
		constructor() {
			super(new PerspectiveCamera(90, 1, 0.5, 500));
			this._frameExtents = new Vector2(4, 2);
			this._viewportCount = 6;
			this._viewports = [// These viewports map a cube-map onto a 2D texture with the
			// following orientation:
			//
			//	xzXZ
			//	 y Y
			//
			// X - Positive x direction
			// x - Negative x direction
			// Y - Positive y direction
			// y - Negative y direction
			// Z - Positive z direction
			// z - Negative z direction
			// positive X
			new Vector4(2, 1, 1, 1), // negative X
			new Vector4(0, 1, 1, 1), // positive Z
			new Vector4(3, 1, 1, 1), // negative Z
			new Vector4(1, 1, 1, 1), // positive Y
			new Vector4(3, 0, 1, 1), // negative Y
			new Vector4(1, 0, 1, 1)];
			this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
			this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
		}

		updateMatrices(light, viewportIndex = 0) {
			const camera = this.camera;
			const shadowMatrix = this.matrix;
			const far = light.distance || camera.far;

			if (far !== camera.far) {
				camera.far = far;
				camera.updateProjectionMatrix();
			}

			_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);

			camera.position.copy(_lightPositionWorld);

			_lookTarget.copy(camera.position);

			_lookTarget.add(this._cubeDirections[viewportIndex]);

			camera.up.copy(this._cubeUps[viewportIndex]);
			camera.lookAt(_lookTarget);
			camera.updateMatrixWorld();
			shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);

			_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

			this._frustum.setFromProjectionMatrix(_projScreenMatrix);
		}

	}

	PointLightShadow.prototype.isPointLightShadow = true;

	class PointLight extends Light {
		constructor(color, intensity, distance = 0, decay = 1) {
			super(color, intensity);
			this.type = 'PointLight';
			this.distance = distance;
			this.decay = decay; // for physically correct lights, should be 2.

			this.shadow = new PointLightShadow();
		}

		get power() {
			// compute the light's luminous power (in lumens) from its intensity (in candela)
			// for an isotropic light source, luminous power (lm) = 4 π luminous intensity (cd)
			return this.intensity * 4 * Math.PI;
		}

		set power(power) {
			// set the light's intensity (in candela) from the desired luminous power (in lumens)
			this.intensity = power / (4 * Math.PI);
		}

		dispose() {
			this.shadow.dispose();
		}

		copy(source) {
			super.copy(source);
			this.distance = source.distance;
			this.decay = source.decay;
			this.shadow = source.shadow.clone();
			return this;
		}

	}

	PointLight.prototype.isPointLight = true;

	class DirectionalLightShadow extends LightShadow {
		constructor() {
			super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
		}

	}

	DirectionalLightShadow.prototype.isDirectionalLightShadow = true;

	class DirectionalLight extends Light {
		constructor(color, intensity) {
			super(color, intensity);
			this.type = 'DirectionalLight';
			this.position.copy(Object3D.DefaultUp);
			this.updateMatrix();
			this.target = new Object3D();
			this.shadow = new DirectionalLightShadow();
		}

		dispose() {
			this.shadow.dispose();
		}

		copy(source) {
			super.copy(source);
			this.target = source.target.clone();
			this.shadow = source.shadow.clone();
			return this;
		}

	}

	DirectionalLight.prototype.isDirectionalLight = true;

	class AmbientLight extends Light {
		constructor(color, intensity) {
			super(color, intensity);
			this.type = 'AmbientLight';
		}

	}

	AmbientLight.prototype.isAmbientLight = true;

	class RectAreaLight extends Light {
		constructor(color, intensity, width = 10, height = 10) {
			super(color, intensity);
			this.type = 'RectAreaLight';
			this.width = width;
			this.height = height;
		}

		get power() {
			// compute the light's luminous power (in lumens) from its intensity (in nits)
			return this.intensity * this.width * this.height * Math.PI;
		}

		set power(power) {
			// set the light's intensity (in nits) from the desired luminous power (in lumens)
			this.intensity = power / (this.width * this.height * Math.PI);
		}

		copy(source) {
			super.copy(source);
			this.width = source.width;
			this.height = source.height;
			return this;
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.width = this.width;
			data.object.height = this.height;
			return data;
		}

	}

	RectAreaLight.prototype.isRectAreaLight = true;

	/**
	 * Primary reference:
	 *	 https://graphics.stanford.edu/papers/envmap/envmap.pdf
	 *
	 * Secondary reference:
	 *	 https://www.ppsloan.org/publications/StupidSH36.pdf
	 */
	// 3-band SH defined by 9 coefficients

	class SphericalHarmonics3 {
		constructor() {
			this.coefficients = [];

			for (let i = 0; i < 9; i++) {
				this.coefficients.push(new Vector3());
			}
		}

		set(coefficients) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].copy(coefficients[i]);
			}

			return this;
		}

		zero() {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].set(0, 0, 0);
			}

			return this;
		} // get the radiance in the direction of the normal
		// target is a Vector3


		getAt(normal, target) {
			// normal is assumed to be unit length
			const x = normal.x,
						y = normal.y,
						z = normal.z;
			const coeff = this.coefficients; // band 0

			target.copy(coeff[0]).multiplyScalar(0.282095); // band 1

			target.addScaledVector(coeff[1], 0.488603 * y);
			target.addScaledVector(coeff[2], 0.488603 * z);
			target.addScaledVector(coeff[3], 0.488603 * x); // band 2

			target.addScaledVector(coeff[4], 1.092548 * (x * y));
			target.addScaledVector(coeff[5], 1.092548 * (y * z));
			target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
			target.addScaledVector(coeff[7], 1.092548 * (x * z));
			target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
			return target;
		} // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
		// target is a Vector3
		// https://graphics.stanford.edu/papers/envmap/envmap.pdf


		getIrradianceAt(normal, target) {
			// normal is assumed to be unit length
			const x = normal.x,
						y = normal.y,
						z = normal.z;
			const coeff = this.coefficients; // band 0

			target.copy(coeff[0]).multiplyScalar(0.886227); // π * 0.282095
			// band 1

			target.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 * π / 3 ) * 0.488603

			target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);
			target.addScaledVector(coeff[3], 2.0 * 0.511664 * x); // band 2

			target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // ( π / 4 ) * 1.092548

			target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);
			target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // ( π / 4 ) * 0.315392 * 3

			target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);
			target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // ( π / 4 ) * 0.546274

			return target;
		}

		add(sh) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].add(sh.coefficients[i]);
			}

			return this;
		}

		addScaledSH(sh, s) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].addScaledVector(sh.coefficients[i], s);
			}

			return this;
		}

		scale(s) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].multiplyScalar(s);
			}

			return this;
		}

		lerp(sh, alpha) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].lerp(sh.coefficients[i], alpha);
			}

			return this;
		}

		equals(sh) {
			for (let i = 0; i < 9; i++) {
				if (!this.coefficients[i].equals(sh.coefficients[i])) {
					return false;
				}
			}

			return true;
		}

		copy(sh) {
			return this.set(sh.coefficients);
		}

		clone() {
			return new this.constructor().copy(this);
		}

		fromArray(array, offset = 0) {
			const coefficients = this.coefficients;

			for (let i = 0; i < 9; i++) {
				coefficients[i].fromArray(array, offset + i * 3);
			}

			return this;
		}

		toArray(array = [], offset = 0) {
			const coefficients = this.coefficients;

			for (let i = 0; i < 9; i++) {
				coefficients[i].toArray(array, offset + i * 3);
			}

			return array;
		} // evaluate the basis functions
		// shBasis is an Array[ 9 ]


		static getBasisAt(normal, shBasis) {
			// normal is assumed to be unit length
			const x = normal.x,
						y = normal.y,
						z = normal.z; // band 0

			shBasis[0] = 0.282095; // band 1

			shBasis[1] = 0.488603 * y;
			shBasis[2] = 0.488603 * z;
			shBasis[3] = 0.488603 * x; // band 2

			shBasis[4] = 1.092548 * x * y;
			shBasis[5] = 1.092548 * y * z;
			shBasis[6] = 0.315392 * (3 * z * z - 1);
			shBasis[7] = 1.092548 * x * z;
			shBasis[8] = 0.546274 * (x * x - y * y);
		}

	}

	SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;

	class LightProbe extends Light {
		constructor(sh = new SphericalHarmonics3(), intensity = 1) {
			super(undefined, intensity);
			this.sh = sh;
		}

		copy(source) {
			super.copy(source);
			this.sh.copy(source.sh);
			return this;
		}

		fromJSON(json) {
			this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();

			this.sh.fromArray(json.sh);
			return this;
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.sh = this.sh.toArray();
			return data;
		}

	}

	LightProbe.prototype.isLightProbe = true;

	class MaterialLoader extends Loader {
		constructor(manager) {
			super(manager);
			this.textures = {};
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const loader = new FileLoader(scope.manager);
			loader.setPath(scope.path);
			loader.setRequestHeader(scope.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function (text) {
				try {
					onLoad(scope.parse(JSON.parse(text)));
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}

					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		}

		parse(json) {
			const textures = this.textures;

			function getTexture(name) {
				if (textures[name] === undefined) {
					console.warn('THREE.MaterialLoader: Undefined texture', name);
				}

				return textures[name];
			}

			const material = new Materials[json.type]();
			if (json.uuid !== undefined) material.uuid = json.uuid;
			if (json.name !== undefined) material.name = json.name;
			if (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);
			if (json.roughness !== undefined) material.roughness = json.roughness;
			if (json.metalness !== undefined) material.metalness = json.metalness;
			if (json.sheen !== undefined) material.sheen = json.sheen;
			if (json.sheenColor !== undefined) material.sheenColor = new Color().setHex(json.sheenColor);
			if (json.sheenRoughness !== undefined) material.sheenRoughness = json.sheenRoughness;
			if (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);
			if (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);
			if (json.specularIntensity !== undefined) material.specularIntensity = json.specularIntensity;
			if (json.specularColor !== undefined && material.specularColor !== undefined) material.specularColor.setHex(json.specularColor);
			if (json.shininess !== undefined) material.shininess = json.shininess;
			if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
			if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
			if (json.transmission !== undefined) material.transmission = json.transmission;
			if (json.thickness !== undefined) material.thickness = json.thickness;
			if (json.attenuationDistance !== undefined) material.attenuationDistance = json.attenuationDistance;
			if (json.attenuationColor !== undefined && material.attenuationColor !== undefined) material.attenuationColor.setHex(json.attenuationColor);
			if (json.fog !== undefined) material.fog = json.fog;
			if (json.flatShading !== undefined) material.flatShading = json.flatShading;
			if (json.blending !== undefined) material.blending = json.blending;
			if (json.combine !== undefined) material.combine = json.combine;
			if (json.side !== undefined) material.side = json.side;
			if (json.shadowSide !== undefined) material.shadowSide = json.shadowSide;
			if (json.opacity !== undefined) material.opacity = json.opacity;
			if (json.format !== undefined) material.format = json.format;
			if (json.transparent !== undefined) material.transparent = json.transparent;
			if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
			if (json.depthTest !== undefined) material.depthTest = json.depthTest;
			if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
			if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
			if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
			if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
			if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
			if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
			if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
			if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
			if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
			if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
			if (json.wireframe !== undefined) material.wireframe = json.wireframe;
			if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
			if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
			if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
			if (json.rotation !== undefined) material.rotation = json.rotation;
			if (json.linewidth !== 1) material.linewidth = json.linewidth;
			if (json.dashSize !== undefined) material.dashSize = json.dashSize;
			if (json.gapSize !== undefined) material.gapSize = json.gapSize;
			if (json.scale !== undefined) material.scale = json.scale;
			if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
			if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
			if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
			if (json.dithering !== undefined) material.dithering = json.dithering;
			if (json.alphaToCoverage !== undefined) material.alphaToCoverage = json.alphaToCoverage;
			if (json.premultipliedAlpha !== undefined) material.premultipliedAlpha = json.premultipliedAlpha;
			if (json.visible !== undefined) material.visible = json.visible;
			if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
			if (json.userData !== undefined) material.userData = json.userData;

			if (json.vertexColors !== undefined) {
				if (typeof json.vertexColors === 'number') {
					material.vertexColors = json.vertexColors > 0 ? true : false;
				} else {
					material.vertexColors = json.vertexColors;
				}
			} // Shader Material


			if (json.uniforms !== undefined) {
				for (const name in json.uniforms) {
					const uniform = json.uniforms[name];
					material.uniforms[name] = {};

					switch (uniform.type) {
						case 't':
							material.uniforms[name].value = getTexture(uniform.value);
							break;

						case 'c':
							material.uniforms[name].value = new Color().setHex(uniform.value);
							break;

						case 'v2':
							material.uniforms[name].value = new Vector2().fromArray(uniform.value);
							break;

						case 'v3':
							material.uniforms[name].value = new Vector3().fromArray(uniform.value);
							break;

						case 'v4':
							material.uniforms[name].value = new Vector4().fromArray(uniform.value);
							break;

						case 'm3':
							material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
							break;

						case 'm4':
							material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
							break;

						default:
							material.uniforms[name].value = uniform.value;
					}
				}
			}

			if (json.defines !== undefined) material.defines = json.defines;
			if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
			if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;

			if (json.extensions !== undefined) {
				for (const key in json.extensions) {
					material.extensions[key] = json.extensions[key];
				}
			} // Deprecated


			if (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading
			// for PointsMaterial

			if (json.size !== undefined) material.size = json.size;
			if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation; // maps

			if (json.map !== undefined) material.map = getTexture(json.map);
			if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
			if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
			if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
			if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
			if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
			if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;

			if (json.normalScale !== undefined) {
				let normalScale = json.normalScale;

				if (Array.isArray(normalScale) === false) {
					// Blender exporter used to export a scalar. See #7459
					normalScale = [normalScale, normalScale];
				}

				material.normalScale = new Vector2().fromArray(normalScale);
			}

			if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
			if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
			if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
			if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
			if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
			if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
			if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
			if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
			if (json.specularIntensityMap !== undefined) material.specularIntensityMap = getTexture(json.specularIntensityMap);
			if (json.specularColorMap !== undefined) material.specularColorMap = getTexture(json.specularColorMap);
			if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
			if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
			if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
			if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
			if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
			if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
			if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
			if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
			if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
			if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
			if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
			if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
			if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
			if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);
			if (json.thicknessMap !== undefined) material.thicknessMap = getTexture(json.thicknessMap);
			if (json.sheenColorMap !== undefined) material.sheenColorMap = getTexture(json.sheenColorMap);
			if (json.sheenRoughnessMap !== undefined) material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);
			return material;
		}

		setTextures(value) {
			this.textures = value;
			return this;
		}

	}

	class LoaderUtils {
		static decodeText(array) {
			if (typeof TextDecoder !== 'undefined') {
				return new TextDecoder().decode(array);
			} // Avoid the String.fromCharCode.apply(null, array) shortcut, which
			// throws a "maximum call stack size exceeded" error for large arrays.


			let s = '';

			for (let i = 0, il = array.length; i < il; i++) {
				// Implicitly assumes little-endian.
				s += String.fromCharCode(array[i]);
			}

			try {
				// merges multi-byte utf-8 characters.
				return decodeURIComponent(escape(s));
			} catch (e) {
				// see #16358
				return s;
			}
		}

		static extractUrlBase(url) {
			const index = url.lastIndexOf('/');
			if (index === -1) return './';
			return url.substr(0, index + 1);
		}

		static resolveURL(url, path) {
			// Invalid URL
			if (typeof url !== 'string' || url === '') return ''; // Host Relative URL

			if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
				path = path.replace(/(^https?:\/\/[^\/]+).*/i, '$1');
			} // Absolute URL http://,https://,//


			if (/^(https?:)?\/\//i.test(url)) return url; // Data URI

			if (/^data:.*,.*$/i.test(url)) return url; // Blob URL

			if (/^blob:.*$/i.test(url)) return url; // Relative URL

			return path + url;
		}

	}

	class InstancedBufferGeometry extends BufferGeometry {
		constructor() {
			super();
			this.type = 'InstancedBufferGeometry';
			this.instanceCount = Infinity;
		}

		copy(source) {
			super.copy(source);
			this.instanceCount = source.instanceCount;
			return this;
		}

		clone() {
			return new this.constructor().copy(this);
		}

		toJSON() {
			const data = super.toJSON(this);
			data.instanceCount = this.instanceCount;
			data.isInstancedBufferGeometry = true;
			return data;
		}

	}

	InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;

	class BufferGeometryLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const loader = new FileLoader(scope.manager);
			loader.setPath(scope.path);
			loader.setRequestHeader(scope.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function (text) {
				try {
					onLoad(scope.parse(JSON.parse(text)));
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}

					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		}

		parse(json) {
			const interleavedBufferMap = {};
			const arrayBufferMap = {};

			function getInterleavedBuffer(json, uuid) {
				if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
				const interleavedBuffers = json.interleavedBuffers;
				const interleavedBuffer = interleavedBuffers[uuid];
				const buffer = getArrayBuffer(json, interleavedBuffer.buffer);
				const array = getTypedArray(interleavedBuffer.type, buffer);
				const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
				ib.uuid = interleavedBuffer.uuid;
				interleavedBufferMap[uuid] = ib;
				return ib;
			}

			function getArrayBuffer(json, uuid) {
				if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
				const arrayBuffers = json.arrayBuffers;
				const arrayBuffer = arrayBuffers[uuid];
				const ab = new Uint32Array(arrayBuffer).buffer;
				arrayBufferMap[uuid] = ab;
				return ab;
			}

			const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
			const index = json.data.index;

			if (index !== undefined) {
				const typedArray = getTypedArray(index.type, index.array);
				geometry.setIndex(new BufferAttribute(typedArray, 1));
			}

			const attributes = json.data.attributes;

			for (const key in attributes) {
				const attribute = attributes[key];
				let bufferAttribute;

				if (attribute.isInterleavedBufferAttribute) {
					const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
					bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
				} else {
					const typedArray = getTypedArray(attribute.type, attribute.array);
					const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
					bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
				}

				if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
				if (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage);

				if (attribute.updateRange !== undefined) {
					bufferAttribute.updateRange.offset = attribute.updateRange.offset;
					bufferAttribute.updateRange.count = attribute.updateRange.count;
				}

				geometry.setAttribute(key, bufferAttribute);
			}

			const morphAttributes = json.data.morphAttributes;

			if (morphAttributes) {
				for (const key in morphAttributes) {
					const attributeArray = morphAttributes[key];
					const array = [];

					for (let i = 0, il = attributeArray.length; i < il; i++) {
						const attribute = attributeArray[i];
						let bufferAttribute;

						if (attribute.isInterleavedBufferAttribute) {
							const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
							bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
						} else {
							const typedArray = getTypedArray(attribute.type, attribute.array);
							bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
						}

						if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
						array.push(bufferAttribute);
					}

					geometry.morphAttributes[key] = array;
				}
			}

			const morphTargetsRelative = json.data.morphTargetsRelative;

			if (morphTargetsRelative) {
				geometry.morphTargetsRelative = true;
			}

			const groups = json.data.groups || json.data.drawcalls || json.data.offsets;

			if (groups !== undefined) {
				for (let i = 0, n = groups.length; i !== n; ++i) {
					const group = groups[i];
					geometry.addGroup(group.start, group.count, group.materialIndex);
				}
			}

			const boundingSphere = json.data.boundingSphere;

			if (boundingSphere !== undefined) {
				const center = new Vector3();

				if (boundingSphere.center !== undefined) {
					center.fromArray(boundingSphere.center);
				}

				geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
			}

			if (json.name) geometry.name = json.name;
			if (json.userData) geometry.userData = json.userData;
			return geometry;
		}

	}

	class ObjectLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
			this.resourcePath = this.resourcePath || path;
			const loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(this.withCredentials);
			loader.load(url, function (text) {
				let json = null;

				try {
					json = JSON.parse(text);
				} catch (error) {
					if (onError !== undefined) onError(error);
					console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
					return;
				}

				const metadata = json.metadata;

				if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
					console.error('THREE.ObjectLoader: Can\'t load ' + url);
					return;
				}

				scope.parse(json, onLoad);
			}, onProgress, onError);
		}

		async loadAsync(url, onProgress) {
			const scope = this;
			const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
			this.resourcePath = this.resourcePath || path;
			const loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(this.withCredentials);
			const text = await loader.loadAsync(url, onProgress);
			const json = JSON.parse(text);
			const metadata = json.metadata;

			if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
				throw new Error('THREE.ObjectLoader: Can\'t load ' + url);
			}

			return await scope.parseAsync(json);
		}

		parse(json, onLoad) {
			const animations = this.parseAnimations(json.animations);
			const shapes = this.parseShapes(json.shapes);
			const geometries = this.parseGeometries(json.geometries, shapes);
			const images = this.parseImages(json.images, function () {
				if (onLoad !== undefined) onLoad(object);
			});
			const textures = this.parseTextures(json.textures, images);
			const materials = this.parseMaterials(json.materials, textures);
			const object = this.parseObject(json.object, geometries, materials, textures, animations);
			const skeletons = this.parseSkeletons(json.skeletons, object);
			this.bindSkeletons(object, skeletons); //

			if (onLoad !== undefined) {
				let hasImages = false;

				for (const uuid in images) {
					if (images[uuid] instanceof HTMLImageElement) {
						hasImages = true;
						break;
					}
				}

				if (hasImages === false) onLoad(object);
			}

			return object;
		}

		async parseAsync(json) {
			const animations = this.parseAnimations(json.animations);
			const shapes = this.parseShapes(json.shapes);
			const geometries = this.parseGeometries(json.geometries, shapes);
			const images = await this.parseImagesAsync(json.images);
			const textures = this.parseTextures(json.textures, images);
			const materials = this.parseMaterials(json.materials, textures);
			const object = this.parseObject(json.object, geometries, materials, textures, animations);
			const skeletons = this.parseSkeletons(json.skeletons, object);
			this.bindSkeletons(object, skeletons);
			return object;
		}

		parseShapes(json) {
			const shapes = {};

			if (json !== undefined) {
				for (let i = 0, l = json.length; i < l; i++) {
					const shape = new Shape().fromJSON(json[i]);
					shapes[shape.uuid] = shape;
				}
			}

			return shapes;
		}

		parseSkeletons(json, object) {
			const skeletons = {};
			const bones = {}; // generate bone lookup table

			object.traverse(function (child) {
				if (child.isBone) bones[child.uuid] = child;
			}); // create skeletons

			if (json !== undefined) {
				for (let i = 0, l = json.length; i < l; i++) {
					const skeleton = new Skeleton().fromJSON(json[i], bones);
					skeletons[skeleton.uuid] = skeleton;
				}
			}

			return skeletons;
		}

		parseGeometries(json, shapes) {
			const geometries = {};

			if (json !== undefined) {
				const bufferGeometryLoader = new BufferGeometryLoader();

				for (let i = 0, l = json.length; i < l; i++) {
					let geometry;
					const data = json[i];

					switch (data.type) {
						case 'BufferGeometry':
						case 'InstancedBufferGeometry':
							geometry = bufferGeometryLoader.parse(data);
							break;

						case 'Geometry':
							console.error('THREE.ObjectLoader: The legacy Geometry type is no longer supported.');
							break;

						default:
							if (data.type in Geometries) {
								geometry = Geometries[data.type].fromJSON(data, shapes);
							} else {
								console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`);
							}

					}

					geometry.uuid = data.uuid;
					if (data.name !== undefined) geometry.name = data.name;
					if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;
					geometries[data.uuid] = geometry;
				}
			}

			return geometries;
		}

		parseMaterials(json, textures) {
			const cache = {}; // MultiMaterial

			const materials = {};

			if (json !== undefined) {
				const loader = new MaterialLoader();
				loader.setTextures(textures);

				for (let i = 0, l = json.length; i < l; i++) {
					const data = json[i];

					if (data.type === 'MultiMaterial') {
						// Deprecated
						const array = [];

						for (let j = 0; j < data.materials.length; j++) {
							const material = data.materials[j];

							if (cache[material.uuid] === undefined) {
								cache[material.uuid] = loader.parse(material);
							}

							array.push(cache[material.uuid]);
						}

						materials[data.uuid] = array;
					} else {
						if (cache[data.uuid] === undefined) {
							cache[data.uuid] = loader.parse(data);
						}

						materials[data.uuid] = cache[data.uuid];
					}
				}
			}

			return materials;
		}

		parseAnimations(json) {
			const animations = {};

			if (json !== undefined) {
				for (let i = 0; i < json.length; i++) {
					const data = json[i];
					const clip = AnimationClip.parse(data);
					animations[clip.uuid] = clip;
				}
			}

			return animations;
		}

		parseImages(json, onLoad) {
			const scope = this;
			const images = {};
			let loader;

			function loadImage(url) {
				scope.manager.itemStart(url);
				return loader.load(url, function () {
					scope.manager.itemEnd(url);
				}, undefined, function () {
					scope.manager.itemError(url);
					scope.manager.itemEnd(url);
				});
			}

			function deserializeImage(image) {
				if (typeof image === 'string') {
					const url = image;
					const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
					return loadImage(path);
				} else {
					if (image.data) {
						return {
							data: getTypedArray(image.type, image.data),
							width: image.width,
							height: image.height
						};
					} else {
						return null;
					}
				}
			}

			if (json !== undefined && json.length > 0) {
				const manager = new LoadingManager(onLoad);
				loader = new ImageLoader(manager);
				loader.setCrossOrigin(this.crossOrigin);

				for (let i = 0, il = json.length; i < il; i++) {
					const image = json[i];
					const url = image.url;

					if (Array.isArray(url)) {
						// load array of images e.g CubeTexture
						images[image.uuid] = [];

						for (let j = 0, jl = url.length; j < jl; j++) {
							const currentUrl = url[j];
							const deserializedImage = deserializeImage(currentUrl);

							if (deserializedImage !== null) {
								if (deserializedImage instanceof HTMLImageElement) {
									images[image.uuid].push(deserializedImage);
								} else {
									// special case: handle array of data textures for cube textures
									images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
								}
							}
						}
					} else {
						// load single image
						const deserializedImage = deserializeImage(image.url);

						if (deserializedImage !== null) {
							images[image.uuid] = deserializedImage;
						}
					}
				}
			}

			return images;
		}

		async parseImagesAsync(json) {
			const scope = this;
			const images = {};
			let loader;

			async function deserializeImage(image) {
				if (typeof image === 'string') {
					const url = image;
					const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
					return await loader.loadAsync(path);
				} else {
					if (image.data) {
						return {
							data: getTypedArray(image.type, image.data),
							width: image.width,
							height: image.height
						};
					} else {
						return null;
					}
				}
			}

			if (json !== undefined && json.length > 0) {
				loader = new ImageLoader(this.manager);
				loader.setCrossOrigin(this.crossOrigin);

				for (let i = 0, il = json.length; i < il; i++) {
					const image = json[i];
					const url = image.url;

					if (Array.isArray(url)) {
						// load array of images e.g CubeTexture
						images[image.uuid] = [];

						for (let j = 0, jl = url.length; j < jl; j++) {
							const currentUrl = url[j];
							const deserializedImage = await deserializeImage(currentUrl);

							if (deserializedImage !== null) {
								if (deserializedImage instanceof HTMLImageElement) {
									images[image.uuid].push(deserializedImage);
								} else {
									// special case: handle array of data textures for cube textures
									images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
								}
							}
						}
					} else {
						// load single image
						const deserializedImage = await deserializeImage(image.url);

						if (deserializedImage !== null) {
							images[image.uuid] = deserializedImage;
						}
					}
				}
			}

			return images;
		}

		parseTextures(json, images) {
			function parseConstant(value, type) {
				if (typeof value === 'number') return value;
				console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
				return type[value];
			}

			const textures = {};

			if (json !== undefined) {
				for (let i = 0, l = json.length; i < l; i++) {
					const data = json[i];

					if (data.image === undefined) {
						console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
					}

					if (images[data.image] === undefined) {
						console.warn('THREE.ObjectLoader: Undefined image', data.image);
					}

					let texture;
					const image = images[data.image];

					if (Array.isArray(image)) {
						texture = new CubeTexture(image);
						if (image.length === 6) texture.needsUpdate = true;
					} else {
						if (image && image.data) {
							texture = new DataTexture(image.data, image.width, image.height);
						} else {
							texture = new Texture(image);
						}

						if (image) texture.needsUpdate = true; // textures can have undefined image data
					}

					texture.uuid = data.uuid;
					if (data.name !== undefined) texture.name = data.name;
					if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
					if (data.offset !== undefined) texture.offset.fromArray(data.offset);
					if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
					if (data.center !== undefined) texture.center.fromArray(data.center);
					if (data.rotation !== undefined) texture.rotation = data.rotation;

					if (data.wrap !== undefined) {
						texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
						texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
					}

					if (data.format !== undefined) texture.format = data.format;
					if (data.type !== undefined) texture.type = data.type;
					if (data.encoding !== undefined) texture.encoding = data.encoding;
					if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
					if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
					if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
					if (data.flipY !== undefined) texture.flipY = data.flipY;
					if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
					if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
					if (data.userData !== undefined) texture.userData = data.userData;
					textures[data.uuid] = texture;
				}
			}

			return textures;
		}

		parseObject(data, geometries, materials, textures, animations) {
			let object;

			function getGeometry(name) {
				if (geometries[name] === undefined) {
					console.warn('THREE.ObjectLoader: Undefined geometry', name);
				}

				return geometries[name];
			}

			function getMaterial(name) {
				if (name === undefined) return undefined;

				if (Array.isArray(name)) {
					const array = [];

					for (let i = 0, l = name.length; i < l; i++) {
						const uuid = name[i];

						if (materials[uuid] === undefined) {
							console.warn('THREE.ObjectLoader: Undefined material', uuid);
						}

						array.push(materials[uuid]);
					}

					return array;
				}

				if (materials[name] === undefined) {
					console.warn('THREE.ObjectLoader: Undefined material', name);
				}

				return materials[name];
			}

			function getTexture(uuid) {
				if (textures[uuid] === undefined) {
					console.warn('THREE.ObjectLoader: Undefined texture', uuid);
				}

				return textures[uuid];
			}

			let geometry, material;

			switch (data.type) {
				case 'Scene':
					object = new Scene();

					if (data.background !== undefined) {
						if (Number.isInteger(data.background)) {
							object.background = new Color(data.background);
						} else {
							object.background = getTexture(data.background);
						}
					}

					if (data.environment !== undefined) {
						object.environment = getTexture(data.environment);
					}

					if (data.fog !== undefined) {
						if (data.fog.type === 'Fog') {
							object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
						} else if (data.fog.type === 'FogExp2') {
							object.fog = new FogExp2(data.fog.color, data.fog.density);
						}
					}

					break;

				case 'PerspectiveCamera':
					object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
					if (data.focus !== undefined) object.focus = data.focus;
					if (data.zoom !== undefined) object.zoom = data.zoom;
					if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
					if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
					if (data.view !== undefined) object.view = Object.assign({}, data.view);
					break;

				case 'OrthographicCamera':
					object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
					if (data.zoom !== undefined) object.zoom = data.zoom;
					if (data.view !== undefined) object.view = Object.assign({}, data.view);
					break;

				case 'AmbientLight':
					object = new AmbientLight(data.color, data.intensity);
					break;

				case 'DirectionalLight':
					object = new DirectionalLight(data.color, data.intensity);
					break;

				case 'PointLight':
					object = new PointLight(data.color, data.intensity, data.distance, data.decay);
					break;

				case 'RectAreaLight':
					object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
					break;

				case 'SpotLight':
					object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
					break;

				case 'HemisphereLight':
					object = new HemisphereLight(data.color, data.groundColor, data.intensity);
					break;

				case 'LightProbe':
					object = new LightProbe().fromJSON(data);
					break;

				case 'SkinnedMesh':
					geometry = getGeometry(data.geometry);
					material = getMaterial(data.material);
					object = new SkinnedMesh(geometry, material);
					if (data.bindMode !== undefined) object.bindMode = data.bindMode;
					if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);
					if (data.skeleton !== undefined) object.skeleton = data.skeleton;
					break;

				case 'Mesh':
					geometry = getGeometry(data.geometry);
					material = getMaterial(data.material);
					object = new Mesh(geometry, material);
					break;

				case 'InstancedMesh':
					geometry = getGeometry(data.geometry);
					material = getMaterial(data.material);
					const count = data.count;
					const instanceMatrix = data.instanceMatrix;
					const instanceColor = data.instanceColor;
					object = new InstancedMesh(geometry, material, count);
					object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);
					if (instanceColor !== undefined) object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
					break;

				case 'LOD':
					object = new LOD();
					break;

				case 'Line':
					object = new Line(getGeometry(data.geometry), getMaterial(data.material));
					break;

				case 'LineLoop':
					object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
					break;

				case 'LineSegments':
					object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
					break;

				case 'PointCloud':
				case 'Points':
					object = new Points(getGeometry(data.geometry), getMaterial(data.material));
					break;

				case 'Sprite':
					object = new Sprite(getMaterial(data.material));
					break;

				case 'Group':
					object = new Group();
					break;

				case 'Bone':
					object = new Bone();
					break;

				default:
					object = new Object3D();
			}

			object.uuid = data.uuid;
			if (data.name !== undefined) object.name = data.name;

			if (data.matrix !== undefined) {
				object.matrix.fromArray(data.matrix);
				if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
				if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
			} else {
				if (data.position !== undefined) object.position.fromArray(data.position);
				if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
				if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
				if (data.scale !== undefined) object.scale.fromArray(data.scale);
			}

			if (data.castShadow !== undefined) object.castShadow = data.castShadow;
			if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;

			if (data.shadow) {
				if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
				if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
				if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
				if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
				if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
			}

			if (data.visible !== undefined) object.visible = data.visible;
			if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
			if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
			if (data.userData !== undefined) object.userData = data.userData;
			if (data.layers !== undefined) object.layers.mask = data.layers;

			if (data.children !== undefined) {
				const children = data.children;

				for (let i = 0; i < children.length; i++) {
					object.add(this.parseObject(children[i], geometries, materials, textures, animations));
				}
			}

			if (data.animations !== undefined) {
				const objectAnimations = data.animations;

				for (let i = 0; i < objectAnimations.length; i++) {
					const uuid = objectAnimations[i];
					object.animations.push(animations[uuid]);
				}
			}

			if (data.type === 'LOD') {
				if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
				const levels = data.levels;

				for (let l = 0; l < levels.length; l++) {
					const level = levels[l];
					const child = object.getObjectByProperty('uuid', level.object);

					if (child !== undefined) {
						object.addLevel(child, level.distance);
					}
				}
			}

			return object;
		}

		bindSkeletons(object, skeletons) {
			if (Object.keys(skeletons).length === 0) return;
			object.traverse(function (child) {
				if (child.isSkinnedMesh === true && child.skeleton !== undefined) {
					const skeleton = skeletons[child.skeleton];

					if (skeleton === undefined) {
						console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);
					} else {
						child.bind(skeleton, child.bindMatrix);
					}
				}
			});
		}
		/* DEPRECATED */


		setTexturePath(value) {
			console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');
			return this.setResourcePath(value);
		}

	}

	const TEXTURE_MAPPING = {
		UVMapping: UVMapping,
		CubeReflectionMapping: CubeReflectionMapping,
		CubeRefractionMapping: CubeRefractionMapping,
		EquirectangularReflectionMapping: EquirectangularReflectionMapping,
		EquirectangularRefractionMapping: EquirectangularRefractionMapping,
		CubeUVReflectionMapping: CubeUVReflectionMapping,
		CubeUVRefractionMapping: CubeUVRefractionMapping
	};
	const TEXTURE_WRAPPING = {
		RepeatWrapping: RepeatWrapping,
		ClampToEdgeWrapping: ClampToEdgeWrapping,
		MirroredRepeatWrapping: MirroredRepeatWrapping
	};
	const TEXTURE_FILTER = {
		NearestFilter: NearestFilter,
		NearestMipmapNearestFilter: NearestMipmapNearestFilter,
		NearestMipmapLinearFilter: NearestMipmapLinearFilter,
		LinearFilter: LinearFilter,
		LinearMipmapNearestFilter: LinearMipmapNearestFilter,
		LinearMipmapLinearFilter: LinearMipmapLinearFilter
	};

	class ImageBitmapLoader extends Loader {
		constructor(manager) {
			super(manager);

			if (typeof createImageBitmap === 'undefined') {
				console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
			}

			if (typeof fetch === 'undefined') {
				console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
			}

			this.options = {
				premultiplyAlpha: 'none'
			};
		}

		setOptions(options) {
			this.options = options;
			return this;
		}

		load(url, onLoad, onProgress, onError) {
			if (url === undefined) url = '';
			if (this.path !== undefined) url = this.path + url;
			url = this.manager.resolveURL(url);
			const scope = this;
			const cached = Cache.get(url);

			if (cached !== undefined) {
				scope.manager.itemStart(url);
				setTimeout(function () {
					if (onLoad) onLoad(cached);
					scope.manager.itemEnd(url);
				}, 0);
				return cached;
			}

			const fetchOptions = {};
			fetchOptions.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include';
			fetchOptions.headers = this.requestHeader;
			fetch(url, fetchOptions).then(function (res) {
				return res.blob();
			}).then(function (blob) {
				return createImageBitmap(blob, Object.assign(scope.options, {
					colorSpaceConversion: 'none'
				}));
			}).then(function (imageBitmap) {
				Cache.add(url, imageBitmap);
				if (onLoad) onLoad(imageBitmap);
				scope.manager.itemEnd(url);
			}).catch(function (e) {
				if (onError) onError(e);
				scope.manager.itemError(url);
				scope.manager.itemEnd(url);
			});
			scope.manager.itemStart(url);
		}

	}

	ImageBitmapLoader.prototype.isImageBitmapLoader = true;

	let _context;

	const AudioContext = {
		getContext: function () {
			if (_context === undefined) {
				_context = new (window.AudioContext || window.webkitAudioContext)();
			}

			return _context;
		},
		setContext: function (value) {
			_context = value;
		}
	};

	class AudioLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const loader = new FileLoader(this.manager);
			loader.setResponseType('arraybuffer');
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(this.withCredentials);
			loader.load(url, function (buffer) {
				try {
					// Create a copy of the buffer. The `decodeAudioData` method
					// detaches the buffer when complete, preventing reuse.
					const bufferCopy = buffer.slice(0);
					const context = AudioContext.getContext();
					context.decodeAudioData(bufferCopy, function (audioBuffer) {
						onLoad(audioBuffer);
					});
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}

					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		}

	}

	class HemisphereLightProbe extends LightProbe {
		constructor(skyColor, groundColor, intensity = 1) {
			super(undefined, intensity);
			const color1 = new Color().set(skyColor);
			const color2 = new Color().set(groundColor);
			const sky = new Vector3(color1.r, color1.g, color1.b);
			const ground = new Vector3(color2.r, color2.g, color2.b); // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );

			const c0 = Math.sqrt(Math.PI);
			const c1 = c0 * Math.sqrt(0.75);
			this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
			this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
		}

	}

	HemisphereLightProbe.prototype.isHemisphereLightProbe = true;

	class AmbientLightProbe extends LightProbe {
		constructor(color, intensity = 1) {
			super(undefined, intensity);
			const color1 = new Color().set(color); // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );

			this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
		}

	}

	AmbientLightProbe.prototype.isAmbientLightProbe = true;

	const _eyeRight = /*@__PURE__*/new Matrix4();

	const _eyeLeft = /*@__PURE__*/new Matrix4();

	const _projectionMatrix = /*@__PURE__*/new Matrix4();

	class StereoCamera {
		constructor() {
			this.type = 'StereoCamera';
			this.aspect = 1;
			this.eyeSep = 0.064;
			this.cameraL = new PerspectiveCamera();
			this.cameraL.layers.enable(1);
			this.cameraL.matrixAutoUpdate = false;
			this.cameraR = new PerspectiveCamera();
			this.cameraR.layers.enable(2);
			this.cameraR.matrixAutoUpdate = false;
			this._cache = {
				focus: null,
				fov: null,
				aspect: null,
				near: null,
				far: null,
				zoom: null,
				eyeSep: null
			};
		}

		update(camera) {
			const cache = this._cache;
			const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

			if (needsUpdate) {
				cache.focus = camera.focus;
				cache.fov = camera.fov;
				cache.aspect = camera.aspect * this.aspect;
				cache.near = camera.near;
				cache.far = camera.far;
				cache.zoom = camera.zoom;
				cache.eyeSep = this.eyeSep; // Off-axis stereoscopic effect based on
				// http://paulbourke.net/stereographics/stereorender/

				_projectionMatrix.copy(camera.projectionMatrix);

				const eyeSepHalf = cache.eyeSep / 2;
				const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
				const ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;
				let xmin, xmax; // translate xOffset

				_eyeLeft.elements[12] = -eyeSepHalf;
				_eyeRight.elements[12] = eyeSepHalf; // for left eye

				xmin = -ymax * cache.aspect + eyeSepOnProjection;
				xmax = ymax * cache.aspect + eyeSepOnProjection;
				_projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
				_projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
				this.cameraL.projectionMatrix.copy(_projectionMatrix); // for right eye

				xmin = -ymax * cache.aspect - eyeSepOnProjection;
				xmax = ymax * cache.aspect - eyeSepOnProjection;
				_projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
				_projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
				this.cameraR.projectionMatrix.copy(_projectionMatrix);
			}

			this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
			this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
		}

	}

	class Clock {
		constructor(autoStart = true) {
			this.autoStart = autoStart;
			this.startTime = 0;
			this.oldTime = 0;
			this.elapsedTime = 0;
			this.running = false;
		}

		start() {
			this.startTime = now();
			this.oldTime = this.startTime;
			this.elapsedTime = 0;
			this.running = true;
		}

		stop() {
			this.getElapsedTime();
			this.running = false;
			this.autoStart = false;
		}

		getElapsedTime() {
			this.getDelta();
			return this.elapsedTime;
		}

		getDelta() {
			let diff = 0;

			if (this.autoStart && !this.running) {
				this.start();
				return 0;
			}

			if (this.running) {
				const newTime = now();
				diff = (newTime - this.oldTime) / 1000;
				this.oldTime = newTime;
				this.elapsedTime += diff;
			}

			return diff;
		}

	}

	function now() {
		return (typeof performance === 'undefined' ? Date : performance).now(); // see #10732
	}

	const _position$1 = /*@__PURE__*/new Vector3();

	const _quaternion$1 = /*@__PURE__*/new Quaternion();

	const _scale$1 = /*@__PURE__*/new Vector3();

	const _orientation$1 = /*@__PURE__*/new Vector3();

	class AudioListener extends Object3D {
		constructor() {
			super();
			this.type = 'AudioListener';
			this.context = AudioContext.getContext();
			this.gain = this.context.createGain();
			this.gain.connect(this.context.destination);
			this.filter = null;
			this.timeDelta = 0; // private

			this._clock = new Clock();
		}

		getInput() {
			return this.gain;
		}

		removeFilter() {
			if (this.filter !== null) {
				this.gain.disconnect(this.filter);
				this.filter.disconnect(this.context.destination);
				this.gain.connect(this.context.destination);
				this.filter = null;
			}

			return this;
		}

		getFilter() {
			return this.filter;
		}

		setFilter(value) {
			if (this.filter !== null) {
				this.gain.disconnect(this.filter);
				this.filter.disconnect(this.context.destination);
			} else {
				this.gain.disconnect(this.context.destination);
			}

			this.filter = value;
			this.gain.connect(this.filter);
			this.filter.connect(this.context.destination);
			return this;
		}

		getMasterVolume() {
			return this.gain.gain.value;
		}

		setMasterVolume(value) {
			this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
			return this;
		}

		updateMatrixWorld(force) {
			super.updateMatrixWorld(force);
			const listener = this.context.listener;
			const up = this.up;
			this.timeDelta = this._clock.getDelta();
			this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);

			_orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);

			if (listener.positionX) {
				// code path for Chrome (see #14393)
				const endTime = this.context.currentTime + this.timeDelta;
				listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
				listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
				listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
				listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
				listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
				listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
				listener.upX.linearRampToValueAtTime(up.x, endTime);
				listener.upY.linearRampToValueAtTime(up.y, endTime);
				listener.upZ.linearRampToValueAtTime(up.z, endTime);
			} else {
				listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
				listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
			}
		}

	}

	class Audio extends Object3D {
		constructor(listener) {
			super();
			this.type = 'Audio';
			this.listener = listener;
			this.context = listener.context;
			this.gain = this.context.createGain();
			this.gain.connect(listener.getInput());
			this.autoplay = false;
			this.buffer = null;
			this.detune = 0;
			this.loop = false;
			this.loopStart = 0;
			this.loopEnd = 0;
			this.offset = 0;
			this.duration = undefined;
			this.playbackRate = 1;
			this.isPlaying = false;
			this.hasPlaybackControl = true;
			this.source = null;
			this.sourceType = 'empty';
			this._startedAt = 0;
			this._progress = 0;
			this._connected = false;
			this.filters = [];
		}

		getOutput() {
			return this.gain;
		}

		setNodeSource(audioNode) {
			this.hasPlaybackControl = false;
			this.sourceType = 'audioNode';
			this.source = audioNode;
			this.connect();
			return this;
		}

		setMediaElementSource(mediaElement) {
			this.hasPlaybackControl = false;
			this.sourceType = 'mediaNode';
			this.source = this.context.createMediaElementSource(mediaElement);
			this.connect();
			return this;
		}

		setMediaStreamSource(mediaStream) {
			this.hasPlaybackControl = false;
			this.sourceType = 'mediaStreamNode';
			this.source = this.context.createMediaStreamSource(mediaStream);
			this.connect();
			return this;
		}

		setBuffer(audioBuffer) {
			this.buffer = audioBuffer;
			this.sourceType = 'buffer';
			if (this.autoplay) this.play();
			return this;
		}

		play(delay = 0) {
			if (this.isPlaying === true) {
				console.warn('THREE.Audio: Audio is already playing.');
				return;
			}

			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this._startedAt = this.context.currentTime + delay;
			const source = this.context.createBufferSource();
			source.buffer = this.buffer;
			source.loop = this.loop;
			source.loopStart = this.loopStart;
			source.loopEnd = this.loopEnd;
			source.onended = this.onEnded.bind(this);
			source.start(this._startedAt, this._progress + this.offset, this.duration);
			this.isPlaying = true;
			this.source = source;
			this.setDetune(this.detune);
			this.setPlaybackRate(this.playbackRate);
			return this.connect();
		}

		pause() {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			if (this.isPlaying === true) {
				// update current progress
				this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;

				if (this.loop === true) {
					// ensure _progress does not exceed duration with looped audios
					this._progress = this._progress % (this.duration || this.buffer.duration);
				}

				this.source.stop();
				this.source.onended = null;
				this.isPlaying = false;
			}

			return this;
		}

		stop() {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this._progress = 0;
			this.source.stop();
			this.source.onended = null;
			this.isPlaying = false;
			return this;
		}

		connect() {
			if (this.filters.length > 0) {
				this.source.connect(this.filters[0]);

				for (let i = 1, l = this.filters.length; i < l; i++) {
					this.filters[i - 1].connect(this.filters[i]);
				}

				this.filters[this.filters.length - 1].connect(this.getOutput());
			} else {
				this.source.connect(this.getOutput());
			}

			this._connected = true;
			return this;
		}

		disconnect() {
			if (this.filters.length > 0) {
				this.source.disconnect(this.filters[0]);

				for (let i = 1, l = this.filters.length; i < l; i++) {
					this.filters[i - 1].disconnect(this.filters[i]);
				}

				this.filters[this.filters.length - 1].disconnect(this.getOutput());
			} else {
				this.source.disconnect(this.getOutput());
			}

			this._connected = false;
			return this;
		}

		getFilters() {
			return this.filters;
		}

		setFilters(value) {
			if (!value) value = [];

			if (this._connected === true) {
				this.disconnect();
				this.filters = value.slice();
				this.connect();
			} else {
				this.filters = value.slice();
			}

			return this;
		}

		setDetune(value) {
			this.detune = value;
			if (this.source.detune === undefined) return; // only set detune when available

			if (this.isPlaying === true) {
				this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
			}

			return this;
		}

		getDetune() {
			return this.detune;
		}

		getFilter() {
			return this.getFilters()[0];
		}

		setFilter(filter) {
			return this.setFilters(filter ? [filter] : []);
		}

		setPlaybackRate(value) {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this.playbackRate = value;

			if (this.isPlaying === true) {
				this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
			}

			return this;
		}

		getPlaybackRate() {
			return this.playbackRate;
		}

		onEnded() {
			this.isPlaying = false;
		}

		getLoop() {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return false;
			}

			return this.loop;
		}

		setLoop(value) {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this.loop = value;

			if (this.isPlaying === true) {
				this.source.loop = this.loop;
			}

			return this;
		}

		setLoopStart(value) {
			this.loopStart = value;
			return this;
		}

		setLoopEnd(value) {
			this.loopEnd = value;
			return this;
		}

		getVolume() {
			return this.gain.gain.value;
		}

		setVolume(value) {
			this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
			return this;
		}

	}

	const _position = /*@__PURE__*/new Vector3();

	const _quaternion = /*@__PURE__*/new Quaternion();

	const _scale = /*@__PURE__*/new Vector3();

	const _orientation = /*@__PURE__*/new Vector3();

	class PositionalAudio extends Audio {
		constructor(listener) {
			super(listener);
			this.panner = this.context.createPanner();
			this.panner.panningModel = 'HRTF';
			this.panner.connect(this.gain);
		}

		getOutput() {
			return this.panner;
		}

		getRefDistance() {
			return this.panner.refDistance;
		}

		setRefDistance(value) {
			this.panner.refDistance = value;
			return this;
		}

		getRolloffFactor() {
			return this.panner.rolloffFactor;
		}

		setRolloffFactor(value) {
			this.panner.rolloffFactor = value;
			return this;
		}

		getDistanceModel() {
			return this.panner.distanceModel;
		}

		setDistanceModel(value) {
			this.panner.distanceModel = value;
			return this;
		}

		getMaxDistance() {
			return this.panner.maxDistance;
		}

		setMaxDistance(value) {
			this.panner.maxDistance = value;
			return this;
		}

		setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
			this.panner.coneInnerAngle = coneInnerAngle;
			this.panner.coneOuterAngle = coneOuterAngle;
			this.panner.coneOuterGain = coneOuterGain;
			return this;
		}

		updateMatrixWorld(force) {
			super.updateMatrixWorld(force);
			if (this.hasPlaybackControl === true && this.isPlaying === false) return;
			this.matrixWorld.decompose(_position, _quaternion, _scale);

			_orientation.set(0, 0, 1).applyQuaternion(_quaternion);

			const panner = this.panner;

			if (panner.positionX) {
				// code path for Chrome and Firefox (see #14393)
				const endTime = this.context.currentTime + this.listener.timeDelta;
				panner.positionX.linearRampToValueAtTime(_position.x, endTime);
				panner.positionY.linearRampToValueAtTime(_position.y, endTime);
				panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
				panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
				panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
				panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
			} else {
				panner.setPosition(_position.x, _position.y, _position.z);
				panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
			}
		}

	}

	class AudioAnalyser {
		constructor(audio, fftSize = 2048) {
			this.analyser = audio.context.createAnalyser();
			this.analyser.fftSize = fftSize;
			this.data = new Uint8Array(this.analyser.frequencyBinCount);
			audio.getOutput().connect(this.analyser);
		}

		getFrequencyData() {
			this.analyser.getByteFrequencyData(this.data);
			return this.data;
		}

		getAverageFrequency() {
			let value = 0;
			const data = this.getFrequencyData();

			for (let i = 0; i < data.length; i++) {
				value += data[i];
			}

			return value / data.length;
		}

	}

	class PropertyMixer {
		constructor(binding, typeName, valueSize) {
			this.binding = binding;
			this.valueSize = valueSize;
			let mixFunction, mixFunctionAdditive, setIdentity; // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
			//
			// interpolators can use .buffer as their .result
			// the data then goes to 'incoming'
			//
			// 'accu0' and 'accu1' are used frame-interleaved for
			// the cumulative result and are compared to detect
			// changes
			//
			// 'orig' stores the original state of the property
			//
			// 'add' is used for additive cumulative results
			//
			// 'work' is optional and is only present for quaternion types. It is used
			// to store intermediate quaternion multiplication results

			switch (typeName) {
				case 'quaternion':
					mixFunction = this._slerp;
					mixFunctionAdditive = this._slerpAdditive;
					setIdentity = this._setAdditiveIdentityQuaternion;
					this.buffer = new Float64Array(valueSize * 6);
					this._workIndex = 5;
					break;

				case 'string':
				case 'bool':
					mixFunction = this._select; // Use the regular mix function and for additive on these types,
					// additive is not relevant for non-numeric types

					mixFunctionAdditive = this._select;
					setIdentity = this._setAdditiveIdentityOther;
					this.buffer = new Array(valueSize * 5);
					break;

				default:
					mixFunction = this._lerp;
					mixFunctionAdditive = this._lerpAdditive;
					setIdentity = this._setAdditiveIdentityNumeric;
					this.buffer = new Float64Array(valueSize * 5);
			}

			this._mixBufferRegion = mixFunction;
			this._mixBufferRegionAdditive = mixFunctionAdditive;
			this._setIdentity = setIdentity;
			this._origIndex = 3;
			this._addIndex = 4;
			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;
			this.useCount = 0;
			this.referenceCount = 0;
		} // accumulate data in the 'incoming' region into 'accu<i>'


		accumulate(accuIndex, weight) {
			// note: happily accumulating nothing when weight = 0, the caller knows
			// the weight and shouldn't have made the call in the first place
			const buffer = this.buffer,
						stride = this.valueSize,
						offset = accuIndex * stride + stride;
			let currentWeight = this.cumulativeWeight;

			if (currentWeight === 0) {
				// accuN := incoming * weight
				for (let i = 0; i !== stride; ++i) {
					buffer[offset + i] = buffer[i];
				}

				currentWeight = weight;
			} else {
				// accuN := accuN + incoming * weight
				currentWeight += weight;
				const mix = weight / currentWeight;

				this._mixBufferRegion(buffer, offset, 0, mix, stride);
			}

			this.cumulativeWeight = currentWeight;
		} // accumulate data in the 'incoming' region into 'add'


		accumulateAdditive(weight) {
			const buffer = this.buffer,
						stride = this.valueSize,
						offset = stride * this._addIndex;

			if (this.cumulativeWeightAdditive === 0) {
				// add = identity
				this._setIdentity();
			} // add := add + incoming * weight


			this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);

			this.cumulativeWeightAdditive += weight;
		} // apply the state of 'accu<i>' to the binding when accus differ


		apply(accuIndex) {
			const stride = this.valueSize,
						buffer = this.buffer,
						offset = accuIndex * stride + stride,
						weight = this.cumulativeWeight,
						weightAdditive = this.cumulativeWeightAdditive,
						binding = this.binding;
			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;

			if (weight < 1) {
				// accuN := accuN + original * ( 1 - cumulativeWeight )
				const originalValueOffset = stride * this._origIndex;

				this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
			}

			if (weightAdditive > 0) {
				// accuN := accuN + additive accuN
				this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
			}

			for (let i = stride, e = stride + stride; i !== e; ++i) {
				if (buffer[i] !== buffer[i + stride]) {
					// value has changed -> update scene graph
					binding.setValue(buffer, offset);
					break;
				}
			}
		} // remember the state of the bound property and copy it to both accus


		saveOriginalState() {
			const binding = this.binding;
			const buffer = this.buffer,
						stride = this.valueSize,
						originalValueOffset = stride * this._origIndex;
			binding.getValue(buffer, originalValueOffset); // accu[0..1] := orig -- initially detect changes against the original

			for (let i = stride, e = originalValueOffset; i !== e; ++i) {
				buffer[i] = buffer[originalValueOffset + i % stride];
			} // Add to identity for additive


			this._setIdentity();

			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;
		} // apply the state previously taken via 'saveOriginalState' to the binding


		restoreOriginalState() {
			const originalValueOffset = this.valueSize * 3;
			this.binding.setValue(this.buffer, originalValueOffset);
		}

		_setAdditiveIdentityNumeric() {
			const startIndex = this._addIndex * this.valueSize;
			const endIndex = startIndex + this.valueSize;

			for (let i = startIndex; i < endIndex; i++) {
				this.buffer[i] = 0;
			}
		}

		_setAdditiveIdentityQuaternion() {
			this._setAdditiveIdentityNumeric();

			this.buffer[this._addIndex * this.valueSize + 3] = 1;
		}

		_setAdditiveIdentityOther() {
			const startIndex = this._origIndex * this.valueSize;
			const targetIndex = this._addIndex * this.valueSize;

			for (let i = 0; i < this.valueSize; i++) {
				this.buffer[targetIndex + i] = this.buffer[startIndex + i];
			}
		} // mix functions


		_select(buffer, dstOffset, srcOffset, t, stride) {
			if (t >= 0.5) {
				for (let i = 0; i !== stride; ++i) {
					buffer[dstOffset + i] = buffer[srcOffset + i];
				}
			}
		}

		_slerp(buffer, dstOffset, srcOffset, t) {
			Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
		}

		_slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
			const workOffset = this._workIndex * stride; // Store result in intermediate buffer offset

			Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset); // Slerp to the intermediate result

			Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
		}

		_lerp(buffer, dstOffset, srcOffset, t, stride) {
			const s = 1 - t;

			for (let i = 0; i !== stride; ++i) {
				const j = dstOffset + i;
				buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
			}
		}

		_lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
			for (let i = 0; i !== stride; ++i) {
				const j = dstOffset + i;
				buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
			}
		}

	}

	// Characters [].:/ are reserved for track binding syntax.
	const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';

	const _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g'); // Attempts to allow node names from any language. ES5's `\w` regexp matches
	// only latin characters, and the unicode \p{L} is not yet supported. So
	// instead, we exclude reserved characters and match everything else.


	const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';

	const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']'; // Parent directories, delimited by '/' or ':'. Currently unused, but must
	// be matched to parse the rest of the track name.


	const _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar); // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.


	const _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot); // Object on target node, and accessor. May not contain reserved
	// characters. Accessor may contain any character except closing bracket.


	const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar); // Property and accessor. May not contain reserved characters. Accessor may
	// contain any non-bracket characters.


	const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);

	const _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');

	const _supportedObjectNames = ['material', 'materials', 'bones'];

	class Composite {
		constructor(targetGroup, path, optionalParsedPath) {
			const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
			this._targetGroup = targetGroup;
			this._bindings = targetGroup.subscribe_(path, parsedPath);
		}

		getValue(array, offset) {
			this.bind(); // bind all binding

			const firstValidIndex = this._targetGroup.nCachedObjects_,
						binding = this._bindings[firstValidIndex]; // and only call .getValue on the first

			if (binding !== undefined) binding.getValue(array, offset);
		}

		setValue(array, offset) {
			const bindings = this._bindings;

			for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
				bindings[i].setValue(array, offset);
			}
		}

		bind() {
			const bindings = this._bindings;

			for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
				bindings[i].bind();
			}
		}

		unbind() {
			const bindings = this._bindings;

			for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
				bindings[i].unbind();
			}
		}

	} // Note: This class uses a State pattern on a per-method basis:
	// 'bind' sets 'this.getValue' / 'setValue' and shadows the
	// prototype version of these methods with one that represents
	// the bound state. When the property is not found, the methods
	// become no-ops.


	class PropertyBinding {
		constructor(rootNode, path, parsedPath) {
			this.path = path;
			this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
			this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
			this.rootNode = rootNode; // initial state of these methods that calls 'bind'

			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;
		}

		static create(root, path, parsedPath) {
			if (!(root && root.isAnimationObjectGroup)) {
				return new PropertyBinding(root, path, parsedPath);
			} else {
				return new PropertyBinding.Composite(root, path, parsedPath);
			}
		}
		/**
		 * Replaces spaces with underscores and removes unsupported characters from
		 * node names, to ensure compatibility with parseTrackName().
		 *
		 * @param {string} name Node name to be sanitized.
		 * @return {string}
		 */


		static sanitizeNodeName(name) {
			return name.replace(/\s/g, '_').replace(_reservedRe, '');
		}

		static parseTrackName(trackName) {
			const matches = _trackRe.exec(trackName);

			if (!matches) {
				throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
			}

			const results = {
				// directoryName: matches[ 1 ], // (tschw) currently unused
				nodeName: matches[2],
				objectName: matches[3],
				objectIndex: matches[4],
				propertyName: matches[5],
				// required
				propertyIndex: matches[6]
			};
			const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');

			if (lastDot !== undefined && lastDot !== -1) {
				const objectName = results.nodeName.substring(lastDot + 1); // Object names must be checked against an allowlist. Otherwise, there
				// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
				// 'bar' could be the objectName, or part of a nodeName (which can
				// include '.' characters).

				if (_supportedObjectNames.indexOf(objectName) !== -1) {
					results.nodeName = results.nodeName.substring(0, lastDot);
					results.objectName = objectName;
				}
			}

			if (results.propertyName === null || results.propertyName.length === 0) {
				throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
			}

			return results;
		}

		static findNode(root, nodeName) {
			if (!nodeName || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
				return root;
			} // search into skeleton bones.


			if (root.skeleton) {
				const bone = root.skeleton.getBoneByName(nodeName);

				if (bone !== undefined) {
					return bone;
				}
			} // search into node subtree.


			if (root.children) {
				const searchNodeSubtree = function (children) {
					for (let i = 0; i < children.length; i++) {
						const childNode = children[i];

						if (childNode.name === nodeName || childNode.uuid === nodeName) {
							return childNode;
						}

						const result = searchNodeSubtree(childNode.children);
						if (result) return result;
					}

					return null;
				};

				const subTreeNode = searchNodeSubtree(root.children);

				if (subTreeNode) {
					return subTreeNode;
				}
			}

			return null;
		} // these are used to "bind" a nonexistent property


		_getValue_unavailable() {}

		_setValue_unavailable() {} // Getters


		_getValue_direct(buffer, offset) {
			buffer[offset] = this.targetObject[this.propertyName];
		}

		_getValue_array(buffer, offset) {
			const source = this.resolvedProperty;

			for (let i = 0, n = source.length; i !== n; ++i) {
				buffer[offset++] = source[i];
			}
		}

		_getValue_arrayElement(buffer, offset) {
			buffer[offset] = this.resolvedProperty[this.propertyIndex];
		}

		_getValue_toArray(buffer, offset) {
			this.resolvedProperty.toArray(buffer, offset);
		} // Direct


		_setValue_direct(buffer, offset) {
			this.targetObject[this.propertyName] = buffer[offset];
		}

		_setValue_direct_setNeedsUpdate(buffer, offset) {
			this.targetObject[this.propertyName] = buffer[offset];
			this.targetObject.needsUpdate = true;
		}

		_setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
			this.targetObject[this.propertyName] = buffer[offset];
			this.targetObject.matrixWorldNeedsUpdate = true;
		} // EntireArray


		_setValue_array(buffer, offset) {
			const dest = this.resolvedProperty;

			for (let i = 0, n = dest.length; i !== n; ++i) {
				dest[i] = buffer[offset++];
			}
		}

		_setValue_array_setNeedsUpdate(buffer, offset) {
			const dest = this.resolvedProperty;

			for (let i = 0, n = dest.length; i !== n; ++i) {
				dest[i] = buffer[offset++];
			}

			this.targetObject.needsUpdate = true;
		}

		_setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
			const dest = this.resolvedProperty;

			for (let i = 0, n = dest.length; i !== n; ++i) {
				dest[i] = buffer[offset++];
			}

			this.targetObject.matrixWorldNeedsUpdate = true;
		} // ArrayElement


		_setValue_arrayElement(buffer, offset) {
			this.resolvedProperty[this.propertyIndex] = buffer[offset];
		}

		_setValue_arrayElement_setNeedsUpdate(buffer, offset) {
			this.resolvedProperty[this.propertyIndex] = buffer[offset];
			this.targetObject.needsUpdate = true;
		}

		_setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
			this.resolvedProperty[this.propertyIndex] = buffer[offset];
			this.targetObject.matrixWorldNeedsUpdate = true;
		} // HasToFromArray


		_setValue_fromArray(buffer, offset) {
			this.resolvedProperty.fromArray(buffer, offset);
		}

		_setValue_fromArray_setNeedsUpdate(buffer, offset) {
			this.resolvedProperty.fromArray(buffer, offset);
			this.targetObject.needsUpdate = true;
		}

		_setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
			this.resolvedProperty.fromArray(buffer, offset);
			this.targetObject.matrixWorldNeedsUpdate = true;
		}

		_getValue_unbound(targetArray, offset) {
			this.bind();
			this.getValue(targetArray, offset);
		}

		_setValue_unbound(sourceArray, offset) {
			this.bind();
			this.setValue(sourceArray, offset);
		} // create getter / setter pair for a property in the scene graph


		bind() {
			let targetObject = this.node;
			const parsedPath = this.parsedPath;
			const objectName = parsedPath.objectName;
			const propertyName = parsedPath.propertyName;
			let propertyIndex = parsedPath.propertyIndex;

			if (!targetObject) {
				targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
				this.node = targetObject;
			} // set fail state so we can just 'return' on error


			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable; // ensure there is a value node

			if (!targetObject) {
				console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
				return;
			}

			if (objectName) {
				let objectIndex = parsedPath.objectIndex; // special cases were we need to reach deeper into the hierarchy to get the face materials....

				switch (objectName) {
					case 'materials':
						if (!targetObject.material) {
							console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
							return;
						}

						if (!targetObject.material.materials) {
							console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
							return;
						}

						targetObject = targetObject.material.materials;
						break;

					case 'bones':
						if (!targetObject.skeleton) {
							console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
							return;
						} // potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.


						targetObject = targetObject.skeleton.bones; // support resolving morphTarget names into indices.

						for (let i = 0; i < targetObject.length; i++) {
							if (targetObject[i].name === objectIndex) {
								objectIndex = i;
								break;
							}
						}

						break;

					default:
						if (targetObject[objectName] === undefined) {
							console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
							return;
						}

						targetObject = targetObject[objectName];
				}

				if (objectIndex !== undefined) {
					if (targetObject[objectIndex] === undefined) {
						console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
						return;
					}

					targetObject = targetObject[objectIndex];
				}
			} // resolve property


			const nodeProperty = targetObject[propertyName];

			if (nodeProperty === undefined) {
				const nodeName = parsedPath.nodeName;
				console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
				return;
			} // determine versioning scheme


			let versioning = this.Versioning.None;
			this.targetObject = targetObject;

			if (targetObject.needsUpdate !== undefined) {
				// material
				versioning = this.Versioning.NeedsUpdate;
			} else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
				// node transform
				versioning = this.Versioning.MatrixWorldNeedsUpdate;
			} // determine how the property gets bound


			let bindingType = this.BindingType.Direct;

			if (propertyIndex !== undefined) {
				// access a sub element of the property array (only primitives are supported right now)
				if (propertyName === 'morphTargetInfluences') {
					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
					// support resolving morphTarget names into indices.
					if (!targetObject.geometry) {
						console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
						return;
					}

					if (targetObject.geometry.isBufferGeometry) {
						if (!targetObject.geometry.morphAttributes) {
							console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
							return;
						}

						if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {
							propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
						}
					} else {
						console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);
						return;
					}
				}

				bindingType = this.BindingType.ArrayElement;
				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;
			} else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
				// must use copy for Object3D.Euler/Quaternion
				bindingType = this.BindingType.HasFromToArray;
				this.resolvedProperty = nodeProperty;
			} else if (Array.isArray(nodeProperty)) {
				bindingType = this.BindingType.EntireArray;
				this.resolvedProperty = nodeProperty;
			} else {
				this.propertyName = propertyName;
			} // select getter / setter


			this.getValue = this.GetterByBindingType[bindingType];
			this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
		}

		unbind() {
			this.node = null; // back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'

			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;
		}

	}

	PropertyBinding.Composite = Composite;
	PropertyBinding.prototype.BindingType = {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	};
	PropertyBinding.prototype.Versioning = {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	};
	PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];
	PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[// Direct
	PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [// EntireArray
	PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [// ArrayElement
	PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [// HasToFromArray
	PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];

	/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 *	- Add objects you would otherwise pass as 'root' to the
	 *		constructor or the .clipAction method of AnimationMixer.
	 *
	 *	- Instead pass this object as 'root'.
	 *
	 *	- You can also add and remove objects later when the mixer
	 *		is running.
	 *
	 * Note:
	 *
	 *		Objects of this class appear as one object to the mixer,
	 *		so cache control of the individual objects must be done
	 *		on the group.
	 *
	 * Limitation:
	 *
	 *	- The animated properties must be compatible among the
	 *		all objects in the group.
	 *
	 *	- A single property can either be controlled through a
	 *		target group or directly, but not both.
	 */

	class AnimationObjectGroup {
		constructor() {
			this.uuid = generateUUID(); // cached objects followed by the active ones

			this._objects = Array.prototype.slice.call(arguments);
			this.nCachedObjects_ = 0; // threshold
			// note: read by PropertyBinding.Composite

			const indices = {};
			this._indicesByUUID = indices; // for bookkeeping

			for (let i = 0, n = arguments.length; i !== n; ++i) {
				indices[arguments[i].uuid] = i;
			}

			this._paths = []; // inside: string

			this._parsedPaths = []; // inside: { we don't care, here }

			this._bindings = []; // inside: Array< PropertyBinding >

			this._bindingsIndicesByPath = {}; // inside: indices in these arrays

			const scope = this;
			this.stats = {
				objects: {
					get total() {
						return scope._objects.length;
					},

					get inUse() {
						return this.total - scope.nCachedObjects_;
					}

				},

				get bindingsPerObject() {
					return scope._bindings.length;
				}

			};
		}

		add() {
			const objects = this._objects,
						indicesByUUID = this._indicesByUUID,
						paths = this._paths,
						parsedPaths = this._parsedPaths,
						bindings = this._bindings,
						nBindings = bindings.length;
			let knownObject = undefined,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_;

			for (let i = 0, n = arguments.length; i !== n; ++i) {
				const object = arguments[i],
							uuid = object.uuid;
				let index = indicesByUUID[uuid];

				if (index === undefined) {
					// unknown object -> add it to the ACTIVE region
					index = nObjects++;
					indicesByUUID[uuid] = index;
					objects.push(object); // accounting is done, now do the same for all bindings

					for (let j = 0, m = nBindings; j !== m; ++j) {
						bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
					}
				} else if (index < nCachedObjects) {
					knownObject = objects[index]; // move existing object to the ACTIVE region

					const firstActiveIndex = --nCachedObjects,
								lastCachedObject = objects[firstActiveIndex];
					indicesByUUID[lastCachedObject.uuid] = index;
					objects[index] = lastCachedObject;
					indicesByUUID[uuid] = firstActiveIndex;
					objects[firstActiveIndex] = object; // accounting is done, now do the same for all bindings

					for (let j = 0, m = nBindings; j !== m; ++j) {
						const bindingsForPath = bindings[j],
									lastCached = bindingsForPath[firstActiveIndex];
						let binding = bindingsForPath[index];
						bindingsForPath[index] = lastCached;

						if (binding === undefined) {
							// since we do not bother to create new bindings
							// for objects that are cached, the binding may
							// or may not exist
							binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
						}

						bindingsForPath[firstActiveIndex] = binding;
					}
				} else if (objects[index] !== knownObject) {
					console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
				} // else the object is already where we want it to be

			} // for arguments


			this.nCachedObjects_ = nCachedObjects;
		}

		remove() {
			const objects = this._objects,
						indicesByUUID = this._indicesByUUID,
						bindings = this._bindings,
						nBindings = bindings.length;
			let nCachedObjects = this.nCachedObjects_;

			for (let i = 0, n = arguments.length; i !== n; ++i) {
				const object = arguments[i],
							uuid = object.uuid,
							index = indicesByUUID[uuid];

				if (index !== undefined && index >= nCachedObjects) {
					// move existing object into the CACHED region
					const lastCachedIndex = nCachedObjects++,
								firstActiveObject = objects[lastCachedIndex];
					indicesByUUID[firstActiveObject.uuid] = index;
					objects[index] = firstActiveObject;
					indicesByUUID[uuid] = lastCachedIndex;
					objects[lastCachedIndex] = object; // accounting is done, now do the same for all bindings

					for (let j = 0, m = nBindings; j !== m; ++j) {
						const bindingsForPath = bindings[j],
									firstActive = bindingsForPath[lastCachedIndex],
									binding = bindingsForPath[index];
						bindingsForPath[index] = firstActive;
						bindingsForPath[lastCachedIndex] = binding;
					}
				}
			} // for arguments


			this.nCachedObjects_ = nCachedObjects;
		} // remove & forget


		uncache() {
			const objects = this._objects,
						indicesByUUID = this._indicesByUUID,
						bindings = this._bindings,
						nBindings = bindings.length;
			let nCachedObjects = this.nCachedObjects_,
					nObjects = objects.length;

			for (let i = 0, n = arguments.length; i !== n; ++i) {
				const object = arguments[i],
							uuid = object.uuid,
							index = indicesByUUID[uuid];

				if (index !== undefined) {
					delete indicesByUUID[uuid];

					if (index < nCachedObjects) {
						// object is cached, shrink the CACHED region
						const firstActiveIndex = --nCachedObjects,
									lastCachedObject = objects[firstActiveIndex],
									lastIndex = --nObjects,
									lastObject = objects[lastIndex]; // last cached object takes this object's place

						indicesByUUID[lastCachedObject.uuid] = index;
						objects[index] = lastCachedObject; // last object goes to the activated slot and pop

						indicesByUUID[lastObject.uuid] = firstActiveIndex;
						objects[firstActiveIndex] = lastObject;
						objects.pop(); // accounting is done, now do the same for all bindings

						for (let j = 0, m = nBindings; j !== m; ++j) {
							const bindingsForPath = bindings[j],
										lastCached = bindingsForPath[firstActiveIndex],
										last = bindingsForPath[lastIndex];
							bindingsForPath[index] = lastCached;
							bindingsForPath[firstActiveIndex] = last;
							bindingsForPath.pop();
						}
					} else {
						// object is active, just swap with the last and pop
						const lastIndex = --nObjects,
									lastObject = objects[lastIndex];

						if (lastIndex > 0) {
							indicesByUUID[lastObject.uuid] = index;
						}

						objects[index] = lastObject;
						objects.pop(); // accounting is done, now do the same for all bindings

						for (let j = 0, m = nBindings; j !== m; ++j) {
							const bindingsForPath = bindings[j];
							bindingsForPath[index] = bindingsForPath[lastIndex];
							bindingsForPath.pop();
						}
					} // cached or active

				} // if object is known

			} // for arguments


			this.nCachedObjects_ = nCachedObjects;
		} // Internal interface used by befriended PropertyBinding.Composite:


		subscribe_(path, parsedPath) {
			// returns an array of bindings for the given path that is changed
			// according to the contained objects in the group
			const indicesByPath = this._bindingsIndicesByPath;
			let index = indicesByPath[path];
			const bindings = this._bindings;
			if (index !== undefined) return bindings[index];
			const paths = this._paths,
						parsedPaths = this._parsedPaths,
						objects = this._objects,
						nObjects = objects.length,
						nCachedObjects = this.nCachedObjects_,
						bindingsForPath = new Array(nObjects);
			index = bindings.length;
			indicesByPath[path] = index;
			paths.push(path);
			parsedPaths.push(parsedPath);
			bindings.push(bindingsForPath);

			for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
				const object = objects[i];
				bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
			}

			return bindingsForPath;
		}

		unsubscribe_(path) {
			// tells the group to forget about a property path and no longer
			// update the array previously obtained with 'subscribe_'
			const indicesByPath = this._bindingsIndicesByPath,
						index = indicesByPath[path];

			if (index !== undefined) {
				const paths = this._paths,
							parsedPaths = this._parsedPaths,
							bindings = this._bindings,
							lastBindingsIndex = bindings.length - 1,
							lastBindings = bindings[lastBindingsIndex],
							lastBindingsPath = path[lastBindingsIndex];
				indicesByPath[lastBindingsPath] = index;
				bindings[index] = lastBindings;
				bindings.pop();
				parsedPaths[index] = parsedPaths[lastBindingsIndex];
				parsedPaths.pop();
				paths[index] = paths[lastBindingsIndex];
				paths.pop();
			}
		}

	}

	AnimationObjectGroup.prototype.isAnimationObjectGroup = true;

	class AnimationAction {
		constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
			this._mixer = mixer;
			this._clip = clip;
			this._localRoot = localRoot;
			this.blendMode = blendMode;
			const tracks = clip.tracks,
						nTracks = tracks.length,
						interpolants = new Array(nTracks);
			const interpolantSettings = {
				endingStart: ZeroCurvatureEnding,
				endingEnd: ZeroCurvatureEnding
			};

			for (let i = 0; i !== nTracks; ++i) {
				const interpolant = tracks[i].createInterpolant(null);
				interpolants[i] = interpolant;
				interpolant.settings = interpolantSettings;
			}

			this._interpolantSettings = interpolantSettings;
			this._interpolants = interpolants; // bound by the mixer
			// inside: PropertyMixer (managed by the mixer)

			this._propertyBindings = new Array(nTracks);
			this._cacheIndex = null; // for the memory manager

			this._byClipCacheIndex = null; // for the memory manager

			this._timeScaleInterpolant = null;
			this._weightInterpolant = null;
			this.loop = LoopRepeat;
			this._loopCount = -1; // global mixer time when the action is to be started
			// it's set back to 'null' upon start of the action

			this._startTime = null; // scaled local time of the action
			// gets clamped or wrapped to 0..clip.duration according to loop

			this.time = 0;
			this.timeScale = 1;
			this._effectiveTimeScale = 1;
			this.weight = 1;
			this._effectiveWeight = 1;
			this.repetitions = Infinity; // no. of repetitions when looping

			this.paused = false; // true -> zero effective time scale

			this.enabled = true; // false -> zero effective weight

			this.clampWhenFinished = false; // keep feeding the last frame?

			this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate

			this.zeroSlopeAtEnd = true; // clips for start, loop and end
		} // State & Scheduling


		play() {
			this._mixer._activateAction(this);

			return this;
		}

		stop() {
			this._mixer._deactivateAction(this);

			return this.reset();
		}

		reset() {
			this.paused = false;
			this.enabled = true;
			this.time = 0; // restart clip

			this._loopCount = -1; // forget previous loops

			this._startTime = null; // forget scheduling

			return this.stopFading().stopWarping();
		}

		isRunning() {
			return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
		} // return true when play has been called


		isScheduled() {
			return this._mixer._isActiveAction(this);
		}

		startAt(time) {
			this._startTime = time;
			return this;
		}

		setLoop(mode, repetitions) {
			this.loop = mode;
			this.repetitions = repetitions;
			return this;
		} // Weight
		// set the weight stopping any scheduled fading
		// although .enabled = false yields an effective weight of zero, this
		// method does *not* change .enabled, because it would be confusing


		setEffectiveWeight(weight) {
			this.weight = weight; // note: same logic as when updated at runtime

			this._effectiveWeight = this.enabled ? weight : 0;
			return this.stopFading();
		} // return the weight considering fading and .enabled


		getEffectiveWeight() {
			return this._effectiveWeight;
		}

		fadeIn(duration) {
			return this._scheduleFading(duration, 0, 1);
		}

		fadeOut(duration) {
			return this._scheduleFading(duration, 1, 0);
		}

		crossFadeFrom(fadeOutAction, duration, warp) {
			fadeOutAction.fadeOut(duration);
			this.fadeIn(duration);

			if (warp) {
				const fadeInDuration = this._clip.duration,
							fadeOutDuration = fadeOutAction._clip.duration,
							startEndRatio = fadeOutDuration / fadeInDuration,
							endStartRatio = fadeInDuration / fadeOutDuration;
				fadeOutAction.warp(1.0, startEndRatio, duration);
				this.warp(endStartRatio, 1.0, duration);
			}

			return this;
		}

		crossFadeTo(fadeInAction, duration, warp) {
			return fadeInAction.crossFadeFrom(this, duration, warp);
		}

		stopFading() {
			const weightInterpolant = this._weightInterpolant;

			if (weightInterpolant !== null) {
				this._weightInterpolant = null;

				this._mixer._takeBackControlInterpolant(weightInterpolant);
			}

			return this;
		} // Time Scale Control
		// set the time scale stopping any scheduled warping
		// although .paused = true yields an effective time scale of zero, this
		// method does *not* change .paused, because it would be confusing


		setEffectiveTimeScale(timeScale) {
			this.timeScale = timeScale;
			this._effectiveTimeScale = this.paused ? 0 : timeScale;
			return this.stopWarping();
		} // return the time scale considering warping and .paused


		getEffectiveTimeScale() {
			return this._effectiveTimeScale;
		}

		setDuration(duration) {
			this.timeScale = this._clip.duration / duration;
			return this.stopWarping();
		}

		syncWith(action) {
			this.time = action.time;
			this.timeScale = action.timeScale;
			return this.stopWarping();
		}

		halt(duration) {
			return this.warp(this._effectiveTimeScale, 0, duration);
		}

		warp(startTimeScale, endTimeScale, duration) {
			const mixer = this._mixer,
						now = mixer.time,
						timeScale = this.timeScale;
			let interpolant = this._timeScaleInterpolant;

			if (interpolant === null) {
				interpolant = mixer._lendControlInterpolant();
				this._timeScaleInterpolant = interpolant;
			}

			const times = interpolant.parameterPositions,
						values = interpolant.sampleValues;
			times[0] = now;
			times[1] = now + duration;
			values[0] = startTimeScale / timeScale;
			values[1] = endTimeScale / timeScale;
			return this;
		}

		stopWarping() {
			const timeScaleInterpolant = this._timeScaleInterpolant;

			if (timeScaleInterpolant !== null) {
				this._timeScaleInterpolant = null;

				this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
			}

			return this;
		} // Object Accessors


		getMixer() {
			return this._mixer;
		}

		getClip() {
			return this._clip;
		}

		getRoot() {
			return this._localRoot || this._mixer._root;
		} // Interna


		_update(time, deltaTime, timeDirection, accuIndex) {
			// called by the mixer
			if (!this.enabled) {
				// call ._updateWeight() to update ._effectiveWeight
				this._updateWeight(time);

				return;
			}

			const startTime = this._startTime;

			if (startTime !== null) {
				// check for scheduled start of action
				const timeRunning = (time - startTime) * timeDirection;

				if (timeRunning < 0 || timeDirection === 0) {
					return; // yet to come / don't decide when delta = 0
				} // start


				this._startTime = null; // unschedule

				deltaTime = timeDirection * timeRunning;
			} // apply time scale and advance time


			deltaTime *= this._updateTimeScale(time);

			const clipTime = this._updateTime(deltaTime); // note: _updateTime may disable the action resulting in
			// an effective weight of 0


			const weight = this._updateWeight(time);

			if (weight > 0) {
				const interpolants = this._interpolants;
				const propertyMixers = this._propertyBindings;

				switch (this.blendMode) {
					case AdditiveAnimationBlendMode:
						for (let j = 0, m = interpolants.length; j !== m; ++j) {
							interpolants[j].evaluate(clipTime);
							propertyMixers[j].accumulateAdditive(weight);
						}

						break;

					case NormalAnimationBlendMode:
					default:
						for (let j = 0, m = interpolants.length; j !== m; ++j) {
							interpolants[j].evaluate(clipTime);
							propertyMixers[j].accumulate(accuIndex, weight);
						}

				}
			}
		}

		_updateWeight(time) {
			let weight = 0;

			if (this.enabled) {
				weight = this.weight;
				const interpolant = this._weightInterpolant;

				if (interpolant !== null) {
					const interpolantValue = interpolant.evaluate(time)[0];
					weight *= interpolantValue;

					if (time > interpolant.parameterPositions[1]) {
						this.stopFading();

						if (interpolantValue === 0) {
							// faded out, disable
							this.enabled = false;
						}
					}
				}
			}

			this._effectiveWeight = weight;
			return weight;
		}

		_updateTimeScale(time) {
			let timeScale = 0;

			if (!this.paused) {
				timeScale = this.timeScale;
				const interpolant = this._timeScaleInterpolant;

				if (interpolant !== null) {
					const interpolantValue = interpolant.evaluate(time)[0];
					timeScale *= interpolantValue;

					if (time > interpolant.parameterPositions[1]) {
						this.stopWarping();

						if (timeScale === 0) {
							// motion has halted, pause
							this.paused = true;
						} else {
							// warp done - apply final time scale
							this.timeScale = timeScale;
						}
					}
				}
			}

			this._effectiveTimeScale = timeScale;
			return timeScale;
		}

		_updateTime(deltaTime) {
			const duration = this._clip.duration;
			const loop = this.loop;
			let time = this.time + deltaTime;
			let loopCount = this._loopCount;
			const pingPong = loop === LoopPingPong;

			if (deltaTime === 0) {
				if (loopCount === -1) return time;
				return pingPong && (loopCount & 1) === 1 ? duration - time : time;
			}

			if (loop === LoopOnce) {
				if (loopCount === -1) {
					// just started
					this._loopCount = 0;

					this._setEndings(true, true, false);
				}

				handle_stop: {
					if (time >= duration) {
						time = duration;
					} else if (time < 0) {
						time = 0;
					} else {
						this.time = time;
						break handle_stop;
					}

					if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
					this.time = time;

					this._mixer.dispatchEvent({
						type: 'finished',
						action: this,
						direction: deltaTime < 0 ? -1 : 1
					});
				}
			} else {
				// repetitive Repeat or PingPong
				if (loopCount === -1) {
					// just started
					if (deltaTime >= 0) {
						loopCount = 0;

						this._setEndings(true, this.repetitions === 0, pingPong);
					} else {
						// when looping in reverse direction, the initial
						// transition through zero counts as a repetition,
						// so leave loopCount at -1
						this._setEndings(this.repetitions === 0, true, pingPong);
					}
				}

				if (time >= duration || time < 0) {
					// wrap around
					const loopDelta = Math.floor(time / duration); // signed

					time -= duration * loopDelta;
					loopCount += Math.abs(loopDelta);
					const pending = this.repetitions - loopCount;

					if (pending <= 0) {
						// have to stop (switch state, clamp time, fire event)
						if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
						time = deltaTime > 0 ? duration : 0;
						this.time = time;

						this._mixer.dispatchEvent({
							type: 'finished',
							action: this,
							direction: deltaTime > 0 ? 1 : -1
						});
					} else {
						// keep running
						if (pending === 1) {
							// entering the last round
							const atStart = deltaTime < 0;

							this._setEndings(atStart, !atStart, pingPong);
						} else {
							this._setEndings(false, false, pingPong);
						}

						this._loopCount = loopCount;
						this.time = time;

						this._mixer.dispatchEvent({
							type: 'loop',
							action: this,
							loopDelta: loopDelta
						});
					}
				} else {
					this.time = time;
				}

				if (pingPong && (loopCount & 1) === 1) {
					// invert time for the "pong round"
					return duration - time;
				}
			}

			return time;
		}

		_setEndings(atStart, atEnd, pingPong) {
			const settings = this._interpolantSettings;

			if (pingPong) {
				settings.endingStart = ZeroSlopeEnding;
				settings.endingEnd = ZeroSlopeEnding;
			} else {
				// assuming for LoopOnce atStart == atEnd == true
				if (atStart) {
					settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
				} else {
					settings.endingStart = WrapAroundEnding;
				}

				if (atEnd) {
					settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
				} else {
					settings.endingEnd = WrapAroundEnding;
				}
			}
		}

		_scheduleFading(duration, weightNow, weightThen) {
			const mixer = this._mixer,
						now = mixer.time;
			let interpolant = this._weightInterpolant;

			if (interpolant === null) {
				interpolant = mixer._lendControlInterpolant();
				this._weightInterpolant = interpolant;
			}

			const times = interpolant.parameterPositions,
						values = interpolant.sampleValues;
			times[0] = now;
			values[0] = weightNow;
			times[1] = now + duration;
			values[1] = weightThen;
			return this;
		}

	}

	class AnimationMixer extends EventDispatcher {
		constructor(root) {
			super();
			this._root = root;

			this._initMemoryManager();

			this._accuIndex = 0;
			this.time = 0;
			this.timeScale = 1.0;
		}

		_bindAction(action, prototypeAction) {
			const root = action._localRoot || this._root,
						tracks = action._clip.tracks,
						nTracks = tracks.length,
						bindings = action._propertyBindings,
						interpolants = action._interpolants,
						rootUuid = root.uuid,
						bindingsByRoot = this._bindingsByRootAndName;
			let bindingsByName = bindingsByRoot[rootUuid];

			if (bindingsByName === undefined) {
				bindingsByName = {};
				bindingsByRoot[rootUuid] = bindingsByName;
			}

			for (let i = 0; i !== nTracks; ++i) {
				const track = tracks[i],
							trackName = track.name;
				let binding = bindingsByName[trackName];

				if (binding !== undefined) {
					bindings[i] = binding;
				} else {
					binding = bindings[i];

					if (binding !== undefined) {
						// existing binding, make sure the cache knows
						if (binding._cacheIndex === null) {
							++binding.referenceCount;

							this._addInactiveBinding(binding, rootUuid, trackName);
						}

						continue;
					}

					const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
					binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
					++binding.referenceCount;

					this._addInactiveBinding(binding, rootUuid, trackName);

					bindings[i] = binding;
				}

				interpolants[i].resultBuffer = binding.buffer;
			}
		}

		_activateAction(action) {
			if (!this._isActiveAction(action)) {
				if (action._cacheIndex === null) {
					// this action has been forgotten by the cache, but the user
					// appears to be still using it -> rebind
					const rootUuid = (action._localRoot || this._root).uuid,
								clipUuid = action._clip.uuid,
								actionsForClip = this._actionsByClip[clipUuid];

					this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);

					this._addInactiveAction(action, clipUuid, rootUuid);
				}

				const bindings = action._propertyBindings; // increment reference counts / sort out state

				for (let i = 0, n = bindings.length; i !== n; ++i) {
					const binding = bindings[i];

					if (binding.useCount++ === 0) {
						this._lendBinding(binding);

						binding.saveOriginalState();
					}
				}

				this._lendAction(action);
			}
		}

		_deactivateAction(action) {
			if (this._isActiveAction(action)) {
				const bindings = action._propertyBindings; // decrement reference counts / sort out state

				for (let i = 0, n = bindings.length; i !== n; ++i) {
					const binding = bindings[i];

					if (--binding.useCount === 0) {
						binding.restoreOriginalState();

						this._takeBackBinding(binding);
					}
				}

				this._takeBackAction(action);
			}
		} // Memory manager


		_initMemoryManager() {
			this._actions = []; // 'nActiveActions' followed by inactive ones

			this._nActiveActions = 0;
			this._actionsByClip = {}; // inside:
			// {
			// 	knownActions: Array< AnimationAction > - used as prototypes
			// 	actionByRoot: AnimationAction - lookup
			// }

			this._bindings = []; // 'nActiveBindings' followed by inactive ones

			this._nActiveBindings = 0;
			this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >

			this._controlInterpolants = []; // same game as above

			this._nActiveControlInterpolants = 0;
			const scope = this;
			this.stats = {
				actions: {
					get total() {
						return scope._actions.length;
					},

					get inUse() {
						return scope._nActiveActions;
					}

				},
				bindings: {
					get total() {
						return scope._bindings.length;
					},

					get inUse() {
						return scope._nActiveBindings;
					}

				},
				controlInterpolants: {
					get total() {
						return scope._controlInterpolants.length;
					},

					get inUse() {
						return scope._nActiveControlInterpolants;
					}

				}
			};
		} // Memory management for AnimationAction objects


		_isActiveAction(action) {
			const index = action._cacheIndex;
			return index !== null && index < this._nActiveActions;
		}

		_addInactiveAction(action, clipUuid, rootUuid) {
			const actions = this._actions,
						actionsByClip = this._actionsByClip;
			let actionsForClip = actionsByClip[clipUuid];

			if (actionsForClip === undefined) {
				actionsForClip = {
					knownActions: [action],
					actionByRoot: {}
				};
				action._byClipCacheIndex = 0;
				actionsByClip[clipUuid] = actionsForClip;
			} else {
				const knownActions = actionsForClip.knownActions;
				action._byClipCacheIndex = knownActions.length;
				knownActions.push(action);
			}

			action._cacheIndex = actions.length;
			actions.push(action);
			actionsForClip.actionByRoot[rootUuid] = action;
		}

		_removeInactiveAction(action) {
			const actions = this._actions,
						lastInactiveAction = actions[actions.length - 1],
						cacheIndex = action._cacheIndex;
			lastInactiveAction._cacheIndex = cacheIndex;
			actions[cacheIndex] = lastInactiveAction;
			actions.pop();
			action._cacheIndex = null;
			const clipUuid = action._clip.uuid,
						actionsByClip = this._actionsByClip,
						actionsForClip = actionsByClip[clipUuid],
						knownActionsForClip = actionsForClip.knownActions,
						lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
						byClipCacheIndex = action._byClipCacheIndex;
			lastKnownAction._byClipCacheIndex = byClipCacheIndex;
			knownActionsForClip[byClipCacheIndex] = lastKnownAction;
			knownActionsForClip.pop();
			action._byClipCacheIndex = null;
			const actionByRoot = actionsForClip.actionByRoot,
						rootUuid = (action._localRoot || this._root).uuid;
			delete actionByRoot[rootUuid];

			if (knownActionsForClip.length === 0) {
				delete actionsByClip[clipUuid];
			}

			this._removeInactiveBindingsForAction(action);
		}

		_removeInactiveBindingsForAction(action) {
			const bindings = action._propertyBindings;

			for (let i = 0, n = bindings.length; i !== n; ++i) {
				const binding = bindings[i];

				if (--binding.referenceCount === 0) {
					this._removeInactiveBinding(binding);
				}
			}
		}

		_lendAction(action) {
			// [ active actions |	inactive actions	]
			// [	active actions >| inactive actions ]
			//								 s				a
			//									<-swap->
			//								 a				s
			const actions = this._actions,
						prevIndex = action._cacheIndex,
						lastActiveIndex = this._nActiveActions++,
						firstInactiveAction = actions[lastActiveIndex];
			action._cacheIndex = lastActiveIndex;
			actions[lastActiveIndex] = action;
			firstInactiveAction._cacheIndex = prevIndex;
			actions[prevIndex] = firstInactiveAction;
		}

		_takeBackAction(action) {
			// [	active actions	| inactive actions ]
			// [ active actions |< inactive actions	]
			//				a				s
			//				 <-swap->
			//				s				a
			const actions = this._actions,
						prevIndex = action._cacheIndex,
						firstInactiveIndex = --this._nActiveActions,
						lastActiveAction = actions[firstInactiveIndex];
			action._cacheIndex = firstInactiveIndex;
			actions[firstInactiveIndex] = action;
			lastActiveAction._cacheIndex = prevIndex;
			actions[prevIndex] = lastActiveAction;
		} // Memory management for PropertyMixer objects


		_addInactiveBinding(binding, rootUuid, trackName) {
			const bindingsByRoot = this._bindingsByRootAndName,
						bindings = this._bindings;
			let bindingByName = bindingsByRoot[rootUuid];

			if (bindingByName === undefined) {
				bindingByName = {};
				bindingsByRoot[rootUuid] = bindingByName;
			}

			bindingByName[trackName] = binding;
			binding._cacheIndex = bindings.length;
			bindings.push(binding);
		}

		_removeInactiveBinding(binding) {
			const bindings = this._bindings,
						propBinding = binding.binding,
						rootUuid = propBinding.rootNode.uuid,
						trackName = propBinding.path,
						bindingsByRoot = this._bindingsByRootAndName,
						bindingByName = bindingsByRoot[rootUuid],
						lastInactiveBinding = bindings[bindings.length - 1],
						cacheIndex = binding._cacheIndex;
			lastInactiveBinding._cacheIndex = cacheIndex;
			bindings[cacheIndex] = lastInactiveBinding;
			bindings.pop();
			delete bindingByName[trackName];

			if (Object.keys(bindingByName).length === 0) {
				delete bindingsByRoot[rootUuid];
			}
		}

		_lendBinding(binding) {
			const bindings = this._bindings,
						prevIndex = binding._cacheIndex,
						lastActiveIndex = this._nActiveBindings++,
						firstInactiveBinding = bindings[lastActiveIndex];
			binding._cacheIndex = lastActiveIndex;
			bindings[lastActiveIndex] = binding;
			firstInactiveBinding._cacheIndex = prevIndex;
			bindings[prevIndex] = firstInactiveBinding;
		}

		_takeBackBinding(binding) {
			const bindings = this._bindings,
						prevIndex = binding._cacheIndex,
						firstInactiveIndex = --this._nActiveBindings,
						lastActiveBinding = bindings[firstInactiveIndex];
			binding._cacheIndex = firstInactiveIndex;
			bindings[firstInactiveIndex] = binding;
			lastActiveBinding._cacheIndex = prevIndex;
			bindings[prevIndex] = lastActiveBinding;
		} // Memory management of Interpolants for weight and time scale


		_lendControlInterpolant() {
			const interpolants = this._controlInterpolants,
						lastActiveIndex = this._nActiveControlInterpolants++;
			let interpolant = interpolants[lastActiveIndex];

			if (interpolant === undefined) {
				interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
				interpolant.__cacheIndex = lastActiveIndex;
				interpolants[lastActiveIndex] = interpolant;
			}

			return interpolant;
		}

		_takeBackControlInterpolant(interpolant) {
			const interpolants = this._controlInterpolants,
						prevIndex = interpolant.__cacheIndex,
						firstInactiveIndex = --this._nActiveControlInterpolants,
						lastActiveInterpolant = interpolants[firstInactiveIndex];
			interpolant.__cacheIndex = firstInactiveIndex;
			interpolants[firstInactiveIndex] = interpolant;
			lastActiveInterpolant.__cacheIndex = prevIndex;
			interpolants[prevIndex] = lastActiveInterpolant;
		} // return an action for a clip optionally using a custom root target
		// object (this method allocates a lot of dynamic memory in case a
		// previously unknown clip/root combination is specified)


		clipAction(clip, optionalRoot, blendMode) {
			const root = optionalRoot || this._root,
						rootUuid = root.uuid;
			let clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;
			const clipUuid = clipObject !== null ? clipObject.uuid : clip;
			const actionsForClip = this._actionsByClip[clipUuid];
			let prototypeAction = null;

			if (blendMode === undefined) {
				if (clipObject !== null) {
					blendMode = clipObject.blendMode;
				} else {
					blendMode = NormalAnimationBlendMode;
				}
			}

			if (actionsForClip !== undefined) {
				const existingAction = actionsForClip.actionByRoot[rootUuid];

				if (existingAction !== undefined && existingAction.blendMode === blendMode) {
					return existingAction;
				} // we know the clip, so we don't have to parse all
				// the bindings again but can just copy


				prototypeAction = actionsForClip.knownActions[0]; // also, take the clip from the prototype action

				if (clipObject === null) clipObject = prototypeAction._clip;
			} // clip must be known when specified via string


			if (clipObject === null) return null; // allocate all resources required to run it

			const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);

			this._bindAction(newAction, prototypeAction); // and make the action known to the memory manager


			this._addInactiveAction(newAction, clipUuid, rootUuid);

			return newAction;
		} // get an existing action


		existingAction(clip, optionalRoot) {
			const root = optionalRoot || this._root,
						rootUuid = root.uuid,
						clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
						clipUuid = clipObject ? clipObject.uuid : clip,
						actionsForClip = this._actionsByClip[clipUuid];

			if (actionsForClip !== undefined) {
				return actionsForClip.actionByRoot[rootUuid] || null;
			}

			return null;
		} // deactivates all previously scheduled actions


		stopAllAction() {
			const actions = this._actions,
						nActions = this._nActiveActions;

			for (let i = nActions - 1; i >= 0; --i) {
				actions[i].stop();
			}

			return this;
		} // advance the time and update apply the animation


		update(deltaTime) {
			deltaTime *= this.timeScale;
			const actions = this._actions,
						nActions = this._nActiveActions,
						time = this.time += deltaTime,
						timeDirection = Math.sign(deltaTime),
						accuIndex = this._accuIndex ^= 1; // run active actions

			for (let i = 0; i !== nActions; ++i) {
				const action = actions[i];

				action._update(time, deltaTime, timeDirection, accuIndex);
			} // update scene graph


			const bindings = this._bindings,
						nBindings = this._nActiveBindings;

			for (let i = 0; i !== nBindings; ++i) {
				bindings[i].apply(accuIndex);
			}

			return this;
		} // Allows you to seek to a specific time in an animation.


		setTime(timeInSeconds) {
			this.time = 0; // Zero out time attribute for AnimationMixer object;

			for (let i = 0; i < this._actions.length; i++) {
				this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.
			}

			return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
		} // return this mixer's root target object


		getRoot() {
			return this._root;
		} // free all resources specific to a particular clip


		uncacheClip(clip) {
			const actions = this._actions,
						clipUuid = clip.uuid,
						actionsByClip = this._actionsByClip,
						actionsForClip = actionsByClip[clipUuid];

			if (actionsForClip !== undefined) {
				// note: just calling _removeInactiveAction would mess up the
				// iteration state and also require updating the state we can
				// just throw away
				const actionsToRemove = actionsForClip.knownActions;

				for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
					const action = actionsToRemove[i];

					this._deactivateAction(action);

					const cacheIndex = action._cacheIndex,
								lastInactiveAction = actions[actions.length - 1];
					action._cacheIndex = null;
					action._byClipCacheIndex = null;
					lastInactiveAction._cacheIndex = cacheIndex;
					actions[cacheIndex] = lastInactiveAction;
					actions.pop();

					this._removeInactiveBindingsForAction(action);
				}

				delete actionsByClip[clipUuid];
			}
		} // free all resources specific to a particular root target object


		uncacheRoot(root) {
			const rootUuid = root.uuid,
						actionsByClip = this._actionsByClip;

			for (const clipUuid in actionsByClip) {
				const actionByRoot = actionsByClip[clipUuid].actionByRoot,
							action = actionByRoot[rootUuid];

				if (action !== undefined) {
					this._deactivateAction(action);

					this._removeInactiveAction(action);
				}
			}

			const bindingsByRoot = this._bindingsByRootAndName,
						bindingByName = bindingsByRoot[rootUuid];

			if (bindingByName !== undefined) {
				for (const trackName in bindingByName) {
					const binding = bindingByName[trackName];
					binding.restoreOriginalState();

					this._removeInactiveBinding(binding);
				}
			}
		} // remove a targeted clip from the cache


		uncacheAction(clip, optionalRoot) {
			const action = this.existingAction(clip, optionalRoot);

			if (action !== null) {
				this._deactivateAction(action);

				this._removeInactiveAction(action);
			}
		}

	}

	AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);

	class Uniform {
		constructor(value) {
			if (typeof value === 'string') {
				console.warn('THREE.Uniform: Type parameter is no longer needed.');
				value = arguments[1];
			}

			this.value = value;
		}

		clone() {
			return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
		}

	}

	class InstancedInterleavedBuffer extends InterleavedBuffer {
		constructor(array, stride, meshPerAttribute = 1) {
			super(array, stride);
			this.meshPerAttribute = meshPerAttribute;
		}

		copy(source) {
			super.copy(source);
			this.meshPerAttribute = source.meshPerAttribute;
			return this;
		}

		clone(data) {
			const ib = super.clone(data);
			ib.meshPerAttribute = this.meshPerAttribute;
			return ib;
		}

		toJSON(data) {
			const json = super.toJSON(data);
			json.isInstancedInterleavedBuffer = true;
			json.meshPerAttribute = this.meshPerAttribute;
			return json;
		}

	}

	InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;

	class GLBufferAttribute {
		constructor(buffer, type, itemSize, elementSize, count) {
			this.buffer = buffer;
			this.type = type;
			this.itemSize = itemSize;
			this.elementSize = elementSize;
			this.count = count;
			this.version = 0;
		}

		set needsUpdate(value) {
			if (value === true) this.version++;
		}

		setBuffer(buffer) {
			this.buffer = buffer;
			return this;
		}

		setType(type, elementSize) {
			this.type = type;
			this.elementSize = elementSize;
			return this;
		}

		setItemSize(itemSize) {
			this.itemSize = itemSize;
			return this;
		}

		setCount(count) {
			this.count = count;
			return this;
		}

	}

	GLBufferAttribute.prototype.isGLBufferAttribute = true;

	class Raycaster {
		constructor(origin, direction, near = 0, far = Infinity) {
			this.ray = new Ray(origin, direction); // direction is assumed to be normalized (for accurate distance calculations)

			this.near = near;
			this.far = far;
			this.camera = null;
			this.layers = new Layers();
			this.params = {
				Mesh: {},
				Line: {
					threshold: 1
				},
				LOD: {},
				Points: {
					threshold: 1
				},
				Sprite: {}
			};
		}

		set(origin, direction) {
			// direction is assumed to be normalized (for accurate distance calculations)
			this.ray.set(origin, direction);
		}

		setFromCamera(coords, camera) {
			if (camera && camera.isPerspectiveCamera) {
				this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
				this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
				this.camera = camera;
			} else if (camera && camera.isOrthographicCamera) {
				this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera

				this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
				this.camera = camera;
			} else {
				console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);
			}
		}

		intersectObject(object, recursive = true, intersects = []) {
			intersectObject(object, this, intersects, recursive);
			intersects.sort(ascSort);
			return intersects;
		}

		intersectObjects(objects, recursive = true, intersects = []) {
			for (let i = 0, l = objects.length; i < l; i++) {
				intersectObject(objects[i], this, intersects, recursive);
			}

			intersects.sort(ascSort);
			return intersects;
		}

	}

	function ascSort(a, b) {
		return a.distance - b.distance;
	}

	function intersectObject(object, raycaster, intersects, recursive) {
		if (object.layers.test(raycaster.layers)) {
			object.raycast(raycaster, intersects);
		}

		if (recursive === true) {
			const children = object.children;

			for (let i = 0, l = children.length; i < l; i++) {
				intersectObject(children[i], raycaster, intersects, true);
			}
		}
	}

	/**
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
	 * The azimuthal angle (theta) is measured from the positive z-axis.
	 */

	class Spherical {
		constructor(radius = 1, phi = 0, theta = 0) {
			this.radius = radius;
			this.phi = phi; // polar angle

			this.theta = theta; // azimuthal angle

			return this;
		}

		set(radius, phi, theta) {
			this.radius = radius;
			this.phi = phi;
			this.theta = theta;
			return this;
		}

		copy(other) {
			this.radius = other.radius;
			this.phi = other.phi;
			this.theta = other.theta;
			return this;
		} // restrict phi to be betwee EPS and PI-EPS


		makeSafe() {
			const EPS = 0.000001;
			this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
			return this;
		}

		setFromVector3(v) {
			return this.setFromCartesianCoords(v.x, v.y, v.z);
		}

		setFromCartesianCoords(x, y, z) {
			this.radius = Math.sqrt(x * x + y * y + z * z);

			if (this.radius === 0) {
				this.theta = 0;
				this.phi = 0;
			} else {
				this.theta = Math.atan2(x, z);
				this.phi = Math.acos(clamp(y / this.radius, -1, 1));
			}

			return this;
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	/**
	 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
	 */
	class Cylindrical {
		constructor(radius = 1, theta = 0, y = 0) {
			this.radius = radius; // distance from the origin to a point in the x-z plane

			this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis

			this.y = y; // height above the x-z plane

			return this;
		}

		set(radius, theta, y) {
			this.radius = radius;
			this.theta = theta;
			this.y = y;
			return this;
		}

		copy(other) {
			this.radius = other.radius;
			this.theta = other.theta;
			this.y = other.y;
			return this;
		}

		setFromVector3(v) {
			return this.setFromCartesianCoords(v.x, v.y, v.z);
		}

		setFromCartesianCoords(x, y, z) {
			this.radius = Math.sqrt(x * x + z * z);
			this.theta = Math.atan2(x, z);
			this.y = y;
			return this;
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	const _vector$4 = /*@__PURE__*/new Vector2();

	class Box2 {
		constructor(min = new Vector2(+Infinity, +Infinity), max = new Vector2(-Infinity, -Infinity)) {
			this.min = min;
			this.max = max;
		}

		set(min, max) {
			this.min.copy(min);
			this.max.copy(max);
			return this;
		}

		setFromPoints(points) {
			this.makeEmpty();

			for (let i = 0, il = points.length; i < il; i++) {
				this.expandByPoint(points[i]);
			}

			return this;
		}

		setFromCenterAndSize(center, size) {
			const halfSize = _vector$4.copy(size).multiplyScalar(0.5);

			this.min.copy(center).sub(halfSize);
			this.max.copy(center).add(halfSize);
			return this;
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(box) {
			this.min.copy(box.min);
			this.max.copy(box.max);
			return this;
		}

		makeEmpty() {
			this.min.x = this.min.y = +Infinity;
			this.max.x = this.max.y = -Infinity;
			return this;
		}

		isEmpty() {
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
			return this.max.x < this.min.x || this.max.y < this.min.y;
		}

		getCenter(target) {
			return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
		}

		getSize(target) {
			return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
		}

		expandByPoint(point) {
			this.min.min(point);
			this.max.max(point);
			return this;
		}

		expandByVector(vector) {
			this.min.sub(vector);
			this.max.add(vector);
			return this;
		}

		expandByScalar(scalar) {
			this.min.addScalar(-scalar);
			this.max.addScalar(scalar);
			return this;
		}

		containsPoint(point) {
			return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
		}

		containsBox(box) {
			return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
		}

		getParameter(point, target) {
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
			return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
		}

		intersectsBox(box) {
			// using 4 splitting planes to rule out intersections
			return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
		}

		clampPoint(point, target) {
			return target.copy(point).clamp(this.min, this.max);
		}

		distanceToPoint(point) {
			const clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);

			return clampedPoint.sub(point).length();
		}

		intersect(box) {
			this.min.max(box.min);
			this.max.min(box.max);
			return this;
		}

		union(box) {
			this.min.min(box.min);
			this.max.max(box.max);
			return this;
		}

		translate(offset) {
			this.min.add(offset);
			this.max.add(offset);
			return this;
		}

		equals(box) {
			return box.min.equals(this.min) && box.max.equals(this.max);
		}

	}

	Box2.prototype.isBox2 = true;

	const _startP = /*@__PURE__*/new Vector3();

	const _startEnd = /*@__PURE__*/new Vector3();

	class Line3 {
		constructor(start = new Vector3(), end = new Vector3()) {
			this.start = start;
			this.end = end;
		}

		set(start, end) {
			this.start.copy(start);
			this.end.copy(end);
			return this;
		}

		copy(line) {
			this.start.copy(line.start);
			this.end.copy(line.end);
			return this;
		}

		getCenter(target) {
			return target.addVectors(this.start, this.end).multiplyScalar(0.5);
		}

		delta(target) {
			return target.subVectors(this.end, this.start);
		}

		distanceSq() {
			return this.start.distanceToSquared(this.end);
		}

		distance() {
			return this.start.distanceTo(this.end);
		}

		at(t, target) {
			return this.delta(target).multiplyScalar(t).add(this.start);
		}

		closestPointToPointParameter(point, clampToLine) {
			_startP.subVectors(point, this.start);

			_startEnd.subVectors(this.end, this.start);

			const startEnd2 = _startEnd.dot(_startEnd);

			const startEnd_startP = _startEnd.dot(_startP);

			let t = startEnd_startP / startEnd2;

			if (clampToLine) {
				t = clamp(t, 0, 1);
			}

			return t;
		}

		closestPointToPoint(point, clampToLine, target) {
			const t = this.closestPointToPointParameter(point, clampToLine);
			return this.delta(target).multiplyScalar(t).add(this.start);
		}

		applyMatrix4(matrix) {
			this.start.applyMatrix4(matrix);
			this.end.applyMatrix4(matrix);
			return this;
		}

		equals(line) {
			return line.start.equals(this.start) && line.end.equals(this.end);
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	const _vector$3 = /*@__PURE__*/new Vector3();

	class SpotLightHelper extends Object3D {
		constructor(light, color) {
			super();
			this.light = light;
			this.light.updateMatrixWorld();
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
			this.color = color;
			const geometry = new BufferGeometry();
			const positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];

			for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
				const p1 = i / l * Math.PI * 2;
				const p2 = j / l * Math.PI * 2;
				positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
			}

			geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
			const material = new LineBasicMaterial({
				fog: false,
				toneMapped: false
			});
			this.cone = new LineSegments(geometry, material);
			this.add(this.cone);
			this.update();
		}

		dispose() {
			this.cone.geometry.dispose();
			this.cone.material.dispose();
		}

		update() {
			this.light.updateMatrixWorld();
			const coneLength = this.light.distance ? this.light.distance : 1000;
			const coneWidth = coneLength * Math.tan(this.light.angle);
			this.cone.scale.set(coneWidth, coneWidth, coneLength);

			_vector$3.setFromMatrixPosition(this.light.target.matrixWorld);

			this.cone.lookAt(_vector$3);

			if (this.color !== undefined) {
				this.cone.material.color.set(this.color);
			} else {
				this.cone.material.color.copy(this.light.color);
			}
		}

	}

	const _vector$2 = /*@__PURE__*/new Vector3();

	const _boneMatrix = /*@__PURE__*/new Matrix4();

	const _matrixWorldInv = /*@__PURE__*/new Matrix4();

	class SkeletonHelper extends LineSegments {
		constructor(object) {
			const bones = getBoneList(object);
			const geometry = new BufferGeometry();
			const vertices = [];
			const colors = [];
			const color1 = new Color(0, 0, 1);
			const color2 = new Color(0, 1, 0);

			for (let i = 0; i < bones.length; i++) {
				const bone = bones[i];

				if (bone.parent && bone.parent.isBone) {
					vertices.push(0, 0, 0);
					vertices.push(0, 0, 0);
					colors.push(color1.r, color1.g, color1.b);
					colors.push(color2.r, color2.g, color2.b);
				}
			}

			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			const material = new LineBasicMaterial({
				vertexColors: true,
				depthTest: false,
				depthWrite: false,
				toneMapped: false,
				transparent: true
			});
			super(geometry, material);
			this.type = 'SkeletonHelper';
			this.isSkeletonHelper = true;
			this.root = object;
			this.bones = bones;
			this.matrix = object.matrixWorld;
			this.matrixAutoUpdate = false;
		}

		updateMatrixWorld(force) {
			const bones = this.bones;
			const geometry = this.geometry;
			const position = geometry.getAttribute('position');

			_matrixWorldInv.copy(this.root.matrixWorld).invert();

			for (let i = 0, j = 0; i < bones.length; i++) {
				const bone = bones[i];

				if (bone.parent && bone.parent.isBone) {
					_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);

					_vector$2.setFromMatrixPosition(_boneMatrix);

					position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);

					_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);

					_vector$2.setFromMatrixPosition(_boneMatrix);

					position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
					j += 2;
				}
			}

			geometry.getAttribute('position').needsUpdate = true;
			super.updateMatrixWorld(force);
		}

	}

	function getBoneList(object) {
		const boneList = [];

		if (object && object.isBone) {
			boneList.push(object);
		}

		for (let i = 0; i < object.children.length; i++) {
			boneList.push.apply(boneList, getBoneList(object.children[i]));
		}

		return boneList;
	}

	class PointLightHelper extends Mesh {
		constructor(light, sphereSize, color) {
			const geometry = new SphereGeometry(sphereSize, 4, 2);
			const material = new MeshBasicMaterial({
				wireframe: true,
				fog: false,
				toneMapped: false
			});
			super(geometry, material);
			this.light = light;
			this.light.updateMatrixWorld();
			this.color = color;
			this.type = 'PointLightHelper';
			this.matrix = this.light.matrixWorld;
			this.matrixAutoUpdate = false;
			this.update();
			/*
			// TODO: delete this comment?
			const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
			const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
			this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
			this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
			const d = light.distance;
			if ( d === 0.0 ) {
				this.lightDistance.visible = false;
			} else {
				this.lightDistance.scale.set( d, d, d );
			}
			this.add( this.lightDistance );
			*/
		}

		dispose() {
			this.geometry.dispose();
			this.material.dispose();
		}

		update() {
			if (this.color !== undefined) {
				this.material.color.set(this.color);
			} else {
				this.material.color.copy(this.light.color);
			}
			/*
			const d = this.light.distance;
				if ( d === 0.0 ) {
					this.lightDistance.visible = false;
				} else {
					this.lightDistance.visible = true;
				this.lightDistance.scale.set( d, d, d );
				}
			*/

		}

	}

	const _vector$1 = /*@__PURE__*/new Vector3();

	const _color1 = /*@__PURE__*/new Color();

	const _color2 = /*@__PURE__*/new Color();

	class HemisphereLightHelper extends Object3D {
		constructor(light, size, color) {
			super();
			this.light = light;
			this.light.updateMatrixWorld();
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
			this.color = color;
			const geometry = new OctahedronGeometry(size);
			geometry.rotateY(Math.PI * 0.5);
			this.material = new MeshBasicMaterial({
				wireframe: true,
				fog: false,
				toneMapped: false
			});
			if (this.color === undefined) this.material.vertexColors = true;
			const position = geometry.getAttribute('position');
			const colors = new Float32Array(position.count * 3);
			geometry.setAttribute('color', new BufferAttribute(colors, 3));
			this.add(new Mesh(geometry, this.material));
			this.update();
		}

		dispose() {
			this.children[0].geometry.dispose();
			this.children[0].material.dispose();
		}

		update() {
			const mesh = this.children[0];

			if (this.color !== undefined) {
				this.material.color.set(this.color);
			} else {
				const colors = mesh.geometry.getAttribute('color');

				_color1.copy(this.light.color);

				_color2.copy(this.light.groundColor);

				for (let i = 0, l = colors.count; i < l; i++) {
					const color = i < l / 2 ? _color1 : _color2;
					colors.setXYZ(i, color.r, color.g, color.b);
				}

				colors.needsUpdate = true;
			}

			mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
		}

	}

	class GridHelper extends LineSegments {
		constructor(size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888) {
			color1 = new Color(color1);
			color2 = new Color(color2);
			const center = divisions / 2;
			const step = size / divisions;
			const halfSize = size / 2;
			const vertices = [],
						colors = [];

			for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
				vertices.push(-halfSize, 0, k, halfSize, 0, k);
				vertices.push(k, 0, -halfSize, k, 0, halfSize);
				const color = i === center ? color1 : color2;
				color.toArray(colors, j);
				j += 3;
				color.toArray(colors, j);
				j += 3;
				color.toArray(colors, j);
				j += 3;
				color.toArray(colors, j);
				j += 3;
			}

			const geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			const material = new LineBasicMaterial({
				vertexColors: true,
				toneMapped: false
			});
			super(geometry, material);
			this.type = 'GridHelper';
		}

	}

	class PolarGridHelper extends LineSegments {
		constructor(radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888) {
			color1 = new Color(color1);
			color2 = new Color(color2);
			const vertices = [];
			const colors = []; // create the radials

			for (let i = 0; i <= radials; i++) {
				const v = i / radials * (Math.PI * 2);
				const x = Math.sin(v) * radius;
				const z = Math.cos(v) * radius;
				vertices.push(0, 0, 0);
				vertices.push(x, 0, z);
				const color = i & 1 ? color1 : color2;
				colors.push(color.r, color.g, color.b);
				colors.push(color.r, color.g, color.b);
			} // create the circles


			for (let i = 0; i <= circles; i++) {
				const color = i & 1 ? color1 : color2;
				const r = radius - radius / circles * i;

				for (let j = 0; j < divisions; j++) {
					// first vertex
					let v = j / divisions * (Math.PI * 2);
					let x = Math.sin(v) * r;
					let z = Math.cos(v) * r;
					vertices.push(x, 0, z);
					colors.push(color.r, color.g, color.b); // second vertex

					v = (j + 1) / divisions * (Math.PI * 2);
					x = Math.sin(v) * r;
					z = Math.cos(v) * r;
					vertices.push(x, 0, z);
					colors.push(color.r, color.g, color.b);
				}
			}

			const geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			const material = new LineBasicMaterial({
				vertexColors: true,
				toneMapped: false
			});
			super(geometry, material);
			this.type = 'PolarGridHelper';
		}

	}

	const _v1 = /*@__PURE__*/new Vector3();

	const _v2 = /*@__PURE__*/new Vector3();

	const _v3 = /*@__PURE__*/new Vector3();

	class DirectionalLightHelper extends Object3D {
		constructor(light, size, color) {
			super();
			this.light = light;
			this.light.updateMatrixWorld();
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
			this.color = color;
			if (size === undefined) size = 1;
			let geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
			const material = new LineBasicMaterial({
				fog: false,
				toneMapped: false
			});
			this.lightPlane = new Line(geometry, material);
			this.add(this.lightPlane);
			geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
			this.targetLine = new Line(geometry, material);
			this.add(this.targetLine);
			this.update();
		}

		dispose() {
			this.lightPlane.geometry.dispose();
			this.lightPlane.material.dispose();
			this.targetLine.geometry.dispose();
			this.targetLine.material.dispose();
		}

		update() {
			_v1.setFromMatrixPosition(this.light.matrixWorld);

			_v2.setFromMatrixPosition(this.light.target.matrixWorld);

			_v3.subVectors(_v2, _v1);

			this.lightPlane.lookAt(_v2);

			if (this.color !== undefined) {
				this.lightPlane.material.color.set(this.color);
				this.targetLine.material.color.set(this.color);
			} else {
				this.lightPlane.material.color.copy(this.light.color);
				this.targetLine.material.color.copy(this.light.color);
			}

			this.targetLine.lookAt(_v2);
			this.targetLine.scale.z = _v3.length();
		}

	}

	const _vector = /*@__PURE__*/new Vector3();

	const _camera = /*@__PURE__*/new Camera();
	/**
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */


	class CameraHelper extends LineSegments {
		constructor(camera) {
			const geometry = new BufferGeometry();
			const material = new LineBasicMaterial({
				color: 0xffffff,
				vertexColors: true,
				toneMapped: false
			});
			const vertices = [];
			const colors = [];
			const pointMap = {}; // colors

			const colorFrustum = new Color(0xffaa00);
			const colorCone = new Color(0xff0000);
			const colorUp = new Color(0x00aaff);
			const colorTarget = new Color(0xffffff);
			const colorCross = new Color(0x333333); // near

			addLine('n1', 'n2', colorFrustum);
			addLine('n2', 'n4', colorFrustum);
			addLine('n4', 'n3', colorFrustum);
			addLine('n3', 'n1', colorFrustum); // far

			addLine('f1', 'f2', colorFrustum);
			addLine('f2', 'f4', colorFrustum);
			addLine('f4', 'f3', colorFrustum);
			addLine('f3', 'f1', colorFrustum); // sides

			addLine('n1', 'f1', colorFrustum);
			addLine('n2', 'f2', colorFrustum);
			addLine('n3', 'f3', colorFrustum);
			addLine('n4', 'f4', colorFrustum); // cone

			addLine('p', 'n1', colorCone);
			addLine('p', 'n2', colorCone);
			addLine('p', 'n3', colorCone);
			addLine('p', 'n4', colorCone); // up

			addLine('u1', 'u2', colorUp);
			addLine('u2', 'u3', colorUp);
			addLine('u3', 'u1', colorUp); // target

			addLine('c', 't', colorTarget);
			addLine('p', 'c', colorCross); // cross

			addLine('cn1', 'cn2', colorCross);
			addLine('cn3', 'cn4', colorCross);
			addLine('cf1', 'cf2', colorCross);
			addLine('cf3', 'cf4', colorCross);

			function addLine(a, b, color) {
				addPoint(a, color);
				addPoint(b, color);
			}

			function addPoint(id, color) {
				vertices.push(0, 0, 0);
				colors.push(color.r, color.g, color.b);

				if (pointMap[id] === undefined) {
					pointMap[id] = [];
				}

				pointMap[id].push(vertices.length / 3 - 1);
			}

			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			super(geometry, material);
			this.type = 'CameraHelper';
			this.camera = camera;
			if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
			this.matrix = camera.matrixWorld;
			this.matrixAutoUpdate = false;
			this.pointMap = pointMap;
			this.update();
		}

		update() {
			const geometry = this.geometry;
			const pointMap = this.pointMap;
			const w = 1,
						h = 1; // we need just camera projection matrix inverse
			// world matrix must be identity

			_camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse); // center / target


			setPoint('c', pointMap, geometry, _camera, 0, 0, -1);
			setPoint('t', pointMap, geometry, _camera, 0, 0, 1); // near

			setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);
			setPoint('n2', pointMap, geometry, _camera, w, -h, -1);
			setPoint('n3', pointMap, geometry, _camera, -w, h, -1);
			setPoint('n4', pointMap, geometry, _camera, w, h, -1); // far

			setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
			setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
			setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
			setPoint('f4', pointMap, geometry, _camera, w, h, 1); // up

			setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
			setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
			setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1); // cross

			setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
			setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
			setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
			setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);
			setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);
			setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);
			setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);
			setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);
			geometry.getAttribute('position').needsUpdate = true;
		}

		dispose() {
			this.geometry.dispose();
			this.material.dispose();
		}

	}

	function setPoint(point, pointMap, geometry, camera, x, y, z) {
		_vector.set(x, y, z).unproject(camera);

		const points = pointMap[point];

		if (points !== undefined) {
			const position = geometry.getAttribute('position');

			for (let i = 0, l = points.length; i < l; i++) {
				position.setXYZ(points[i], _vector.x, _vector.y, _vector.z);
			}
		}
	}

	const _box = /*@__PURE__*/new Box3();

	class BoxHelper extends LineSegments {
		constructor(object, color = 0xffff00) {
			const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
			const positions = new Float32Array(8 * 3);
			const geometry = new BufferGeometry();
			geometry.setIndex(new BufferAttribute(indices, 1));
			geometry.setAttribute('position', new BufferAttribute(positions, 3));
			super(geometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.object = object;
			this.type = 'BoxHelper';
			this.matrixAutoUpdate = false;
			this.update();
		}

		update(object) {
			if (object !== undefined) {
				console.warn('THREE.BoxHelper: .update() has no longer arguments.');
			}

			if (this.object !== undefined) {
				_box.setFromObject(this.object);
			}

			if (_box.isEmpty()) return;
			const min = _box.min;
			const max = _box.max;
			/*
				5____4
			1/___0/|
			| 6__|_7
			2/___3/
				0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/

			const position = this.geometry.attributes.position;
			const array = position.array;
			array[0] = max.x;
			array[1] = max.y;
			array[2] = max.z;
			array[3] = min.x;
			array[4] = max.y;
			array[5] = max.z;
			array[6] = min.x;
			array[7] = min.y;
			array[8] = max.z;
			array[9] = max.x;
			array[10] = min.y;
			array[11] = max.z;
			array[12] = max.x;
			array[13] = max.y;
			array[14] = min.z;
			array[15] = min.x;
			array[16] = max.y;
			array[17] = min.z;
			array[18] = min.x;
			array[19] = min.y;
			array[20] = min.z;
			array[21] = max.x;
			array[22] = min.y;
			array[23] = min.z;
			position.needsUpdate = true;
			this.geometry.computeBoundingSphere();
		}

		setFromObject(object) {
			this.object = object;
			this.update();
			return this;
		}

		copy(source) {
			LineSegments.prototype.copy.call(this, source);
			this.object = source.object;
			return this;
		}

	}

	class Box3Helper extends LineSegments {
		constructor(box, color = 0xffff00) {
			const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
			const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
			const geometry = new BufferGeometry();
			geometry.setIndex(new BufferAttribute(indices, 1));
			geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
			super(geometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.box = box;
			this.type = 'Box3Helper';
			this.geometry.computeBoundingSphere();
		}

		updateMatrixWorld(force) {
			const box = this.box;
			if (box.isEmpty()) return;
			box.getCenter(this.position);
			box.getSize(this.scale);
			this.scale.multiplyScalar(0.5);
			super.updateMatrixWorld(force);
		}

	}

	class PlaneHelper extends Line {
		constructor(plane, size = 1, hex = 0xffff00) {
			const color = hex;
			const positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
			const geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
			geometry.computeBoundingSphere();
			super(geometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.type = 'PlaneHelper';
			this.plane = plane;
			this.size = size;
			const positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
			const geometry2 = new BufferGeometry();
			geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
			geometry2.computeBoundingSphere();
			this.add(new Mesh(geometry2, new MeshBasicMaterial({
				color: color,
				opacity: 0.2,
				transparent: true,
				depthWrite: false,
				toneMapped: false
			})));
		}

		updateMatrixWorld(force) {
			let scale = -this.plane.constant;
			if (Math.abs(scale) < 1e-8) scale = 1e-8; // sign does not matter

			this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
			this.children[0].material.side = scale < 0 ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

			this.lookAt(this.plane.normal);
			super.updateMatrixWorld(force);
		}

	}

	const _axis = /*@__PURE__*/new Vector3();

	let _lineGeometry, _coneGeometry;

	class ArrowHelper extends Object3D {
		// dir is assumed to be normalized
		constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2) {
			super();
			this.type = 'ArrowHelper';

			if (_lineGeometry === undefined) {
				_lineGeometry = new BufferGeometry();

				_lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));

				_coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);

				_coneGeometry.translate(0, -0.5, 0);
			}

			this.position.copy(origin);
			this.line = new Line(_lineGeometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.line.matrixAutoUpdate = false;
			this.add(this.line);
			this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.cone.matrixAutoUpdate = false;
			this.add(this.cone);
			this.setDirection(dir);
			this.setLength(length, headLength, headWidth);
		}

		setDirection(dir) {
			// dir is assumed to be normalized
			if (dir.y > 0.99999) {
				this.quaternion.set(0, 0, 0, 1);
			} else if (dir.y < -0.99999) {
				this.quaternion.set(1, 0, 0, 0);
			} else {
				_axis.set(dir.z, 0, -dir.x).normalize();

				const radians = Math.acos(dir.y);
				this.quaternion.setFromAxisAngle(_axis, radians);
			}
		}

		setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
			this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458

			this.line.updateMatrix();
			this.cone.scale.set(headWidth, headLength, headWidth);
			this.cone.position.y = length;
			this.cone.updateMatrix();
		}

		setColor(color) {
			this.line.material.color.set(color);
			this.cone.material.color.set(color);
		}

		copy(source) {
			super.copy(source, false);
			this.line.copy(source.line);
			this.cone.copy(source.cone);
			return this;
		}

	}

	class AxesHelper extends LineSegments {
		constructor(size = 1) {
			const vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
			const colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
			const geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			const material = new LineBasicMaterial({
				vertexColors: true,
				toneMapped: false
			});
			super(geometry, material);
			this.type = 'AxesHelper';
		}

		setColors(xAxisColor, yAxisColor, zAxisColor) {
			const color = new Color();
			const array = this.geometry.attributes.color.array;
			color.set(xAxisColor);
			color.toArray(array, 0);
			color.toArray(array, 3);
			color.set(yAxisColor);
			color.toArray(array, 6);
			color.toArray(array, 9);
			color.set(zAxisColor);
			color.toArray(array, 12);
			color.toArray(array, 15);
			this.geometry.attributes.color.needsUpdate = true;
			return this;
		}

		dispose() {
			this.geometry.dispose();
			this.material.dispose();
		}

	}

	class ShapePath {
		constructor() {
			this.type = 'ShapePath';
			this.color = new Color();
			this.subPaths = [];
			this.currentPath = null;
		}

		moveTo(x, y) {
			this.currentPath = new Path();
			this.subPaths.push(this.currentPath);
			this.currentPath.moveTo(x, y);
			return this;
		}

		lineTo(x, y) {
			this.currentPath.lineTo(x, y);
			return this;
		}

		quadraticCurveTo(aCPx, aCPy, aX, aY) {
			this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
			return this;
		}

		bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
			this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
			return this;
		}

		splineThru(pts) {
			this.currentPath.splineThru(pts);
			return this;
		}

		toShapes(isCCW, noHoles) {
			function toShapesNoHoles(inSubpaths) {
				const shapes = [];

				for (let i = 0, l = inSubpaths.length; i < l; i++) {
					const tmpPath = inSubpaths[i];
					const tmpShape = new Shape();
					tmpShape.curves = tmpPath.curves;
					shapes.push(tmpShape);
				}

				return shapes;
			}

			function isPointInsidePolygon(inPt, inPolygon) {
				const polyLen = inPolygon.length; // inPt on polygon contour => immediate success		or
				// toggling of inside/outside at every single! intersection point of an edge
				//	with the horizontal line through inPt, left of inPt
				//	not counting lowerY endpoints of edges and whole edges on that line

				let inside = false;

				for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
					let edgeLowPt = inPolygon[p];
					let edgeHighPt = inPolygon[q];
					let edgeDx = edgeHighPt.x - edgeLowPt.x;
					let edgeDy = edgeHighPt.y - edgeLowPt.y;

					if (Math.abs(edgeDy) > Number.EPSILON) {
						// not parallel
						if (edgeDy < 0) {
							edgeLowPt = inPolygon[q];
							edgeDx = -edgeDx;
							edgeHighPt = inPolygon[p];
							edgeDy = -edgeDy;
						}

						if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;

						if (inPt.y === edgeLowPt.y) {
							if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
							// continue;				// no intersection or edgeLowPt => doesn't count !!!
						} else {
							const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
							if (perpEdge === 0) return true; // inPt is on contour ?

							if (perpEdge < 0) continue;
							inside = !inside; // true intersection left of inPt
						}
					} else {
						// parallel or collinear
						if (inPt.y !== edgeLowPt.y) continue; // parallel
						// edge lies on the same horizontal line as inPt

						if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
						// continue;
					}
				}

				return inside;
			}

			const isClockWise = ShapeUtils.isClockWise;
			const subPaths = this.subPaths;
			if (subPaths.length === 0) return [];
			if (noHoles === true) return toShapesNoHoles(subPaths);
			let solid, tmpPath, tmpShape;
			const shapes = [];

			if (subPaths.length === 1) {
				tmpPath = subPaths[0];
				tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;
				shapes.push(tmpShape);
				return shapes;
			}

			let holesFirst = !isClockWise(subPaths[0].getPoints());
			holesFirst = isCCW ? !holesFirst : holesFirst; // console.log("Holes first", holesFirst);

			const betterShapeHoles = [];
			const newShapes = [];
			let newShapeHoles = [];
			let mainIdx = 0;
			let tmpPoints;
			newShapes[mainIdx] = undefined;
			newShapeHoles[mainIdx] = [];

			for (let i = 0, l = subPaths.length; i < l; i++) {
				tmpPath = subPaths[i];
				tmpPoints = tmpPath.getPoints();
				solid = isClockWise(tmpPoints);
				solid = isCCW ? !solid : solid;

				if (solid) {
					if (!holesFirst && newShapes[mainIdx]) mainIdx++;
					newShapes[mainIdx] = {
						s: new Shape(),
						p: tmpPoints
					};
					newShapes[mainIdx].s.curves = tmpPath.curves;
					if (holesFirst) mainIdx++;
					newShapeHoles[mainIdx] = []; //console.log('cw', i);
				} else {
					newShapeHoles[mainIdx].push({
						h: tmpPath,
						p: tmpPoints[0]
					}); //console.log('ccw', i);
				}
			} // only Holes? -> probably all Shapes with wrong orientation


			if (!newShapes[0]) return toShapesNoHoles(subPaths);

			if (newShapes.length > 1) {
				let ambiguous = false;
				const toChange = [];

				for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
					betterShapeHoles[sIdx] = [];
				}

				for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
					const sho = newShapeHoles[sIdx];

					for (let hIdx = 0; hIdx < sho.length; hIdx++) {
						const ho = sho[hIdx];
						let hole_unassigned = true;

						for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
							if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
								if (sIdx !== s2Idx) toChange.push({
									froms: sIdx,
									tos: s2Idx,
									hole: hIdx
								});

								if (hole_unassigned) {
									hole_unassigned = false;
									betterShapeHoles[s2Idx].push(ho);
								} else {
									ambiguous = true;
								}
							}
						}

						if (hole_unassigned) {
							betterShapeHoles[sIdx].push(ho);
						}
					}
				} // console.log("ambiguous: ", ambiguous);


				if (toChange.length > 0) {
					// console.log("to change: ", toChange);
					if (!ambiguous) newShapeHoles = betterShapeHoles;
				}
			}

			let tmpHoles;

			for (let i = 0, il = newShapes.length; i < il; i++) {
				tmpShape = newShapes[i].s;
				shapes.push(tmpShape);
				tmpHoles = newShapeHoles[i];

				for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
					tmpShape.holes.push(tmpHoles[j].h);
				}
			} //console.log("shape", shapes);


			return shapes;
		}

	}

	const _floatView = new Float32Array(1);

	const _int32View = new Int32Array(_floatView.buffer);

	class DataUtils {
		// Converts float32 to float16 (stored as uint16 value).
		static toHalfFloat(val) {
			if (val > 65504) {
				console.warn('THREE.DataUtils.toHalfFloat(): value exceeds 65504.');
				val = 65504; // maximum representable value in float16
			} // Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410

			/* This method is faster than the OpenEXR implementation (very often
			* used, eg. in Ogre), with the additional benefit of rounding, inspired
			* by James Tursa?s half-precision code. */


			_floatView[0] = val;
			const x = _int32View[0];
			let bits = x >> 16 & 0x8000;
			/* Get the sign */

			let m = x >> 12 & 0x07ff;
			/* Keep one extra bit for rounding */

			const e = x >> 23 & 0xff;
			/* Using int is faster here */

			/* If zero, or denormal, or exponent underflows too much for a denormal
				* half, return signed zero. */

			if (e < 103) return bits;
			/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */

			if (e > 142) {
				bits |= 0x7c00;
				/* If exponent was 0xff and one mantissa bit was set, it means NaN,
							* not Inf, so make sure we set one mantissa bit too. */

				bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;
				return bits;
			}
			/* If exponent underflows but not too much, return a denormal */


			if (e < 113) {
				m |= 0x0800;
				/* Extra rounding may overflow and set mantissa to 0 and exponent
					* to 1, which is OK. */

				bits |= (m >> 114 - e) + (m >> 113 - e & 1);
				return bits;
			}

			bits |= e - 112 << 10 | m >> 1;
			/* Extra rounding. An overflow will set mantissa to 0 and increment
				* the exponent, which is OK. */

			bits += m & 1;
			return bits;
		}

	}

	const LineStrip = 0;
	const LinePieces = 1;
	const NoColors = 0;
	const FaceColors = 1;
	const VertexColors = 2;
	function MeshFaceMaterial(materials) {
		console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
		return materials;
	}
	function MultiMaterial(materials = []) {
		console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
		materials.isMultiMaterial = true;
		materials.materials = materials;

		materials.clone = function () {
			return materials.slice();
		};

		return materials;
	}
	function PointCloud(geometry, material) {
		console.warn('THREE.PointCloud has been renamed to THREE.Points.');
		return new Points(geometry, material);
	}
	function Particle(material) {
		console.warn('THREE.Particle has been renamed to THREE.Sprite.');
		return new Sprite(material);
	}
	function ParticleSystem(geometry, material) {
		console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
		return new Points(geometry, material);
	}
	function PointCloudMaterial(parameters) {
		console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
		return new PointsMaterial(parameters);
	}
	function ParticleBasicMaterial(parameters) {
		console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
		return new PointsMaterial(parameters);
	}
	function ParticleSystemMaterial(parameters) {
		console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
		return new PointsMaterial(parameters);
	}
	function Vertex(x, y, z) {
		console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
		return new Vector3(x, y, z);
	} //

	function DynamicBufferAttribute(array, itemSize) {
		console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.');
		return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);
	}
	function Int8Attribute(array, itemSize) {
		console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
		return new Int8BufferAttribute(array, itemSize);
	}
	function Uint8Attribute(array, itemSize) {
		console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
		return new Uint8BufferAttribute(array, itemSize);
	}
	function Uint8ClampedAttribute(array, itemSize) {
		console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
		return new Uint8ClampedBufferAttribute(array, itemSize);
	}
	function Int16Attribute(array, itemSize) {
		console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
		return new Int16BufferAttribute(array, itemSize);
	}
	function Uint16Attribute(array, itemSize) {
		console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
		return new Uint16BufferAttribute(array, itemSize);
	}
	function Int32Attribute(array, itemSize) {
		console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
		return new Int32BufferAttribute(array, itemSize);
	}
	function Uint32Attribute(array, itemSize) {
		console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
		return new Uint32BufferAttribute(array, itemSize);
	}
	function Float32Attribute(array, itemSize) {
		console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
		return new Float32BufferAttribute(array, itemSize);
	}
	function Float64Attribute(array, itemSize) {
		console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
		return new Float64BufferAttribute(array, itemSize);
	} //

	Curve.create = function (construct, getPoint) {
		console.log('THREE.Curve.create() has been deprecated');
		construct.prototype = Object.create(Curve.prototype);
		construct.prototype.constructor = construct;
		construct.prototype.getPoint = getPoint;
		return construct;
	}; //


	Path.prototype.fromPoints = function (points) {
		console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
		return this.setFromPoints(points);
	}; //


	function AxisHelper(size) {
		console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
		return new AxesHelper(size);
	}
	function BoundingBoxHelper(object, color) {
		console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
		return new BoxHelper(object, color);
	}
	function EdgesHelper(object, hex) {
		console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
		return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
			color: hex !== undefined ? hex : 0xffffff
		}));
	}

	GridHelper.prototype.setColors = function () {
		console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
	};

	SkeletonHelper.prototype.update = function () {
		console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
	};

	function WireframeHelper(object, hex) {
		console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
		return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
			color: hex !== undefined ? hex : 0xffffff
		}));
	} //

	Loader.prototype.extractUrlBase = function (url) {
		console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
		return LoaderUtils.extractUrlBase(url);
	};

	Loader.Handlers = {
		add: function () {
			console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');
		},
		get: function () {
			console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');
		}
	};
	function XHRLoader(manager) {
		console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
		return new FileLoader(manager);
	}
	function BinaryTextureLoader(manager) {
		console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
		return new DataTextureLoader(manager);
	} //

	Box2.prototype.center = function (optionalTarget) {
		console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
		return this.getCenter(optionalTarget);
	};

	Box2.prototype.empty = function () {
		console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
		return this.isEmpty();
	};

	Box2.prototype.isIntersectionBox = function (box) {
		console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
		return this.intersectsBox(box);
	};

	Box2.prototype.size = function (optionalTarget) {
		console.warn('THREE.Box2: .size() has been renamed to .getSize().');
		return this.getSize(optionalTarget);
	}; //


	Box3.prototype.center = function (optionalTarget) {
		console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
		return this.getCenter(optionalTarget);
	};

	Box3.prototype.empty = function () {
		console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
		return this.isEmpty();
	};

	Box3.prototype.isIntersectionBox = function (box) {
		console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
		return this.intersectsBox(box);
	};

	Box3.prototype.isIntersectionSphere = function (sphere) {
		console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
		return this.intersectsSphere(sphere);
	};

	Box3.prototype.size = function (optionalTarget) {
		console.warn('THREE.Box3: .size() has been renamed to .getSize().');
		return this.getSize(optionalTarget);
	}; //


	Sphere.prototype.empty = function () {
		console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');
		return this.isEmpty();
	}; //


	Frustum.prototype.setFromMatrix = function (m) {
		console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');
		return this.setFromProjectionMatrix(m);
	}; //


	Line3.prototype.center = function (optionalTarget) {
		console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
		return this.getCenter(optionalTarget);
	}; //


	Matrix3.prototype.flattenToArrayOffset = function (array, offset) {
		console.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
		return this.toArray(array, offset);
	};

	Matrix3.prototype.multiplyVector3 = function (vector) {
		console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
		return vector.applyMatrix3(this);
	};

	Matrix3.prototype.multiplyVector3Array = function () {
		console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
	};

	Matrix3.prototype.applyToBufferAttribute = function (attribute) {
		console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');
		return attribute.applyMatrix3(this);
	};

	Matrix3.prototype.applyToVector3Array = function () {
		console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
	};

	Matrix3.prototype.getInverse = function (matrix) {
		console.warn('THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
		return this.copy(matrix).invert();
	}; //


	Matrix4.prototype.extractPosition = function (m) {
		console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
		return this.copyPosition(m);
	};

	Matrix4.prototype.flattenToArrayOffset = function (array, offset) {
		console.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
		return this.toArray(array, offset);
	};

	Matrix4.prototype.getPosition = function () {
		console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
		return new Vector3().setFromMatrixColumn(this, 3);
	};

	Matrix4.prototype.setRotationFromQuaternion = function (q) {
		console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
		return this.makeRotationFromQuaternion(q);
	};

	Matrix4.prototype.multiplyToArray = function () {
		console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
	};

	Matrix4.prototype.multiplyVector3 = function (vector) {
		console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
		return vector.applyMatrix4(this);
	};

	Matrix4.prototype.multiplyVector4 = function (vector) {
		console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
		return vector.applyMatrix4(this);
	};

	Matrix4.prototype.multiplyVector3Array = function () {
		console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
	};

	Matrix4.prototype.rotateAxis = function (v) {
		console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
		v.transformDirection(this);
	};

	Matrix4.prototype.crossVector = function (vector) {
		console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
		return vector.applyMatrix4(this);
	};

	Matrix4.prototype.translate = function () {
		console.error('THREE.Matrix4: .translate() has been removed.');
	};

	Matrix4.prototype.rotateX = function () {
		console.error('THREE.Matrix4: .rotateX() has been removed.');
	};

	Matrix4.prototype.rotateY = function () {
		console.error('THREE.Matrix4: .rotateY() has been removed.');
	};

	Matrix4.prototype.rotateZ = function () {
		console.error('THREE.Matrix4: .rotateZ() has been removed.');
	};

	Matrix4.prototype.rotateByAxis = function () {
		console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
	};

	Matrix4.prototype.applyToBufferAttribute = function (attribute) {
		console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');
		return attribute.applyMatrix4(this);
	};

	Matrix4.prototype.applyToVector3Array = function () {
		console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
	};

	Matrix4.prototype.makeFrustum = function (left, right, bottom, top, near, far) {
		console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
		return this.makePerspective(left, right, top, bottom, near, far);
	};

	Matrix4.prototype.getInverse = function (matrix) {
		console.warn('THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
		return this.copy(matrix).invert();
	}; //


	Plane.prototype.isIntersectionLine = function (line) {
		console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
		return this.intersectsLine(line);
	}; //


	Quaternion.prototype.multiplyVector3 = function (vector) {
		console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
		return vector.applyQuaternion(this);
	};

	Quaternion.prototype.inverse = function () {
		console.warn('THREE.Quaternion: .inverse() has been renamed to invert().');
		return this.invert();
	}; //


	Ray.prototype.isIntersectionBox = function (box) {
		console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
		return this.intersectsBox(box);
	};

	Ray.prototype.isIntersectionPlane = function (plane) {
		console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
		return this.intersectsPlane(plane);
	};

	Ray.prototype.isIntersectionSphere = function (sphere) {
		console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
		return this.intersectsSphere(sphere);
	}; //


	Triangle.prototype.area = function () {
		console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
		return this.getArea();
	};

	Triangle.prototype.barycoordFromPoint = function (point, target) {
		console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
		return this.getBarycoord(point, target);
	};

	Triangle.prototype.midpoint = function (target) {
		console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
		return this.getMidpoint(target);
	};

	Triangle.prototypenormal = function (target) {
		console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
		return this.getNormal(target);
	};

	Triangle.prototype.plane = function (target) {
		console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
		return this.getPlane(target);
	};

	Triangle.barycoordFromPoint = function (point, a, b, c, target) {
		console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
		return Triangle.getBarycoord(point, a, b, c, target);
	};

	Triangle.normal = function (a, b, c, target) {
		console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
		return Triangle.getNormal(a, b, c, target);
	}; //


	Shape.prototype.extractAllPoints = function (divisions) {
		console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
		return this.extractPoints(divisions);
	};

	Shape.prototype.extrude = function (options) {
		console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
		return new ExtrudeGeometry(this, options);
	};

	Shape.prototype.makeGeometry = function (options) {
		console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
		return new ShapeGeometry(this, options);
	}; //


	Vector2.prototype.fromAttribute = function (attribute, index, offset) {
		console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
		return this.fromBufferAttribute(attribute, index, offset);
	};

	Vector2.prototype.distanceToManhattan = function (v) {
		console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
		return this.manhattanDistanceTo(v);
	};

	Vector2.prototype.lengthManhattan = function () {
		console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
		return this.manhattanLength();
	}; //


	Vector3.prototype.setEulerFromRotationMatrix = function () {
		console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
	};

	Vector3.prototype.setEulerFromQuaternion = function () {
		console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
	};

	Vector3.prototype.getPositionFromMatrix = function (m) {
		console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
		return this.setFromMatrixPosition(m);
	};

	Vector3.prototype.getScaleFromMatrix = function (m) {
		console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
		return this.setFromMatrixScale(m);
	};

	Vector3.prototype.getColumnFromMatrix = function (index, matrix) {
		console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
		return this.setFromMatrixColumn(matrix, index);
	};

	Vector3.prototype.applyProjection = function (m) {
		console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
		return this.applyMatrix4(m);
	};

	Vector3.prototype.fromAttribute = function (attribute, index, offset) {
		console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
		return this.fromBufferAttribute(attribute, index, offset);
	};

	Vector3.prototype.distanceToManhattan = function (v) {
		console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
		return this.manhattanDistanceTo(v);
	};

	Vector3.prototype.lengthManhattan = function () {
		console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
		return this.manhattanLength();
	}; //


	Vector4.prototype.fromAttribute = function (attribute, index, offset) {
		console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
		return this.fromBufferAttribute(attribute, index, offset);
	};

	Vector4.prototype.lengthManhattan = function () {
		console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
		return this.manhattanLength();
	}; //


	Object3D.prototype.getChildByName = function (name) {
		console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
		return this.getObjectByName(name);
	};

	Object3D.prototype.renderDepth = function () {
		console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
	};

	Object3D.prototype.translate = function (distance, axis) {
		console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
		return this.translateOnAxis(axis, distance);
	};

	Object3D.prototype.getWorldRotation = function () {
		console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');
	};

	Object3D.prototype.applyMatrix = function (matrix) {
		console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');
		return this.applyMatrix4(matrix);
	};

	Object.defineProperties(Object3D.prototype, {
		eulerOrder: {
			get: function () {
				console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
				return this.rotation.order;
			},
			set: function (value) {
				console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
				this.rotation.order = value;
			}
		},
		useQuaternion: {
			get: function () {
				console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
			},
			set: function () {
				console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
			}
		}
	});

	Mesh.prototype.setDrawMode = function () {
		console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
	};

	Object.defineProperties(Mesh.prototype, {
		drawMode: {
			get: function () {
				console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');
				return TrianglesDrawMode;
			},
			set: function () {
				console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
			}
		}
	});

	SkinnedMesh.prototype.initBones = function () {
		console.error('THREE.SkinnedMesh: initBones() has been removed.');
	}; //


	PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {
		console.warn('THREE.PerspectiveCamera.setLens is deprecated. ' + 'Use .setFocalLength and .filmGauge for a photographic setup.');
		if (filmGauge !== undefined) this.filmGauge = filmGauge;
		this.setFocalLength(focalLength);
	}; //


	Object.defineProperties(Light.prototype, {
		onlyShadow: {
			set: function () {
				console.warn('THREE.Light: .onlyShadow has been removed.');
			}
		},
		shadowCameraFov: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
				this.shadow.camera.fov = value;
			}
		},
		shadowCameraLeft: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
				this.shadow.camera.left = value;
			}
		},
		shadowCameraRight: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
				this.shadow.camera.right = value;
			}
		},
		shadowCameraTop: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
				this.shadow.camera.top = value;
			}
		},
		shadowCameraBottom: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
				this.shadow.camera.bottom = value;
			}
		},
		shadowCameraNear: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
				this.shadow.camera.near = value;
			}
		},
		shadowCameraFar: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
				this.shadow.camera.far = value;
			}
		},
		shadowCameraVisible: {
			set: function () {
				console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
			}
		},
		shadowBias: {
			set: function (value) {
				console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
				this.shadow.bias = value;
			}
		},
		shadowDarkness: {
			set: function () {
				console.warn('THREE.Light: .shadowDarkness has been removed.');
			}
		},
		shadowMapWidth: {
			set: function (value) {
				console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
				this.shadow.mapSize.width = value;
			}
		},
		shadowMapHeight: {
			set: function (value) {
				console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
				this.shadow.mapSize.height = value;
			}
		}
	}); //

	Object.defineProperties(BufferAttribute.prototype, {
		length: {
			get: function () {
				console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
				return this.array.length;
			}
		},
		dynamic: {
			get: function () {
				console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
				return this.usage === DynamicDrawUsage;
			},
			set: function () {
				console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
				this.setUsage(DynamicDrawUsage);
			}
		}
	});

	BufferAttribute.prototype.setDynamic = function (value) {
		console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');
		this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
		return this;
	};

	BufferAttribute.prototype.copyIndicesArray = function () {
		console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
	}, BufferAttribute.prototype.setArray = function () {
		console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
	}; //

	BufferGeometry.prototype.addIndex = function (index) {
		console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
		this.setIndex(index);
	};

	BufferGeometry.prototype.addAttribute = function (name, attribute) {
		console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');

		if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
			console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
			return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
		}

		if (name === 'index') {
			console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
			this.setIndex(attribute);
			return this;
		}

		return this.setAttribute(name, attribute);
	};

	BufferGeometry.prototype.addDrawCall = function (start, count, indexOffset) {
		if (indexOffset !== undefined) {
			console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
		}

		console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
		this.addGroup(start, count);
	};

	BufferGeometry.prototype.clearDrawCalls = function () {
		console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
		this.clearGroups();
	};

	BufferGeometry.prototype.computeOffsets = function () {
		console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
	};

	BufferGeometry.prototype.removeAttribute = function (name) {
		console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');
		return this.deleteAttribute(name);
	};

	BufferGeometry.prototype.applyMatrix = function (matrix) {
		console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');
		return this.applyMatrix4(matrix);
	};

	Object.defineProperties(BufferGeometry.prototype, {
		drawcalls: {
			get: function () {
				console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
				return this.groups;
			}
		},
		offsets: {
			get: function () {
				console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
				return this.groups;
			}
		}
	});

	InterleavedBuffer.prototype.setDynamic = function (value) {
		console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');
		this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
		return this;
	};

	InterleavedBuffer.prototype.setArray = function () {
		console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
	}; //


	ExtrudeGeometry.prototype.getArrays = function () {
		console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.');
	};

	ExtrudeGeometry.prototype.addShapeList = function () {
		console.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.');
	};

	ExtrudeGeometry.prototype.addShape = function () {
		console.error('THREE.ExtrudeGeometry: .addShape() has been removed.');
	}; //


	Scene.prototype.dispose = function () {
		console.error('THREE.Scene: .dispose() has been removed.');
	}; //


	Uniform.prototype.onUpdate = function () {
		console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
		return this;
	}; //


	Object.defineProperties(Material.prototype, {
		wrapAround: {
			get: function () {
				console.warn('THREE.Material: .wrapAround has been removed.');
			},
			set: function () {
				console.warn('THREE.Material: .wrapAround has been removed.');
			}
		},
		overdraw: {
			get: function () {
				console.warn('THREE.Material: .overdraw has been removed.');
			},
			set: function () {
				console.warn('THREE.Material: .overdraw has been removed.');
			}
		},
		wrapRGB: {
			get: function () {
				console.warn('THREE.Material: .wrapRGB has been removed.');
				return new Color();
			}
		},
		shading: {
			get: function () {
				console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
			},
			set: function (value) {
				console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
				this.flatShading = value === FlatShading;
			}
		},
		stencilMask: {
			get: function () {
				console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
				return this.stencilFuncMask;
			},
			set: function (value) {
				console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
				this.stencilFuncMask = value;
			}
		},
		vertexTangents: {
			get: function () {
				console.warn('THREE.' + this.type + ': .vertexTangents has been removed.');
			},
			set: function () {
				console.warn('THREE.' + this.type + ': .vertexTangents has been removed.');
			}
		}
	});
	Object.defineProperties(ShaderMaterial.prototype, {
		derivatives: {
			get: function () {
				console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
				return this.extensions.derivatives;
			},
			set: function (value) {
				console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
				this.extensions.derivatives = value;
			}
		}
	}); //

	WebGLRenderer.prototype.clearTarget = function (renderTarget, color, depth, stencil) {
		console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');
		this.setRenderTarget(renderTarget);
		this.clear(color, depth, stencil);
	};

	WebGLRenderer.prototype.animate = function (callback) {
		console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
		this.setAnimationLoop(callback);
	};

	WebGLRenderer.prototype.getCurrentRenderTarget = function () {
		console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
		return this.getRenderTarget();
	};

	WebGLRenderer.prototype.getMaxAnisotropy = function () {
		console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
		return this.capabilities.getMaxAnisotropy();
	};

	WebGLRenderer.prototype.getPrecision = function () {
		console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
		return this.capabilities.precision;
	};

	WebGLRenderer.prototype.resetGLState = function () {
		console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
		return this.state.reset();
	};

	WebGLRenderer.prototype.supportsFloatTextures = function () {
		console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
		return this.extensions.get('OES_texture_float');
	};

	WebGLRenderer.prototype.supportsHalfFloatTextures = function () {
		console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
		return this.extensions.get('OES_texture_half_float');
	};

	WebGLRenderer.prototype.supportsStandardDerivatives = function () {
		console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
		return this.extensions.get('OES_standard_derivatives');
	};

	WebGLRenderer.prototype.supportsCompressedTextureS3TC = function () {
		console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
		return this.extensions.get('WEBGL_compressed_texture_s3tc');
	};

	WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () {
		console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
		return this.extensions.get('WEBGL_compressed_texture_pvrtc');
	};

	WebGLRenderer.prototype.supportsBlendMinMax = function () {
		console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
		return this.extensions.get('EXT_blend_minmax');
	};

	WebGLRenderer.prototype.supportsVertexTextures = function () {
		console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
		return this.capabilities.vertexTextures;
	};

	WebGLRenderer.prototype.supportsInstancedArrays = function () {
		console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
		return this.extensions.get('ANGLE_instanced_arrays');
	};

	WebGLRenderer.prototype.enableScissorTest = function (boolean) {
		console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
		this.setScissorTest(boolean);
	};

	WebGLRenderer.prototype.initMaterial = function () {
		console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
	};

	WebGLRenderer.prototype.addPrePlugin = function () {
		console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
	};

	WebGLRenderer.prototype.addPostPlugin = function () {
		console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
	};

	WebGLRenderer.prototype.updateShadowMap = function () {
		console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
	};

	WebGLRenderer.prototype.setFaceCulling = function () {
		console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
	};

	WebGLRenderer.prototype.allocTextureUnit = function () {
		console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');
	};

	WebGLRenderer.prototype.setTexture = function () {
		console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');
	};

	WebGLRenderer.prototype.setTexture2D = function () {
		console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');
	};

	WebGLRenderer.prototype.setTextureCube = function () {
		console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');
	};

	WebGLRenderer.prototype.getActiveMipMapLevel = function () {
		console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');
		return this.getActiveMipmapLevel();
	};

	Object.defineProperties(WebGLRenderer.prototype, {
		shadowMapEnabled: {
			get: function () {
				return this.shadowMap.enabled;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
				this.shadowMap.enabled = value;
			}
		},
		shadowMapType: {
			get: function () {
				return this.shadowMap.type;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
				this.shadowMap.type = value;
			}
		},
		shadowMapCullFace: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set: function () {
				console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
			}
		},
		context: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');
				return this.getContext();
			}
		},
		vr: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');
				return this.xr;
			}
		},
		gammaInput: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
				return false;
			},
			set: function () {
				console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
			}
		},
		gammaOutput: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
				return false;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
				this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
			}
		},
		toneMappingWhitePoint: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
				return 1.0;
			},
			set: function () {
				console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
			}
		}
	});
	Object.defineProperties(WebGLShadowMap.prototype, {
		cullFace: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set: function () {
				console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
			}
		},
		renderReverseSided: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set: function () {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
			}
		},
		renderSingleSided: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set: function () {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
			}
		}
	});
	function WebGLRenderTargetCube(width, height, options) {
		console.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).');
		return new WebGLCubeRenderTarget(width, options);
	} //

	Object.defineProperties(WebGLRenderTarget.prototype, {
		wrapS: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
				return this.texture.wrapS;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
				this.texture.wrapS = value;
			}
		},
		wrapT: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
				return this.texture.wrapT;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
				this.texture.wrapT = value;
			}
		},
		magFilter: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
				return this.texture.magFilter;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
				this.texture.magFilter = value;
			}
		},
		minFilter: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
				return this.texture.minFilter;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
				this.texture.minFilter = value;
			}
		},
		anisotropy: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
				return this.texture.anisotropy;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
				this.texture.anisotropy = value;
			}
		},
		offset: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
				return this.texture.offset;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
				this.texture.offset = value;
			}
		},
		repeat: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
				return this.texture.repeat;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
				this.texture.repeat = value;
			}
		},
		format: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
				return this.texture.format;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
				this.texture.format = value;
			}
		},
		type: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
				return this.texture.type;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
				this.texture.type = value;
			}
		},
		generateMipmaps: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
				return this.texture.generateMipmaps;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
				this.texture.generateMipmaps = value;
			}
		}
	}); //

	Audio.prototype.load = function (file) {
		console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
		const scope = this;
		const audioLoader = new AudioLoader();
		audioLoader.load(file, function (buffer) {
			scope.setBuffer(buffer);
		});
		return this;
	};

	AudioAnalyser.prototype.getData = function () {
		console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
		return this.getFrequencyData();
	}; //


	CubeCamera.prototype.updateCubeMap = function (renderer, scene) {
		console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
		return this.update(renderer, scene);
	};

	CubeCamera.prototype.clear = function (renderer, color, depth, stencil) {
		console.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().');
		return this.renderTarget.clear(renderer, color, depth, stencil);
	};

	ImageUtils.crossOrigin = undefined;

	ImageUtils.loadTexture = function (url, mapping, onLoad, onError) {
		console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
		const loader = new TextureLoader();
		loader.setCrossOrigin(this.crossOrigin);
		const texture = loader.load(url, onLoad, undefined, onError);
		if (mapping) texture.mapping = mapping;
		return texture;
	};

	ImageUtils.loadTextureCube = function (urls, mapping, onLoad, onError) {
		console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
		const loader = new CubeTextureLoader();
		loader.setCrossOrigin(this.crossOrigin);
		const texture = loader.load(urls, onLoad, undefined, onError);
		if (mapping) texture.mapping = mapping;
		return texture;
	};

	ImageUtils.loadCompressedTexture = function () {
		console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
	};

	ImageUtils.loadCompressedTextureCube = function () {
		console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
	}; //


	function CanvasRenderer() {
		console.error('THREE.CanvasRenderer has been removed');
	} //

	function JSONLoader() {
		console.error('THREE.JSONLoader has been removed.');
	} //

	const SceneUtils = {
		createMultiMaterialObject: function () {
			console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
		},
		detach: function () {
			console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
		},
		attach: function () {
			console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
		}
	}; //

	function LensFlare() {
		console.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js');
	} //

	function ParametricGeometry() {
		console.error('THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js');
		return new BufferGeometry();
	}
	function TextGeometry() {
		console.error('THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js');
		return new BufferGeometry();
	}
	function FontLoader() {
		console.error('THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js');
	}
	function Font() {
		console.error('THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js');
	}
	function ImmediateRenderObject() {
		console.error('THREE.ImmediateRenderObject has been removed.');
	}

	if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
		/* eslint-disable no-undef */
		__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
			detail: {
				revision: REVISION
			}
		}));
		/* eslint-enable no-undef */

	}

	if (typeof window !== 'undefined') {
		if (window.__THREE__) {
			console.warn('WARNING: Multiple instances of Three.js being imported.');
		} else {
			window.__THREE__ = REVISION;
		}
	}

	exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
	exports.AddEquation = AddEquation;
	exports.AddOperation = AddOperation;
	exports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;
	exports.AdditiveBlending = AdditiveBlending;
	exports.AlphaFormat = AlphaFormat;
	exports.AlwaysDepth = AlwaysDepth;
	exports.AlwaysStencilFunc = AlwaysStencilFunc;
	exports.AmbientLight = AmbientLight;
	exports.AmbientLightProbe = AmbientLightProbe;
	exports.AnimationClip = AnimationClip;
	exports.AnimationLoader = AnimationLoader;
	exports.AnimationMixer = AnimationMixer;
	exports.AnimationObjectGroup = AnimationObjectGroup;
	exports.AnimationUtils = AnimationUtils;
	exports.ArcCurve = ArcCurve;
	exports.ArrayCamera = ArrayCamera;
	exports.ArrowHelper = ArrowHelper;
	exports.Audio = Audio;
	exports.AudioAnalyser = AudioAnalyser;
	exports.AudioContext = AudioContext;
	exports.AudioListener = AudioListener;
	exports.AudioLoader = AudioLoader;
	exports.AxesHelper = AxesHelper;
	exports.AxisHelper = AxisHelper;
	exports.BackSide = BackSide;
	exports.BasicDepthPacking = BasicDepthPacking;
	exports.BasicShadowMap = BasicShadowMap;
	exports.BinaryTextureLoader = BinaryTextureLoader;
	exports.Bone = Bone;
	exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
	exports.BoundingBoxHelper = BoundingBoxHelper;
	exports.Box2 = Box2;
	exports.Box3 = Box3;
	exports.Box3Helper = Box3Helper;
	exports.BoxBufferGeometry = BoxGeometry;
	exports.BoxGeometry = BoxGeometry;
	exports.BoxHelper = BoxHelper;
	exports.BufferAttribute = BufferAttribute;
	exports.BufferGeometry = BufferGeometry;
	exports.BufferGeometryLoader = BufferGeometryLoader;
	exports.ByteType = ByteType;
	exports.Cache = Cache;
	exports.Camera = Camera;
	exports.CameraHelper = CameraHelper;
	exports.CanvasRenderer = CanvasRenderer;
	exports.CanvasTexture = CanvasTexture;
	exports.CatmullRomCurve3 = CatmullRomCurve3;
	exports.CineonToneMapping = CineonToneMapping;
	exports.CircleBufferGeometry = CircleGeometry;
	exports.CircleGeometry = CircleGeometry;
	exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
	exports.Clock = Clock;
	exports.Color = Color;
	exports.ColorKeyframeTrack = ColorKeyframeTrack;
	exports.CompressedTexture = CompressedTexture;
	exports.CompressedTextureLoader = CompressedTextureLoader;
	exports.ConeBufferGeometry = ConeGeometry;
	exports.ConeGeometry = ConeGeometry;
	exports.CubeCamera = CubeCamera;
	exports.CubeReflectionMapping = CubeReflectionMapping;
	exports.CubeRefractionMapping = CubeRefractionMapping;
	exports.CubeTexture = CubeTexture;
	exports.CubeTextureLoader = CubeTextureLoader;
	exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
	exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
	exports.CubicBezierCurve = CubicBezierCurve;
	exports.CubicBezierCurve3 = CubicBezierCurve3;
	exports.CubicInterpolant = CubicInterpolant;
	exports.CullFaceBack = CullFaceBack;
	exports.CullFaceFront = CullFaceFront;
	exports.CullFaceFrontBack = CullFaceFrontBack;
	exports.CullFaceNone = CullFaceNone;
	exports.Curve = Curve;
	exports.CurvePath = CurvePath;
	exports.CustomBlending = CustomBlending;
	exports.CustomToneMapping = CustomToneMapping;
	exports.CylinderBufferGeometry = CylinderGeometry;
	exports.CylinderGeometry = CylinderGeometry;
	exports.Cylindrical = Cylindrical;
	exports.DataTexture = DataTexture;
	exports.DataTexture2DArray = DataTexture2DArray;
	exports.DataTexture3D = DataTexture3D;
	exports.DataTextureLoader = DataTextureLoader;
	exports.DataUtils = DataUtils;
	exports.DecrementStencilOp = DecrementStencilOp;
	exports.DecrementWrapStencilOp = DecrementWrapStencilOp;
	exports.DefaultLoadingManager = DefaultLoadingManager;
	exports.DepthFormat = DepthFormat;
	exports.DepthStencilFormat = DepthStencilFormat;
	exports.DepthTexture = DepthTexture;
	exports.DirectionalLight = DirectionalLight;
	exports.DirectionalLightHelper = DirectionalLightHelper;
	exports.DiscreteInterpolant = DiscreteInterpolant;
	exports.DodecahedronBufferGeometry = DodecahedronGeometry;
	exports.DodecahedronGeometry = DodecahedronGeometry;
	exports.DoubleSide = DoubleSide;
	exports.DstAlphaFactor = DstAlphaFactor;
	exports.DstColorFactor = DstColorFactor;
	exports.DynamicBufferAttribute = DynamicBufferAttribute;
	exports.DynamicCopyUsage = DynamicCopyUsage;
	exports.DynamicDrawUsage = DynamicDrawUsage;
	exports.DynamicReadUsage = DynamicReadUsage;
	exports.EdgesGeometry = EdgesGeometry;
	exports.EdgesHelper = EdgesHelper;
	exports.EllipseCurve = EllipseCurve;
	exports.EqualDepth = EqualDepth;
	exports.EqualStencilFunc = EqualStencilFunc;
	exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
	exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
	exports.Euler = Euler;
	exports.EventDispatcher = EventDispatcher;
	exports.ExtrudeBufferGeometry = ExtrudeGeometry;
	exports.ExtrudeGeometry = ExtrudeGeometry;
	exports.FaceColors = FaceColors;
	exports.FileLoader = FileLoader;
	exports.FlatShading = FlatShading;
	exports.Float16BufferAttribute = Float16BufferAttribute;
	exports.Float32Attribute = Float32Attribute;
	exports.Float32BufferAttribute = Float32BufferAttribute;
	exports.Float64Attribute = Float64Attribute;
	exports.Float64BufferAttribute = Float64BufferAttribute;
	exports.FloatType = FloatType;
	exports.Fog = Fog;
	exports.FogExp2 = FogExp2;
	exports.Font = Font;
	exports.FontLoader = FontLoader;
	exports.FrontSide = FrontSide;
	exports.Frustum = Frustum;
	exports.GLBufferAttribute = GLBufferAttribute;
	exports.GLSL1 = GLSL1;
	exports.GLSL3 = GLSL3;
	exports.GammaEncoding = GammaEncoding;
	exports.GreaterDepth = GreaterDepth;
	exports.GreaterEqualDepth = GreaterEqualDepth;
	exports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
	exports.GreaterStencilFunc = GreaterStencilFunc;
	exports.GridHelper = GridHelper;
	exports.Group = Group;
	exports.HalfFloatType = HalfFloatType;
	exports.HemisphereLight = HemisphereLight;
	exports.HemisphereLightHelper = HemisphereLightHelper;
	exports.HemisphereLightProbe = HemisphereLightProbe;
	exports.IcosahedronBufferGeometry = IcosahedronGeometry;
	exports.IcosahedronGeometry = IcosahedronGeometry;
	exports.ImageBitmapLoader = ImageBitmapLoader;
	exports.ImageLoader = ImageLoader;
	exports.ImageUtils = ImageUtils;
	exports.ImmediateRenderObject = ImmediateRenderObject;
	exports.IncrementStencilOp = IncrementStencilOp;
	exports.IncrementWrapStencilOp = IncrementWrapStencilOp;
	exports.InstancedBufferAttribute = InstancedBufferAttribute;
	exports.InstancedBufferGeometry = InstancedBufferGeometry;
	exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
	exports.InstancedMesh = InstancedMesh;
	exports.Int16Attribute = Int16Attribute;
	exports.Int16BufferAttribute = Int16BufferAttribute;
	exports.Int32Attribute = Int32Attribute;
	exports.Int32BufferAttribute = Int32BufferAttribute;
	exports.Int8Attribute = Int8Attribute;
	exports.Int8BufferAttribute = Int8BufferAttribute;
	exports.IntType = IntType;
	exports.InterleavedBuffer = InterleavedBuffer;
	exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
	exports.Interpolant = Interpolant;
	exports.InterpolateDiscrete = InterpolateDiscrete;
	exports.InterpolateLinear = InterpolateLinear;
	exports.InterpolateSmooth = InterpolateSmooth;
	exports.InvertStencilOp = InvertStencilOp;
	exports.JSONLoader = JSONLoader;
	exports.KeepStencilOp = KeepStencilOp;
	exports.KeyframeTrack = KeyframeTrack;
	exports.LOD = LOD;
	exports.LatheBufferGeometry = LatheGeometry;
	exports.LatheGeometry = LatheGeometry;
	exports.Layers = Layers;
	exports.LensFlare = LensFlare;
	exports.LessDepth = LessDepth;
	exports.LessEqualDepth = LessEqualDepth;
	exports.LessEqualStencilFunc = LessEqualStencilFunc;
	exports.LessStencilFunc = LessStencilFunc;
	exports.Light = Light;
	exports.LightProbe = LightProbe;
	exports.Line = Line;
	exports.Line3 = Line3;
	exports.LineBasicMaterial = LineBasicMaterial;
	exports.LineCurve = LineCurve;
	exports.LineCurve3 = LineCurve3;
	exports.LineDashedMaterial = LineDashedMaterial;
	exports.LineLoop = LineLoop;
	exports.LinePieces = LinePieces;
	exports.LineSegments = LineSegments;
	exports.LineStrip = LineStrip;
	exports.LinearEncoding = LinearEncoding;
	exports.LinearFilter = LinearFilter;
	exports.LinearInterpolant = LinearInterpolant;
	exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
	exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
	exports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
	exports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
	exports.LinearToneMapping = LinearToneMapping;
	exports.Loader = Loader;
	exports.LoaderUtils = LoaderUtils;
	exports.LoadingManager = LoadingManager;
	exports.LoopOnce = LoopOnce;
	exports.LoopPingPong = LoopPingPong;
	exports.LoopRepeat = LoopRepeat;
	exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
	exports.LuminanceFormat = LuminanceFormat;
	exports.MOUSE = MOUSE;
	exports.Material = Material;
	exports.MaterialLoader = MaterialLoader;
	exports.Math = MathUtils;
	exports.MathUtils = MathUtils;
	exports.Matrix3 = Matrix3;
	exports.Matrix4 = Matrix4;
	exports.MaxEquation = MaxEquation;
	exports.Mesh = Mesh;
	exports.MeshBasicMaterial = MeshBasicMaterial;
	exports.MeshDepthMaterial = MeshDepthMaterial;
	exports.MeshDistanceMaterial = MeshDistanceMaterial;
	exports.MeshFaceMaterial = MeshFaceMaterial;
	exports.MeshLambertMaterial = MeshLambertMaterial;
	exports.MeshMatcapMaterial = MeshMatcapMaterial;
	exports.MeshNormalMaterial = MeshNormalMaterial;
	exports.MeshPhongMaterial = MeshPhongMaterial;
	exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
	exports.MeshStandardMaterial = MeshStandardMaterial;
	exports.MeshToonMaterial = MeshToonMaterial;
	exports.MinEquation = MinEquation;
	exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
	exports.MixOperation = MixOperation;
	exports.MultiMaterial = MultiMaterial;
	exports.MultiplyBlending = MultiplyBlending;
	exports.MultiplyOperation = MultiplyOperation;
	exports.NearestFilter = NearestFilter;
	exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
	exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
	exports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
	exports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
	exports.NeverDepth = NeverDepth;
	exports.NeverStencilFunc = NeverStencilFunc;
	exports.NoBlending = NoBlending;
	exports.NoColors = NoColors;
	exports.NoToneMapping = NoToneMapping;
	exports.NormalAnimationBlendMode = NormalAnimationBlendMode;
	exports.NormalBlending = NormalBlending;
	exports.NotEqualDepth = NotEqualDepth;
	exports.NotEqualStencilFunc = NotEqualStencilFunc;
	exports.NumberKeyframeTrack = NumberKeyframeTrack;
	exports.Object3D = Object3D;
	exports.ObjectLoader = ObjectLoader;
	exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
	exports.OctahedronBufferGeometry = OctahedronGeometry;
	exports.OctahedronGeometry = OctahedronGeometry;
	exports.OneFactor = OneFactor;
	exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
	exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
	exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
	exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
	exports.OrthographicCamera = OrthographicCamera;
	exports.PCFShadowMap = PCFShadowMap;
	exports.PCFSoftShadowMap = PCFSoftShadowMap;
	exports.PMREMGenerator = PMREMGenerator;
	exports.ParametricGeometry = ParametricGeometry;
	exports.Particle = Particle;
	exports.ParticleBasicMaterial = ParticleBasicMaterial;
	exports.ParticleSystem = ParticleSystem;
	exports.ParticleSystemMaterial = ParticleSystemMaterial;
	exports.Path = Path;
	exports.PerspectiveCamera = PerspectiveCamera;
	exports.Plane = Plane;
	exports.PlaneBufferGeometry = PlaneGeometry;
	exports.PlaneGeometry = PlaneGeometry;
	exports.PlaneHelper = PlaneHelper;
	exports.PointCloud = PointCloud;
	exports.PointCloudMaterial = PointCloudMaterial;
	exports.PointLight = PointLight;
	exports.PointLightHelper = PointLightHelper;
	exports.Points = Points;
	exports.PointsMaterial = PointsMaterial;
	exports.PolarGridHelper = PolarGridHelper;
	exports.PolyhedronBufferGeometry = PolyhedronGeometry;
	exports.PolyhedronGeometry = PolyhedronGeometry;
	exports.PositionalAudio = PositionalAudio;
	exports.PropertyBinding = PropertyBinding;
	exports.PropertyMixer = PropertyMixer;
	exports.QuadraticBezierCurve = QuadraticBezierCurve;
	exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
	exports.Quaternion = Quaternion;
	exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
	exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
	exports.REVISION = REVISION;
	exports.RGBADepthPacking = RGBADepthPacking;
	exports.RGBAFormat = RGBAFormat;
	exports.RGBAIntegerFormat = RGBAIntegerFormat;
	exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
	exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
	exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
	exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
	exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
	exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
	exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
	exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
	exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
	exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
	exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
	exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
	exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
	exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
	exports.RGBA_BPTC_Format = RGBA_BPTC_Format;
	exports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;
	exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
	exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
	exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
	exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
	exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
	exports.RGBDEncoding = RGBDEncoding;
	exports.RGBEEncoding = RGBEEncoding;
	exports.RGBEFormat = RGBEFormat;
	exports.RGBFormat = RGBFormat;
	exports.RGBIntegerFormat = RGBIntegerFormat;
	exports.RGBM16Encoding = RGBM16Encoding;
	exports.RGBM7Encoding = RGBM7Encoding;
	exports.RGB_ETC1_Format = RGB_ETC1_Format;
	exports.RGB_ETC2_Format = RGB_ETC2_Format;
	exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
	exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
	exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
	exports.RGFormat = RGFormat;
	exports.RGIntegerFormat = RGIntegerFormat;
	exports.RawShaderMaterial = RawShaderMaterial;
	exports.Ray = Ray;
	exports.Raycaster = Raycaster;
	exports.RectAreaLight = RectAreaLight;
	exports.RedFormat = RedFormat;
	exports.RedIntegerFormat = RedIntegerFormat;
	exports.ReinhardToneMapping = ReinhardToneMapping;
	exports.RepeatWrapping = RepeatWrapping;
	exports.ReplaceStencilOp = ReplaceStencilOp;
	exports.ReverseSubtractEquation = ReverseSubtractEquation;
	exports.RingBufferGeometry = RingGeometry;
	exports.RingGeometry = RingGeometry;
	exports.SRGB8_ALPHA8_ASTC_10x10_Format = SRGB8_ALPHA8_ASTC_10x10_Format;
	exports.SRGB8_ALPHA8_ASTC_10x5_Format = SRGB8_ALPHA8_ASTC_10x5_Format;
	exports.SRGB8_ALPHA8_ASTC_10x6_Format = SRGB8_ALPHA8_ASTC_10x6_Format;
	exports.SRGB8_ALPHA8_ASTC_10x8_Format = SRGB8_ALPHA8_ASTC_10x8_Format;
	exports.SRGB8_ALPHA8_ASTC_12x10_Format = SRGB8_ALPHA8_ASTC_12x10_Format;
	exports.SRGB8_ALPHA8_ASTC_12x12_Format = SRGB8_ALPHA8_ASTC_12x12_Format;
	exports.SRGB8_ALPHA8_ASTC_4x4_Format = SRGB8_ALPHA8_ASTC_4x4_Format;
	exports.SRGB8_ALPHA8_ASTC_5x4_Format = SRGB8_ALPHA8_ASTC_5x4_Format;
	exports.SRGB8_ALPHA8_ASTC_5x5_Format = SRGB8_ALPHA8_ASTC_5x5_Format;
	exports.SRGB8_ALPHA8_ASTC_6x5_Format = SRGB8_ALPHA8_ASTC_6x5_Format;
	exports.SRGB8_ALPHA8_ASTC_6x6_Format = SRGB8_ALPHA8_ASTC_6x6_Format;
	exports.SRGB8_ALPHA8_ASTC_8x5_Format = SRGB8_ALPHA8_ASTC_8x5_Format;
	exports.SRGB8_ALPHA8_ASTC_8x6_Format = SRGB8_ALPHA8_ASTC_8x6_Format;
	exports.SRGB8_ALPHA8_ASTC_8x8_Format = SRGB8_ALPHA8_ASTC_8x8_Format;
	exports.Scene = Scene;
	exports.SceneUtils = SceneUtils;
	exports.ShaderChunk = ShaderChunk;
	exports.ShaderLib = ShaderLib;
	exports.ShaderMaterial = ShaderMaterial;
	exports.ShadowMaterial = ShadowMaterial;
	exports.Shape = Shape;
	exports.ShapeBufferGeometry = ShapeGeometry;
	exports.ShapeGeometry = ShapeGeometry;
	exports.ShapePath = ShapePath;
	exports.ShapeUtils = ShapeUtils;
	exports.ShortType = ShortType;
	exports.Skeleton = Skeleton;
	exports.SkeletonHelper = SkeletonHelper;
	exports.SkinnedMesh = SkinnedMesh;
	exports.SmoothShading = SmoothShading;
	exports.Sphere = Sphere;
	exports.SphereBufferGeometry = SphereGeometry;
	exports.SphereGeometry = SphereGeometry;
	exports.Spherical = Spherical;
	exports.SphericalHarmonics3 = SphericalHarmonics3;
	exports.SplineCurve = SplineCurve;
	exports.SpotLight = SpotLight;
	exports.SpotLightHelper = SpotLightHelper;
	exports.Sprite = Sprite;
	exports.SpriteMaterial = SpriteMaterial;
	exports.SrcAlphaFactor = SrcAlphaFactor;
	exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
	exports.SrcColorFactor = SrcColorFactor;
	exports.StaticCopyUsage = StaticCopyUsage;
	exports.StaticDrawUsage = StaticDrawUsage;
	exports.StaticReadUsage = StaticReadUsage;
	exports.StereoCamera = StereoCamera;
	exports.StreamCopyUsage = StreamCopyUsage;
	exports.StreamDrawUsage = StreamDrawUsage;
	exports.StreamReadUsage = StreamReadUsage;
	exports.StringKeyframeTrack = StringKeyframeTrack;
	exports.SubtractEquation = SubtractEquation;
	exports.SubtractiveBlending = SubtractiveBlending;
	exports.TOUCH = TOUCH;
	exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
	exports.TetrahedronBufferGeometry = TetrahedronGeometry;
	exports.TetrahedronGeometry = TetrahedronGeometry;
	exports.TextGeometry = TextGeometry;
	exports.Texture = Texture;
	exports.TextureLoader = TextureLoader;
	exports.TorusBufferGeometry = TorusGeometry;
	exports.TorusGeometry = TorusGeometry;
	exports.TorusKnotBufferGeometry = TorusKnotGeometry;
	exports.TorusKnotGeometry = TorusKnotGeometry;
	exports.Triangle = Triangle;
	exports.TriangleFanDrawMode = TriangleFanDrawMode;
	exports.TriangleStripDrawMode = TriangleStripDrawMode;
	exports.TrianglesDrawMode = TrianglesDrawMode;
	exports.TubeBufferGeometry = TubeGeometry;
	exports.TubeGeometry = TubeGeometry;
	exports.UVMapping = UVMapping;
	exports.Uint16Attribute = Uint16Attribute;
	exports.Uint16BufferAttribute = Uint16BufferAttribute;
	exports.Uint32Attribute = Uint32Attribute;
	exports.Uint32BufferAttribute = Uint32BufferAttribute;
	exports.Uint8Attribute = Uint8Attribute;
	exports.Uint8BufferAttribute = Uint8BufferAttribute;
	exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
	exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
	exports.Uniform = Uniform;
	exports.UniformsLib = UniformsLib;
	exports.UniformsUtils = UniformsUtils;
	exports.UnsignedByteType = UnsignedByteType;
	exports.UnsignedInt248Type = UnsignedInt248Type;
	exports.UnsignedIntType = UnsignedIntType;
	exports.UnsignedShort4444Type = UnsignedShort4444Type;
	exports.UnsignedShort5551Type = UnsignedShort5551Type;
	exports.UnsignedShort565Type = UnsignedShort565Type;
	exports.UnsignedShortType = UnsignedShortType;
	exports.VSMShadowMap = VSMShadowMap;
	exports.Vector2 = Vector2;
	exports.Vector3 = Vector3;
	exports.Vector4 = Vector4;
	exports.VectorKeyframeTrack = VectorKeyframeTrack;
	exports.Vertex = Vertex;
	exports.VertexColors = VertexColors;
	exports.VideoTexture = VideoTexture;
	exports.WebGL1Renderer = WebGL1Renderer;
	exports.WebGLCubeRenderTarget = WebGLCubeRenderTarget;
	exports.WebGLMultipleRenderTargets = WebGLMultipleRenderTargets;
	exports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;
	exports.WebGLRenderTarget = WebGLRenderTarget;
	exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
	exports.WebGLRenderer = WebGLRenderer;
	exports.WebGLUtils = WebGLUtils;
	exports.WireframeGeometry = WireframeGeometry;
	exports.WireframeHelper = WireframeHelper;
	exports.WrapAroundEnding = WrapAroundEnding;
	exports.XHRLoader = XHRLoader;
	exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
	exports.ZeroFactor = ZeroFactor;
	exports.ZeroSlopeEnding = ZeroSlopeEnding;
	exports.ZeroStencilOp = ZeroStencilOp;
	exports.sRGBEncoding = sRGBEncoding;

	Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],23:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DRACOLoader = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _three = require("three");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _taskCache = new WeakMap();

var DRACOLoader = function (_Loader) {
  (0, _inherits2["default"])(DRACOLoader, _Loader);

  var _super = _createSuper(DRACOLoader);

  function DRACOLoader(manager) {
    var _this;

    (0, _classCallCheck2["default"])(this, DRACOLoader);
    _this = _super.call(this, manager);
    _this.decoderPath = '';
    _this.decoderConfig = {};
    _this.decoderBinary = null;
    _this.decoderPending = null;
    _this.workerLimit = 4;
    _this.workerPool = [];
    _this.workerNextTaskID = 1;
    _this.workerSourceURL = '';
    _this.defaultAttributeIDs = {
      position: 'POSITION',
      normal: 'NORMAL',
      color: 'COLOR',
      uv: 'TEX_COORD'
    };
    _this.defaultAttributeTypes = {
      position: 'Float32Array',
      normal: 'Float32Array',
      color: 'Float32Array',
      uv: 'Float32Array'
    };
    return _this;
  }

  (0, _createClass2["default"])(DRACOLoader, [{
    key: "setDecoderPath",
    value: function setDecoderPath(path) {
      this.decoderPath = path;
      return this;
    }
  }, {
    key: "setDecoderConfig",
    value: function setDecoderConfig(config) {
      this.decoderConfig = config;
      return this;
    }
  }, {
    key: "setWorkerLimit",
    value: function setWorkerLimit(workerLimit) {
      this.workerLimit = workerLimit;
      return this;
    }
  }, {
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      var _this2 = this;

      var loader = new _three.FileLoader(this.manager);
      loader.setPath(this.path);
      loader.setResponseType('arraybuffer');
      loader.setRequestHeader(this.requestHeader);
      loader.setWithCredentials(this.withCredentials);
      loader.load(url, function (buffer) {
        var taskConfig = {
          attributeIDs: _this2.defaultAttributeIDs,
          attributeTypes: _this2.defaultAttributeTypes,
          useUniqueIDs: false
        };

        _this2.decodeGeometry(buffer, taskConfig).then(onLoad)["catch"](onError);
      }, onProgress, onError);
    }
  }, {
    key: "decodeDracoFile",
    value: function decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {
      var taskConfig = {
        attributeIDs: attributeIDs || this.defaultAttributeIDs,
        attributeTypes: attributeTypes || this.defaultAttributeTypes,
        useUniqueIDs: !!attributeIDs
      };
      this.decodeGeometry(buffer, taskConfig).then(callback);
    }
  }, {
    key: "decodeGeometry",
    value: function decodeGeometry(buffer, taskConfig) {
      var _this3 = this;

      for (var attribute in taskConfig.attributeTypes) {
        var type = taskConfig.attributeTypes[attribute];

        if (type.BYTES_PER_ELEMENT !== undefined) {
          taskConfig.attributeTypes[attribute] = type.name;
        }
      }

      var taskKey = JSON.stringify(taskConfig);

      if (_taskCache.has(buffer)) {
        var cachedTask = _taskCache.get(buffer);

        if (cachedTask.key === taskKey) {
          return cachedTask.promise;
        } else if (buffer.byteLength === 0) {
          throw new Error('THREE.DRACOLoader: Unable to re-decode a buffer with different ' + 'settings. Buffer has already been transferred.');
        }
      }

      var worker;
      var taskID = this.workerNextTaskID++;
      var taskCost = buffer.byteLength;

      var geometryPending = this._getWorker(taskID, taskCost).then(function (_worker) {
        worker = _worker;
        return new Promise(function (resolve, reject) {
          worker._callbacks[taskID] = {
            resolve: resolve,
            reject: reject
          };
          worker.postMessage({
            type: 'decode',
            id: taskID,
            taskConfig: taskConfig,
            buffer: buffer
          }, [buffer]);
        });
      }).then(function (message) {
        return _this3._createGeometry(message.geometry);
      });

      geometryPending["catch"](function () {
        return true;
      }).then(function () {
        if (worker && taskID) {
          _this3._releaseTask(worker, taskID);
        }
      });

      _taskCache.set(buffer, {
        key: taskKey,
        promise: geometryPending
      });

      return geometryPending;
    }
  }, {
    key: "_createGeometry",
    value: function _createGeometry(geometryData) {
      var geometry = new _three.BufferGeometry();

      if (geometryData.index) {
        geometry.setIndex(new _three.BufferAttribute(geometryData.index.array, 1));
      }

      for (var i = 0; i < geometryData.attributes.length; i++) {
        var attribute = geometryData.attributes[i];
        var name = attribute.name;
        var array = attribute.array;
        var itemSize = attribute.itemSize;
        geometry.setAttribute(name, new _three.BufferAttribute(array, itemSize));
      }

      return geometry;
    }
  }, {
    key: "_loadLibrary",
    value: function _loadLibrary(url, responseType) {
      var loader = new _three.FileLoader(this.manager);
      loader.setPath(this.decoderPath);
      loader.setResponseType(responseType);
      loader.setWithCredentials(this.withCredentials);
      return new Promise(function (resolve, reject) {
        loader.load(url, resolve, undefined, reject);
      });
    }
  }, {
    key: "preload",
    value: function preload() {
      this._initDecoder();

      return this;
    }
  }, {
    key: "_initDecoder",
    value: function _initDecoder() {
      var _this4 = this;

      if (this.decoderPending) return this.decoderPending;
      var useJS = (typeof WebAssembly === "undefined" ? "undefined" : (0, _typeof2["default"])(WebAssembly)) !== 'object' || this.decoderConfig.type === 'js';
      var librariesPending = [];

      if (useJS) {
        librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'));
      } else {
        librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'));
        librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'));
      }

      this.decoderPending = Promise.all(librariesPending).then(function (libraries) {
        var jsContent = libraries[0];

        if (!useJS) {
          _this4.decoderConfig.wasmBinary = libraries[1];
        }

        var fn = DRACOWorker.toString();
        var body = ['/* draco decoder */', jsContent, '', '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\n');
        _this4.workerSourceURL = URL.createObjectURL(new Blob([body]));
      });
      return this.decoderPending;
    }
  }, {
    key: "_getWorker",
    value: function _getWorker(taskID, taskCost) {
      var _this5 = this;

      return this._initDecoder().then(function () {
        if (_this5.workerPool.length < _this5.workerLimit) {
          var _worker2 = new Worker(_this5.workerSourceURL);

          _worker2._callbacks = {};
          _worker2._taskCosts = {};
          _worker2._taskLoad = 0;

          _worker2.postMessage({
            type: 'init',
            decoderConfig: _this5.decoderConfig
          });

          _worker2.onmessage = function (e) {
            var message = e.data;

            switch (message.type) {
              case 'decode':
                _worker2._callbacks[message.id].resolve(message);

                break;

              case 'error':
                _worker2._callbacks[message.id].reject(message);

                break;

              default:
                console.error('THREE.DRACOLoader: Unexpected message, "' + message.type + '"');
            }
          };

          _this5.workerPool.push(_worker2);
        } else {
          _this5.workerPool.sort(function (a, b) {
            return a._taskLoad > b._taskLoad ? -1 : 1;
          });
        }

        var worker = _this5.workerPool[_this5.workerPool.length - 1];
        worker._taskCosts[taskID] = taskCost;
        worker._taskLoad += taskCost;
        return worker;
      });
    }
  }, {
    key: "_releaseTask",
    value: function _releaseTask(worker, taskID) {
      worker._taskLoad -= worker._taskCosts[taskID];
      delete worker._callbacks[taskID];
      delete worker._taskCosts[taskID];
    }
  }, {
    key: "debug",
    value: function debug() {
      console.log('Task load: ', this.workerPool.map(function (worker) {
        return worker._taskLoad;
      }));
    }
  }, {
    key: "dispose",
    value: function dispose() {
      for (var i = 0; i < this.workerPool.length; ++i) {
        this.workerPool[i].terminate();
      }

      this.workerPool.length = 0;
      return this;
    }
  }]);
  return DRACOLoader;
}(_three.Loader);

exports.DRACOLoader = DRACOLoader;

function DRACOWorker() {
  var decoderConfig;
  var decoderPending;

  onmessage = function onmessage(e) {
    var message = e.data;

    switch (message.type) {
      case 'init':
        decoderConfig = message.decoderConfig;
        decoderPending = new Promise(function (resolve) {
          decoderConfig.onModuleLoaded = function (draco) {
            resolve({
              draco: draco
            });
          };

          DracoDecoderModule(decoderConfig);
        });
        break;

      case 'decode':
        var buffer = message.buffer;
        var taskConfig = message.taskConfig;
        decoderPending.then(function (module) {
          var draco = module.draco;
          var decoder = new draco.Decoder();
          var decoderBuffer = new draco.DecoderBuffer();
          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);

          try {
            var geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);
            var buffers = geometry.attributes.map(function (attr) {
              return attr.array.buffer;
            });
            if (geometry.index) buffers.push(geometry.index.array.buffer);
            self.postMessage({
              type: 'decode',
              id: message.id,
              geometry: geometry
            }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({
              type: 'error',
              id: message.id,
              error: error.message
            });
          } finally {
            draco.destroy(decoderBuffer);
            draco.destroy(decoder);
          }
        });
        break;
    }
  };

  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {
    var attributeIDs = taskConfig.attributeIDs;
    var attributeTypes = taskConfig.attributeTypes;
    var dracoGeometry;
    var decodingStatus;
    var geometryType = decoder.GetEncodedGeometryType(decoderBuffer);

    if (geometryType === draco.TRIANGULAR_MESH) {
      dracoGeometry = new draco.Mesh();
      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);
    } else if (geometryType === draco.POINT_CLOUD) {
      dracoGeometry = new draco.PointCloud();
      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);
    } else {
      throw new Error('THREE.DRACOLoader: Unexpected geometry type.');
    }

    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {
      throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg());
    }

    var geometry = {
      index: null,
      attributes: []
    };

    for (var attributeName in attributeIDs) {
      var attributeType = self[attributeTypes[attributeName]];
      var attribute = void 0;
      var attributeID = void 0;

      if (taskConfig.useUniqueIDs) {
        attributeID = attributeIDs[attributeName];
        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);
      } else {
        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);
        if (attributeID === -1) continue;
        attribute = decoder.GetAttribute(dracoGeometry, attributeID);
      }

      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));
    }

    if (geometryType === draco.TRIANGULAR_MESH) {
      geometry.index = decodeIndex(draco, decoder, dracoGeometry);
    }

    draco.destroy(dracoGeometry);
    return geometry;
  }

  function decodeIndex(draco, decoder, dracoGeometry) {
    var numFaces = dracoGeometry.num_faces();
    var numIndices = numFaces * 3;
    var byteLength = numIndices * 4;

    var ptr = draco._malloc(byteLength);

    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
    var index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();

    draco._free(ptr);

    return {
      array: index,
      itemSize: 1
    };
  }

  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {
    var numComponents = attribute.num_components();
    var numPoints = dracoGeometry.num_points();
    var numValues = numPoints * numComponents;
    var byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
    var dataType = getDracoDataType(draco, attributeType);

    var ptr = draco._malloc(byteLength);

    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);
    var array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();

    draco._free(ptr);

    return {
      name: attributeName,
      array: array,
      itemSize: numComponents
    };
  }

  function getDracoDataType(draco, attributeType) {
    switch (attributeType) {
      case Float32Array:
        return draco.DT_FLOAT32;

      case Int8Array:
        return draco.DT_INT8;

      case Int16Array:
        return draco.DT_INT16;

      case Int32Array:
        return draco.DT_INT32;

      case Uint8Array:
        return draco.DT_UINT8;

      case Uint16Array:
        return draco.DT_UINT16;

      case Uint32Array:
        return draco.DT_UINT32;
    }
  }
}

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":6,"@babel/runtime/helpers/getPrototypeOf":8,"@babel/runtime/helpers/inherits":9,"@babel/runtime/helpers/interopRequireDefault":10,"@babel/runtime/helpers/possibleConstructorReturn":13,"@babel/runtime/helpers/typeof":17,"three":22}],24:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GLTFLoader = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _three = require("three");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var GLTFLoader = function (_Loader) {
  (0, _inherits2["default"])(GLTFLoader, _Loader);

  var _super = _createSuper(GLTFLoader);

  function GLTFLoader(manager) {
    var _this;

    (0, _classCallCheck2["default"])(this, GLTFLoader);
    _this = _super.call(this, manager);
    _this.dracoLoader = null;
    _this.ktx2Loader = null;
    _this.meshoptDecoder = null;
    _this.pluginCallbacks = [];

    _this.register(function (parser) {
      return new GLTFMaterialsClearcoatExtension(parser);
    });

    _this.register(function (parser) {
      return new GLTFTextureBasisUExtension(parser);
    });

    _this.register(function (parser) {
      return new GLTFTextureWebPExtension(parser);
    });

    _this.register(function (parser) {
      return new GLTFMaterialsSheenExtension(parser);
    });

    _this.register(function (parser) {
      return new GLTFMaterialsTransmissionExtension(parser);
    });

    _this.register(function (parser) {
      return new GLTFMaterialsVolumeExtension(parser);
    });

    _this.register(function (parser) {
      return new GLTFMaterialsIorExtension(parser);
    });

    _this.register(function (parser) {
      return new GLTFMaterialsSpecularExtension(parser);
    });

    _this.register(function (parser) {
      return new GLTFLightsExtension(parser);
    });

    _this.register(function (parser) {
      return new GLTFMeshoptCompression(parser);
    });

    return _this;
  }

  (0, _createClass2["default"])(GLTFLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var resourcePath;

      if (this.resourcePath !== '') {
        resourcePath = this.resourcePath;
      } else if (this.path !== '') {
        resourcePath = this.path;
      } else {
        resourcePath = _three.LoaderUtils.extractUrlBase(url);
      }

      this.manager.itemStart(url);

      var _onError = function _onError(e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }

        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      };

      var loader = new _three.FileLoader(this.manager);
      loader.setPath(this.path);
      loader.setResponseType('arraybuffer');
      loader.setRequestHeader(this.requestHeader);
      loader.setWithCredentials(this.withCredentials);
      loader.load(url, function (data) {
        try {
          scope.parse(data, resourcePath, function (gltf) {
            onLoad(gltf);
            scope.manager.itemEnd(url);
          }, _onError);
        } catch (e) {
          _onError(e);
        }
      }, onProgress, _onError);
    }
  }, {
    key: "setDRACOLoader",
    value: function setDRACOLoader(dracoLoader) {
      this.dracoLoader = dracoLoader;
      return this;
    }
  }, {
    key: "setDDSLoader",
    value: function setDDSLoader() {
      throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
    }
  }, {
    key: "setKTX2Loader",
    value: function setKTX2Loader(ktx2Loader) {
      this.ktx2Loader = ktx2Loader;
      return this;
    }
  }, {
    key: "setMeshoptDecoder",
    value: function setMeshoptDecoder(meshoptDecoder) {
      this.meshoptDecoder = meshoptDecoder;
      return this;
    }
  }, {
    key: "register",
    value: function register(callback) {
      if (this.pluginCallbacks.indexOf(callback) === -1) {
        this.pluginCallbacks.push(callback);
      }

      return this;
    }
  }, {
    key: "unregister",
    value: function unregister(callback) {
      if (this.pluginCallbacks.indexOf(callback) !== -1) {
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
      }

      return this;
    }
  }, {
    key: "parse",
    value: function parse(data, path, onLoad, onError) {
      var content;
      var extensions = {};
      var plugins = {};

      if (typeof data === 'string') {
        content = data;
      } else {
        var magic = _three.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));

        if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
          try {
            extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
          } catch (error) {
            if (onError) onError(error);
            return;
          }

          content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;
        } else {
          content = _three.LoaderUtils.decodeText(new Uint8Array(data));
        }
      }

      var json = JSON.parse(content);

      if (json.asset === undefined || json.asset.version[0] < 2) {
        if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));
        return;
      }

      var parser = new GLTFParser(json, {
        path: path || this.resourcePath || '',
        crossOrigin: this.crossOrigin,
        requestHeader: this.requestHeader,
        manager: this.manager,
        ktx2Loader: this.ktx2Loader,
        meshoptDecoder: this.meshoptDecoder
      });
      parser.fileLoader.setRequestHeader(this.requestHeader);

      for (var i = 0; i < this.pluginCallbacks.length; i++) {
        var plugin = this.pluginCallbacks[i](parser);
        plugins[plugin.name] = plugin;
        extensions[plugin.name] = true;
      }

      if (json.extensionsUsed) {
        for (var _i = 0; _i < json.extensionsUsed.length; ++_i) {
          var extensionName = json.extensionsUsed[_i];
          var extensionsRequired = json.extensionsRequired || [];

          switch (extensionName) {
            case EXTENSIONS.KHR_MATERIALS_UNLIT:
              extensions[extensionName] = new GLTFMaterialsUnlitExtension();
              break;

            case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
              extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();
              break;

            case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
              extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
              break;

            case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
              extensions[extensionName] = new GLTFTextureTransformExtension();
              break;

            case EXTENSIONS.KHR_MESH_QUANTIZATION:
              extensions[extensionName] = new GLTFMeshQuantizationExtension();
              break;

            default:
              if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {
                console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
              }

          }
        }
      }

      parser.setExtensions(extensions);
      parser.setPlugins(plugins);
      parser.parse(onLoad, onError);
    }
  }, {
    key: "parseAsync",
    value: function parseAsync(data, path) {
      var scope = this;
      return new Promise(function (resolve, reject) {
        scope.parse(data, path, resolve, reject);
      });
    }
  }]);
  return GLTFLoader;
}(_three.Loader);

exports.GLTFLoader = GLTFLoader;

function GLTFRegistry() {
  var objects = {};
  return {
    get: function get(key) {
      return objects[key];
    },
    add: function add(key, object) {
      objects[key] = object;
    },
    remove: function remove(key) {
      delete objects[key];
    },
    removeAll: function removeAll() {
      objects = {};
    }
  };
}

var EXTENSIONS = {
  KHR_BINARY_GLTF: 'KHR_binary_glTF',
  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
  KHR_MATERIALS_IOR: 'KHR_materials_ior',
  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
  KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
  EXT_TEXTURE_WEBP: 'EXT_texture_webp',
  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'
};

var GLTFLightsExtension = function () {
  function GLTFLightsExtension(parser) {
    (0, _classCallCheck2["default"])(this, GLTFLightsExtension);
    this.parser = parser;
    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
    this.cache = {
      refs: {},
      uses: {}
    };
  }

  (0, _createClass2["default"])(GLTFLightsExtension, [{
    key: "_markDefs",
    value: function _markDefs() {
      var parser = this.parser;
      var nodeDefs = this.parser.json.nodes || [];

      for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
        var nodeDef = nodeDefs[nodeIndex];

        if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {
          parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
        }
      }
    }
  }, {
    key: "_loadLight",
    value: function _loadLight(lightIndex) {
      var parser = this.parser;
      var cacheKey = 'light:' + lightIndex;
      var dependency = parser.cache.get(cacheKey);
      if (dependency) return dependency;
      var json = parser.json;
      var extensions = json.extensions && json.extensions[this.name] || {};
      var lightDefs = extensions.lights || [];
      var lightDef = lightDefs[lightIndex];
      var lightNode;
      var color = new _three.Color(0xffffff);
      if (lightDef.color !== undefined) color.fromArray(lightDef.color);
      var range = lightDef.range !== undefined ? lightDef.range : 0;

      switch (lightDef.type) {
        case 'directional':
          lightNode = new _three.DirectionalLight(color);
          lightNode.target.position.set(0, 0, -1);
          lightNode.add(lightNode.target);
          break;

        case 'point':
          lightNode = new _three.PointLight(color);
          lightNode.distance = range;
          break;

        case 'spot':
          lightNode = new _three.SpotLight(color);
          lightNode.distance = range;
          lightDef.spot = lightDef.spot || {};
          lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
          lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
          lightNode.angle = lightDef.spot.outerConeAngle;
          lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
          lightNode.target.position.set(0, 0, -1);
          lightNode.add(lightNode.target);
          break;

        default:
          throw new Error('THREE.GLTFLoader: Unexpected light type: ' + lightDef.type);
      }

      lightNode.position.set(0, 0, 0);
      lightNode.decay = 2;
      if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;
      lightNode.name = parser.createUniqueName(lightDef.name || 'light_' + lightIndex);
      dependency = Promise.resolve(lightNode);
      parser.cache.add(cacheKey, dependency);
      return dependency;
    }
  }, {
    key: "createNodeAttachment",
    value: function createNodeAttachment(nodeIndex) {
      var self = this;
      var parser = this.parser;
      var json = parser.json;
      var nodeDef = json.nodes[nodeIndex];
      var lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
      var lightIndex = lightDef.light;
      if (lightIndex === undefined) return null;
      return this._loadLight(lightIndex).then(function (light) {
        return parser._getNodeRef(self.cache, lightIndex, light);
      });
    }
  }]);
  return GLTFLightsExtension;
}();

var GLTFMaterialsUnlitExtension = function () {
  function GLTFMaterialsUnlitExtension() {
    (0, _classCallCheck2["default"])(this, GLTFMaterialsUnlitExtension);
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }

  (0, _createClass2["default"])(GLTFMaterialsUnlitExtension, [{
    key: "getMaterialType",
    value: function getMaterialType() {
      return _three.MeshBasicMaterial;
    }
  }, {
    key: "extendParams",
    value: function extendParams(materialParams, materialDef, parser) {
      var pending = [];
      materialParams.color = new _three.Color(1.0, 1.0, 1.0);
      materialParams.opacity = 1.0;
      var metallicRoughness = materialDef.pbrMetallicRoughness;

      if (metallicRoughness) {
        if (Array.isArray(metallicRoughness.baseColorFactor)) {
          var array = metallicRoughness.baseColorFactor;
          materialParams.color.fromArray(array);
          materialParams.opacity = array[3];
        }

        if (metallicRoughness.baseColorTexture !== undefined) {
          pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));
        }
      }

      return Promise.all(pending);
    }
  }]);
  return GLTFMaterialsUnlitExtension;
}();

var GLTFMaterialsClearcoatExtension = function () {
  function GLTFMaterialsClearcoatExtension(parser) {
    (0, _classCallCheck2["default"])(this, GLTFMaterialsClearcoatExtension);
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }

  (0, _createClass2["default"])(GLTFMaterialsClearcoatExtension, [{
    key: "getMaterialType",
    value: function getMaterialType(materialIndex) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
      return _three.MeshPhysicalMaterial;
    }
  }, {
    key: "extendMaterialParams",
    value: function extendMaterialParams(materialIndex, materialParams) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];

      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }

      var pending = [];
      var extension = materialDef.extensions[this.name];

      if (extension.clearcoatFactor !== undefined) {
        materialParams.clearcoat = extension.clearcoatFactor;
      }

      if (extension.clearcoatTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture));
      }

      if (extension.clearcoatRoughnessFactor !== undefined) {
        materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
      }

      if (extension.clearcoatRoughnessTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture));
      }

      if (extension.clearcoatNormalTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture));

        if (extension.clearcoatNormalTexture.scale !== undefined) {
          var scale = extension.clearcoatNormalTexture.scale;
          materialParams.clearcoatNormalScale = new _three.Vector2(scale, scale);
        }
      }

      return Promise.all(pending);
    }
  }]);
  return GLTFMaterialsClearcoatExtension;
}();

var GLTFMaterialsSheenExtension = function () {
  function GLTFMaterialsSheenExtension(parser) {
    (0, _classCallCheck2["default"])(this, GLTFMaterialsSheenExtension);
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
  }

  (0, _createClass2["default"])(GLTFMaterialsSheenExtension, [{
    key: "getMaterialType",
    value: function getMaterialType(materialIndex) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
      return _three.MeshPhysicalMaterial;
    }
  }, {
    key: "extendMaterialParams",
    value: function extendMaterialParams(materialIndex, materialParams) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];

      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }

      var pending = [];
      materialParams.sheenColor = new _three.Color(0, 0, 0);
      materialParams.sheenRoughness = 0;
      materialParams.sheen = 1;
      var extension = materialDef.extensions[this.name];

      if (extension.sheenColorFactor !== undefined) {
        materialParams.sheenColor.fromArray(extension.sheenColorFactor);
      }

      if (extension.sheenRoughnessFactor !== undefined) {
        materialParams.sheenRoughness = extension.sheenRoughnessFactor;
      }

      if (extension.sheenColorTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'sheenColorMap', extension.sheenColorTexture));
      }

      if (extension.sheenRoughnessTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture));
      }

      return Promise.all(pending);
    }
  }]);
  return GLTFMaterialsSheenExtension;
}();

var GLTFMaterialsTransmissionExtension = function () {
  function GLTFMaterialsTransmissionExtension(parser) {
    (0, _classCallCheck2["default"])(this, GLTFMaterialsTransmissionExtension);
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
  }

  (0, _createClass2["default"])(GLTFMaterialsTransmissionExtension, [{
    key: "getMaterialType",
    value: function getMaterialType(materialIndex) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
      return _three.MeshPhysicalMaterial;
    }
  }, {
    key: "extendMaterialParams",
    value: function extendMaterialParams(materialIndex, materialParams) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];

      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }

      var pending = [];
      var extension = materialDef.extensions[this.name];

      if (extension.transmissionFactor !== undefined) {
        materialParams.transmission = extension.transmissionFactor;
      }

      if (extension.transmissionTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture));
      }

      return Promise.all(pending);
    }
  }]);
  return GLTFMaterialsTransmissionExtension;
}();

var GLTFMaterialsVolumeExtension = function () {
  function GLTFMaterialsVolumeExtension(parser) {
    (0, _classCallCheck2["default"])(this, GLTFMaterialsVolumeExtension);
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
  }

  (0, _createClass2["default"])(GLTFMaterialsVolumeExtension, [{
    key: "getMaterialType",
    value: function getMaterialType(materialIndex) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
      return _three.MeshPhysicalMaterial;
    }
  }, {
    key: "extendMaterialParams",
    value: function extendMaterialParams(materialIndex, materialParams) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];

      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }

      var pending = [];
      var extension = materialDef.extensions[this.name];
      materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;

      if (extension.thicknessTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'thicknessMap', extension.thicknessTexture));
      }

      materialParams.attenuationDistance = extension.attenuationDistance || 0;
      var colorArray = extension.attenuationColor || [1, 1, 1];
      materialParams.attenuationColor = new _three.Color(colorArray[0], colorArray[1], colorArray[2]);
      return Promise.all(pending);
    }
  }]);
  return GLTFMaterialsVolumeExtension;
}();

var GLTFMaterialsIorExtension = function () {
  function GLTFMaterialsIorExtension(parser) {
    (0, _classCallCheck2["default"])(this, GLTFMaterialsIorExtension);
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IOR;
  }

  (0, _createClass2["default"])(GLTFMaterialsIorExtension, [{
    key: "getMaterialType",
    value: function getMaterialType(materialIndex) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
      return _three.MeshPhysicalMaterial;
    }
  }, {
    key: "extendMaterialParams",
    value: function extendMaterialParams(materialIndex, materialParams) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];

      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }

      var extension = materialDef.extensions[this.name];
      materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;
      return Promise.resolve();
    }
  }]);
  return GLTFMaterialsIorExtension;
}();

var GLTFMaterialsSpecularExtension = function () {
  function GLTFMaterialsSpecularExtension(parser) {
    (0, _classCallCheck2["default"])(this, GLTFMaterialsSpecularExtension);
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
  }

  (0, _createClass2["default"])(GLTFMaterialsSpecularExtension, [{
    key: "getMaterialType",
    value: function getMaterialType(materialIndex) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
      return _three.MeshPhysicalMaterial;
    }
  }, {
    key: "extendMaterialParams",
    value: function extendMaterialParams(materialIndex, materialParams) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];

      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }

      var pending = [];
      var extension = materialDef.extensions[this.name];
      materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;

      if (extension.specularTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'specularIntensityMap', extension.specularTexture));
      }

      var colorArray = extension.specularColorFactor || [1, 1, 1];
      materialParams.specularColor = new _three.Color(colorArray[0], colorArray[1], colorArray[2]);

      if (extension.specularColorTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'specularColorMap', extension.specularColorTexture).then(function (texture) {
          texture.encoding = _three.sRGBEncoding;
        }));
      }

      return Promise.all(pending);
    }
  }]);
  return GLTFMaterialsSpecularExtension;
}();

var GLTFTextureBasisUExtension = function () {
  function GLTFTextureBasisUExtension(parser) {
    (0, _classCallCheck2["default"])(this, GLTFTextureBasisUExtension);
    this.parser = parser;
    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }

  (0, _createClass2["default"])(GLTFTextureBasisUExtension, [{
    key: "loadTexture",
    value: function loadTexture(textureIndex) {
      var parser = this.parser;
      var json = parser.json;
      var textureDef = json.textures[textureIndex];

      if (!textureDef.extensions || !textureDef.extensions[this.name]) {
        return null;
      }

      var extension = textureDef.extensions[this.name];
      var source = json.images[extension.source];
      var loader = parser.options.ktx2Loader;

      if (!loader) {
        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures');
        } else {
          return null;
        }
      }

      return parser.loadTextureImage(textureIndex, source, loader);
    }
  }]);
  return GLTFTextureBasisUExtension;
}();

var GLTFTextureWebPExtension = function () {
  function GLTFTextureWebPExtension(parser) {
    (0, _classCallCheck2["default"])(this, GLTFTextureWebPExtension);
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
    this.isSupported = null;
  }

  (0, _createClass2["default"])(GLTFTextureWebPExtension, [{
    key: "loadTexture",
    value: function loadTexture(textureIndex) {
      var name = this.name;
      var parser = this.parser;
      var json = parser.json;
      var textureDef = json.textures[textureIndex];

      if (!textureDef.extensions || !textureDef.extensions[name]) {
        return null;
      }

      var extension = textureDef.extensions[name];
      var source = json.images[extension.source];
      var loader = parser.textureLoader;

      if (source.uri) {
        var handler = parser.options.manager.getHandler(source.uri);
        if (handler !== null) loader = handler;
      }

      return this.detectSupport().then(function (isSupported) {
        if (isSupported) return parser.loadTextureImage(textureIndex, source, loader);

        if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
          throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.');
        }

        return parser.loadTexture(textureIndex);
      });
    }
  }, {
    key: "detectSupport",
    value: function detectSupport() {
      if (!this.isSupported) {
        this.isSupported = new Promise(function (resolve) {
          var image = new Image();
          image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';

          image.onload = image.onerror = function () {
            resolve(image.height === 1);
          };
        });
      }

      return this.isSupported;
    }
  }]);
  return GLTFTextureWebPExtension;
}();

var GLTFMeshoptCompression = function () {
  function GLTFMeshoptCompression(parser) {
    (0, _classCallCheck2["default"])(this, GLTFMeshoptCompression);
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
    this.parser = parser;
  }

  (0, _createClass2["default"])(GLTFMeshoptCompression, [{
    key: "loadBufferView",
    value: function loadBufferView(index) {
      var json = this.parser.json;
      var bufferView = json.bufferViews[index];

      if (bufferView.extensions && bufferView.extensions[this.name]) {
        var extensionDef = bufferView.extensions[this.name];
        var buffer = this.parser.getDependency('buffer', extensionDef.buffer);
        var decoder = this.parser.options.meshoptDecoder;

        if (!decoder || !decoder.supported) {
          if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
            throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files');
          } else {
            return null;
          }
        }

        return Promise.all([buffer, decoder.ready]).then(function (res) {
          var byteOffset = extensionDef.byteOffset || 0;
          var byteLength = extensionDef.byteLength || 0;
          var count = extensionDef.count;
          var stride = extensionDef.byteStride;
          var result = new ArrayBuffer(count * stride);
          var source = new Uint8Array(res[0], byteOffset, byteLength);
          decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
          return result;
        });
      } else {
        return null;
      }
    }
  }]);
  return GLTFMeshoptCompression;
}();

var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
var BINARY_EXTENSION_HEADER_LENGTH = 12;
var BINARY_EXTENSION_CHUNK_TYPES = {
  JSON: 0x4E4F534A,
  BIN: 0x004E4942
};
var GLTFBinaryExtension = (0, _createClass2["default"])(function GLTFBinaryExtension(data) {
  (0, _classCallCheck2["default"])(this, GLTFBinaryExtension);
  this.name = EXTENSIONS.KHR_BINARY_GLTF;
  this.content = null;
  this.body = null;
  var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
  this.header = {
    magic: _three.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
    version: headerView.getUint32(4, true),
    length: headerView.getUint32(8, true)
  };

  if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
    throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');
  } else if (this.header.version < 2.0) {
    throw new Error('THREE.GLTFLoader: Legacy binary file detected.');
  }

  var chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
  var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
  var chunkIndex = 0;

  while (chunkIndex < chunkContentsLength) {
    var chunkLength = chunkView.getUint32(chunkIndex, true);
    chunkIndex += 4;
    var chunkType = chunkView.getUint32(chunkIndex, true);
    chunkIndex += 4;

    if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
      var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
      this.content = _three.LoaderUtils.decodeText(contentArray);
    } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
      var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
      this.body = data.slice(byteOffset, byteOffset + chunkLength);
    }

    chunkIndex += chunkLength;
  }

  if (this.content === null) {
    throw new Error('THREE.GLTFLoader: JSON content not found.');
  }
});

var GLTFDracoMeshCompressionExtension = function () {
  function GLTFDracoMeshCompressionExtension(json, dracoLoader) {
    (0, _classCallCheck2["default"])(this, GLTFDracoMeshCompressionExtension);

    if (!dracoLoader) {
      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');
    }

    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
    this.json = json;
    this.dracoLoader = dracoLoader;
    this.dracoLoader.preload();
  }

  (0, _createClass2["default"])(GLTFDracoMeshCompressionExtension, [{
    key: "decodePrimitive",
    value: function decodePrimitive(primitive, parser) {
      var json = this.json;
      var dracoLoader = this.dracoLoader;
      var bufferViewIndex = primitive.extensions[this.name].bufferView;
      var gltfAttributeMap = primitive.extensions[this.name].attributes;
      var threeAttributeMap = {};
      var attributeNormalizedMap = {};
      var attributeTypeMap = {};

      for (var attributeName in gltfAttributeMap) {
        var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
        threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
      }

      for (var _attributeName in primitive.attributes) {
        var _threeAttributeName = ATTRIBUTES[_attributeName] || _attributeName.toLowerCase();

        if (gltfAttributeMap[_attributeName] !== undefined) {
          var accessorDef = json.accessors[primitive.attributes[_attributeName]];
          var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
          attributeTypeMap[_threeAttributeName] = componentType;
          attributeNormalizedMap[_threeAttributeName] = accessorDef.normalized === true;
        }
      }

      return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {
        return new Promise(function (resolve) {
          dracoLoader.decodeDracoFile(bufferView, function (geometry) {
            for (var _attributeName2 in geometry.attributes) {
              var attribute = geometry.attributes[_attributeName2];
              var normalized = attributeNormalizedMap[_attributeName2];
              if (normalized !== undefined) attribute.normalized = normalized;
            }

            resolve(geometry);
          }, threeAttributeMap, attributeTypeMap);
        });
      });
    }
  }]);
  return GLTFDracoMeshCompressionExtension;
}();

var GLTFTextureTransformExtension = function () {
  function GLTFTextureTransformExtension() {
    (0, _classCallCheck2["default"])(this, GLTFTextureTransformExtension);
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }

  (0, _createClass2["default"])(GLTFTextureTransformExtension, [{
    key: "extendTexture",
    value: function extendTexture(texture, transform) {
      if (transform.texCoord !== undefined) {
        console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');
      }

      if (transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined) {
        return texture;
      }

      texture = texture.clone();

      if (transform.offset !== undefined) {
        texture.offset.fromArray(transform.offset);
      }

      if (transform.rotation !== undefined) {
        texture.rotation = transform.rotation;
      }

      if (transform.scale !== undefined) {
        texture.repeat.fromArray(transform.scale);
      }

      texture.needsUpdate = true;
      return texture;
    }
  }]);
  return GLTFTextureTransformExtension;
}();

var GLTFMeshStandardSGMaterial = function (_MeshStandardMaterial) {
  (0, _inherits2["default"])(GLTFMeshStandardSGMaterial, _MeshStandardMaterial);

  var _super2 = _createSuper(GLTFMeshStandardSGMaterial);

  function GLTFMeshStandardSGMaterial(params) {
    var _this2;

    (0, _classCallCheck2["default"])(this, GLTFMeshStandardSGMaterial);
    _this2 = _super2.call(this);
    _this2.isGLTFSpecularGlossinessMaterial = true;
    var specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '	uniform sampler2D specularMap;', '#endif'].join('\n');
    var glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '	uniform sampler2D glossinessMap;', '#endif'].join('\n');
    var specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '	vec4 texelSpecular = texture2D( specularMap, vUv );', '	texelSpecular = sRGBToLinear( texelSpecular );', '	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '	specularFactor *= texelSpecular.rgb;', '#endif'].join('\n');
    var glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '	vec4 texelGlossiness = texture2D( glossinessMap, vUv );', '	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '	glossinessFactor *= texelGlossiness.a;', '#endif'].join('\n');
    var lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );', 'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );', 'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );', 'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.', 'material.roughness += geometryRoughness;', 'material.roughness = min( material.roughness, 1.0 );', 'material.specularColor = specularFactor;'].join('\n');
    var uniforms = {
      specular: {
        value: new _three.Color().setHex(0xffffff)
      },
      glossiness: {
        value: 1
      },
      specularMap: {
        value: null
      },
      glossinessMap: {
        value: null
      }
    };
    _this2._extraUniforms = uniforms;

    _this2.onBeforeCompile = function (shader) {
      for (var uniformName in uniforms) {
        shader.uniforms[uniformName] = uniforms[uniformName];
      }

      shader.fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);
    };

    Object.defineProperties((0, _assertThisInitialized2["default"])(_this2), {
      specular: {
        get: function get() {
          return uniforms.specular.value;
        },
        set: function set(v) {
          uniforms.specular.value = v;
        }
      },
      specularMap: {
        get: function get() {
          return uniforms.specularMap.value;
        },
        set: function set(v) {
          uniforms.specularMap.value = v;

          if (v) {
            this.defines.USE_SPECULARMAP = '';
          } else {
            delete this.defines.USE_SPECULARMAP;
          }
        }
      },
      glossiness: {
        get: function get() {
          return uniforms.glossiness.value;
        },
        set: function set(v) {
          uniforms.glossiness.value = v;
        }
      },
      glossinessMap: {
        get: function get() {
          return uniforms.glossinessMap.value;
        },
        set: function set(v) {
          uniforms.glossinessMap.value = v;

          if (v) {
            this.defines.USE_GLOSSINESSMAP = '';
            this.defines.USE_UV = '';
          } else {
            delete this.defines.USE_GLOSSINESSMAP;
            delete this.defines.USE_UV;
          }
        }
      }
    });
    delete _this2.metalness;
    delete _this2.roughness;
    delete _this2.metalnessMap;
    delete _this2.roughnessMap;

    _this2.setValues(params);

    return _this2;
  }

  (0, _createClass2["default"])(GLTFMeshStandardSGMaterial, [{
    key: "copy",
    value: function copy(source) {
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(GLTFMeshStandardSGMaterial.prototype), "copy", this).call(this, source);
      this.specularMap = source.specularMap;
      this.specular.copy(source.specular);
      this.glossinessMap = source.glossinessMap;
      this.glossiness = source.glossiness;
      delete this.metalness;
      delete this.roughness;
      delete this.metalnessMap;
      delete this.roughnessMap;
      return this;
    }
  }]);
  return GLTFMeshStandardSGMaterial;
}(_three.MeshStandardMaterial);

var GLTFMaterialsPbrSpecularGlossinessExtension = function () {
  function GLTFMaterialsPbrSpecularGlossinessExtension() {
    (0, _classCallCheck2["default"])(this, GLTFMaterialsPbrSpecularGlossinessExtension);
    this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;
    this.specularGlossinessParams = ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'normalMapType', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'];
  }

  (0, _createClass2["default"])(GLTFMaterialsPbrSpecularGlossinessExtension, [{
    key: "getMaterialType",
    value: function getMaterialType() {
      return GLTFMeshStandardSGMaterial;
    }
  }, {
    key: "extendParams",
    value: function extendParams(materialParams, materialDef, parser) {
      var pbrSpecularGlossiness = materialDef.extensions[this.name];
      materialParams.color = new _three.Color(1.0, 1.0, 1.0);
      materialParams.opacity = 1.0;
      var pending = [];

      if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
        var array = pbrSpecularGlossiness.diffuseFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }

      if (pbrSpecularGlossiness.diffuseTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture));
      }

      materialParams.emissive = new _three.Color(0.0, 0.0, 0.0);
      materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
      materialParams.specular = new _three.Color(1.0, 1.0, 1.0);

      if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {
        materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);
      }

      if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {
        var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
        pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));
        pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef));
      }

      return Promise.all(pending);
    }
  }, {
    key: "createMaterial",
    value: function createMaterial(materialParams) {
      var material = new GLTFMeshStandardSGMaterial(materialParams);
      material.fog = true;
      material.color = materialParams.color;
      material.map = materialParams.map === undefined ? null : materialParams.map;
      material.lightMap = null;
      material.lightMapIntensity = 1.0;
      material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
      material.aoMapIntensity = 1.0;
      material.emissive = materialParams.emissive;
      material.emissiveIntensity = 1.0;
      material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;
      material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
      material.bumpScale = 1;
      material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
      material.normalMapType = _three.TangentSpaceNormalMap;
      if (materialParams.normalScale) material.normalScale = materialParams.normalScale;
      material.displacementMap = null;
      material.displacementScale = 1;
      material.displacementBias = 0;
      material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
      material.specular = materialParams.specular;
      material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
      material.glossiness = materialParams.glossiness;
      material.alphaMap = null;
      material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
      material.envMapIntensity = 1.0;
      material.refractionRatio = 0.98;
      return material;
    }
  }]);
  return GLTFMaterialsPbrSpecularGlossinessExtension;
}();

var GLTFMeshQuantizationExtension = (0, _createClass2["default"])(function GLTFMeshQuantizationExtension() {
  (0, _classCallCheck2["default"])(this, GLTFMeshQuantizationExtension);
  this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
});

var GLTFCubicSplineInterpolant = function (_Interpolant) {
  (0, _inherits2["default"])(GLTFCubicSplineInterpolant, _Interpolant);

  var _super3 = _createSuper(GLTFCubicSplineInterpolant);

  function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    (0, _classCallCheck2["default"])(this, GLTFCubicSplineInterpolant);
    return _super3.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  }

  (0, _createClass2["default"])(GLTFCubicSplineInterpolant, [{
    key: "copySampleValue_",
    value: function copySampleValue_(index) {
      var result = this.resultBuffer,
          values = this.sampleValues,
          valueSize = this.valueSize,
          offset = index * valueSize * 3 + valueSize;

      for (var i = 0; i !== valueSize; i++) {
        result[i] = values[offset + i];
      }

      return result;
    }
  }]);
  return GLTFCubicSplineInterpolant;
}(_three.Interpolant);

GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

GLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
  var result = this.resultBuffer;
  var values = this.sampleValues;
  var stride = this.valueSize;
  var stride2 = stride * 2;
  var stride3 = stride * 3;
  var td = t1 - t0;
  var p = (t - t0) / td;
  var pp = p * p;
  var ppp = pp * p;
  var offset1 = i1 * stride3;
  var offset0 = offset1 - stride3;
  var s2 = -2 * ppp + 3 * pp;
  var s3 = ppp - pp;
  var s0 = 1 - s2;
  var s1 = s3 - pp + p;

  for (var i = 0; i !== stride; i++) {
    var p0 = values[offset0 + i + stride];
    var m0 = values[offset0 + i + stride2] * td;
    var p1 = values[offset1 + i + stride];
    var m1 = values[offset1 + i] * td;
    result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
  }

  return result;
};

var _q = new _three.Quaternion();

var GLTFCubicSplineQuaternionInterpolant = function (_GLTFCubicSplineInter) {
  (0, _inherits2["default"])(GLTFCubicSplineQuaternionInterpolant, _GLTFCubicSplineInter);

  var _super4 = _createSuper(GLTFCubicSplineQuaternionInterpolant);

  function GLTFCubicSplineQuaternionInterpolant() {
    (0, _classCallCheck2["default"])(this, GLTFCubicSplineQuaternionInterpolant);
    return _super4.apply(this, arguments);
  }

  (0, _createClass2["default"])(GLTFCubicSplineQuaternionInterpolant, [{
    key: "interpolate_",
    value: function interpolate_(i1, t0, t, t1) {
      var result = (0, _get2["default"])((0, _getPrototypeOf2["default"])(GLTFCubicSplineQuaternionInterpolant.prototype), "interpolate_", this).call(this, i1, t0, t, t1);

      _q.fromArray(result).normalize().toArray(result);

      return result;
    }
  }]);
  return GLTFCubicSplineQuaternionInterpolant;
}(GLTFCubicSplineInterpolant);

var WEBGL_CONSTANTS = {
  FLOAT: 5126,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
};
var WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
var WEBGL_FILTERS = {
  9728: _three.NearestFilter,
  9729: _three.LinearFilter,
  9984: _three.NearestMipmapNearestFilter,
  9985: _three.LinearMipmapNearestFilter,
  9986: _three.NearestMipmapLinearFilter,
  9987: _three.LinearMipmapLinearFilter
};
var WEBGL_WRAPPINGS = {
  33071: _three.ClampToEdgeWrapping,
  33648: _three.MirroredRepeatWrapping,
  10497: _three.RepeatWrapping
};
var WEBGL_TYPE_SIZES = {
  'SCALAR': 1,
  'VEC2': 2,
  'VEC3': 3,
  'VEC4': 4,
  'MAT2': 4,
  'MAT3': 9,
  'MAT4': 16
};
var ATTRIBUTES = {
  POSITION: 'position',
  NORMAL: 'normal',
  TANGENT: 'tangent',
  TEXCOORD_0: 'uv',
  TEXCOORD_1: 'uv2',
  COLOR_0: 'color',
  WEIGHTS_0: 'skinWeight',
  JOINTS_0: 'skinIndex'
};
var PATH_PROPERTIES = {
  scale: 'scale',
  translation: 'position',
  rotation: 'quaternion',
  weights: 'morphTargetInfluences'
};
var INTERPOLATION = {
  CUBICSPLINE: undefined,
  LINEAR: _three.InterpolateLinear,
  STEP: _three.InterpolateDiscrete
};
var ALPHA_MODES = {
  OPAQUE: 'OPAQUE',
  MASK: 'MASK',
  BLEND: 'BLEND'
};

function createDefaultMaterial(cache) {
  if (cache['DefaultMaterial'] === undefined) {
    cache['DefaultMaterial'] = new _three.MeshStandardMaterial({
      color: 0xFFFFFF,
      emissive: 0x000000,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: _three.FrontSide
    });
  }

  return cache['DefaultMaterial'];
}

function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
  for (var name in objectDef.extensions) {
    if (knownExtensions[name] === undefined) {
      object.userData.gltfExtensions = object.userData.gltfExtensions || {};
      object.userData.gltfExtensions[name] = objectDef.extensions[name];
    }
  }
}

function assignExtrasToUserData(object, gltfDef) {
  if (gltfDef.extras !== undefined) {
    if ((0, _typeof2["default"])(gltfDef.extras) === 'object') {
      Object.assign(object.userData, gltfDef.extras);
    } else {
      console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);
    }
  }
}

function addMorphTargets(geometry, targets, parser) {
  var hasMorphPosition = false;
  var hasMorphNormal = false;

  for (var i = 0, il = targets.length; i < il; i++) {
    var target = targets[i];
    if (target.POSITION !== undefined) hasMorphPosition = true;
    if (target.NORMAL !== undefined) hasMorphNormal = true;
    if (hasMorphPosition && hasMorphNormal) break;
  }

  if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);
  var pendingPositionAccessors = [];
  var pendingNormalAccessors = [];

  for (var _i2 = 0, _il = targets.length; _i2 < _il; _i2++) {
    var _target = targets[_i2];

    if (hasMorphPosition) {
      var pendingAccessor = _target.POSITION !== undefined ? parser.getDependency('accessor', _target.POSITION) : geometry.attributes.position;
      pendingPositionAccessors.push(pendingAccessor);
    }

    if (hasMorphNormal) {
      var _pendingAccessor = _target.NORMAL !== undefined ? parser.getDependency('accessor', _target.NORMAL) : geometry.attributes.normal;

      pendingNormalAccessors.push(_pendingAccessor);
    }
  }

  return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors)]).then(function (accessors) {
    var morphPositions = accessors[0];
    var morphNormals = accessors[1];
    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;
    geometry.morphTargetsRelative = true;
    return geometry;
  });
}

function updateMorphTargets(mesh, meshDef) {
  mesh.updateMorphTargets();

  if (meshDef.weights !== undefined) {
    for (var i = 0, il = meshDef.weights.length; i < il; i++) {
      mesh.morphTargetInfluences[i] = meshDef.weights[i];
    }
  }

  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
    var targetNames = meshDef.extras.targetNames;

    if (mesh.morphTargetInfluences.length === targetNames.length) {
      mesh.morphTargetDictionary = {};

      for (var _i3 = 0, _il2 = targetNames.length; _i3 < _il2; _i3++) {
        mesh.morphTargetDictionary[targetNames[_i3]] = _i3;
      }
    } else {
      console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');
    }
  }
}

function createPrimitiveKey(primitiveDef) {
  var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  var geometryKey;

  if (dracoExtension) {
    geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes);
  } else {
    geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;
  }

  return geometryKey;
}

function createAttributesKey(attributes) {
  var attributesKey = '';
  var keys = Object.keys(attributes).sort();

  for (var i = 0, il = keys.length; i < il; i++) {
    attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';
  }

  return attributesKey;
}

function getNormalizedComponentScale(constructor) {
  switch (constructor) {
    case Int8Array:
      return 1 / 127;

    case Uint8Array:
      return 1 / 255;

    case Int16Array:
      return 1 / 32767;

    case Uint16Array:
      return 1 / 65535;

    default:
      throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.');
  }
}

var GLTFParser = function () {
  function GLTFParser() {
    var json = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, GLTFParser);
    this.json = json;
    this.extensions = {};
    this.plugins = {};
    this.options = options;
    this.cache = new GLTFRegistry();
    this.associations = new Map();
    this.primitiveCache = {};
    this.meshCache = {
      refs: {},
      uses: {}
    };
    this.cameraCache = {
      refs: {},
      uses: {}
    };
    this.lightCache = {
      refs: {},
      uses: {}
    };
    this.textureCache = {};
    this.nodeNamesUsed = {};

    if (typeof createImageBitmap !== 'undefined' && /Firefox/.test(navigator.userAgent) === false) {
      this.textureLoader = new _three.ImageBitmapLoader(this.options.manager);
    } else {
      this.textureLoader = new _three.TextureLoader(this.options.manager);
    }

    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
    this.textureLoader.setRequestHeader(this.options.requestHeader);
    this.fileLoader = new _three.FileLoader(this.options.manager);
    this.fileLoader.setResponseType('arraybuffer');

    if (this.options.crossOrigin === 'use-credentials') {
      this.fileLoader.setWithCredentials(true);
    }
  }

  (0, _createClass2["default"])(GLTFParser, [{
    key: "setExtensions",
    value: function setExtensions(extensions) {
      this.extensions = extensions;
    }
  }, {
    key: "setPlugins",
    value: function setPlugins(plugins) {
      this.plugins = plugins;
    }
  }, {
    key: "parse",
    value: function parse(onLoad, onError) {
      var parser = this;
      var json = this.json;
      var extensions = this.extensions;
      this.cache.removeAll();

      this._invokeAll(function (ext) {
        return ext._markDefs && ext._markDefs();
      });

      Promise.all(this._invokeAll(function (ext) {
        return ext.beforeRoot && ext.beforeRoot();
      })).then(function () {
        return Promise.all([parser.getDependencies('scene'), parser.getDependencies('animation'), parser.getDependencies('camera')]);
      }).then(function (dependencies) {
        var result = {
          scene: dependencies[0][json.scene || 0],
          scenes: dependencies[0],
          animations: dependencies[1],
          cameras: dependencies[2],
          asset: json.asset,
          parser: parser,
          userData: {}
        };
        addUnknownExtensionsToUserData(extensions, result, json);
        assignExtrasToUserData(result, json);
        Promise.all(parser._invokeAll(function (ext) {
          return ext.afterRoot && ext.afterRoot(result);
        })).then(function () {
          onLoad(result);
        });
      })["catch"](onError);
    }
  }, {
    key: "_markDefs",
    value: function _markDefs() {
      var nodeDefs = this.json.nodes || [];
      var skinDefs = this.json.skins || [];
      var meshDefs = this.json.meshes || [];

      for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
        var joints = skinDefs[skinIndex].joints;

        for (var i = 0, il = joints.length; i < il; i++) {
          nodeDefs[joints[i]].isBone = true;
        }
      }

      for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
        var nodeDef = nodeDefs[nodeIndex];

        if (nodeDef.mesh !== undefined) {
          this._addNodeRef(this.meshCache, nodeDef.mesh);

          if (nodeDef.skin !== undefined) {
            meshDefs[nodeDef.mesh].isSkinnedMesh = true;
          }
        }

        if (nodeDef.camera !== undefined) {
          this._addNodeRef(this.cameraCache, nodeDef.camera);
        }
      }
    }
  }, {
    key: "_addNodeRef",
    value: function _addNodeRef(cache, index) {
      if (index === undefined) return;

      if (cache.refs[index] === undefined) {
        cache.refs[index] = cache.uses[index] = 0;
      }

      cache.refs[index]++;
    }
  }, {
    key: "_getNodeRef",
    value: function _getNodeRef(cache, index, object) {
      var _this3 = this;

      if (cache.refs[index] <= 1) return object;
      var ref = object.clone();

      var updateMappings = function updateMappings(original, clone) {
        var mappings = _this3.associations.get(original);

        if (mappings != null) {
          _this3.associations.set(clone, mappings);
        }

        var _iterator = _createForOfIteratorHelper(original.children.entries()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = (0, _slicedToArray2["default"])(_step.value, 2),
                i = _step$value[0],
                child = _step$value[1];

            updateMappings(child, clone.children[i]);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      };

      updateMappings(object, ref);
      ref.name += '_instance_' + cache.uses[index]++;
      return ref;
    }
  }, {
    key: "_invokeOne",
    value: function _invokeOne(func) {
      var extensions = Object.values(this.plugins);
      extensions.push(this);

      for (var i = 0; i < extensions.length; i++) {
        var result = func(extensions[i]);
        if (result) return result;
      }

      return null;
    }
  }, {
    key: "_invokeAll",
    value: function _invokeAll(func) {
      var extensions = Object.values(this.plugins);
      extensions.unshift(this);
      var pending = [];

      for (var i = 0; i < extensions.length; i++) {
        var result = func(extensions[i]);
        if (result) pending.push(result);
      }

      return pending;
    }
  }, {
    key: "getDependency",
    value: function getDependency(type, index) {
      var cacheKey = type + ':' + index;
      var dependency = this.cache.get(cacheKey);

      if (!dependency) {
        switch (type) {
          case 'scene':
            dependency = this.loadScene(index);
            break;

          case 'node':
            dependency = this.loadNode(index);
            break;

          case 'mesh':
            dependency = this._invokeOne(function (ext) {
              return ext.loadMesh && ext.loadMesh(index);
            });
            break;

          case 'accessor':
            dependency = this.loadAccessor(index);
            break;

          case 'bufferView':
            dependency = this._invokeOne(function (ext) {
              return ext.loadBufferView && ext.loadBufferView(index);
            });
            break;

          case 'buffer':
            dependency = this.loadBuffer(index);
            break;

          case 'material':
            dependency = this._invokeOne(function (ext) {
              return ext.loadMaterial && ext.loadMaterial(index);
            });
            break;

          case 'texture':
            dependency = this._invokeOne(function (ext) {
              return ext.loadTexture && ext.loadTexture(index);
            });
            break;

          case 'skin':
            dependency = this.loadSkin(index);
            break;

          case 'animation':
            dependency = this.loadAnimation(index);
            break;

          case 'camera':
            dependency = this.loadCamera(index);
            break;

          default:
            throw new Error('Unknown type: ' + type);
        }

        this.cache.add(cacheKey, dependency);
      }

      return dependency;
    }
  }, {
    key: "getDependencies",
    value: function getDependencies(type) {
      var dependencies = this.cache.get(type);

      if (!dependencies) {
        var parser = this;
        var defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];
        dependencies = Promise.all(defs.map(function (def, index) {
          return parser.getDependency(type, index);
        }));
        this.cache.add(type, dependencies);
      }

      return dependencies;
    }
  }, {
    key: "loadBuffer",
    value: function loadBuffer(bufferIndex) {
      var bufferDef = this.json.buffers[bufferIndex];
      var loader = this.fileLoader;

      if (bufferDef.type && bufferDef.type !== 'arraybuffer') {
        throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');
      }

      if (bufferDef.uri === undefined && bufferIndex === 0) {
        return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
      }

      var options = this.options;
      return new Promise(function (resolve, reject) {
        loader.load(_three.LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {
          reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
        });
      });
    }
  }, {
    key: "loadBufferView",
    value: function loadBufferView(bufferViewIndex) {
      var bufferViewDef = this.json.bufferViews[bufferViewIndex];
      return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {
        var byteLength = bufferViewDef.byteLength || 0;
        var byteOffset = bufferViewDef.byteOffset || 0;
        return buffer.slice(byteOffset, byteOffset + byteLength);
      });
    }
  }, {
    key: "loadAccessor",
    value: function loadAccessor(accessorIndex) {
      var parser = this;
      var json = this.json;
      var accessorDef = this.json.accessors[accessorIndex];

      if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {
        return Promise.resolve(null);
      }

      var pendingBufferViews = [];

      if (accessorDef.bufferView !== undefined) {
        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));
      } else {
        pendingBufferViews.push(null);
      }

      if (accessorDef.sparse !== undefined) {
        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));
        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));
      }

      return Promise.all(pendingBufferViews).then(function (bufferViews) {
        var bufferView = bufferViews[0];
        var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
        var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        var elementBytes = TypedArray.BYTES_PER_ELEMENT;
        var itemBytes = elementBytes * itemSize;
        var byteOffset = accessorDef.byteOffset || 0;
        var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;
        var normalized = accessorDef.normalized === true;
        var array, bufferAttribute;

        if (byteStride && byteStride !== itemBytes) {
          var ibSlice = Math.floor(byteOffset / byteStride);
          var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
          var ib = parser.cache.get(ibCacheKey);

          if (!ib) {
            array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
            ib = new _three.InterleavedBuffer(array, byteStride / elementBytes);
            parser.cache.add(ibCacheKey, ib);
          }

          bufferAttribute = new _three.InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
        } else {
          if (bufferView === null) {
            array = new TypedArray(accessorDef.count * itemSize);
          } else {
            array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
          }

          bufferAttribute = new _three.BufferAttribute(array, itemSize, normalized);
        }

        if (accessorDef.sparse !== undefined) {
          var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
          var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
          var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
          var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
          var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
          var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);

          if (bufferView !== null) {
            bufferAttribute = new _three.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
          }

          for (var i = 0, il = sparseIndices.length; i < il; i++) {
            var index = sparseIndices[i];
            bufferAttribute.setX(index, sparseValues[i * itemSize]);
            if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
            if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
            if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
            if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');
          }
        }

        return bufferAttribute;
      });
    }
  }, {
    key: "loadTexture",
    value: function loadTexture(textureIndex) {
      var json = this.json;
      var options = this.options;
      var textureDef = json.textures[textureIndex];
      var source = json.images[textureDef.source];
      var loader = this.textureLoader;

      if (source.uri) {
        var handler = options.manager.getHandler(source.uri);
        if (handler !== null) loader = handler;
      }

      return this.loadTextureImage(textureIndex, source, loader);
    }
  }, {
    key: "loadTextureImage",
    value: function loadTextureImage(textureIndex, source, loader) {
      var parser = this;
      var json = this.json;
      var options = this.options;
      var textureDef = json.textures[textureIndex];
      var cacheKey = (source.uri || source.bufferView) + ':' + textureDef.sampler;

      if (this.textureCache[cacheKey]) {
        return this.textureCache[cacheKey];
      }

      var URL = self.URL || self.webkitURL;
      var sourceURI = source.uri || '';
      var isObjectURL = false;

      if (source.bufferView !== undefined) {
        sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {
          isObjectURL = true;
          var blob = new Blob([bufferView], {
            type: source.mimeType
          });
          sourceURI = URL.createObjectURL(blob);
          return sourceURI;
        });
      } else if (source.uri === undefined) {
        throw new Error('THREE.GLTFLoader: Image ' + textureIndex + ' is missing URI and bufferView');
      }

      var promise = Promise.resolve(sourceURI).then(function (sourceURI) {
        return new Promise(function (resolve, reject) {
          var onLoad = resolve;

          if (loader.isImageBitmapLoader === true) {
            onLoad = function onLoad(imageBitmap) {
              var texture = new _three.Texture(imageBitmap);
              texture.needsUpdate = true;
              resolve(texture);
            };
          }

          loader.load(_three.LoaderUtils.resolveURL(sourceURI, options.path), onLoad, undefined, reject);
        });
      }).then(function (texture) {
        if (isObjectURL === true) {
          URL.revokeObjectURL(sourceURI);
        }

        texture.flipY = false;
        if (textureDef.name) texture.name = textureDef.name;
        var samplers = json.samplers || {};
        var sampler = samplers[textureDef.sampler] || {};
        texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || _three.LinearFilter;
        texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || _three.LinearMipmapLinearFilter;
        texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || _three.RepeatWrapping;
        texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || _three.RepeatWrapping;
        parser.associations.set(texture, {
          textures: textureIndex
        });
        return texture;
      })["catch"](function () {
        console.error('THREE.GLTFLoader: Couldn\'t load texture', sourceURI);
        return null;
      });
      this.textureCache[cacheKey] = promise;
      return promise;
    }
  }, {
    key: "assignTexture",
    value: function assignTexture(materialParams, mapName, mapDef) {
      var parser = this;
      return this.getDependency('texture', mapDef.index).then(function (texture) {
        if (mapDef.texCoord !== undefined && mapDef.texCoord != 0 && !(mapName === 'aoMap' && mapDef.texCoord == 1)) {
          console.warn('THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.');
        }

        if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
          var transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;

          if (transform) {
            var gltfReference = parser.associations.get(texture);
            texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
            parser.associations.set(texture, gltfReference);
          }
        }

        materialParams[mapName] = texture;
        return texture;
      });
    }
  }, {
    key: "assignFinalMaterial",
    value: function assignFinalMaterial(mesh) {
      var geometry = mesh.geometry;
      var material = mesh.material;
      var useDerivativeTangents = geometry.attributes.tangent === undefined;
      var useVertexColors = geometry.attributes.color !== undefined;
      var useFlatShading = geometry.attributes.normal === undefined;

      if (mesh.isPoints) {
        var cacheKey = 'PointsMaterial:' + material.uuid;
        var pointsMaterial = this.cache.get(cacheKey);

        if (!pointsMaterial) {
          pointsMaterial = new _three.PointsMaterial();

          _three.Material.prototype.copy.call(pointsMaterial, material);

          pointsMaterial.color.copy(material.color);
          pointsMaterial.map = material.map;
          pointsMaterial.sizeAttenuation = false;
          this.cache.add(cacheKey, pointsMaterial);
        }

        material = pointsMaterial;
      } else if (mesh.isLine) {
        var _cacheKey = 'LineBasicMaterial:' + material.uuid;

        var lineMaterial = this.cache.get(_cacheKey);

        if (!lineMaterial) {
          lineMaterial = new _three.LineBasicMaterial();

          _three.Material.prototype.copy.call(lineMaterial, material);

          lineMaterial.color.copy(material.color);
          this.cache.add(_cacheKey, lineMaterial);
        }

        material = lineMaterial;
      }

      if (useDerivativeTangents || useVertexColors || useFlatShading) {
        var _cacheKey2 = 'ClonedMaterial:' + material.uuid + ':';

        if (material.isGLTFSpecularGlossinessMaterial) _cacheKey2 += 'specular-glossiness:';
        if (useDerivativeTangents) _cacheKey2 += 'derivative-tangents:';
        if (useVertexColors) _cacheKey2 += 'vertex-colors:';
        if (useFlatShading) _cacheKey2 += 'flat-shading:';
        var cachedMaterial = this.cache.get(_cacheKey2);

        if (!cachedMaterial) {
          cachedMaterial = material.clone();
          if (useVertexColors) cachedMaterial.vertexColors = true;
          if (useFlatShading) cachedMaterial.flatShading = true;

          if (useDerivativeTangents) {
            if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;
            if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;
          }

          this.cache.add(_cacheKey2, cachedMaterial);
          this.associations.set(cachedMaterial, this.associations.get(material));
        }

        material = cachedMaterial;
      }

      if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {
        geometry.setAttribute('uv2', geometry.attributes.uv);
      }

      mesh.material = material;
    }
  }, {
    key: "getMaterialType",
    value: function getMaterialType() {
      return _three.MeshStandardMaterial;
    }
  }, {
    key: "loadMaterial",
    value: function loadMaterial(materialIndex) {
      var parser = this;
      var json = this.json;
      var extensions = this.extensions;
      var materialDef = json.materials[materialIndex];
      var materialType;
      var materialParams = {};
      var materialExtensions = materialDef.extensions || {};
      var pending = [];

      if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
        var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
        materialType = sgExtension.getMaterialType();
        pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
      } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
        var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
        materialType = kmuExtension.getMaterialType();
        pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
      } else {
        var metallicRoughness = materialDef.pbrMetallicRoughness || {};
        materialParams.color = new _three.Color(1.0, 1.0, 1.0);
        materialParams.opacity = 1.0;

        if (Array.isArray(metallicRoughness.baseColorFactor)) {
          var array = metallicRoughness.baseColorFactor;
          materialParams.color.fromArray(array);
          materialParams.opacity = array[3];
        }

        if (metallicRoughness.baseColorTexture !== undefined) {
          pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));
        }

        materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
        materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

        if (metallicRoughness.metallicRoughnessTexture !== undefined) {
          pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));
          pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));
        }

        materialType = this._invokeOne(function (ext) {
          return ext.getMaterialType && ext.getMaterialType(materialIndex);
        });
        pending.push(Promise.all(this._invokeAll(function (ext) {
          return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
        })));
      }

      if (materialDef.doubleSided === true) {
        materialParams.side = _three.DoubleSide;
      }

      var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

      if (alphaMode === ALPHA_MODES.BLEND) {
        materialParams.transparent = true;
        materialParams.depthWrite = false;
      } else {
        materialParams.format = _three.RGBFormat;
        materialParams.transparent = false;

        if (alphaMode === ALPHA_MODES.MASK) {
          materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;
        }
      }

      if (materialDef.normalTexture !== undefined && materialType !== _three.MeshBasicMaterial) {
        pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture));
        materialParams.normalScale = new _three.Vector2(1, 1);

        if (materialDef.normalTexture.scale !== undefined) {
          var scale = materialDef.normalTexture.scale;
          materialParams.normalScale.set(scale, scale);
        }
      }

      if (materialDef.occlusionTexture !== undefined && materialType !== _three.MeshBasicMaterial) {
        pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));

        if (materialDef.occlusionTexture.strength !== undefined) {
          materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
        }
      }

      if (materialDef.emissiveFactor !== undefined && materialType !== _three.MeshBasicMaterial) {
        materialParams.emissive = new _three.Color().fromArray(materialDef.emissiveFactor);
      }

      if (materialDef.emissiveTexture !== undefined && materialType !== _three.MeshBasicMaterial) {
        pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));
      }

      return Promise.all(pending).then(function () {
        var material;

        if (materialType === GLTFMeshStandardSGMaterial) {
          material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
        } else {
          material = new materialType(materialParams);
        }

        if (materialDef.name) material.name = materialDef.name;
        if (material.map) material.map.encoding = _three.sRGBEncoding;
        if (material.emissiveMap) material.emissiveMap.encoding = _three.sRGBEncoding;
        assignExtrasToUserData(material, materialDef);
        parser.associations.set(material, {
          materials: materialIndex
        });
        if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);
        return material;
      });
    }
  }, {
    key: "createUniqueName",
    value: function createUniqueName(originalName) {
      var sanitizedName = _three.PropertyBinding.sanitizeNodeName(originalName || '');

      var name = sanitizedName;

      for (var i = 1; this.nodeNamesUsed[name]; ++i) {
        name = sanitizedName + '_' + i;
      }

      this.nodeNamesUsed[name] = true;
      return name;
    }
  }, {
    key: "loadGeometries",
    value: function loadGeometries(primitives) {
      var parser = this;
      var extensions = this.extensions;
      var cache = this.primitiveCache;

      function createDracoPrimitive(primitive) {
        return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {
          return addPrimitiveAttributes(geometry, primitive, parser);
        });
      }

      var pending = [];

      for (var i = 0, il = primitives.length; i < il; i++) {
        var primitive = primitives[i];
        var cacheKey = createPrimitiveKey(primitive);
        var cached = cache[cacheKey];

        if (cached) {
          pending.push(cached.promise);
        } else {
          var geometryPromise = void 0;

          if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
            geometryPromise = createDracoPrimitive(primitive);
          } else {
            geometryPromise = addPrimitiveAttributes(new _three.BufferGeometry(), primitive, parser);
          }

          cache[cacheKey] = {
            primitive: primitive,
            promise: geometryPromise
          };
          pending.push(geometryPromise);
        }
      }

      return Promise.all(pending);
    }
  }, {
    key: "loadMesh",
    value: function loadMesh(meshIndex) {
      var parser = this;
      var json = this.json;
      var extensions = this.extensions;
      var meshDef = json.meshes[meshIndex];
      var primitives = meshDef.primitives;
      var pending = [];

      for (var i = 0, il = primitives.length; i < il; i++) {
        var material = primitives[i].material === undefined ? createDefaultMaterial(this.cache) : this.getDependency('material', primitives[i].material);
        pending.push(material);
      }

      pending.push(parser.loadGeometries(primitives));
      return Promise.all(pending).then(function (results) {
        var materials = results.slice(0, results.length - 1);
        var geometries = results[results.length - 1];
        var meshes = [];

        for (var _i4 = 0, _il3 = geometries.length; _i4 < _il3; _i4++) {
          var geometry = geometries[_i4];
          var primitive = primitives[_i4];
          var mesh = void 0;
          var _material = materials[_i4];

          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {
            mesh = meshDef.isSkinnedMesh === true ? new _three.SkinnedMesh(geometry, _material) : new _three.Mesh(geometry, _material);

            if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {
              mesh.normalizeSkinWeights();
            }

            if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
              mesh.geometry = toTrianglesDrawMode(mesh.geometry, _three.TriangleStripDrawMode);
            } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
              mesh.geometry = toTrianglesDrawMode(mesh.geometry, _three.TriangleFanDrawMode);
            }
          } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
            mesh = new _three.LineSegments(geometry, _material);
          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
            mesh = new _three.Line(geometry, _material);
          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
            mesh = new _three.LineLoop(geometry, _material);
          } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
            mesh = new _three.Points(geometry, _material);
          } else {
            throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);
          }

          if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
            updateMorphTargets(mesh, meshDef);
          }

          mesh.name = parser.createUniqueName(meshDef.name || 'mesh_' + meshIndex);
          assignExtrasToUserData(mesh, meshDef);
          if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);
          parser.assignFinalMaterial(mesh);
          meshes.push(mesh);
        }

        for (var _i5 = 0, _il4 = meshes.length; _i5 < _il4; _i5++) {
          parser.associations.set(meshes[_i5], {
            meshes: meshIndex,
            primitives: _i5
          });
        }

        if (meshes.length === 1) {
          return meshes[0];
        }

        var group = new _three.Group();
        parser.associations.set(group, {
          meshes: meshIndex
        });

        for (var _i6 = 0, _il5 = meshes.length; _i6 < _il5; _i6++) {
          group.add(meshes[_i6]);
        }

        return group;
      });
    }
  }, {
    key: "loadCamera",
    value: function loadCamera(cameraIndex) {
      var camera;
      var cameraDef = this.json.cameras[cameraIndex];
      var params = cameraDef[cameraDef.type];

      if (!params) {
        console.warn('THREE.GLTFLoader: Missing camera parameters.');
        return;
      }

      if (cameraDef.type === 'perspective') {
        camera = new _three.PerspectiveCamera(_three.MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
      } else if (cameraDef.type === 'orthographic') {
        camera = new _three.OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
      }

      if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);
      assignExtrasToUserData(camera, cameraDef);
      return Promise.resolve(camera);
    }
  }, {
    key: "loadSkin",
    value: function loadSkin(skinIndex) {
      var skinDef = this.json.skins[skinIndex];
      var skinEntry = {
        joints: skinDef.joints
      };

      if (skinDef.inverseBindMatrices === undefined) {
        return Promise.resolve(skinEntry);
      }

      return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {
        skinEntry.inverseBindMatrices = accessor;
        return skinEntry;
      });
    }
  }, {
    key: "loadAnimation",
    value: function loadAnimation(animationIndex) {
      var json = this.json;
      var animationDef = json.animations[animationIndex];
      var pendingNodes = [];
      var pendingInputAccessors = [];
      var pendingOutputAccessors = [];
      var pendingSamplers = [];
      var pendingTargets = [];

      for (var i = 0, il = animationDef.channels.length; i < il; i++) {
        var channel = animationDef.channels[i];
        var sampler = animationDef.samplers[channel.sampler];
        var target = channel.target;
        var name = target.node !== undefined ? target.node : target.id;
        var input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;
        var output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;
        pendingNodes.push(this.getDependency('node', name));
        pendingInputAccessors.push(this.getDependency('accessor', input));
        pendingOutputAccessors.push(this.getDependency('accessor', output));
        pendingSamplers.push(sampler);
        pendingTargets.push(target);
      }

      return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {
        var nodes = dependencies[0];
        var inputAccessors = dependencies[1];
        var outputAccessors = dependencies[2];
        var samplers = dependencies[3];
        var targets = dependencies[4];
        var tracks = [];

        var _loop = function _loop(_i7, _il6) {
          var node = nodes[_i7];
          var inputAccessor = inputAccessors[_i7];
          var outputAccessor = outputAccessors[_i7];
          var sampler = samplers[_i7];
          var target = targets[_i7];
          if (node === undefined) return "continue";
          node.updateMatrix();
          node.matrixAutoUpdate = true;
          var TypedKeyframeTrack = void 0;

          switch (PATH_PROPERTIES[target.path]) {
            case PATH_PROPERTIES.weights:
              TypedKeyframeTrack = _three.NumberKeyframeTrack;
              break;

            case PATH_PROPERTIES.rotation:
              TypedKeyframeTrack = _three.QuaternionKeyframeTrack;
              break;

            case PATH_PROPERTIES.position:
            case PATH_PROPERTIES.scale:
            default:
              TypedKeyframeTrack = _three.VectorKeyframeTrack;
              break;
          }

          var targetName = node.name ? node.name : node.uuid;
          var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : _three.InterpolateLinear;
          var targetNames = [];

          if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
            node.traverse(function (object) {
              if (object.morphTargetInfluences) {
                targetNames.push(object.name ? object.name : object.uuid);
              }
            });
          } else {
            targetNames.push(targetName);
          }

          var outputArray = outputAccessor.array;

          if (outputAccessor.normalized) {
            var scale = getNormalizedComponentScale(outputArray.constructor);
            var scaled = new Float32Array(outputArray.length);

            for (var j = 0, jl = outputArray.length; j < jl; j++) {
              scaled[j] = outputArray[j] * scale;
            }

            outputArray = scaled;
          }

          for (var _j = 0, _jl = targetNames.length; _j < _jl; _j++) {
            var track = new TypedKeyframeTrack(targetNames[_j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);

            if (sampler.interpolation === 'CUBICSPLINE') {
              track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
                var interpolantType = this instanceof _three.QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
                return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
              };

              track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
            }

            tracks.push(track);
          }
        };

        for (var _i7 = 0, _il6 = nodes.length; _i7 < _il6; _i7++) {
          var _ret = _loop(_i7, _il6);

          if (_ret === "continue") continue;
        }

        var name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;
        return new _three.AnimationClip(name, undefined, tracks);
      });
    }
  }, {
    key: "createNodeMesh",
    value: function createNodeMesh(nodeIndex) {
      var json = this.json;
      var parser = this;
      var nodeDef = json.nodes[nodeIndex];
      if (nodeDef.mesh === undefined) return null;
      return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {
        var node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);

        if (nodeDef.weights !== undefined) {
          node.traverse(function (o) {
            if (!o.isMesh) return;

            for (var i = 0, il = nodeDef.weights.length; i < il; i++) {
              o.morphTargetInfluences[i] = nodeDef.weights[i];
            }
          });
        }

        return node;
      });
    }
  }, {
    key: "loadNode",
    value: function loadNode(nodeIndex) {
      var json = this.json;
      var extensions = this.extensions;
      var parser = this;
      var nodeDef = json.nodes[nodeIndex];
      var nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : '';
      return function () {
        var pending = [];

        var meshPromise = parser._invokeOne(function (ext) {
          return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
        });

        if (meshPromise) {
          pending.push(meshPromise);
        }

        if (nodeDef.camera !== undefined) {
          pending.push(parser.getDependency('camera', nodeDef.camera).then(function (camera) {
            return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
          }));
        }

        parser._invokeAll(function (ext) {
          return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
        }).forEach(function (promise) {
          pending.push(promise);
        });

        return Promise.all(pending);
      }().then(function (objects) {
        var node;

        if (nodeDef.isBone === true) {
          node = new _three.Bone();
        } else if (objects.length > 1) {
          node = new _three.Group();
        } else if (objects.length === 1) {
          node = objects[0];
        } else {
          node = new _three.Object3D();
        }

        if (node !== objects[0]) {
          for (var i = 0, il = objects.length; i < il; i++) {
            node.add(objects[i]);
          }
        }

        if (nodeDef.name) {
          node.userData.name = nodeDef.name;
          node.name = nodeName;
        }

        assignExtrasToUserData(node, nodeDef);
        if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);

        if (nodeDef.matrix !== undefined) {
          var matrix = new _three.Matrix4();
          matrix.fromArray(nodeDef.matrix);
          node.applyMatrix4(matrix);
        } else {
          if (nodeDef.translation !== undefined) {
            node.position.fromArray(nodeDef.translation);
          }

          if (nodeDef.rotation !== undefined) {
            node.quaternion.fromArray(nodeDef.rotation);
          }

          if (nodeDef.scale !== undefined) {
            node.scale.fromArray(nodeDef.scale);
          }
        }

        if (!parser.associations.has(node)) {
          parser.associations.set(node, {});
        }

        parser.associations.get(node).nodes = nodeIndex;
        return node;
      });
    }
  }, {
    key: "loadScene",
    value: function loadScene(sceneIndex) {
      var json = this.json;
      var extensions = this.extensions;
      var sceneDef = this.json.scenes[sceneIndex];
      var parser = this;
      var scene = new _three.Group();
      if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);
      assignExtrasToUserData(scene, sceneDef);
      if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);
      var nodeIds = sceneDef.nodes || [];
      var pending = [];

      for (var i = 0, il = nodeIds.length; i < il; i++) {
        pending.push(buildNodeHierarchy(nodeIds[i], scene, json, parser));
      }

      return Promise.all(pending).then(function () {
        var reduceAssociations = function reduceAssociations(node) {
          var reducedAssociations = new Map();

          var _iterator2 = _createForOfIteratorHelper(parser.associations),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var _step2$value = (0, _slicedToArray2["default"])(_step2.value, 2),
                  key = _step2$value[0],
                  value = _step2$value[1];

              if (key instanceof _three.Material || key instanceof _three.Texture) {
                reducedAssociations.set(key, value);
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          node.traverse(function (node) {
            var mappings = parser.associations.get(node);

            if (mappings != null) {
              reducedAssociations.set(node, mappings);
            }
          });
          return reducedAssociations;
        };

        parser.associations = reduceAssociations(scene);
        return scene;
      });
    }
  }]);
  return GLTFParser;
}();

function buildNodeHierarchy(nodeId, parentObject, json, parser) {
  var nodeDef = json.nodes[nodeId];
  return parser.getDependency('node', nodeId).then(function (node) {
    if (nodeDef.skin === undefined) return node;
    var skinEntry;
    return parser.getDependency('skin', nodeDef.skin).then(function (skin) {
      skinEntry = skin;
      var pendingJoints = [];

      for (var i = 0, il = skinEntry.joints.length; i < il; i++) {
        pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));
      }

      return Promise.all(pendingJoints);
    }).then(function (jointNodes) {
      node.traverse(function (mesh) {
        if (!mesh.isMesh) return;
        var bones = [];
        var boneInverses = [];

        for (var j = 0, jl = jointNodes.length; j < jl; j++) {
          var jointNode = jointNodes[j];

          if (jointNode) {
            bones.push(jointNode);
            var mat = new _three.Matrix4();

            if (skinEntry.inverseBindMatrices !== undefined) {
              mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);
            }

            boneInverses.push(mat);
          } else {
            console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j]);
          }
        }

        mesh.bind(new _three.Skeleton(bones, boneInverses), mesh.matrixWorld);
      });
      return node;
    });
  }).then(function (node) {
    parentObject.add(node);
    var pending = [];

    if (nodeDef.children) {
      var children = nodeDef.children;

      for (var i = 0, il = children.length; i < il; i++) {
        var child = children[i];
        pending.push(buildNodeHierarchy(child, node, json, parser));
      }
    }

    return Promise.all(pending);
  });
}

function computeBounds(geometry, primitiveDef, parser) {
  var attributes = primitiveDef.attributes;
  var box = new _three.Box3();

  if (attributes.POSITION !== undefined) {
    var accessor = parser.json.accessors[attributes.POSITION];
    var min = accessor.min;
    var max = accessor.max;

    if (min !== undefined && max !== undefined) {
      box.set(new _three.Vector3(min[0], min[1], min[2]), new _three.Vector3(max[0], max[1], max[2]));

      if (accessor.normalized) {
        var boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
        box.min.multiplyScalar(boxScale);
        box.max.multiplyScalar(boxScale);
      }
    } else {
      console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');
      return;
    }
  } else {
    return;
  }

  var targets = primitiveDef.targets;

  if (targets !== undefined) {
    var maxDisplacement = new _three.Vector3();
    var vector = new _three.Vector3();

    for (var i = 0, il = targets.length; i < il; i++) {
      var target = targets[i];

      if (target.POSITION !== undefined) {
        var _accessor = parser.json.accessors[target.POSITION];
        var _min = _accessor.min;
        var _max = _accessor.max;

        if (_min !== undefined && _max !== undefined) {
          vector.setX(Math.max(Math.abs(_min[0]), Math.abs(_max[0])));
          vector.setY(Math.max(Math.abs(_min[1]), Math.abs(_max[1])));
          vector.setZ(Math.max(Math.abs(_min[2]), Math.abs(_max[2])));

          if (_accessor.normalized) {
            var _boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[_accessor.componentType]);

            vector.multiplyScalar(_boxScale);
          }

          maxDisplacement.max(vector);
        } else {
          console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');
        }
      }
    }

    box.expandByVector(maxDisplacement);
  }

  geometry.boundingBox = box;
  var sphere = new _three.Sphere();
  box.getCenter(sphere.center);
  sphere.radius = box.min.distanceTo(box.max) / 2;
  geometry.boundingSphere = sphere;
}

function addPrimitiveAttributes(geometry, primitiveDef, parser) {
  var attributes = primitiveDef.attributes;
  var pending = [];

  function assignAttributeAccessor(accessorIndex, attributeName) {
    return parser.getDependency('accessor', accessorIndex).then(function (accessor) {
      geometry.setAttribute(attributeName, accessor);
    });
  }

  for (var gltfAttributeName in attributes) {
    var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
    if (threeAttributeName in geometry.attributes) continue;
    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
  }

  if (primitiveDef.indices !== undefined && !geometry.index) {
    var accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {
      geometry.setIndex(accessor);
    });
    pending.push(accessor);
  }

  assignExtrasToUserData(geometry, primitiveDef);
  computeBounds(geometry, primitiveDef, parser);
  return Promise.all(pending).then(function () {
    return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
  });
}

function toTrianglesDrawMode(geometry, drawMode) {
  var index = geometry.getIndex();

  if (index === null) {
    var indices = [];
    var position = geometry.getAttribute('position');

    if (position !== undefined) {
      for (var i = 0; i < position.count; i++) {
        indices.push(i);
      }

      geometry.setIndex(indices);
      index = geometry.getIndex();
    } else {
      console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');
      return geometry;
    }
  }

  var numberOfTriangles = index.count - 2;
  var newIndices = [];

  if (drawMode === _three.TriangleFanDrawMode) {
    for (var _i8 = 1; _i8 <= numberOfTriangles; _i8++) {
      newIndices.push(index.getX(0));
      newIndices.push(index.getX(_i8));
      newIndices.push(index.getX(_i8 + 1));
    }
  } else {
    for (var _i9 = 0; _i9 < numberOfTriangles; _i9++) {
      if (_i9 % 2 === 0) {
        newIndices.push(index.getX(_i9));
        newIndices.push(index.getX(_i9 + 1));
        newIndices.push(index.getX(_i9 + 2));
      } else {
        newIndices.push(index.getX(_i9 + 2));
        newIndices.push(index.getX(_i9 + 1));
        newIndices.push(index.getX(_i9));
      }
    }
  }

  if (newIndices.length / 3 !== numberOfTriangles) {
    console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');
  }

  var newGeometry = geometry.clone();
  newGeometry.setIndex(newIndices);
  return newGeometry;
}

},{"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":6,"@babel/runtime/helpers/get":7,"@babel/runtime/helpers/getPrototypeOf":8,"@babel/runtime/helpers/inherits":9,"@babel/runtime/helpers/interopRequireDefault":10,"@babel/runtime/helpers/possibleConstructorReturn":13,"@babel/runtime/helpers/slicedToArray":15,"@babel/runtime/helpers/typeof":17,"three":22}],25:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VRButton = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var VRButton = function () {
  function VRButton() {
    (0, _classCallCheck2["default"])(this, VRButton);
  }

  (0, _createClass2["default"])(VRButton, null, [{
    key: "createButton",
    value: function createButton(renderer, options) {
      if (options) {
        console.error('THREE.VRButton: The "options" parameter has been removed. Please set the reference space type via renderer.xr.setReferenceSpaceType() instead.');
      }

      var button = document.createElement('button');

      function showEnterVR() {
        var currentSession = null;

        function onSessionStarted(_x) {
          return _onSessionStarted.apply(this, arguments);
        }

        function _onSessionStarted() {
          _onSessionStarted = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(session) {
            return _regenerator["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    session.addEventListener('end', onSessionEnded);
                    _context.next = 3;
                    return renderer.xr.setSession(session);

                  case 3:
                    button.textContent = 'EXIT VR';
                    currentSession = session;

                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));
          return _onSessionStarted.apply(this, arguments);
        }

        function onSessionEnded() {
          currentSession.removeEventListener('end', onSessionEnded);
          button.textContent = 'ENTER VR';
          currentSession = null;
        }

        button.style.display = '';
        button.style.cursor = 'pointer';
        button.style.left = 'calc(50% - 50px)';
        button.style.width = '100px';
        button.textContent = 'ENTER VR';

        button.onmouseenter = function () {
          button.style.opacity = '1.0';
        };

        button.onmouseleave = function () {
          button.style.opacity = '0.5';
        };

        button.onclick = function () {
          if (currentSession === null) {
            var sessionInit = {
              optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking', 'layers']
            };
            navigator.xr.requestSession('immersive-vr', sessionInit).then(onSessionStarted);
          } else {
            currentSession.end();
          }
        };
      }

      function disableButton() {
        button.style.display = '';
        button.style.cursor = 'auto';
        button.style.left = 'calc(50% - 75px)';
        button.style.width = '150px';
        button.onmouseenter = null;
        button.onmouseleave = null;
        button.onclick = null;
      }

      function showWebXRNotFound() {
        disableButton();
        button.textContent = 'VR NOT SUPPORTED';
      }

      function stylizeElement(element) {
        element.style.position = 'absolute';
        element.style.bottom = '20px';
        element.style.padding = '12px 6px';
        element.style.border = '1px solid #fff';
        element.style.borderRadius = '4px';
        element.style.background = 'rgba(0,0,0,0.1)';
        element.style.color = '#fff';
        element.style.font = 'normal 13px sans-serif';
        element.style.textAlign = 'center';
        element.style.opacity = '0.5';
        element.style.outline = 'none';
        element.style.zIndex = '999';
      }

      if ('xr' in navigator) {
        button.id = 'VRButton';
        button.style.display = 'none';
        stylizeElement(button);
        navigator.xr.isSessionSupported('immersive-vr').then(function (supported) {
          supported ? showEnterVR() : showWebXRNotFound();
        });
        return button;
      } else {
        var message = document.createElement('a');

        if (window.isSecureContext === false) {
          message.href = document.location.href.replace(/^http:/, 'https:');
          message.innerHTML = 'WEBXR NEEDS HTTPS';
        } else {
          message.href = 'https://immersiveweb.dev/';
          message.innerHTML = 'WEBXR NOT AVAILABLE';
        }

        message.style.left = 'calc(50% - 90px)';
        message.style.width = '180px';
        message.style.textDecoration = 'none';
        stylizeElement(message);
        return message;
      }
    }
  }]);
  return VRButton;
}();

exports.VRButton = VRButton;

},{"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":6,"@babel/runtime/helpers/interopRequireDefault":10,"@babel/runtime/regenerator":19}],26:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var THREE = _interopRequireWildcard(require("three"));

var _characterControllerInput = _interopRequireDefault(require("./characterControllerInput.js"));

var _thirdPersonCamera = _interopRequireDefault(require("./thirdPersonCamera"));

var _finiteStateMachine = _interopRequireDefault(require("./finiteStateMachine.js"));

var _GLTFLoader = require("./GLTFLoader.js");

var _DRACOLoader = require("./DRACOLoader.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var Character = function () {
  function Character(params) {
    (0, _classCallCheck2["default"])(this, Character);
    this.init(params);
  }

  (0, _createClass2["default"])(Character, [{
    key: "init",
    value: function init(params) {
      this.isLoaded = false;
      this.params = params;
      this.sceneParent = params.scene;
      this.scene = params.scene.scene;
      this.camera = params.camera;
      this.animations = {};

      if (this.params.isControllable) {
        this.decceleration = new THREE.Vector3(-0.00005, -0.000001, -2.5);
        this.acceleration = new THREE.Vector3(0.1, 0.5, 5.0);
        this.velocity = new THREE.Vector3();
        this.input = new _characterControllerInput["default"]();
      }

      this.stateMachine = new _finiteStateMachine["default"]({
        animations: this.animations
      });
      this.loadModelAndAnimations();
    }
  }, {
    key: "loadModelAndAnimations",
    value: function loadModelAndAnimations() {
      var _this = this;

      var mesh = new THREE.Object3D();
      this.target = mesh;
      this.userData = {
        model: 'proxy',
        mesh: mesh,
        x: mesh.position.x,
        y: mesh.position.y,
        z: mesh.position.z,
        rx: mesh.rotation.x,
        ry: mesh.rotation.y,
        rz: mesh.rotation.rz,
        clipAction: undefined
      };
      var dracoLoader = new _DRACOLoader.DRACOLoader();
      dracoLoader.setDecoderPath('static/draco');
      var gltfLoader = new _GLTFLoader.GLTFLoader();
      gltfLoader.setDRACOLoader(dracoLoader);
      gltfLoader.load('static/models/Soldier.glb', function (glb) {
        var mesh = glb.scene;

        _this.scene.add(mesh);

        _this.target = mesh;
        _this.mixer = new THREE.AnimationMixer(_this.target);
        _this.animations['idle'] = {
          clip: glb.animations[0],
          action: _this.mixer.clipAction(glb.animations[0])
        };
        _this.animations['walk'] = {
          clip: glb.animations[0],
          action: _this.mixer.clipAction(glb.animations[3])
        };

        _this.stateMachine.setState('idle');

        if (_this.params.isControllable) {
          _this.thirdPersonCamera = new _thirdPersonCamera["default"]({
            camera: _this.camera,
            mesh: mesh
          });
        }

        _this.userData = {
          model: 'soldier',
          mesh: mesh,
          x: mesh.position.x,
          y: mesh.position.y,
          z: mesh.position.z,
          rx: mesh.rotation.x,
          ry: mesh.rotation.y,
          rz: mesh.rotation.z,
          clipAction: 'idle'
        };
        _this.isLoaded = true;
      });
    }
  }, {
    key: "onLoadAnimation",
    value: function onLoadAnimation(animationName, animation) {
      var clip = animation.animations[0];
      var action = this.mixer.clipAction(clip);
      this.animations[animationName] = {
        clip: clip,
        action: action
      };
    }
  }, {
    key: "checkIfCollision",
    value: function checkIfCollision() {
      var raycasterPosition = this.target.position.clone();
      raycasterPosition.y += 1.5;
      var raycasterDirection = new THREE.Vector3();
      this.target.getWorldDirection(raycasterDirection);

      if (this.input.controlKeys.w) {
        raycasterDirection.negate();
      }

      var raycaster = new THREE.Raycaster(raycasterPosition, raycasterDirection);
      var intersects = raycaster.intersectObjects(this.sceneParent.colliders);

      if (intersects.length > 0) {
        if (intersects[0].distance < 0.5) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "update",
    value: function update(deltaTime) {
      if (this.target == undefined) {
        return;
      }

      if (!this.stateMachine.currentState) {
        return;
      }

      this.stateMachine.update(deltaTime, this.input);
      var velocity = this.velocity;
      var rotationOffset = new THREE.Quaternion();
      var rotationAxis = new THREE.Vector3(0, 1, 0);
      var targetRotation = this.target.quaternion.clone();
      var frameDecceleration = new THREE.Vector3(velocity.x * this.decceleration.x, velocity.y * this.decceleration.y, velocity.z * this.decceleration.z);
      frameDecceleration.multiplyScalar(deltaTime);
      frameDecceleration.z = Math.sign(frameDecceleration.z) * Math.min(Math.abs(frameDecceleration.z), Math.abs(velocity.z));
      velocity.add(frameDecceleration);

      if (this.input.controlKeys.w) {
        velocity.z -= this.acceleration.z * deltaTime;
      } else if (this.input.controlKeys.s) {
        velocity.z += this.acceleration.z * deltaTime;
      } else {
        velocity.z = 0;
      }

      if (this.input.controlKeys.a) {
        rotationOffset.setFromAxisAngle(rotationAxis, 2.0 * Math.PI * deltaTime * this.acceleration.y);
        targetRotation.multiply(rotationOffset);
      } else if (this.input.controlKeys.d) {
        rotationOffset.setFromAxisAngle(rotationAxis, 2.0 * -Math.PI * deltaTime * this.acceleration.y);
        targetRotation.multiply(rotationOffset);
      }

      if (this.checkIfCollision()) {
        velocity.z = 0;
      }

      this.target.quaternion.copy(targetRotation);
      var oldPosition = new THREE.Vector3();
      oldPosition.copy(this.target.position);
      var forward = new THREE.Vector3(0, 0, 1);
      forward.applyQuaternion(this.target.quaternion);
      forward.normalize();
      var sideways = new THREE.Vector3(1, 0, 0);
      sideways.applyQuaternion(this.target.quaternion);
      sideways.normalize();
      forward.multiplyScalar(velocity.z * deltaTime);
      sideways.multiplyScalar(velocity.x * deltaTime);
      this.target.position.add(forward);
      this.target.position.add(sideways);

      if (this.mixer) {
        this.mixer.update(deltaTime);
      }
    }
  }]);
  return Character;
}();

var _default = Character;
exports["default"] = _default;

},{"./DRACOLoader.js":23,"./GLTFLoader.js":24,"./characterControllerInput.js":27,"./finiteStateMachine.js":28,"./thirdPersonCamera":31,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":6,"@babel/runtime/helpers/interopRequireDefault":10,"@babel/runtime/helpers/typeof":17,"three":22}],27:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var CharacterControllerInput = function () {
  function CharacterControllerInput(params) {
    var _this = this;

    (0, _classCallCheck2["default"])(this, CharacterControllerInput);
    this.params = params;
    this.controlKeys = {
      w: false,
      a: false,
      s: false,
      d: false,
      q: false
    };
    window.addEventListener('keydown', function (e) {
      _this.handleKeyDown(e);
    });
    window.addEventListener('keyup', function (e) {
      _this.handleKeyUp(e);
    });
  }

  (0, _createClass2["default"])(CharacterControllerInput, [{
    key: "handleKeyDown",
    value: function handleKeyDown(e) {
      var pressedKey = e.code.replace('Key', '').toLowerCase();

      switch (pressedKey) {
        case 'w':
          this.controlKeys.w = true;
          break;

        case 'a':
          this.controlKeys.a = true;
          break;

        case 's':
          this.controlKeys.s = true;
          break;

        case 'd':
          this.controlKeys.d = true;
          break;

        case 'q':
          if (this.controlKeys.q) {
            this.controlKeys.q = false;
          } else {
            this.controlKeys.q = true;
          }

          break;
      }
    }
  }, {
    key: "handleKeyUp",
    value: function handleKeyUp(e) {
      var pressedKey = e.code.replace('Key', '').toLowerCase();

      switch (pressedKey) {
        case 'w':
          this.controlKeys.w = false;
          break;

        case 'a':
          this.controlKeys.a = false;
          break;

        case 's':
          this.controlKeys.s = false;
          break;

        case 'd':
          this.controlKeys.d = false;
          break;
      }
    }
  }]);
  return CharacterControllerInput;
}();

var _default = CharacterControllerInput;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":6,"@babel/runtime/helpers/interopRequireDefault":10}],28:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var THREE = _interopRequireWildcard(require("three"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var FiniteStateMachine = function () {
  function FiniteStateMachine(params) {
    (0, _classCallCheck2["default"])(this, FiniteStateMachine);
    this.states = {
      'idle': IdleState,
      'walk': WalkState
    };
    this.currentState = null;
    this.animations = params.animations;
  }

  (0, _createClass2["default"])(FiniteStateMachine, [{
    key: "setState",
    value: function setState(name) {
      var prevState = this.currentState;

      if (prevState) {
        if (prevState.name == name) {
          return;
        }

        prevState.exit();
      }

      var state = new this.states[name](this);
      this.currentState = state;
      state.enter(prevState);
    }
  }, {
    key: "update",
    value: function update(deltaTime, input) {
      if (this.currentState) {
        this.currentState.update(deltaTime, input);
      }
    }
  }]);
  return FiniteStateMachine;
}();

var State = function () {
  function State(parent) {
    (0, _classCallCheck2["default"])(this, State);
    this.parent = parent;
  }

  (0, _createClass2["default"])(State, [{
    key: "enter",
    value: function enter() {}
  }, {
    key: "exit",
    value: function exit() {}
  }, {
    key: "update",
    value: function update() {}
  }]);
  return State;
}();

var IdleState = function (_State) {
  (0, _inherits2["default"])(IdleState, _State);

  var _super = _createSuper(IdleState);

  function IdleState(parent) {
    var _this;

    (0, _classCallCheck2["default"])(this, IdleState);
    _this = _super.call(this, parent);
    _this.name = 'idle';
    return _this;
  }

  (0, _createClass2["default"])(IdleState, [{
    key: "enter",
    value: function enter(prevState) {
      var idleAction = this.parent.animations['idle'].action;

      if (prevState) {
        var prevAction = this.parent.animations[prevState.name].action;
        idleAction.enabled = true;
        idleAction.time = 0.0;
        idleAction.crossFadeFrom(prevAction, 0.5, true);
        idleAction.play();
      } else {
        idleAction.play();
      }
    }
  }, {
    key: "exit",
    value: function exit() {}
  }, {
    key: "update",
    value: function update(deltaTime, input) {
      if (input.controlKeys.w) {
        this.parent.setState('walk');
      } else if (input.controlKeys.s) {}
    }
  }]);
  return IdleState;
}(State);

var WalkState = function (_State2) {
  (0, _inherits2["default"])(WalkState, _State2);

  var _super2 = _createSuper(WalkState);

  function WalkState(parent) {
    var _this2;

    (0, _classCallCheck2["default"])(this, WalkState);
    _this2 = _super2.call(this, parent);
    _this2.name = 'walk';
    return _this2;
  }

  (0, _createClass2["default"])(WalkState, [{
    key: "enter",
    value: function enter(prevState) {
      var walkAction = this.parent.animations['walk'].action;

      if (prevState) {
        var prevAction = this.parent.animations[prevState.name].action;
        walkAction.enabled = true;
        walkAction.time = 0.0;
        walkAction.crossFadeFrom(prevAction, 0.5, true);
        walkAction.play();
      } else {
        walkAction.play();
      }
    }
  }, {
    key: "exit",
    value: function exit() {}
  }, {
    key: "update",
    value: function update(deltaTime, input) {
      if (input.controlKeys.w) {
        return;
      }

      this.parent.setState('idle');
    }
  }]);
  return WalkState;
}(State);

var _default = FiniteStateMachine;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":6,"@babel/runtime/helpers/getPrototypeOf":8,"@babel/runtime/helpers/inherits":9,"@babel/runtime/helpers/interopRequireDefault":10,"@babel/runtime/helpers/possibleConstructorReturn":13,"@babel/runtime/helpers/typeof":17,"three":22}],29:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

var THREE = _interopRequireWildcard(require("three"));

var _scene = _interopRequireDefault(require("./scene.js"));

var dat = _interopRequireWildcard(require("dat.gui"));

var _character = _interopRequireDefault(require("./character.js"));

var _VRButton = require("./VRButton.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var socket = io();
var playerScene = new _scene["default"]();
var remoteData = {};
var renderedUsers = {};
var currentUserId = undefined;
var character = undefined;
var clock = new THREE.Clock();

function update() {
  if (currentUserId && character.isLoaded) {
    character.update(clock.getDelta());
    character.thirdPersonCamera.update(character.input);
    character.stateMachine.update(clock.getDelta(), character.input);
    socket.emit('update', {
      id: currentUserId,
      model: character.userData.model,
      x: character.target.position.x,
      y: character.target.position.y,
      z: character.target.position.z,
      rx: character.target.rotation.x,
      ry: character.target.rotation.y,
      rz: character.target.rotation.z,
      clipAction: character.stateMachine.currentState.name
    });
  }

  if (renderedUsers) {
    updateUsers(clock.getDelta());
  }
}

function animate() {
  update();
  playerScene.renderer.render(playerScene.scene, playerScene.camera);
  window.requestAnimationFrame(function () {
    animate();
  });
}

animate();
playerScene.renderer.xr.enabled = true;
document.body.appendChild(_VRButton.VRButton.createButton(playerScene.renderer));
playerScene.renderer.setAnimationLoop(function () {
  playerScene.renderer.render(playerScene.scene, playerScene.camera);
});
socket.on('setId', function handleSetId(params) {
  currentUserId = params.id;
  character = new _character["default"]({
    scene: playerScene,
    camera: playerScene.camera,
    isControllable: true
  });
  socket.emit('init', {
    model: character.userData.model,
    x: character.userData.x,
    y: character.userData.y,
    z: character.userData.z,
    rx: character.userData.rx,
    ry: character.userData.ry,
    rz: character.userData.rz,
    clipAction: character.userData.clipAction
  });
});
socket.on('payloadDrop', function handlePayloadDrop(params) {
  params.payload.forEach(function (user) {
    if (user.id != currentUserId) {
      remoteData[user.id] = user;

      if (renderedUsers[user.id] == undefined) {
        renderedUsers[user.id] = new _character["default"]({
          scene: playerScene,
          isControllable: false
        });
      }
    }
  });
});
socket.on('deleteUser', function handleDeleteUser(params) {
  if (remoteData[params.id]) {
    playerScene.scene.remove(renderedUsers[params.id].userData.mesh);
    delete renderedUsers[params.id];
    delete remoteData[params.id];
  }
});

function updateUsers(deltaTime) {
  Object.keys(renderedUsers).forEach(function (id) {
    var mesh = renderedUsers[id].target;
    mesh.rotation.x = remoteData[id].rx;
    mesh.rotation.y = remoteData[id].ry;
    mesh.rotation.z = remoteData[id].rz;
    mesh.position.lerp(new THREE.Vector3(remoteData[id].x, remoteData[id].y, remoteData[id].z), 0.1);

    if (renderedUsers[id].isLoaded) {
      renderedUsers[id].mixer.update(0.025);

      if (remoteData[id].clipAction != undefined && renderedUsers[id].stateMachine.currentState.name != remoteData[id].clipAction) {
        renderedUsers[id].stateMachine.setState(remoteData[id].clipAction);
      }
    }
  });
}

},{"./VRButton.js":25,"./character.js":26,"./scene.js":30,"@babel/runtime/helpers/interopRequireDefault":10,"@babel/runtime/helpers/typeof":17,"dat.gui":20,"three":22}],30:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var THREE = _interopRequireWildcard(require("three"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var Scene = function () {
  function Scene() {
    var _this = this;

    var canvas = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document.querySelector('#webgl_handle');
    var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.innerWidth;
    var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : window.innerHeight;
    (0, _classCallCheck2["default"])(this, Scene);
    this.canvas = canvas;
    this.sizes = {
      width: width,
      height: height
    };
    this.parameters = {};
    this.scene = new THREE.Scene();
    this.camera = new THREE.PerspectiveCamera(70, this.sizes.width / this.sizes.height, 0.1, 100);
    var sunlight = new THREE.AmbientLight('#ffffff', 0.5);
    this.scene.add(sunlight);
    var gridHelper = new THREE.GridHelper(100, 100);
    this.scene.add(gridHelper);
    this.colliders = [];
    this.createColliders();
    this.renderer = new THREE.WebGLRenderer({
      canvas: this.canvas,
      antialias: true
    });
    this.renderer.setSize(this.sizes.width, this.sizes.height);
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    this.renderer.outputEncoding = THREE.sRGBEncoding;
    this.renderer.setClearColor(new THREE.Color('#000000'));
    window.addEventListener('resize', function (e) {
      _this.handleResize(e);
    });
  }

  (0, _createClass2["default"])(Scene, [{
    key: "handleResize",
    value: function handleResize(e) {
      this.sizes.width = window.innerWidth;
      this.sizes.height = window.innerHeight;
      this.camera.aspect = this.sizes.width / this.sizes.height;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(this.sizes.width, this.sizes.height);
      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }
  }, {
    key: "createColliders",
    value: function createColliders() {
      var geometry = new THREE.BoxGeometry(5, 5, 5, 10, 10, 10);
      var material = new THREE.MeshBasicMaterial({
        color: '#AA0000',
        wireframe: true
      });

      for (var x = -10; x < 10; x += 5) {
        for (var z = -10; z < 10; z += 5) {
          if (x == 0 || z == 0) {
            continue;
          }

          var collider = new THREE.Mesh(geometry, material);
          collider.matrixAutoUpdate = false;
          collider.position.set(x, 2.5 + 0.1, z);
          collider.updateMatrix();
          this.scene.add(collider);
          this.colliders.push(collider);
        }
      }
    }
  }]);
  return Scene;
}();

var _default = Scene;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":6,"@babel/runtime/helpers/interopRequireDefault":10,"@babel/runtime/helpers/typeof":17,"three":22}],31:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var THREE = _interopRequireWildcard(require("three"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var ThirdPersonCamera = function () {
  function ThirdPersonCamera(params) {
    (0, _classCallCheck2["default"])(this, ThirdPersonCamera);
    this.params = params;
    this.camera = params.camera;
    this.target = params.mesh;
    this.currentPosition = new THREE.Vector3();
    this.currentLookAt = new THREE.Vector3();
    this.isInThirdPerson = true;
    this.idealOffset = new THREE.Vector3(0, 2, 4);
  }

  (0, _createClass2["default"])(ThirdPersonCamera, [{
    key: "update",
    value: function update(input) {
      if (input.controlKeys.q) {
        this.idealOffset = new THREE.Vector3(0, 1.5, -0.5);
      } else {
        this.idealOffset = new THREE.Vector3(0, 2, 4);
      }

      var idealOffset = this.calculateIdealOffset();
      var idealLookAt = this.calculateIdealLookAt();
      this.currentPosition.lerp(idealOffset, 0.2);
      this.currentLookAt.lerp(idealLookAt, 0.2);
      this.camera.position.copy(this.currentPosition);
      this.camera.lookAt(this.currentLookAt);
    }
  }, {
    key: "calculateIdealOffset",
    value: function calculateIdealOffset() {
      var idealOffset = this.idealOffset;
      idealOffset.applyQuaternion(this.target.quaternion);
      idealOffset.add(this.target.position);
      return idealOffset;
    }
  }, {
    key: "calculateIdealLookAt",
    value: function calculateIdealLookAt() {
      var idealLookAt = new THREE.Vector3(0, 1, -5);
      idealLookAt.applyQuaternion(this.target.quaternion);
      idealLookAt.add(this.target.position);
      return idealLookAt;
    }
  }]);
  return ThirdPersonCamera;
}();

var _default = ThirdPersonCamera;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":6,"@babel/runtime/helpers/interopRequireDefault":10,"@babel/runtime/helpers/typeof":17,"three":22}]},{},[29])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRoSG9sZXMuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlUmVzdC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zdXBlclByb3BCYXNlLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGF0Lmd1aS9idWlsZC9kYXQuZ3VpLmpzIiwibm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9idWlsZC90aHJlZS5qcyIsInNyYy9EUkFDT0xvYWRlci5qcyIsInNyYy9HTFRGTG9hZGVyLmpzIiwic3JjL1ZSQnV0dG9uLmpzIiwic3JjL2NoYXJhY3Rlci5qcyIsInNyYy9jaGFyYWN0ZXJDb250cm9sbGVySW5wdXQuanMiLCJzcmMvZmluaXRlU3RhdGVNYWNoaW5lLmpzIiwic3JjL2luZGV4LmpzIiwic3JjL3NjZW5lLmpzIiwic3JjL3RoaXJkUGVyc29uQ2FtZXJhLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMStFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2x2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbm9uQ0E7Ozs7OztBQU9BLElBQU0sVUFBVSxHQUFHLElBQUksT0FBSixFQUFuQjs7SUFFTSxXOzs7OztBQUVMLHVCQUFhLE9BQWIsRUFBdUI7QUFBQTs7QUFBQTtBQUV0Qiw4QkFBTyxPQUFQO0FBRUEsVUFBSyxXQUFMLEdBQW1CLEVBQW5CO0FBQ0EsVUFBSyxhQUFMLEdBQXFCLEVBQXJCO0FBQ0EsVUFBSyxhQUFMLEdBQXFCLElBQXJCO0FBQ0EsVUFBSyxjQUFMLEdBQXNCLElBQXRCO0FBRUEsVUFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQ0EsVUFBSyxVQUFMLEdBQWtCLEVBQWxCO0FBQ0EsVUFBSyxnQkFBTCxHQUF3QixDQUF4QjtBQUNBLFVBQUssZUFBTCxHQUF1QixFQUF2QjtBQUVBLFVBQUssbUJBQUwsR0FBMkI7QUFDMUIsTUFBQSxRQUFRLEVBQUUsVUFEZ0I7QUFFMUIsTUFBQSxNQUFNLEVBQUUsUUFGa0I7QUFHMUIsTUFBQSxLQUFLLEVBQUUsT0FIbUI7QUFJMUIsTUFBQSxFQUFFLEVBQUU7QUFKc0IsS0FBM0I7QUFNQSxVQUFLLHFCQUFMLEdBQTZCO0FBQzVCLE1BQUEsUUFBUSxFQUFFLGNBRGtCO0FBRTVCLE1BQUEsTUFBTSxFQUFFLGNBRm9CO0FBRzVCLE1BQUEsS0FBSyxFQUFFLGNBSHFCO0FBSTVCLE1BQUEsRUFBRSxFQUFFO0FBSndCLEtBQTdCO0FBcEJzQjtBQTJCdEI7Ozs7V0FFRCx3QkFBZ0IsSUFBaEIsRUFBdUI7QUFFdEIsV0FBSyxXQUFMLEdBQW1CLElBQW5CO0FBRUEsYUFBTyxJQUFQO0FBRUE7OztXQUVELDBCQUFrQixNQUFsQixFQUEyQjtBQUUxQixXQUFLLGFBQUwsR0FBcUIsTUFBckI7QUFFQSxhQUFPLElBQVA7QUFFQTs7O1dBRUQsd0JBQWdCLFdBQWhCLEVBQThCO0FBRTdCLFdBQUssV0FBTCxHQUFtQixXQUFuQjtBQUVBLGFBQU8sSUFBUDtBQUVBOzs7V0FFRCxjQUFNLEdBQU4sRUFBVyxNQUFYLEVBQW1CLFVBQW5CLEVBQStCLE9BQS9CLEVBQXlDO0FBQUE7O0FBRXhDLFVBQU0sTUFBTSxHQUFHLElBQUksaUJBQUosQ0FBZ0IsS0FBSyxPQUFyQixDQUFmO0FBRUEsTUFBQSxNQUFNLENBQUMsT0FBUCxDQUFnQixLQUFLLElBQXJCO0FBQ0EsTUFBQSxNQUFNLENBQUMsZUFBUCxDQUF3QixhQUF4QjtBQUNBLE1BQUEsTUFBTSxDQUFDLGdCQUFQLENBQXlCLEtBQUssYUFBOUI7QUFDQSxNQUFBLE1BQU0sQ0FBQyxrQkFBUCxDQUEyQixLQUFLLGVBQWhDO0FBRUEsTUFBQSxNQUFNLENBQUMsSUFBUCxDQUFhLEdBQWIsRUFBa0IsVUFBRSxNQUFGLEVBQWM7QUFFL0IsWUFBTSxVQUFVLEdBQUc7QUFDbEIsVUFBQSxZQUFZLEVBQUUsTUFBSSxDQUFDLG1CQUREO0FBRWxCLFVBQUEsY0FBYyxFQUFFLE1BQUksQ0FBQyxxQkFGSDtBQUdsQixVQUFBLFlBQVksRUFBRTtBQUhJLFNBQW5COztBQU1BLFFBQUEsTUFBSSxDQUFDLGNBQUwsQ0FBcUIsTUFBckIsRUFBNkIsVUFBN0IsRUFDRSxJQURGLENBQ1EsTUFEUixXQUVTLE9BRlQ7QUFJQSxPQVpELEVBWUcsVUFaSCxFQVllLE9BWmY7QUFjQTs7O1dBR0QseUJBQWlCLE1BQWpCLEVBQXlCLFFBQXpCLEVBQW1DLFlBQW5DLEVBQWlELGNBQWpELEVBQWtFO0FBRWpFLFVBQU0sVUFBVSxHQUFHO0FBQ2xCLFFBQUEsWUFBWSxFQUFFLFlBQVksSUFBSSxLQUFLLG1CQURqQjtBQUVsQixRQUFBLGNBQWMsRUFBRSxjQUFjLElBQUksS0FBSyxxQkFGckI7QUFHbEIsUUFBQSxZQUFZLEVBQUUsQ0FBQyxDQUFFO0FBSEMsT0FBbkI7QUFNQSxXQUFLLGNBQUwsQ0FBcUIsTUFBckIsRUFBNkIsVUFBN0IsRUFBMEMsSUFBMUMsQ0FBZ0QsUUFBaEQ7QUFFQTs7O1dBRUQsd0JBQWdCLE1BQWhCLEVBQXdCLFVBQXhCLEVBQXFDO0FBQUE7O0FBS3BDLFdBQU0sSUFBTSxTQUFaLElBQXlCLFVBQVUsQ0FBQyxjQUFwQyxFQUFxRDtBQUVwRCxZQUFNLElBQUksR0FBRyxVQUFVLENBQUMsY0FBWCxDQUEyQixTQUEzQixDQUFiOztBQUVBLFlBQUssSUFBSSxDQUFDLGlCQUFMLEtBQTJCLFNBQWhDLEVBQTRDO0FBRTNDLFVBQUEsVUFBVSxDQUFDLGNBQVgsQ0FBMkIsU0FBM0IsSUFBeUMsSUFBSSxDQUFDLElBQTlDO0FBRUE7QUFFRDs7QUFJRCxVQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsU0FBTCxDQUFnQixVQUFoQixDQUFoQjs7QUFJQSxVQUFLLFVBQVUsQ0FBQyxHQUFYLENBQWdCLE1BQWhCLENBQUwsRUFBZ0M7QUFFL0IsWUFBTSxVQUFVLEdBQUcsVUFBVSxDQUFDLEdBQVgsQ0FBZ0IsTUFBaEIsQ0FBbkI7O0FBRUEsWUFBSyxVQUFVLENBQUMsR0FBWCxLQUFtQixPQUF4QixFQUFrQztBQUVqQyxpQkFBTyxVQUFVLENBQUMsT0FBbEI7QUFFQSxTQUpELE1BSU8sSUFBSyxNQUFNLENBQUMsVUFBUCxLQUFzQixDQUEzQixFQUErQjtBQU1yQyxnQkFBTSxJQUFJLEtBQUosQ0FFTCxvRUFDQSxnREFISyxDQUFOO0FBT0E7QUFFRDs7QUFJRCxVQUFJLE1BQUo7QUFDQSxVQUFNLE1BQU0sR0FBRyxLQUFLLGdCQUFMLEVBQWY7QUFDQSxVQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsVUFBeEI7O0FBSUEsVUFBTSxlQUFlLEdBQUcsS0FBSyxVQUFMLENBQWlCLE1BQWpCLEVBQXlCLFFBQXpCLEVBQ3RCLElBRHNCLENBQ2hCLFVBQUUsT0FBRixFQUFlO0FBRXJCLFFBQUEsTUFBTSxHQUFHLE9BQVQ7QUFFQSxlQUFPLElBQUksT0FBSixDQUFhLFVBQUUsT0FBRixFQUFXLE1BQVgsRUFBdUI7QUFFMUMsVUFBQSxNQUFNLENBQUMsVUFBUCxDQUFtQixNQUFuQixJQUE4QjtBQUFFLFlBQUEsT0FBTyxFQUFQLE9BQUY7QUFBVyxZQUFBLE1BQU0sRUFBTjtBQUFYLFdBQTlCO0FBRUEsVUFBQSxNQUFNLENBQUMsV0FBUCxDQUFvQjtBQUFFLFlBQUEsSUFBSSxFQUFFLFFBQVI7QUFBa0IsWUFBQSxFQUFFLEVBQUUsTUFBdEI7QUFBOEIsWUFBQSxVQUFVLEVBQVYsVUFBOUI7QUFBMEMsWUFBQSxNQUFNLEVBQU47QUFBMUMsV0FBcEIsRUFBd0UsQ0FBRSxNQUFGLENBQXhFO0FBSUEsU0FSTSxDQUFQO0FBVUEsT0Fmc0IsRUFnQnRCLElBaEJzQixDQWdCaEIsVUFBRSxPQUFGO0FBQUEsZUFBZSxNQUFJLENBQUMsZUFBTCxDQUFzQixPQUFPLENBQUMsUUFBOUIsQ0FBZjtBQUFBLE9BaEJnQixDQUF4Qjs7QUFvQkEsTUFBQSxlQUFlLFNBQWYsQ0FDUztBQUFBLGVBQU0sSUFBTjtBQUFBLE9BRFQsRUFFRSxJQUZGLENBRVEsWUFBTTtBQUVaLFlBQUssTUFBTSxJQUFJLE1BQWYsRUFBd0I7QUFFdkIsVUFBQSxNQUFJLENBQUMsWUFBTCxDQUFtQixNQUFuQixFQUEyQixNQUEzQjtBQUlBO0FBRUQsT0FaRjs7QUFlQSxNQUFBLFVBQVUsQ0FBQyxHQUFYLENBQWdCLE1BQWhCLEVBQXdCO0FBRXZCLFFBQUEsR0FBRyxFQUFFLE9BRmtCO0FBR3ZCLFFBQUEsT0FBTyxFQUFFO0FBSGMsT0FBeEI7O0FBT0EsYUFBTyxlQUFQO0FBRUE7OztXQUVELHlCQUFpQixZQUFqQixFQUFnQztBQUUvQixVQUFNLFFBQVEsR0FBRyxJQUFJLHFCQUFKLEVBQWpCOztBQUVBLFVBQUssWUFBWSxDQUFDLEtBQWxCLEVBQTBCO0FBRXpCLFFBQUEsUUFBUSxDQUFDLFFBQVQsQ0FBbUIsSUFBSSxzQkFBSixDQUFxQixZQUFZLENBQUMsS0FBYixDQUFtQixLQUF4QyxFQUErQyxDQUEvQyxDQUFuQjtBQUVBOztBQUVELFdBQU0sSUFBSSxDQUFDLEdBQUcsQ0FBZCxFQUFpQixDQUFDLEdBQUcsWUFBWSxDQUFDLFVBQWIsQ0FBd0IsTUFBN0MsRUFBcUQsQ0FBQyxFQUF0RCxFQUE0RDtBQUUzRCxZQUFNLFNBQVMsR0FBRyxZQUFZLENBQUMsVUFBYixDQUF5QixDQUF6QixDQUFsQjtBQUNBLFlBQU0sSUFBSSxHQUFHLFNBQVMsQ0FBQyxJQUF2QjtBQUNBLFlBQU0sS0FBSyxHQUFHLFNBQVMsQ0FBQyxLQUF4QjtBQUNBLFlBQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQyxRQUEzQjtBQUVBLFFBQUEsUUFBUSxDQUFDLFlBQVQsQ0FBdUIsSUFBdkIsRUFBNkIsSUFBSSxzQkFBSixDQUFxQixLQUFyQixFQUE0QixRQUE1QixDQUE3QjtBQUVBOztBQUVELGFBQU8sUUFBUDtBQUVBOzs7V0FFRCxzQkFBYyxHQUFkLEVBQW1CLFlBQW5CLEVBQWtDO0FBRWpDLFVBQU0sTUFBTSxHQUFHLElBQUksaUJBQUosQ0FBZ0IsS0FBSyxPQUFyQixDQUFmO0FBQ0EsTUFBQSxNQUFNLENBQUMsT0FBUCxDQUFnQixLQUFLLFdBQXJCO0FBQ0EsTUFBQSxNQUFNLENBQUMsZUFBUCxDQUF3QixZQUF4QjtBQUNBLE1BQUEsTUFBTSxDQUFDLGtCQUFQLENBQTJCLEtBQUssZUFBaEM7QUFFQSxhQUFPLElBQUksT0FBSixDQUFhLFVBQUUsT0FBRixFQUFXLE1BQVgsRUFBdUI7QUFFMUMsUUFBQSxNQUFNLENBQUMsSUFBUCxDQUFhLEdBQWIsRUFBa0IsT0FBbEIsRUFBMkIsU0FBM0IsRUFBc0MsTUFBdEM7QUFFQSxPQUpNLENBQVA7QUFNQTs7O1dBRUQsbUJBQVU7QUFFVCxXQUFLLFlBQUw7O0FBRUEsYUFBTyxJQUFQO0FBRUE7OztXQUVELHdCQUFlO0FBQUE7O0FBRWQsVUFBSyxLQUFLLGNBQVYsRUFBMkIsT0FBTyxLQUFLLGNBQVo7QUFFM0IsVUFBTSxLQUFLLEdBQUcsUUFBTyxXQUFQLDBEQUFPLFdBQVAsT0FBdUIsUUFBdkIsSUFBbUMsS0FBSyxhQUFMLENBQW1CLElBQW5CLEtBQTRCLElBQTdFO0FBQ0EsVUFBTSxnQkFBZ0IsR0FBRyxFQUF6Qjs7QUFFQSxVQUFLLEtBQUwsRUFBYTtBQUVaLFFBQUEsZ0JBQWdCLENBQUMsSUFBakIsQ0FBdUIsS0FBSyxZQUFMLENBQW1CLGtCQUFuQixFQUF1QyxNQUF2QyxDQUF2QjtBQUVBLE9BSkQsTUFJTztBQUVOLFFBQUEsZ0JBQWdCLENBQUMsSUFBakIsQ0FBdUIsS0FBSyxZQUFMLENBQW1CLHVCQUFuQixFQUE0QyxNQUE1QyxDQUF2QjtBQUNBLFFBQUEsZ0JBQWdCLENBQUMsSUFBakIsQ0FBdUIsS0FBSyxZQUFMLENBQW1CLG9CQUFuQixFQUF5QyxhQUF6QyxDQUF2QjtBQUVBOztBQUVELFdBQUssY0FBTCxHQUFzQixPQUFPLENBQUMsR0FBUixDQUFhLGdCQUFiLEVBQ3BCLElBRG9CLENBQ2QsVUFBRSxTQUFGLEVBQWlCO0FBRXZCLFlBQU0sU0FBUyxHQUFHLFNBQVMsQ0FBRSxDQUFGLENBQTNCOztBQUVBLFlBQUssQ0FBRSxLQUFQLEVBQWU7QUFFZCxVQUFBLE1BQUksQ0FBQyxhQUFMLENBQW1CLFVBQW5CLEdBQWdDLFNBQVMsQ0FBRSxDQUFGLENBQXpDO0FBRUE7O0FBRUQsWUFBTSxFQUFFLEdBQUcsV0FBVyxDQUFDLFFBQVosRUFBWDtBQUVBLFlBQU0sSUFBSSxHQUFHLENBQ1oscUJBRFksRUFFWixTQUZZLEVBR1osRUFIWSxFQUlaLGNBSlksRUFLWixFQUFFLENBQUMsU0FBSCxDQUFjLEVBQUUsQ0FBQyxPQUFILENBQVksR0FBWixJQUFvQixDQUFsQyxFQUFxQyxFQUFFLENBQUMsV0FBSCxDQUFnQixHQUFoQixDQUFyQyxDQUxZLEVBTVgsSUFOVyxDQU1MLElBTkssQ0FBYjtBQVFBLFFBQUEsTUFBSSxDQUFDLGVBQUwsR0FBdUIsR0FBRyxDQUFDLGVBQUosQ0FBcUIsSUFBSSxJQUFKLENBQVUsQ0FBRSxJQUFGLENBQVYsQ0FBckIsQ0FBdkI7QUFFQSxPQXZCb0IsQ0FBdEI7QUF5QkEsYUFBTyxLQUFLLGNBQVo7QUFFQTs7O1dBRUQsb0JBQVksTUFBWixFQUFvQixRQUFwQixFQUErQjtBQUFBOztBQUU5QixhQUFPLEtBQUssWUFBTCxHQUFvQixJQUFwQixDQUEwQixZQUFNO0FBRXRDLFlBQUssTUFBSSxDQUFDLFVBQUwsQ0FBZ0IsTUFBaEIsR0FBeUIsTUFBSSxDQUFDLFdBQW5DLEVBQWlEO0FBRWhELGNBQU0sUUFBTSxHQUFHLElBQUksTUFBSixDQUFZLE1BQUksQ0FBQyxlQUFqQixDQUFmOztBQUVBLFVBQUEsUUFBTSxDQUFDLFVBQVAsR0FBb0IsRUFBcEI7QUFDQSxVQUFBLFFBQU0sQ0FBQyxVQUFQLEdBQW9CLEVBQXBCO0FBQ0EsVUFBQSxRQUFNLENBQUMsU0FBUCxHQUFtQixDQUFuQjs7QUFFQSxVQUFBLFFBQU0sQ0FBQyxXQUFQLENBQW9CO0FBQUUsWUFBQSxJQUFJLEVBQUUsTUFBUjtBQUFnQixZQUFBLGFBQWEsRUFBRSxNQUFJLENBQUM7QUFBcEMsV0FBcEI7O0FBRUEsVUFBQSxRQUFNLENBQUMsU0FBUCxHQUFtQixVQUFXLENBQVgsRUFBZTtBQUVqQyxnQkFBTSxPQUFPLEdBQUcsQ0FBQyxDQUFDLElBQWxCOztBQUVBLG9CQUFTLE9BQU8sQ0FBQyxJQUFqQjtBQUVDLG1CQUFLLFFBQUw7QUFDQyxnQkFBQSxRQUFNLENBQUMsVUFBUCxDQUFtQixPQUFPLENBQUMsRUFBM0IsRUFBZ0MsT0FBaEMsQ0FBeUMsT0FBekM7O0FBQ0E7O0FBRUQsbUJBQUssT0FBTDtBQUNDLGdCQUFBLFFBQU0sQ0FBQyxVQUFQLENBQW1CLE9BQU8sQ0FBQyxFQUEzQixFQUFnQyxNQUFoQyxDQUF3QyxPQUF4Qzs7QUFDQTs7QUFFRDtBQUNDLGdCQUFBLE9BQU8sQ0FBQyxLQUFSLENBQWUsNkNBQTZDLE9BQU8sQ0FBQyxJQUFyRCxHQUE0RCxHQUEzRTtBQVhGO0FBZUEsV0FuQkQ7O0FBcUJBLFVBQUEsTUFBSSxDQUFDLFVBQUwsQ0FBZ0IsSUFBaEIsQ0FBc0IsUUFBdEI7QUFFQSxTQWpDRCxNQWlDTztBQUVOLFVBQUEsTUFBSSxDQUFDLFVBQUwsQ0FBZ0IsSUFBaEIsQ0FBc0IsVUFBVyxDQUFYLEVBQWMsQ0FBZCxFQUFrQjtBQUV2QyxtQkFBTyxDQUFDLENBQUMsU0FBRixHQUFjLENBQUMsQ0FBQyxTQUFoQixHQUE0QixDQUFFLENBQTlCLEdBQWtDLENBQXpDO0FBRUEsV0FKRDtBQU1BOztBQUVELFlBQU0sTUFBTSxHQUFHLE1BQUksQ0FBQyxVQUFMLENBQWlCLE1BQUksQ0FBQyxVQUFMLENBQWdCLE1BQWhCLEdBQXlCLENBQTFDLENBQWY7QUFDQSxRQUFBLE1BQU0sQ0FBQyxVQUFQLENBQW1CLE1BQW5CLElBQThCLFFBQTlCO0FBQ0EsUUFBQSxNQUFNLENBQUMsU0FBUCxJQUFvQixRQUFwQjtBQUNBLGVBQU8sTUFBUDtBQUVBLE9BbERNLENBQVA7QUFvREE7OztXQUVELHNCQUFjLE1BQWQsRUFBc0IsTUFBdEIsRUFBK0I7QUFFOUIsTUFBQSxNQUFNLENBQUMsU0FBUCxJQUFvQixNQUFNLENBQUMsVUFBUCxDQUFtQixNQUFuQixDQUFwQjtBQUNBLGFBQU8sTUFBTSxDQUFDLFVBQVAsQ0FBbUIsTUFBbkIsQ0FBUDtBQUNBLGFBQU8sTUFBTSxDQUFDLFVBQVAsQ0FBbUIsTUFBbkIsQ0FBUDtBQUVBOzs7V0FFRCxpQkFBUTtBQUVQLE1BQUEsT0FBTyxDQUFDLEdBQVIsQ0FBYSxhQUFiLEVBQTRCLEtBQUssVUFBTCxDQUFnQixHQUFoQixDQUFxQixVQUFFLE1BQUY7QUFBQSxlQUFjLE1BQU0sQ0FBQyxTQUFyQjtBQUFBLE9BQXJCLENBQTVCO0FBRUE7OztXQUVELG1CQUFVO0FBRVQsV0FBTSxJQUFJLENBQUMsR0FBRyxDQUFkLEVBQWlCLENBQUMsR0FBRyxLQUFLLFVBQUwsQ0FBZ0IsTUFBckMsRUFBNkMsRUFBRyxDQUFoRCxFQUFvRDtBQUVuRCxhQUFLLFVBQUwsQ0FBaUIsQ0FBakIsRUFBcUIsU0FBckI7QUFFQTs7QUFFRCxXQUFLLFVBQUwsQ0FBZ0IsTUFBaEIsR0FBeUIsQ0FBekI7QUFFQSxhQUFPLElBQVA7QUFFQTs7O0VBcFh3QixhOzs7O0FBMFgxQixTQUFTLFdBQVQsR0FBdUI7QUFFdEIsTUFBSSxhQUFKO0FBQ0EsTUFBSSxjQUFKOztBQUVBLEVBQUEsU0FBUyxHQUFHLG1CQUFXLENBQVgsRUFBZTtBQUUxQixRQUFNLE9BQU8sR0FBRyxDQUFDLENBQUMsSUFBbEI7O0FBRUEsWUFBUyxPQUFPLENBQUMsSUFBakI7QUFFQyxXQUFLLE1BQUw7QUFDQyxRQUFBLGFBQWEsR0FBRyxPQUFPLENBQUMsYUFBeEI7QUFDQSxRQUFBLGNBQWMsR0FBRyxJQUFJLE9BQUosQ0FBYSxVQUFXLE9BQVgsRUFBaUM7QUFFOUQsVUFBQSxhQUFhLENBQUMsY0FBZCxHQUErQixVQUFXLEtBQVgsRUFBbUI7QUFHakQsWUFBQSxPQUFPLENBQUU7QUFBRSxjQUFBLEtBQUssRUFBRTtBQUFULGFBQUYsQ0FBUDtBQUVBLFdBTEQ7O0FBT0EsVUFBQSxrQkFBa0IsQ0FBRSxhQUFGLENBQWxCO0FBRUEsU0FYZ0IsQ0FBakI7QUFZQTs7QUFFRCxXQUFLLFFBQUw7QUFDQyxZQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsTUFBdkI7QUFDQSxZQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsVUFBM0I7QUFDQSxRQUFBLGNBQWMsQ0FBQyxJQUFmLENBQXFCLFVBQUUsTUFBRixFQUFjO0FBRWxDLGNBQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFyQjtBQUNBLGNBQU0sT0FBTyxHQUFHLElBQUksS0FBSyxDQUFDLE9BQVYsRUFBaEI7QUFDQSxjQUFNLGFBQWEsR0FBRyxJQUFJLEtBQUssQ0FBQyxhQUFWLEVBQXRCO0FBQ0EsVUFBQSxhQUFhLENBQUMsSUFBZCxDQUFvQixJQUFJLFNBQUosQ0FBZSxNQUFmLENBQXBCLEVBQTZDLE1BQU0sQ0FBQyxVQUFwRDs7QUFFQSxjQUFJO0FBRUgsZ0JBQU0sUUFBUSxHQUFHLGNBQWMsQ0FBRSxLQUFGLEVBQVMsT0FBVCxFQUFrQixhQUFsQixFQUFpQyxVQUFqQyxDQUEvQjtBQUVBLGdCQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsVUFBVCxDQUFvQixHQUFwQixDQUF5QixVQUFFLElBQUY7QUFBQSxxQkFBWSxJQUFJLENBQUMsS0FBTCxDQUFXLE1BQXZCO0FBQUEsYUFBekIsQ0FBaEI7QUFFQSxnQkFBSyxRQUFRLENBQUMsS0FBZCxFQUFzQixPQUFPLENBQUMsSUFBUixDQUFjLFFBQVEsQ0FBQyxLQUFULENBQWUsS0FBZixDQUFxQixNQUFuQztBQUV0QixZQUFBLElBQUksQ0FBQyxXQUFMLENBQWtCO0FBQUUsY0FBQSxJQUFJLEVBQUUsUUFBUjtBQUFrQixjQUFBLEVBQUUsRUFBRSxPQUFPLENBQUMsRUFBOUI7QUFBa0MsY0FBQSxRQUFRLEVBQVI7QUFBbEMsYUFBbEIsRUFBZ0UsT0FBaEU7QUFFQSxXQVZELENBVUUsT0FBUSxLQUFSLEVBQWdCO0FBRWpCLFlBQUEsT0FBTyxDQUFDLEtBQVIsQ0FBZSxLQUFmO0FBRUEsWUFBQSxJQUFJLENBQUMsV0FBTCxDQUFrQjtBQUFFLGNBQUEsSUFBSSxFQUFFLE9BQVI7QUFBaUIsY0FBQSxFQUFFLEVBQUUsT0FBTyxDQUFDLEVBQTdCO0FBQWlDLGNBQUEsS0FBSyxFQUFFLEtBQUssQ0FBQztBQUE5QyxhQUFsQjtBQUVBLFdBaEJELFNBZ0JVO0FBRVQsWUFBQSxLQUFLLENBQUMsT0FBTixDQUFlLGFBQWY7QUFDQSxZQUFBLEtBQUssQ0FBQyxPQUFOLENBQWUsT0FBZjtBQUVBO0FBRUQsU0E5QkQ7QUErQkE7QUFwREY7QUF3REEsR0E1REQ7O0FBOERBLFdBQVMsY0FBVCxDQUF5QixLQUF6QixFQUFnQyxPQUFoQyxFQUF5QyxhQUF6QyxFQUF3RCxVQUF4RCxFQUFxRTtBQUVwRSxRQUFNLFlBQVksR0FBRyxVQUFVLENBQUMsWUFBaEM7QUFDQSxRQUFNLGNBQWMsR0FBRyxVQUFVLENBQUMsY0FBbEM7QUFFQSxRQUFJLGFBQUo7QUFDQSxRQUFJLGNBQUo7QUFFQSxRQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsc0JBQVIsQ0FBZ0MsYUFBaEMsQ0FBckI7O0FBRUEsUUFBSyxZQUFZLEtBQUssS0FBSyxDQUFDLGVBQTVCLEVBQThDO0FBRTdDLE1BQUEsYUFBYSxHQUFHLElBQUksS0FBSyxDQUFDLElBQVYsRUFBaEI7QUFDQSxNQUFBLGNBQWMsR0FBRyxPQUFPLENBQUMsa0JBQVIsQ0FBNEIsYUFBNUIsRUFBMkMsYUFBM0MsQ0FBakI7QUFFQSxLQUxELE1BS08sSUFBSyxZQUFZLEtBQUssS0FBSyxDQUFDLFdBQTVCLEVBQTBDO0FBRWhELE1BQUEsYUFBYSxHQUFHLElBQUksS0FBSyxDQUFDLFVBQVYsRUFBaEI7QUFDQSxNQUFBLGNBQWMsR0FBRyxPQUFPLENBQUMsd0JBQVIsQ0FBa0MsYUFBbEMsRUFBaUQsYUFBakQsQ0FBakI7QUFFQSxLQUxNLE1BS0E7QUFFTixZQUFNLElBQUksS0FBSixDQUFXLDhDQUFYLENBQU47QUFFQTs7QUFFRCxRQUFLLENBQUUsY0FBYyxDQUFDLEVBQWYsRUFBRixJQUF5QixhQUFhLENBQUMsR0FBZCxLQUFzQixDQUFwRCxFQUF3RDtBQUV2RCxZQUFNLElBQUksS0FBSixDQUFXLHlDQUF5QyxjQUFjLENBQUMsU0FBZixFQUFwRCxDQUFOO0FBRUE7O0FBRUQsUUFBTSxRQUFRLEdBQUc7QUFBRSxNQUFBLEtBQUssRUFBRSxJQUFUO0FBQWUsTUFBQSxVQUFVLEVBQUU7QUFBM0IsS0FBakI7O0FBR0EsU0FBTSxJQUFNLGFBQVosSUFBNkIsWUFBN0IsRUFBNEM7QUFFM0MsVUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFFLGNBQWMsQ0FBRSxhQUFGLENBQWhCLENBQTFCO0FBRUEsVUFBSSxTQUFTLFNBQWI7QUFDQSxVQUFJLFdBQVcsU0FBZjs7QUFNQSxVQUFLLFVBQVUsQ0FBQyxZQUFoQixFQUErQjtBQUU5QixRQUFBLFdBQVcsR0FBRyxZQUFZLENBQUUsYUFBRixDQUExQjtBQUNBLFFBQUEsU0FBUyxHQUFHLE9BQU8sQ0FBQyxzQkFBUixDQUFnQyxhQUFoQyxFQUErQyxXQUEvQyxDQUFaO0FBRUEsT0FMRCxNQUtPO0FBRU4sUUFBQSxXQUFXLEdBQUcsT0FBTyxDQUFDLGNBQVIsQ0FBd0IsYUFBeEIsRUFBdUMsS0FBSyxDQUFFLFlBQVksQ0FBRSxhQUFGLENBQWQsQ0FBNUMsQ0FBZDtBQUVBLFlBQUssV0FBVyxLQUFLLENBQUUsQ0FBdkIsRUFBMkI7QUFFM0IsUUFBQSxTQUFTLEdBQUcsT0FBTyxDQUFDLFlBQVIsQ0FBc0IsYUFBdEIsRUFBcUMsV0FBckMsQ0FBWjtBQUVBOztBQUVELE1BQUEsUUFBUSxDQUFDLFVBQVQsQ0FBb0IsSUFBcEIsQ0FBMEIsZUFBZSxDQUFFLEtBQUYsRUFBUyxPQUFULEVBQWtCLGFBQWxCLEVBQWlDLGFBQWpDLEVBQWdELGFBQWhELEVBQStELFNBQS9ELENBQXpDO0FBRUE7O0FBR0QsUUFBSyxZQUFZLEtBQUssS0FBSyxDQUFDLGVBQTVCLEVBQThDO0FBRTdDLE1BQUEsUUFBUSxDQUFDLEtBQVQsR0FBaUIsV0FBVyxDQUFFLEtBQUYsRUFBUyxPQUFULEVBQWtCLGFBQWxCLENBQTVCO0FBRUE7O0FBRUQsSUFBQSxLQUFLLENBQUMsT0FBTixDQUFlLGFBQWY7QUFFQSxXQUFPLFFBQVA7QUFFQTs7QUFFRCxXQUFTLFdBQVQsQ0FBc0IsS0FBdEIsRUFBNkIsT0FBN0IsRUFBc0MsYUFBdEMsRUFBc0Q7QUFFckQsUUFBTSxRQUFRLEdBQUcsYUFBYSxDQUFDLFNBQWQsRUFBakI7QUFDQSxRQUFNLFVBQVUsR0FBRyxRQUFRLEdBQUcsQ0FBOUI7QUFDQSxRQUFNLFVBQVUsR0FBRyxVQUFVLEdBQUcsQ0FBaEM7O0FBRUEsUUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDLE9BQU4sQ0FBZSxVQUFmLENBQVo7O0FBQ0EsSUFBQSxPQUFPLENBQUMsdUJBQVIsQ0FBaUMsYUFBakMsRUFBZ0QsVUFBaEQsRUFBNEQsR0FBNUQ7QUFDQSxRQUFNLEtBQUssR0FBRyxJQUFJLFdBQUosQ0FBaUIsS0FBSyxDQUFDLE9BQU4sQ0FBYyxNQUEvQixFQUF1QyxHQUF2QyxFQUE0QyxVQUE1QyxFQUF5RCxLQUF6RCxFQUFkOztBQUNBLElBQUEsS0FBSyxDQUFDLEtBQU4sQ0FBYSxHQUFiOztBQUVBLFdBQU87QUFBRSxNQUFBLEtBQUssRUFBRSxLQUFUO0FBQWdCLE1BQUEsUUFBUSxFQUFFO0FBQTFCLEtBQVA7QUFFQTs7QUFFRCxXQUFTLGVBQVQsQ0FBMEIsS0FBMUIsRUFBaUMsT0FBakMsRUFBMEMsYUFBMUMsRUFBeUQsYUFBekQsRUFBd0UsYUFBeEUsRUFBdUYsU0FBdkYsRUFBbUc7QUFFbEcsUUFBTSxhQUFhLEdBQUcsU0FBUyxDQUFDLGNBQVYsRUFBdEI7QUFDQSxRQUFNLFNBQVMsR0FBRyxhQUFhLENBQUMsVUFBZCxFQUFsQjtBQUNBLFFBQU0sU0FBUyxHQUFHLFNBQVMsR0FBRyxhQUE5QjtBQUNBLFFBQU0sVUFBVSxHQUFHLFNBQVMsR0FBRyxhQUFhLENBQUMsaUJBQTdDO0FBQ0EsUUFBTSxRQUFRLEdBQUcsZ0JBQWdCLENBQUUsS0FBRixFQUFTLGFBQVQsQ0FBakM7O0FBRUEsUUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDLE9BQU4sQ0FBZSxVQUFmLENBQVo7O0FBQ0EsSUFBQSxPQUFPLENBQUMsaUNBQVIsQ0FBMkMsYUFBM0MsRUFBMEQsU0FBMUQsRUFBcUUsUUFBckUsRUFBK0UsVUFBL0UsRUFBMkYsR0FBM0Y7QUFDQSxRQUFNLEtBQUssR0FBRyxJQUFJLGFBQUosQ0FBbUIsS0FBSyxDQUFDLE9BQU4sQ0FBYyxNQUFqQyxFQUF5QyxHQUF6QyxFQUE4QyxTQUE5QyxFQUEwRCxLQUExRCxFQUFkOztBQUNBLElBQUEsS0FBSyxDQUFDLEtBQU4sQ0FBYSxHQUFiOztBQUVBLFdBQU87QUFDTixNQUFBLElBQUksRUFBRSxhQURBO0FBRU4sTUFBQSxLQUFLLEVBQUUsS0FGRDtBQUdOLE1BQUEsUUFBUSxFQUFFO0FBSEosS0FBUDtBQU1BOztBQUVELFdBQVMsZ0JBQVQsQ0FBMkIsS0FBM0IsRUFBa0MsYUFBbEMsRUFBa0Q7QUFFakQsWUFBUyxhQUFUO0FBRUMsV0FBSyxZQUFMO0FBQW1CLGVBQU8sS0FBSyxDQUFDLFVBQWI7O0FBQ25CLFdBQUssU0FBTDtBQUFnQixlQUFPLEtBQUssQ0FBQyxPQUFiOztBQUNoQixXQUFLLFVBQUw7QUFBaUIsZUFBTyxLQUFLLENBQUMsUUFBYjs7QUFDakIsV0FBSyxVQUFMO0FBQWlCLGVBQU8sS0FBSyxDQUFDLFFBQWI7O0FBQ2pCLFdBQUssVUFBTDtBQUFpQixlQUFPLEtBQUssQ0FBQyxRQUFiOztBQUNqQixXQUFLLFdBQUw7QUFBa0IsZUFBTyxLQUFLLENBQUMsU0FBYjs7QUFDbEIsV0FBSyxXQUFMO0FBQWtCLGVBQU8sS0FBSyxDQUFDLFNBQWI7QUFSbkI7QUFZQTtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4a0JEOzs7Ozs7Ozs7Ozs7SUFrRU0sVTs7Ozs7QUFFTCxzQkFBYSxPQUFiLEVBQXVCO0FBQUE7O0FBQUE7QUFFdEIsOEJBQU8sT0FBUDtBQUVBLFVBQUssV0FBTCxHQUFtQixJQUFuQjtBQUNBLFVBQUssVUFBTCxHQUFrQixJQUFsQjtBQUNBLFVBQUssY0FBTCxHQUFzQixJQUF0QjtBQUVBLFVBQUssZUFBTCxHQUF1QixFQUF2Qjs7QUFFQSxVQUFLLFFBQUwsQ0FBZSxVQUFXLE1BQVgsRUFBb0I7QUFFbEMsYUFBTyxJQUFJLCtCQUFKLENBQXFDLE1BQXJDLENBQVA7QUFFQSxLQUpEOztBQU1BLFVBQUssUUFBTCxDQUFlLFVBQVcsTUFBWCxFQUFvQjtBQUVsQyxhQUFPLElBQUksMEJBQUosQ0FBZ0MsTUFBaEMsQ0FBUDtBQUVBLEtBSkQ7O0FBTUEsVUFBSyxRQUFMLENBQWUsVUFBVyxNQUFYLEVBQW9CO0FBRWxDLGFBQU8sSUFBSSx3QkFBSixDQUE4QixNQUE5QixDQUFQO0FBRUEsS0FKRDs7QUFNQSxVQUFLLFFBQUwsQ0FBZSxVQUFXLE1BQVgsRUFBb0I7QUFFbEMsYUFBTyxJQUFJLDJCQUFKLENBQWlDLE1BQWpDLENBQVA7QUFFQSxLQUpEOztBQU1BLFVBQUssUUFBTCxDQUFlLFVBQVcsTUFBWCxFQUFvQjtBQUVsQyxhQUFPLElBQUksa0NBQUosQ0FBd0MsTUFBeEMsQ0FBUDtBQUVBLEtBSkQ7O0FBTUEsVUFBSyxRQUFMLENBQWUsVUFBVyxNQUFYLEVBQW9CO0FBRWxDLGFBQU8sSUFBSSw0QkFBSixDQUFrQyxNQUFsQyxDQUFQO0FBRUEsS0FKRDs7QUFNQSxVQUFLLFFBQUwsQ0FBZSxVQUFXLE1BQVgsRUFBb0I7QUFFbEMsYUFBTyxJQUFJLHlCQUFKLENBQStCLE1BQS9CLENBQVA7QUFFQSxLQUpEOztBQU1BLFVBQUssUUFBTCxDQUFlLFVBQVcsTUFBWCxFQUFvQjtBQUVsQyxhQUFPLElBQUksOEJBQUosQ0FBb0MsTUFBcEMsQ0FBUDtBQUVBLEtBSkQ7O0FBTUEsVUFBSyxRQUFMLENBQWUsVUFBVyxNQUFYLEVBQW9CO0FBRWxDLGFBQU8sSUFBSSxtQkFBSixDQUF5QixNQUF6QixDQUFQO0FBRUEsS0FKRDs7QUFNQSxVQUFLLFFBQUwsQ0FBZSxVQUFXLE1BQVgsRUFBb0I7QUFFbEMsYUFBTyxJQUFJLHNCQUFKLENBQTRCLE1BQTVCLENBQVA7QUFFQSxLQUpEOztBQWhFc0I7QUFzRXRCOzs7O1dBRUQsY0FBTSxHQUFOLEVBQVcsTUFBWCxFQUFtQixVQUFuQixFQUErQixPQUEvQixFQUF5QztBQUV4QyxVQUFNLEtBQUssR0FBRyxJQUFkO0FBRUEsVUFBSSxZQUFKOztBQUVBLFVBQUssS0FBSyxZQUFMLEtBQXNCLEVBQTNCLEVBQWdDO0FBRS9CLFFBQUEsWUFBWSxHQUFHLEtBQUssWUFBcEI7QUFFQSxPQUpELE1BSU8sSUFBSyxLQUFLLElBQUwsS0FBYyxFQUFuQixFQUF3QjtBQUU5QixRQUFBLFlBQVksR0FBRyxLQUFLLElBQXBCO0FBRUEsT0FKTSxNQUlBO0FBRU4sUUFBQSxZQUFZLEdBQUcsbUJBQVksY0FBWixDQUE0QixHQUE1QixDQUFmO0FBRUE7O0FBS0QsV0FBSyxPQUFMLENBQWEsU0FBYixDQUF3QixHQUF4Qjs7QUFFQSxVQUFNLFFBQVEsR0FBRyxTQUFYLFFBQVcsQ0FBVyxDQUFYLEVBQWU7QUFFL0IsWUFBSyxPQUFMLEVBQWU7QUFFZCxVQUFBLE9BQU8sQ0FBRSxDQUFGLENBQVA7QUFFQSxTQUpELE1BSU87QUFFTixVQUFBLE9BQU8sQ0FBQyxLQUFSLENBQWUsQ0FBZjtBQUVBOztBQUVELFFBQUEsS0FBSyxDQUFDLE9BQU4sQ0FBYyxTQUFkLENBQXlCLEdBQXpCO0FBQ0EsUUFBQSxLQUFLLENBQUMsT0FBTixDQUFjLE9BQWQsQ0FBdUIsR0FBdkI7QUFFQSxPQWZEOztBQWlCQSxVQUFNLE1BQU0sR0FBRyxJQUFJLGlCQUFKLENBQWdCLEtBQUssT0FBckIsQ0FBZjtBQUVBLE1BQUEsTUFBTSxDQUFDLE9BQVAsQ0FBZ0IsS0FBSyxJQUFyQjtBQUNBLE1BQUEsTUFBTSxDQUFDLGVBQVAsQ0FBd0IsYUFBeEI7QUFDQSxNQUFBLE1BQU0sQ0FBQyxnQkFBUCxDQUF5QixLQUFLLGFBQTlCO0FBQ0EsTUFBQSxNQUFNLENBQUMsa0JBQVAsQ0FBMkIsS0FBSyxlQUFoQztBQUVBLE1BQUEsTUFBTSxDQUFDLElBQVAsQ0FBYSxHQUFiLEVBQWtCLFVBQVcsSUFBWCxFQUFrQjtBQUVuQyxZQUFJO0FBRUgsVUFBQSxLQUFLLENBQUMsS0FBTixDQUFhLElBQWIsRUFBbUIsWUFBbkIsRUFBaUMsVUFBVyxJQUFYLEVBQWtCO0FBRWxELFlBQUEsTUFBTSxDQUFFLElBQUYsQ0FBTjtBQUVBLFlBQUEsS0FBSyxDQUFDLE9BQU4sQ0FBYyxPQUFkLENBQXVCLEdBQXZCO0FBRUEsV0FORCxFQU1HLFFBTkg7QUFRQSxTQVZELENBVUUsT0FBUSxDQUFSLEVBQVk7QUFFYixVQUFBLFFBQVEsQ0FBRSxDQUFGLENBQVI7QUFFQTtBQUVELE9BbEJELEVBa0JHLFVBbEJILEVBa0JlLFFBbEJmO0FBb0JBOzs7V0FFRCx3QkFBZ0IsV0FBaEIsRUFBOEI7QUFFN0IsV0FBSyxXQUFMLEdBQW1CLFdBQW5CO0FBQ0EsYUFBTyxJQUFQO0FBRUE7OztXQUVELHdCQUFlO0FBRWQsWUFBTSxJQUFJLEtBQUosQ0FFTCxrR0FGSyxDQUFOO0FBTUE7OztXQUVELHVCQUFlLFVBQWYsRUFBNEI7QUFFM0IsV0FBSyxVQUFMLEdBQWtCLFVBQWxCO0FBQ0EsYUFBTyxJQUFQO0FBRUE7OztXQUVELDJCQUFtQixjQUFuQixFQUFvQztBQUVuQyxXQUFLLGNBQUwsR0FBc0IsY0FBdEI7QUFDQSxhQUFPLElBQVA7QUFFQTs7O1dBRUQsa0JBQVUsUUFBVixFQUFxQjtBQUVwQixVQUFLLEtBQUssZUFBTCxDQUFxQixPQUFyQixDQUE4QixRQUE5QixNQUE2QyxDQUFFLENBQXBELEVBQXdEO0FBRXZELGFBQUssZUFBTCxDQUFxQixJQUFyQixDQUEyQixRQUEzQjtBQUVBOztBQUVELGFBQU8sSUFBUDtBQUVBOzs7V0FFRCxvQkFBWSxRQUFaLEVBQXVCO0FBRXRCLFVBQUssS0FBSyxlQUFMLENBQXFCLE9BQXJCLENBQThCLFFBQTlCLE1BQTZDLENBQUUsQ0FBcEQsRUFBd0Q7QUFFdkQsYUFBSyxlQUFMLENBQXFCLE1BQXJCLENBQTZCLEtBQUssZUFBTCxDQUFxQixPQUFyQixDQUE4QixRQUE5QixDQUE3QixFQUF1RSxDQUF2RTtBQUVBOztBQUVELGFBQU8sSUFBUDtBQUVBOzs7V0FFRCxlQUFPLElBQVAsRUFBYSxJQUFiLEVBQW1CLE1BQW5CLEVBQTJCLE9BQTNCLEVBQXFDO0FBRXBDLFVBQUksT0FBSjtBQUNBLFVBQU0sVUFBVSxHQUFHLEVBQW5CO0FBQ0EsVUFBTSxPQUFPLEdBQUcsRUFBaEI7O0FBRUEsVUFBSyxPQUFPLElBQVAsS0FBZ0IsUUFBckIsRUFBZ0M7QUFFL0IsUUFBQSxPQUFPLEdBQUcsSUFBVjtBQUVBLE9BSkQsTUFJTztBQUVOLFlBQU0sS0FBSyxHQUFHLG1CQUFZLFVBQVosQ0FBd0IsSUFBSSxVQUFKLENBQWdCLElBQWhCLEVBQXNCLENBQXRCLEVBQXlCLENBQXpCLENBQXhCLENBQWQ7O0FBRUEsWUFBSyxLQUFLLEtBQUssNkJBQWYsRUFBK0M7QUFFOUMsY0FBSTtBQUVILFlBQUEsVUFBVSxDQUFFLFVBQVUsQ0FBQyxlQUFiLENBQVYsR0FBMkMsSUFBSSxtQkFBSixDQUF5QixJQUF6QixDQUEzQztBQUVBLFdBSkQsQ0FJRSxPQUFRLEtBQVIsRUFBZ0I7QUFFakIsZ0JBQUssT0FBTCxFQUFlLE9BQU8sQ0FBRSxLQUFGLENBQVA7QUFDZjtBQUVBOztBQUVELFVBQUEsT0FBTyxHQUFHLFVBQVUsQ0FBRSxVQUFVLENBQUMsZUFBYixDQUFWLENBQXlDLE9BQW5EO0FBRUEsU0FmRCxNQWVPO0FBRU4sVUFBQSxPQUFPLEdBQUcsbUJBQVksVUFBWixDQUF3QixJQUFJLFVBQUosQ0FBZ0IsSUFBaEIsQ0FBeEIsQ0FBVjtBQUVBO0FBRUQ7O0FBRUQsVUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUwsQ0FBWSxPQUFaLENBQWI7O0FBRUEsVUFBSyxJQUFJLENBQUMsS0FBTCxLQUFlLFNBQWYsSUFBNEIsSUFBSSxDQUFDLEtBQUwsQ0FBVyxPQUFYLENBQW9CLENBQXBCLElBQTBCLENBQTNELEVBQStEO0FBRTlELFlBQUssT0FBTCxFQUFlLE9BQU8sQ0FBRSxJQUFJLEtBQUosQ0FBVyx5RUFBWCxDQUFGLENBQVA7QUFDZjtBQUVBOztBQUVELFVBQU0sTUFBTSxHQUFHLElBQUksVUFBSixDQUFnQixJQUFoQixFQUFzQjtBQUVwQyxRQUFBLElBQUksRUFBRSxJQUFJLElBQUksS0FBSyxZQUFiLElBQTZCLEVBRkM7QUFHcEMsUUFBQSxXQUFXLEVBQUUsS0FBSyxXQUhrQjtBQUlwQyxRQUFBLGFBQWEsRUFBRSxLQUFLLGFBSmdCO0FBS3BDLFFBQUEsT0FBTyxFQUFFLEtBQUssT0FMc0I7QUFNcEMsUUFBQSxVQUFVLEVBQUUsS0FBSyxVQU5tQjtBQU9wQyxRQUFBLGNBQWMsRUFBRSxLQUFLO0FBUGUsT0FBdEIsQ0FBZjtBQVdBLE1BQUEsTUFBTSxDQUFDLFVBQVAsQ0FBa0IsZ0JBQWxCLENBQW9DLEtBQUssYUFBekM7O0FBRUEsV0FBTSxJQUFJLENBQUMsR0FBRyxDQUFkLEVBQWlCLENBQUMsR0FBRyxLQUFLLGVBQUwsQ0FBcUIsTUFBMUMsRUFBa0QsQ0FBQyxFQUFuRCxFQUF5RDtBQUV4RCxZQUFNLE1BQU0sR0FBRyxLQUFLLGVBQUwsQ0FBc0IsQ0FBdEIsRUFBMkIsTUFBM0IsQ0FBZjtBQUNBLFFBQUEsT0FBTyxDQUFFLE1BQU0sQ0FBQyxJQUFULENBQVAsR0FBeUIsTUFBekI7QUFNQSxRQUFBLFVBQVUsQ0FBRSxNQUFNLENBQUMsSUFBVCxDQUFWLEdBQTRCLElBQTVCO0FBRUE7O0FBRUQsVUFBSyxJQUFJLENBQUMsY0FBVixFQUEyQjtBQUUxQixhQUFNLElBQUksRUFBQyxHQUFHLENBQWQsRUFBaUIsRUFBQyxHQUFHLElBQUksQ0FBQyxjQUFMLENBQW9CLE1BQXpDLEVBQWlELEVBQUcsRUFBcEQsRUFBd0Q7QUFFdkQsY0FBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLGNBQUwsQ0FBcUIsRUFBckIsQ0FBdEI7QUFDQSxjQUFNLGtCQUFrQixHQUFHLElBQUksQ0FBQyxrQkFBTCxJQUEyQixFQUF0RDs7QUFFQSxrQkFBUyxhQUFUO0FBRUMsaUJBQUssVUFBVSxDQUFDLG1CQUFoQjtBQUNDLGNBQUEsVUFBVSxDQUFFLGFBQUYsQ0FBVixHQUE4QixJQUFJLDJCQUFKLEVBQTlCO0FBQ0E7O0FBRUQsaUJBQUssVUFBVSxDQUFDLHFDQUFoQjtBQUNDLGNBQUEsVUFBVSxDQUFFLGFBQUYsQ0FBVixHQUE4QixJQUFJLDJDQUFKLEVBQTlCO0FBQ0E7O0FBRUQsaUJBQUssVUFBVSxDQUFDLDBCQUFoQjtBQUNDLGNBQUEsVUFBVSxDQUFFLGFBQUYsQ0FBVixHQUE4QixJQUFJLGlDQUFKLENBQXVDLElBQXZDLEVBQTZDLEtBQUssV0FBbEQsQ0FBOUI7QUFDQTs7QUFFRCxpQkFBSyxVQUFVLENBQUMscUJBQWhCO0FBQ0MsY0FBQSxVQUFVLENBQUUsYUFBRixDQUFWLEdBQThCLElBQUksNkJBQUosRUFBOUI7QUFDQTs7QUFFRCxpQkFBSyxVQUFVLENBQUMscUJBQWhCO0FBQ0MsY0FBQSxVQUFVLENBQUUsYUFBRixDQUFWLEdBQThCLElBQUksNkJBQUosRUFBOUI7QUFDQTs7QUFFRDtBQUVDLGtCQUFLLGtCQUFrQixDQUFDLE9BQW5CLENBQTRCLGFBQTVCLEtBQStDLENBQS9DLElBQW9ELE9BQU8sQ0FBRSxhQUFGLENBQVAsS0FBNkIsU0FBdEYsRUFBa0c7QUFFakcsZ0JBQUEsT0FBTyxDQUFDLElBQVIsQ0FBYywwQ0FBMEMsYUFBMUMsR0FBMEQsSUFBeEU7QUFFQTs7QUE1Qkg7QUFnQ0E7QUFFRDs7QUFFRCxNQUFBLE1BQU0sQ0FBQyxhQUFQLENBQXNCLFVBQXRCO0FBQ0EsTUFBQSxNQUFNLENBQUMsVUFBUCxDQUFtQixPQUFuQjtBQUNBLE1BQUEsTUFBTSxDQUFDLEtBQVAsQ0FBYyxNQUFkLEVBQXNCLE9BQXRCO0FBRUE7OztXQUVELG9CQUFZLElBQVosRUFBa0IsSUFBbEIsRUFBeUI7QUFFeEIsVUFBTSxLQUFLLEdBQUcsSUFBZDtBQUVBLGFBQU8sSUFBSSxPQUFKLENBQWEsVUFBVyxPQUFYLEVBQW9CLE1BQXBCLEVBQTZCO0FBRWhELFFBQUEsS0FBSyxDQUFDLEtBQU4sQ0FBYSxJQUFiLEVBQW1CLElBQW5CLEVBQXlCLE9BQXpCLEVBQWtDLE1BQWxDO0FBRUEsT0FKTSxDQUFQO0FBTUE7OztFQTNVdUIsYTs7OztBQWlWekIsU0FBUyxZQUFULEdBQXdCO0FBRXZCLE1BQUksT0FBTyxHQUFHLEVBQWQ7QUFFQSxTQUFPO0FBRU4sSUFBQSxHQUFHLEVBQUUsYUFBVyxHQUFYLEVBQWlCO0FBRXJCLGFBQU8sT0FBTyxDQUFFLEdBQUYsQ0FBZDtBQUVBLEtBTks7QUFRTixJQUFBLEdBQUcsRUFBRSxhQUFXLEdBQVgsRUFBZ0IsTUFBaEIsRUFBeUI7QUFFN0IsTUFBQSxPQUFPLENBQUUsR0FBRixDQUFQLEdBQWlCLE1BQWpCO0FBRUEsS0FaSztBQWNOLElBQUEsTUFBTSxFQUFFLGdCQUFXLEdBQVgsRUFBaUI7QUFFeEIsYUFBTyxPQUFPLENBQUUsR0FBRixDQUFkO0FBRUEsS0FsQks7QUFvQk4sSUFBQSxTQUFTLEVBQUUscUJBQVk7QUFFdEIsTUFBQSxPQUFPLEdBQUcsRUFBVjtBQUVBO0FBeEJLLEdBQVA7QUE0QkE7O0FBTUQsSUFBTSxVQUFVLEdBQUc7QUFDbEIsRUFBQSxlQUFlLEVBQUUsaUJBREM7QUFFbEIsRUFBQSwwQkFBMEIsRUFBRSw0QkFGVjtBQUdsQixFQUFBLG1CQUFtQixFQUFFLHFCQUhIO0FBSWxCLEVBQUEsdUJBQXVCLEVBQUUseUJBSlA7QUFLbEIsRUFBQSxpQkFBaUIsRUFBRSxtQkFMRDtBQU1sQixFQUFBLHFDQUFxQyxFQUFFLHFDQU5yQjtBQU9sQixFQUFBLG1CQUFtQixFQUFFLHFCQVBIO0FBUWxCLEVBQUEsc0JBQXNCLEVBQUUsd0JBUk47QUFTbEIsRUFBQSwwQkFBMEIsRUFBRSw0QkFUVjtBQVVsQixFQUFBLG1CQUFtQixFQUFFLHFCQVZIO0FBV2xCLEVBQUEsb0JBQW9CLEVBQUUsc0JBWEo7QUFZbEIsRUFBQSxrQkFBa0IsRUFBRSxvQkFaRjtBQWFsQixFQUFBLHFCQUFxQixFQUFFLHVCQWJMO0FBY2xCLEVBQUEscUJBQXFCLEVBQUUsdUJBZEw7QUFlbEIsRUFBQSxnQkFBZ0IsRUFBRSxrQkFmQTtBQWdCbEIsRUFBQSx1QkFBdUIsRUFBRTtBQWhCUCxDQUFuQjs7SUF3Qk0sbUI7QUFFTCwrQkFBYSxNQUFiLEVBQXNCO0FBQUE7QUFFckIsU0FBSyxNQUFMLEdBQWMsTUFBZDtBQUNBLFNBQUssSUFBTCxHQUFZLFVBQVUsQ0FBQyxtQkFBdkI7QUFHQSxTQUFLLEtBQUwsR0FBYTtBQUFFLE1BQUEsSUFBSSxFQUFFLEVBQVI7QUFBWSxNQUFBLElBQUksRUFBRTtBQUFsQixLQUFiO0FBRUE7Ozs7V0FFRCxxQkFBWTtBQUVYLFVBQU0sTUFBTSxHQUFHLEtBQUssTUFBcEI7QUFDQSxVQUFNLFFBQVEsR0FBRyxLQUFLLE1BQUwsQ0FBWSxJQUFaLENBQWlCLEtBQWpCLElBQTBCLEVBQTNDOztBQUVBLFdBQU0sSUFBSSxTQUFTLEdBQUcsQ0FBaEIsRUFBbUIsVUFBVSxHQUFHLFFBQVEsQ0FBQyxNQUEvQyxFQUF1RCxTQUFTLEdBQUcsVUFBbkUsRUFBK0UsU0FBUyxFQUF4RixFQUE4RjtBQUU3RixZQUFNLE9BQU8sR0FBRyxRQUFRLENBQUUsU0FBRixDQUF4Qjs7QUFFQSxZQUFLLE9BQU8sQ0FBQyxVQUFSLElBQ0EsT0FBTyxDQUFDLFVBQVIsQ0FBb0IsS0FBSyxJQUF6QixDQURBLElBRUEsT0FBTyxDQUFDLFVBQVIsQ0FBb0IsS0FBSyxJQUF6QixFQUFnQyxLQUFoQyxLQUEwQyxTQUYvQyxFQUUyRDtBQUUxRCxVQUFBLE1BQU0sQ0FBQyxXQUFQLENBQW9CLEtBQUssS0FBekIsRUFBZ0MsT0FBTyxDQUFDLFVBQVIsQ0FBb0IsS0FBSyxJQUF6QixFQUFnQyxLQUFoRTtBQUVBO0FBRUQ7QUFFRDs7O1dBRUQsb0JBQVksVUFBWixFQUF5QjtBQUV4QixVQUFNLE1BQU0sR0FBRyxLQUFLLE1BQXBCO0FBQ0EsVUFBTSxRQUFRLEdBQUcsV0FBVyxVQUE1QjtBQUNBLFVBQUksVUFBVSxHQUFHLE1BQU0sQ0FBQyxLQUFQLENBQWEsR0FBYixDQUFrQixRQUFsQixDQUFqQjtBQUVBLFVBQUssVUFBTCxFQUFrQixPQUFPLFVBQVA7QUFFbEIsVUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQXBCO0FBQ0EsVUFBTSxVQUFVLEdBQUssSUFBSSxDQUFDLFVBQUwsSUFBbUIsSUFBSSxDQUFDLFVBQUwsQ0FBaUIsS0FBSyxJQUF0QixDQUFyQixJQUF1RCxFQUExRTtBQUNBLFVBQU0sU0FBUyxHQUFHLFVBQVUsQ0FBQyxNQUFYLElBQXFCLEVBQXZDO0FBQ0EsVUFBTSxRQUFRLEdBQUcsU0FBUyxDQUFFLFVBQUYsQ0FBMUI7QUFDQSxVQUFJLFNBQUo7QUFFQSxVQUFNLEtBQUssR0FBRyxJQUFJLFlBQUosQ0FBVyxRQUFYLENBQWQ7QUFFQSxVQUFLLFFBQVEsQ0FBQyxLQUFULEtBQW1CLFNBQXhCLEVBQW9DLEtBQUssQ0FBQyxTQUFOLENBQWlCLFFBQVEsQ0FBQyxLQUExQjtBQUVwQyxVQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsS0FBVCxLQUFtQixTQUFuQixHQUErQixRQUFRLENBQUMsS0FBeEMsR0FBZ0QsQ0FBOUQ7O0FBRUEsY0FBUyxRQUFRLENBQUMsSUFBbEI7QUFFQyxhQUFLLGFBQUw7QUFDQyxVQUFBLFNBQVMsR0FBRyxJQUFJLHVCQUFKLENBQXNCLEtBQXRCLENBQVo7QUFDQSxVQUFBLFNBQVMsQ0FBQyxNQUFWLENBQWlCLFFBQWpCLENBQTBCLEdBQTFCLENBQStCLENBQS9CLEVBQWtDLENBQWxDLEVBQXFDLENBQUUsQ0FBdkM7QUFDQSxVQUFBLFNBQVMsQ0FBQyxHQUFWLENBQWUsU0FBUyxDQUFDLE1BQXpCO0FBQ0E7O0FBRUQsYUFBSyxPQUFMO0FBQ0MsVUFBQSxTQUFTLEdBQUcsSUFBSSxpQkFBSixDQUFnQixLQUFoQixDQUFaO0FBQ0EsVUFBQSxTQUFTLENBQUMsUUFBVixHQUFxQixLQUFyQjtBQUNBOztBQUVELGFBQUssTUFBTDtBQUNDLFVBQUEsU0FBUyxHQUFHLElBQUksZ0JBQUosQ0FBZSxLQUFmLENBQVo7QUFDQSxVQUFBLFNBQVMsQ0FBQyxRQUFWLEdBQXFCLEtBQXJCO0FBRUEsVUFBQSxRQUFRLENBQUMsSUFBVCxHQUFnQixRQUFRLENBQUMsSUFBVCxJQUFpQixFQUFqQztBQUNBLFVBQUEsUUFBUSxDQUFDLElBQVQsQ0FBYyxjQUFkLEdBQStCLFFBQVEsQ0FBQyxJQUFULENBQWMsY0FBZCxLQUFpQyxTQUFqQyxHQUE2QyxRQUFRLENBQUMsSUFBVCxDQUFjLGNBQTNELEdBQTRFLENBQTNHO0FBQ0EsVUFBQSxRQUFRLENBQUMsSUFBVCxDQUFjLGNBQWQsR0FBK0IsUUFBUSxDQUFDLElBQVQsQ0FBYyxjQUFkLEtBQWlDLFNBQWpDLEdBQTZDLFFBQVEsQ0FBQyxJQUFULENBQWMsY0FBM0QsR0FBNEUsSUFBSSxDQUFDLEVBQUwsR0FBVSxHQUFySDtBQUNBLFVBQUEsU0FBUyxDQUFDLEtBQVYsR0FBa0IsUUFBUSxDQUFDLElBQVQsQ0FBYyxjQUFoQztBQUNBLFVBQUEsU0FBUyxDQUFDLFFBQVYsR0FBcUIsTUFBTSxRQUFRLENBQUMsSUFBVCxDQUFjLGNBQWQsR0FBK0IsUUFBUSxDQUFDLElBQVQsQ0FBYyxjQUF4RTtBQUNBLFVBQUEsU0FBUyxDQUFDLE1BQVYsQ0FBaUIsUUFBakIsQ0FBMEIsR0FBMUIsQ0FBK0IsQ0FBL0IsRUFBa0MsQ0FBbEMsRUFBcUMsQ0FBRSxDQUF2QztBQUNBLFVBQUEsU0FBUyxDQUFDLEdBQVYsQ0FBZSxTQUFTLENBQUMsTUFBekI7QUFDQTs7QUFFRDtBQUNDLGdCQUFNLElBQUksS0FBSixDQUFXLDhDQUE4QyxRQUFRLENBQUMsSUFBbEUsQ0FBTjtBQTNCRjs7QUFpQ0EsTUFBQSxTQUFTLENBQUMsUUFBVixDQUFtQixHQUFuQixDQUF3QixDQUF4QixFQUEyQixDQUEzQixFQUE4QixDQUE5QjtBQUVBLE1BQUEsU0FBUyxDQUFDLEtBQVYsR0FBa0IsQ0FBbEI7QUFFQSxVQUFLLFFBQVEsQ0FBQyxTQUFULEtBQXVCLFNBQTVCLEVBQXdDLFNBQVMsQ0FBQyxTQUFWLEdBQXNCLFFBQVEsQ0FBQyxTQUEvQjtBQUV4QyxNQUFBLFNBQVMsQ0FBQyxJQUFWLEdBQWlCLE1BQU0sQ0FBQyxnQkFBUCxDQUF5QixRQUFRLENBQUMsSUFBVCxJQUFtQixXQUFXLFVBQXZELENBQWpCO0FBRUEsTUFBQSxVQUFVLEdBQUcsT0FBTyxDQUFDLE9BQVIsQ0FBaUIsU0FBakIsQ0FBYjtBQUVBLE1BQUEsTUFBTSxDQUFDLEtBQVAsQ0FBYSxHQUFiLENBQWtCLFFBQWxCLEVBQTRCLFVBQTVCO0FBRUEsYUFBTyxVQUFQO0FBRUE7OztXQUVELDhCQUFzQixTQUF0QixFQUFrQztBQUVqQyxVQUFNLElBQUksR0FBRyxJQUFiO0FBQ0EsVUFBTSxNQUFNLEdBQUcsS0FBSyxNQUFwQjtBQUNBLFVBQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFwQjtBQUNBLFVBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFMLENBQVksU0FBWixDQUFoQjtBQUNBLFVBQU0sUUFBUSxHQUFLLE9BQU8sQ0FBQyxVQUFSLElBQXNCLE9BQU8sQ0FBQyxVQUFSLENBQW9CLEtBQUssSUFBekIsQ0FBeEIsSUFBNkQsRUFBOUU7QUFDQSxVQUFNLFVBQVUsR0FBRyxRQUFRLENBQUMsS0FBNUI7QUFFQSxVQUFLLFVBQVUsS0FBSyxTQUFwQixFQUFnQyxPQUFPLElBQVA7QUFFaEMsYUFBTyxLQUFLLFVBQUwsQ0FBaUIsVUFBakIsRUFBOEIsSUFBOUIsQ0FBb0MsVUFBVyxLQUFYLEVBQW1CO0FBRTdELGVBQU8sTUFBTSxDQUFDLFdBQVAsQ0FBb0IsSUFBSSxDQUFDLEtBQXpCLEVBQWdDLFVBQWhDLEVBQTRDLEtBQTVDLENBQVA7QUFFQSxPQUpNLENBQVA7QUFNQTs7Ozs7SUFTSSwyQjtBQUVMLHlDQUFjO0FBQUE7QUFFYixTQUFLLElBQUwsR0FBWSxVQUFVLENBQUMsbUJBQXZCO0FBRUE7Ozs7V0FFRCwyQkFBa0I7QUFFakIsYUFBTyx3QkFBUDtBQUVBOzs7V0FFRCxzQkFBYyxjQUFkLEVBQThCLFdBQTlCLEVBQTJDLE1BQTNDLEVBQW9EO0FBRW5ELFVBQU0sT0FBTyxHQUFHLEVBQWhCO0FBRUEsTUFBQSxjQUFjLENBQUMsS0FBZixHQUF1QixJQUFJLFlBQUosQ0FBVyxHQUFYLEVBQWdCLEdBQWhCLEVBQXFCLEdBQXJCLENBQXZCO0FBQ0EsTUFBQSxjQUFjLENBQUMsT0FBZixHQUF5QixHQUF6QjtBQUVBLFVBQU0saUJBQWlCLEdBQUcsV0FBVyxDQUFDLG9CQUF0Qzs7QUFFQSxVQUFLLGlCQUFMLEVBQXlCO0FBRXhCLFlBQUssS0FBSyxDQUFDLE9BQU4sQ0FBZSxpQkFBaUIsQ0FBQyxlQUFqQyxDQUFMLEVBQTBEO0FBRXpELGNBQU0sS0FBSyxHQUFHLGlCQUFpQixDQUFDLGVBQWhDO0FBRUEsVUFBQSxjQUFjLENBQUMsS0FBZixDQUFxQixTQUFyQixDQUFnQyxLQUFoQztBQUNBLFVBQUEsY0FBYyxDQUFDLE9BQWYsR0FBeUIsS0FBSyxDQUFFLENBQUYsQ0FBOUI7QUFFQTs7QUFFRCxZQUFLLGlCQUFpQixDQUFDLGdCQUFsQixLQUF1QyxTQUE1QyxFQUF3RDtBQUV2RCxVQUFBLE9BQU8sQ0FBQyxJQUFSLENBQWMsTUFBTSxDQUFDLGFBQVAsQ0FBc0IsY0FBdEIsRUFBc0MsS0FBdEMsRUFBNkMsaUJBQWlCLENBQUMsZ0JBQS9ELENBQWQ7QUFFQTtBQUVEOztBQUVELGFBQU8sT0FBTyxDQUFDLEdBQVIsQ0FBYSxPQUFiLENBQVA7QUFFQTs7Ozs7SUFTSSwrQjtBQUVMLDJDQUFhLE1BQWIsRUFBc0I7QUFBQTtBQUVyQixTQUFLLE1BQUwsR0FBYyxNQUFkO0FBQ0EsU0FBSyxJQUFMLEdBQVksVUFBVSxDQUFDLHVCQUF2QjtBQUVBOzs7O1dBRUQseUJBQWlCLGFBQWpCLEVBQWlDO0FBRWhDLFVBQU0sTUFBTSxHQUFHLEtBQUssTUFBcEI7QUFDQSxVQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsSUFBUCxDQUFZLFNBQVosQ0FBdUIsYUFBdkIsQ0FBcEI7QUFFQSxVQUFLLENBQUUsV0FBVyxDQUFDLFVBQWQsSUFBNEIsQ0FBRSxXQUFXLENBQUMsVUFBWixDQUF3QixLQUFLLElBQTdCLENBQW5DLEVBQXlFLE9BQU8sSUFBUDtBQUV6RSxhQUFPLDJCQUFQO0FBRUE7OztXQUVELDhCQUFzQixhQUF0QixFQUFxQyxjQUFyQyxFQUFzRDtBQUVyRCxVQUFNLE1BQU0sR0FBRyxLQUFLLE1BQXBCO0FBQ0EsVUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLElBQVAsQ0FBWSxTQUFaLENBQXVCLGFBQXZCLENBQXBCOztBQUVBLFVBQUssQ0FBRSxXQUFXLENBQUMsVUFBZCxJQUE0QixDQUFFLFdBQVcsQ0FBQyxVQUFaLENBQXdCLEtBQUssSUFBN0IsQ0FBbkMsRUFBeUU7QUFFeEUsZUFBTyxPQUFPLENBQUMsT0FBUixFQUFQO0FBRUE7O0FBRUQsVUFBTSxPQUFPLEdBQUcsRUFBaEI7QUFFQSxVQUFNLFNBQVMsR0FBRyxXQUFXLENBQUMsVUFBWixDQUF3QixLQUFLLElBQTdCLENBQWxCOztBQUVBLFVBQUssU0FBUyxDQUFDLGVBQVYsS0FBOEIsU0FBbkMsRUFBK0M7QUFFOUMsUUFBQSxjQUFjLENBQUMsU0FBZixHQUEyQixTQUFTLENBQUMsZUFBckM7QUFFQTs7QUFFRCxVQUFLLFNBQVMsQ0FBQyxnQkFBVixLQUErQixTQUFwQyxFQUFnRDtBQUUvQyxRQUFBLE9BQU8sQ0FBQyxJQUFSLENBQWMsTUFBTSxDQUFDLGFBQVAsQ0FBc0IsY0FBdEIsRUFBc0MsY0FBdEMsRUFBc0QsU0FBUyxDQUFDLGdCQUFoRSxDQUFkO0FBRUE7O0FBRUQsVUFBSyxTQUFTLENBQUMsd0JBQVYsS0FBdUMsU0FBNUMsRUFBd0Q7QUFFdkQsUUFBQSxjQUFjLENBQUMsa0JBQWYsR0FBb0MsU0FBUyxDQUFDLHdCQUE5QztBQUVBOztBQUVELFVBQUssU0FBUyxDQUFDLHlCQUFWLEtBQXdDLFNBQTdDLEVBQXlEO0FBRXhELFFBQUEsT0FBTyxDQUFDLElBQVIsQ0FBYyxNQUFNLENBQUMsYUFBUCxDQUFzQixjQUF0QixFQUFzQyx1QkFBdEMsRUFBK0QsU0FBUyxDQUFDLHlCQUF6RSxDQUFkO0FBRUE7O0FBRUQsVUFBSyxTQUFTLENBQUMsc0JBQVYsS0FBcUMsU0FBMUMsRUFBc0Q7QUFFckQsUUFBQSxPQUFPLENBQUMsSUFBUixDQUFjLE1BQU0sQ0FBQyxhQUFQLENBQXNCLGNBQXRCLEVBQXNDLG9CQUF0QyxFQUE0RCxTQUFTLENBQUMsc0JBQXRFLENBQWQ7O0FBRUEsWUFBSyxTQUFTLENBQUMsc0JBQVYsQ0FBaUMsS0FBakMsS0FBMkMsU0FBaEQsRUFBNEQ7QUFFM0QsY0FBTSxLQUFLLEdBQUcsU0FBUyxDQUFDLHNCQUFWLENBQWlDLEtBQS9DO0FBRUEsVUFBQSxjQUFjLENBQUMsb0JBQWYsR0FBc0MsSUFBSSxjQUFKLENBQWEsS0FBYixFQUFvQixLQUFwQixDQUF0QztBQUVBO0FBRUQ7O0FBRUQsYUFBTyxPQUFPLENBQUMsR0FBUixDQUFhLE9BQWIsQ0FBUDtBQUVBOzs7OztJQVNJLDJCO0FBRUwsdUNBQWEsTUFBYixFQUFzQjtBQUFBO0FBRXJCLFNBQUssTUFBTCxHQUFjLE1BQWQ7QUFDQSxTQUFLLElBQUwsR0FBWSxVQUFVLENBQUMsbUJBQXZCO0FBRUE7Ozs7V0FFRCx5QkFBaUIsYUFBakIsRUFBaUM7QUFFaEMsVUFBTSxNQUFNLEdBQUcsS0FBSyxNQUFwQjtBQUNBLFVBQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxJQUFQLENBQVksU0FBWixDQUF1QixhQUF2QixDQUFwQjtBQUVBLFVBQUssQ0FBRSxXQUFXLENBQUMsVUFBZCxJQUE0QixDQUFFLFdBQVcsQ0FBQyxVQUFaLENBQXdCLEtBQUssSUFBN0IsQ0FBbkMsRUFBeUUsT0FBTyxJQUFQO0FBRXpFLGFBQU8sMkJBQVA7QUFFQTs7O1dBRUQsOEJBQXNCLGFBQXRCLEVBQXFDLGNBQXJDLEVBQXNEO0FBRXJELFVBQU0sTUFBTSxHQUFHLEtBQUssTUFBcEI7QUFDQSxVQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsSUFBUCxDQUFZLFNBQVosQ0FBdUIsYUFBdkIsQ0FBcEI7O0FBRUEsVUFBSyxDQUFFLFdBQVcsQ0FBQyxVQUFkLElBQTRCLENBQUUsV0FBVyxDQUFDLFVBQVosQ0FBd0IsS0FBSyxJQUE3QixDQUFuQyxFQUF5RTtBQUV4RSxlQUFPLE9BQU8sQ0FBQyxPQUFSLEVBQVA7QUFFQTs7QUFFRCxVQUFNLE9BQU8sR0FBRyxFQUFoQjtBQUVBLE1BQUEsY0FBYyxDQUFDLFVBQWYsR0FBNEIsSUFBSSxZQUFKLENBQVcsQ0FBWCxFQUFjLENBQWQsRUFBaUIsQ0FBakIsQ0FBNUI7QUFDQSxNQUFBLGNBQWMsQ0FBQyxjQUFmLEdBQWdDLENBQWhDO0FBQ0EsTUFBQSxjQUFjLENBQUMsS0FBZixHQUF1QixDQUF2QjtBQUVBLFVBQU0sU0FBUyxHQUFHLFdBQVcsQ0FBQyxVQUFaLENBQXdCLEtBQUssSUFBN0IsQ0FBbEI7O0FBRUEsVUFBSyxTQUFTLENBQUMsZ0JBQVYsS0FBK0IsU0FBcEMsRUFBZ0Q7QUFFL0MsUUFBQSxjQUFjLENBQUMsVUFBZixDQUEwQixTQUExQixDQUFxQyxTQUFTLENBQUMsZ0JBQS9DO0FBRUE7O0FBRUQsVUFBSyxTQUFTLENBQUMsb0JBQVYsS0FBbUMsU0FBeEMsRUFBb0Q7QUFFbkQsUUFBQSxjQUFjLENBQUMsY0FBZixHQUFnQyxTQUFTLENBQUMsb0JBQTFDO0FBRUE7O0FBRUQsVUFBSyxTQUFTLENBQUMsaUJBQVYsS0FBZ0MsU0FBckMsRUFBaUQ7QUFFaEQsUUFBQSxPQUFPLENBQUMsSUFBUixDQUFjLE1BQU0sQ0FBQyxhQUFQLENBQXNCLGNBQXRCLEVBQXNDLGVBQXRDLEVBQXVELFNBQVMsQ0FBQyxpQkFBakUsQ0FBZDtBQUVBOztBQUVELFVBQUssU0FBUyxDQUFDLHFCQUFWLEtBQW9DLFNBQXpDLEVBQXFEO0FBRXBELFFBQUEsT0FBTyxDQUFDLElBQVIsQ0FBYyxNQUFNLENBQUMsYUFBUCxDQUFzQixjQUF0QixFQUFzQyxtQkFBdEMsRUFBMkQsU0FBUyxDQUFDLHFCQUFyRSxDQUFkO0FBRUE7O0FBRUQsYUFBTyxPQUFPLENBQUMsR0FBUixDQUFhLE9BQWIsQ0FBUDtBQUVBOzs7OztJQVVJLGtDO0FBRUwsOENBQWEsTUFBYixFQUFzQjtBQUFBO0FBRXJCLFNBQUssTUFBTCxHQUFjLE1BQWQ7QUFDQSxTQUFLLElBQUwsR0FBWSxVQUFVLENBQUMsMEJBQXZCO0FBRUE7Ozs7V0FFRCx5QkFBaUIsYUFBakIsRUFBaUM7QUFFaEMsVUFBTSxNQUFNLEdBQUcsS0FBSyxNQUFwQjtBQUNBLFVBQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxJQUFQLENBQVksU0FBWixDQUF1QixhQUF2QixDQUFwQjtBQUVBLFVBQUssQ0FBRSxXQUFXLENBQUMsVUFBZCxJQUE0QixDQUFFLFdBQVcsQ0FBQyxVQUFaLENBQXdCLEtBQUssSUFBN0IsQ0FBbkMsRUFBeUUsT0FBTyxJQUFQO0FBRXpFLGFBQU8sMkJBQVA7QUFFQTs7O1dBRUQsOEJBQXNCLGFBQXRCLEVBQXFDLGNBQXJDLEVBQXNEO0FBRXJELFVBQU0sTUFBTSxHQUFHLEtBQUssTUFBcEI7QUFDQSxVQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsSUFBUCxDQUFZLFNBQVosQ0FBdUIsYUFBdkIsQ0FBcEI7O0FBRUEsVUFBSyxDQUFFLFdBQVcsQ0FBQyxVQUFkLElBQTRCLENBQUUsV0FBVyxDQUFDLFVBQVosQ0FBd0IsS0FBSyxJQUE3QixDQUFuQyxFQUF5RTtBQUV4RSxlQUFPLE9BQU8sQ0FBQyxPQUFSLEVBQVA7QUFFQTs7QUFFRCxVQUFNLE9BQU8sR0FBRyxFQUFoQjtBQUVBLFVBQU0sU0FBUyxHQUFHLFdBQVcsQ0FBQyxVQUFaLENBQXdCLEtBQUssSUFBN0IsQ0FBbEI7O0FBRUEsVUFBSyxTQUFTLENBQUMsa0JBQVYsS0FBaUMsU0FBdEMsRUFBa0Q7QUFFakQsUUFBQSxjQUFjLENBQUMsWUFBZixHQUE4QixTQUFTLENBQUMsa0JBQXhDO0FBRUE7O0FBRUQsVUFBSyxTQUFTLENBQUMsbUJBQVYsS0FBa0MsU0FBdkMsRUFBbUQ7QUFFbEQsUUFBQSxPQUFPLENBQUMsSUFBUixDQUFjLE1BQU0sQ0FBQyxhQUFQLENBQXNCLGNBQXRCLEVBQXNDLGlCQUF0QyxFQUF5RCxTQUFTLENBQUMsbUJBQW5FLENBQWQ7QUFFQTs7QUFFRCxhQUFPLE9BQU8sQ0FBQyxHQUFSLENBQWEsT0FBYixDQUFQO0FBRUE7Ozs7O0lBU0ksNEI7QUFFTCx3Q0FBYSxNQUFiLEVBQXNCO0FBQUE7QUFFckIsU0FBSyxNQUFMLEdBQWMsTUFBZDtBQUNBLFNBQUssSUFBTCxHQUFZLFVBQVUsQ0FBQyxvQkFBdkI7QUFFQTs7OztXQUVELHlCQUFpQixhQUFqQixFQUFpQztBQUVoQyxVQUFNLE1BQU0sR0FBRyxLQUFLLE1BQXBCO0FBQ0EsVUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLElBQVAsQ0FBWSxTQUFaLENBQXVCLGFBQXZCLENBQXBCO0FBRUEsVUFBSyxDQUFFLFdBQVcsQ0FBQyxVQUFkLElBQTRCLENBQUUsV0FBVyxDQUFDLFVBQVosQ0FBd0IsS0FBSyxJQUE3QixDQUFuQyxFQUF5RSxPQUFPLElBQVA7QUFFekUsYUFBTywyQkFBUDtBQUVBOzs7V0FFRCw4QkFBc0IsYUFBdEIsRUFBcUMsY0FBckMsRUFBc0Q7QUFFckQsVUFBTSxNQUFNLEdBQUcsS0FBSyxNQUFwQjtBQUNBLFVBQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxJQUFQLENBQVksU0FBWixDQUF1QixhQUF2QixDQUFwQjs7QUFFQSxVQUFLLENBQUUsV0FBVyxDQUFDLFVBQWQsSUFBNEIsQ0FBRSxXQUFXLENBQUMsVUFBWixDQUF3QixLQUFLLElBQTdCLENBQW5DLEVBQXlFO0FBRXhFLGVBQU8sT0FBTyxDQUFDLE9BQVIsRUFBUDtBQUVBOztBQUVELFVBQU0sT0FBTyxHQUFHLEVBQWhCO0FBRUEsVUFBTSxTQUFTLEdBQUcsV0FBVyxDQUFDLFVBQVosQ0FBd0IsS0FBSyxJQUE3QixDQUFsQjtBQUVBLE1BQUEsY0FBYyxDQUFDLFNBQWYsR0FBMkIsU0FBUyxDQUFDLGVBQVYsS0FBOEIsU0FBOUIsR0FBMEMsU0FBUyxDQUFDLGVBQXBELEdBQXNFLENBQWpHOztBQUVBLFVBQUssU0FBUyxDQUFDLGdCQUFWLEtBQStCLFNBQXBDLEVBQWdEO0FBRS9DLFFBQUEsT0FBTyxDQUFDLElBQVIsQ0FBYyxNQUFNLENBQUMsYUFBUCxDQUFzQixjQUF0QixFQUFzQyxjQUF0QyxFQUFzRCxTQUFTLENBQUMsZ0JBQWhFLENBQWQ7QUFFQTs7QUFFRCxNQUFBLGNBQWMsQ0FBQyxtQkFBZixHQUFxQyxTQUFTLENBQUMsbUJBQVYsSUFBaUMsQ0FBdEU7QUFFQSxVQUFNLFVBQVUsR0FBRyxTQUFTLENBQUMsZ0JBQVYsSUFBOEIsQ0FBRSxDQUFGLEVBQUssQ0FBTCxFQUFRLENBQVIsQ0FBakQ7QUFDQSxNQUFBLGNBQWMsQ0FBQyxnQkFBZixHQUFrQyxJQUFJLFlBQUosQ0FBVyxVQUFVLENBQUUsQ0FBRixDQUFyQixFQUE0QixVQUFVLENBQUUsQ0FBRixDQUF0QyxFQUE2QyxVQUFVLENBQUUsQ0FBRixDQUF2RCxDQUFsQztBQUVBLGFBQU8sT0FBTyxDQUFDLEdBQVIsQ0FBYSxPQUFiLENBQVA7QUFFQTs7Ozs7SUFTSSx5QjtBQUVMLHFDQUFhLE1BQWIsRUFBc0I7QUFBQTtBQUVyQixTQUFLLE1BQUwsR0FBYyxNQUFkO0FBQ0EsU0FBSyxJQUFMLEdBQVksVUFBVSxDQUFDLGlCQUF2QjtBQUVBOzs7O1dBRUQseUJBQWlCLGFBQWpCLEVBQWlDO0FBRWhDLFVBQU0sTUFBTSxHQUFHLEtBQUssTUFBcEI7QUFDQSxVQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsSUFBUCxDQUFZLFNBQVosQ0FBdUIsYUFBdkIsQ0FBcEI7QUFFQSxVQUFLLENBQUUsV0FBVyxDQUFDLFVBQWQsSUFBNEIsQ0FBRSxXQUFXLENBQUMsVUFBWixDQUF3QixLQUFLLElBQTdCLENBQW5DLEVBQXlFLE9BQU8sSUFBUDtBQUV6RSxhQUFPLDJCQUFQO0FBRUE7OztXQUVELDhCQUFzQixhQUF0QixFQUFxQyxjQUFyQyxFQUFzRDtBQUVyRCxVQUFNLE1BQU0sR0FBRyxLQUFLLE1BQXBCO0FBQ0EsVUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLElBQVAsQ0FBWSxTQUFaLENBQXVCLGFBQXZCLENBQXBCOztBQUVBLFVBQUssQ0FBRSxXQUFXLENBQUMsVUFBZCxJQUE0QixDQUFFLFdBQVcsQ0FBQyxVQUFaLENBQXdCLEtBQUssSUFBN0IsQ0FBbkMsRUFBeUU7QUFFeEUsZUFBTyxPQUFPLENBQUMsT0FBUixFQUFQO0FBRUE7O0FBRUQsVUFBTSxTQUFTLEdBQUcsV0FBVyxDQUFDLFVBQVosQ0FBd0IsS0FBSyxJQUE3QixDQUFsQjtBQUVBLE1BQUEsY0FBYyxDQUFDLEdBQWYsR0FBcUIsU0FBUyxDQUFDLEdBQVYsS0FBa0IsU0FBbEIsR0FBOEIsU0FBUyxDQUFDLEdBQXhDLEdBQThDLEdBQW5FO0FBRUEsYUFBTyxPQUFPLENBQUMsT0FBUixFQUFQO0FBRUE7Ozs7O0lBU0ksOEI7QUFFTCwwQ0FBYSxNQUFiLEVBQXNCO0FBQUE7QUFFckIsU0FBSyxNQUFMLEdBQWMsTUFBZDtBQUNBLFNBQUssSUFBTCxHQUFZLFVBQVUsQ0FBQyxzQkFBdkI7QUFFQTs7OztXQUVELHlCQUFpQixhQUFqQixFQUFpQztBQUVoQyxVQUFNLE1BQU0sR0FBRyxLQUFLLE1BQXBCO0FBQ0EsVUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLElBQVAsQ0FBWSxTQUFaLENBQXVCLGFBQXZCLENBQXBCO0FBRUEsVUFBSyxDQUFFLFdBQVcsQ0FBQyxVQUFkLElBQTRCLENBQUUsV0FBVyxDQUFDLFVBQVosQ0FBd0IsS0FBSyxJQUE3QixDQUFuQyxFQUF5RSxPQUFPLElBQVA7QUFFekUsYUFBTywyQkFBUDtBQUVBOzs7V0FFRCw4QkFBc0IsYUFBdEIsRUFBcUMsY0FBckMsRUFBc0Q7QUFFckQsVUFBTSxNQUFNLEdBQUcsS0FBSyxNQUFwQjtBQUNBLFVBQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxJQUFQLENBQVksU0FBWixDQUF1QixhQUF2QixDQUFwQjs7QUFFQSxVQUFLLENBQUUsV0FBVyxDQUFDLFVBQWQsSUFBNEIsQ0FBRSxXQUFXLENBQUMsVUFBWixDQUF3QixLQUFLLElBQTdCLENBQW5DLEVBQXlFO0FBRXhFLGVBQU8sT0FBTyxDQUFDLE9BQVIsRUFBUDtBQUVBOztBQUVELFVBQU0sT0FBTyxHQUFHLEVBQWhCO0FBRUEsVUFBTSxTQUFTLEdBQUcsV0FBVyxDQUFDLFVBQVosQ0FBd0IsS0FBSyxJQUE3QixDQUFsQjtBQUVBLE1BQUEsY0FBYyxDQUFDLGlCQUFmLEdBQW1DLFNBQVMsQ0FBQyxjQUFWLEtBQTZCLFNBQTdCLEdBQXlDLFNBQVMsQ0FBQyxjQUFuRCxHQUFvRSxHQUF2Rzs7QUFFQSxVQUFLLFNBQVMsQ0FBQyxlQUFWLEtBQThCLFNBQW5DLEVBQStDO0FBRTlDLFFBQUEsT0FBTyxDQUFDLElBQVIsQ0FBYyxNQUFNLENBQUMsYUFBUCxDQUFzQixjQUF0QixFQUFzQyxzQkFBdEMsRUFBOEQsU0FBUyxDQUFDLGVBQXhFLENBQWQ7QUFFQTs7QUFFRCxVQUFNLFVBQVUsR0FBRyxTQUFTLENBQUMsbUJBQVYsSUFBaUMsQ0FBRSxDQUFGLEVBQUssQ0FBTCxFQUFRLENBQVIsQ0FBcEQ7QUFDQSxNQUFBLGNBQWMsQ0FBQyxhQUFmLEdBQStCLElBQUksWUFBSixDQUFXLFVBQVUsQ0FBRSxDQUFGLENBQXJCLEVBQTRCLFVBQVUsQ0FBRSxDQUFGLENBQXRDLEVBQTZDLFVBQVUsQ0FBRSxDQUFGLENBQXZELENBQS9COztBQUVBLFVBQUssU0FBUyxDQUFDLG9CQUFWLEtBQW1DLFNBQXhDLEVBQW9EO0FBRW5ELFFBQUEsT0FBTyxDQUFDLElBQVIsQ0FBYyxNQUFNLENBQUMsYUFBUCxDQUFzQixjQUF0QixFQUFzQyxrQkFBdEMsRUFBMEQsU0FBUyxDQUFDLG9CQUFwRSxFQUEyRixJQUEzRixDQUFpRyxVQUFXLE9BQVgsRUFBcUI7QUFFbkksVUFBQSxPQUFPLENBQUMsUUFBUixHQUFtQixtQkFBbkI7QUFFQSxTQUphLENBQWQ7QUFNQTs7QUFFRCxhQUFPLE9BQU8sQ0FBQyxHQUFSLENBQWEsT0FBYixDQUFQO0FBRUE7Ozs7O0lBU0ksMEI7QUFFTCxzQ0FBYSxNQUFiLEVBQXNCO0FBQUE7QUFFckIsU0FBSyxNQUFMLEdBQWMsTUFBZDtBQUNBLFNBQUssSUFBTCxHQUFZLFVBQVUsQ0FBQyxrQkFBdkI7QUFFQTs7OztXQUVELHFCQUFhLFlBQWIsRUFBNEI7QUFFM0IsVUFBTSxNQUFNLEdBQUcsS0FBSyxNQUFwQjtBQUNBLFVBQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFwQjtBQUVBLFVBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxRQUFMLENBQWUsWUFBZixDQUFuQjs7QUFFQSxVQUFLLENBQUUsVUFBVSxDQUFDLFVBQWIsSUFBMkIsQ0FBRSxVQUFVLENBQUMsVUFBWCxDQUF1QixLQUFLLElBQTVCLENBQWxDLEVBQXVFO0FBRXRFLGVBQU8sSUFBUDtBQUVBOztBQUVELFVBQU0sU0FBUyxHQUFHLFVBQVUsQ0FBQyxVQUFYLENBQXVCLEtBQUssSUFBNUIsQ0FBbEI7QUFDQSxVQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTCxDQUFhLFNBQVMsQ0FBQyxNQUF2QixDQUFmO0FBQ0EsVUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLE9BQVAsQ0FBZSxVQUE5Qjs7QUFFQSxVQUFLLENBQUUsTUFBUCxFQUFnQjtBQUVmLFlBQUssSUFBSSxDQUFDLGtCQUFMLElBQTJCLElBQUksQ0FBQyxrQkFBTCxDQUF3QixPQUF4QixDQUFpQyxLQUFLLElBQXRDLEtBQWdELENBQWhGLEVBQW9GO0FBRW5GLGdCQUFNLElBQUksS0FBSixDQUFXLDZFQUFYLENBQU47QUFFQSxTQUpELE1BSU87QUFHTixpQkFBTyxJQUFQO0FBRUE7QUFFRDs7QUFFRCxhQUFPLE1BQU0sQ0FBQyxnQkFBUCxDQUF5QixZQUF6QixFQUF1QyxNQUF2QyxFQUErQyxNQUEvQyxDQUFQO0FBRUE7Ozs7O0lBU0ksd0I7QUFFTCxvQ0FBYSxNQUFiLEVBQXNCO0FBQUE7QUFFckIsU0FBSyxNQUFMLEdBQWMsTUFBZDtBQUNBLFNBQUssSUFBTCxHQUFZLFVBQVUsQ0FBQyxnQkFBdkI7QUFDQSxTQUFLLFdBQUwsR0FBbUIsSUFBbkI7QUFFQTs7OztXQUVELHFCQUFhLFlBQWIsRUFBNEI7QUFFM0IsVUFBTSxJQUFJLEdBQUcsS0FBSyxJQUFsQjtBQUNBLFVBQU0sTUFBTSxHQUFHLEtBQUssTUFBcEI7QUFDQSxVQUFNLElBQUksR0FBRyxNQUFNLENBQUMsSUFBcEI7QUFFQSxVQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsUUFBTCxDQUFlLFlBQWYsQ0FBbkI7O0FBRUEsVUFBSyxDQUFFLFVBQVUsQ0FBQyxVQUFiLElBQTJCLENBQUUsVUFBVSxDQUFDLFVBQVgsQ0FBdUIsSUFBdkIsQ0FBbEMsRUFBa0U7QUFFakUsZUFBTyxJQUFQO0FBRUE7O0FBRUQsVUFBTSxTQUFTLEdBQUcsVUFBVSxDQUFDLFVBQVgsQ0FBdUIsSUFBdkIsQ0FBbEI7QUFDQSxVQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTCxDQUFhLFNBQVMsQ0FBQyxNQUF2QixDQUFmO0FBRUEsVUFBSSxNQUFNLEdBQUcsTUFBTSxDQUFDLGFBQXBCOztBQUNBLFVBQUssTUFBTSxDQUFDLEdBQVosRUFBa0I7QUFFakIsWUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLE9BQVAsQ0FBZSxPQUFmLENBQXVCLFVBQXZCLENBQW1DLE1BQU0sQ0FBQyxHQUExQyxDQUFoQjtBQUNBLFlBQUssT0FBTyxLQUFLLElBQWpCLEVBQXdCLE1BQU0sR0FBRyxPQUFUO0FBRXhCOztBQUVELGFBQU8sS0FBSyxhQUFMLEdBQXFCLElBQXJCLENBQTJCLFVBQVcsV0FBWCxFQUF5QjtBQUUxRCxZQUFLLFdBQUwsRUFBbUIsT0FBTyxNQUFNLENBQUMsZ0JBQVAsQ0FBeUIsWUFBekIsRUFBdUMsTUFBdkMsRUFBK0MsTUFBL0MsQ0FBUDs7QUFFbkIsWUFBSyxJQUFJLENBQUMsa0JBQUwsSUFBMkIsSUFBSSxDQUFDLGtCQUFMLENBQXdCLE9BQXhCLENBQWlDLElBQWpDLEtBQTJDLENBQTNFLEVBQStFO0FBRTlFLGdCQUFNLElBQUksS0FBSixDQUFXLDJEQUFYLENBQU47QUFFQTs7QUFHRCxlQUFPLE1BQU0sQ0FBQyxXQUFQLENBQW9CLFlBQXBCLENBQVA7QUFFQSxPQWJNLENBQVA7QUFlQTs7O1dBRUQseUJBQWdCO0FBRWYsVUFBSyxDQUFFLEtBQUssV0FBWixFQUEwQjtBQUV6QixhQUFLLFdBQUwsR0FBbUIsSUFBSSxPQUFKLENBQWEsVUFBVyxPQUFYLEVBQXFCO0FBRXBELGNBQU0sS0FBSyxHQUFHLElBQUksS0FBSixFQUFkO0FBSUEsVUFBQSxLQUFLLENBQUMsR0FBTixHQUFZLGlGQUFaOztBQUVBLFVBQUEsS0FBSyxDQUFDLE1BQU4sR0FBZSxLQUFLLENBQUMsT0FBTixHQUFnQixZQUFZO0FBRTFDLFlBQUEsT0FBTyxDQUFFLEtBQUssQ0FBQyxNQUFOLEtBQWlCLENBQW5CLENBQVA7QUFFQSxXQUpEO0FBTUEsU0Fka0IsQ0FBbkI7QUFnQkE7O0FBRUQsYUFBTyxLQUFLLFdBQVo7QUFFQTs7Ozs7SUFTSSxzQjtBQUVMLGtDQUFhLE1BQWIsRUFBc0I7QUFBQTtBQUVyQixTQUFLLElBQUwsR0FBWSxVQUFVLENBQUMsdUJBQXZCO0FBQ0EsU0FBSyxNQUFMLEdBQWMsTUFBZDtBQUVBOzs7O1dBRUQsd0JBQWdCLEtBQWhCLEVBQXdCO0FBRXZCLFVBQU0sSUFBSSxHQUFHLEtBQUssTUFBTCxDQUFZLElBQXpCO0FBQ0EsVUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFdBQUwsQ0FBa0IsS0FBbEIsQ0FBbkI7O0FBRUEsVUFBSyxVQUFVLENBQUMsVUFBWCxJQUF5QixVQUFVLENBQUMsVUFBWCxDQUF1QixLQUFLLElBQTVCLENBQTlCLEVBQW1FO0FBRWxFLFlBQU0sWUFBWSxHQUFHLFVBQVUsQ0FBQyxVQUFYLENBQXVCLEtBQUssSUFBNUIsQ0FBckI7QUFFQSxZQUFNLE1BQU0sR0FBRyxLQUFLLE1BQUwsQ0FBWSxhQUFaLENBQTJCLFFBQTNCLEVBQXFDLFlBQVksQ0FBQyxNQUFsRCxDQUFmO0FBQ0EsWUFBTSxPQUFPLEdBQUcsS0FBSyxNQUFMLENBQVksT0FBWixDQUFvQixjQUFwQzs7QUFFQSxZQUFLLENBQUUsT0FBRixJQUFhLENBQUUsT0FBTyxDQUFDLFNBQTVCLEVBQXdDO0FBRXZDLGNBQUssSUFBSSxDQUFDLGtCQUFMLElBQTJCLElBQUksQ0FBQyxrQkFBTCxDQUF3QixPQUF4QixDQUFpQyxLQUFLLElBQXRDLEtBQWdELENBQWhGLEVBQW9GO0FBRW5GLGtCQUFNLElBQUksS0FBSixDQUFXLG9GQUFYLENBQU47QUFFQSxXQUpELE1BSU87QUFHTixtQkFBTyxJQUFQO0FBRUE7QUFFRDs7QUFFRCxlQUFPLE9BQU8sQ0FBQyxHQUFSLENBQWEsQ0FBRSxNQUFGLEVBQVUsT0FBTyxDQUFDLEtBQWxCLENBQWIsRUFBeUMsSUFBekMsQ0FBK0MsVUFBVyxHQUFYLEVBQWlCO0FBRXRFLGNBQU0sVUFBVSxHQUFHLFlBQVksQ0FBQyxVQUFiLElBQTJCLENBQTlDO0FBQ0EsY0FBTSxVQUFVLEdBQUcsWUFBWSxDQUFDLFVBQWIsSUFBMkIsQ0FBOUM7QUFFQSxjQUFNLEtBQUssR0FBRyxZQUFZLENBQUMsS0FBM0I7QUFDQSxjQUFNLE1BQU0sR0FBRyxZQUFZLENBQUMsVUFBNUI7QUFFQSxjQUFNLE1BQU0sR0FBRyxJQUFJLFdBQUosQ0FBaUIsS0FBSyxHQUFHLE1BQXpCLENBQWY7QUFDQSxjQUFNLE1BQU0sR0FBRyxJQUFJLFVBQUosQ0FBZ0IsR0FBRyxDQUFFLENBQUYsQ0FBbkIsRUFBMEIsVUFBMUIsRUFBc0MsVUFBdEMsQ0FBZjtBQUVBLFVBQUEsT0FBTyxDQUFDLGdCQUFSLENBQTBCLElBQUksVUFBSixDQUFnQixNQUFoQixDQUExQixFQUFvRCxLQUFwRCxFQUEyRCxNQUEzRCxFQUFtRSxNQUFuRSxFQUEyRSxZQUFZLENBQUMsSUFBeEYsRUFBOEYsWUFBWSxDQUFDLE1BQTNHO0FBQ0EsaUJBQU8sTUFBUDtBQUVBLFNBZE0sQ0FBUDtBQWdCQSxPQXRDRCxNQXNDTztBQUVOLGVBQU8sSUFBUDtBQUVBO0FBRUQ7Ozs7O0FBS0YsSUFBTSw2QkFBNkIsR0FBRyxNQUF0QztBQUNBLElBQU0sOEJBQThCLEdBQUcsRUFBdkM7QUFDQSxJQUFNLDRCQUE0QixHQUFHO0FBQUUsRUFBQSxJQUFJLEVBQUUsVUFBUjtBQUFvQixFQUFBLEdBQUcsRUFBRTtBQUF6QixDQUFyQztJQUVNLG1CLGlDQUVMLDZCQUFhLElBQWIsRUFBb0I7QUFBQTtBQUVuQixPQUFLLElBQUwsR0FBWSxVQUFVLENBQUMsZUFBdkI7QUFDQSxPQUFLLE9BQUwsR0FBZSxJQUFmO0FBQ0EsT0FBSyxJQUFMLEdBQVksSUFBWjtBQUVBLE1BQU0sVUFBVSxHQUFHLElBQUksUUFBSixDQUFjLElBQWQsRUFBb0IsQ0FBcEIsRUFBdUIsOEJBQXZCLENBQW5CO0FBRUEsT0FBSyxNQUFMLEdBQWM7QUFDYixJQUFBLEtBQUssRUFBRSxtQkFBWSxVQUFaLENBQXdCLElBQUksVUFBSixDQUFnQixJQUFJLENBQUMsS0FBTCxDQUFZLENBQVosRUFBZSxDQUFmLENBQWhCLENBQXhCLENBRE07QUFFYixJQUFBLE9BQU8sRUFBRSxVQUFVLENBQUMsU0FBWCxDQUFzQixDQUF0QixFQUF5QixJQUF6QixDQUZJO0FBR2IsSUFBQSxNQUFNLEVBQUUsVUFBVSxDQUFDLFNBQVgsQ0FBc0IsQ0FBdEIsRUFBeUIsSUFBekI7QUFISyxHQUFkOztBQU1BLE1BQUssS0FBSyxNQUFMLENBQVksS0FBWixLQUFzQiw2QkFBM0IsRUFBMkQ7QUFFMUQsVUFBTSxJQUFJLEtBQUosQ0FBVyxtREFBWCxDQUFOO0FBRUEsR0FKRCxNQUlPLElBQUssS0FBSyxNQUFMLENBQVksT0FBWixHQUFzQixHQUEzQixFQUFpQztBQUV2QyxVQUFNLElBQUksS0FBSixDQUFXLGdEQUFYLENBQU47QUFFQTs7QUFFRCxNQUFNLG1CQUFtQixHQUFHLEtBQUssTUFBTCxDQUFZLE1BQVosR0FBcUIsOEJBQWpEO0FBQ0EsTUFBTSxTQUFTLEdBQUcsSUFBSSxRQUFKLENBQWMsSUFBZCxFQUFvQiw4QkFBcEIsQ0FBbEI7QUFDQSxNQUFJLFVBQVUsR0FBRyxDQUFqQjs7QUFFQSxTQUFRLFVBQVUsR0FBRyxtQkFBckIsRUFBMkM7QUFFMUMsUUFBTSxXQUFXLEdBQUcsU0FBUyxDQUFDLFNBQVYsQ0FBcUIsVUFBckIsRUFBaUMsSUFBakMsQ0FBcEI7QUFDQSxJQUFBLFVBQVUsSUFBSSxDQUFkO0FBRUEsUUFBTSxTQUFTLEdBQUcsU0FBUyxDQUFDLFNBQVYsQ0FBcUIsVUFBckIsRUFBaUMsSUFBakMsQ0FBbEI7QUFDQSxJQUFBLFVBQVUsSUFBSSxDQUFkOztBQUVBLFFBQUssU0FBUyxLQUFLLDRCQUE0QixDQUFDLElBQWhELEVBQXVEO0FBRXRELFVBQU0sWUFBWSxHQUFHLElBQUksVUFBSixDQUFnQixJQUFoQixFQUFzQiw4QkFBOEIsR0FBRyxVQUF2RCxFQUFtRSxXQUFuRSxDQUFyQjtBQUNBLFdBQUssT0FBTCxHQUFlLG1CQUFZLFVBQVosQ0FBd0IsWUFBeEIsQ0FBZjtBQUVBLEtBTEQsTUFLTyxJQUFLLFNBQVMsS0FBSyw0QkFBNEIsQ0FBQyxHQUFoRCxFQUFzRDtBQUU1RCxVQUFNLFVBQVUsR0FBRyw4QkFBOEIsR0FBRyxVQUFwRDtBQUNBLFdBQUssSUFBTCxHQUFZLElBQUksQ0FBQyxLQUFMLENBQVksVUFBWixFQUF3QixVQUFVLEdBQUcsV0FBckMsQ0FBWjtBQUVBOztBQUlELElBQUEsVUFBVSxJQUFJLFdBQWQ7QUFFQTs7QUFFRCxNQUFLLEtBQUssT0FBTCxLQUFpQixJQUF0QixFQUE2QjtBQUU1QixVQUFNLElBQUksS0FBSixDQUFXLDJDQUFYLENBQU47QUFFQTtBQUVELEM7O0lBU0ksaUM7QUFFTCw2Q0FBYSxJQUFiLEVBQW1CLFdBQW5CLEVBQWlDO0FBQUE7O0FBRWhDLFFBQUssQ0FBRSxXQUFQLEVBQXFCO0FBRXBCLFlBQU0sSUFBSSxLQUFKLENBQVcscURBQVgsQ0FBTjtBQUVBOztBQUVELFNBQUssSUFBTCxHQUFZLFVBQVUsQ0FBQywwQkFBdkI7QUFDQSxTQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0EsU0FBSyxXQUFMLEdBQW1CLFdBQW5CO0FBQ0EsU0FBSyxXQUFMLENBQWlCLE9BQWpCO0FBRUE7Ozs7V0FFRCx5QkFBaUIsU0FBakIsRUFBNEIsTUFBNUIsRUFBcUM7QUFFcEMsVUFBTSxJQUFJLEdBQUcsS0FBSyxJQUFsQjtBQUNBLFVBQU0sV0FBVyxHQUFHLEtBQUssV0FBekI7QUFDQSxVQUFNLGVBQWUsR0FBRyxTQUFTLENBQUMsVUFBVixDQUFzQixLQUFLLElBQTNCLEVBQWtDLFVBQTFEO0FBQ0EsVUFBTSxnQkFBZ0IsR0FBRyxTQUFTLENBQUMsVUFBVixDQUFzQixLQUFLLElBQTNCLEVBQWtDLFVBQTNEO0FBQ0EsVUFBTSxpQkFBaUIsR0FBRyxFQUExQjtBQUNBLFVBQU0sc0JBQXNCLEdBQUcsRUFBL0I7QUFDQSxVQUFNLGdCQUFnQixHQUFHLEVBQXpCOztBQUVBLFdBQU0sSUFBTSxhQUFaLElBQTZCLGdCQUE3QixFQUFnRDtBQUUvQyxZQUFNLGtCQUFrQixHQUFHLFVBQVUsQ0FBRSxhQUFGLENBQVYsSUFBK0IsYUFBYSxDQUFDLFdBQWQsRUFBMUQ7QUFFQSxRQUFBLGlCQUFpQixDQUFFLGtCQUFGLENBQWpCLEdBQTBDLGdCQUFnQixDQUFFLGFBQUYsQ0FBMUQ7QUFFQTs7QUFFRCxXQUFNLElBQU0sY0FBWixJQUE2QixTQUFTLENBQUMsVUFBdkMsRUFBb0Q7QUFFbkQsWUFBTSxtQkFBa0IsR0FBRyxVQUFVLENBQUUsY0FBRixDQUFWLElBQStCLGNBQWEsQ0FBQyxXQUFkLEVBQTFEOztBQUVBLFlBQUssZ0JBQWdCLENBQUUsY0FBRixDQUFoQixLQUFzQyxTQUEzQyxFQUF1RDtBQUV0RCxjQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsU0FBTCxDQUFnQixTQUFTLENBQUMsVUFBVixDQUFzQixjQUF0QixDQUFoQixDQUFwQjtBQUNBLGNBQU0sYUFBYSxHQUFHLHFCQUFxQixDQUFFLFdBQVcsQ0FBQyxhQUFkLENBQTNDO0FBRUEsVUFBQSxnQkFBZ0IsQ0FBRSxtQkFBRixDQUFoQixHQUF5QyxhQUF6QztBQUNBLFVBQUEsc0JBQXNCLENBQUUsbUJBQUYsQ0FBdEIsR0FBK0MsV0FBVyxDQUFDLFVBQVosS0FBMkIsSUFBMUU7QUFFQTtBQUVEOztBQUVELGFBQU8sTUFBTSxDQUFDLGFBQVAsQ0FBc0IsWUFBdEIsRUFBb0MsZUFBcEMsRUFBc0QsSUFBdEQsQ0FBNEQsVUFBVyxVQUFYLEVBQXdCO0FBRTFGLGVBQU8sSUFBSSxPQUFKLENBQWEsVUFBVyxPQUFYLEVBQXFCO0FBRXhDLFVBQUEsV0FBVyxDQUFDLGVBQVosQ0FBNkIsVUFBN0IsRUFBeUMsVUFBVyxRQUFYLEVBQXNCO0FBRTlELGlCQUFNLElBQU0sZUFBWixJQUE2QixRQUFRLENBQUMsVUFBdEMsRUFBbUQ7QUFFbEQsa0JBQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxVQUFULENBQXFCLGVBQXJCLENBQWxCO0FBQ0Esa0JBQU0sVUFBVSxHQUFHLHNCQUFzQixDQUFFLGVBQUYsQ0FBekM7QUFFQSxrQkFBSyxVQUFVLEtBQUssU0FBcEIsRUFBZ0MsU0FBUyxDQUFDLFVBQVYsR0FBdUIsVUFBdkI7QUFFaEM7O0FBRUQsWUFBQSxPQUFPLENBQUUsUUFBRixDQUFQO0FBRUEsV0FiRCxFQWFHLGlCQWJILEVBYXNCLGdCQWJ0QjtBQWVBLFNBakJNLENBQVA7QUFtQkEsT0FyQk0sQ0FBUDtBQXVCQTs7Ozs7SUFTSSw2QjtBQUVMLDJDQUFjO0FBQUE7QUFFYixTQUFLLElBQUwsR0FBWSxVQUFVLENBQUMscUJBQXZCO0FBRUE7Ozs7V0FFRCx1QkFBZSxPQUFmLEVBQXdCLFNBQXhCLEVBQW9DO0FBRW5DLFVBQUssU0FBUyxDQUFDLFFBQVYsS0FBdUIsU0FBNUIsRUFBd0M7QUFFdkMsUUFBQSxPQUFPLENBQUMsSUFBUixDQUFjLDBDQUEwQyxLQUFLLElBQS9DLEdBQXNELGdDQUFwRTtBQUVBOztBQUVELFVBQUssU0FBUyxDQUFDLE1BQVYsS0FBcUIsU0FBckIsSUFBa0MsU0FBUyxDQUFDLFFBQVYsS0FBdUIsU0FBekQsSUFBc0UsU0FBUyxDQUFDLEtBQVYsS0FBb0IsU0FBL0YsRUFBMkc7QUFHMUcsZUFBTyxPQUFQO0FBRUE7O0FBRUQsTUFBQSxPQUFPLEdBQUcsT0FBTyxDQUFDLEtBQVIsRUFBVjs7QUFFQSxVQUFLLFNBQVMsQ0FBQyxNQUFWLEtBQXFCLFNBQTFCLEVBQXNDO0FBRXJDLFFBQUEsT0FBTyxDQUFDLE1BQVIsQ0FBZSxTQUFmLENBQTBCLFNBQVMsQ0FBQyxNQUFwQztBQUVBOztBQUVELFVBQUssU0FBUyxDQUFDLFFBQVYsS0FBdUIsU0FBNUIsRUFBd0M7QUFFdkMsUUFBQSxPQUFPLENBQUMsUUFBUixHQUFtQixTQUFTLENBQUMsUUFBN0I7QUFFQTs7QUFFRCxVQUFLLFNBQVMsQ0FBQyxLQUFWLEtBQW9CLFNBQXpCLEVBQXFDO0FBRXBDLFFBQUEsT0FBTyxDQUFDLE1BQVIsQ0FBZSxTQUFmLENBQTBCLFNBQVMsQ0FBQyxLQUFwQztBQUVBOztBQUVELE1BQUEsT0FBTyxDQUFDLFdBQVIsR0FBc0IsSUFBdEI7QUFFQSxhQUFPLE9BQVA7QUFFQTs7Ozs7SUFlSSwwQjs7Ozs7QUFFTCxzQ0FBYSxNQUFiLEVBQXNCO0FBQUE7O0FBQUE7QUFFckI7QUFFQSxXQUFLLGdDQUFMLEdBQXdDLElBQXhDO0FBR0EsUUFBTSw0QkFBNEIsR0FBRyxDQUNwQyx3QkFEb0MsRUFFcEMsaUNBRm9DLEVBR3BDLFFBSG9DLEVBSW5DLElBSm1DLENBSTdCLElBSjZCLENBQXJDO0FBTUEsUUFBTSw4QkFBOEIsR0FBRyxDQUN0QywwQkFEc0MsRUFFdEMsbUNBRnNDLEVBR3RDLFFBSHNDLEVBSXJDLElBSnFDLENBSS9CLElBSitCLENBQXZDO0FBTUEsUUFBTSx3QkFBd0IsR0FBRyxDQUNoQyxpQ0FEZ0MsRUFFaEMsd0JBRmdDLEVBR2hDLHNEQUhnQyxFQUloQyxpREFKZ0MsRUFLaEMsa0ZBTGdDLEVBTWhDLHVDQU5nQyxFQU9oQyxRQVBnQyxFQVEvQixJQVIrQixDQVF6QixJQVJ5QixDQUFqQztBQVVBLFFBQU0sMEJBQTBCLEdBQUcsQ0FDbEMsc0NBRGtDLEVBRWxDLDBCQUZrQyxFQUdsQywwREFIa0MsRUFJbEMsZ0ZBSmtDLEVBS2xDLHlDQUxrQyxFQU1sQyxRQU5rQyxFQU9qQyxJQVBpQyxDQU8zQixJQVAyQixDQUFuQztBQVNBLFFBQU0sMEJBQTBCLEdBQUcsQ0FDbEMsNEJBRGtDLEVBRWxDLHlIQUZrQyxFQUdsQyxpRkFIa0MsRUFJbEMsOERBSmtDLEVBS2xDLHFIQUxrQyxFQU1sQywwQ0FOa0MsRUFPbEMsc0RBUGtDLEVBUWxDLDBDQVJrQyxFQVNqQyxJQVRpQyxDQVMzQixJQVQyQixDQUFuQztBQVdBLFFBQU0sUUFBUSxHQUFHO0FBQ2hCLE1BQUEsUUFBUSxFQUFFO0FBQUUsUUFBQSxLQUFLLEVBQUUsSUFBSSxZQUFKLEdBQVksTUFBWixDQUFvQixRQUFwQjtBQUFULE9BRE07QUFFaEIsTUFBQSxVQUFVLEVBQUU7QUFBRSxRQUFBLEtBQUssRUFBRTtBQUFULE9BRkk7QUFHaEIsTUFBQSxXQUFXLEVBQUU7QUFBRSxRQUFBLEtBQUssRUFBRTtBQUFULE9BSEc7QUFJaEIsTUFBQSxhQUFhLEVBQUU7QUFBRSxRQUFBLEtBQUssRUFBRTtBQUFUO0FBSkMsS0FBakI7QUFPQSxXQUFLLGNBQUwsR0FBc0IsUUFBdEI7O0FBRUEsV0FBSyxlQUFMLEdBQXVCLFVBQVcsTUFBWCxFQUFvQjtBQUUxQyxXQUFNLElBQU0sV0FBWixJQUEyQixRQUEzQixFQUFzQztBQUVyQyxRQUFBLE1BQU0sQ0FBQyxRQUFQLENBQWlCLFdBQWpCLElBQWlDLFFBQVEsQ0FBRSxXQUFGLENBQXpDO0FBRUE7O0FBRUQsTUFBQSxNQUFNLENBQUMsY0FBUCxHQUF3QixNQUFNLENBQUMsY0FBUCxDQUN0QixPQURzQixDQUNiLDBCQURhLEVBQ2Usd0JBRGYsRUFFdEIsT0FGc0IsQ0FFYiwwQkFGYSxFQUVlLDJCQUZmLEVBR3RCLE9BSHNCLENBR2IsdUNBSGEsRUFHNEIsNEJBSDVCLEVBSXRCLE9BSnNCLENBSWIsdUNBSmEsRUFJNEIsOEJBSjVCLEVBS3RCLE9BTHNCLENBS2Isa0NBTGEsRUFLdUIsd0JBTHZCLEVBTXRCLE9BTnNCLENBTWIsa0NBTmEsRUFNdUIsMEJBTnZCLEVBT3RCLE9BUHNCLENBT2IscUNBUGEsRUFPMEIsMEJBUDFCLENBQXhCO0FBU0EsS0FqQkQ7O0FBbUJBLElBQUEsTUFBTSxDQUFDLGdCQUFQLGtEQUErQjtBQUU5QixNQUFBLFFBQVEsRUFBRTtBQUNULFFBQUEsR0FBRyxFQUFFLGVBQVk7QUFFaEIsaUJBQU8sUUFBUSxDQUFDLFFBQVQsQ0FBa0IsS0FBekI7QUFFQSxTQUxRO0FBTVQsUUFBQSxHQUFHLEVBQUUsYUFBVyxDQUFYLEVBQWU7QUFFbkIsVUFBQSxRQUFRLENBQUMsUUFBVCxDQUFrQixLQUFsQixHQUEwQixDQUExQjtBQUVBO0FBVlEsT0FGb0I7QUFlOUIsTUFBQSxXQUFXLEVBQUU7QUFDWixRQUFBLEdBQUcsRUFBRSxlQUFZO0FBRWhCLGlCQUFPLFFBQVEsQ0FBQyxXQUFULENBQXFCLEtBQTVCO0FBRUEsU0FMVztBQU1aLFFBQUEsR0FBRyxFQUFFLGFBQVcsQ0FBWCxFQUFlO0FBRW5CLFVBQUEsUUFBUSxDQUFDLFdBQVQsQ0FBcUIsS0FBckIsR0FBNkIsQ0FBN0I7O0FBRUEsY0FBSyxDQUFMLEVBQVM7QUFFUixpQkFBSyxPQUFMLENBQWEsZUFBYixHQUErQixFQUEvQjtBQUVBLFdBSkQsTUFJTztBQUVOLG1CQUFPLEtBQUssT0FBTCxDQUFhLGVBQXBCO0FBRUE7QUFFRDtBQXBCVyxPQWZpQjtBQXNDOUIsTUFBQSxVQUFVLEVBQUU7QUFDWCxRQUFBLEdBQUcsRUFBRSxlQUFZO0FBRWhCLGlCQUFPLFFBQVEsQ0FBQyxVQUFULENBQW9CLEtBQTNCO0FBRUEsU0FMVTtBQU1YLFFBQUEsR0FBRyxFQUFFLGFBQVcsQ0FBWCxFQUFlO0FBRW5CLFVBQUEsUUFBUSxDQUFDLFVBQVQsQ0FBb0IsS0FBcEIsR0FBNEIsQ0FBNUI7QUFFQTtBQVZVLE9BdENrQjtBQW1EOUIsTUFBQSxhQUFhLEVBQUU7QUFDZCxRQUFBLEdBQUcsRUFBRSxlQUFZO0FBRWhCLGlCQUFPLFFBQVEsQ0FBQyxhQUFULENBQXVCLEtBQTlCO0FBRUEsU0FMYTtBQU1kLFFBQUEsR0FBRyxFQUFFLGFBQVcsQ0FBWCxFQUFlO0FBRW5CLFVBQUEsUUFBUSxDQUFDLGFBQVQsQ0FBdUIsS0FBdkIsR0FBK0IsQ0FBL0I7O0FBRUEsY0FBSyxDQUFMLEVBQVM7QUFFUixpQkFBSyxPQUFMLENBQWEsaUJBQWIsR0FBaUMsRUFBakM7QUFDQSxpQkFBSyxPQUFMLENBQWEsTUFBYixHQUFzQixFQUF0QjtBQUVBLFdBTEQsTUFLTztBQUVOLG1CQUFPLEtBQUssT0FBTCxDQUFhLGlCQUFwQjtBQUNBLG1CQUFPLEtBQUssT0FBTCxDQUFhLE1BQXBCO0FBRUE7QUFFRDtBQXRCYTtBQW5EZSxLQUEvQjtBQThFQSxXQUFPLE9BQUssU0FBWjtBQUNBLFdBQU8sT0FBSyxTQUFaO0FBQ0EsV0FBTyxPQUFLLFlBQVo7QUFDQSxXQUFPLE9BQUssWUFBWjs7QUFFQSxXQUFLLFNBQUwsQ0FBZ0IsTUFBaEI7O0FBaEtxQjtBQWtLckI7Ozs7V0FFRCxjQUFNLE1BQU4sRUFBZTtBQUVkLDZIQUFZLE1BQVo7QUFFQSxXQUFLLFdBQUwsR0FBbUIsTUFBTSxDQUFDLFdBQTFCO0FBQ0EsV0FBSyxRQUFMLENBQWMsSUFBZCxDQUFvQixNQUFNLENBQUMsUUFBM0I7QUFDQSxXQUFLLGFBQUwsR0FBcUIsTUFBTSxDQUFDLGFBQTVCO0FBQ0EsV0FBSyxVQUFMLEdBQWtCLE1BQU0sQ0FBQyxVQUF6QjtBQUNBLGFBQU8sS0FBSyxTQUFaO0FBQ0EsYUFBTyxLQUFLLFNBQVo7QUFDQSxhQUFPLEtBQUssWUFBWjtBQUNBLGFBQU8sS0FBSyxZQUFaO0FBQ0EsYUFBTyxJQUFQO0FBRUE7OztFQXBMdUMsMkI7O0lBeUxuQywyQztBQUVMLHlEQUFjO0FBQUE7QUFFYixTQUFLLElBQUwsR0FBWSxVQUFVLENBQUMscUNBQXZCO0FBRUEsU0FBSyx3QkFBTCxHQUFnQyxDQUMvQixPQUQrQixFQUUvQixLQUYrQixFQUcvQixVQUgrQixFQUkvQixtQkFKK0IsRUFLL0IsT0FMK0IsRUFNL0IsZ0JBTitCLEVBTy9CLFVBUCtCLEVBUS9CLG1CQVIrQixFQVMvQixhQVQrQixFQVUvQixTQVYrQixFQVcvQixXQVgrQixFQVkvQixXQVorQixFQWEvQixlQWIrQixFQWMvQixpQkFkK0IsRUFlL0IsbUJBZitCLEVBZ0IvQixrQkFoQitCLEVBaUIvQixhQWpCK0IsRUFrQi9CLFVBbEIrQixFQW1CL0IsZUFuQitCLEVBb0IvQixZQXBCK0IsRUFxQi9CLFVBckIrQixFQXNCL0IsUUF0QitCLEVBdUIvQixpQkF2QitCLEVBd0IvQixpQkF4QitCLENBQWhDO0FBMkJBOzs7O1dBRUQsMkJBQWtCO0FBRWpCLGFBQU8sMEJBQVA7QUFFQTs7O1dBRUQsc0JBQWMsY0FBZCxFQUE4QixXQUE5QixFQUEyQyxNQUEzQyxFQUFvRDtBQUVuRCxVQUFNLHFCQUFxQixHQUFHLFdBQVcsQ0FBQyxVQUFaLENBQXdCLEtBQUssSUFBN0IsQ0FBOUI7QUFFQSxNQUFBLGNBQWMsQ0FBQyxLQUFmLEdBQXVCLElBQUksWUFBSixDQUFXLEdBQVgsRUFBZ0IsR0FBaEIsRUFBcUIsR0FBckIsQ0FBdkI7QUFDQSxNQUFBLGNBQWMsQ0FBQyxPQUFmLEdBQXlCLEdBQXpCO0FBRUEsVUFBTSxPQUFPLEdBQUcsRUFBaEI7O0FBRUEsVUFBSyxLQUFLLENBQUMsT0FBTixDQUFlLHFCQUFxQixDQUFDLGFBQXJDLENBQUwsRUFBNEQ7QUFFM0QsWUFBTSxLQUFLLEdBQUcscUJBQXFCLENBQUMsYUFBcEM7QUFFQSxRQUFBLGNBQWMsQ0FBQyxLQUFmLENBQXFCLFNBQXJCLENBQWdDLEtBQWhDO0FBQ0EsUUFBQSxjQUFjLENBQUMsT0FBZixHQUF5QixLQUFLLENBQUUsQ0FBRixDQUE5QjtBQUVBOztBQUVELFVBQUsscUJBQXFCLENBQUMsY0FBdEIsS0FBeUMsU0FBOUMsRUFBMEQ7QUFFekQsUUFBQSxPQUFPLENBQUMsSUFBUixDQUFjLE1BQU0sQ0FBQyxhQUFQLENBQXNCLGNBQXRCLEVBQXNDLEtBQXRDLEVBQTZDLHFCQUFxQixDQUFDLGNBQW5FLENBQWQ7QUFFQTs7QUFFRCxNQUFBLGNBQWMsQ0FBQyxRQUFmLEdBQTBCLElBQUksWUFBSixDQUFXLEdBQVgsRUFBZ0IsR0FBaEIsRUFBcUIsR0FBckIsQ0FBMUI7QUFDQSxNQUFBLGNBQWMsQ0FBQyxVQUFmLEdBQTRCLHFCQUFxQixDQUFDLGdCQUF0QixLQUEyQyxTQUEzQyxHQUF1RCxxQkFBcUIsQ0FBQyxnQkFBN0UsR0FBZ0csR0FBNUg7QUFDQSxNQUFBLGNBQWMsQ0FBQyxRQUFmLEdBQTBCLElBQUksWUFBSixDQUFXLEdBQVgsRUFBZ0IsR0FBaEIsRUFBcUIsR0FBckIsQ0FBMUI7O0FBRUEsVUFBSyxLQUFLLENBQUMsT0FBTixDQUFlLHFCQUFxQixDQUFDLGNBQXJDLENBQUwsRUFBNkQ7QUFFNUQsUUFBQSxjQUFjLENBQUMsUUFBZixDQUF3QixTQUF4QixDQUFtQyxxQkFBcUIsQ0FBQyxjQUF6RDtBQUVBOztBQUVELFVBQUsscUJBQXFCLENBQUMseUJBQXRCLEtBQW9ELFNBQXpELEVBQXFFO0FBRXBFLFlBQU0sZUFBZSxHQUFHLHFCQUFxQixDQUFDLHlCQUE5QztBQUNBLFFBQUEsT0FBTyxDQUFDLElBQVIsQ0FBYyxNQUFNLENBQUMsYUFBUCxDQUFzQixjQUF0QixFQUFzQyxlQUF0QyxFQUF1RCxlQUF2RCxDQUFkO0FBQ0EsUUFBQSxPQUFPLENBQUMsSUFBUixDQUFjLE1BQU0sQ0FBQyxhQUFQLENBQXNCLGNBQXRCLEVBQXNDLGFBQXRDLEVBQXFELGVBQXJELENBQWQ7QUFFQTs7QUFFRCxhQUFPLE9BQU8sQ0FBQyxHQUFSLENBQWEsT0FBYixDQUFQO0FBRUE7OztXQUVELHdCQUFnQixjQUFoQixFQUFpQztBQUVoQyxVQUFNLFFBQVEsR0FBRyxJQUFJLDBCQUFKLENBQWdDLGNBQWhDLENBQWpCO0FBQ0EsTUFBQSxRQUFRLENBQUMsR0FBVCxHQUFlLElBQWY7QUFFQSxNQUFBLFFBQVEsQ0FBQyxLQUFULEdBQWlCLGNBQWMsQ0FBQyxLQUFoQztBQUVBLE1BQUEsUUFBUSxDQUFDLEdBQVQsR0FBZSxjQUFjLENBQUMsR0FBZixLQUF1QixTQUF2QixHQUFtQyxJQUFuQyxHQUEwQyxjQUFjLENBQUMsR0FBeEU7QUFFQSxNQUFBLFFBQVEsQ0FBQyxRQUFULEdBQW9CLElBQXBCO0FBQ0EsTUFBQSxRQUFRLENBQUMsaUJBQVQsR0FBNkIsR0FBN0I7QUFFQSxNQUFBLFFBQVEsQ0FBQyxLQUFULEdBQWlCLGNBQWMsQ0FBQyxLQUFmLEtBQXlCLFNBQXpCLEdBQXFDLElBQXJDLEdBQTRDLGNBQWMsQ0FBQyxLQUE1RTtBQUNBLE1BQUEsUUFBUSxDQUFDLGNBQVQsR0FBMEIsR0FBMUI7QUFFQSxNQUFBLFFBQVEsQ0FBQyxRQUFULEdBQW9CLGNBQWMsQ0FBQyxRQUFuQztBQUNBLE1BQUEsUUFBUSxDQUFDLGlCQUFULEdBQTZCLEdBQTdCO0FBQ0EsTUFBQSxRQUFRLENBQUMsV0FBVCxHQUF1QixjQUFjLENBQUMsV0FBZixLQUErQixTQUEvQixHQUEyQyxJQUEzQyxHQUFrRCxjQUFjLENBQUMsV0FBeEY7QUFFQSxNQUFBLFFBQVEsQ0FBQyxPQUFULEdBQW1CLGNBQWMsQ0FBQyxPQUFmLEtBQTJCLFNBQTNCLEdBQXVDLElBQXZDLEdBQThDLGNBQWMsQ0FBQyxPQUFoRjtBQUNBLE1BQUEsUUFBUSxDQUFDLFNBQVQsR0FBcUIsQ0FBckI7QUFFQSxNQUFBLFFBQVEsQ0FBQyxTQUFULEdBQXFCLGNBQWMsQ0FBQyxTQUFmLEtBQTZCLFNBQTdCLEdBQXlDLElBQXpDLEdBQWdELGNBQWMsQ0FBQyxTQUFwRjtBQUNBLE1BQUEsUUFBUSxDQUFDLGFBQVQsR0FBeUIsNEJBQXpCO0FBRUEsVUFBSyxjQUFjLENBQUMsV0FBcEIsRUFBa0MsUUFBUSxDQUFDLFdBQVQsR0FBdUIsY0FBYyxDQUFDLFdBQXRDO0FBRWxDLE1BQUEsUUFBUSxDQUFDLGVBQVQsR0FBMkIsSUFBM0I7QUFDQSxNQUFBLFFBQVEsQ0FBQyxpQkFBVCxHQUE2QixDQUE3QjtBQUNBLE1BQUEsUUFBUSxDQUFDLGdCQUFULEdBQTRCLENBQTVCO0FBRUEsTUFBQSxRQUFRLENBQUMsV0FBVCxHQUF1QixjQUFjLENBQUMsV0FBZixLQUErQixTQUEvQixHQUEyQyxJQUEzQyxHQUFrRCxjQUFjLENBQUMsV0FBeEY7QUFDQSxNQUFBLFFBQVEsQ0FBQyxRQUFULEdBQW9CLGNBQWMsQ0FBQyxRQUFuQztBQUVBLE1BQUEsUUFBUSxDQUFDLGFBQVQsR0FBeUIsY0FBYyxDQUFDLGFBQWYsS0FBaUMsU0FBakMsR0FBNkMsSUFBN0MsR0FBb0QsY0FBYyxDQUFDLGFBQTVGO0FBQ0EsTUFBQSxRQUFRLENBQUMsVUFBVCxHQUFzQixjQUFjLENBQUMsVUFBckM7QUFFQSxNQUFBLFFBQVEsQ0FBQyxRQUFULEdBQW9CLElBQXBCO0FBRUEsTUFBQSxRQUFRLENBQUMsTUFBVCxHQUFrQixjQUFjLENBQUMsTUFBZixLQUEwQixTQUExQixHQUFzQyxJQUF0QyxHQUE2QyxjQUFjLENBQUMsTUFBOUU7QUFDQSxNQUFBLFFBQVEsQ0FBQyxlQUFULEdBQTJCLEdBQTNCO0FBRUEsTUFBQSxRQUFRLENBQUMsZUFBVCxHQUEyQixJQUEzQjtBQUVBLGFBQU8sUUFBUDtBQUVBOzs7OztJQVNJLDZCLGlDQUVMLHlDQUFjO0FBQUE7QUFFYixPQUFLLElBQUwsR0FBWSxVQUFVLENBQUMscUJBQXZCO0FBRUEsQzs7SUFVSSwwQjs7Ozs7QUFFTCxzQ0FBYSxrQkFBYixFQUFpQyxZQUFqQyxFQUErQyxVQUEvQyxFQUEyRCxZQUEzRCxFQUEwRTtBQUFBO0FBQUEsOEJBRWxFLGtCQUZrRSxFQUU5QyxZQUY4QyxFQUVoQyxVQUZnQyxFQUVwQixZQUZvQjtBQUl6RTs7OztXQUVELDBCQUFrQixLQUFsQixFQUEwQjtBQUt6QixVQUFNLE1BQU0sR0FBRyxLQUFLLFlBQXBCO0FBQUEsVUFDQyxNQUFNLEdBQUcsS0FBSyxZQURmO0FBQUEsVUFFQyxTQUFTLEdBQUcsS0FBSyxTQUZsQjtBQUFBLFVBR0MsTUFBTSxHQUFHLEtBQUssR0FBRyxTQUFSLEdBQW9CLENBQXBCLEdBQXdCLFNBSGxDOztBQUtBLFdBQU0sSUFBSSxDQUFDLEdBQUcsQ0FBZCxFQUFpQixDQUFDLEtBQUssU0FBdkIsRUFBa0MsQ0FBQyxFQUFuQyxFQUF5QztBQUV4QyxRQUFBLE1BQU0sQ0FBRSxDQUFGLENBQU4sR0FBYyxNQUFNLENBQUUsTUFBTSxHQUFHLENBQVgsQ0FBcEI7QUFFQTs7QUFFRCxhQUFPLE1BQVA7QUFFQTs7O0VBMUJ1QyxrQjs7QUE4QnpDLDBCQUEwQixDQUFDLFNBQTNCLENBQXFDLFlBQXJDLEdBQW9ELDBCQUEwQixDQUFDLFNBQTNCLENBQXFDLGdCQUF6RjtBQUVBLDBCQUEwQixDQUFDLFNBQTNCLENBQXFDLFNBQXJDLEdBQWlELDBCQUEwQixDQUFDLFNBQTNCLENBQXFDLGdCQUF0Rjs7QUFFQSwwQkFBMEIsQ0FBQyxTQUEzQixDQUFxQyxZQUFyQyxHQUFvRCxVQUFXLEVBQVgsRUFBZSxFQUFmLEVBQW1CLENBQW5CLEVBQXNCLEVBQXRCLEVBQTJCO0FBRTlFLE1BQU0sTUFBTSxHQUFHLEtBQUssWUFBcEI7QUFDQSxNQUFNLE1BQU0sR0FBRyxLQUFLLFlBQXBCO0FBQ0EsTUFBTSxNQUFNLEdBQUcsS0FBSyxTQUFwQjtBQUVBLE1BQU0sT0FBTyxHQUFHLE1BQU0sR0FBRyxDQUF6QjtBQUNBLE1BQU0sT0FBTyxHQUFHLE1BQU0sR0FBRyxDQUF6QjtBQUVBLE1BQU0sRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFoQjtBQUVBLE1BQU0sQ0FBQyxHQUFHLENBQUUsQ0FBQyxHQUFHLEVBQU4sSUFBYSxFQUF2QjtBQUNBLE1BQU0sRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFmO0FBQ0EsTUFBTSxHQUFHLEdBQUcsRUFBRSxHQUFHLENBQWpCO0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBRSxHQUFHLE9BQXJCO0FBQ0EsTUFBTSxPQUFPLEdBQUcsT0FBTyxHQUFHLE9BQTFCO0FBRUEsTUFBTSxFQUFFLEdBQUcsQ0FBRSxDQUFGLEdBQU0sR0FBTixHQUFZLElBQUksRUFBM0I7QUFDQSxNQUFNLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBakI7QUFDQSxNQUFNLEVBQUUsR0FBRyxJQUFJLEVBQWY7QUFDQSxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBTCxHQUFVLENBQXJCOztBQUlBLE9BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBZCxFQUFpQixDQUFDLEtBQUssTUFBdkIsRUFBK0IsQ0FBQyxFQUFoQyxFQUFzQztBQUVyQyxRQUFNLEVBQUUsR0FBRyxNQUFNLENBQUUsT0FBTyxHQUFHLENBQVYsR0FBYyxNQUFoQixDQUFqQjtBQUNBLFFBQU0sRUFBRSxHQUFHLE1BQU0sQ0FBRSxPQUFPLEdBQUcsQ0FBVixHQUFjLE9BQWhCLENBQU4sR0FBa0MsRUFBN0M7QUFDQSxRQUFNLEVBQUUsR0FBRyxNQUFNLENBQUUsT0FBTyxHQUFHLENBQVYsR0FBYyxNQUFoQixDQUFqQjtBQUNBLFFBQU0sRUFBRSxHQUFHLE1BQU0sQ0FBRSxPQUFPLEdBQUcsQ0FBWixDQUFOLEdBQXdCLEVBQW5DO0FBRUEsSUFBQSxNQUFNLENBQUUsQ0FBRixDQUFOLEdBQWMsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFFLEdBQUcsRUFBZixHQUFvQixFQUFFLEdBQUcsRUFBekIsR0FBOEIsRUFBRSxHQUFHLEVBQWpEO0FBRUE7O0FBRUQsU0FBTyxNQUFQO0FBRUEsQ0F0Q0Q7O0FBd0NBLElBQU0sRUFBRSxHQUFHLElBQUksaUJBQUosRUFBWDs7SUFFTSxvQzs7Ozs7Ozs7Ozs7O1dBRUwsc0JBQWMsRUFBZCxFQUFrQixFQUFsQixFQUFzQixDQUF0QixFQUF5QixFQUF6QixFQUE4QjtBQUU3QixVQUFNLE1BQU0sNElBQXVCLEVBQXZCLEVBQTJCLEVBQTNCLEVBQStCLENBQS9CLEVBQWtDLEVBQWxDLENBQVo7O0FBRUEsTUFBQSxFQUFFLENBQUMsU0FBSCxDQUFjLE1BQWQsRUFBdUIsU0FBdkIsR0FBbUMsT0FBbkMsQ0FBNEMsTUFBNUM7O0FBRUEsYUFBTyxNQUFQO0FBRUE7OztFQVZpRCwwQjs7QUFxQm5ELElBQU0sZUFBZSxHQUFHO0FBQ3ZCLEVBQUEsS0FBSyxFQUFFLElBRGdCO0FBR3ZCLEVBQUEsVUFBVSxFQUFFLEtBSFc7QUFJdkIsRUFBQSxVQUFVLEVBQUUsS0FKVztBQUt2QixFQUFBLFVBQVUsRUFBRSxLQUxXO0FBTXZCLEVBQUEsVUFBVSxFQUFFLEtBTlc7QUFPdkIsRUFBQSxVQUFVLEVBQUUsS0FQVztBQVF2QixFQUFBLE1BQU0sRUFBRSxJQVJlO0FBU3ZCLEVBQUEsTUFBTSxFQUFFLEtBVGU7QUFVdkIsRUFBQSxVQUFVLEVBQUUsS0FWVztBQVd2QixFQUFBLE1BQU0sRUFBRSxDQVhlO0FBWXZCLEVBQUEsS0FBSyxFQUFFLENBWmdCO0FBYXZCLEVBQUEsU0FBUyxFQUFFLENBYlk7QUFjdkIsRUFBQSxVQUFVLEVBQUUsQ0FkVztBQWV2QixFQUFBLFNBQVMsRUFBRSxDQWZZO0FBZ0J2QixFQUFBLGNBQWMsRUFBRSxDQWhCTztBQWlCdkIsRUFBQSxZQUFZLEVBQUUsQ0FqQlM7QUFrQnZCLEVBQUEsYUFBYSxFQUFFLElBbEJRO0FBbUJ2QixFQUFBLGNBQWMsRUFBRTtBQW5CTyxDQUF4QjtBQXNCQSxJQUFNLHFCQUFxQixHQUFHO0FBQzdCLFFBQU0sU0FEdUI7QUFFN0IsUUFBTSxVQUZ1QjtBQUc3QixRQUFNLFVBSHVCO0FBSTdCLFFBQU0sV0FKdUI7QUFLN0IsUUFBTSxXQUx1QjtBQU03QixRQUFNO0FBTnVCLENBQTlCO0FBU0EsSUFBTSxhQUFhLEdBQUc7QUFDckIsUUFBTSxvQkFEZTtBQUVyQixRQUFNLG1CQUZlO0FBR3JCLFFBQU0saUNBSGU7QUFJckIsUUFBTSxnQ0FKZTtBQUtyQixRQUFNLGdDQUxlO0FBTXJCLFFBQU07QUFOZSxDQUF0QjtBQVNBLElBQU0sZUFBZSxHQUFHO0FBQ3ZCLFNBQU8sMEJBRGdCO0FBRXZCLFNBQU8sNkJBRmdCO0FBR3ZCLFNBQU87QUFIZ0IsQ0FBeEI7QUFNQSxJQUFNLGdCQUFnQixHQUFHO0FBQ3hCLFlBQVUsQ0FEYztBQUV4QixVQUFRLENBRmdCO0FBR3hCLFVBQVEsQ0FIZ0I7QUFJeEIsVUFBUSxDQUpnQjtBQUt4QixVQUFRLENBTGdCO0FBTXhCLFVBQVEsQ0FOZ0I7QUFPeEIsVUFBUTtBQVBnQixDQUF6QjtBQVVBLElBQU0sVUFBVSxHQUFHO0FBQ2xCLEVBQUEsUUFBUSxFQUFFLFVBRFE7QUFFbEIsRUFBQSxNQUFNLEVBQUUsUUFGVTtBQUdsQixFQUFBLE9BQU8sRUFBRSxTQUhTO0FBSWxCLEVBQUEsVUFBVSxFQUFFLElBSk07QUFLbEIsRUFBQSxVQUFVLEVBQUUsS0FMTTtBQU1sQixFQUFBLE9BQU8sRUFBRSxPQU5TO0FBT2xCLEVBQUEsU0FBUyxFQUFFLFlBUE87QUFRbEIsRUFBQSxRQUFRLEVBQUU7QUFSUSxDQUFuQjtBQVdBLElBQU0sZUFBZSxHQUFHO0FBQ3ZCLEVBQUEsS0FBSyxFQUFFLE9BRGdCO0FBRXZCLEVBQUEsV0FBVyxFQUFFLFVBRlU7QUFHdkIsRUFBQSxRQUFRLEVBQUUsWUFIYTtBQUl2QixFQUFBLE9BQU8sRUFBRTtBQUpjLENBQXhCO0FBT0EsSUFBTSxhQUFhLEdBQUc7QUFDckIsRUFBQSxXQUFXLEVBQUUsU0FEUTtBQUdyQixFQUFBLE1BQU0sRUFBRSx3QkFIYTtBQUlyQixFQUFBLElBQUksRUFBRTtBQUplLENBQXRCO0FBT0EsSUFBTSxXQUFXLEdBQUc7QUFDbkIsRUFBQSxNQUFNLEVBQUUsUUFEVztBQUVuQixFQUFBLElBQUksRUFBRSxNQUZhO0FBR25CLEVBQUEsS0FBSyxFQUFFO0FBSFksQ0FBcEI7O0FBU0EsU0FBUyxxQkFBVCxDQUFnQyxLQUFoQyxFQUF3QztBQUV2QyxNQUFLLEtBQUssQ0FBRSxpQkFBRixDQUFMLEtBQStCLFNBQXBDLEVBQWdEO0FBRS9DLElBQUEsS0FBSyxDQUFFLGlCQUFGLENBQUwsR0FBNkIsSUFBSSwyQkFBSixDQUEwQjtBQUN0RCxNQUFBLEtBQUssRUFBRSxRQUQrQztBQUV0RCxNQUFBLFFBQVEsRUFBRSxRQUY0QztBQUd0RCxNQUFBLFNBQVMsRUFBRSxDQUgyQztBQUl0RCxNQUFBLFNBQVMsRUFBRSxDQUoyQztBQUt0RCxNQUFBLFdBQVcsRUFBRSxLQUx5QztBQU10RCxNQUFBLFNBQVMsRUFBRSxJQU4yQztBQU90RCxNQUFBLElBQUksRUFBRTtBQVBnRCxLQUExQixDQUE3QjtBQVVBOztBQUVELFNBQU8sS0FBSyxDQUFFLGlCQUFGLENBQVo7QUFFQTs7QUFFRCxTQUFTLDhCQUFULENBQXlDLGVBQXpDLEVBQTBELE1BQTFELEVBQWtFLFNBQWxFLEVBQThFO0FBSTdFLE9BQU0sSUFBTSxJQUFaLElBQW9CLFNBQVMsQ0FBQyxVQUE5QixFQUEyQztBQUUxQyxRQUFLLGVBQWUsQ0FBRSxJQUFGLENBQWYsS0FBNEIsU0FBakMsRUFBNkM7QUFFNUMsTUFBQSxNQUFNLENBQUMsUUFBUCxDQUFnQixjQUFoQixHQUFpQyxNQUFNLENBQUMsUUFBUCxDQUFnQixjQUFoQixJQUFrQyxFQUFuRTtBQUNBLE1BQUEsTUFBTSxDQUFDLFFBQVAsQ0FBZ0IsY0FBaEIsQ0FBZ0MsSUFBaEMsSUFBeUMsU0FBUyxDQUFDLFVBQVYsQ0FBc0IsSUFBdEIsQ0FBekM7QUFFQTtBQUVEO0FBRUQ7O0FBTUQsU0FBUyxzQkFBVCxDQUFpQyxNQUFqQyxFQUF5QyxPQUF6QyxFQUFtRDtBQUVsRCxNQUFLLE9BQU8sQ0FBQyxNQUFSLEtBQW1CLFNBQXhCLEVBQW9DO0FBRW5DLFFBQUsseUJBQU8sT0FBTyxDQUFDLE1BQWYsTUFBMEIsUUFBL0IsRUFBMEM7QUFFekMsTUFBQSxNQUFNLENBQUMsTUFBUCxDQUFlLE1BQU0sQ0FBQyxRQUF0QixFQUFnQyxPQUFPLENBQUMsTUFBeEM7QUFFQSxLQUpELE1BSU87QUFFTixNQUFBLE9BQU8sQ0FBQyxJQUFSLENBQWMsd0RBQXdELE9BQU8sQ0FBQyxNQUE5RTtBQUVBO0FBRUQ7QUFFRDs7QUFVRCxTQUFTLGVBQVQsQ0FBMEIsUUFBMUIsRUFBb0MsT0FBcEMsRUFBNkMsTUFBN0MsRUFBc0Q7QUFFckQsTUFBSSxnQkFBZ0IsR0FBRyxLQUF2QjtBQUNBLE1BQUksY0FBYyxHQUFHLEtBQXJCOztBQUVBLE9BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBUixFQUFXLEVBQUUsR0FBRyxPQUFPLENBQUMsTUFBOUIsRUFBc0MsQ0FBQyxHQUFHLEVBQTFDLEVBQThDLENBQUMsRUFBL0MsRUFBcUQ7QUFFcEQsUUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFFLENBQUYsQ0FBdEI7QUFFQSxRQUFLLE1BQU0sQ0FBQyxRQUFQLEtBQW9CLFNBQXpCLEVBQXFDLGdCQUFnQixHQUFHLElBQW5CO0FBQ3JDLFFBQUssTUFBTSxDQUFDLE1BQVAsS0FBa0IsU0FBdkIsRUFBbUMsY0FBYyxHQUFHLElBQWpCO0FBRW5DLFFBQUssZ0JBQWdCLElBQUksY0FBekIsRUFBMEM7QUFFMUM7O0FBRUQsTUFBSyxDQUFFLGdCQUFGLElBQXNCLENBQUUsY0FBN0IsRUFBOEMsT0FBTyxPQUFPLENBQUMsT0FBUixDQUFpQixRQUFqQixDQUFQO0FBRTlDLE1BQU0sd0JBQXdCLEdBQUcsRUFBakM7QUFDQSxNQUFNLHNCQUFzQixHQUFHLEVBQS9COztBQUVBLE9BQU0sSUFBSSxHQUFDLEdBQUcsQ0FBUixFQUFXLEdBQUUsR0FBRyxPQUFPLENBQUMsTUFBOUIsRUFBc0MsR0FBQyxHQUFHLEdBQTFDLEVBQThDLEdBQUMsRUFBL0MsRUFBcUQ7QUFFcEQsUUFBTSxPQUFNLEdBQUcsT0FBTyxDQUFFLEdBQUYsQ0FBdEI7O0FBRUEsUUFBSyxnQkFBTCxFQUF3QjtBQUV2QixVQUFNLGVBQWUsR0FBRyxPQUFNLENBQUMsUUFBUCxLQUFvQixTQUFwQixHQUNyQixNQUFNLENBQUMsYUFBUCxDQUFzQixVQUF0QixFQUFrQyxPQUFNLENBQUMsUUFBekMsQ0FEcUIsR0FFckIsUUFBUSxDQUFDLFVBQVQsQ0FBb0IsUUFGdkI7QUFJQSxNQUFBLHdCQUF3QixDQUFDLElBQXpCLENBQStCLGVBQS9CO0FBRUE7O0FBRUQsUUFBSyxjQUFMLEVBQXNCO0FBRXJCLFVBQU0sZ0JBQWUsR0FBRyxPQUFNLENBQUMsTUFBUCxLQUFrQixTQUFsQixHQUNyQixNQUFNLENBQUMsYUFBUCxDQUFzQixVQUF0QixFQUFrQyxPQUFNLENBQUMsTUFBekMsQ0FEcUIsR0FFckIsUUFBUSxDQUFDLFVBQVQsQ0FBb0IsTUFGdkI7O0FBSUEsTUFBQSxzQkFBc0IsQ0FBQyxJQUF2QixDQUE2QixnQkFBN0I7QUFFQTtBQUVEOztBQUVELFNBQU8sT0FBTyxDQUFDLEdBQVIsQ0FBYSxDQUNuQixPQUFPLENBQUMsR0FBUixDQUFhLHdCQUFiLENBRG1CLEVBRW5CLE9BQU8sQ0FBQyxHQUFSLENBQWEsc0JBQWIsQ0FGbUIsQ0FBYixFQUdILElBSEcsQ0FHRyxVQUFXLFNBQVgsRUFBdUI7QUFFaEMsUUFBTSxjQUFjLEdBQUcsU0FBUyxDQUFFLENBQUYsQ0FBaEM7QUFDQSxRQUFNLFlBQVksR0FBRyxTQUFTLENBQUUsQ0FBRixDQUE5QjtBQUVBLFFBQUssZ0JBQUwsRUFBd0IsUUFBUSxDQUFDLGVBQVQsQ0FBeUIsUUFBekIsR0FBb0MsY0FBcEM7QUFDeEIsUUFBSyxjQUFMLEVBQXNCLFFBQVEsQ0FBQyxlQUFULENBQXlCLE1BQXpCLEdBQWtDLFlBQWxDO0FBQ3RCLElBQUEsUUFBUSxDQUFDLG9CQUFULEdBQWdDLElBQWhDO0FBRUEsV0FBTyxRQUFQO0FBRUEsR0FkTSxDQUFQO0FBZ0JBOztBQU1ELFNBQVMsa0JBQVQsQ0FBNkIsSUFBN0IsRUFBbUMsT0FBbkMsRUFBNkM7QUFFNUMsRUFBQSxJQUFJLENBQUMsa0JBQUw7O0FBRUEsTUFBSyxPQUFPLENBQUMsT0FBUixLQUFvQixTQUF6QixFQUFxQztBQUVwQyxTQUFNLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxFQUFFLEdBQUcsT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsTUFBdEMsRUFBOEMsQ0FBQyxHQUFHLEVBQWxELEVBQXNELENBQUMsRUFBdkQsRUFBNkQ7QUFFNUQsTUFBQSxJQUFJLENBQUMscUJBQUwsQ0FBNEIsQ0FBNUIsSUFBa0MsT0FBTyxDQUFDLE9BQVIsQ0FBaUIsQ0FBakIsQ0FBbEM7QUFFQTtBQUVEOztBQUdELE1BQUssT0FBTyxDQUFDLE1BQVIsSUFBa0IsS0FBSyxDQUFDLE9BQU4sQ0FBZSxPQUFPLENBQUMsTUFBUixDQUFlLFdBQTlCLENBQXZCLEVBQXFFO0FBRXBFLFFBQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxNQUFSLENBQWUsV0FBbkM7O0FBRUEsUUFBSyxJQUFJLENBQUMscUJBQUwsQ0FBMkIsTUFBM0IsS0FBc0MsV0FBVyxDQUFDLE1BQXZELEVBQWdFO0FBRS9ELE1BQUEsSUFBSSxDQUFDLHFCQUFMLEdBQTZCLEVBQTdCOztBQUVBLFdBQU0sSUFBSSxHQUFDLEdBQUcsQ0FBUixFQUFXLElBQUUsR0FBRyxXQUFXLENBQUMsTUFBbEMsRUFBMEMsR0FBQyxHQUFHLElBQTlDLEVBQWtELEdBQUMsRUFBbkQsRUFBeUQ7QUFFeEQsUUFBQSxJQUFJLENBQUMscUJBQUwsQ0FBNEIsV0FBVyxDQUFFLEdBQUYsQ0FBdkMsSUFBaUQsR0FBakQ7QUFFQTtBQUVELEtBVkQsTUFVTztBQUVOLE1BQUEsT0FBTyxDQUFDLElBQVIsQ0FBYyxzRUFBZDtBQUVBO0FBRUQ7QUFFRDs7QUFFRCxTQUFTLGtCQUFULENBQTZCLFlBQTdCLEVBQTRDO0FBRTNDLE1BQU0sY0FBYyxHQUFHLFlBQVksQ0FBQyxVQUFiLElBQTJCLFlBQVksQ0FBQyxVQUFiLENBQXlCLFVBQVUsQ0FBQywwQkFBcEMsQ0FBbEQ7QUFDQSxNQUFJLFdBQUo7O0FBRUEsTUFBSyxjQUFMLEVBQXNCO0FBRXJCLElBQUEsV0FBVyxHQUFHLFdBQVcsY0FBYyxDQUFDLFVBQTFCLEdBQ1YsR0FEVSxHQUNKLGNBQWMsQ0FBQyxPQURYLEdBRVYsR0FGVSxHQUVKLG1CQUFtQixDQUFFLGNBQWMsQ0FBQyxVQUFqQixDQUY3QjtBQUlBLEdBTkQsTUFNTztBQUVOLElBQUEsV0FBVyxHQUFHLFlBQVksQ0FBQyxPQUFiLEdBQXVCLEdBQXZCLEdBQTZCLG1CQUFtQixDQUFFLFlBQVksQ0FBQyxVQUFmLENBQWhELEdBQThFLEdBQTlFLEdBQW9GLFlBQVksQ0FBQyxJQUEvRztBQUVBOztBQUVELFNBQU8sV0FBUDtBQUVBOztBQUVELFNBQVMsbUJBQVQsQ0FBOEIsVUFBOUIsRUFBMkM7QUFFMUMsTUFBSSxhQUFhLEdBQUcsRUFBcEI7QUFFQSxNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsSUFBUCxDQUFhLFVBQWIsRUFBMEIsSUFBMUIsRUFBYjs7QUFFQSxPQUFNLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQTNCLEVBQW1DLENBQUMsR0FBRyxFQUF2QyxFQUEyQyxDQUFDLEVBQTVDLEVBQWtEO0FBRWpELElBQUEsYUFBYSxJQUFJLElBQUksQ0FBRSxDQUFGLENBQUosR0FBWSxHQUFaLEdBQWtCLFVBQVUsQ0FBRSxJQUFJLENBQUUsQ0FBRixDQUFOLENBQTVCLEdBQTRDLEdBQTdEO0FBRUE7O0FBRUQsU0FBTyxhQUFQO0FBRUE7O0FBRUQsU0FBUywyQkFBVCxDQUFzQyxXQUF0QyxFQUFvRDtBQUtuRCxVQUFTLFdBQVQ7QUFFQyxTQUFLLFNBQUw7QUFDQyxhQUFPLElBQUksR0FBWDs7QUFFRCxTQUFLLFVBQUw7QUFDQyxhQUFPLElBQUksR0FBWDs7QUFFRCxTQUFLLFVBQUw7QUFDQyxhQUFPLElBQUksS0FBWDs7QUFFRCxTQUFLLFdBQUw7QUFDQyxhQUFPLElBQUksS0FBWDs7QUFFRDtBQUNDLFlBQU0sSUFBSSxLQUFKLENBQVcsbUVBQVgsQ0FBTjtBQWZGO0FBbUJBOztJQUlLLFU7QUFFTCx3QkFBdUM7QUFBQSxRQUExQixJQUEwQix1RUFBbkIsRUFBbUI7QUFBQSxRQUFmLE9BQWUsdUVBQUwsRUFBSztBQUFBO0FBRXRDLFNBQUssSUFBTCxHQUFZLElBQVo7QUFDQSxTQUFLLFVBQUwsR0FBa0IsRUFBbEI7QUFDQSxTQUFLLE9BQUwsR0FBZSxFQUFmO0FBQ0EsU0FBSyxPQUFMLEdBQWUsT0FBZjtBQUdBLFNBQUssS0FBTCxHQUFhLElBQUksWUFBSixFQUFiO0FBR0EsU0FBSyxZQUFMLEdBQW9CLElBQUksR0FBSixFQUFwQjtBQUdBLFNBQUssY0FBTCxHQUFzQixFQUF0QjtBQUdBLFNBQUssU0FBTCxHQUFpQjtBQUFFLE1BQUEsSUFBSSxFQUFFLEVBQVI7QUFBWSxNQUFBLElBQUksRUFBRTtBQUFsQixLQUFqQjtBQUNBLFNBQUssV0FBTCxHQUFtQjtBQUFFLE1BQUEsSUFBSSxFQUFFLEVBQVI7QUFBWSxNQUFBLElBQUksRUFBRTtBQUFsQixLQUFuQjtBQUNBLFNBQUssVUFBTCxHQUFrQjtBQUFFLE1BQUEsSUFBSSxFQUFFLEVBQVI7QUFBWSxNQUFBLElBQUksRUFBRTtBQUFsQixLQUFsQjtBQUVBLFNBQUssWUFBTCxHQUFvQixFQUFwQjtBQUdBLFNBQUssYUFBTCxHQUFxQixFQUFyQjs7QUFJQSxRQUFLLE9BQU8saUJBQVAsS0FBNkIsV0FBN0IsSUFBNEMsVUFBVSxJQUFWLENBQWdCLFNBQVMsQ0FBQyxTQUExQixNQUEwQyxLQUEzRixFQUFtRztBQUVsRyxXQUFLLGFBQUwsR0FBcUIsSUFBSSx3QkFBSixDQUF1QixLQUFLLE9BQUwsQ0FBYSxPQUFwQyxDQUFyQjtBQUVBLEtBSkQsTUFJTztBQUVOLFdBQUssYUFBTCxHQUFxQixJQUFJLG9CQUFKLENBQW1CLEtBQUssT0FBTCxDQUFhLE9BQWhDLENBQXJCO0FBRUE7O0FBRUQsU0FBSyxhQUFMLENBQW1CLGNBQW5CLENBQW1DLEtBQUssT0FBTCxDQUFhLFdBQWhEO0FBQ0EsU0FBSyxhQUFMLENBQW1CLGdCQUFuQixDQUFxQyxLQUFLLE9BQUwsQ0FBYSxhQUFsRDtBQUVBLFNBQUssVUFBTCxHQUFrQixJQUFJLGlCQUFKLENBQWdCLEtBQUssT0FBTCxDQUFhLE9BQTdCLENBQWxCO0FBQ0EsU0FBSyxVQUFMLENBQWdCLGVBQWhCLENBQWlDLGFBQWpDOztBQUVBLFFBQUssS0FBSyxPQUFMLENBQWEsV0FBYixLQUE2QixpQkFBbEMsRUFBc0Q7QUFFckQsV0FBSyxVQUFMLENBQWdCLGtCQUFoQixDQUFvQyxJQUFwQztBQUVBO0FBRUQ7Ozs7V0FFRCx1QkFBZSxVQUFmLEVBQTRCO0FBRTNCLFdBQUssVUFBTCxHQUFrQixVQUFsQjtBQUVBOzs7V0FFRCxvQkFBWSxPQUFaLEVBQXNCO0FBRXJCLFdBQUssT0FBTCxHQUFlLE9BQWY7QUFFQTs7O1dBRUQsZUFBTyxNQUFQLEVBQWUsT0FBZixFQUF5QjtBQUV4QixVQUFNLE1BQU0sR0FBRyxJQUFmO0FBQ0EsVUFBTSxJQUFJLEdBQUcsS0FBSyxJQUFsQjtBQUNBLFVBQU0sVUFBVSxHQUFHLEtBQUssVUFBeEI7QUFHQSxXQUFLLEtBQUwsQ0FBVyxTQUFYOztBQUdBLFdBQUssVUFBTCxDQUFpQixVQUFXLEdBQVgsRUFBaUI7QUFFakMsZUFBTyxHQUFHLENBQUMsU0FBSixJQUFpQixHQUFHLENBQUMsU0FBSixFQUF4QjtBQUVBLE9BSkQ7O0FBTUEsTUFBQSxPQUFPLENBQUMsR0FBUixDQUFhLEtBQUssVUFBTCxDQUFpQixVQUFXLEdBQVgsRUFBaUI7QUFFOUMsZUFBTyxHQUFHLENBQUMsVUFBSixJQUFrQixHQUFHLENBQUMsVUFBSixFQUF6QjtBQUVBLE9BSlksQ0FBYixFQUlNLElBSk4sQ0FJWSxZQUFZO0FBRXZCLGVBQU8sT0FBTyxDQUFDLEdBQVIsQ0FBYSxDQUVuQixNQUFNLENBQUMsZUFBUCxDQUF3QixPQUF4QixDQUZtQixFQUduQixNQUFNLENBQUMsZUFBUCxDQUF3QixXQUF4QixDQUhtQixFQUluQixNQUFNLENBQUMsZUFBUCxDQUF3QixRQUF4QixDQUptQixDQUFiLENBQVA7QUFRQSxPQWRELEVBY0ksSUFkSixDQWNVLFVBQVcsWUFBWCxFQUEwQjtBQUVuQyxZQUFNLE1BQU0sR0FBRztBQUNkLFVBQUEsS0FBSyxFQUFFLFlBQVksQ0FBRSxDQUFGLENBQVosQ0FBbUIsSUFBSSxDQUFDLEtBQUwsSUFBYyxDQUFqQyxDQURPO0FBRWQsVUFBQSxNQUFNLEVBQUUsWUFBWSxDQUFFLENBQUYsQ0FGTjtBQUdkLFVBQUEsVUFBVSxFQUFFLFlBQVksQ0FBRSxDQUFGLENBSFY7QUFJZCxVQUFBLE9BQU8sRUFBRSxZQUFZLENBQUUsQ0FBRixDQUpQO0FBS2QsVUFBQSxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBTEU7QUFNZCxVQUFBLE1BQU0sRUFBRSxNQU5NO0FBT2QsVUFBQSxRQUFRLEVBQUU7QUFQSSxTQUFmO0FBVUEsUUFBQSw4QkFBOEIsQ0FBRSxVQUFGLEVBQWMsTUFBZCxFQUFzQixJQUF0QixDQUE5QjtBQUVBLFFBQUEsc0JBQXNCLENBQUUsTUFBRixFQUFVLElBQVYsQ0FBdEI7QUFFQSxRQUFBLE9BQU8sQ0FBQyxHQUFSLENBQWEsTUFBTSxDQUFDLFVBQVAsQ0FBbUIsVUFBVyxHQUFYLEVBQWlCO0FBRWhELGlCQUFPLEdBQUcsQ0FBQyxTQUFKLElBQWlCLEdBQUcsQ0FBQyxTQUFKLENBQWUsTUFBZixDQUF4QjtBQUVBLFNBSlksQ0FBYixFQUlNLElBSk4sQ0FJWSxZQUFZO0FBRXZCLFVBQUEsTUFBTSxDQUFFLE1BQUYsQ0FBTjtBQUVBLFNBUkQ7QUFVQSxPQXhDRCxXQXdDVyxPQXhDWDtBQTBDQTs7O1dBS0QscUJBQVk7QUFFWCxVQUFNLFFBQVEsR0FBRyxLQUFLLElBQUwsQ0FBVSxLQUFWLElBQW1CLEVBQXBDO0FBQ0EsVUFBTSxRQUFRLEdBQUcsS0FBSyxJQUFMLENBQVUsS0FBVixJQUFtQixFQUFwQztBQUNBLFVBQU0sUUFBUSxHQUFHLEtBQUssSUFBTCxDQUFVLE1BQVYsSUFBb0IsRUFBckM7O0FBSUEsV0FBTSxJQUFJLFNBQVMsR0FBRyxDQUFoQixFQUFtQixVQUFVLEdBQUcsUUFBUSxDQUFDLE1BQS9DLEVBQXVELFNBQVMsR0FBRyxVQUFuRSxFQUErRSxTQUFTLEVBQXhGLEVBQThGO0FBRTdGLFlBQU0sTUFBTSxHQUFHLFFBQVEsQ0FBRSxTQUFGLENBQVIsQ0FBc0IsTUFBckM7O0FBRUEsYUFBTSxJQUFJLENBQUMsR0FBRyxDQUFSLEVBQVcsRUFBRSxHQUFHLE1BQU0sQ0FBQyxNQUE3QixFQUFxQyxDQUFDLEdBQUcsRUFBekMsRUFBNkMsQ0FBQyxFQUE5QyxFQUFvRDtBQUVuRCxVQUFBLFFBQVEsQ0FBRSxNQUFNLENBQUUsQ0FBRixDQUFSLENBQVIsQ0FBd0IsTUFBeEIsR0FBaUMsSUFBakM7QUFFQTtBQUVEOztBQUlELFdBQU0sSUFBSSxTQUFTLEdBQUcsQ0FBaEIsRUFBbUIsVUFBVSxHQUFHLFFBQVEsQ0FBQyxNQUEvQyxFQUF1RCxTQUFTLEdBQUcsVUFBbkUsRUFBK0UsU0FBUyxFQUF4RixFQUE4RjtBQUU3RixZQUFNLE9BQU8sR0FBRyxRQUFRLENBQUUsU0FBRixDQUF4Qjs7QUFFQSxZQUFLLE9BQU8sQ0FBQyxJQUFSLEtBQWlCLFNBQXRCLEVBQWtDO0FBRWpDLGVBQUssV0FBTCxDQUFrQixLQUFLLFNBQXZCLEVBQWtDLE9BQU8sQ0FBQyxJQUExQzs7QUFLQSxjQUFLLE9BQU8sQ0FBQyxJQUFSLEtBQWlCLFNBQXRCLEVBQWtDO0FBRWpDLFlBQUEsUUFBUSxDQUFFLE9BQU8sQ0FBQyxJQUFWLENBQVIsQ0FBeUIsYUFBekIsR0FBeUMsSUFBekM7QUFFQTtBQUVEOztBQUVELFlBQUssT0FBTyxDQUFDLE1BQVIsS0FBbUIsU0FBeEIsRUFBb0M7QUFFbkMsZUFBSyxXQUFMLENBQWtCLEtBQUssV0FBdkIsRUFBb0MsT0FBTyxDQUFDLE1BQTVDO0FBRUE7QUFFRDtBQUVEOzs7V0FXRCxxQkFBYSxLQUFiLEVBQW9CLEtBQXBCLEVBQTRCO0FBRTNCLFVBQUssS0FBSyxLQUFLLFNBQWYsRUFBMkI7O0FBRTNCLFVBQUssS0FBSyxDQUFDLElBQU4sQ0FBWSxLQUFaLE1BQXdCLFNBQTdCLEVBQXlDO0FBRXhDLFFBQUEsS0FBSyxDQUFDLElBQU4sQ0FBWSxLQUFaLElBQXNCLEtBQUssQ0FBQyxJQUFOLENBQVksS0FBWixJQUFzQixDQUE1QztBQUVBOztBQUVELE1BQUEsS0FBSyxDQUFDLElBQU4sQ0FBWSxLQUFaO0FBRUE7OztXQUdELHFCQUFhLEtBQWIsRUFBb0IsS0FBcEIsRUFBMkIsTUFBM0IsRUFBb0M7QUFBQTs7QUFFbkMsVUFBSyxLQUFLLENBQUMsSUFBTixDQUFZLEtBQVosS0FBdUIsQ0FBNUIsRUFBZ0MsT0FBTyxNQUFQO0FBRWhDLFVBQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxLQUFQLEVBQVo7O0FBSUEsVUFBTSxjQUFjLEdBQUcsU0FBakIsY0FBaUIsQ0FBRSxRQUFGLEVBQVksS0FBWixFQUF1QjtBQUU3QyxZQUFNLFFBQVEsR0FBRyxNQUFJLENBQUMsWUFBTCxDQUFrQixHQUFsQixDQUF1QixRQUF2QixDQUFqQjs7QUFDQSxZQUFLLFFBQVEsSUFBSSxJQUFqQixFQUF3QjtBQUV2QixVQUFBLE1BQUksQ0FBQyxZQUFMLENBQWtCLEdBQWxCLENBQXVCLEtBQXZCLEVBQThCLFFBQTlCO0FBRUE7O0FBUDRDLG1EQVNqQixRQUFRLENBQUMsUUFBVCxDQUFrQixPQUFsQixFQVRpQjtBQUFBOztBQUFBO0FBUzdDLDhEQUEwRDtBQUFBO0FBQUEsZ0JBQTVDLENBQTRDO0FBQUEsZ0JBQXpDLEtBQXlDOztBQUV6RCxZQUFBLGNBQWMsQ0FBRSxLQUFGLEVBQVMsS0FBSyxDQUFDLFFBQU4sQ0FBZ0IsQ0FBaEIsQ0FBVCxDQUFkO0FBRUE7QUFiNEM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWU3QyxPQWZEOztBQWlCQSxNQUFBLGNBQWMsQ0FBRSxNQUFGLEVBQVUsR0FBVixDQUFkO0FBRUEsTUFBQSxHQUFHLENBQUMsSUFBSixJQUFZLGVBQWlCLEtBQUssQ0FBQyxJQUFOLENBQVksS0FBWixHQUE3QjtBQUVBLGFBQU8sR0FBUDtBQUVBOzs7V0FFRCxvQkFBWSxJQUFaLEVBQW1CO0FBRWxCLFVBQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxNQUFQLENBQWUsS0FBSyxPQUFwQixDQUFuQjtBQUNBLE1BQUEsVUFBVSxDQUFDLElBQVgsQ0FBaUIsSUFBakI7O0FBRUEsV0FBTSxJQUFJLENBQUMsR0FBRyxDQUFkLEVBQWlCLENBQUMsR0FBRyxVQUFVLENBQUMsTUFBaEMsRUFBd0MsQ0FBQyxFQUF6QyxFQUErQztBQUU5QyxZQUFNLE1BQU0sR0FBRyxJQUFJLENBQUUsVUFBVSxDQUFFLENBQUYsQ0FBWixDQUFuQjtBQUVBLFlBQUssTUFBTCxFQUFjLE9BQU8sTUFBUDtBQUVkOztBQUVELGFBQU8sSUFBUDtBQUVBOzs7V0FFRCxvQkFBWSxJQUFaLEVBQW1CO0FBRWxCLFVBQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxNQUFQLENBQWUsS0FBSyxPQUFwQixDQUFuQjtBQUNBLE1BQUEsVUFBVSxDQUFDLE9BQVgsQ0FBb0IsSUFBcEI7QUFFQSxVQUFNLE9BQU8sR0FBRyxFQUFoQjs7QUFFQSxXQUFNLElBQUksQ0FBQyxHQUFHLENBQWQsRUFBaUIsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxNQUFoQyxFQUF3QyxDQUFDLEVBQXpDLEVBQStDO0FBRTlDLFlBQU0sTUFBTSxHQUFHLElBQUksQ0FBRSxVQUFVLENBQUUsQ0FBRixDQUFaLENBQW5CO0FBRUEsWUFBSyxNQUFMLEVBQWMsT0FBTyxDQUFDLElBQVIsQ0FBYyxNQUFkO0FBRWQ7O0FBRUQsYUFBTyxPQUFQO0FBRUE7OztXQVFELHVCQUFlLElBQWYsRUFBcUIsS0FBckIsRUFBNkI7QUFFNUIsVUFBTSxRQUFRLEdBQUcsSUFBSSxHQUFHLEdBQVAsR0FBYSxLQUE5QjtBQUNBLFVBQUksVUFBVSxHQUFHLEtBQUssS0FBTCxDQUFXLEdBQVgsQ0FBZ0IsUUFBaEIsQ0FBakI7O0FBRUEsVUFBSyxDQUFFLFVBQVAsRUFBb0I7QUFFbkIsZ0JBQVMsSUFBVDtBQUVDLGVBQUssT0FBTDtBQUNDLFlBQUEsVUFBVSxHQUFHLEtBQUssU0FBTCxDQUFnQixLQUFoQixDQUFiO0FBQ0E7O0FBRUQsZUFBSyxNQUFMO0FBQ0MsWUFBQSxVQUFVLEdBQUcsS0FBSyxRQUFMLENBQWUsS0FBZixDQUFiO0FBQ0E7O0FBRUQsZUFBSyxNQUFMO0FBQ0MsWUFBQSxVQUFVLEdBQUcsS0FBSyxVQUFMLENBQWlCLFVBQVcsR0FBWCxFQUFpQjtBQUU5QyxxQkFBTyxHQUFHLENBQUMsUUFBSixJQUFnQixHQUFHLENBQUMsUUFBSixDQUFjLEtBQWQsQ0FBdkI7QUFFQSxhQUpZLENBQWI7QUFLQTs7QUFFRCxlQUFLLFVBQUw7QUFDQyxZQUFBLFVBQVUsR0FBRyxLQUFLLFlBQUwsQ0FBbUIsS0FBbkIsQ0FBYjtBQUNBOztBQUVELGVBQUssWUFBTDtBQUNDLFlBQUEsVUFBVSxHQUFHLEtBQUssVUFBTCxDQUFpQixVQUFXLEdBQVgsRUFBaUI7QUFFOUMscUJBQU8sR0FBRyxDQUFDLGNBQUosSUFBc0IsR0FBRyxDQUFDLGNBQUosQ0FBb0IsS0FBcEIsQ0FBN0I7QUFFQSxhQUpZLENBQWI7QUFLQTs7QUFFRCxlQUFLLFFBQUw7QUFDQyxZQUFBLFVBQVUsR0FBRyxLQUFLLFVBQUwsQ0FBaUIsS0FBakIsQ0FBYjtBQUNBOztBQUVELGVBQUssVUFBTDtBQUNDLFlBQUEsVUFBVSxHQUFHLEtBQUssVUFBTCxDQUFpQixVQUFXLEdBQVgsRUFBaUI7QUFFOUMscUJBQU8sR0FBRyxDQUFDLFlBQUosSUFBb0IsR0FBRyxDQUFDLFlBQUosQ0FBa0IsS0FBbEIsQ0FBM0I7QUFFQSxhQUpZLENBQWI7QUFLQTs7QUFFRCxlQUFLLFNBQUw7QUFDQyxZQUFBLFVBQVUsR0FBRyxLQUFLLFVBQUwsQ0FBaUIsVUFBVyxHQUFYLEVBQWlCO0FBRTlDLHFCQUFPLEdBQUcsQ0FBQyxXQUFKLElBQW1CLEdBQUcsQ0FBQyxXQUFKLENBQWlCLEtBQWpCLENBQTFCO0FBRUEsYUFKWSxDQUFiO0FBS0E7O0FBRUQsZUFBSyxNQUFMO0FBQ0MsWUFBQSxVQUFVLEdBQUcsS0FBSyxRQUFMLENBQWUsS0FBZixDQUFiO0FBQ0E7O0FBRUQsZUFBSyxXQUFMO0FBQ0MsWUFBQSxVQUFVLEdBQUcsS0FBSyxhQUFMLENBQW9CLEtBQXBCLENBQWI7QUFDQTs7QUFFRCxlQUFLLFFBQUw7QUFDQyxZQUFBLFVBQVUsR0FBRyxLQUFLLFVBQUwsQ0FBaUIsS0FBakIsQ0FBYjtBQUNBOztBQUVEO0FBQ0Msa0JBQU0sSUFBSSxLQUFKLENBQVcsbUJBQW1CLElBQTlCLENBQU47QUEvREY7O0FBbUVBLGFBQUssS0FBTCxDQUFXLEdBQVgsQ0FBZ0IsUUFBaEIsRUFBMEIsVUFBMUI7QUFFQTs7QUFFRCxhQUFPLFVBQVA7QUFFQTs7O1dBT0QseUJBQWlCLElBQWpCLEVBQXdCO0FBRXZCLFVBQUksWUFBWSxHQUFHLEtBQUssS0FBTCxDQUFXLEdBQVgsQ0FBZ0IsSUFBaEIsQ0FBbkI7O0FBRUEsVUFBSyxDQUFFLFlBQVAsRUFBc0I7QUFFckIsWUFBTSxNQUFNLEdBQUcsSUFBZjtBQUNBLFlBQU0sSUFBSSxHQUFHLEtBQUssSUFBTCxDQUFXLElBQUksSUFBSyxJQUFJLEtBQUssTUFBVCxHQUFrQixJQUFsQixHQUF5QixHQUE5QixDQUFmLEtBQXdELEVBQXJFO0FBRUEsUUFBQSxZQUFZLEdBQUcsT0FBTyxDQUFDLEdBQVIsQ0FBYSxJQUFJLENBQUMsR0FBTCxDQUFVLFVBQVcsR0FBWCxFQUFnQixLQUFoQixFQUF3QjtBQUU3RCxpQkFBTyxNQUFNLENBQUMsYUFBUCxDQUFzQixJQUF0QixFQUE0QixLQUE1QixDQUFQO0FBRUEsU0FKMkIsQ0FBYixDQUFmO0FBTUEsYUFBSyxLQUFMLENBQVcsR0FBWCxDQUFnQixJQUFoQixFQUFzQixZQUF0QjtBQUVBOztBQUVELGFBQU8sWUFBUDtBQUVBOzs7V0FPRCxvQkFBWSxXQUFaLEVBQTBCO0FBRXpCLFVBQU0sU0FBUyxHQUFHLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBbUIsV0FBbkIsQ0FBbEI7QUFDQSxVQUFNLE1BQU0sR0FBRyxLQUFLLFVBQXBCOztBQUVBLFVBQUssU0FBUyxDQUFDLElBQVYsSUFBa0IsU0FBUyxDQUFDLElBQVYsS0FBbUIsYUFBMUMsRUFBMEQ7QUFFekQsY0FBTSxJQUFJLEtBQUosQ0FBVyx1QkFBdUIsU0FBUyxDQUFDLElBQWpDLEdBQXdDLGdDQUFuRCxDQUFOO0FBRUE7O0FBR0QsVUFBSyxTQUFTLENBQUMsR0FBVixLQUFrQixTQUFsQixJQUErQixXQUFXLEtBQUssQ0FBcEQsRUFBd0Q7QUFFdkQsZUFBTyxPQUFPLENBQUMsT0FBUixDQUFpQixLQUFLLFVBQUwsQ0FBaUIsVUFBVSxDQUFDLGVBQTVCLEVBQThDLElBQS9ELENBQVA7QUFFQTs7QUFFRCxVQUFNLE9BQU8sR0FBRyxLQUFLLE9BQXJCO0FBRUEsYUFBTyxJQUFJLE9BQUosQ0FBYSxVQUFXLE9BQVgsRUFBb0IsTUFBcEIsRUFBNkI7QUFFaEQsUUFBQSxNQUFNLENBQUMsSUFBUCxDQUFhLG1CQUFZLFVBQVosQ0FBd0IsU0FBUyxDQUFDLEdBQWxDLEVBQXVDLE9BQU8sQ0FBQyxJQUEvQyxDQUFiLEVBQW9FLE9BQXBFLEVBQTZFLFNBQTdFLEVBQXdGLFlBQVk7QUFFbkcsVUFBQSxNQUFNLENBQUUsSUFBSSxLQUFKLENBQVcsOENBQThDLFNBQVMsQ0FBQyxHQUF4RCxHQUE4RCxJQUF6RSxDQUFGLENBQU47QUFFQSxTQUpEO0FBTUEsT0FSTSxDQUFQO0FBVUE7OztXQU9ELHdCQUFnQixlQUFoQixFQUFrQztBQUVqQyxVQUFNLGFBQWEsR0FBRyxLQUFLLElBQUwsQ0FBVSxXQUFWLENBQXVCLGVBQXZCLENBQXRCO0FBRUEsYUFBTyxLQUFLLGFBQUwsQ0FBb0IsUUFBcEIsRUFBOEIsYUFBYSxDQUFDLE1BQTVDLEVBQXFELElBQXJELENBQTJELFVBQVcsTUFBWCxFQUFvQjtBQUVyRixZQUFNLFVBQVUsR0FBRyxhQUFhLENBQUMsVUFBZCxJQUE0QixDQUEvQztBQUNBLFlBQU0sVUFBVSxHQUFHLGFBQWEsQ0FBQyxVQUFkLElBQTRCLENBQS9DO0FBQ0EsZUFBTyxNQUFNLENBQUMsS0FBUCxDQUFjLFVBQWQsRUFBMEIsVUFBVSxHQUFHLFVBQXZDLENBQVA7QUFFQSxPQU5NLENBQVA7QUFRQTs7O1dBT0Qsc0JBQWMsYUFBZCxFQUE4QjtBQUU3QixVQUFNLE1BQU0sR0FBRyxJQUFmO0FBQ0EsVUFBTSxJQUFJLEdBQUcsS0FBSyxJQUFsQjtBQUVBLFVBQU0sV0FBVyxHQUFHLEtBQUssSUFBTCxDQUFVLFNBQVYsQ0FBcUIsYUFBckIsQ0FBcEI7O0FBRUEsVUFBSyxXQUFXLENBQUMsVUFBWixLQUEyQixTQUEzQixJQUF3QyxXQUFXLENBQUMsTUFBWixLQUF1QixTQUFwRSxFQUFnRjtBQUsvRSxlQUFPLE9BQU8sQ0FBQyxPQUFSLENBQWlCLElBQWpCLENBQVA7QUFFQTs7QUFFRCxVQUFNLGtCQUFrQixHQUFHLEVBQTNCOztBQUVBLFVBQUssV0FBVyxDQUFDLFVBQVosS0FBMkIsU0FBaEMsRUFBNEM7QUFFM0MsUUFBQSxrQkFBa0IsQ0FBQyxJQUFuQixDQUF5QixLQUFLLGFBQUwsQ0FBb0IsWUFBcEIsRUFBa0MsV0FBVyxDQUFDLFVBQTlDLENBQXpCO0FBRUEsT0FKRCxNQUlPO0FBRU4sUUFBQSxrQkFBa0IsQ0FBQyxJQUFuQixDQUF5QixJQUF6QjtBQUVBOztBQUVELFVBQUssV0FBVyxDQUFDLE1BQVosS0FBdUIsU0FBNUIsRUFBd0M7QUFFdkMsUUFBQSxrQkFBa0IsQ0FBQyxJQUFuQixDQUF5QixLQUFLLGFBQUwsQ0FBb0IsWUFBcEIsRUFBa0MsV0FBVyxDQUFDLE1BQVosQ0FBbUIsT0FBbkIsQ0FBMkIsVUFBN0QsQ0FBekI7QUFDQSxRQUFBLGtCQUFrQixDQUFDLElBQW5CLENBQXlCLEtBQUssYUFBTCxDQUFvQixZQUFwQixFQUFrQyxXQUFXLENBQUMsTUFBWixDQUFtQixNQUFuQixDQUEwQixVQUE1RCxDQUF6QjtBQUVBOztBQUVELGFBQU8sT0FBTyxDQUFDLEdBQVIsQ0FBYSxrQkFBYixFQUFrQyxJQUFsQyxDQUF3QyxVQUFXLFdBQVgsRUFBeUI7QUFFdkUsWUFBTSxVQUFVLEdBQUcsV0FBVyxDQUFFLENBQUYsQ0FBOUI7QUFFQSxZQUFNLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBRSxXQUFXLENBQUMsSUFBZCxDQUFqQztBQUNBLFlBQU0sVUFBVSxHQUFHLHFCQUFxQixDQUFFLFdBQVcsQ0FBQyxhQUFkLENBQXhDO0FBR0EsWUFBTSxZQUFZLEdBQUcsVUFBVSxDQUFDLGlCQUFoQztBQUNBLFlBQU0sU0FBUyxHQUFHLFlBQVksR0FBRyxRQUFqQztBQUNBLFlBQU0sVUFBVSxHQUFHLFdBQVcsQ0FBQyxVQUFaLElBQTBCLENBQTdDO0FBQ0EsWUFBTSxVQUFVLEdBQUcsV0FBVyxDQUFDLFVBQVosS0FBMkIsU0FBM0IsR0FBdUMsSUFBSSxDQUFDLFdBQUwsQ0FBa0IsV0FBVyxDQUFDLFVBQTlCLEVBQTJDLFVBQWxGLEdBQStGLFNBQWxIO0FBQ0EsWUFBTSxVQUFVLEdBQUcsV0FBVyxDQUFDLFVBQVosS0FBMkIsSUFBOUM7QUFDQSxZQUFJLEtBQUosRUFBVyxlQUFYOztBQUdBLFlBQUssVUFBVSxJQUFJLFVBQVUsS0FBSyxTQUFsQyxFQUE4QztBQUk3QyxjQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBTCxDQUFZLFVBQVUsR0FBRyxVQUF6QixDQUFoQjtBQUNBLGNBQU0sVUFBVSxHQUFHLHVCQUF1QixXQUFXLENBQUMsVUFBbkMsR0FBZ0QsR0FBaEQsR0FBc0QsV0FBVyxDQUFDLGFBQWxFLEdBQWtGLEdBQWxGLEdBQXdGLE9BQXhGLEdBQWtHLEdBQWxHLEdBQXdHLFdBQVcsQ0FBQyxLQUF2STtBQUNBLGNBQUksRUFBRSxHQUFHLE1BQU0sQ0FBQyxLQUFQLENBQWEsR0FBYixDQUFrQixVQUFsQixDQUFUOztBQUVBLGNBQUssQ0FBRSxFQUFQLEVBQVk7QUFFWCxZQUFBLEtBQUssR0FBRyxJQUFJLFVBQUosQ0FBZ0IsVUFBaEIsRUFBNEIsT0FBTyxHQUFHLFVBQXRDLEVBQWtELFdBQVcsQ0FBQyxLQUFaLEdBQW9CLFVBQXBCLEdBQWlDLFlBQW5GLENBQVI7QUFHQSxZQUFBLEVBQUUsR0FBRyxJQUFJLHdCQUFKLENBQXVCLEtBQXZCLEVBQThCLFVBQVUsR0FBRyxZQUEzQyxDQUFMO0FBRUEsWUFBQSxNQUFNLENBQUMsS0FBUCxDQUFhLEdBQWIsQ0FBa0IsVUFBbEIsRUFBOEIsRUFBOUI7QUFFQTs7QUFFRCxVQUFBLGVBQWUsR0FBRyxJQUFJLGlDQUFKLENBQWdDLEVBQWhDLEVBQW9DLFFBQXBDLEVBQWdELFVBQVUsR0FBRyxVQUFmLEdBQThCLFlBQTVFLEVBQTBGLFVBQTFGLENBQWxCO0FBRUEsU0FyQkQsTUFxQk87QUFFTixjQUFLLFVBQVUsS0FBSyxJQUFwQixFQUEyQjtBQUUxQixZQUFBLEtBQUssR0FBRyxJQUFJLFVBQUosQ0FBZ0IsV0FBVyxDQUFDLEtBQVosR0FBb0IsUUFBcEMsQ0FBUjtBQUVBLFdBSkQsTUFJTztBQUVOLFlBQUEsS0FBSyxHQUFHLElBQUksVUFBSixDQUFnQixVQUFoQixFQUE0QixVQUE1QixFQUF3QyxXQUFXLENBQUMsS0FBWixHQUFvQixRQUE1RCxDQUFSO0FBRUE7O0FBRUQsVUFBQSxlQUFlLEdBQUcsSUFBSSxzQkFBSixDQUFxQixLQUFyQixFQUE0QixRQUE1QixFQUFzQyxVQUF0QyxDQUFsQjtBQUVBOztBQUdELFlBQUssV0FBVyxDQUFDLE1BQVosS0FBdUIsU0FBNUIsRUFBd0M7QUFFdkMsY0FBTSxlQUFlLEdBQUcsZ0JBQWdCLENBQUMsTUFBekM7QUFDQSxjQUFNLGlCQUFpQixHQUFHLHFCQUFxQixDQUFFLFdBQVcsQ0FBQyxNQUFaLENBQW1CLE9BQW5CLENBQTJCLGFBQTdCLENBQS9DO0FBRUEsY0FBTSxpQkFBaUIsR0FBRyxXQUFXLENBQUMsTUFBWixDQUFtQixPQUFuQixDQUEyQixVQUEzQixJQUF5QyxDQUFuRTtBQUNBLGNBQU0sZ0JBQWdCLEdBQUcsV0FBVyxDQUFDLE1BQVosQ0FBbUIsTUFBbkIsQ0FBMEIsVUFBMUIsSUFBd0MsQ0FBakU7QUFFQSxjQUFNLGFBQWEsR0FBRyxJQUFJLGlCQUFKLENBQXVCLFdBQVcsQ0FBRSxDQUFGLENBQWxDLEVBQXlDLGlCQUF6QyxFQUE0RCxXQUFXLENBQUMsTUFBWixDQUFtQixLQUFuQixHQUEyQixlQUF2RixDQUF0QjtBQUNBLGNBQU0sWUFBWSxHQUFHLElBQUksVUFBSixDQUFnQixXQUFXLENBQUUsQ0FBRixDQUEzQixFQUFrQyxnQkFBbEMsRUFBb0QsV0FBVyxDQUFDLE1BQVosQ0FBbUIsS0FBbkIsR0FBMkIsUUFBL0UsQ0FBckI7O0FBRUEsY0FBSyxVQUFVLEtBQUssSUFBcEIsRUFBMkI7QUFHMUIsWUFBQSxlQUFlLEdBQUcsSUFBSSxzQkFBSixDQUFxQixlQUFlLENBQUMsS0FBaEIsQ0FBc0IsS0FBdEIsRUFBckIsRUFBb0QsZUFBZSxDQUFDLFFBQXBFLEVBQThFLGVBQWUsQ0FBQyxVQUE5RixDQUFsQjtBQUVBOztBQUVELGVBQU0sSUFBSSxDQUFDLEdBQUcsQ0FBUixFQUFXLEVBQUUsR0FBRyxhQUFhLENBQUMsTUFBcEMsRUFBNEMsQ0FBQyxHQUFHLEVBQWhELEVBQW9ELENBQUMsRUFBckQsRUFBMkQ7QUFFMUQsZ0JBQU0sS0FBSyxHQUFHLGFBQWEsQ0FBRSxDQUFGLENBQTNCO0FBRUEsWUFBQSxlQUFlLENBQUMsSUFBaEIsQ0FBc0IsS0FBdEIsRUFBNkIsWUFBWSxDQUFFLENBQUMsR0FBRyxRQUFOLENBQXpDO0FBQ0EsZ0JBQUssUUFBUSxJQUFJLENBQWpCLEVBQXFCLGVBQWUsQ0FBQyxJQUFoQixDQUFzQixLQUF0QixFQUE2QixZQUFZLENBQUUsQ0FBQyxHQUFHLFFBQUosR0FBZSxDQUFqQixDQUF6QztBQUNyQixnQkFBSyxRQUFRLElBQUksQ0FBakIsRUFBcUIsZUFBZSxDQUFDLElBQWhCLENBQXNCLEtBQXRCLEVBQTZCLFlBQVksQ0FBRSxDQUFDLEdBQUcsUUFBSixHQUFlLENBQWpCLENBQXpDO0FBQ3JCLGdCQUFLLFFBQVEsSUFBSSxDQUFqQixFQUFxQixlQUFlLENBQUMsSUFBaEIsQ0FBc0IsS0FBdEIsRUFBNkIsWUFBWSxDQUFFLENBQUMsR0FBRyxRQUFKLEdBQWUsQ0FBakIsQ0FBekM7QUFDckIsZ0JBQUssUUFBUSxJQUFJLENBQWpCLEVBQXFCLE1BQU0sSUFBSSxLQUFKLENBQVcsbUVBQVgsQ0FBTjtBQUVyQjtBQUVEOztBQUVELGVBQU8sZUFBUDtBQUVBLE9BeEZNLENBQVA7QUEwRkE7OztXQU9ELHFCQUFhLFlBQWIsRUFBNEI7QUFFM0IsVUFBTSxJQUFJLEdBQUcsS0FBSyxJQUFsQjtBQUNBLFVBQU0sT0FBTyxHQUFHLEtBQUssT0FBckI7QUFDQSxVQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsUUFBTCxDQUFlLFlBQWYsQ0FBbkI7QUFDQSxVQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTCxDQUFhLFVBQVUsQ0FBQyxNQUF4QixDQUFmO0FBRUEsVUFBSSxNQUFNLEdBQUcsS0FBSyxhQUFsQjs7QUFFQSxVQUFLLE1BQU0sQ0FBQyxHQUFaLEVBQWtCO0FBRWpCLFlBQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFSLENBQWdCLFVBQWhCLENBQTRCLE1BQU0sQ0FBQyxHQUFuQyxDQUFoQjtBQUNBLFlBQUssT0FBTyxLQUFLLElBQWpCLEVBQXdCLE1BQU0sR0FBRyxPQUFUO0FBRXhCOztBQUVELGFBQU8sS0FBSyxnQkFBTCxDQUF1QixZQUF2QixFQUFxQyxNQUFyQyxFQUE2QyxNQUE3QyxDQUFQO0FBRUE7OztXQUVELDBCQUFrQixZQUFsQixFQUFnQyxNQUFoQyxFQUF3QyxNQUF4QyxFQUFpRDtBQUVoRCxVQUFNLE1BQU0sR0FBRyxJQUFmO0FBQ0EsVUFBTSxJQUFJLEdBQUcsS0FBSyxJQUFsQjtBQUNBLFVBQU0sT0FBTyxHQUFHLEtBQUssT0FBckI7QUFFQSxVQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsUUFBTCxDQUFlLFlBQWYsQ0FBbkI7QUFFQSxVQUFNLFFBQVEsR0FBRyxDQUFFLE1BQU0sQ0FBQyxHQUFQLElBQWMsTUFBTSxDQUFDLFVBQXZCLElBQXNDLEdBQXRDLEdBQTRDLFVBQVUsQ0FBQyxPQUF4RTs7QUFFQSxVQUFLLEtBQUssWUFBTCxDQUFtQixRQUFuQixDQUFMLEVBQXFDO0FBR3BDLGVBQU8sS0FBSyxZQUFMLENBQW1CLFFBQW5CLENBQVA7QUFFQTs7QUFFRCxVQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBTCxJQUFZLElBQUksQ0FBQyxTQUE3QjtBQUVBLFVBQUksU0FBUyxHQUFHLE1BQU0sQ0FBQyxHQUFQLElBQWMsRUFBOUI7QUFDQSxVQUFJLFdBQVcsR0FBRyxLQUFsQjs7QUFFQSxVQUFLLE1BQU0sQ0FBQyxVQUFQLEtBQXNCLFNBQTNCLEVBQXVDO0FBSXRDLFFBQUEsU0FBUyxHQUFHLE1BQU0sQ0FBQyxhQUFQLENBQXNCLFlBQXRCLEVBQW9DLE1BQU0sQ0FBQyxVQUEzQyxFQUF3RCxJQUF4RCxDQUE4RCxVQUFXLFVBQVgsRUFBd0I7QUFFakcsVUFBQSxXQUFXLEdBQUcsSUFBZDtBQUNBLGNBQU0sSUFBSSxHQUFHLElBQUksSUFBSixDQUFVLENBQUUsVUFBRixDQUFWLEVBQTBCO0FBQUUsWUFBQSxJQUFJLEVBQUUsTUFBTSxDQUFDO0FBQWYsV0FBMUIsQ0FBYjtBQUNBLFVBQUEsU0FBUyxHQUFHLEdBQUcsQ0FBQyxlQUFKLENBQXFCLElBQXJCLENBQVo7QUFDQSxpQkFBTyxTQUFQO0FBRUEsU0FQVyxDQUFaO0FBU0EsT0FiRCxNQWFPLElBQUssTUFBTSxDQUFDLEdBQVAsS0FBZSxTQUFwQixFQUFnQztBQUV0QyxjQUFNLElBQUksS0FBSixDQUFXLDZCQUE2QixZQUE3QixHQUE0QyxnQ0FBdkQsQ0FBTjtBQUVBOztBQUVELFVBQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFSLENBQWlCLFNBQWpCLEVBQTZCLElBQTdCLENBQW1DLFVBQVcsU0FBWCxFQUF1QjtBQUV6RSxlQUFPLElBQUksT0FBSixDQUFhLFVBQVcsT0FBWCxFQUFvQixNQUFwQixFQUE2QjtBQUVoRCxjQUFJLE1BQU0sR0FBRyxPQUFiOztBQUVBLGNBQUssTUFBTSxDQUFDLG1CQUFQLEtBQStCLElBQXBDLEVBQTJDO0FBRTFDLFlBQUEsTUFBTSxHQUFHLGdCQUFXLFdBQVgsRUFBeUI7QUFFakMsa0JBQU0sT0FBTyxHQUFHLElBQUksY0FBSixDQUFhLFdBQWIsQ0FBaEI7QUFDQSxjQUFBLE9BQU8sQ0FBQyxXQUFSLEdBQXNCLElBQXRCO0FBRUEsY0FBQSxPQUFPLENBQUUsT0FBRixDQUFQO0FBRUEsYUFQRDtBQVNBOztBQUVELFVBQUEsTUFBTSxDQUFDLElBQVAsQ0FBYSxtQkFBWSxVQUFaLENBQXdCLFNBQXhCLEVBQW1DLE9BQU8sQ0FBQyxJQUEzQyxDQUFiLEVBQWdFLE1BQWhFLEVBQXdFLFNBQXhFLEVBQW1GLE1BQW5GO0FBRUEsU0FuQk0sQ0FBUDtBQXFCQSxPQXZCZSxFQXVCWixJQXZCWSxDQXVCTixVQUFXLE9BQVgsRUFBcUI7QUFJOUIsWUFBSyxXQUFXLEtBQUssSUFBckIsRUFBNEI7QUFFM0IsVUFBQSxHQUFHLENBQUMsZUFBSixDQUFxQixTQUFyQjtBQUVBOztBQUVELFFBQUEsT0FBTyxDQUFDLEtBQVIsR0FBZ0IsS0FBaEI7QUFFQSxZQUFLLFVBQVUsQ0FBQyxJQUFoQixFQUF1QixPQUFPLENBQUMsSUFBUixHQUFlLFVBQVUsQ0FBQyxJQUExQjtBQUV2QixZQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBTCxJQUFpQixFQUFsQztBQUNBLFlBQU0sT0FBTyxHQUFHLFFBQVEsQ0FBRSxVQUFVLENBQUMsT0FBYixDQUFSLElBQWtDLEVBQWxEO0FBRUEsUUFBQSxPQUFPLENBQUMsU0FBUixHQUFvQixhQUFhLENBQUUsT0FBTyxDQUFDLFNBQVYsQ0FBYixJQUFzQyxtQkFBMUQ7QUFDQSxRQUFBLE9BQU8sQ0FBQyxTQUFSLEdBQW9CLGFBQWEsQ0FBRSxPQUFPLENBQUMsU0FBVixDQUFiLElBQXNDLCtCQUExRDtBQUNBLFFBQUEsT0FBTyxDQUFDLEtBQVIsR0FBZ0IsZUFBZSxDQUFFLE9BQU8sQ0FBQyxLQUFWLENBQWYsSUFBb0MscUJBQXBEO0FBQ0EsUUFBQSxPQUFPLENBQUMsS0FBUixHQUFnQixlQUFlLENBQUUsT0FBTyxDQUFDLEtBQVYsQ0FBZixJQUFvQyxxQkFBcEQ7QUFFQSxRQUFBLE1BQU0sQ0FBQyxZQUFQLENBQW9CLEdBQXBCLENBQXlCLE9BQXpCLEVBQWtDO0FBQUUsVUFBQSxRQUFRLEVBQUU7QUFBWixTQUFsQztBQUVBLGVBQU8sT0FBUDtBQUVBLE9BakRlLFdBaURMLFlBQVk7QUFFdEIsUUFBQSxPQUFPLENBQUMsS0FBUixDQUFlLDBDQUFmLEVBQTJELFNBQTNEO0FBQ0EsZUFBTyxJQUFQO0FBRUEsT0F0RGUsQ0FBaEI7QUF3REEsV0FBSyxZQUFMLENBQW1CLFFBQW5CLElBQWdDLE9BQWhDO0FBRUEsYUFBTyxPQUFQO0FBRUE7OztXQVNELHVCQUFlLGNBQWYsRUFBK0IsT0FBL0IsRUFBd0MsTUFBeEMsRUFBaUQ7QUFFaEQsVUFBTSxNQUFNLEdBQUcsSUFBZjtBQUVBLGFBQU8sS0FBSyxhQUFMLENBQW9CLFNBQXBCLEVBQStCLE1BQU0sQ0FBQyxLQUF0QyxFQUE4QyxJQUE5QyxDQUFvRCxVQUFXLE9BQVgsRUFBcUI7QUFJL0UsWUFBSyxNQUFNLENBQUMsUUFBUCxLQUFvQixTQUFwQixJQUFpQyxNQUFNLENBQUMsUUFBUCxJQUFtQixDQUFwRCxJQUF5RCxFQUFJLE9BQU8sS0FBSyxPQUFaLElBQXVCLE1BQU0sQ0FBQyxRQUFQLElBQW1CLENBQTlDLENBQTlELEVBQWtIO0FBRWpILFVBQUEsT0FBTyxDQUFDLElBQVIsQ0FBYyxxQ0FBcUMsTUFBTSxDQUFDLFFBQTVDLEdBQXVELGVBQXZELEdBQXlFLE9BQXpFLEdBQW1GLHFCQUFqRztBQUVBOztBQUVELFlBQUssTUFBTSxDQUFDLFVBQVAsQ0FBbUIsVUFBVSxDQUFDLHFCQUE5QixDQUFMLEVBQTZEO0FBRTVELGNBQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxVQUFQLEtBQXNCLFNBQXRCLEdBQWtDLE1BQU0sQ0FBQyxVQUFQLENBQW1CLFVBQVUsQ0FBQyxxQkFBOUIsQ0FBbEMsR0FBMEYsU0FBNUc7O0FBRUEsY0FBSyxTQUFMLEVBQWlCO0FBRWhCLGdCQUFNLGFBQWEsR0FBRyxNQUFNLENBQUMsWUFBUCxDQUFvQixHQUFwQixDQUF5QixPQUF6QixDQUF0QjtBQUNBLFlBQUEsT0FBTyxHQUFHLE1BQU0sQ0FBQyxVQUFQLENBQW1CLFVBQVUsQ0FBQyxxQkFBOUIsRUFBc0QsYUFBdEQsQ0FBcUUsT0FBckUsRUFBOEUsU0FBOUUsQ0FBVjtBQUNBLFlBQUEsTUFBTSxDQUFDLFlBQVAsQ0FBb0IsR0FBcEIsQ0FBeUIsT0FBekIsRUFBa0MsYUFBbEM7QUFFQTtBQUVEOztBQUVELFFBQUEsY0FBYyxDQUFFLE9BQUYsQ0FBZCxHQUE0QixPQUE1QjtBQUVBLGVBQU8sT0FBUDtBQUVBLE9BNUJNLENBQVA7QUE4QkE7OztXQVVELDZCQUFxQixJQUFyQixFQUE0QjtBQUUzQixVQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBdEI7QUFDQSxVQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBcEI7QUFFQSxVQUFNLHFCQUFxQixHQUFHLFFBQVEsQ0FBQyxVQUFULENBQW9CLE9BQXBCLEtBQWdDLFNBQTlEO0FBQ0EsVUFBTSxlQUFlLEdBQUcsUUFBUSxDQUFDLFVBQVQsQ0FBb0IsS0FBcEIsS0FBOEIsU0FBdEQ7QUFDQSxVQUFNLGNBQWMsR0FBRyxRQUFRLENBQUMsVUFBVCxDQUFvQixNQUFwQixLQUErQixTQUF0RDs7QUFFQSxVQUFLLElBQUksQ0FBQyxRQUFWLEVBQXFCO0FBRXBCLFlBQU0sUUFBUSxHQUFHLG9CQUFvQixRQUFRLENBQUMsSUFBOUM7QUFFQSxZQUFJLGNBQWMsR0FBRyxLQUFLLEtBQUwsQ0FBVyxHQUFYLENBQWdCLFFBQWhCLENBQXJCOztBQUVBLFlBQUssQ0FBRSxjQUFQLEVBQXdCO0FBRXZCLFVBQUEsY0FBYyxHQUFHLElBQUkscUJBQUosRUFBakI7O0FBQ0EsMEJBQVMsU0FBVCxDQUFtQixJQUFuQixDQUF3QixJQUF4QixDQUE4QixjQUE5QixFQUE4QyxRQUE5Qzs7QUFDQSxVQUFBLGNBQWMsQ0FBQyxLQUFmLENBQXFCLElBQXJCLENBQTJCLFFBQVEsQ0FBQyxLQUFwQztBQUNBLFVBQUEsY0FBYyxDQUFDLEdBQWYsR0FBcUIsUUFBUSxDQUFDLEdBQTlCO0FBQ0EsVUFBQSxjQUFjLENBQUMsZUFBZixHQUFpQyxLQUFqQztBQUVBLGVBQUssS0FBTCxDQUFXLEdBQVgsQ0FBZ0IsUUFBaEIsRUFBMEIsY0FBMUI7QUFFQTs7QUFFRCxRQUFBLFFBQVEsR0FBRyxjQUFYO0FBRUEsT0FwQkQsTUFvQk8sSUFBSyxJQUFJLENBQUMsTUFBVixFQUFtQjtBQUV6QixZQUFNLFNBQVEsR0FBRyx1QkFBdUIsUUFBUSxDQUFDLElBQWpEOztBQUVBLFlBQUksWUFBWSxHQUFHLEtBQUssS0FBTCxDQUFXLEdBQVgsQ0FBZ0IsU0FBaEIsQ0FBbkI7O0FBRUEsWUFBSyxDQUFFLFlBQVAsRUFBc0I7QUFFckIsVUFBQSxZQUFZLEdBQUcsSUFBSSx3QkFBSixFQUFmOztBQUNBLDBCQUFTLFNBQVQsQ0FBbUIsSUFBbkIsQ0FBd0IsSUFBeEIsQ0FBOEIsWUFBOUIsRUFBNEMsUUFBNUM7O0FBQ0EsVUFBQSxZQUFZLENBQUMsS0FBYixDQUFtQixJQUFuQixDQUF5QixRQUFRLENBQUMsS0FBbEM7QUFFQSxlQUFLLEtBQUwsQ0FBVyxHQUFYLENBQWdCLFNBQWhCLEVBQTBCLFlBQTFCO0FBRUE7O0FBRUQsUUFBQSxRQUFRLEdBQUcsWUFBWDtBQUVBOztBQUdELFVBQUsscUJBQXFCLElBQUksZUFBekIsSUFBNEMsY0FBakQsRUFBa0U7QUFFakUsWUFBSSxVQUFRLEdBQUcsb0JBQW9CLFFBQVEsQ0FBQyxJQUE3QixHQUFvQyxHQUFuRDs7QUFFQSxZQUFLLFFBQVEsQ0FBQyxnQ0FBZCxFQUFpRCxVQUFRLElBQUksc0JBQVo7QUFDakQsWUFBSyxxQkFBTCxFQUE2QixVQUFRLElBQUksc0JBQVo7QUFDN0IsWUFBSyxlQUFMLEVBQXVCLFVBQVEsSUFBSSxnQkFBWjtBQUN2QixZQUFLLGNBQUwsRUFBc0IsVUFBUSxJQUFJLGVBQVo7QUFFdEIsWUFBSSxjQUFjLEdBQUcsS0FBSyxLQUFMLENBQVcsR0FBWCxDQUFnQixVQUFoQixDQUFyQjs7QUFFQSxZQUFLLENBQUUsY0FBUCxFQUF3QjtBQUV2QixVQUFBLGNBQWMsR0FBRyxRQUFRLENBQUMsS0FBVCxFQUFqQjtBQUVBLGNBQUssZUFBTCxFQUF1QixjQUFjLENBQUMsWUFBZixHQUE4QixJQUE5QjtBQUN2QixjQUFLLGNBQUwsRUFBc0IsY0FBYyxDQUFDLFdBQWYsR0FBNkIsSUFBN0I7O0FBRXRCLGNBQUsscUJBQUwsRUFBNkI7QUFHNUIsZ0JBQUssY0FBYyxDQUFDLFdBQXBCLEVBQWtDLGNBQWMsQ0FBQyxXQUFmLENBQTJCLENBQTNCLElBQWdDLENBQUUsQ0FBbEM7QUFDbEMsZ0JBQUssY0FBYyxDQUFDLG9CQUFwQixFQUEyQyxjQUFjLENBQUMsb0JBQWYsQ0FBb0MsQ0FBcEMsSUFBeUMsQ0FBRSxDQUEzQztBQUUzQzs7QUFFRCxlQUFLLEtBQUwsQ0FBVyxHQUFYLENBQWdCLFVBQWhCLEVBQTBCLGNBQTFCO0FBRUEsZUFBSyxZQUFMLENBQWtCLEdBQWxCLENBQXVCLGNBQXZCLEVBQXVDLEtBQUssWUFBTCxDQUFrQixHQUFsQixDQUF1QixRQUF2QixDQUF2QztBQUVBOztBQUVELFFBQUEsUUFBUSxHQUFHLGNBQVg7QUFFQTs7QUFJRCxVQUFLLFFBQVEsQ0FBQyxLQUFULElBQWtCLFFBQVEsQ0FBQyxVQUFULENBQW9CLEdBQXBCLEtBQTRCLFNBQTlDLElBQTJELFFBQVEsQ0FBQyxVQUFULENBQW9CLEVBQXBCLEtBQTJCLFNBQTNGLEVBQXVHO0FBRXRHLFFBQUEsUUFBUSxDQUFDLFlBQVQsQ0FBdUIsS0FBdkIsRUFBOEIsUUFBUSxDQUFDLFVBQVQsQ0FBb0IsRUFBbEQ7QUFFQTs7QUFFRCxNQUFBLElBQUksQ0FBQyxRQUFMLEdBQWdCLFFBQWhCO0FBRUE7OztXQUVELDJCQUF1QztBQUV0QyxhQUFPLDJCQUFQO0FBRUE7OztXQU9ELHNCQUFjLGFBQWQsRUFBOEI7QUFFN0IsVUFBTSxNQUFNLEdBQUcsSUFBZjtBQUNBLFVBQU0sSUFBSSxHQUFHLEtBQUssSUFBbEI7QUFDQSxVQUFNLFVBQVUsR0FBRyxLQUFLLFVBQXhCO0FBQ0EsVUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLFNBQUwsQ0FBZ0IsYUFBaEIsQ0FBcEI7QUFFQSxVQUFJLFlBQUo7QUFDQSxVQUFNLGNBQWMsR0FBRyxFQUF2QjtBQUNBLFVBQU0sa0JBQWtCLEdBQUcsV0FBVyxDQUFDLFVBQVosSUFBMEIsRUFBckQ7QUFFQSxVQUFNLE9BQU8sR0FBRyxFQUFoQjs7QUFFQSxVQUFLLGtCQUFrQixDQUFFLFVBQVUsQ0FBQyxxQ0FBYixDQUF2QixFQUE4RTtBQUU3RSxZQUFNLFdBQVcsR0FBRyxVQUFVLENBQUUsVUFBVSxDQUFDLHFDQUFiLENBQTlCO0FBQ0EsUUFBQSxZQUFZLEdBQUcsV0FBVyxDQUFDLGVBQVosRUFBZjtBQUNBLFFBQUEsT0FBTyxDQUFDLElBQVIsQ0FBYyxXQUFXLENBQUMsWUFBWixDQUEwQixjQUExQixFQUEwQyxXQUExQyxFQUF1RCxNQUF2RCxDQUFkO0FBRUEsT0FORCxNQU1PLElBQUssa0JBQWtCLENBQUUsVUFBVSxDQUFDLG1CQUFiLENBQXZCLEVBQTREO0FBRWxFLFlBQU0sWUFBWSxHQUFHLFVBQVUsQ0FBRSxVQUFVLENBQUMsbUJBQWIsQ0FBL0I7QUFDQSxRQUFBLFlBQVksR0FBRyxZQUFZLENBQUMsZUFBYixFQUFmO0FBQ0EsUUFBQSxPQUFPLENBQUMsSUFBUixDQUFjLFlBQVksQ0FBQyxZQUFiLENBQTJCLGNBQTNCLEVBQTJDLFdBQTNDLEVBQXdELE1BQXhELENBQWQ7QUFFQSxPQU5NLE1BTUE7QUFLTixZQUFNLGlCQUFpQixHQUFHLFdBQVcsQ0FBQyxvQkFBWixJQUFvQyxFQUE5RDtBQUVBLFFBQUEsY0FBYyxDQUFDLEtBQWYsR0FBdUIsSUFBSSxZQUFKLENBQVcsR0FBWCxFQUFnQixHQUFoQixFQUFxQixHQUFyQixDQUF2QjtBQUNBLFFBQUEsY0FBYyxDQUFDLE9BQWYsR0FBeUIsR0FBekI7O0FBRUEsWUFBSyxLQUFLLENBQUMsT0FBTixDQUFlLGlCQUFpQixDQUFDLGVBQWpDLENBQUwsRUFBMEQ7QUFFekQsY0FBTSxLQUFLLEdBQUcsaUJBQWlCLENBQUMsZUFBaEM7QUFFQSxVQUFBLGNBQWMsQ0FBQyxLQUFmLENBQXFCLFNBQXJCLENBQWdDLEtBQWhDO0FBQ0EsVUFBQSxjQUFjLENBQUMsT0FBZixHQUF5QixLQUFLLENBQUUsQ0FBRixDQUE5QjtBQUVBOztBQUVELFlBQUssaUJBQWlCLENBQUMsZ0JBQWxCLEtBQXVDLFNBQTVDLEVBQXdEO0FBRXZELFVBQUEsT0FBTyxDQUFDLElBQVIsQ0FBYyxNQUFNLENBQUMsYUFBUCxDQUFzQixjQUF0QixFQUFzQyxLQUF0QyxFQUE2QyxpQkFBaUIsQ0FBQyxnQkFBL0QsQ0FBZDtBQUVBOztBQUVELFFBQUEsY0FBYyxDQUFDLFNBQWYsR0FBMkIsaUJBQWlCLENBQUMsY0FBbEIsS0FBcUMsU0FBckMsR0FBaUQsaUJBQWlCLENBQUMsY0FBbkUsR0FBb0YsR0FBL0c7QUFDQSxRQUFBLGNBQWMsQ0FBQyxTQUFmLEdBQTJCLGlCQUFpQixDQUFDLGVBQWxCLEtBQXNDLFNBQXRDLEdBQWtELGlCQUFpQixDQUFDLGVBQXBFLEdBQXNGLEdBQWpIOztBQUVBLFlBQUssaUJBQWlCLENBQUMsd0JBQWxCLEtBQStDLFNBQXBELEVBQWdFO0FBRS9ELFVBQUEsT0FBTyxDQUFDLElBQVIsQ0FBYyxNQUFNLENBQUMsYUFBUCxDQUFzQixjQUF0QixFQUFzQyxjQUF0QyxFQUFzRCxpQkFBaUIsQ0FBQyx3QkFBeEUsQ0FBZDtBQUNBLFVBQUEsT0FBTyxDQUFDLElBQVIsQ0FBYyxNQUFNLENBQUMsYUFBUCxDQUFzQixjQUF0QixFQUFzQyxjQUF0QyxFQUFzRCxpQkFBaUIsQ0FBQyx3QkFBeEUsQ0FBZDtBQUVBOztBQUVELFFBQUEsWUFBWSxHQUFHLEtBQUssVUFBTCxDQUFpQixVQUFXLEdBQVgsRUFBaUI7QUFFaEQsaUJBQU8sR0FBRyxDQUFDLGVBQUosSUFBdUIsR0FBRyxDQUFDLGVBQUosQ0FBcUIsYUFBckIsQ0FBOUI7QUFFQSxTQUpjLENBQWY7QUFNQSxRQUFBLE9BQU8sQ0FBQyxJQUFSLENBQWMsT0FBTyxDQUFDLEdBQVIsQ0FBYSxLQUFLLFVBQUwsQ0FBaUIsVUFBVyxHQUFYLEVBQWlCO0FBRTVELGlCQUFPLEdBQUcsQ0FBQyxvQkFBSixJQUE0QixHQUFHLENBQUMsb0JBQUosQ0FBMEIsYUFBMUIsRUFBeUMsY0FBekMsQ0FBbkM7QUFFQSxTQUowQixDQUFiLENBQWQ7QUFNQTs7QUFFRCxVQUFLLFdBQVcsQ0FBQyxXQUFaLEtBQTRCLElBQWpDLEVBQXdDO0FBRXZDLFFBQUEsY0FBYyxDQUFDLElBQWYsR0FBc0IsaUJBQXRCO0FBRUE7O0FBRUQsVUFBTSxTQUFTLEdBQUcsV0FBVyxDQUFDLFNBQVosSUFBeUIsV0FBVyxDQUFDLE1BQXZEOztBQUVBLFVBQUssU0FBUyxLQUFLLFdBQVcsQ0FBQyxLQUEvQixFQUF1QztBQUV0QyxRQUFBLGNBQWMsQ0FBQyxXQUFmLEdBQTZCLElBQTdCO0FBR0EsUUFBQSxjQUFjLENBQUMsVUFBZixHQUE0QixLQUE1QjtBQUVBLE9BUEQsTUFPTztBQUVOLFFBQUEsY0FBYyxDQUFDLE1BQWYsR0FBd0IsZ0JBQXhCO0FBQ0EsUUFBQSxjQUFjLENBQUMsV0FBZixHQUE2QixLQUE3Qjs7QUFFQSxZQUFLLFNBQVMsS0FBSyxXQUFXLENBQUMsSUFBL0IsRUFBc0M7QUFFckMsVUFBQSxjQUFjLENBQUMsU0FBZixHQUEyQixXQUFXLENBQUMsV0FBWixLQUE0QixTQUE1QixHQUF3QyxXQUFXLENBQUMsV0FBcEQsR0FBa0UsR0FBN0Y7QUFFQTtBQUVEOztBQUVELFVBQUssV0FBVyxDQUFDLGFBQVosS0FBOEIsU0FBOUIsSUFBMkMsWUFBWSxLQUFLLHdCQUFqRSxFQUFxRjtBQUVwRixRQUFBLE9BQU8sQ0FBQyxJQUFSLENBQWMsTUFBTSxDQUFDLGFBQVAsQ0FBc0IsY0FBdEIsRUFBc0MsV0FBdEMsRUFBbUQsV0FBVyxDQUFDLGFBQS9ELENBQWQ7QUFFQSxRQUFBLGNBQWMsQ0FBQyxXQUFmLEdBQTZCLElBQUksY0FBSixDQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FBN0I7O0FBRUEsWUFBSyxXQUFXLENBQUMsYUFBWixDQUEwQixLQUExQixLQUFvQyxTQUF6QyxFQUFxRDtBQUVwRCxjQUFNLEtBQUssR0FBRyxXQUFXLENBQUMsYUFBWixDQUEwQixLQUF4QztBQUVBLFVBQUEsY0FBYyxDQUFDLFdBQWYsQ0FBMkIsR0FBM0IsQ0FBZ0MsS0FBaEMsRUFBdUMsS0FBdkM7QUFFQTtBQUVEOztBQUVELFVBQUssV0FBVyxDQUFDLGdCQUFaLEtBQWlDLFNBQWpDLElBQThDLFlBQVksS0FBSyx3QkFBcEUsRUFBd0Y7QUFFdkYsUUFBQSxPQUFPLENBQUMsSUFBUixDQUFjLE1BQU0sQ0FBQyxhQUFQLENBQXNCLGNBQXRCLEVBQXNDLE9BQXRDLEVBQStDLFdBQVcsQ0FBQyxnQkFBM0QsQ0FBZDs7QUFFQSxZQUFLLFdBQVcsQ0FBQyxnQkFBWixDQUE2QixRQUE3QixLQUEwQyxTQUEvQyxFQUEyRDtBQUUxRCxVQUFBLGNBQWMsQ0FBQyxjQUFmLEdBQWdDLFdBQVcsQ0FBQyxnQkFBWixDQUE2QixRQUE3RDtBQUVBO0FBRUQ7O0FBRUQsVUFBSyxXQUFXLENBQUMsY0FBWixLQUErQixTQUEvQixJQUE0QyxZQUFZLEtBQUssd0JBQWxFLEVBQXNGO0FBRXJGLFFBQUEsY0FBYyxDQUFDLFFBQWYsR0FBMEIsSUFBSSxZQUFKLEdBQVksU0FBWixDQUF1QixXQUFXLENBQUMsY0FBbkMsQ0FBMUI7QUFFQTs7QUFFRCxVQUFLLFdBQVcsQ0FBQyxlQUFaLEtBQWdDLFNBQWhDLElBQTZDLFlBQVksS0FBSyx3QkFBbkUsRUFBdUY7QUFFdEYsUUFBQSxPQUFPLENBQUMsSUFBUixDQUFjLE1BQU0sQ0FBQyxhQUFQLENBQXNCLGNBQXRCLEVBQXNDLGFBQXRDLEVBQXFELFdBQVcsQ0FBQyxlQUFqRSxDQUFkO0FBRUE7O0FBRUQsYUFBTyxPQUFPLENBQUMsR0FBUixDQUFhLE9BQWIsRUFBdUIsSUFBdkIsQ0FBNkIsWUFBWTtBQUUvQyxZQUFJLFFBQUo7O0FBRUEsWUFBSyxZQUFZLEtBQUssMEJBQXRCLEVBQW1EO0FBRWxELFVBQUEsUUFBUSxHQUFHLFVBQVUsQ0FBRSxVQUFVLENBQUMscUNBQWIsQ0FBVixDQUErRCxjQUEvRCxDQUErRSxjQUEvRSxDQUFYO0FBRUEsU0FKRCxNQUlPO0FBRU4sVUFBQSxRQUFRLEdBQUcsSUFBSSxZQUFKLENBQWtCLGNBQWxCLENBQVg7QUFFQTs7QUFFRCxZQUFLLFdBQVcsQ0FBQyxJQUFqQixFQUF3QixRQUFRLENBQUMsSUFBVCxHQUFnQixXQUFXLENBQUMsSUFBNUI7QUFHeEIsWUFBSyxRQUFRLENBQUMsR0FBZCxFQUFvQixRQUFRLENBQUMsR0FBVCxDQUFhLFFBQWIsR0FBd0IsbUJBQXhCO0FBQ3BCLFlBQUssUUFBUSxDQUFDLFdBQWQsRUFBNEIsUUFBUSxDQUFDLFdBQVQsQ0FBcUIsUUFBckIsR0FBZ0MsbUJBQWhDO0FBRTVCLFFBQUEsc0JBQXNCLENBQUUsUUFBRixFQUFZLFdBQVosQ0FBdEI7QUFFQSxRQUFBLE1BQU0sQ0FBQyxZQUFQLENBQW9CLEdBQXBCLENBQXlCLFFBQXpCLEVBQW1DO0FBQUUsVUFBQSxTQUFTLEVBQUU7QUFBYixTQUFuQztBQUVBLFlBQUssV0FBVyxDQUFDLFVBQWpCLEVBQThCLDhCQUE4QixDQUFFLFVBQUYsRUFBYyxRQUFkLEVBQXdCLFdBQXhCLENBQTlCO0FBRTlCLGVBQU8sUUFBUDtBQUVBLE9BNUJNLENBQVA7QUE4QkE7OztXQUdELDBCQUFrQixZQUFsQixFQUFpQztBQUVoQyxVQUFNLGFBQWEsR0FBRyx1QkFBZ0IsZ0JBQWhCLENBQWtDLFlBQVksSUFBSSxFQUFsRCxDQUF0Qjs7QUFFQSxVQUFJLElBQUksR0FBRyxhQUFYOztBQUVBLFdBQU0sSUFBSSxDQUFDLEdBQUcsQ0FBZCxFQUFpQixLQUFLLGFBQUwsQ0FBb0IsSUFBcEIsQ0FBakIsRUFBNkMsRUFBRyxDQUFoRCxFQUFvRDtBQUVuRCxRQUFBLElBQUksR0FBRyxhQUFhLEdBQUcsR0FBaEIsR0FBc0IsQ0FBN0I7QUFFQTs7QUFFRCxXQUFLLGFBQUwsQ0FBb0IsSUFBcEIsSUFBNkIsSUFBN0I7QUFFQSxhQUFPLElBQVA7QUFFQTs7O1dBVUQsd0JBQWdCLFVBQWhCLEVBQTZCO0FBRTVCLFVBQU0sTUFBTSxHQUFHLElBQWY7QUFDQSxVQUFNLFVBQVUsR0FBRyxLQUFLLFVBQXhCO0FBQ0EsVUFBTSxLQUFLLEdBQUcsS0FBSyxjQUFuQjs7QUFFQSxlQUFTLG9CQUFULENBQStCLFNBQS9CLEVBQTJDO0FBRTFDLGVBQU8sVUFBVSxDQUFFLFVBQVUsQ0FBQywwQkFBYixDQUFWLENBQ0wsZUFESyxDQUNZLFNBRFosRUFDdUIsTUFEdkIsRUFFTCxJQUZLLENBRUMsVUFBVyxRQUFYLEVBQXNCO0FBRTVCLGlCQUFPLHNCQUFzQixDQUFFLFFBQUYsRUFBWSxTQUFaLEVBQXVCLE1BQXZCLENBQTdCO0FBRUEsU0FOSyxDQUFQO0FBUUE7O0FBRUQsVUFBTSxPQUFPLEdBQUcsRUFBaEI7O0FBRUEsV0FBTSxJQUFJLENBQUMsR0FBRyxDQUFSLEVBQVcsRUFBRSxHQUFHLFVBQVUsQ0FBQyxNQUFqQyxFQUF5QyxDQUFDLEdBQUcsRUFBN0MsRUFBaUQsQ0FBQyxFQUFsRCxFQUF3RDtBQUV2RCxZQUFNLFNBQVMsR0FBRyxVQUFVLENBQUUsQ0FBRixDQUE1QjtBQUNBLFlBQU0sUUFBUSxHQUFHLGtCQUFrQixDQUFFLFNBQUYsQ0FBbkM7QUFHQSxZQUFNLE1BQU0sR0FBRyxLQUFLLENBQUUsUUFBRixDQUFwQjs7QUFFQSxZQUFLLE1BQUwsRUFBYztBQUdiLFVBQUEsT0FBTyxDQUFDLElBQVIsQ0FBYyxNQUFNLENBQUMsT0FBckI7QUFFQSxTQUxELE1BS087QUFFTixjQUFJLGVBQWUsU0FBbkI7O0FBRUEsY0FBSyxTQUFTLENBQUMsVUFBVixJQUF3QixTQUFTLENBQUMsVUFBVixDQUFzQixVQUFVLENBQUMsMEJBQWpDLENBQTdCLEVBQTZGO0FBRzVGLFlBQUEsZUFBZSxHQUFHLG9CQUFvQixDQUFFLFNBQUYsQ0FBdEM7QUFFQSxXQUxELE1BS087QUFHTixZQUFBLGVBQWUsR0FBRyxzQkFBc0IsQ0FBRSxJQUFJLHFCQUFKLEVBQUYsRUFBd0IsU0FBeEIsRUFBbUMsTUFBbkMsQ0FBeEM7QUFFQTs7QUFHRCxVQUFBLEtBQUssQ0FBRSxRQUFGLENBQUwsR0FBb0I7QUFBRSxZQUFBLFNBQVMsRUFBRSxTQUFiO0FBQXdCLFlBQUEsT0FBTyxFQUFFO0FBQWpDLFdBQXBCO0FBRUEsVUFBQSxPQUFPLENBQUMsSUFBUixDQUFjLGVBQWQ7QUFFQTtBQUVEOztBQUVELGFBQU8sT0FBTyxDQUFDLEdBQVIsQ0FBYSxPQUFiLENBQVA7QUFFQTs7O1dBT0Qsa0JBQVUsU0FBVixFQUFzQjtBQUVyQixVQUFNLE1BQU0sR0FBRyxJQUFmO0FBQ0EsVUFBTSxJQUFJLEdBQUcsS0FBSyxJQUFsQjtBQUNBLFVBQU0sVUFBVSxHQUFHLEtBQUssVUFBeEI7QUFFQSxVQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTCxDQUFhLFNBQWIsQ0FBaEI7QUFDQSxVQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsVUFBM0I7QUFFQSxVQUFNLE9BQU8sR0FBRyxFQUFoQjs7QUFFQSxXQUFNLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxFQUFFLEdBQUcsVUFBVSxDQUFDLE1BQWpDLEVBQXlDLENBQUMsR0FBRyxFQUE3QyxFQUFpRCxDQUFDLEVBQWxELEVBQXdEO0FBRXZELFlBQU0sUUFBUSxHQUFHLFVBQVUsQ0FBRSxDQUFGLENBQVYsQ0FBZ0IsUUFBaEIsS0FBNkIsU0FBN0IsR0FDZCxxQkFBcUIsQ0FBRSxLQUFLLEtBQVAsQ0FEUCxHQUVkLEtBQUssYUFBTCxDQUFvQixVQUFwQixFQUFnQyxVQUFVLENBQUUsQ0FBRixDQUFWLENBQWdCLFFBQWhELENBRkg7QUFJQSxRQUFBLE9BQU8sQ0FBQyxJQUFSLENBQWMsUUFBZDtBQUVBOztBQUVELE1BQUEsT0FBTyxDQUFDLElBQVIsQ0FBYyxNQUFNLENBQUMsY0FBUCxDQUF1QixVQUF2QixDQUFkO0FBRUEsYUFBTyxPQUFPLENBQUMsR0FBUixDQUFhLE9BQWIsRUFBdUIsSUFBdkIsQ0FBNkIsVUFBVyxPQUFYLEVBQXFCO0FBRXhELFlBQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxLQUFSLENBQWUsQ0FBZixFQUFrQixPQUFPLENBQUMsTUFBUixHQUFpQixDQUFuQyxDQUFsQjtBQUNBLFlBQU0sVUFBVSxHQUFHLE9BQU8sQ0FBRSxPQUFPLENBQUMsTUFBUixHQUFpQixDQUFuQixDQUExQjtBQUVBLFlBQU0sTUFBTSxHQUFHLEVBQWY7O0FBRUEsYUFBTSxJQUFJLEdBQUMsR0FBRyxDQUFSLEVBQVcsSUFBRSxHQUFHLFVBQVUsQ0FBQyxNQUFqQyxFQUF5QyxHQUFDLEdBQUcsSUFBN0MsRUFBaUQsR0FBQyxFQUFsRCxFQUF3RDtBQUV2RCxjQUFNLFFBQVEsR0FBRyxVQUFVLENBQUUsR0FBRixDQUEzQjtBQUNBLGNBQU0sU0FBUyxHQUFHLFVBQVUsQ0FBRSxHQUFGLENBQTVCO0FBSUEsY0FBSSxJQUFJLFNBQVI7QUFFQSxjQUFNLFNBQVEsR0FBRyxTQUFTLENBQUUsR0FBRixDQUExQjs7QUFFQSxjQUFLLFNBQVMsQ0FBQyxJQUFWLEtBQW1CLGVBQWUsQ0FBQyxTQUFuQyxJQUNILFNBQVMsQ0FBQyxJQUFWLEtBQW1CLGVBQWUsQ0FBQyxjQURoQyxJQUVILFNBQVMsQ0FBQyxJQUFWLEtBQW1CLGVBQWUsQ0FBQyxZQUZoQyxJQUdILFNBQVMsQ0FBQyxJQUFWLEtBQW1CLFNBSHJCLEVBR2lDO0FBR2hDLFlBQUEsSUFBSSxHQUFHLE9BQU8sQ0FBQyxhQUFSLEtBQTBCLElBQTFCLEdBQ0osSUFBSSxrQkFBSixDQUFpQixRQUFqQixFQUEyQixTQUEzQixDQURJLEdBRUosSUFBSSxXQUFKLENBQVUsUUFBVixFQUFvQixTQUFwQixDQUZIOztBQUlBLGdCQUFLLElBQUksQ0FBQyxhQUFMLEtBQXVCLElBQXZCLElBQStCLENBQUUsSUFBSSxDQUFDLFFBQUwsQ0FBYyxVQUFkLENBQXlCLFVBQXpCLENBQW9DLFVBQTFFLEVBQXVGO0FBSXRGLGNBQUEsSUFBSSxDQUFDLG9CQUFMO0FBRUE7O0FBRUQsZ0JBQUssU0FBUyxDQUFDLElBQVYsS0FBbUIsZUFBZSxDQUFDLGNBQXhDLEVBQXlEO0FBRXhELGNBQUEsSUFBSSxDQUFDLFFBQUwsR0FBZ0IsbUJBQW1CLENBQUUsSUFBSSxDQUFDLFFBQVAsRUFBaUIsNEJBQWpCLENBQW5DO0FBRUEsYUFKRCxNQUlPLElBQUssU0FBUyxDQUFDLElBQVYsS0FBbUIsZUFBZSxDQUFDLFlBQXhDLEVBQXVEO0FBRTdELGNBQUEsSUFBSSxDQUFDLFFBQUwsR0FBZ0IsbUJBQW1CLENBQUUsSUFBSSxDQUFDLFFBQVAsRUFBaUIsMEJBQWpCLENBQW5DO0FBRUE7QUFFRCxXQTVCRCxNQTRCTyxJQUFLLFNBQVMsQ0FBQyxJQUFWLEtBQW1CLGVBQWUsQ0FBQyxLQUF4QyxFQUFnRDtBQUV0RCxZQUFBLElBQUksR0FBRyxJQUFJLG1CQUFKLENBQWtCLFFBQWxCLEVBQTRCLFNBQTVCLENBQVA7QUFFQSxXQUpNLE1BSUEsSUFBSyxTQUFTLENBQUMsSUFBVixLQUFtQixlQUFlLENBQUMsVUFBeEMsRUFBcUQ7QUFFM0QsWUFBQSxJQUFJLEdBQUcsSUFBSSxXQUFKLENBQVUsUUFBVixFQUFvQixTQUFwQixDQUFQO0FBRUEsV0FKTSxNQUlBLElBQUssU0FBUyxDQUFDLElBQVYsS0FBbUIsZUFBZSxDQUFDLFNBQXhDLEVBQW9EO0FBRTFELFlBQUEsSUFBSSxHQUFHLElBQUksZUFBSixDQUFjLFFBQWQsRUFBd0IsU0FBeEIsQ0FBUDtBQUVBLFdBSk0sTUFJQSxJQUFLLFNBQVMsQ0FBQyxJQUFWLEtBQW1CLGVBQWUsQ0FBQyxNQUF4QyxFQUFpRDtBQUV2RCxZQUFBLElBQUksR0FBRyxJQUFJLGFBQUosQ0FBWSxRQUFaLEVBQXNCLFNBQXRCLENBQVA7QUFFQSxXQUpNLE1BSUE7QUFFTixrQkFBTSxJQUFJLEtBQUosQ0FBVyxtREFBbUQsU0FBUyxDQUFDLElBQXhFLENBQU47QUFFQTs7QUFFRCxjQUFLLE1BQU0sQ0FBQyxJQUFQLENBQWEsSUFBSSxDQUFDLFFBQUwsQ0FBYyxlQUEzQixFQUE2QyxNQUE3QyxHQUFzRCxDQUEzRCxFQUErRDtBQUU5RCxZQUFBLGtCQUFrQixDQUFFLElBQUYsRUFBUSxPQUFSLENBQWxCO0FBRUE7O0FBRUQsVUFBQSxJQUFJLENBQUMsSUFBTCxHQUFZLE1BQU0sQ0FBQyxnQkFBUCxDQUF5QixPQUFPLENBQUMsSUFBUixJQUFrQixVQUFVLFNBQXJELENBQVo7QUFFQSxVQUFBLHNCQUFzQixDQUFFLElBQUYsRUFBUSxPQUFSLENBQXRCO0FBRUEsY0FBSyxTQUFTLENBQUMsVUFBZixFQUE0Qiw4QkFBOEIsQ0FBRSxVQUFGLEVBQWMsSUFBZCxFQUFvQixTQUFwQixDQUE5QjtBQUU1QixVQUFBLE1BQU0sQ0FBQyxtQkFBUCxDQUE0QixJQUE1QjtBQUVBLFVBQUEsTUFBTSxDQUFDLElBQVAsQ0FBYSxJQUFiO0FBRUE7O0FBRUQsYUFBTSxJQUFJLEdBQUMsR0FBRyxDQUFSLEVBQVcsSUFBRSxHQUFHLE1BQU0sQ0FBQyxNQUE3QixFQUFxQyxHQUFDLEdBQUcsSUFBekMsRUFBNkMsR0FBQyxFQUE5QyxFQUFvRDtBQUVuRCxVQUFBLE1BQU0sQ0FBQyxZQUFQLENBQW9CLEdBQXBCLENBQXlCLE1BQU0sQ0FBRSxHQUFGLENBQS9CLEVBQXNDO0FBQ3JDLFlBQUEsTUFBTSxFQUFFLFNBRDZCO0FBRXJDLFlBQUEsVUFBVSxFQUFFO0FBRnlCLFdBQXRDO0FBS0E7O0FBRUQsWUFBSyxNQUFNLENBQUMsTUFBUCxLQUFrQixDQUF2QixFQUEyQjtBQUUxQixpQkFBTyxNQUFNLENBQUUsQ0FBRixDQUFiO0FBRUE7O0FBRUQsWUFBTSxLQUFLLEdBQUcsSUFBSSxZQUFKLEVBQWQ7QUFFQSxRQUFBLE1BQU0sQ0FBQyxZQUFQLENBQW9CLEdBQXBCLENBQXlCLEtBQXpCLEVBQWdDO0FBQUUsVUFBQSxNQUFNLEVBQUU7QUFBVixTQUFoQzs7QUFFQSxhQUFNLElBQUksR0FBQyxHQUFHLENBQVIsRUFBVyxJQUFFLEdBQUcsTUFBTSxDQUFDLE1BQTdCLEVBQXFDLEdBQUMsR0FBRyxJQUF6QyxFQUE2QyxHQUFDLEVBQTlDLEVBQW9EO0FBRW5ELFVBQUEsS0FBSyxDQUFDLEdBQU4sQ0FBVyxNQUFNLENBQUUsR0FBRixDQUFqQjtBQUVBOztBQUVELGVBQU8sS0FBUDtBQUVBLE9BakhNLENBQVA7QUFtSEE7OztXQU9ELG9CQUFZLFdBQVosRUFBMEI7QUFFekIsVUFBSSxNQUFKO0FBQ0EsVUFBTSxTQUFTLEdBQUcsS0FBSyxJQUFMLENBQVUsT0FBVixDQUFtQixXQUFuQixDQUFsQjtBQUNBLFVBQU0sTUFBTSxHQUFHLFNBQVMsQ0FBRSxTQUFTLENBQUMsSUFBWixDQUF4Qjs7QUFFQSxVQUFLLENBQUUsTUFBUCxFQUFnQjtBQUVmLFFBQUEsT0FBTyxDQUFDLElBQVIsQ0FBYyw4Q0FBZDtBQUNBO0FBRUE7O0FBRUQsVUFBSyxTQUFTLENBQUMsSUFBVixLQUFtQixhQUF4QixFQUF3QztBQUV2QyxRQUFBLE1BQU0sR0FBRyxJQUFJLHdCQUFKLENBQXVCLGlCQUFVLFFBQVYsQ0FBb0IsTUFBTSxDQUFDLElBQTNCLENBQXZCLEVBQTBELE1BQU0sQ0FBQyxXQUFQLElBQXNCLENBQWhGLEVBQW1GLE1BQU0sQ0FBQyxLQUFQLElBQWdCLENBQW5HLEVBQXNHLE1BQU0sQ0FBQyxJQUFQLElBQWUsR0FBckgsQ0FBVDtBQUVBLE9BSkQsTUFJTyxJQUFLLFNBQVMsQ0FBQyxJQUFWLEtBQW1CLGNBQXhCLEVBQXlDO0FBRS9DLFFBQUEsTUFBTSxHQUFHLElBQUkseUJBQUosQ0FBd0IsQ0FBRSxNQUFNLENBQUMsSUFBakMsRUFBdUMsTUFBTSxDQUFDLElBQTlDLEVBQW9ELE1BQU0sQ0FBQyxJQUEzRCxFQUFpRSxDQUFFLE1BQU0sQ0FBQyxJQUExRSxFQUFnRixNQUFNLENBQUMsS0FBdkYsRUFBOEYsTUFBTSxDQUFDLElBQXJHLENBQVQ7QUFFQTs7QUFFRCxVQUFLLFNBQVMsQ0FBQyxJQUFmLEVBQXNCLE1BQU0sQ0FBQyxJQUFQLEdBQWMsS0FBSyxnQkFBTCxDQUF1QixTQUFTLENBQUMsSUFBakMsQ0FBZDtBQUV0QixNQUFBLHNCQUFzQixDQUFFLE1BQUYsRUFBVSxTQUFWLENBQXRCO0FBRUEsYUFBTyxPQUFPLENBQUMsT0FBUixDQUFpQixNQUFqQixDQUFQO0FBRUE7OztXQU9ELGtCQUFVLFNBQVYsRUFBc0I7QUFFckIsVUFBTSxPQUFPLEdBQUcsS0FBSyxJQUFMLENBQVUsS0FBVixDQUFpQixTQUFqQixDQUFoQjtBQUVBLFVBQU0sU0FBUyxHQUFHO0FBQUUsUUFBQSxNQUFNLEVBQUUsT0FBTyxDQUFDO0FBQWxCLE9BQWxCOztBQUVBLFVBQUssT0FBTyxDQUFDLG1CQUFSLEtBQWdDLFNBQXJDLEVBQWlEO0FBRWhELGVBQU8sT0FBTyxDQUFDLE9BQVIsQ0FBaUIsU0FBakIsQ0FBUDtBQUVBOztBQUVELGFBQU8sS0FBSyxhQUFMLENBQW9CLFVBQXBCLEVBQWdDLE9BQU8sQ0FBQyxtQkFBeEMsRUFBOEQsSUFBOUQsQ0FBb0UsVUFBVyxRQUFYLEVBQXNCO0FBRWhHLFFBQUEsU0FBUyxDQUFDLG1CQUFWLEdBQWdDLFFBQWhDO0FBRUEsZUFBTyxTQUFQO0FBRUEsT0FOTSxDQUFQO0FBUUE7OztXQU9ELHVCQUFlLGNBQWYsRUFBZ0M7QUFFL0IsVUFBTSxJQUFJLEdBQUcsS0FBSyxJQUFsQjtBQUVBLFVBQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxVQUFMLENBQWlCLGNBQWpCLENBQXJCO0FBRUEsVUFBTSxZQUFZLEdBQUcsRUFBckI7QUFDQSxVQUFNLHFCQUFxQixHQUFHLEVBQTlCO0FBQ0EsVUFBTSxzQkFBc0IsR0FBRyxFQUEvQjtBQUNBLFVBQU0sZUFBZSxHQUFHLEVBQXhCO0FBQ0EsVUFBTSxjQUFjLEdBQUcsRUFBdkI7O0FBRUEsV0FBTSxJQUFJLENBQUMsR0FBRyxDQUFSLEVBQVcsRUFBRSxHQUFHLFlBQVksQ0FBQyxRQUFiLENBQXNCLE1BQTVDLEVBQW9ELENBQUMsR0FBRyxFQUF4RCxFQUE0RCxDQUFDLEVBQTdELEVBQW1FO0FBRWxFLFlBQU0sT0FBTyxHQUFHLFlBQVksQ0FBQyxRQUFiLENBQXVCLENBQXZCLENBQWhCO0FBQ0EsWUFBTSxPQUFPLEdBQUcsWUFBWSxDQUFDLFFBQWIsQ0FBdUIsT0FBTyxDQUFDLE9BQS9CLENBQWhCO0FBQ0EsWUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE1BQXZCO0FBQ0EsWUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQVAsS0FBZ0IsU0FBaEIsR0FBNEIsTUFBTSxDQUFDLElBQW5DLEdBQTBDLE1BQU0sQ0FBQyxFQUE5RDtBQUNBLFlBQU0sS0FBSyxHQUFHLFlBQVksQ0FBQyxVQUFiLEtBQTRCLFNBQTVCLEdBQXdDLFlBQVksQ0FBQyxVQUFiLENBQXlCLE9BQU8sQ0FBQyxLQUFqQyxDQUF4QyxHQUFtRixPQUFPLENBQUMsS0FBekc7QUFDQSxZQUFNLE1BQU0sR0FBRyxZQUFZLENBQUMsVUFBYixLQUE0QixTQUE1QixHQUF3QyxZQUFZLENBQUMsVUFBYixDQUF5QixPQUFPLENBQUMsTUFBakMsQ0FBeEMsR0FBb0YsT0FBTyxDQUFDLE1BQTNHO0FBRUEsUUFBQSxZQUFZLENBQUMsSUFBYixDQUFtQixLQUFLLGFBQUwsQ0FBb0IsTUFBcEIsRUFBNEIsSUFBNUIsQ0FBbkI7QUFDQSxRQUFBLHFCQUFxQixDQUFDLElBQXRCLENBQTRCLEtBQUssYUFBTCxDQUFvQixVQUFwQixFQUFnQyxLQUFoQyxDQUE1QjtBQUNBLFFBQUEsc0JBQXNCLENBQUMsSUFBdkIsQ0FBNkIsS0FBSyxhQUFMLENBQW9CLFVBQXBCLEVBQWdDLE1BQWhDLENBQTdCO0FBQ0EsUUFBQSxlQUFlLENBQUMsSUFBaEIsQ0FBc0IsT0FBdEI7QUFDQSxRQUFBLGNBQWMsQ0FBQyxJQUFmLENBQXFCLE1BQXJCO0FBRUE7O0FBRUQsYUFBTyxPQUFPLENBQUMsR0FBUixDQUFhLENBRW5CLE9BQU8sQ0FBQyxHQUFSLENBQWEsWUFBYixDQUZtQixFQUduQixPQUFPLENBQUMsR0FBUixDQUFhLHFCQUFiLENBSG1CLEVBSW5CLE9BQU8sQ0FBQyxHQUFSLENBQWEsc0JBQWIsQ0FKbUIsRUFLbkIsT0FBTyxDQUFDLEdBQVIsQ0FBYSxlQUFiLENBTG1CLEVBTW5CLE9BQU8sQ0FBQyxHQUFSLENBQWEsY0FBYixDQU5tQixDQUFiLEVBUUgsSUFSRyxDQVFHLFVBQVcsWUFBWCxFQUEwQjtBQUVuQyxZQUFNLEtBQUssR0FBRyxZQUFZLENBQUUsQ0FBRixDQUExQjtBQUNBLFlBQU0sY0FBYyxHQUFHLFlBQVksQ0FBRSxDQUFGLENBQW5DO0FBQ0EsWUFBTSxlQUFlLEdBQUcsWUFBWSxDQUFFLENBQUYsQ0FBcEM7QUFDQSxZQUFNLFFBQVEsR0FBRyxZQUFZLENBQUUsQ0FBRixDQUE3QjtBQUNBLFlBQU0sT0FBTyxHQUFHLFlBQVksQ0FBRSxDQUFGLENBQTVCO0FBRUEsWUFBTSxNQUFNLEdBQUcsRUFBZjs7QUFSbUMsbUNBVXpCLEdBVnlCLEVBVWxCLElBVmtCO0FBWWxDLGNBQU0sSUFBSSxHQUFHLEtBQUssQ0FBRSxHQUFGLENBQWxCO0FBQ0EsY0FBTSxhQUFhLEdBQUcsY0FBYyxDQUFFLEdBQUYsQ0FBcEM7QUFDQSxjQUFNLGNBQWMsR0FBRyxlQUFlLENBQUUsR0FBRixDQUF0QztBQUNBLGNBQU0sT0FBTyxHQUFHLFFBQVEsQ0FBRSxHQUFGLENBQXhCO0FBQ0EsY0FBTSxNQUFNLEdBQUcsT0FBTyxDQUFFLEdBQUYsQ0FBdEI7QUFFQSxjQUFLLElBQUksS0FBSyxTQUFkLEVBQTBCO0FBRTFCLFVBQUEsSUFBSSxDQUFDLFlBQUw7QUFDQSxVQUFBLElBQUksQ0FBQyxnQkFBTCxHQUF3QixJQUF4QjtBQUVBLGNBQUksa0JBQWtCLFNBQXRCOztBQUVBLGtCQUFTLGVBQWUsQ0FBRSxNQUFNLENBQUMsSUFBVCxDQUF4QjtBQUVDLGlCQUFLLGVBQWUsQ0FBQyxPQUFyQjtBQUVDLGNBQUEsa0JBQWtCLEdBQUcsMEJBQXJCO0FBQ0E7O0FBRUQsaUJBQUssZUFBZSxDQUFDLFFBQXJCO0FBRUMsY0FBQSxrQkFBa0IsR0FBRyw4QkFBckI7QUFDQTs7QUFFRCxpQkFBSyxlQUFlLENBQUMsUUFBckI7QUFDQSxpQkFBSyxlQUFlLENBQUMsS0FBckI7QUFDQTtBQUVDLGNBQUEsa0JBQWtCLEdBQUcsMEJBQXJCO0FBQ0E7QUFqQkY7O0FBcUJBLGNBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxJQUFMLEdBQVksSUFBSSxDQUFDLElBQWpCLEdBQXdCLElBQUksQ0FBQyxJQUFoRDtBQUVBLGNBQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxhQUFSLEtBQTBCLFNBQTFCLEdBQXNDLGFBQWEsQ0FBRSxPQUFPLENBQUMsYUFBVixDQUFuRCxHQUErRSx3QkFBckc7QUFFQSxjQUFNLFdBQVcsR0FBRyxFQUFwQjs7QUFFQSxjQUFLLGVBQWUsQ0FBRSxNQUFNLENBQUMsSUFBVCxDQUFmLEtBQW1DLGVBQWUsQ0FBQyxPQUF4RCxFQUFrRTtBQUVqRSxZQUFBLElBQUksQ0FBQyxRQUFMLENBQWUsVUFBVyxNQUFYLEVBQW9CO0FBRWxDLGtCQUFLLE1BQU0sQ0FBQyxxQkFBWixFQUFvQztBQUVuQyxnQkFBQSxXQUFXLENBQUMsSUFBWixDQUFrQixNQUFNLENBQUMsSUFBUCxHQUFjLE1BQU0sQ0FBQyxJQUFyQixHQUE0QixNQUFNLENBQUMsSUFBckQ7QUFFQTtBQUVELGFBUkQ7QUFVQSxXQVpELE1BWU87QUFFTixZQUFBLFdBQVcsQ0FBQyxJQUFaLENBQWtCLFVBQWxCO0FBRUE7O0FBRUQsY0FBSSxXQUFXLEdBQUcsY0FBYyxDQUFDLEtBQWpDOztBQUVBLGNBQUssY0FBYyxDQUFDLFVBQXBCLEVBQWlDO0FBRWhDLGdCQUFNLEtBQUssR0FBRywyQkFBMkIsQ0FBRSxXQUFXLENBQUMsV0FBZCxDQUF6QztBQUNBLGdCQUFNLE1BQU0sR0FBRyxJQUFJLFlBQUosQ0FBa0IsV0FBVyxDQUFDLE1BQTlCLENBQWY7O0FBRUEsaUJBQU0sSUFBSSxDQUFDLEdBQUcsQ0FBUixFQUFXLEVBQUUsR0FBRyxXQUFXLENBQUMsTUFBbEMsRUFBMEMsQ0FBQyxHQUFHLEVBQTlDLEVBQWtELENBQUMsRUFBbkQsRUFBeUQ7QUFFeEQsY0FBQSxNQUFNLENBQUUsQ0FBRixDQUFOLEdBQWMsV0FBVyxDQUFFLENBQUYsQ0FBWCxHQUFtQixLQUFqQztBQUVBOztBQUVELFlBQUEsV0FBVyxHQUFHLE1BQWQ7QUFFQTs7QUFFRCxlQUFNLElBQUksRUFBQyxHQUFHLENBQVIsRUFBVyxHQUFFLEdBQUcsV0FBVyxDQUFDLE1BQWxDLEVBQTBDLEVBQUMsR0FBRyxHQUE5QyxFQUFrRCxFQUFDLEVBQW5ELEVBQXlEO0FBRXhELGdCQUFNLEtBQUssR0FBRyxJQUFJLGtCQUFKLENBQ2IsV0FBVyxDQUFFLEVBQUYsQ0FBWCxHQUFtQixHQUFuQixHQUF5QixlQUFlLENBQUUsTUFBTSxDQUFDLElBQVQsQ0FEM0IsRUFFYixhQUFhLENBQUMsS0FGRCxFQUdiLFdBSGEsRUFJYixhQUphLENBQWQ7O0FBUUEsZ0JBQUssT0FBTyxDQUFDLGFBQVIsS0FBMEIsYUFBL0IsRUFBK0M7QUFFOUMsY0FBQSxLQUFLLENBQUMsaUJBQU4sR0FBMEIsU0FBUyx1Q0FBVCxDQUFrRCxNQUFsRCxFQUEyRDtBQU1wRixvQkFBTSxlQUFlLEdBQUssZ0JBQWdCLDhCQUFsQixHQUE4QyxvQ0FBOUMsR0FBcUYsMEJBQTdHO0FBRUEsdUJBQU8sSUFBSSxlQUFKLENBQXFCLEtBQUssS0FBMUIsRUFBaUMsS0FBSyxNQUF0QyxFQUE4QyxLQUFLLFlBQUwsS0FBc0IsQ0FBcEUsRUFBdUUsTUFBdkUsQ0FBUDtBQUVBLGVBVkQ7O0FBYUEsY0FBQSxLQUFLLENBQUMsaUJBQU4sQ0FBd0IseUNBQXhCLEdBQW9FLElBQXBFO0FBRUE7O0FBRUQsWUFBQSxNQUFNLENBQUMsSUFBUCxDQUFhLEtBQWI7QUFFQTtBQXRIaUM7O0FBVW5DLGFBQU0sSUFBSSxHQUFDLEdBQUcsQ0FBUixFQUFXLElBQUUsR0FBRyxLQUFLLENBQUMsTUFBNUIsRUFBb0MsR0FBQyxHQUFHLElBQXhDLEVBQTRDLEdBQUMsRUFBN0MsRUFBbUQ7QUFBQSwyQkFBekMsR0FBeUMsRUFBbEMsSUFBa0M7O0FBQUEsbUNBUXhCO0FBc0cxQjs7QUFFRCxZQUFNLElBQUksR0FBRyxZQUFZLENBQUMsSUFBYixHQUFvQixZQUFZLENBQUMsSUFBakMsR0FBd0MsZUFBZSxjQUFwRTtBQUVBLGVBQU8sSUFBSSxvQkFBSixDQUFtQixJQUFuQixFQUF5QixTQUF6QixFQUFvQyxNQUFwQyxDQUFQO0FBRUEsT0F0SU0sQ0FBUDtBQXdJQTs7O1dBRUQsd0JBQWdCLFNBQWhCLEVBQTRCO0FBRTNCLFVBQU0sSUFBSSxHQUFHLEtBQUssSUFBbEI7QUFDQSxVQUFNLE1BQU0sR0FBRyxJQUFmO0FBQ0EsVUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUwsQ0FBWSxTQUFaLENBQWhCO0FBRUEsVUFBSyxPQUFPLENBQUMsSUFBUixLQUFpQixTQUF0QixFQUFrQyxPQUFPLElBQVA7QUFFbEMsYUFBTyxNQUFNLENBQUMsYUFBUCxDQUFzQixNQUF0QixFQUE4QixPQUFPLENBQUMsSUFBdEMsRUFBNkMsSUFBN0MsQ0FBbUQsVUFBVyxJQUFYLEVBQWtCO0FBRTNFLFlBQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxXQUFQLENBQW9CLE1BQU0sQ0FBQyxTQUEzQixFQUFzQyxPQUFPLENBQUMsSUFBOUMsRUFBb0QsSUFBcEQsQ0FBYjs7QUFHQSxZQUFLLE9BQU8sQ0FBQyxPQUFSLEtBQW9CLFNBQXpCLEVBQXFDO0FBRXBDLFVBQUEsSUFBSSxDQUFDLFFBQUwsQ0FBZSxVQUFXLENBQVgsRUFBZTtBQUU3QixnQkFBSyxDQUFFLENBQUMsQ0FBQyxNQUFULEVBQWtCOztBQUVsQixpQkFBTSxJQUFJLENBQUMsR0FBRyxDQUFSLEVBQVcsRUFBRSxHQUFHLE9BQU8sQ0FBQyxPQUFSLENBQWdCLE1BQXRDLEVBQThDLENBQUMsR0FBRyxFQUFsRCxFQUFzRCxDQUFDLEVBQXZELEVBQTZEO0FBRTVELGNBQUEsQ0FBQyxDQUFDLHFCQUFGLENBQXlCLENBQXpCLElBQStCLE9BQU8sQ0FBQyxPQUFSLENBQWlCLENBQWpCLENBQS9CO0FBRUE7QUFFRCxXQVZEO0FBWUE7O0FBRUQsZUFBTyxJQUFQO0FBRUEsT0F2Qk0sQ0FBUDtBQXlCQTs7O1dBT0Qsa0JBQVUsU0FBVixFQUFzQjtBQUVyQixVQUFNLElBQUksR0FBRyxLQUFLLElBQWxCO0FBQ0EsVUFBTSxVQUFVLEdBQUcsS0FBSyxVQUF4QjtBQUNBLFVBQU0sTUFBTSxHQUFHLElBQWY7QUFFQSxVQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBTCxDQUFZLFNBQVosQ0FBaEI7QUFHQSxVQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsSUFBUixHQUFlLE1BQU0sQ0FBQyxnQkFBUCxDQUF5QixPQUFPLENBQUMsSUFBakMsQ0FBZixHQUF5RCxFQUExRTtBQUVBLGFBQVMsWUFBWTtBQUVwQixZQUFNLE9BQU8sR0FBRyxFQUFoQjs7QUFFQSxZQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsVUFBUCxDQUFtQixVQUFXLEdBQVgsRUFBaUI7QUFFdkQsaUJBQU8sR0FBRyxDQUFDLGNBQUosSUFBc0IsR0FBRyxDQUFDLGNBQUosQ0FBb0IsU0FBcEIsQ0FBN0I7QUFFQSxTQUptQixDQUFwQjs7QUFNQSxZQUFLLFdBQUwsRUFBbUI7QUFFbEIsVUFBQSxPQUFPLENBQUMsSUFBUixDQUFjLFdBQWQ7QUFFQTs7QUFFRCxZQUFLLE9BQU8sQ0FBQyxNQUFSLEtBQW1CLFNBQXhCLEVBQW9DO0FBRW5DLFVBQUEsT0FBTyxDQUFDLElBQVIsQ0FBYyxNQUFNLENBQUMsYUFBUCxDQUFzQixRQUF0QixFQUFnQyxPQUFPLENBQUMsTUFBeEMsRUFBaUQsSUFBakQsQ0FBdUQsVUFBVyxNQUFYLEVBQW9CO0FBRXhGLG1CQUFPLE1BQU0sQ0FBQyxXQUFQLENBQW9CLE1BQU0sQ0FBQyxXQUEzQixFQUF3QyxPQUFPLENBQUMsTUFBaEQsRUFBd0QsTUFBeEQsQ0FBUDtBQUVBLFdBSmEsQ0FBZDtBQU1BOztBQUVELFFBQUEsTUFBTSxDQUFDLFVBQVAsQ0FBbUIsVUFBVyxHQUFYLEVBQWlCO0FBRW5DLGlCQUFPLEdBQUcsQ0FBQyxvQkFBSixJQUE0QixHQUFHLENBQUMsb0JBQUosQ0FBMEIsU0FBMUIsQ0FBbkM7QUFFQSxTQUpELEVBSUksT0FKSixDQUlhLFVBQVcsT0FBWCxFQUFxQjtBQUVqQyxVQUFBLE9BQU8sQ0FBQyxJQUFSLENBQWMsT0FBZDtBQUVBLFNBUkQ7O0FBVUEsZUFBTyxPQUFPLENBQUMsR0FBUixDQUFhLE9BQWIsQ0FBUDtBQUVBLE9BdENRLEVBQUYsQ0FzQ0QsSUF0Q0MsQ0FzQ0ssVUFBVyxPQUFYLEVBQXFCO0FBRWhDLFlBQUksSUFBSjs7QUFHQSxZQUFLLE9BQU8sQ0FBQyxNQUFSLEtBQW1CLElBQXhCLEVBQStCO0FBRTlCLFVBQUEsSUFBSSxHQUFHLElBQUksV0FBSixFQUFQO0FBRUEsU0FKRCxNQUlPLElBQUssT0FBTyxDQUFDLE1BQVIsR0FBaUIsQ0FBdEIsRUFBMEI7QUFFaEMsVUFBQSxJQUFJLEdBQUcsSUFBSSxZQUFKLEVBQVA7QUFFQSxTQUpNLE1BSUEsSUFBSyxPQUFPLENBQUMsTUFBUixLQUFtQixDQUF4QixFQUE0QjtBQUVsQyxVQUFBLElBQUksR0FBRyxPQUFPLENBQUUsQ0FBRixDQUFkO0FBRUEsU0FKTSxNQUlBO0FBRU4sVUFBQSxJQUFJLEdBQUcsSUFBSSxlQUFKLEVBQVA7QUFFQTs7QUFFRCxZQUFLLElBQUksS0FBSyxPQUFPLENBQUUsQ0FBRixDQUFyQixFQUE2QjtBQUU1QixlQUFNLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxFQUFFLEdBQUcsT0FBTyxDQUFDLE1BQTlCLEVBQXNDLENBQUMsR0FBRyxFQUExQyxFQUE4QyxDQUFDLEVBQS9DLEVBQXFEO0FBRXBELFlBQUEsSUFBSSxDQUFDLEdBQUwsQ0FBVSxPQUFPLENBQUUsQ0FBRixDQUFqQjtBQUVBO0FBRUQ7O0FBRUQsWUFBSyxPQUFPLENBQUMsSUFBYixFQUFvQjtBQUVuQixVQUFBLElBQUksQ0FBQyxRQUFMLENBQWMsSUFBZCxHQUFxQixPQUFPLENBQUMsSUFBN0I7QUFDQSxVQUFBLElBQUksQ0FBQyxJQUFMLEdBQVksUUFBWjtBQUVBOztBQUVELFFBQUEsc0JBQXNCLENBQUUsSUFBRixFQUFRLE9BQVIsQ0FBdEI7QUFFQSxZQUFLLE9BQU8sQ0FBQyxVQUFiLEVBQTBCLDhCQUE4QixDQUFFLFVBQUYsRUFBYyxJQUFkLEVBQW9CLE9BQXBCLENBQTlCOztBQUUxQixZQUFLLE9BQU8sQ0FBQyxNQUFSLEtBQW1CLFNBQXhCLEVBQW9DO0FBRW5DLGNBQU0sTUFBTSxHQUFHLElBQUksY0FBSixFQUFmO0FBQ0EsVUFBQSxNQUFNLENBQUMsU0FBUCxDQUFrQixPQUFPLENBQUMsTUFBMUI7QUFDQSxVQUFBLElBQUksQ0FBQyxZQUFMLENBQW1CLE1BQW5CO0FBRUEsU0FORCxNQU1PO0FBRU4sY0FBSyxPQUFPLENBQUMsV0FBUixLQUF3QixTQUE3QixFQUF5QztBQUV4QyxZQUFBLElBQUksQ0FBQyxRQUFMLENBQWMsU0FBZCxDQUF5QixPQUFPLENBQUMsV0FBakM7QUFFQTs7QUFFRCxjQUFLLE9BQU8sQ0FBQyxRQUFSLEtBQXFCLFNBQTFCLEVBQXNDO0FBRXJDLFlBQUEsSUFBSSxDQUFDLFVBQUwsQ0FBZ0IsU0FBaEIsQ0FBMkIsT0FBTyxDQUFDLFFBQW5DO0FBRUE7O0FBRUQsY0FBSyxPQUFPLENBQUMsS0FBUixLQUFrQixTQUF2QixFQUFtQztBQUVsQyxZQUFBLElBQUksQ0FBQyxLQUFMLENBQVcsU0FBWCxDQUFzQixPQUFPLENBQUMsS0FBOUI7QUFFQTtBQUVEOztBQUVELFlBQUssQ0FBRSxNQUFNLENBQUMsWUFBUCxDQUFvQixHQUFwQixDQUF5QixJQUF6QixDQUFQLEVBQXlDO0FBRXhDLFVBQUEsTUFBTSxDQUFDLFlBQVAsQ0FBb0IsR0FBcEIsQ0FBeUIsSUFBekIsRUFBK0IsRUFBL0I7QUFFQTs7QUFFRCxRQUFBLE1BQU0sQ0FBQyxZQUFQLENBQW9CLEdBQXBCLENBQXlCLElBQXpCLEVBQWdDLEtBQWhDLEdBQXdDLFNBQXhDO0FBRUEsZUFBTyxJQUFQO0FBRUEsT0F4SE0sQ0FBUDtBQTBIQTs7O1dBT0QsbUJBQVcsVUFBWCxFQUF3QjtBQUV2QixVQUFNLElBQUksR0FBRyxLQUFLLElBQWxCO0FBQ0EsVUFBTSxVQUFVLEdBQUcsS0FBSyxVQUF4QjtBQUNBLFVBQU0sUUFBUSxHQUFHLEtBQUssSUFBTCxDQUFVLE1BQVYsQ0FBa0IsVUFBbEIsQ0FBakI7QUFDQSxVQUFNLE1BQU0sR0FBRyxJQUFmO0FBSUEsVUFBTSxLQUFLLEdBQUcsSUFBSSxZQUFKLEVBQWQ7QUFDQSxVQUFLLFFBQVEsQ0FBQyxJQUFkLEVBQXFCLEtBQUssQ0FBQyxJQUFOLEdBQWEsTUFBTSxDQUFDLGdCQUFQLENBQXlCLFFBQVEsQ0FBQyxJQUFsQyxDQUFiO0FBRXJCLE1BQUEsc0JBQXNCLENBQUUsS0FBRixFQUFTLFFBQVQsQ0FBdEI7QUFFQSxVQUFLLFFBQVEsQ0FBQyxVQUFkLEVBQTJCLDhCQUE4QixDQUFFLFVBQUYsRUFBYyxLQUFkLEVBQXFCLFFBQXJCLENBQTlCO0FBRTNCLFVBQU0sT0FBTyxHQUFHLFFBQVEsQ0FBQyxLQUFULElBQWtCLEVBQWxDO0FBRUEsVUFBTSxPQUFPLEdBQUcsRUFBaEI7O0FBRUEsV0FBTSxJQUFJLENBQUMsR0FBRyxDQUFSLEVBQVcsRUFBRSxHQUFHLE9BQU8sQ0FBQyxNQUE5QixFQUFzQyxDQUFDLEdBQUcsRUFBMUMsRUFBOEMsQ0FBQyxFQUEvQyxFQUFxRDtBQUVwRCxRQUFBLE9BQU8sQ0FBQyxJQUFSLENBQWMsa0JBQWtCLENBQUUsT0FBTyxDQUFFLENBQUYsQ0FBVCxFQUFnQixLQUFoQixFQUF1QixJQUF2QixFQUE2QixNQUE3QixDQUFoQztBQUVBOztBQUVELGFBQU8sT0FBTyxDQUFDLEdBQVIsQ0FBYSxPQUFiLEVBQXVCLElBQXZCLENBQTZCLFlBQVk7QUFJL0MsWUFBTSxrQkFBa0IsR0FBRyxTQUFyQixrQkFBcUIsQ0FBRSxJQUFGLEVBQVk7QUFFdEMsY0FBTSxtQkFBbUIsR0FBRyxJQUFJLEdBQUosRUFBNUI7O0FBRnNDLHNEQUlSLE1BQU0sQ0FBQyxZQUpDO0FBQUE7O0FBQUE7QUFJdEMsbUVBQW9EO0FBQUE7QUFBQSxrQkFBdEMsR0FBc0M7QUFBQSxrQkFBakMsS0FBaUM7O0FBRW5ELGtCQUFLLEdBQUcsWUFBWSxlQUFmLElBQTJCLEdBQUcsWUFBWSxjQUEvQyxFQUF5RDtBQUV4RCxnQkFBQSxtQkFBbUIsQ0FBQyxHQUFwQixDQUF5QixHQUF6QixFQUE4QixLQUE5QjtBQUVBO0FBRUQ7QUFacUM7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFjdEMsVUFBQSxJQUFJLENBQUMsUUFBTCxDQUFlLFVBQUUsSUFBRixFQUFZO0FBRTFCLGdCQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsWUFBUCxDQUFvQixHQUFwQixDQUF5QixJQUF6QixDQUFqQjs7QUFFQSxnQkFBSyxRQUFRLElBQUksSUFBakIsRUFBd0I7QUFFdkIsY0FBQSxtQkFBbUIsQ0FBQyxHQUFwQixDQUF5QixJQUF6QixFQUErQixRQUEvQjtBQUVBO0FBRUQsV0FWRDtBQVlBLGlCQUFPLG1CQUFQO0FBRUEsU0E1QkQ7O0FBOEJBLFFBQUEsTUFBTSxDQUFDLFlBQVAsR0FBc0Isa0JBQWtCLENBQUUsS0FBRixDQUF4QztBQUVBLGVBQU8sS0FBUDtBQUVBLE9BdENNLENBQVA7QUF3Q0E7Ozs7O0FBSUYsU0FBUyxrQkFBVCxDQUE2QixNQUE3QixFQUFxQyxZQUFyQyxFQUFtRCxJQUFuRCxFQUF5RCxNQUF6RCxFQUFrRTtBQUVqRSxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBTCxDQUFZLE1BQVosQ0FBaEI7QUFFQSxTQUFPLE1BQU0sQ0FBQyxhQUFQLENBQXNCLE1BQXRCLEVBQThCLE1BQTlCLEVBQXVDLElBQXZDLENBQTZDLFVBQVcsSUFBWCxFQUFrQjtBQUVyRSxRQUFLLE9BQU8sQ0FBQyxJQUFSLEtBQWlCLFNBQXRCLEVBQWtDLE9BQU8sSUFBUDtBQUlsQyxRQUFJLFNBQUo7QUFFQSxXQUFPLE1BQU0sQ0FBQyxhQUFQLENBQXNCLE1BQXRCLEVBQThCLE9BQU8sQ0FBQyxJQUF0QyxFQUE2QyxJQUE3QyxDQUFtRCxVQUFXLElBQVgsRUFBa0I7QUFFM0UsTUFBQSxTQUFTLEdBQUcsSUFBWjtBQUVBLFVBQU0sYUFBYSxHQUFHLEVBQXRCOztBQUVBLFdBQU0sSUFBSSxDQUFDLEdBQUcsQ0FBUixFQUFXLEVBQUUsR0FBRyxTQUFTLENBQUMsTUFBVixDQUFpQixNQUF2QyxFQUErQyxDQUFDLEdBQUcsRUFBbkQsRUFBdUQsQ0FBQyxFQUF4RCxFQUE4RDtBQUU3RCxRQUFBLGFBQWEsQ0FBQyxJQUFkLENBQW9CLE1BQU0sQ0FBQyxhQUFQLENBQXNCLE1BQXRCLEVBQThCLFNBQVMsQ0FBQyxNQUFWLENBQWtCLENBQWxCLENBQTlCLENBQXBCO0FBRUE7O0FBRUQsYUFBTyxPQUFPLENBQUMsR0FBUixDQUFhLGFBQWIsQ0FBUDtBQUVBLEtBZE0sRUFjSCxJQWRHLENBY0csVUFBVyxVQUFYLEVBQXdCO0FBRWpDLE1BQUEsSUFBSSxDQUFDLFFBQUwsQ0FBZSxVQUFXLElBQVgsRUFBa0I7QUFFaEMsWUFBSyxDQUFFLElBQUksQ0FBQyxNQUFaLEVBQXFCO0FBRXJCLFlBQU0sS0FBSyxHQUFHLEVBQWQ7QUFDQSxZQUFNLFlBQVksR0FBRyxFQUFyQjs7QUFFQSxhQUFNLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxFQUFFLEdBQUcsVUFBVSxDQUFDLE1BQWpDLEVBQXlDLENBQUMsR0FBRyxFQUE3QyxFQUFpRCxDQUFDLEVBQWxELEVBQXdEO0FBRXZELGNBQU0sU0FBUyxHQUFHLFVBQVUsQ0FBRSxDQUFGLENBQTVCOztBQUVBLGNBQUssU0FBTCxFQUFpQjtBQUVoQixZQUFBLEtBQUssQ0FBQyxJQUFOLENBQVksU0FBWjtBQUVBLGdCQUFNLEdBQUcsR0FBRyxJQUFJLGNBQUosRUFBWjs7QUFFQSxnQkFBSyxTQUFTLENBQUMsbUJBQVYsS0FBa0MsU0FBdkMsRUFBbUQ7QUFFbEQsY0FBQSxHQUFHLENBQUMsU0FBSixDQUFlLFNBQVMsQ0FBQyxtQkFBVixDQUE4QixLQUE3QyxFQUFvRCxDQUFDLEdBQUcsRUFBeEQ7QUFFQTs7QUFFRCxZQUFBLFlBQVksQ0FBQyxJQUFiLENBQW1CLEdBQW5CO0FBRUEsV0FkRCxNQWNPO0FBRU4sWUFBQSxPQUFPLENBQUMsSUFBUixDQUFjLGtEQUFkLEVBQWtFLFNBQVMsQ0FBQyxNQUFWLENBQWtCLENBQWxCLENBQWxFO0FBRUE7QUFFRDs7QUFFRCxRQUFBLElBQUksQ0FBQyxJQUFMLENBQVcsSUFBSSxlQUFKLENBQWMsS0FBZCxFQUFxQixZQUFyQixDQUFYLEVBQWdELElBQUksQ0FBQyxXQUFyRDtBQUVBLE9BbkNEO0FBcUNBLGFBQU8sSUFBUDtBQUVBLEtBdkRNLENBQVA7QUF5REEsR0FqRU0sRUFpRUgsSUFqRUcsQ0FpRUcsVUFBVyxJQUFYLEVBQWtCO0FBSTNCLElBQUEsWUFBWSxDQUFDLEdBQWIsQ0FBa0IsSUFBbEI7QUFFQSxRQUFNLE9BQU8sR0FBRyxFQUFoQjs7QUFFQSxRQUFLLE9BQU8sQ0FBQyxRQUFiLEVBQXdCO0FBRXZCLFVBQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxRQUF6Qjs7QUFFQSxXQUFNLElBQUksQ0FBQyxHQUFHLENBQVIsRUFBVyxFQUFFLEdBQUcsUUFBUSxDQUFDLE1BQS9CLEVBQXVDLENBQUMsR0FBRyxFQUEzQyxFQUErQyxDQUFDLEVBQWhELEVBQXNEO0FBRXJELFlBQU0sS0FBSyxHQUFHLFFBQVEsQ0FBRSxDQUFGLENBQXRCO0FBQ0EsUUFBQSxPQUFPLENBQUMsSUFBUixDQUFjLGtCQUFrQixDQUFFLEtBQUYsRUFBUyxJQUFULEVBQWUsSUFBZixFQUFxQixNQUFyQixDQUFoQztBQUVBO0FBRUQ7O0FBRUQsV0FBTyxPQUFPLENBQUMsR0FBUixDQUFhLE9BQWIsQ0FBUDtBQUVBLEdBeEZNLENBQVA7QUEwRkE7O0FBT0QsU0FBUyxhQUFULENBQXdCLFFBQXhCLEVBQWtDLFlBQWxDLEVBQWdELE1BQWhELEVBQXlEO0FBRXhELE1BQU0sVUFBVSxHQUFHLFlBQVksQ0FBQyxVQUFoQztBQUVBLE1BQU0sR0FBRyxHQUFHLElBQUksV0FBSixFQUFaOztBQUVBLE1BQUssVUFBVSxDQUFDLFFBQVgsS0FBd0IsU0FBN0IsRUFBeUM7QUFFeEMsUUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLElBQVAsQ0FBWSxTQUFaLENBQXVCLFVBQVUsQ0FBQyxRQUFsQyxDQUFqQjtBQUVBLFFBQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxHQUFyQjtBQUNBLFFBQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxHQUFyQjs7QUFJQSxRQUFLLEdBQUcsS0FBSyxTQUFSLElBQXFCLEdBQUcsS0FBSyxTQUFsQyxFQUE4QztBQUU3QyxNQUFBLEdBQUcsQ0FBQyxHQUFKLENBQ0MsSUFBSSxjQUFKLENBQWEsR0FBRyxDQUFFLENBQUYsQ0FBaEIsRUFBdUIsR0FBRyxDQUFFLENBQUYsQ0FBMUIsRUFBaUMsR0FBRyxDQUFFLENBQUYsQ0FBcEMsQ0FERCxFQUVDLElBQUksY0FBSixDQUFhLEdBQUcsQ0FBRSxDQUFGLENBQWhCLEVBQXVCLEdBQUcsQ0FBRSxDQUFGLENBQTFCLEVBQWlDLEdBQUcsQ0FBRSxDQUFGLENBQXBDLENBRkQ7O0FBS0EsVUFBSyxRQUFRLENBQUMsVUFBZCxFQUEyQjtBQUUxQixZQUFNLFFBQVEsR0FBRywyQkFBMkIsQ0FBRSxxQkFBcUIsQ0FBRSxRQUFRLENBQUMsYUFBWCxDQUF2QixDQUE1QztBQUNBLFFBQUEsR0FBRyxDQUFDLEdBQUosQ0FBUSxjQUFSLENBQXdCLFFBQXhCO0FBQ0EsUUFBQSxHQUFHLENBQUMsR0FBSixDQUFRLGNBQVIsQ0FBd0IsUUFBeEI7QUFFQTtBQUVELEtBZkQsTUFlTztBQUVOLE1BQUEsT0FBTyxDQUFDLElBQVIsQ0FBYyxxRUFBZDtBQUVBO0FBRUE7QUFFRCxHQWhDRCxNQWdDTztBQUVOO0FBRUE7O0FBRUQsTUFBTSxPQUFPLEdBQUcsWUFBWSxDQUFDLE9BQTdCOztBQUVBLE1BQUssT0FBTyxLQUFLLFNBQWpCLEVBQTZCO0FBRTVCLFFBQU0sZUFBZSxHQUFHLElBQUksY0FBSixFQUF4QjtBQUNBLFFBQU0sTUFBTSxHQUFHLElBQUksY0FBSixFQUFmOztBQUVBLFNBQU0sSUFBSSxDQUFDLEdBQUcsQ0FBUixFQUFXLEVBQUUsR0FBRyxPQUFPLENBQUMsTUFBOUIsRUFBc0MsQ0FBQyxHQUFHLEVBQTFDLEVBQThDLENBQUMsRUFBL0MsRUFBcUQ7QUFFcEQsVUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFFLENBQUYsQ0FBdEI7O0FBRUEsVUFBSyxNQUFNLENBQUMsUUFBUCxLQUFvQixTQUF6QixFQUFxQztBQUVwQyxZQUFNLFNBQVEsR0FBRyxNQUFNLENBQUMsSUFBUCxDQUFZLFNBQVosQ0FBdUIsTUFBTSxDQUFDLFFBQTlCLENBQWpCO0FBQ0EsWUFBTSxJQUFHLEdBQUcsU0FBUSxDQUFDLEdBQXJCO0FBQ0EsWUFBTSxJQUFHLEdBQUcsU0FBUSxDQUFDLEdBQXJCOztBQUlBLFlBQUssSUFBRyxLQUFLLFNBQVIsSUFBcUIsSUFBRyxLQUFLLFNBQWxDLEVBQThDO0FBRzdDLFVBQUEsTUFBTSxDQUFDLElBQVAsQ0FBYSxJQUFJLENBQUMsR0FBTCxDQUFVLElBQUksQ0FBQyxHQUFMLENBQVUsSUFBRyxDQUFFLENBQUYsQ0FBYixDQUFWLEVBQWdDLElBQUksQ0FBQyxHQUFMLENBQVUsSUFBRyxDQUFFLENBQUYsQ0FBYixDQUFoQyxDQUFiO0FBQ0EsVUFBQSxNQUFNLENBQUMsSUFBUCxDQUFhLElBQUksQ0FBQyxHQUFMLENBQVUsSUFBSSxDQUFDLEdBQUwsQ0FBVSxJQUFHLENBQUUsQ0FBRixDQUFiLENBQVYsRUFBZ0MsSUFBSSxDQUFDLEdBQUwsQ0FBVSxJQUFHLENBQUUsQ0FBRixDQUFiLENBQWhDLENBQWI7QUFDQSxVQUFBLE1BQU0sQ0FBQyxJQUFQLENBQWEsSUFBSSxDQUFDLEdBQUwsQ0FBVSxJQUFJLENBQUMsR0FBTCxDQUFVLElBQUcsQ0FBRSxDQUFGLENBQWIsQ0FBVixFQUFnQyxJQUFJLENBQUMsR0FBTCxDQUFVLElBQUcsQ0FBRSxDQUFGLENBQWIsQ0FBaEMsQ0FBYjs7QUFHQSxjQUFLLFNBQVEsQ0FBQyxVQUFkLEVBQTJCO0FBRTFCLGdCQUFNLFNBQVEsR0FBRywyQkFBMkIsQ0FBRSxxQkFBcUIsQ0FBRSxTQUFRLENBQUMsYUFBWCxDQUF2QixDQUE1Qzs7QUFDQSxZQUFBLE1BQU0sQ0FBQyxjQUFQLENBQXVCLFNBQXZCO0FBRUE7O0FBTUQsVUFBQSxlQUFlLENBQUMsR0FBaEIsQ0FBcUIsTUFBckI7QUFFQSxTQXJCRCxNQXFCTztBQUVOLFVBQUEsT0FBTyxDQUFDLElBQVIsQ0FBYyxxRUFBZDtBQUVBO0FBRUQ7QUFFRDs7QUFHRCxJQUFBLEdBQUcsQ0FBQyxjQUFKLENBQW9CLGVBQXBCO0FBRUE7O0FBRUQsRUFBQSxRQUFRLENBQUMsV0FBVCxHQUF1QixHQUF2QjtBQUVBLE1BQU0sTUFBTSxHQUFHLElBQUksYUFBSixFQUFmO0FBRUEsRUFBQSxHQUFHLENBQUMsU0FBSixDQUFlLE1BQU0sQ0FBQyxNQUF0QjtBQUNBLEVBQUEsTUFBTSxDQUFDLE1BQVAsR0FBZ0IsR0FBRyxDQUFDLEdBQUosQ0FBUSxVQUFSLENBQW9CLEdBQUcsQ0FBQyxHQUF4QixJQUFnQyxDQUFoRDtBQUVBLEVBQUEsUUFBUSxDQUFDLGNBQVQsR0FBMEIsTUFBMUI7QUFFQTs7QUFRRCxTQUFTLHNCQUFULENBQWlDLFFBQWpDLEVBQTJDLFlBQTNDLEVBQXlELE1BQXpELEVBQWtFO0FBRWpFLE1BQU0sVUFBVSxHQUFHLFlBQVksQ0FBQyxVQUFoQztBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQWhCOztBQUVBLFdBQVMsdUJBQVQsQ0FBa0MsYUFBbEMsRUFBaUQsYUFBakQsRUFBaUU7QUFFaEUsV0FBTyxNQUFNLENBQUMsYUFBUCxDQUFzQixVQUF0QixFQUFrQyxhQUFsQyxFQUNMLElBREssQ0FDQyxVQUFXLFFBQVgsRUFBc0I7QUFFNUIsTUFBQSxRQUFRLENBQUMsWUFBVCxDQUF1QixhQUF2QixFQUFzQyxRQUF0QztBQUVBLEtBTEssQ0FBUDtBQU9BOztBQUVELE9BQU0sSUFBTSxpQkFBWixJQUFpQyxVQUFqQyxFQUE4QztBQUU3QyxRQUFNLGtCQUFrQixHQUFHLFVBQVUsQ0FBRSxpQkFBRixDQUFWLElBQW1DLGlCQUFpQixDQUFDLFdBQWxCLEVBQTlEO0FBR0EsUUFBSyxrQkFBa0IsSUFBSSxRQUFRLENBQUMsVUFBcEMsRUFBaUQ7QUFFakQsSUFBQSxPQUFPLENBQUMsSUFBUixDQUFjLHVCQUF1QixDQUFFLFVBQVUsQ0FBRSxpQkFBRixDQUFaLEVBQW1DLGtCQUFuQyxDQUFyQztBQUVBOztBQUVELE1BQUssWUFBWSxDQUFDLE9BQWIsS0FBeUIsU0FBekIsSUFBc0MsQ0FBRSxRQUFRLENBQUMsS0FBdEQsRUFBOEQ7QUFFN0QsUUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLGFBQVAsQ0FBc0IsVUFBdEIsRUFBa0MsWUFBWSxDQUFDLE9BQS9DLEVBQXlELElBQXpELENBQStELFVBQVcsUUFBWCxFQUFzQjtBQUVyRyxNQUFBLFFBQVEsQ0FBQyxRQUFULENBQW1CLFFBQW5CO0FBRUEsS0FKZ0IsQ0FBakI7QUFNQSxJQUFBLE9BQU8sQ0FBQyxJQUFSLENBQWMsUUFBZDtBQUVBOztBQUVELEVBQUEsc0JBQXNCLENBQUUsUUFBRixFQUFZLFlBQVosQ0FBdEI7QUFFQSxFQUFBLGFBQWEsQ0FBRSxRQUFGLEVBQVksWUFBWixFQUEwQixNQUExQixDQUFiO0FBRUEsU0FBTyxPQUFPLENBQUMsR0FBUixDQUFhLE9BQWIsRUFBdUIsSUFBdkIsQ0FBNkIsWUFBWTtBQUUvQyxXQUFPLFlBQVksQ0FBQyxPQUFiLEtBQXlCLFNBQXpCLEdBQ0osZUFBZSxDQUFFLFFBQUYsRUFBWSxZQUFZLENBQUMsT0FBekIsRUFBa0MsTUFBbEMsQ0FEWCxHQUVKLFFBRkg7QUFJQSxHQU5NLENBQVA7QUFRQTs7QUFPRCxTQUFTLG1CQUFULENBQThCLFFBQTlCLEVBQXdDLFFBQXhDLEVBQW1EO0FBRWxELE1BQUksS0FBSyxHQUFHLFFBQVEsQ0FBQyxRQUFULEVBQVo7O0FBSUEsTUFBSyxLQUFLLEtBQUssSUFBZixFQUFzQjtBQUVyQixRQUFNLE9BQU8sR0FBRyxFQUFoQjtBQUVBLFFBQU0sUUFBUSxHQUFHLFFBQVEsQ0FBQyxZQUFULENBQXVCLFVBQXZCLENBQWpCOztBQUVBLFFBQUssUUFBUSxLQUFLLFNBQWxCLEVBQThCO0FBRTdCLFdBQU0sSUFBSSxDQUFDLEdBQUcsQ0FBZCxFQUFpQixDQUFDLEdBQUcsUUFBUSxDQUFDLEtBQTlCLEVBQXFDLENBQUMsRUFBdEMsRUFBNEM7QUFFM0MsUUFBQSxPQUFPLENBQUMsSUFBUixDQUFjLENBQWQ7QUFFQTs7QUFFRCxNQUFBLFFBQVEsQ0FBQyxRQUFULENBQW1CLE9BQW5CO0FBQ0EsTUFBQSxLQUFLLEdBQUcsUUFBUSxDQUFDLFFBQVQsRUFBUjtBQUVBLEtBWEQsTUFXTztBQUVOLE1BQUEsT0FBTyxDQUFDLEtBQVIsQ0FBZSxnR0FBZjtBQUNBLGFBQU8sUUFBUDtBQUVBO0FBRUQ7O0FBSUQsTUFBTSxpQkFBaUIsR0FBRyxLQUFLLENBQUMsS0FBTixHQUFjLENBQXhDO0FBQ0EsTUFBTSxVQUFVLEdBQUcsRUFBbkI7O0FBRUEsTUFBSyxRQUFRLEtBQUssMEJBQWxCLEVBQXdDO0FBSXZDLFNBQU0sSUFBSSxHQUFDLEdBQUcsQ0FBZCxFQUFpQixHQUFDLElBQUksaUJBQXRCLEVBQXlDLEdBQUMsRUFBMUMsRUFBZ0Q7QUFFL0MsTUFBQSxVQUFVLENBQUMsSUFBWCxDQUFpQixLQUFLLENBQUMsSUFBTixDQUFZLENBQVosQ0FBakI7QUFDQSxNQUFBLFVBQVUsQ0FBQyxJQUFYLENBQWlCLEtBQUssQ0FBQyxJQUFOLENBQVksR0FBWixDQUFqQjtBQUNBLE1BQUEsVUFBVSxDQUFDLElBQVgsQ0FBaUIsS0FBSyxDQUFDLElBQU4sQ0FBWSxHQUFDLEdBQUcsQ0FBaEIsQ0FBakI7QUFFQTtBQUVELEdBWkQsTUFZTztBQUlOLFNBQU0sSUFBSSxHQUFDLEdBQUcsQ0FBZCxFQUFpQixHQUFDLEdBQUcsaUJBQXJCLEVBQXdDLEdBQUMsRUFBekMsRUFBK0M7QUFFOUMsVUFBSyxHQUFDLEdBQUcsQ0FBSixLQUFVLENBQWYsRUFBbUI7QUFFbEIsUUFBQSxVQUFVLENBQUMsSUFBWCxDQUFpQixLQUFLLENBQUMsSUFBTixDQUFZLEdBQVosQ0FBakI7QUFDQSxRQUFBLFVBQVUsQ0FBQyxJQUFYLENBQWlCLEtBQUssQ0FBQyxJQUFOLENBQVksR0FBQyxHQUFHLENBQWhCLENBQWpCO0FBQ0EsUUFBQSxVQUFVLENBQUMsSUFBWCxDQUFpQixLQUFLLENBQUMsSUFBTixDQUFZLEdBQUMsR0FBRyxDQUFoQixDQUFqQjtBQUdBLE9BUEQsTUFPTztBQUVOLFFBQUEsVUFBVSxDQUFDLElBQVgsQ0FBaUIsS0FBSyxDQUFDLElBQU4sQ0FBWSxHQUFDLEdBQUcsQ0FBaEIsQ0FBakI7QUFDQSxRQUFBLFVBQVUsQ0FBQyxJQUFYLENBQWlCLEtBQUssQ0FBQyxJQUFOLENBQVksR0FBQyxHQUFHLENBQWhCLENBQWpCO0FBQ0EsUUFBQSxVQUFVLENBQUMsSUFBWCxDQUFpQixLQUFLLENBQUMsSUFBTixDQUFZLEdBQVosQ0FBakI7QUFFQTtBQUVEO0FBRUQ7O0FBRUQsTUFBTyxVQUFVLENBQUMsTUFBWCxHQUFvQixDQUF0QixLQUE4QixpQkFBbkMsRUFBdUQ7QUFFdEQsSUFBQSxPQUFPLENBQUMsS0FBUixDQUFlLHlGQUFmO0FBRUE7O0FBSUQsTUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDLEtBQVQsRUFBcEI7QUFDQSxFQUFBLFdBQVcsQ0FBQyxRQUFaLENBQXNCLFVBQXRCO0FBRUEsU0FBTyxXQUFQO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDMXZJSyxROzs7Ozs7O1dBRUwsc0JBQXFCLFFBQXJCLEVBQStCLE9BQS9CLEVBQXlDO0FBRXhDLFVBQUssT0FBTCxFQUFlO0FBRWQsUUFBQSxPQUFPLENBQUMsS0FBUixDQUFlLGdKQUFmO0FBRUE7O0FBRUQsVUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLGFBQVQsQ0FBd0IsUUFBeEIsQ0FBZjs7QUFFQSxlQUFTLFdBQVQsR0FBbUM7QUFFbEMsWUFBSSxjQUFjLEdBQUcsSUFBckI7O0FBRmtDLGlCQUluQixnQkFKbUI7QUFBQTtBQUFBOztBQUFBO0FBQUEsOEZBSWxDLGlCQUFpQyxPQUFqQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUMsb0JBQUEsT0FBTyxDQUFDLGdCQUFSLENBQTBCLEtBQTFCLEVBQWlDLGNBQWpDO0FBRkQ7QUFBQSwyQkFJTyxRQUFRLENBQUMsRUFBVCxDQUFZLFVBQVosQ0FBd0IsT0FBeEIsQ0FKUDs7QUFBQTtBQUtDLG9CQUFBLE1BQU0sQ0FBQyxXQUFQLEdBQXFCLFNBQXJCO0FBRUEsb0JBQUEsY0FBYyxHQUFHLE9BQWpCOztBQVBEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBSmtDO0FBQUE7QUFBQTs7QUFlbEMsaUJBQVMsY0FBVCxHQUFxQztBQUVwQyxVQUFBLGNBQWMsQ0FBQyxtQkFBZixDQUFvQyxLQUFwQyxFQUEyQyxjQUEzQztBQUVBLFVBQUEsTUFBTSxDQUFDLFdBQVAsR0FBcUIsVUFBckI7QUFFQSxVQUFBLGNBQWMsR0FBRyxJQUFqQjtBQUVBOztBQUlELFFBQUEsTUFBTSxDQUFDLEtBQVAsQ0FBYSxPQUFiLEdBQXVCLEVBQXZCO0FBRUEsUUFBQSxNQUFNLENBQUMsS0FBUCxDQUFhLE1BQWIsR0FBc0IsU0FBdEI7QUFDQSxRQUFBLE1BQU0sQ0FBQyxLQUFQLENBQWEsSUFBYixHQUFvQixrQkFBcEI7QUFDQSxRQUFBLE1BQU0sQ0FBQyxLQUFQLENBQWEsS0FBYixHQUFxQixPQUFyQjtBQUVBLFFBQUEsTUFBTSxDQUFDLFdBQVAsR0FBcUIsVUFBckI7O0FBRUEsUUFBQSxNQUFNLENBQUMsWUFBUCxHQUFzQixZQUFZO0FBRWpDLFVBQUEsTUFBTSxDQUFDLEtBQVAsQ0FBYSxPQUFiLEdBQXVCLEtBQXZCO0FBRUEsU0FKRDs7QUFNQSxRQUFBLE1BQU0sQ0FBQyxZQUFQLEdBQXNCLFlBQVk7QUFFakMsVUFBQSxNQUFNLENBQUMsS0FBUCxDQUFhLE9BQWIsR0FBdUIsS0FBdkI7QUFFQSxTQUpEOztBQU1BLFFBQUEsTUFBTSxDQUFDLE9BQVAsR0FBaUIsWUFBWTtBQUU1QixjQUFLLGNBQWMsS0FBSyxJQUF4QixFQUErQjtBQVM5QixnQkFBTSxXQUFXLEdBQUc7QUFBRSxjQUFBLGdCQUFnQixFQUFFLENBQUUsYUFBRixFQUFpQixlQUFqQixFQUFrQyxlQUFsQyxFQUFtRCxRQUFuRDtBQUFwQixhQUFwQjtBQUNBLFlBQUEsU0FBUyxDQUFDLEVBQVYsQ0FBYSxjQUFiLENBQTZCLGNBQTdCLEVBQTZDLFdBQTdDLEVBQTJELElBQTNELENBQWlFLGdCQUFqRTtBQUVBLFdBWkQsTUFZTztBQUVOLFlBQUEsY0FBYyxDQUFDLEdBQWY7QUFFQTtBQUVELFNBcEJEO0FBc0JBOztBQUVELGVBQVMsYUFBVCxHQUF5QjtBQUV4QixRQUFBLE1BQU0sQ0FBQyxLQUFQLENBQWEsT0FBYixHQUF1QixFQUF2QjtBQUVBLFFBQUEsTUFBTSxDQUFDLEtBQVAsQ0FBYSxNQUFiLEdBQXNCLE1BQXRCO0FBQ0EsUUFBQSxNQUFNLENBQUMsS0FBUCxDQUFhLElBQWIsR0FBb0Isa0JBQXBCO0FBQ0EsUUFBQSxNQUFNLENBQUMsS0FBUCxDQUFhLEtBQWIsR0FBcUIsT0FBckI7QUFFQSxRQUFBLE1BQU0sQ0FBQyxZQUFQLEdBQXNCLElBQXRCO0FBQ0EsUUFBQSxNQUFNLENBQUMsWUFBUCxHQUFzQixJQUF0QjtBQUVBLFFBQUEsTUFBTSxDQUFDLE9BQVAsR0FBaUIsSUFBakI7QUFFQTs7QUFFRCxlQUFTLGlCQUFULEdBQTZCO0FBRTVCLFFBQUEsYUFBYTtBQUViLFFBQUEsTUFBTSxDQUFDLFdBQVAsR0FBcUIsa0JBQXJCO0FBRUE7O0FBRUQsZUFBUyxjQUFULENBQXlCLE9BQXpCLEVBQW1DO0FBRWxDLFFBQUEsT0FBTyxDQUFDLEtBQVIsQ0FBYyxRQUFkLEdBQXlCLFVBQXpCO0FBQ0EsUUFBQSxPQUFPLENBQUMsS0FBUixDQUFjLE1BQWQsR0FBdUIsTUFBdkI7QUFDQSxRQUFBLE9BQU8sQ0FBQyxLQUFSLENBQWMsT0FBZCxHQUF3QixVQUF4QjtBQUNBLFFBQUEsT0FBTyxDQUFDLEtBQVIsQ0FBYyxNQUFkLEdBQXVCLGdCQUF2QjtBQUNBLFFBQUEsT0FBTyxDQUFDLEtBQVIsQ0FBYyxZQUFkLEdBQTZCLEtBQTdCO0FBQ0EsUUFBQSxPQUFPLENBQUMsS0FBUixDQUFjLFVBQWQsR0FBMkIsaUJBQTNCO0FBQ0EsUUFBQSxPQUFPLENBQUMsS0FBUixDQUFjLEtBQWQsR0FBc0IsTUFBdEI7QUFDQSxRQUFBLE9BQU8sQ0FBQyxLQUFSLENBQWMsSUFBZCxHQUFxQix3QkFBckI7QUFDQSxRQUFBLE9BQU8sQ0FBQyxLQUFSLENBQWMsU0FBZCxHQUEwQixRQUExQjtBQUNBLFFBQUEsT0FBTyxDQUFDLEtBQVIsQ0FBYyxPQUFkLEdBQXdCLEtBQXhCO0FBQ0EsUUFBQSxPQUFPLENBQUMsS0FBUixDQUFjLE9BQWQsR0FBd0IsTUFBeEI7QUFDQSxRQUFBLE9BQU8sQ0FBQyxLQUFSLENBQWMsTUFBZCxHQUF1QixLQUF2QjtBQUVBOztBQUVELFVBQUssUUFBUSxTQUFiLEVBQXlCO0FBRXhCLFFBQUEsTUFBTSxDQUFDLEVBQVAsR0FBWSxVQUFaO0FBQ0EsUUFBQSxNQUFNLENBQUMsS0FBUCxDQUFhLE9BQWIsR0FBdUIsTUFBdkI7QUFFQSxRQUFBLGNBQWMsQ0FBRSxNQUFGLENBQWQ7QUFFQSxRQUFBLFNBQVMsQ0FBQyxFQUFWLENBQWEsa0JBQWIsQ0FBaUMsY0FBakMsRUFBa0QsSUFBbEQsQ0FBd0QsVUFBVyxTQUFYLEVBQXVCO0FBRTlFLFVBQUEsU0FBUyxHQUFHLFdBQVcsRUFBZCxHQUFtQixpQkFBaUIsRUFBN0M7QUFFQSxTQUpEO0FBTUEsZUFBTyxNQUFQO0FBRUEsT0FmRCxNQWVPO0FBRU4sWUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLGFBQVQsQ0FBd0IsR0FBeEIsQ0FBaEI7O0FBRUEsWUFBSyxNQUFNLENBQUMsZUFBUCxLQUEyQixLQUFoQyxFQUF3QztBQUV2QyxVQUFBLE9BQU8sQ0FBQyxJQUFSLEdBQWUsUUFBUSxDQUFDLFFBQVQsQ0FBa0IsSUFBbEIsQ0FBdUIsT0FBdkIsQ0FBZ0MsUUFBaEMsRUFBMEMsUUFBMUMsQ0FBZjtBQUNBLFVBQUEsT0FBTyxDQUFDLFNBQVIsR0FBb0IsbUJBQXBCO0FBRUEsU0FMRCxNQUtPO0FBRU4sVUFBQSxPQUFPLENBQUMsSUFBUixHQUFlLDJCQUFmO0FBQ0EsVUFBQSxPQUFPLENBQUMsU0FBUixHQUFvQixxQkFBcEI7QUFFQTs7QUFFRCxRQUFBLE9BQU8sQ0FBQyxLQUFSLENBQWMsSUFBZCxHQUFxQixrQkFBckI7QUFDQSxRQUFBLE9BQU8sQ0FBQyxLQUFSLENBQWMsS0FBZCxHQUFzQixPQUF0QjtBQUNBLFFBQUEsT0FBTyxDQUFDLEtBQVIsQ0FBYyxjQUFkLEdBQStCLE1BQS9CO0FBRUEsUUFBQSxjQUFjLENBQUUsT0FBRixDQUFkO0FBRUEsZUFBTyxPQUFQO0FBRUE7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwS0Y7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7OztJQUVNLFM7QUFDRixxQkFBWSxNQUFaLEVBQW9CO0FBQUE7QUFDaEIsU0FBSyxJQUFMLENBQVUsTUFBVjtBQUNIOzs7O1dBRUQsY0FBSyxNQUFMLEVBQWE7QUFDVCxXQUFLLFFBQUwsR0FBZ0IsS0FBaEI7QUFDQSxXQUFLLE1BQUwsR0FBYyxNQUFkO0FBQ0EsV0FBSyxXQUFMLEdBQW1CLE1BQU0sQ0FBQyxLQUExQjtBQUNBLFdBQUssS0FBTCxHQUFhLE1BQU0sQ0FBQyxLQUFQLENBQWEsS0FBMUI7QUFDQSxXQUFLLE1BQUwsR0FBYyxNQUFNLENBQUMsTUFBckI7QUFFQSxXQUFLLFVBQUwsR0FBa0IsRUFBbEI7O0FBRUEsVUFBSSxLQUFLLE1BQUwsQ0FBWSxjQUFoQixFQUFnQztBQUk1QixhQUFLLGFBQUwsR0FBcUIsSUFBSSxLQUFLLENBQUMsT0FBVixDQUFrQixDQUFDLE9BQW5CLEVBQTRCLENBQUMsUUFBN0IsRUFBdUMsQ0FBQyxHQUF4QyxDQUFyQjtBQUNBLGFBQUssWUFBTCxHQUFvQixJQUFJLEtBQUssQ0FBQyxPQUFWLENBQWtCLEdBQWxCLEVBQXVCLEdBQXZCLEVBQTRCLEdBQTVCLENBQXBCO0FBQ0EsYUFBSyxRQUFMLEdBQWdCLElBQUksS0FBSyxDQUFDLE9BQVYsRUFBaEI7QUFLQSxhQUFLLEtBQUwsR0FBYSxJQUFJLG9DQUFKLEVBQWI7QUFDSDs7QUFLRCxXQUFLLFlBQUwsR0FBb0IsSUFBSSw4QkFBSixDQUF1QjtBQUN2QyxRQUFBLFVBQVUsRUFBRSxLQUFLO0FBRHNCLE9BQXZCLENBQXBCO0FBUUEsV0FBSyxzQkFBTDtBQUNIOzs7V0FFRCxrQ0FBeUI7QUFBQTs7QUFJckIsVUFBTSxJQUFJLEdBQUcsSUFBSSxLQUFLLENBQUMsUUFBVixFQUFiO0FBQ0EsV0FBSyxNQUFMLEdBQWMsSUFBZDtBQUNBLFdBQUssUUFBTCxHQUFnQjtBQUNaLFFBQUEsS0FBSyxFQUFFLE9BREs7QUFFWixRQUFBLElBQUksRUFBRSxJQUZNO0FBR1osUUFBQSxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQUwsQ0FBYyxDQUhMO0FBSVosUUFBQSxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQUwsQ0FBYyxDQUpMO0FBS1osUUFBQSxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQUwsQ0FBYyxDQUxMO0FBTVosUUFBQSxFQUFFLEVBQUUsSUFBSSxDQUFDLFFBQUwsQ0FBYyxDQU5OO0FBT1osUUFBQSxFQUFFLEVBQUUsSUFBSSxDQUFDLFFBQUwsQ0FBYyxDQVBOO0FBUVosUUFBQSxFQUFFLEVBQUUsSUFBSSxDQUFDLFFBQUwsQ0FBYyxFQVJOO0FBU1osUUFBQSxVQUFVLEVBQUU7QUFUQSxPQUFoQjtBQWdCQSxVQUFNLFdBQVcsR0FBRyxJQUFJLHdCQUFKLEVBQXBCO0FBQ0EsTUFBQSxXQUFXLENBQUMsY0FBWixDQUEyQixjQUEzQjtBQUVBLFVBQU0sVUFBVSxHQUFHLElBQUksc0JBQUosRUFBbkI7QUFDQSxNQUFBLFVBQVUsQ0FBQyxjQUFYLENBQTBCLFdBQTFCO0FBRUEsTUFBQSxVQUFVLENBQUMsSUFBWCxDQUFnQiwyQkFBaEIsRUFBNkMsVUFBQyxHQUFELEVBQVM7QUFDbEQsWUFBTSxJQUFJLEdBQUcsR0FBRyxDQUFDLEtBQWpCOztBQUVBLFFBQUEsS0FBSSxDQUFDLEtBQUwsQ0FBVyxHQUFYLENBQWUsSUFBZjs7QUFLQSxRQUFBLEtBQUksQ0FBQyxNQUFMLEdBQWMsSUFBZDtBQUtBLFFBQUEsS0FBSSxDQUFDLEtBQUwsR0FBYSxJQUFJLEtBQUssQ0FBQyxjQUFWLENBQXlCLEtBQUksQ0FBQyxNQUE5QixDQUFiO0FBS0EsUUFBQSxLQUFJLENBQUMsVUFBTCxDQUFnQixNQUFoQixJQUEwQjtBQUN0QixVQUFBLElBQUksRUFBRSxHQUFHLENBQUMsVUFBSixDQUFlLENBQWYsQ0FEZ0I7QUFFdEIsVUFBQSxNQUFNLEVBQUUsS0FBSSxDQUFDLEtBQUwsQ0FBVyxVQUFYLENBQXNCLEdBQUcsQ0FBQyxVQUFKLENBQWUsQ0FBZixDQUF0QjtBQUZjLFNBQTFCO0FBSUEsUUFBQSxLQUFJLENBQUMsVUFBTCxDQUFnQixNQUFoQixJQUEwQjtBQUN0QixVQUFBLElBQUksRUFBRSxHQUFHLENBQUMsVUFBSixDQUFlLENBQWYsQ0FEZ0I7QUFFdEIsVUFBQSxNQUFNLEVBQUUsS0FBSSxDQUFDLEtBQUwsQ0FBVyxVQUFYLENBQXNCLEdBQUcsQ0FBQyxVQUFKLENBQWUsQ0FBZixDQUF0QjtBQUZjLFNBQTFCOztBQUlBLFFBQUEsS0FBSSxDQUFDLFlBQUwsQ0FBa0IsUUFBbEIsQ0FBMkIsTUFBM0I7O0FBS0EsWUFBSSxLQUFJLENBQUMsTUFBTCxDQUFZLGNBQWhCLEVBQWdDO0FBQzVCLFVBQUEsS0FBSSxDQUFDLGlCQUFMLEdBQXlCLElBQUksNkJBQUosQ0FBc0I7QUFDM0MsWUFBQSxNQUFNLEVBQUUsS0FBSSxDQUFDLE1BRDhCO0FBRTNDLFlBQUEsSUFBSSxFQUFFO0FBRnFDLFdBQXRCLENBQXpCO0FBSUg7O0FBS0QsUUFBQSxLQUFJLENBQUMsUUFBTCxHQUFnQjtBQUNaLFVBQUEsS0FBSyxFQUFFLFNBREs7QUFFWixVQUFBLElBQUksRUFBRSxJQUZNO0FBR1osVUFBQSxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQUwsQ0FBYyxDQUhMO0FBSVosVUFBQSxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQUwsQ0FBYyxDQUpMO0FBS1osVUFBQSxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQUwsQ0FBYyxDQUxMO0FBTVosVUFBQSxFQUFFLEVBQUUsSUFBSSxDQUFDLFFBQUwsQ0FBYyxDQU5OO0FBT1osVUFBQSxFQUFFLEVBQUUsSUFBSSxDQUFDLFFBQUwsQ0FBYyxDQVBOO0FBUVosVUFBQSxFQUFFLEVBQUUsSUFBSSxDQUFDLFFBQUwsQ0FBYyxDQVJOO0FBU1osVUFBQSxVQUFVLEVBQUU7QUFUQSxTQUFoQjtBQVdBLFFBQUEsS0FBSSxDQUFDLFFBQUwsR0FBZ0IsSUFBaEI7QUFDSCxPQXJERDtBQXdESDs7O1dBRUQseUJBQWdCLGFBQWhCLEVBQStCLFNBQS9CLEVBQTBDO0FBQ3RDLFVBQU0sSUFBSSxHQUFHLFNBQVMsQ0FBQyxVQUFWLENBQXFCLENBQXJCLENBQWI7QUFDQSxVQUFNLE1BQU0sR0FBRyxLQUFLLEtBQUwsQ0FBVyxVQUFYLENBQXNCLElBQXRCLENBQWY7QUFFQSxXQUFLLFVBQUwsQ0FBZ0IsYUFBaEIsSUFBaUM7QUFDN0IsUUFBQSxJQUFJLEVBQUUsSUFEdUI7QUFFN0IsUUFBQSxNQUFNLEVBQUU7QUFGcUIsT0FBakM7QUFJSDs7O1dBRUQsNEJBQW1CO0FBT2YsVUFBTSxpQkFBaUIsR0FBRyxLQUFLLE1BQUwsQ0FBWSxRQUFaLENBQXFCLEtBQXJCLEVBQTFCO0FBQ0EsTUFBQSxpQkFBaUIsQ0FBQyxDQUFsQixJQUF1QixHQUF2QjtBQUtBLFVBQU0sa0JBQWtCLEdBQUcsSUFBSSxLQUFLLENBQUMsT0FBVixFQUEzQjtBQUNBLFdBQUssTUFBTCxDQUFZLGlCQUFaLENBQThCLGtCQUE5Qjs7QUFNQSxVQUFJLEtBQUssS0FBTCxDQUFXLFdBQVgsQ0FBdUIsQ0FBM0IsRUFBOEI7QUFDMUIsUUFBQSxrQkFBa0IsQ0FBQyxNQUFuQjtBQUNIOztBQUtELFVBQUksU0FBUyxHQUFHLElBQUksS0FBSyxDQUFDLFNBQVYsQ0FBb0IsaUJBQXBCLEVBQXVDLGtCQUF2QyxDQUFoQjtBQUtBLFVBQUksVUFBVSxHQUFHLFNBQVMsQ0FBQyxnQkFBVixDQUEyQixLQUFLLFdBQUwsQ0FBaUIsU0FBNUMsQ0FBakI7O0FBS0EsVUFBSSxVQUFVLENBQUMsTUFBWCxHQUFvQixDQUF4QixFQUEyQjtBQUN2QixZQUFJLFVBQVUsQ0FBQyxDQUFELENBQVYsQ0FBYyxRQUFkLEdBQXlCLEdBQTdCLEVBQWtDO0FBQzlCLGlCQUFPLElBQVA7QUFDSDtBQUNKOztBQUVELGFBQU8sS0FBUDtBQUNIOzs7V0FFRCxnQkFBTyxTQUFQLEVBQWtCO0FBQ2QsVUFBSSxLQUFLLE1BQUwsSUFBZSxTQUFuQixFQUE4QjtBQUMxQjtBQUNIOztBQUVELFVBQUksQ0FBQyxLQUFLLFlBQUwsQ0FBa0IsWUFBdkIsRUFBcUM7QUFDakM7QUFDSDs7QUFDRCxXQUFLLFlBQUwsQ0FBa0IsTUFBbEIsQ0FBeUIsU0FBekIsRUFBb0MsS0FBSyxLQUF6QztBQUtBLFVBQU0sUUFBUSxHQUFHLEtBQUssUUFBdEI7QUFFQSxVQUFNLGNBQWMsR0FBRyxJQUFJLEtBQUssQ0FBQyxVQUFWLEVBQXZCO0FBQ0EsVUFBTSxZQUFZLEdBQUcsSUFBSSxLQUFLLENBQUMsT0FBVixDQUFrQixDQUFsQixFQUFxQixDQUFyQixFQUF3QixDQUF4QixDQUFyQjtBQUNBLFVBQU0sY0FBYyxHQUFHLEtBQUssTUFBTCxDQUFZLFVBQVosQ0FBdUIsS0FBdkIsRUFBdkI7QUFLQSxVQUFNLGtCQUFrQixHQUFHLElBQUksS0FBSyxDQUFDLE9BQVYsQ0FDdkIsUUFBUSxDQUFDLENBQVQsR0FBYSxLQUFLLGFBQUwsQ0FBbUIsQ0FEVCxFQUV2QixRQUFRLENBQUMsQ0FBVCxHQUFhLEtBQUssYUFBTCxDQUFtQixDQUZULEVBR3ZCLFFBQVEsQ0FBQyxDQUFULEdBQWEsS0FBSyxhQUFMLENBQW1CLENBSFQsQ0FBM0I7QUFLQSxNQUFBLGtCQUFrQixDQUFDLGNBQW5CLENBQWtDLFNBQWxDO0FBQ0EsTUFBQSxrQkFBa0IsQ0FBQyxDQUFuQixHQUF1QixJQUFJLENBQUMsSUFBTCxDQUFVLGtCQUFrQixDQUFDLENBQTdCLElBQWtDLElBQUksQ0FBQyxHQUFMLENBQVMsSUFBSSxDQUFDLEdBQUwsQ0FBUyxrQkFBa0IsQ0FBQyxDQUE1QixDQUFULEVBQXlDLElBQUksQ0FBQyxHQUFMLENBQVMsUUFBUSxDQUFDLENBQWxCLENBQXpDLENBQXpEO0FBRUEsTUFBQSxRQUFRLENBQUMsR0FBVCxDQUFhLGtCQUFiOztBQUtBLFVBQUksS0FBSyxLQUFMLENBQVcsV0FBWCxDQUF1QixDQUEzQixFQUE4QjtBQUMxQixRQUFBLFFBQVEsQ0FBQyxDQUFULElBQWMsS0FBSyxZQUFMLENBQWtCLENBQWxCLEdBQXNCLFNBQXBDO0FBQ0gsT0FGRCxNQUVPLElBQUksS0FBSyxLQUFMLENBQVcsV0FBWCxDQUF1QixDQUEzQixFQUE4QjtBQUNqQyxRQUFBLFFBQVEsQ0FBQyxDQUFULElBQWMsS0FBSyxZQUFMLENBQWtCLENBQWxCLEdBQXNCLFNBQXBDO0FBQ0gsT0FGTSxNQUVBO0FBQ0gsUUFBQSxRQUFRLENBQUMsQ0FBVCxHQUFhLENBQWI7QUFDSDs7QUFLRCxVQUFJLEtBQUssS0FBTCxDQUFXLFdBQVgsQ0FBdUIsQ0FBM0IsRUFBOEI7QUFDMUIsUUFBQSxjQUFjLENBQUMsZ0JBQWYsQ0FBZ0MsWUFBaEMsRUFBOEMsTUFBTSxJQUFJLENBQUMsRUFBWCxHQUFnQixTQUFoQixHQUE0QixLQUFLLFlBQUwsQ0FBa0IsQ0FBNUY7QUFDQSxRQUFBLGNBQWMsQ0FBQyxRQUFmLENBQXdCLGNBQXhCO0FBQ0gsT0FIRCxNQUdPLElBQUksS0FBSyxLQUFMLENBQVcsV0FBWCxDQUF1QixDQUEzQixFQUE4QjtBQUNqQyxRQUFBLGNBQWMsQ0FBQyxnQkFBZixDQUFnQyxZQUFoQyxFQUE4QyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQVosR0FBaUIsU0FBakIsR0FBNkIsS0FBSyxZQUFMLENBQWtCLENBQTdGO0FBQ0EsUUFBQSxjQUFjLENBQUMsUUFBZixDQUF3QixjQUF4QjtBQUNIOztBQU9ELFVBQUksS0FBSyxnQkFBTCxFQUFKLEVBQTZCO0FBQ3pCLFFBQUEsUUFBUSxDQUFDLENBQVQsR0FBYSxDQUFiO0FBQ0g7O0FBS0QsV0FBSyxNQUFMLENBQVksVUFBWixDQUF1QixJQUF2QixDQUE0QixjQUE1QjtBQUVBLFVBQU0sV0FBVyxHQUFHLElBQUksS0FBSyxDQUFDLE9BQVYsRUFBcEI7QUFDQSxNQUFBLFdBQVcsQ0FBQyxJQUFaLENBQWlCLEtBQUssTUFBTCxDQUFZLFFBQTdCO0FBS0EsVUFBTSxPQUFPLEdBQUcsSUFBSSxLQUFLLENBQUMsT0FBVixDQUFrQixDQUFsQixFQUFxQixDQUFyQixFQUF3QixDQUF4QixDQUFoQjtBQUNBLE1BQUEsT0FBTyxDQUFDLGVBQVIsQ0FBd0IsS0FBSyxNQUFMLENBQVksVUFBcEM7QUFDQSxNQUFBLE9BQU8sQ0FBQyxTQUFSO0FBRUEsVUFBTSxRQUFRLEdBQUcsSUFBSSxLQUFLLENBQUMsT0FBVixDQUFrQixDQUFsQixFQUFxQixDQUFyQixFQUF3QixDQUF4QixDQUFqQjtBQUNBLE1BQUEsUUFBUSxDQUFDLGVBQVQsQ0FBeUIsS0FBSyxNQUFMLENBQVksVUFBckM7QUFDQSxNQUFBLFFBQVEsQ0FBQyxTQUFUO0FBRUEsTUFBQSxPQUFPLENBQUMsY0FBUixDQUF1QixRQUFRLENBQUMsQ0FBVCxHQUFhLFNBQXBDO0FBQ0EsTUFBQSxRQUFRLENBQUMsY0FBVCxDQUF3QixRQUFRLENBQUMsQ0FBVCxHQUFhLFNBQXJDO0FBRUEsV0FBSyxNQUFMLENBQVksUUFBWixDQUFxQixHQUFyQixDQUF5QixPQUF6QjtBQUNBLFdBQUssTUFBTCxDQUFZLFFBQVosQ0FBcUIsR0FBckIsQ0FBeUIsUUFBekI7O0FBTUEsVUFBSSxLQUFLLEtBQVQsRUFBZ0I7QUFDWixhQUFLLEtBQUwsQ0FBVyxNQUFYLENBQWtCLFNBQWxCO0FBQ0g7QUFDSjs7Ozs7ZUFHVSxTOzs7Ozs7Ozs7Ozs7Ozs7OztJQ2xTVCx3QjtBQUNGLG9DQUFZLE1BQVosRUFBb0I7QUFBQTs7QUFBQTtBQUNoQixTQUFLLE1BQUwsR0FBYyxNQUFkO0FBS0EsU0FBSyxXQUFMLEdBQW1CO0FBQ2YsTUFBQSxDQUFDLEVBQUUsS0FEWTtBQUVmLE1BQUEsQ0FBQyxFQUFFLEtBRlk7QUFHZixNQUFBLENBQUMsRUFBRSxLQUhZO0FBSWYsTUFBQSxDQUFDLEVBQUUsS0FKWTtBQUtmLE1BQUEsQ0FBQyxFQUFFO0FBTFksS0FBbkI7QUFRQSxJQUFBLE1BQU0sQ0FBQyxnQkFBUCxDQUF3QixTQUF4QixFQUFtQyxVQUFDLENBQUQsRUFBTztBQUFFLE1BQUEsS0FBSSxDQUFDLGFBQUwsQ0FBbUIsQ0FBbkI7QUFBdUIsS0FBbkU7QUFDQSxJQUFBLE1BQU0sQ0FBQyxnQkFBUCxDQUF3QixPQUF4QixFQUFpQyxVQUFDLENBQUQsRUFBTztBQUFFLE1BQUEsS0FBSSxDQUFDLFdBQUwsQ0FBaUIsQ0FBakI7QUFBcUIsS0FBL0Q7QUFDSDs7OztXQUVELHVCQUFjLENBQWQsRUFBaUI7QUFDYixVQUFNLFVBQVUsR0FBRyxDQUFDLENBQUMsSUFBRixDQUFPLE9BQVAsQ0FBZSxLQUFmLEVBQXNCLEVBQXRCLEVBQTBCLFdBQTFCLEVBQW5COztBQUNBLGNBQU8sVUFBUDtBQUNJLGFBQUssR0FBTDtBQUNJLGVBQUssV0FBTCxDQUFpQixDQUFqQixHQUFxQixJQUFyQjtBQUNBOztBQUNKLGFBQUssR0FBTDtBQUNJLGVBQUssV0FBTCxDQUFpQixDQUFqQixHQUFxQixJQUFyQjtBQUNBOztBQUNKLGFBQUssR0FBTDtBQUNJLGVBQUssV0FBTCxDQUFpQixDQUFqQixHQUFxQixJQUFyQjtBQUNBOztBQUNKLGFBQUssR0FBTDtBQUNJLGVBQUssV0FBTCxDQUFpQixDQUFqQixHQUFxQixJQUFyQjtBQUNBOztBQUNKLGFBQUssR0FBTDtBQUNJLGNBQUksS0FBSyxXQUFMLENBQWlCLENBQXJCLEVBQXdCO0FBQ3BCLGlCQUFLLFdBQUwsQ0FBaUIsQ0FBakIsR0FBcUIsS0FBckI7QUFDSCxXQUZELE1BRU87QUFDSCxpQkFBSyxXQUFMLENBQWlCLENBQWpCLEdBQXFCLElBQXJCO0FBQ0g7O0FBQ0Q7QUFuQlI7QUFxQkg7OztXQUVELHFCQUFZLENBQVosRUFBZTtBQUNYLFVBQU0sVUFBVSxHQUFHLENBQUMsQ0FBQyxJQUFGLENBQU8sT0FBUCxDQUFlLEtBQWYsRUFBc0IsRUFBdEIsRUFBMEIsV0FBMUIsRUFBbkI7O0FBQ0EsY0FBTyxVQUFQO0FBQ0ksYUFBSyxHQUFMO0FBQ0ksZUFBSyxXQUFMLENBQWlCLENBQWpCLEdBQXFCLEtBQXJCO0FBQ0E7O0FBQ0osYUFBSyxHQUFMO0FBQ0ksZUFBSyxXQUFMLENBQWlCLENBQWpCLEdBQXFCLEtBQXJCO0FBQ0E7O0FBQ0osYUFBSyxHQUFMO0FBQ0ksZUFBSyxXQUFMLENBQWlCLENBQWpCLEdBQXFCLEtBQXJCO0FBQ0E7O0FBQ0osYUFBSyxHQUFMO0FBQ0ksZUFBSyxXQUFMLENBQWlCLENBQWpCLEdBQXFCLEtBQXJCO0FBQ0E7QUFaUjtBQWNIOzs7OztlQUdVLHdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0RmOzs7Ozs7Ozs7O0lBS00sa0I7QUFDRiw4QkFBWSxNQUFaLEVBQW9CO0FBQUE7QUFJaEIsU0FBSyxNQUFMLEdBQWM7QUFDVixjQUFRLFNBREU7QUFFVixjQUFRO0FBRkUsS0FBZDtBQUtBLFNBQUssWUFBTCxHQUFvQixJQUFwQjtBQUNBLFNBQUssVUFBTCxHQUFrQixNQUFNLENBQUMsVUFBekI7QUFDSDs7OztXQUlELGtCQUFTLElBQVQsRUFBZTtBQUNYLFVBQU0sU0FBUyxHQUFHLEtBQUssWUFBdkI7O0FBRUEsVUFBSSxTQUFKLEVBQWU7QUFDWCxZQUFJLFNBQVMsQ0FBQyxJQUFWLElBQWtCLElBQXRCLEVBQTRCO0FBQ3hCO0FBQ0g7O0FBRUQsUUFBQSxTQUFTLENBQUMsSUFBVjtBQUNIOztBQUtELFVBQU0sS0FBSyxHQUFHLElBQUksS0FBSyxNQUFMLENBQVksSUFBWixDQUFKLENBQXNCLElBQXRCLENBQWQ7QUFFQSxXQUFLLFlBQUwsR0FBb0IsS0FBcEI7QUFLQSxNQUFBLEtBQUssQ0FBQyxLQUFOLENBQVksU0FBWjtBQUNIOzs7V0FFRCxnQkFBTyxTQUFQLEVBQWtCLEtBQWxCLEVBQXlCO0FBQ3JCLFVBQUksS0FBSyxZQUFULEVBQXVCO0FBQ25CLGFBQUssWUFBTCxDQUFrQixNQUFsQixDQUF5QixTQUF6QixFQUFvQyxLQUFwQztBQUNIO0FBQ0o7Ozs7O0lBTUMsSztBQUNGLGlCQUFZLE1BQVosRUFBb0I7QUFBQTtBQUNoQixTQUFLLE1BQUwsR0FBYyxNQUFkO0FBQ0g7Ozs7V0FFRCxpQkFBUSxDQUFFOzs7V0FDVixnQkFBTyxDQUFFOzs7V0FDVCxrQkFBUyxDQUFFOzs7OztJQU1ULFM7Ozs7O0FBQ0YscUJBQVksTUFBWixFQUFvQjtBQUFBOztBQUFBO0FBQ2hCLDhCQUFNLE1BQU47QUFFQSxVQUFLLElBQUwsR0FBWSxNQUFaO0FBSGdCO0FBSW5COzs7O1dBRUQsZUFBTSxTQUFOLEVBQWlCO0FBQ2IsVUFBTSxVQUFVLEdBQUcsS0FBSyxNQUFMLENBQVksVUFBWixDQUF1QixNQUF2QixFQUErQixNQUFsRDs7QUFFQSxVQUFJLFNBQUosRUFBZTtBQUNYLFlBQU0sVUFBVSxHQUFHLEtBQUssTUFBTCxDQUFZLFVBQVosQ0FBdUIsU0FBUyxDQUFDLElBQWpDLEVBQXVDLE1BQTFEO0FBRUEsUUFBQSxVQUFVLENBQUMsT0FBWCxHQUFxQixJQUFyQjtBQUNBLFFBQUEsVUFBVSxDQUFDLElBQVgsR0FBa0IsR0FBbEI7QUFDQSxRQUFBLFVBQVUsQ0FBQyxhQUFYLENBQXlCLFVBQXpCLEVBQXFDLEdBQXJDLEVBQTBDLElBQTFDO0FBQ0EsUUFBQSxVQUFVLENBQUMsSUFBWDtBQUNILE9BUEQsTUFPTztBQUNILFFBQUEsVUFBVSxDQUFDLElBQVg7QUFDSDtBQUNKOzs7V0FFRCxnQkFBTyxDQUVOOzs7V0FFRCxnQkFBTyxTQUFQLEVBQWtCLEtBQWxCLEVBQXlCO0FBS3JCLFVBQUksS0FBSyxDQUFDLFdBQU4sQ0FBa0IsQ0FBdEIsRUFBeUI7QUFDckIsYUFBSyxNQUFMLENBQVksUUFBWixDQUFxQixNQUFyQjtBQUNILE9BRkQsTUFFTyxJQUFJLEtBQUssQ0FBQyxXQUFOLENBQWtCLENBQXRCLEVBQXlCLENBRS9CO0FBQ0o7OztFQXBDbUIsSzs7SUF1Q2xCLFM7Ozs7O0FBQ0YscUJBQVksTUFBWixFQUFvQjtBQUFBOztBQUFBO0FBQ2hCLGdDQUFNLE1BQU47QUFFQSxXQUFLLElBQUwsR0FBWSxNQUFaO0FBSGdCO0FBSW5COzs7O1dBRUQsZUFBTSxTQUFOLEVBQWlCO0FBQ2IsVUFBTSxVQUFVLEdBQUcsS0FBSyxNQUFMLENBQVksVUFBWixDQUF1QixNQUF2QixFQUErQixNQUFsRDs7QUFFQSxVQUFJLFNBQUosRUFBZTtBQUNYLFlBQU0sVUFBVSxHQUFHLEtBQUssTUFBTCxDQUFZLFVBQVosQ0FBdUIsU0FBUyxDQUFDLElBQWpDLEVBQXVDLE1BQTFEO0FBRUEsUUFBQSxVQUFVLENBQUMsT0FBWCxHQUFxQixJQUFyQjtBQU1BLFFBQUEsVUFBVSxDQUFDLElBQVgsR0FBa0IsR0FBbEI7QUFDQSxRQUFBLFVBQVUsQ0FBQyxhQUFYLENBQXlCLFVBQXpCLEVBQXFDLEdBQXJDLEVBQTBDLElBQTFDO0FBQ0EsUUFBQSxVQUFVLENBQUMsSUFBWDtBQUNILE9BWkQsTUFZTztBQUNILFFBQUEsVUFBVSxDQUFDLElBQVg7QUFDSDtBQUNKOzs7V0FFRCxnQkFBTyxDQUVOOzs7V0FFRCxnQkFBTyxTQUFQLEVBQWtCLEtBQWxCLEVBQXlCO0FBQ3JCLFVBQUksS0FBSyxDQUFDLFdBQU4sQ0FBa0IsQ0FBdEIsRUFBeUI7QUFDckI7QUFDSDs7QUFFRCxXQUFLLE1BQUwsQ0FBWSxRQUFaLENBQXFCLE1BQXJCO0FBQ0g7OztFQXJDbUIsSzs7ZUF3Q1Qsa0I7Ozs7Ozs7Ozs7QUNuSmY7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7OztBQUtBLElBQU0sTUFBTSxHQUFHLEVBQUUsRUFBakI7QUFZQSxJQUFNLFdBQVcsR0FBRyxJQUFJLGlCQUFKLEVBQXBCO0FBS0EsSUFBTSxVQUFVLEdBQUcsRUFBbkI7QUFDQSxJQUFNLGFBQWEsR0FBRyxFQUF0QjtBQUtBLElBQUksYUFBYSxHQUFHLFNBQXBCO0FBS0EsSUFBSSxTQUFTLEdBQUcsU0FBaEI7QUFLQSxJQUFNLEtBQUssR0FBRyxJQUFJLEtBQUssQ0FBQyxLQUFWLEVBQWQ7O0FBRUEsU0FBUyxNQUFULEdBQWtCO0FBSWIsTUFBSSxhQUFhLElBQUksU0FBUyxDQUFDLFFBQS9CLEVBQXlDO0FBQ3RDLElBQUEsU0FBUyxDQUFDLE1BQVYsQ0FBaUIsS0FBSyxDQUFDLFFBQU4sRUFBakI7QUFDQSxJQUFBLFNBQVMsQ0FBQyxpQkFBVixDQUE0QixNQUE1QixDQUFtQyxTQUFTLENBQUMsS0FBN0M7QUFDQSxJQUFBLFNBQVMsQ0FBQyxZQUFWLENBQXVCLE1BQXZCLENBQThCLEtBQUssQ0FBQyxRQUFOLEVBQTlCLEVBQWdELFNBQVMsQ0FBQyxLQUExRDtBQUVBLElBQUEsTUFBTSxDQUFDLElBQVAsQ0FBWSxRQUFaLEVBQXNCO0FBQ2xCLE1BQUEsRUFBRSxFQUFFLGFBRGM7QUFFbEIsTUFBQSxLQUFLLEVBQUUsU0FBUyxDQUFDLFFBQVYsQ0FBbUIsS0FGUjtBQUdsQixNQUFBLENBQUMsRUFBRSxTQUFTLENBQUMsTUFBVixDQUFpQixRQUFqQixDQUEwQixDQUhYO0FBSWxCLE1BQUEsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxNQUFWLENBQWlCLFFBQWpCLENBQTBCLENBSlg7QUFLbEIsTUFBQSxDQUFDLEVBQUUsU0FBUyxDQUFDLE1BQVYsQ0FBaUIsUUFBakIsQ0FBMEIsQ0FMWDtBQU1sQixNQUFBLEVBQUUsRUFBRSxTQUFTLENBQUMsTUFBVixDQUFpQixRQUFqQixDQUEwQixDQU5aO0FBT2xCLE1BQUEsRUFBRSxFQUFFLFNBQVMsQ0FBQyxNQUFWLENBQWlCLFFBQWpCLENBQTBCLENBUFo7QUFRbEIsTUFBQSxFQUFFLEVBQUUsU0FBUyxDQUFDLE1BQVYsQ0FBaUIsUUFBakIsQ0FBMEIsQ0FSWjtBQVNsQixNQUFBLFVBQVUsRUFBRSxTQUFTLENBQUMsWUFBVixDQUF1QixZQUF2QixDQUFvQztBQVQ5QixLQUF0QjtBQVdIOztBQUlELE1BQUksYUFBSixFQUFtQjtBQUNmLElBQUEsV0FBVyxDQUFDLEtBQUssQ0FBQyxRQUFOLEVBQUQsQ0FBWDtBQUNIO0FBQ0o7O0FBRUQsU0FBUyxPQUFULEdBQW1CO0FBSWYsRUFBQSxNQUFNO0FBS04sRUFBQSxXQUFXLENBQUMsUUFBWixDQUFxQixNQUFyQixDQUE0QixXQUFXLENBQUMsS0FBeEMsRUFBK0MsV0FBVyxDQUFDLE1BQTNEO0FBRUEsRUFBQSxNQUFNLENBQUMscUJBQVAsQ0FBNkIsWUFBTTtBQUMvQixJQUFBLE9BQU87QUFDVixHQUZEO0FBR0g7O0FBQ0QsT0FBTztBQUtQLFdBQVcsQ0FBQyxRQUFaLENBQXFCLEVBQXJCLENBQXdCLE9BQXhCLEdBQWtDLElBQWxDO0FBQ0EsUUFBUSxDQUFDLElBQVQsQ0FBYyxXQUFkLENBQTBCLG1CQUFTLFlBQVQsQ0FBc0IsV0FBVyxDQUFDLFFBQWxDLENBQTFCO0FBRUEsV0FBVyxDQUFDLFFBQVosQ0FBcUIsZ0JBQXJCLENBQXNDLFlBQVc7QUFHN0MsRUFBQSxXQUFXLENBQUMsUUFBWixDQUFxQixNQUFyQixDQUE0QixXQUFXLENBQUMsS0FBeEMsRUFBK0MsV0FBVyxDQUFDLE1BQTNEO0FBQ0gsQ0FKRDtBQWNBLE1BQU0sQ0FBQyxFQUFQLENBQVUsT0FBVixFQUFtQixTQUFTLFdBQVQsQ0FBcUIsTUFBckIsRUFBNkI7QUFJNUMsRUFBQSxhQUFhLEdBQUcsTUFBTSxDQUFDLEVBQXZCO0FBS0EsRUFBQSxTQUFTLEdBQUcsSUFBSSxxQkFBSixDQUFjO0FBQ3RCLElBQUEsS0FBSyxFQUFFLFdBRGU7QUFFdEIsSUFBQSxNQUFNLEVBQUUsV0FBVyxDQUFDLE1BRkU7QUFHdEIsSUFBQSxjQUFjLEVBQUU7QUFITSxHQUFkLENBQVo7QUFNQSxFQUFBLE1BQU0sQ0FBQyxJQUFQLENBQVksTUFBWixFQUFvQjtBQUNoQixJQUFBLEtBQUssRUFBRSxTQUFTLENBQUMsUUFBVixDQUFtQixLQURWO0FBRWhCLElBQUEsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxRQUFWLENBQW1CLENBRk47QUFHaEIsSUFBQSxDQUFDLEVBQUUsU0FBUyxDQUFDLFFBQVYsQ0FBbUIsQ0FITjtBQUloQixJQUFBLENBQUMsRUFBRSxTQUFTLENBQUMsUUFBVixDQUFtQixDQUpOO0FBS2hCLElBQUEsRUFBRSxFQUFFLFNBQVMsQ0FBQyxRQUFWLENBQW1CLEVBTFA7QUFNaEIsSUFBQSxFQUFFLEVBQUUsU0FBUyxDQUFDLFFBQVYsQ0FBbUIsRUFOUDtBQU9oQixJQUFBLEVBQUUsRUFBRSxTQUFTLENBQUMsUUFBVixDQUFtQixFQVBQO0FBUWhCLElBQUEsVUFBVSxFQUFFLFNBQVMsQ0FBQyxRQUFWLENBQW1CO0FBUmYsR0FBcEI7QUFVSCxDQXpCRDtBQThCQSxNQUFNLENBQUMsRUFBUCxDQUFVLGFBQVYsRUFBeUIsU0FBUyxpQkFBVCxDQUEyQixNQUEzQixFQUFtQztBQUN4RCxFQUFBLE1BQU0sQ0FBQyxPQUFQLENBQWUsT0FBZixDQUF1QixVQUFDLElBQUQsRUFBVTtBQUM3QixRQUFJLElBQUksQ0FBQyxFQUFMLElBQVcsYUFBZixFQUE4QjtBQUkxQixNQUFBLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBTixDQUFWLEdBQXNCLElBQXRCOztBQUtBLFVBQUksYUFBYSxDQUFDLElBQUksQ0FBQyxFQUFOLENBQWIsSUFBMEIsU0FBOUIsRUFBeUM7QUFDckMsUUFBQSxhQUFhLENBQUMsSUFBSSxDQUFDLEVBQU4sQ0FBYixHQUF5QixJQUFJLHFCQUFKLENBQWM7QUFDbkMsVUFBQSxLQUFLLEVBQUUsV0FENEI7QUFFbkMsVUFBQSxjQUFjLEVBQUU7QUFGbUIsU0FBZCxDQUF6QjtBQUlIO0FBQ0o7QUFDSixHQWpCRDtBQWtCSCxDQW5CRDtBQXdCQSxNQUFNLENBQUMsRUFBUCxDQUFVLFlBQVYsRUFBd0IsU0FBUyxnQkFBVCxDQUEwQixNQUExQixFQUFrQztBQUN0RCxNQUFJLFVBQVUsQ0FBQyxNQUFNLENBQUMsRUFBUixDQUFkLEVBQTJCO0FBQ3ZCLElBQUEsV0FBVyxDQUFDLEtBQVosQ0FBa0IsTUFBbEIsQ0FBeUIsYUFBYSxDQUFDLE1BQU0sQ0FBQyxFQUFSLENBQWIsQ0FBeUIsUUFBekIsQ0FBa0MsSUFBM0Q7QUFDQSxXQUFPLGFBQWEsQ0FBQyxNQUFNLENBQUMsRUFBUixDQUFwQjtBQUNBLFdBQU8sVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFSLENBQWpCO0FBQ0g7QUFDSixDQU5EOztBQVdDLFNBQVMsV0FBVCxDQUFxQixTQUFyQixFQUFnQztBQUM3QixFQUFBLE1BQU0sQ0FBQyxJQUFQLENBQVksYUFBWixFQUEyQixPQUEzQixDQUFtQyxVQUFDLEVBQUQsRUFBUTtBQUN2QyxRQUFNLElBQUksR0FBRyxhQUFhLENBQUMsRUFBRCxDQUFiLENBQWtCLE1BQS9CO0FBRUEsSUFBQSxJQUFJLENBQUMsUUFBTCxDQUFjLENBQWQsR0FBa0IsVUFBVSxDQUFDLEVBQUQsQ0FBVixDQUFlLEVBQWpDO0FBQ0EsSUFBQSxJQUFJLENBQUMsUUFBTCxDQUFjLENBQWQsR0FBa0IsVUFBVSxDQUFDLEVBQUQsQ0FBVixDQUFlLEVBQWpDO0FBQ0EsSUFBQSxJQUFJLENBQUMsUUFBTCxDQUFjLENBQWQsR0FBa0IsVUFBVSxDQUFDLEVBQUQsQ0FBVixDQUFlLEVBQWpDO0FBRUEsSUFBQSxJQUFJLENBQUMsUUFBTCxDQUFjLElBQWQsQ0FBbUIsSUFBSSxLQUFLLENBQUMsT0FBVixDQUFrQixVQUFVLENBQUMsRUFBRCxDQUFWLENBQWUsQ0FBakMsRUFBb0MsVUFBVSxDQUFDLEVBQUQsQ0FBVixDQUFlLENBQW5ELEVBQXNELFVBQVUsQ0FBQyxFQUFELENBQVYsQ0FBZSxDQUFyRSxDQUFuQixFQUE0RixHQUE1Rjs7QUFFQSxRQUFJLGFBQWEsQ0FBQyxFQUFELENBQWIsQ0FBa0IsUUFBdEIsRUFBZ0M7QUFDNUIsTUFBQSxhQUFhLENBQUMsRUFBRCxDQUFiLENBQWtCLEtBQWxCLENBQXdCLE1BQXhCLENBQStCLEtBQS9COztBQUVBLFVBQUksVUFBVSxDQUFDLEVBQUQsQ0FBVixDQUFlLFVBQWYsSUFBNkIsU0FBN0IsSUFBMEMsYUFBYSxDQUFDLEVBQUQsQ0FBYixDQUFrQixZQUFsQixDQUErQixZQUEvQixDQUE0QyxJQUE1QyxJQUFvRCxVQUFVLENBQUMsRUFBRCxDQUFWLENBQWUsVUFBakgsRUFBNkg7QUFDekgsUUFBQSxhQUFhLENBQUMsRUFBRCxDQUFiLENBQWtCLFlBQWxCLENBQStCLFFBQS9CLENBQXdDLFVBQVUsQ0FBQyxFQUFELENBQVYsQ0FBZSxVQUF2RDtBQUNIO0FBQ0o7QUFDSixHQWhCRDtBQWlCSDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbE1EOzs7Ozs7SUFLTSxLO0FBQ0YsbUJBSUM7QUFBQTs7QUFBQSxRQUhHLE1BR0gsdUVBSFksUUFBUSxDQUFDLGFBQVQsQ0FBdUIsZUFBdkIsQ0FHWjtBQUFBLFFBRkcsS0FFSCx1RUFGVyxNQUFNLENBQUMsVUFFbEI7QUFBQSxRQURHLE1BQ0gsdUVBRFksTUFBTSxDQUFDLFdBQ25CO0FBQUE7QUFJRyxTQUFLLE1BQUwsR0FBYyxNQUFkO0FBS0EsU0FBSyxLQUFMLEdBQWE7QUFDVCxNQUFBLEtBQUssRUFBRSxLQURFO0FBRVQsTUFBQSxNQUFNLEVBQUU7QUFGQyxLQUFiO0FBUUEsU0FBSyxVQUFMLEdBQWtCLEVBQWxCO0FBT0EsU0FBSyxLQUFMLEdBQWEsSUFBSSxLQUFLLENBQUMsS0FBVixFQUFiO0FBS0EsU0FBSyxNQUFMLEdBQWMsSUFBSSxLQUFLLENBQUMsaUJBQVYsQ0FBNEIsRUFBNUIsRUFBZ0MsS0FBSyxLQUFMLENBQVcsS0FBWCxHQUFtQixLQUFLLEtBQUwsQ0FBVyxNQUE5RCxFQUFzRSxHQUF0RSxFQUEyRSxHQUEzRSxDQUFkO0FBS0EsUUFBTSxRQUFRLEdBQUcsSUFBSSxLQUFLLENBQUMsWUFBVixDQUF1QixTQUF2QixFQUFrQyxHQUFsQyxDQUFqQjtBQUNBLFNBQUssS0FBTCxDQUFXLEdBQVgsQ0FBZSxRQUFmO0FBS0EsUUFBTSxVQUFVLEdBQUcsSUFBSSxLQUFLLENBQUMsVUFBVixDQUFxQixHQUFyQixFQUEwQixHQUExQixDQUFuQjtBQUNBLFNBQUssS0FBTCxDQUFXLEdBQVgsQ0FBZSxVQUFmO0FBS0EsU0FBSyxTQUFMLEdBQWlCLEVBQWpCO0FBQ0EsU0FBSyxlQUFMO0FBTUEsU0FBSyxRQUFMLEdBQWdCLElBQUksS0FBSyxDQUFDLGFBQVYsQ0FBd0I7QUFDcEMsTUFBQSxNQUFNLEVBQUUsS0FBSyxNQUR1QjtBQUVwQyxNQUFBLFNBQVMsRUFBRTtBQUZ5QixLQUF4QixDQUFoQjtBQUlBLFNBQUssUUFBTCxDQUFjLE9BQWQsQ0FBc0IsS0FBSyxLQUFMLENBQVcsS0FBakMsRUFBd0MsS0FBSyxLQUFMLENBQVcsTUFBbkQ7QUFDQSxTQUFLLFFBQUwsQ0FBYyxhQUFkLENBQTRCLElBQUksQ0FBQyxHQUFMLENBQVMsTUFBTSxDQUFDLGdCQUFoQixFQUFrQyxDQUFsQyxDQUE1QjtBQUNBLFNBQUssUUFBTCxDQUFjLGNBQWQsR0FBK0IsS0FBSyxDQUFDLFlBQXJDO0FBQ0EsU0FBSyxRQUFMLENBQWMsYUFBZCxDQUE0QixJQUFJLEtBQUssQ0FBQyxLQUFWLENBQWdCLFNBQWhCLENBQTVCO0FBS0EsSUFBQSxNQUFNLENBQUMsZ0JBQVAsQ0FBd0IsUUFBeEIsRUFBa0MsVUFBQyxDQUFELEVBQU87QUFBRSxNQUFBLEtBQUksQ0FBQyxZQUFMLENBQWtCLENBQWxCO0FBQXNCLEtBQWpFO0FBQ0g7Ozs7V0FFRCxzQkFBYSxDQUFiLEVBQWdCO0FBQ1osV0FBSyxLQUFMLENBQVcsS0FBWCxHQUFtQixNQUFNLENBQUMsVUFBMUI7QUFDQSxXQUFLLEtBQUwsQ0FBVyxNQUFYLEdBQW9CLE1BQU0sQ0FBQyxXQUEzQjtBQUVBLFdBQUssTUFBTCxDQUFZLE1BQVosR0FBcUIsS0FBSyxLQUFMLENBQVcsS0FBWCxHQUFtQixLQUFLLEtBQUwsQ0FBVyxNQUFuRDtBQUNBLFdBQUssTUFBTCxDQUFZLHNCQUFaO0FBRUEsV0FBSyxRQUFMLENBQWMsT0FBZCxDQUFzQixLQUFLLEtBQUwsQ0FBVyxLQUFqQyxFQUF3QyxLQUFLLEtBQUwsQ0FBVyxNQUFuRDtBQUNBLFdBQUssUUFBTCxDQUFjLGFBQWQsQ0FBNEIsSUFBSSxDQUFDLEdBQUwsQ0FBUyxNQUFNLENBQUMsZ0JBQWhCLEVBQWtDLENBQWxDLENBQTVCO0FBQ0g7OztXQUVELDJCQUFrQjtBQUNkLFVBQU0sUUFBUSxHQUFHLElBQUksS0FBSyxDQUFDLFdBQVYsQ0FBc0IsQ0FBdEIsRUFBeUIsQ0FBekIsRUFBNEIsQ0FBNUIsRUFBK0IsRUFBL0IsRUFBbUMsRUFBbkMsRUFBdUMsRUFBdkMsQ0FBakI7QUFDQSxVQUFNLFFBQVEsR0FBRyxJQUFJLEtBQUssQ0FBQyxpQkFBVixDQUE0QjtBQUN6QyxRQUFBLEtBQUssRUFBRSxTQURrQztBQUV6QyxRQUFBLFNBQVMsRUFBRTtBQUY4QixPQUE1QixDQUFqQjs7QUFRQSxXQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBZCxFQUFrQixDQUFDLEdBQUcsRUFBdEIsRUFBMEIsQ0FBQyxJQUFJLENBQS9CLEVBQWtDO0FBQzlCLGFBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFkLEVBQWtCLENBQUMsR0FBRyxFQUF0QixFQUEwQixDQUFDLElBQUksQ0FBL0IsRUFBa0M7QUFDOUIsY0FBSSxDQUFDLElBQUksQ0FBTCxJQUFVLENBQUMsSUFBSSxDQUFuQixFQUFzQjtBQUNsQjtBQUNIOztBQUVELGNBQU0sUUFBUSxHQUFHLElBQUksS0FBSyxDQUFDLElBQVYsQ0FBZSxRQUFmLEVBQXlCLFFBQXpCLENBQWpCO0FBQ0EsVUFBQSxRQUFRLENBQUMsZ0JBQVQsR0FBNEIsS0FBNUI7QUFDQSxVQUFBLFFBQVEsQ0FBQyxRQUFULENBQWtCLEdBQWxCLENBQXNCLENBQXRCLEVBQXlCLE1BQU0sR0FBL0IsRUFBb0MsQ0FBcEM7QUFDQSxVQUFBLFFBQVEsQ0FBQyxZQUFUO0FBQ0EsZUFBSyxLQUFMLENBQVcsR0FBWCxDQUFlLFFBQWY7QUFDQSxlQUFLLFNBQUwsQ0FBZSxJQUFmLENBQW9CLFFBQXBCO0FBQ0g7QUFDSjtBQUtKOzs7OztlQUdVLEs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4SGY7Ozs7OztJQUVNLGlCO0FBQ0YsNkJBQVksTUFBWixFQUFvQjtBQUFBO0FBQ2hCLFNBQUssTUFBTCxHQUFjLE1BQWQ7QUFDQSxTQUFLLE1BQUwsR0FBYyxNQUFNLENBQUMsTUFBckI7QUFDQSxTQUFLLE1BQUwsR0FBYyxNQUFNLENBQUMsSUFBckI7QUFFQSxTQUFLLGVBQUwsR0FBdUIsSUFBSSxLQUFLLENBQUMsT0FBVixFQUF2QjtBQUNBLFNBQUssYUFBTCxHQUFxQixJQUFJLEtBQUssQ0FBQyxPQUFWLEVBQXJCO0FBRUEsU0FBSyxlQUFMLEdBQXVCLElBQXZCO0FBQ0EsU0FBSyxXQUFMLEdBQW1CLElBQUksS0FBSyxDQUFDLE9BQVYsQ0FBa0IsQ0FBbEIsRUFBcUIsQ0FBckIsRUFBd0IsQ0FBeEIsQ0FBbkI7QUFDSDs7OztXQUVELGdCQUFPLEtBQVAsRUFBYztBQUlWLFVBQUksS0FBSyxDQUFDLFdBQU4sQ0FBa0IsQ0FBdEIsRUFBeUI7QUFDckIsYUFBSyxXQUFMLEdBQW1CLElBQUksS0FBSyxDQUFDLE9BQVYsQ0FBa0IsQ0FBbEIsRUFBcUIsR0FBckIsRUFBMEIsQ0FBQyxHQUEzQixDQUFuQjtBQUNILE9BRkQsTUFFTztBQUNILGFBQUssV0FBTCxHQUFtQixJQUFJLEtBQUssQ0FBQyxPQUFWLENBQWtCLENBQWxCLEVBQXFCLENBQXJCLEVBQXdCLENBQXhCLENBQW5CO0FBQ0g7O0FBTUQsVUFBTSxXQUFXLEdBQUcsS0FBSyxvQkFBTCxFQUFwQjtBQUNBLFVBQU0sV0FBVyxHQUFHLEtBQUssb0JBQUwsRUFBcEI7QUFLQSxXQUFLLGVBQUwsQ0FBcUIsSUFBckIsQ0FBMEIsV0FBMUIsRUFBdUMsR0FBdkM7QUFDQSxXQUFLLGFBQUwsQ0FBbUIsSUFBbkIsQ0FBd0IsV0FBeEIsRUFBcUMsR0FBckM7QUFFQSxXQUFLLE1BQUwsQ0FBWSxRQUFaLENBQXFCLElBQXJCLENBQTBCLEtBQUssZUFBL0I7QUFDQSxXQUFLLE1BQUwsQ0FBWSxNQUFaLENBQW1CLEtBQUssYUFBeEI7QUFDSDs7O1dBRUQsZ0NBQXVCO0FBVW5CLFVBQU0sV0FBVyxHQUFHLEtBQUssV0FBekI7QUFHQSxNQUFBLFdBQVcsQ0FBQyxlQUFaLENBQTRCLEtBQUssTUFBTCxDQUFZLFVBQXhDO0FBQ0EsTUFBQSxXQUFXLENBQUMsR0FBWixDQUFnQixLQUFLLE1BQUwsQ0FBWSxRQUE1QjtBQUNBLGFBQU8sV0FBUDtBQUNIOzs7V0FFRCxnQ0FBdUI7QUFDbkIsVUFBTSxXQUFXLEdBQUcsSUFBSSxLQUFLLENBQUMsT0FBVixDQUFrQixDQUFsQixFQUFxQixDQUFyQixFQUF3QixDQUFDLENBQXpCLENBQXBCO0FBQ0EsTUFBQSxXQUFXLENBQUMsZUFBWixDQUE0QixLQUFLLE1BQUwsQ0FBWSxVQUF4QztBQUNBLE1BQUEsV0FBVyxDQUFDLEdBQVosQ0FBZ0IsS0FBSyxNQUFMLENBQVksUUFBNUI7QUFDQSxhQUFPLFdBQVA7QUFDSDs7Ozs7ZUFJVSxpQiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsImZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlMaWtlVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXN5bmNUb0dlbmVyYXRvciwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NyZWF0ZUNsYXNzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIHN1cGVyUHJvcEJhc2UgPSByZXF1aXJlKFwiLi9zdXBlclByb3BCYXNlLmpzXCIpO1xuXG5mdW5jdGlvbiBfZ2V0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9nZXQgPSBSZWZsZWN0LmdldCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgIHZhciBiYXNlID0gc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICAgIGlmICghYmFzZSkgcmV0dXJuO1xuICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcblxuICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG4gIH1cblxuICByZXR1cm4gX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mLmpzXCIpO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW5oZXJpdHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgIFwiZGVmYXVsdFwiOiBvYmpcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG5cbiAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG5cbiAgdmFyIF9zLCBfZTtcblxuICB0cnkge1xuICAgIGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlUmVzdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4vdHlwZW9mLmpzXCIpW1wiZGVmYXVsdFwiXTtcblxudmFyIGFzc2VydFRoaXNJbml0aWFsaXplZCA9IHJlcXVpcmUoXCIuL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qc1wiKTtcblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuXG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBhcnJheVdpdGhIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aEhvbGVzLmpzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5TGltaXQgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qc1wiKTtcblxudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanNcIik7XG5cbnZhciBub25JdGVyYWJsZVJlc3QgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVJlc3QuanNcIik7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NsaWNlZFRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9nZXRQcm90b3R5cGVPZi5qc1wiKTtcblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zdXBlclByb3BCYXNlLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiAobW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cyksIF90eXBlb2Yob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5LmpzXCIpO1xuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG4iLCIvKipcbiAqIGRhdC1ndWkgSmF2YVNjcmlwdCBDb250cm9sbGVyIExpYnJhcnlcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9kYXQtZ3VpXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgRGF0YSBBcnRzIFRlYW0sIEdvb2dsZSBDcmVhdGl2ZSBMYWJcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLmRhdCA9IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfX18kaW5zZXJ0U3R5bGUoY3NzKSB7XG4gIGlmICghY3NzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cbiAgc3R5bGUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gIHN0eWxlLmlubmVySFRNTCA9IGNzcztcbiAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cbiAgcmV0dXJuIGNzcztcbn1cblxuZnVuY3Rpb24gY29sb3JUb1N0cmluZyAoY29sb3IsIGZvcmNlQ1NTSGV4KSB7XG4gIHZhciBjb2xvckZvcm1hdCA9IGNvbG9yLl9fc3RhdGUuY29udmVyc2lvbk5hbWUudG9TdHJpbmcoKTtcbiAgdmFyIHIgPSBNYXRoLnJvdW5kKGNvbG9yLnIpO1xuICB2YXIgZyA9IE1hdGgucm91bmQoY29sb3IuZyk7XG4gIHZhciBiID0gTWF0aC5yb3VuZChjb2xvci5iKTtcbiAgdmFyIGEgPSBjb2xvci5hO1xuICB2YXIgaCA9IE1hdGgucm91bmQoY29sb3IuaCk7XG4gIHZhciBzID0gY29sb3Iucy50b0ZpeGVkKDEpO1xuICB2YXIgdiA9IGNvbG9yLnYudG9GaXhlZCgxKTtcbiAgaWYgKGZvcmNlQ1NTSGV4IHx8IGNvbG9yRm9ybWF0ID09PSAnVEhSRUVfQ0hBUl9IRVgnIHx8IGNvbG9yRm9ybWF0ID09PSAnU0lYX0NIQVJfSEVYJykge1xuICAgIHZhciBzdHIgPSBjb2xvci5oZXgudG9TdHJpbmcoMTYpO1xuICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgNikge1xuICAgICAgc3RyID0gJzAnICsgc3RyO1xuICAgIH1cbiAgICByZXR1cm4gJyMnICsgc3RyO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnQ1NTX1JHQicpIHtcbiAgICByZXR1cm4gJ3JnYignICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJyknO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnQ1NTX1JHQkEnKSB7XG4gICAgcmV0dXJuICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnSEVYJykge1xuICAgIHJldHVybiAnMHgnICsgY29sb3IuaGV4LnRvU3RyaW5nKDE2KTtcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ1JHQl9BUlJBWScpIHtcbiAgICByZXR1cm4gJ1snICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJ10nO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnUkdCQV9BUlJBWScpIHtcbiAgICByZXR1cm4gJ1snICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICddJztcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ1JHQl9PQkonKSB7XG4gICAgcmV0dXJuICd7cjonICsgciArICcsZzonICsgZyArICcsYjonICsgYiArICd9JztcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ1JHQkFfT0JKJykge1xuICAgIHJldHVybiAne3I6JyArIHIgKyAnLGc6JyArIGcgKyAnLGI6JyArIGIgKyAnLGE6JyArIGEgKyAnfSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdIU1ZfT0JKJykge1xuICAgIHJldHVybiAne2g6JyArIGggKyAnLHM6JyArIHMgKyAnLHY6JyArIHYgKyAnfSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdIU1ZBX09CSicpIHtcbiAgICByZXR1cm4gJ3toOicgKyBoICsgJyxzOicgKyBzICsgJyx2OicgKyB2ICsgJyxhOicgKyBhICsgJ30nO1xuICB9XG4gIHJldHVybiAndW5rbm93biBmb3JtYXQnO1xufVxuXG52YXIgQVJSX0VBQ0ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcbnZhciBBUlJfU0xJQ0UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgQ29tbW9uID0ge1xuICBCUkVBSzoge30sXG4gIGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCkge1xuICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICB2YXIga2V5cyA9IHRoaXMuaXNPYmplY3Qob2JqKSA/IE9iamVjdC5rZXlzKG9iaikgOiBbXTtcbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1VuZGVmaW5lZChvYmpba2V5XSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH0sXG4gIGRlZmF1bHRzOiBmdW5jdGlvbiBkZWZhdWx0cyh0YXJnZXQpIHtcbiAgICB0aGlzLmVhY2goQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgdmFyIGtleXMgPSB0aGlzLmlzT2JqZWN0KG9iaikgPyBPYmplY3Qua2V5cyhvYmopIDogW107XG4gICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAodGhpcy5pc1VuZGVmaW5lZCh0YXJnZXRba2V5XSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH0sXG4gIGNvbXBvc2U6IGZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gICAgdmFyIHRvQ2FsbCA9IEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIGZvciAodmFyIGkgPSB0b0NhbGwubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYXJncyA9IFt0b0NhbGxbaV0uYXBwbHkodGhpcywgYXJncyldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgfTtcbiAgfSxcbiAgZWFjaDogZnVuY3Rpb24gZWFjaChvYmosIGl0ciwgc2NvcGUpIHtcbiAgICBpZiAoIW9iaikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoQVJSX0VBQ0ggJiYgb2JqLmZvckVhY2ggJiYgb2JqLmZvckVhY2ggPT09IEFSUl9FQUNIKSB7XG4gICAgICBvYmouZm9yRWFjaChpdHIsIHNjb3BlKTtcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09IG9iai5sZW5ndGggKyAwKSB7XG4gICAgICB2YXIga2V5ID0gdm9pZCAwO1xuICAgICAgdmFyIGwgPSB2b2lkIDA7XG4gICAgICBmb3IgKGtleSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBrZXkgPCBsOyBrZXkrKykge1xuICAgICAgICBpZiAoa2V5IGluIG9iaiAmJiBpdHIuY2FsbChzY29wZSwgb2JqW2tleV0sIGtleSkgPT09IHRoaXMuQlJFQUspIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgX2tleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKGl0ci5jYWxsKHNjb3BlLCBvYmpbX2tleV0sIF9rZXkpID09PSB0aGlzLkJSRUFLKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBkZWZlcjogZnVuY3Rpb24gZGVmZXIoZm5jKSB7XG4gICAgc2V0VGltZW91dChmbmMsIDApO1xuICB9LFxuICBkZWJvdW5jZTogZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgdGhyZXNob2xkLCBjYWxsSW1tZWRpYXRlbHkpIHtcbiAgICB2YXIgdGltZW91dCA9IHZvaWQgMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9iaiA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGZ1bmN0aW9uIGRlbGF5ZWQoKSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAoIWNhbGxJbW1lZGlhdGVseSkgZnVuYy5hcHBseShvYmosIGFyZ3MpO1xuICAgICAgfVxuICAgICAgdmFyIGNhbGxOb3cgPSBjYWxsSW1tZWRpYXRlbHkgfHwgIXRpbWVvdXQ7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChkZWxheWVkLCB0aHJlc2hvbGQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgZnVuYy5hcHBseShvYmosIGFyZ3MpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgaWYgKG9iai50b0FycmF5KSByZXR1cm4gb2JqLnRvQXJyYXkoKTtcbiAgICByZXR1cm4gQVJSX1NMSUNFLmNhbGwob2JqKTtcbiAgfSxcbiAgaXNVbmRlZmluZWQ6IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHVuZGVmaW5lZDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbiBpc051bGwob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOYU46IGZ1bmN0aW9uIChfaXNOYU4pIHtcbiAgICBmdW5jdGlvbiBpc05hTihfeCkge1xuICAgICAgcmV0dXJuIF9pc05hTi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBpc05hTi50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaXNOYU4udG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIHJldHVybiBpc05hTjtcbiAgfShmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIGlzTmFOKG9iaik7XG4gIH0pLFxuICBpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqLmNvbnN0cnVjdG9yID09PSBBcnJheTtcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xuICB9LFxuICBpc051bWJlcjogZnVuY3Rpb24gaXNOdW1iZXIob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gb2JqICsgMDtcbiAgfSxcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG9iaiArICcnO1xuICB9LFxuICBpc0Jvb2xlYW46IGZ1bmN0aW9uIGlzQm9vbGVhbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBmYWxzZSB8fCBvYmogPT09IHRydWU7XG4gIH0sXG4gIGlzRnVuY3Rpb246IGZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xuICB9XG59O1xuXG52YXIgSU5URVJQUkVUQVRJT05TID0gW1xue1xuICBsaXRtdXM6IENvbW1vbi5pc1N0cmluZyxcbiAgY29udmVyc2lvbnM6IHtcbiAgICBUSFJFRV9DSEFSX0hFWDoge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9eIyhbQS1GMC05XSkoW0EtRjAtOV0pKFtBLUYwLTldKSQvaSk7XG4gICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgIGhleDogcGFyc2VJbnQoJzB4JyArIHRlc3RbMV0udG9TdHJpbmcoKSArIHRlc3RbMV0udG9TdHJpbmcoKSArIHRlc3RbMl0udG9TdHJpbmcoKSArIHRlc3RbMl0udG9TdHJpbmcoKSArIHRlc3RbM10udG9TdHJpbmcoKSArIHRlc3RbM10udG9TdHJpbmcoKSwgMClcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogY29sb3JUb1N0cmluZ1xuICAgIH0sXG4gICAgU0lYX0NIQVJfSEVYOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL14jKFtBLUYwLTldezZ9KSQvaSk7XG4gICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgIGhleDogcGFyc2VJbnQoJzB4JyArIHRlc3RbMV0udG9TdHJpbmcoKSwgMClcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogY29sb3JUb1N0cmluZ1xuICAgIH0sXG4gICAgQ1NTX1JHQjoge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9ecmdiXFwoXFxzKiguKylcXHMqLFxccyooLispXFxzKixcXHMqKC4rKVxccypcXCkvKTtcbiAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgcjogcGFyc2VGbG9hdCh0ZXN0WzFdKSxcbiAgICAgICAgICBnOiBwYXJzZUZsb2F0KHRlc3RbMl0pLFxuICAgICAgICAgIGI6IHBhcnNlRmxvYXQodGVzdFszXSlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogY29sb3JUb1N0cmluZ1xuICAgIH0sXG4gICAgQ1NTX1JHQkE6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXnJnYmFcXChcXHMqKC4rKVxccyosXFxzKiguKylcXHMqLFxccyooLispXFxzKixcXHMqKC4rKVxccypcXCkvKTtcbiAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgcjogcGFyc2VGbG9hdCh0ZXN0WzFdKSxcbiAgICAgICAgICBnOiBwYXJzZUZsb2F0KHRlc3RbMl0pLFxuICAgICAgICAgIGI6IHBhcnNlRmxvYXQodGVzdFszXSksXG4gICAgICAgICAgYTogcGFyc2VGbG9hdCh0ZXN0WzRdKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBjb2xvclRvU3RyaW5nXG4gICAgfVxuICB9XG59LFxue1xuICBsaXRtdXM6IENvbW1vbi5pc051bWJlcixcbiAgY29udmVyc2lvbnM6IHtcbiAgICBIRVg6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgaGV4OiBvcmlnaW5hbCxcbiAgICAgICAgICBjb252ZXJzaW9uTmFtZTogJ0hFWCdcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yLmhleDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG57XG4gIGxpdG11czogQ29tbW9uLmlzQXJyYXksXG4gIGNvbnZlcnNpb25zOiB7XG4gICAgUkdCX0FSUkFZOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgcjogb3JpZ2luYWxbMF0sXG4gICAgICAgICAgZzogb3JpZ2luYWxbMV0sXG4gICAgICAgICAgYjogb3JpZ2luYWxbMl1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIFtjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFJHQkFfQVJSQVk6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgaWYgKG9yaWdpbmFsLmxlbmd0aCAhPT0gNCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICByOiBvcmlnaW5hbFswXSxcbiAgICAgICAgICBnOiBvcmlnaW5hbFsxXSxcbiAgICAgICAgICBiOiBvcmlnaW5hbFsyXSxcbiAgICAgICAgICBhOiBvcmlnaW5hbFszXVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuICAgICAgICByZXR1cm4gW2NvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIGNvbG9yLmFdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSxcbntcbiAgbGl0bXVzOiBDb21tb24uaXNPYmplY3QsXG4gIGNvbnZlcnNpb25zOiB7XG4gICAgUkdCQV9PQko6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgaWYgKENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5yKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuZykgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmIpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5hKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICByOiBvcmlnaW5hbC5yLFxuICAgICAgICAgICAgZzogb3JpZ2luYWwuZyxcbiAgICAgICAgICAgIGI6IG9yaWdpbmFsLmIsXG4gICAgICAgICAgICBhOiBvcmlnaW5hbC5hXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcjogY29sb3IucixcbiAgICAgICAgICBnOiBjb2xvci5nLFxuICAgICAgICAgIGI6IGNvbG9yLmIsXG4gICAgICAgICAgYTogY29sb3IuYVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgUkdCX09CSjoge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnIpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5nKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYikpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgcjogb3JpZ2luYWwucixcbiAgICAgICAgICAgIGc6IG9yaWdpbmFsLmcsXG4gICAgICAgICAgICBiOiBvcmlnaW5hbC5iXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcjogY29sb3IucixcbiAgICAgICAgICBnOiBjb2xvci5nLFxuICAgICAgICAgIGI6IGNvbG9yLmJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIEhTVkFfT0JKOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIGlmIChDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuaCkgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnMpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC52KSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3BhY2U6ICdIU1YnLFxuICAgICAgICAgICAgaDogb3JpZ2luYWwuaCxcbiAgICAgICAgICAgIHM6IG9yaWdpbmFsLnMsXG4gICAgICAgICAgICB2OiBvcmlnaW5hbC52LFxuICAgICAgICAgICAgYTogb3JpZ2luYWwuYVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGg6IGNvbG9yLmgsXG4gICAgICAgICAgczogY29sb3IucyxcbiAgICAgICAgICB2OiBjb2xvci52LFxuICAgICAgICAgIGE6IGNvbG9yLmFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIEhTVl9PQko6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgaWYgKENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5oKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwucykgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnYpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNwYWNlOiAnSFNWJyxcbiAgICAgICAgICAgIGg6IG9yaWdpbmFsLmgsXG4gICAgICAgICAgICBzOiBvcmlnaW5hbC5zLFxuICAgICAgICAgICAgdjogb3JpZ2luYWwudlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGg6IGNvbG9yLmgsXG4gICAgICAgICAgczogY29sb3IucyxcbiAgICAgICAgICB2OiBjb2xvci52XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XTtcbnZhciByZXN1bHQgPSB2b2lkIDA7XG52YXIgdG9SZXR1cm4gPSB2b2lkIDA7XG52YXIgaW50ZXJwcmV0ID0gZnVuY3Rpb24gaW50ZXJwcmV0KCkge1xuICB0b1JldHVybiA9IGZhbHNlO1xuICB2YXIgb3JpZ2luYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IENvbW1vbi50b0FycmF5KGFyZ3VtZW50cykgOiBhcmd1bWVudHNbMF07XG4gIENvbW1vbi5lYWNoKElOVEVSUFJFVEFUSU9OUywgZnVuY3Rpb24gKGZhbWlseSkge1xuICAgIGlmIChmYW1pbHkubGl0bXVzKG9yaWdpbmFsKSkge1xuICAgICAgQ29tbW9uLmVhY2goZmFtaWx5LmNvbnZlcnNpb25zLCBmdW5jdGlvbiAoY29udmVyc2lvbiwgY29udmVyc2lvbk5hbWUpIHtcbiAgICAgICAgcmVzdWx0ID0gY29udmVyc2lvbi5yZWFkKG9yaWdpbmFsKTtcbiAgICAgICAgaWYgKHRvUmV0dXJuID09PSBmYWxzZSAmJiByZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgdG9SZXR1cm4gPSByZXN1bHQ7XG4gICAgICAgICAgcmVzdWx0LmNvbnZlcnNpb25OYW1lID0gY29udmVyc2lvbk5hbWU7XG4gICAgICAgICAgcmVzdWx0LmNvbnZlcnNpb24gPSBjb252ZXJzaW9uO1xuICAgICAgICAgIHJldHVybiBDb21tb24uQlJFQUs7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIENvbW1vbi5CUkVBSztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdG9SZXR1cm47XG59O1xuXG52YXIgdG1wQ29tcG9uZW50ID0gdm9pZCAwO1xudmFyIENvbG9yTWF0aCA9IHtcbiAgaHN2X3RvX3JnYjogZnVuY3Rpb24gaHN2X3RvX3JnYihoLCBzLCB2KSB7XG4gICAgdmFyIGhpID0gTWF0aC5mbG9vcihoIC8gNjApICUgNjtcbiAgICB2YXIgZiA9IGggLyA2MCAtIE1hdGguZmxvb3IoaCAvIDYwKTtcbiAgICB2YXIgcCA9IHYgKiAoMS4wIC0gcyk7XG4gICAgdmFyIHEgPSB2ICogKDEuMCAtIGYgKiBzKTtcbiAgICB2YXIgdCA9IHYgKiAoMS4wIC0gKDEuMCAtIGYpICogcyk7XG4gICAgdmFyIGMgPSBbW3YsIHQsIHBdLCBbcSwgdiwgcF0sIFtwLCB2LCB0XSwgW3AsIHEsIHZdLCBbdCwgcCwgdl0sIFt2LCBwLCBxXV1baGldO1xuICAgIHJldHVybiB7XG4gICAgICByOiBjWzBdICogMjU1LFxuICAgICAgZzogY1sxXSAqIDI1NSxcbiAgICAgIGI6IGNbMl0gKiAyNTVcbiAgICB9O1xuICB9LFxuICByZ2JfdG9faHN2OiBmdW5jdGlvbiByZ2JfdG9faHN2KHIsIGcsIGIpIHtcbiAgICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIHZhciBkZWx0YSA9IG1heCAtIG1pbjtcbiAgICB2YXIgaCA9IHZvaWQgMDtcbiAgICB2YXIgcyA9IHZvaWQgMDtcbiAgICBpZiAobWF4ICE9PSAwKSB7XG4gICAgICBzID0gZGVsdGEgLyBtYXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGg6IE5hTixcbiAgICAgICAgczogMCxcbiAgICAgICAgdjogMFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHIgPT09IG1heCkge1xuICAgICAgaCA9IChnIC0gYikgLyBkZWx0YTtcbiAgICB9IGVsc2UgaWYgKGcgPT09IG1heCkge1xuICAgICAgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuICAgIH1cbiAgICBoIC89IDY7XG4gICAgaWYgKGggPCAwKSB7XG4gICAgICBoICs9IDE7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBoOiBoICogMzYwLFxuICAgICAgczogcyxcbiAgICAgIHY6IG1heCAvIDI1NVxuICAgIH07XG4gIH0sXG4gIHJnYl90b19oZXg6IGZ1bmN0aW9uIHJnYl90b19oZXgociwgZywgYikge1xuICAgIHZhciBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudCgwLCAyLCByKTtcbiAgICBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudChoZXgsIDEsIGcpO1xuICAgIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KGhleCwgMCwgYik7XG4gICAgcmV0dXJuIGhleDtcbiAgfSxcbiAgY29tcG9uZW50X2Zyb21faGV4OiBmdW5jdGlvbiBjb21wb25lbnRfZnJvbV9oZXgoaGV4LCBjb21wb25lbnRJbmRleCkge1xuICAgIHJldHVybiBoZXggPj4gY29tcG9uZW50SW5kZXggKiA4ICYgMHhGRjtcbiAgfSxcbiAgaGV4X3dpdGhfY29tcG9uZW50OiBmdW5jdGlvbiBoZXhfd2l0aF9jb21wb25lbnQoaGV4LCBjb21wb25lbnRJbmRleCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPDwgKHRtcENvbXBvbmVudCA9IGNvbXBvbmVudEluZGV4ICogOCkgfCBoZXggJiB+KDB4RkYgPDwgdG1wQ29tcG9uZW50KTtcbiAgfVxufTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmo7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cbnZhciBjcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG5cblxuXG5cblxudmFyIGdldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4gIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTtcblxuICBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuXG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7XG4gICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGdldHRlciA9IGRlc2MuZ2V0O1xuXG4gICAgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7XG4gIH1cbn07XG5cbnZhciBpbmhlcml0cyA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07XG5cbnZhciBDb2xvciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29sb3IoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sb3IpO1xuICAgIHRoaXMuX19zdGF0ZSA9IGludGVycHJldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBpbnRlcnByZXQgY29sb3IgYXJndW1lbnRzJyk7XG4gICAgfVxuICAgIHRoaXMuX19zdGF0ZS5hID0gdGhpcy5fX3N0YXRlLmEgfHwgMTtcbiAgfVxuICBjcmVhdGVDbGFzcyhDb2xvciwgW3tcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGNvbG9yVG9TdHJpbmcodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9IZXhTdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0hleFN0cmluZygpIHtcbiAgICAgIHJldHVybiBjb2xvclRvU3RyaW5nKHRoaXMsIHRydWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvT3JpZ2luYWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b09yaWdpbmFsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5jb252ZXJzaW9uLndyaXRlKHRoaXMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29sb3I7XG59KCk7XG5mdW5jdGlvbiBkZWZpbmVSR0JDb21wb25lbnQodGFyZ2V0LCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbXBvbmVudCwge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSA9PT0gJ1JHQicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuICAgICAgfVxuICAgICAgQ29sb3IucmVjYWxjdWxhdGVSR0IodGhpcywgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCk7XG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2KSB7XG4gICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnUkdCJykge1xuICAgICAgICBDb2xvci5yZWNhbGN1bGF0ZVJHQih0aGlzLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KTtcbiAgICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ1JHQic7XG4gICAgICB9XG4gICAgICB0aGlzLl9fc3RhdGVbY29tcG9uZW50XSA9IHY7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGRlZmluZUhTVkNvbXBvbmVudCh0YXJnZXQsIGNvbXBvbmVudCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb21wb25lbnQsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgPT09ICdIU1YnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcbiAgICAgIH1cbiAgICAgIENvbG9yLnJlY2FsY3VsYXRlSFNWKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ0hTVicpIHtcbiAgICAgICAgQ29sb3IucmVjYWxjdWxhdGVIU1YodGhpcyk7XG4gICAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdIU1YnO1xuICAgICAgfVxuICAgICAgdGhpcy5fX3N0YXRlW2NvbXBvbmVudF0gPSB2O1xuICAgIH1cbiAgfSk7XG59XG5Db2xvci5yZWNhbGN1bGF0ZVJHQiA9IGZ1bmN0aW9uIChjb2xvciwgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCkge1xuICBpZiAoY29sb3IuX19zdGF0ZS5zcGFjZSA9PT0gJ0hFWCcpIHtcbiAgICBjb2xvci5fX3N0YXRlW2NvbXBvbmVudF0gPSBDb2xvck1hdGguY29tcG9uZW50X2Zyb21faGV4KGNvbG9yLl9fc3RhdGUuaGV4LCBjb21wb25lbnRIZXhJbmRleCk7XG4gIH0gZWxzZSBpZiAoY29sb3IuX19zdGF0ZS5zcGFjZSA9PT0gJ0hTVicpIHtcbiAgICBDb21tb24uZXh0ZW5kKGNvbG9yLl9fc3RhdGUsIENvbG9yTWF0aC5oc3ZfdG9fcmdiKGNvbG9yLl9fc3RhdGUuaCwgY29sb3IuX19zdGF0ZS5zLCBjb2xvci5fX3N0YXRlLnYpKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvcnJ1cHRlZCBjb2xvciBzdGF0ZScpO1xuICB9XG59O1xuQ29sb3IucmVjYWxjdWxhdGVIU1YgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgdmFyIHJlc3VsdCA9IENvbG9yTWF0aC5yZ2JfdG9faHN2KGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuICBDb21tb24uZXh0ZW5kKGNvbG9yLl9fc3RhdGUsIHtcbiAgICBzOiByZXN1bHQucyxcbiAgICB2OiByZXN1bHQudlxuICB9KTtcbiAgaWYgKCFDb21tb24uaXNOYU4ocmVzdWx0LmgpKSB7XG4gICAgY29sb3IuX19zdGF0ZS5oID0gcmVzdWx0Lmg7XG4gIH0gZWxzZSBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKGNvbG9yLl9fc3RhdGUuaCkpIHtcbiAgICBjb2xvci5fX3N0YXRlLmggPSAwO1xuICB9XG59O1xuQ29sb3IuQ09NUE9ORU5UUyA9IFsncicsICdnJywgJ2InLCAnaCcsICdzJywgJ3YnLCAnaGV4JywgJ2EnXTtcbmRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdyJywgMik7XG5kZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnZycsIDEpO1xuZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2InLCAwKTtcbmRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdoJyk7XG5kZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAncycpO1xuZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3YnKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvci5wcm90b3R5cGUsICdhJywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmE7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICB0aGlzLl9fc3RhdGUuYSA9IHY7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yLnByb3RvdHlwZSwgJ2hleCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ0hFWCcpIHtcbiAgICAgIHRoaXMuX19zdGF0ZS5oZXggPSBDb2xvck1hdGgucmdiX3RvX2hleCh0aGlzLnIsIHRoaXMuZywgdGhpcy5iKTtcbiAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdIRVgnO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmhleDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdIRVgnO1xuICAgIHRoaXMuX19zdGF0ZS5oZXggPSB2O1xuICB9XG59KTtcblxudmFyIENvbnRyb2xsZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRyb2xsZXIpO1xuICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgdGhpcy5fX29uQ2hhbmdlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBjcmVhdGVDbGFzcyhDb250cm9sbGVyLCBbe1xuICAgIGtleTogJ29uQ2hhbmdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25DaGFuZ2UoZm5jKSB7XG4gICAgICB0aGlzLl9fb25DaGFuZ2UgPSBmbmM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkZpbmlzaENoYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRmluaXNoQ2hhbmdlKGZuYykge1xuICAgICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlID0gZm5jO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZShuZXdWYWx1ZSkge1xuICAgICAgdGhpcy5vYmplY3RbdGhpcy5wcm9wZXJ0eV0gPSBuZXdWYWx1ZTtcbiAgICAgIGlmICh0aGlzLl9fb25DaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fX29uQ2hhbmdlLmNhbGwodGhpcywgbmV3VmFsdWUpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMub2JqZWN0W3RoaXMucHJvcGVydHldO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZURpc3BsYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaXNNb2RpZmllZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzTW9kaWZpZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbml0aWFsVmFsdWUgIT09IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENvbnRyb2xsZXI7XG59KCk7XG5cbnZhciBFVkVOVF9NQVAgPSB7XG4gIEhUTUxFdmVudHM6IFsnY2hhbmdlJ10sXG4gIE1vdXNlRXZlbnRzOiBbJ2NsaWNrJywgJ21vdXNlbW92ZScsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZW92ZXInXSxcbiAgS2V5Ym9hcmRFdmVudHM6IFsna2V5ZG93biddXG59O1xudmFyIEVWRU5UX01BUF9JTlYgPSB7fTtcbkNvbW1vbi5lYWNoKEVWRU5UX01BUCwgZnVuY3Rpb24gKHYsIGspIHtcbiAgQ29tbW9uLmVhY2godiwgZnVuY3Rpb24gKGUpIHtcbiAgICBFVkVOVF9NQVBfSU5WW2VdID0gaztcbiAgfSk7XG59KTtcbnZhciBDU1NfVkFMVUVfUElYRUxTID0gLyhcXGQrKFxcLlxcZCspPylweC87XG5mdW5jdGlvbiBjc3NWYWx1ZVRvUGl4ZWxzKHZhbCkge1xuICBpZiAodmFsID09PSAnMCcgfHwgQ29tbW9uLmlzVW5kZWZpbmVkKHZhbCkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgbWF0Y2ggPSB2YWwubWF0Y2goQ1NTX1ZBTFVFX1BJWEVMUyk7XG4gIGlmICghQ29tbW9uLmlzTnVsbChtYXRjaCkpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG52YXIgZG9tID0ge1xuICBtYWtlU2VsZWN0YWJsZTogZnVuY3Rpb24gbWFrZVNlbGVjdGFibGUoZWxlbSwgc2VsZWN0YWJsZSkge1xuICAgIGlmIChlbGVtID09PSB1bmRlZmluZWQgfHwgZWxlbS5zdHlsZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgZWxlbS5vbnNlbGVjdHN0YXJ0ID0gc2VsZWN0YWJsZSA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IDogZnVuY3Rpb24gKCkge307XG4gICAgZWxlbS5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gc2VsZWN0YWJsZSA/ICdhdXRvJyA6ICdub25lJztcbiAgICBlbGVtLnN0eWxlLktodG1sVXNlclNlbGVjdCA9IHNlbGVjdGFibGUgPyAnYXV0bycgOiAnbm9uZSc7XG4gICAgZWxlbS51bnNlbGVjdGFibGUgPSBzZWxlY3RhYmxlID8gJ29uJyA6ICdvZmYnO1xuICB9LFxuICBtYWtlRnVsbHNjcmVlbjogZnVuY3Rpb24gbWFrZUZ1bGxzY3JlZW4oZWxlbSwgaG9yLCB2ZXJ0KSB7XG4gICAgdmFyIHZlcnRpY2FsID0gdmVydDtcbiAgICB2YXIgaG9yaXpvbnRhbCA9IGhvcjtcbiAgICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKGhvcml6b250YWwpKSB7XG4gICAgICBob3Jpem9udGFsID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKENvbW1vbi5pc1VuZGVmaW5lZCh2ZXJ0aWNhbCkpIHtcbiAgICAgIHZlcnRpY2FsID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxlbS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgIGVsZW0uc3R5bGUubGVmdCA9IDA7XG4gICAgICBlbGVtLnN0eWxlLnJpZ2h0ID0gMDtcbiAgICB9XG4gICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICBlbGVtLnN0eWxlLnRvcCA9IDA7XG4gICAgICBlbGVtLnN0eWxlLmJvdHRvbSA9IDA7XG4gICAgfVxuICB9LFxuICBmYWtlRXZlbnQ6IGZ1bmN0aW9uIGZha2VFdmVudChlbGVtLCBldmVudFR5cGUsIHBhcnMsIGF1eCkge1xuICAgIHZhciBwYXJhbXMgPSBwYXJzIHx8IHt9O1xuICAgIHZhciBjbGFzc05hbWUgPSBFVkVOVF9NQVBfSU5WW2V2ZW50VHlwZV07XG4gICAgaWYgKCFjbGFzc05hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXZlbnQgdHlwZSAnICsgZXZlbnRUeXBlICsgJyBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cbiAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoY2xhc3NOYW1lKTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgY2FzZSAnTW91c2VFdmVudHMnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNsaWVudFggPSBwYXJhbXMueCB8fCBwYXJhbXMuY2xpZW50WCB8fCAwO1xuICAgICAgICAgIHZhciBjbGllbnRZID0gcGFyYW1zLnkgfHwgcGFyYW1zLmNsaWVudFkgfHwgMDtcbiAgICAgICAgICBldnQuaW5pdE1vdXNlRXZlbnQoZXZlbnRUeXBlLCBwYXJhbXMuYnViYmxlcyB8fCBmYWxzZSwgcGFyYW1zLmNhbmNlbGFibGUgfHwgdHJ1ZSwgd2luZG93LCBwYXJhbXMuY2xpY2tDb3VudCB8fCAxLCAwLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZLFxuICAgICAgICAgIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnS2V5Ym9hcmRFdmVudHMnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGluaXQgPSBldnQuaW5pdEtleWJvYXJkRXZlbnQgfHwgZXZ0LmluaXRLZXlFdmVudDtcbiAgICAgICAgICBDb21tb24uZGVmYXVsdHMocGFyYW1zLCB7XG4gICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY3RybEtleTogZmFsc2UsXG4gICAgICAgICAgICBhbHRLZXk6IGZhbHNlLFxuICAgICAgICAgICAgc2hpZnRLZXk6IGZhbHNlLFxuICAgICAgICAgICAgbWV0YUtleTogZmFsc2UsXG4gICAgICAgICAgICBrZXlDb2RlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjaGFyQ29kZTogdW5kZWZpbmVkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaW5pdChldmVudFR5cGUsIHBhcmFtcy5idWJibGVzIHx8IGZhbHNlLCBwYXJhbXMuY2FuY2VsYWJsZSwgd2luZG93LCBwYXJhbXMuY3RybEtleSwgcGFyYW1zLmFsdEtleSwgcGFyYW1zLnNoaWZ0S2V5LCBwYXJhbXMubWV0YUtleSwgcGFyYW1zLmtleUNvZGUsIHBhcmFtcy5jaGFyQ29kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBldnQuaW5pdEV2ZW50KGV2ZW50VHlwZSwgcGFyYW1zLmJ1YmJsZXMgfHwgZmFsc2UsIHBhcmFtcy5jYW5jZWxhYmxlIHx8IHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIENvbW1vbi5kZWZhdWx0cyhldnQsIGF1eCk7XG4gICAgZWxlbS5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gIH0sXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoZWxlbSwgZXZlbnQsIGZ1bmMsIG5ld0Jvb2wpIHtcbiAgICB2YXIgYm9vbCA9IG5ld0Jvb2wgfHwgZmFsc2U7XG4gICAgaWYgKGVsZW0uYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmdW5jLCBib29sKTtcbiAgICB9IGVsc2UgaWYgKGVsZW0uYXR0YWNoRXZlbnQpIHtcbiAgICAgIGVsZW0uYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBmdW5jKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbTtcbiAgfSxcbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoZWxlbSwgZXZlbnQsIGZ1bmMsIG5ld0Jvb2wpIHtcbiAgICB2YXIgYm9vbCA9IG5ld0Jvb2wgfHwgZmFsc2U7XG4gICAgaWYgKGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBmdW5jLCBib29sKTtcbiAgICB9IGVsc2UgaWYgKGVsZW0uZGV0YWNoRXZlbnQpIHtcbiAgICAgIGVsZW0uZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBmdW5jKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbTtcbiAgfSxcbiAgYWRkQ2xhc3M6IGZ1bmN0aW9uIGFkZENsYXNzKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgIGlmIChlbGVtLmNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICB9IGVsc2UgaWYgKGVsZW0uY2xhc3NOYW1lICE9PSBjbGFzc05hbWUpIHtcbiAgICAgIHZhciBjbGFzc2VzID0gZWxlbS5jbGFzc05hbWUuc3BsaXQoLyArLyk7XG4gICAgICBpZiAoY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSkgPT09IC0xKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChjbGFzc05hbWUpO1xuICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpLnJlcGxhY2UoL15cXHMrLywgJycpLnJlcGxhY2UoL1xccyskLywgJycpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZG9tO1xuICB9LFxuICByZW1vdmVDbGFzczogZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbSwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgaWYgKGVsZW0uY2xhc3NOYW1lID09PSBjbGFzc05hbWUpIHtcbiAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2xhc3NlcyA9IGVsZW0uY2xhc3NOYW1lLnNwbGl0KC8gKy8pO1xuICAgICAgICB2YXIgaW5kZXggPSBjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIGNsYXNzZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0uY2xhc3NOYW1lID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gZG9tO1xuICB9LFxuICBoYXNDbGFzczogZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbSwgY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoJyg/Ol58XFxcXHMrKScgKyBjbGFzc05hbWUgKyAnKD86XFxcXHMrfCQpJykudGVzdChlbGVtLmNsYXNzTmFtZSkgfHwgZmFsc2U7XG4gIH0sXG4gIGdldFdpZHRoOiBmdW5jdGlvbiBnZXRXaWR0aChlbGVtKSB7XG4gICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcbiAgICByZXR1cm4gY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLWxlZnQtd2lkdGgnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItcmlnaHQtd2lkdGgnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLWxlZnQnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLXJpZ2h0J10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZS53aWR0aCk7XG4gIH0sXG4gIGdldEhlaWdodDogZnVuY3Rpb24gZ2V0SGVpZ2h0KGVsZW0pIHtcbiAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW0pO1xuICAgIHJldHVybiBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItdG9wLXdpZHRoJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLWJvdHRvbS13aWR0aCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctdG9wJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy1ib3R0b20nXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlLmhlaWdodCk7XG4gIH0sXG4gIGdldE9mZnNldDogZnVuY3Rpb24gZ2V0T2Zmc2V0KGVsKSB7XG4gICAgdmFyIGVsZW0gPSBlbDtcbiAgICB2YXIgb2Zmc2V0ID0geyBsZWZ0OiAwLCB0b3A6IDAgfTtcbiAgICBpZiAoZWxlbS5vZmZzZXRQYXJlbnQpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgb2Zmc2V0LmxlZnQgKz0gZWxlbS5vZmZzZXRMZWZ0O1xuICAgICAgICBvZmZzZXQudG9wICs9IGVsZW0ub2Zmc2V0VG9wO1xuICAgICAgICBlbGVtID0gZWxlbS5vZmZzZXRQYXJlbnQ7XG4gICAgICB9IHdoaWxlIChlbGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfSxcbiAgaXNBY3RpdmU6IGZ1bmN0aW9uIGlzQWN0aXZlKGVsZW0pIHtcbiAgICByZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoZWxlbS50eXBlIHx8IGVsZW0uaHJlZik7XG4gIH1cbn07XG5cbnZhciBCb29sZWFuQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhCb29sZWFuQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBCb29sZWFuQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQm9vbGVhbkNvbnRyb2xsZXIpO1xuICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChCb29sZWFuQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJvb2xlYW5Db250cm9sbGVyKSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KSk7XG4gICAgdmFyIF90aGlzID0gX3RoaXMyO1xuICAgIF90aGlzMi5fX3ByZXYgPSBfdGhpczIuZ2V0VmFsdWUoKTtcbiAgICBfdGhpczIuX19jaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgX3RoaXMyLl9fY2hlY2tib3guc2V0QXR0cmlidXRlKCd0eXBlJywgJ2NoZWNrYm94Jyk7XG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICBfdGhpcy5zZXRWYWx1ZSghX3RoaXMuX19wcmV2KTtcbiAgICB9XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fY2hlY2tib3gsICdjaGFuZ2UnLCBvbkNoYW5nZSwgZmFsc2UpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX2NoZWNrYm94KTtcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoQm9vbGVhbkNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnc2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2KSB7XG4gICAgICB2YXIgdG9SZXR1cm4gPSBnZXQoQm9vbGVhbkNvbnRyb2xsZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQm9vbGVhbkNvbnRyb2xsZXIucHJvdG90eXBlKSwgJ3NldFZhbHVlJywgdGhpcykuY2FsbCh0aGlzLCB2KTtcbiAgICAgIGlmICh0aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwodGhpcywgdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19wcmV2ID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgcmV0dXJuIHRvUmV0dXJuO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZURpc3BsYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgICAgaWYgKHRoaXMuZ2V0VmFsdWUoKSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9fY2hlY2tib3guc2V0QXR0cmlidXRlKCdjaGVja2VkJywgJ2NoZWNrZWQnKTtcbiAgICAgICAgdGhpcy5fX2NoZWNrYm94LmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9fcHJldiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9fY2hlY2tib3guY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9fcHJldiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldChCb29sZWFuQ29udHJvbGxlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCb29sZWFuQ29udHJvbGxlci5wcm90b3R5cGUpLCAndXBkYXRlRGlzcGxheScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCb29sZWFuQ29udHJvbGxlcjtcbn0oQ29udHJvbGxlcik7XG5cbnZhciBPcHRpb25Db250cm9sbGVyID0gZnVuY3Rpb24gKF9Db250cm9sbGVyKSB7XG4gIGluaGVyaXRzKE9wdGlvbkNvbnRyb2xsZXIsIF9Db250cm9sbGVyKTtcbiAgZnVuY3Rpb24gT3B0aW9uQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5LCBvcHRzKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgT3B0aW9uQ29udHJvbGxlcik7XG4gICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE9wdGlvbkNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihPcHRpb25Db250cm9sbGVyKSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KSk7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzO1xuICAgIHZhciBfdGhpcyA9IF90aGlzMjtcbiAgICBfdGhpczIuX19zZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICBpZiAoQ29tbW9uLmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgIHZhciBtYXAgPSB7fTtcbiAgICAgIENvbW1vbi5lYWNoKG9wdGlvbnMsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIG1hcFtlbGVtZW50XSA9IGVsZW1lbnQ7XG4gICAgICB9KTtcbiAgICAgIG9wdGlvbnMgPSBtYXA7XG4gICAgfVxuICAgIENvbW1vbi5lYWNoKG9wdGlvbnMsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICB2YXIgb3B0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgICBvcHQuaW5uZXJIVE1MID0ga2V5O1xuICAgICAgb3B0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCB2YWx1ZSk7XG4gICAgICBfdGhpcy5fX3NlbGVjdC5hcHBlbmRDaGlsZChvcHQpO1xuICAgIH0pO1xuICAgIF90aGlzMi51cGRhdGVEaXNwbGF5KCk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fc2VsZWN0LCAnY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGRlc2lyZWRWYWx1ZSA9IHRoaXMub3B0aW9uc1t0aGlzLnNlbGVjdGVkSW5kZXhdLnZhbHVlO1xuICAgICAgX3RoaXMuc2V0VmFsdWUoZGVzaXJlZFZhbHVlKTtcbiAgICB9KTtcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19zZWxlY3QpO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoT3B0aW9uQ29udHJvbGxlciwgW3tcbiAgICBrZXk6ICdzZXRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKHYpIHtcbiAgICAgIHZhciB0b1JldHVybiA9IGdldChPcHRpb25Db250cm9sbGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9wdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlKSwgJ3NldFZhbHVlJywgdGhpcykuY2FsbCh0aGlzLCB2KTtcbiAgICAgIGlmICh0aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwodGhpcywgdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0b1JldHVybjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgIGlmIChkb20uaXNBY3RpdmUodGhpcy5fX3NlbGVjdCkpIHJldHVybiB0aGlzO1xuICAgICAgdGhpcy5fX3NlbGVjdC52YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgIHJldHVybiBnZXQoT3B0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihPcHRpb25Db250cm9sbGVyLnByb3RvdHlwZSksICd1cGRhdGVEaXNwbGF5JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE9wdGlvbkNvbnRyb2xsZXI7XG59KENvbnRyb2xsZXIpO1xuXG52YXIgU3RyaW5nQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhTdHJpbmdDb250cm9sbGVyLCBfQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIFN0cmluZ0NvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFN0cmluZ0NvbnRyb2xsZXIpO1xuICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTdHJpbmdDb250cm9sbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3RyaW5nQ29udHJvbGxlcikpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSkpO1xuICAgIHZhciBfdGhpcyA9IF90aGlzMjtcbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9faW5wdXQudmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBfdGhpczIuX19pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgX3RoaXMyLl9faW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2tleXVwJywgb25DaGFuZ2UpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAnY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAnYmx1cicsIG9uQmx1cik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF90aGlzMi51cGRhdGVEaXNwbGF5KCk7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9faW5wdXQpO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoU3RyaW5nQ29udHJvbGxlciwgW3tcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgIGlmICghZG9tLmlzQWN0aXZlKHRoaXMuX19pbnB1dCkpIHtcbiAgICAgICAgdGhpcy5fX2lucHV0LnZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldChTdHJpbmdDb250cm9sbGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFN0cmluZ0NvbnRyb2xsZXIucHJvdG90eXBlKSwgJ3VwZGF0ZURpc3BsYXknLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU3RyaW5nQ29udHJvbGxlcjtcbn0oQ29udHJvbGxlcik7XG5cbmZ1bmN0aW9uIG51bURlY2ltYWxzKHgpIHtcbiAgdmFyIF94ID0geC50b1N0cmluZygpO1xuICBpZiAoX3guaW5kZXhPZignLicpID4gLTEpIHtcbiAgICByZXR1cm4gX3gubGVuZ3RoIC0gX3guaW5kZXhPZignLicpIC0gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbnZhciBOdW1iZXJDb250cm9sbGVyID0gZnVuY3Rpb24gKF9Db250cm9sbGVyKSB7XG4gIGluaGVyaXRzKE51bWJlckNvbnRyb2xsZXIsIF9Db250cm9sbGVyKTtcbiAgZnVuY3Rpb24gTnVtYmVyQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBOdW1iZXJDb250cm9sbGVyKTtcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChOdW1iZXJDb250cm9sbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVtYmVyQ29udHJvbGxlcikpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSkpO1xuICAgIHZhciBfcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgIF90aGlzLl9fbWluID0gX3BhcmFtcy5taW47XG4gICAgX3RoaXMuX19tYXggPSBfcGFyYW1zLm1heDtcbiAgICBfdGhpcy5fX3N0ZXAgPSBfcGFyYW1zLnN0ZXA7XG4gICAgaWYgKENvbW1vbi5pc1VuZGVmaW5lZChfdGhpcy5fX3N0ZXApKSB7XG4gICAgICBpZiAoX3RoaXMuaW5pdGlhbFZhbHVlID09PSAwKSB7XG4gICAgICAgIF90aGlzLl9faW1wbGllZFN0ZXAgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuX19pbXBsaWVkU3RlcCA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKE1hdGguYWJzKF90aGlzLmluaXRpYWxWYWx1ZSkpIC8gTWF0aC5MTjEwKSkgLyAxMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuX19pbXBsaWVkU3RlcCA9IF90aGlzLl9fc3RlcDtcbiAgICB9XG4gICAgX3RoaXMuX19wcmVjaXNpb24gPSBudW1EZWNpbWFscyhfdGhpcy5fX2ltcGxpZWRTdGVwKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoTnVtYmVyQ29udHJvbGxlciwgW3tcbiAgICBrZXk6ICdzZXRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKHYpIHtcbiAgICAgIHZhciBfdiA9IHY7XG4gICAgICBpZiAodGhpcy5fX21pbiAhPT0gdW5kZWZpbmVkICYmIF92IDwgdGhpcy5fX21pbikge1xuICAgICAgICBfdiA9IHRoaXMuX19taW47XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX19tYXggIT09IHVuZGVmaW5lZCAmJiBfdiA+IHRoaXMuX19tYXgpIHtcbiAgICAgICAgX3YgPSB0aGlzLl9fbWF4O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19zdGVwICE9PSB1bmRlZmluZWQgJiYgX3YgJSB0aGlzLl9fc3RlcCAhPT0gMCkge1xuICAgICAgICBfdiA9IE1hdGgucm91bmQoX3YgLyB0aGlzLl9fc3RlcCkgKiB0aGlzLl9fc3RlcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXQoTnVtYmVyQ29udHJvbGxlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdW1iZXJDb250cm9sbGVyLnByb3RvdHlwZSksICdzZXRWYWx1ZScsIHRoaXMpLmNhbGwodGhpcywgX3YpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21pbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1pbihtaW5WYWx1ZSkge1xuICAgICAgdGhpcy5fX21pbiA9IG1pblZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbWF4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF4KG1heFZhbHVlKSB7XG4gICAgICB0aGlzLl9fbWF4ID0gbWF4VmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzdGVwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RlcChzdGVwVmFsdWUpIHtcbiAgICAgIHRoaXMuX19zdGVwID0gc3RlcFZhbHVlO1xuICAgICAgdGhpcy5fX2ltcGxpZWRTdGVwID0gc3RlcFZhbHVlO1xuICAgICAgdGhpcy5fX3ByZWNpc2lvbiA9IG51bURlY2ltYWxzKHN0ZXBWYWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXI7XG59KENvbnRyb2xsZXIpO1xuXG5mdW5jdGlvbiByb3VuZFRvRGVjaW1hbCh2YWx1ZSwgZGVjaW1hbHMpIHtcbiAgdmFyIHRlblRvID0gTWF0aC5wb3coMTAsIGRlY2ltYWxzKTtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiB0ZW5UbykgLyB0ZW5Ubztcbn1cbnZhciBOdW1iZXJDb250cm9sbGVyQm94ID0gZnVuY3Rpb24gKF9OdW1iZXJDb250cm9sbGVyKSB7XG4gIGluaGVyaXRzKE51bWJlckNvbnRyb2xsZXJCb3gsIF9OdW1iZXJDb250cm9sbGVyKTtcbiAgZnVuY3Rpb24gTnVtYmVyQ29udHJvbGxlckJveChvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBOdW1iZXJDb250cm9sbGVyQm94KTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTnVtYmVyQ29udHJvbGxlckJveC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWJlckNvbnRyb2xsZXJCb3gpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHksIHBhcmFtcykpO1xuICAgIF90aGlzMi5fX3RydW5jYXRpb25TdXNwZW5kZWQgPSBmYWxzZTtcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgdmFyIHByZXZZID0gdm9pZCAwO1xuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgICAgdmFyIGF0dGVtcHRlZCA9IHBhcnNlRmxvYXQoX3RoaXMuX19pbnB1dC52YWx1ZSk7XG4gICAgICBpZiAoIUNvbW1vbi5pc05hTihhdHRlbXB0ZWQpKSB7XG4gICAgICAgIF90aGlzLnNldFZhbHVlKGF0dGVtcHRlZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uRmluaXNoKCkge1xuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgb25GaW5pc2goKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Nb3VzZURyYWcoZSkge1xuICAgICAgdmFyIGRpZmYgPSBwcmV2WSAtIGUuY2xpZW50WTtcbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLmdldFZhbHVlKCkgKyBkaWZmICogX3RoaXMuX19pbXBsaWVkU3RlcCk7XG4gICAgICBwcmV2WSA9IGUuY2xpZW50WTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Nb3VzZVVwKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgb25GaW5pc2goKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICBwcmV2WSA9IGUuY2xpZW50WTtcbiAgICB9XG4gICAgX3RoaXMyLl9faW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIF90aGlzMi5fX2lucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0Jyk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdibHVyJywgb25CbHVyKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgX3RoaXMuX190cnVuY2F0aW9uU3VzcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ibHVyKCk7XG4gICAgICAgIF90aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA9IGZhbHNlO1xuICAgICAgICBvbkZpbmlzaCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF90aGlzMi51cGRhdGVEaXNwbGF5KCk7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9faW5wdXQpO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoTnVtYmVyQ29udHJvbGxlckJveCwgW3tcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgIHRoaXMuX19pbnB1dC52YWx1ZSA9IHRoaXMuX190cnVuY2F0aW9uU3VzcGVuZGVkID8gdGhpcy5nZXRWYWx1ZSgpIDogcm91bmRUb0RlY2ltYWwodGhpcy5nZXRWYWx1ZSgpLCB0aGlzLl9fcHJlY2lzaW9uKTtcbiAgICAgIHJldHVybiBnZXQoTnVtYmVyQ29udHJvbGxlckJveC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdW1iZXJDb250cm9sbGVyQm94LnByb3RvdHlwZSksICd1cGRhdGVEaXNwbGF5JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXJCb3g7XG59KE51bWJlckNvbnRyb2xsZXIpO1xuXG5mdW5jdGlvbiBtYXAodiwgaTEsIGkyLCBvMSwgbzIpIHtcbiAgcmV0dXJuIG8xICsgKG8yIC0gbzEpICogKCh2IC0gaTEpIC8gKGkyIC0gaTEpKTtcbn1cbnZhciBOdW1iZXJDb250cm9sbGVyU2xpZGVyID0gZnVuY3Rpb24gKF9OdW1iZXJDb250cm9sbGVyKSB7XG4gIGluaGVyaXRzKE51bWJlckNvbnRyb2xsZXJTbGlkZXIsIF9OdW1iZXJDb250cm9sbGVyKTtcbiAgZnVuY3Rpb24gTnVtYmVyQ29udHJvbGxlclNsaWRlcihvYmplY3QsIHByb3BlcnR5LCBtaW4sIG1heCwgc3RlcCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE51bWJlckNvbnRyb2xsZXJTbGlkZXIpO1xuICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChOdW1iZXJDb250cm9sbGVyU2xpZGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVtYmVyQ29udHJvbGxlclNsaWRlcikpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwgeyBtaW46IG1pbiwgbWF4OiBtYXgsIHN0ZXA6IHN0ZXAgfSkpO1xuICAgIHZhciBfdGhpcyA9IF90aGlzMjtcbiAgICBfdGhpczIuX19iYWNrZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX3RoaXMyLl9fZm9yZWdyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2JhY2tncm91bmQsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fYmFja2dyb3VuZCwgJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQpO1xuICAgIGRvbS5hZGRDbGFzcyhfdGhpczIuX19iYWNrZ3JvdW5kLCAnc2xpZGVyJyk7XG4gICAgZG9tLmFkZENsYXNzKF90aGlzMi5fX2ZvcmVncm91bmQsICdzbGlkZXItZmcnKTtcbiAgICBmdW5jdGlvbiBvbk1vdXNlRG93bihlKSB7XG4gICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgb25Nb3VzZURyYWcoZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VEcmFnKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHZhciBiZ1JlY3QgPSBfdGhpcy5fX2JhY2tncm91bmQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShtYXAoZS5jbGllbnRYLCBiZ1JlY3QubGVmdCwgYmdSZWN0LnJpZ2h0LCBfdGhpcy5fX21pbiwgX3RoaXMuX19tYXgpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Nb3VzZVVwKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcbiAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCk7XG4gICAgICBvblRvdWNoTW92ZShlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Ub3VjaE1vdmUoZSkge1xuICAgICAgdmFyIGNsaWVudFggPSBlLnRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgIHZhciBiZ1JlY3QgPSBfdGhpcy5fX2JhY2tncm91bmQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShtYXAoY2xpZW50WCwgYmdSZWN0LmxlZnQsIGJnUmVjdC5yaWdodCwgX3RoaXMuX19taW4sIF90aGlzLl9fbWF4KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uVG91Y2hFbmQoKSB7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAndG91Y2hlbmQnLCBvblRvdWNoRW5kKTtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIF90aGlzMi51cGRhdGVEaXNwbGF5KCk7XG4gICAgX3RoaXMyLl9fYmFja2dyb3VuZC5hcHBlbmRDaGlsZChfdGhpczIuX19mb3JlZ3JvdW5kKTtcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19iYWNrZ3JvdW5kKTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKE51bWJlckNvbnRyb2xsZXJTbGlkZXIsIFt7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICB2YXIgcGN0ID0gKHRoaXMuZ2V0VmFsdWUoKSAtIHRoaXMuX19taW4pIC8gKHRoaXMuX19tYXggLSB0aGlzLl9fbWluKTtcbiAgICAgIHRoaXMuX19mb3JlZ3JvdW5kLnN0eWxlLndpZHRoID0gcGN0ICogMTAwICsgJyUnO1xuICAgICAgcmV0dXJuIGdldChOdW1iZXJDb250cm9sbGVyU2xpZGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWJlckNvbnRyb2xsZXJTbGlkZXIucHJvdG90eXBlKSwgJ3VwZGF0ZURpc3BsYXknLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTnVtYmVyQ29udHJvbGxlclNsaWRlcjtcbn0oTnVtYmVyQ29udHJvbGxlcik7XG5cbnZhciBGdW5jdGlvbkNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0NvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoRnVuY3Rpb25Db250cm9sbGVyLCBfQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIEZ1bmN0aW9uQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5LCB0ZXh0KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRnVuY3Rpb25Db250cm9sbGVyKTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRnVuY3Rpb25Db250cm9sbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRnVuY3Rpb25Db250cm9sbGVyKSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KSk7XG4gICAgdmFyIF90aGlzID0gX3RoaXMyO1xuICAgIF90aGlzMi5fX2J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX2J1dHRvbi5pbm5lckhUTUwgPSB0ZXh0ID09PSB1bmRlZmluZWQgPyAnRmlyZScgOiB0ZXh0O1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2J1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIF90aGlzLmZpcmUoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgICBkb20uYWRkQ2xhc3MoX3RoaXMyLl9fYnV0dG9uLCAnYnV0dG9uJyk7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fYnV0dG9uKTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKEZ1bmN0aW9uQ29udHJvbGxlciwgW3tcbiAgICBrZXk6ICdmaXJlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlyZSgpIHtcbiAgICAgIGlmICh0aGlzLl9fb25DaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fX29uQ2hhbmdlLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmdldFZhbHVlKCkuY2FsbCh0aGlzLm9iamVjdCk7XG4gICAgICBpZiAodGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBGdW5jdGlvbkNvbnRyb2xsZXI7XG59KENvbnRyb2xsZXIpO1xuXG52YXIgQ29sb3JDb250cm9sbGVyID0gZnVuY3Rpb24gKF9Db250cm9sbGVyKSB7XG4gIGluaGVyaXRzKENvbG9yQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBDb2xvckNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENvbG9yQ29udHJvbGxlcik7XG4gICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENvbG9yQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvbG9yQ29udHJvbGxlcikpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSkpO1xuICAgIF90aGlzMi5fX2NvbG9yID0gbmV3IENvbG9yKF90aGlzMi5nZXRWYWx1ZSgpKTtcbiAgICBfdGhpczIuX190ZW1wID0gbmV3IENvbG9yKDApO1xuICAgIHZhciBfdGhpcyA9IF90aGlzMjtcbiAgICBfdGhpczIuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvbS5tYWtlU2VsZWN0YWJsZShfdGhpczIuZG9tRWxlbWVudCwgZmFsc2UpO1xuICAgIF90aGlzMi5fX3NlbGVjdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX3RoaXMyLl9fc2VsZWN0b3IuY2xhc3NOYW1lID0gJ3NlbGVjdG9yJztcbiAgICBfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZC5jbGFzc05hbWUgPSAnc2F0dXJhdGlvbi1maWVsZCc7XG4gICAgX3RoaXMyLl9fZmllbGRfa25vYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX2ZpZWxkX2tub2IuY2xhc3NOYW1lID0gJ2ZpZWxkLWtub2InO1xuICAgIF90aGlzMi5fX2ZpZWxkX2tub2JfYm9yZGVyID0gJzJweCBzb2xpZCAnO1xuICAgIF90aGlzMi5fX2h1ZV9rbm9iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX3RoaXMyLl9faHVlX2tub2IuY2xhc3NOYW1lID0gJ2h1ZS1rbm9iJztcbiAgICBfdGhpczIuX19odWVfZmllbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpczIuX19odWVfZmllbGQuY2xhc3NOYW1lID0gJ2h1ZS1maWVsZCc7XG4gICAgX3RoaXMyLl9faW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIF90aGlzMi5fX2lucHV0LnR5cGUgPSAndGV4dCc7XG4gICAgX3RoaXMyLl9faW5wdXRfdGV4dFNoYWRvdyA9ICcwIDFweCAxcHggJztcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgb25CbHVyLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdibHVyJywgb25CbHVyKTtcbiAgICBkb20uYmluZChfdGhpczIuX19zZWxlY3RvciwgJ21vdXNlZG93bicsIGZ1bmN0aW9uICgpICAgICAgICB7XG4gICAgICBkb20uYWRkQ2xhc3ModGhpcywgJ2RyYWcnKS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmdW5jdGlvbiAoKSAgICAgICAge1xuICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoX3RoaXMuX19zZWxlY3RvciwgJ2RyYWcnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX3NlbGVjdG9yLCAndG91Y2hzdGFydCcsIGZ1bmN0aW9uICgpICAgICAgICB7XG4gICAgICBkb20uYWRkQ2xhc3ModGhpcywgJ2RyYWcnKS5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZnVuY3Rpb24gKCkgICAgICAgIHtcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKF90aGlzLl9fc2VsZWN0b3IsICdkcmFnJyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgdmFsdWVGaWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9fc2VsZWN0b3Iuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiAnMTIycHgnLFxuICAgICAgaGVpZ2h0OiAnMTAycHgnLFxuICAgICAgcGFkZGluZzogJzNweCcsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMjIyJyxcbiAgICAgIGJveFNoYWRvdzogJzBweCAxcHggM3B4IHJnYmEoMCwwLDAsMC4zKSdcbiAgICB9KTtcbiAgICBDb21tb24uZXh0ZW5kKF90aGlzMi5fX2ZpZWxkX2tub2Iuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgd2lkdGg6ICcxMnB4JyxcbiAgICAgIGhlaWdodDogJzEycHgnLFxuICAgICAgYm9yZGVyOiBfdGhpczIuX19maWVsZF9rbm9iX2JvcmRlciArIChfdGhpczIuX19jb2xvci52IDwgMC41ID8gJyNmZmYnIDogJyMwMDAnKSxcbiAgICAgIGJveFNoYWRvdzogJzBweCAxcHggM3B4IHJnYmEoMCwwLDAsMC41KScsXG4gICAgICBib3JkZXJSYWRpdXM6ICcxMnB4JyxcbiAgICAgIHpJbmRleDogMVxuICAgIH0pO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9faHVlX2tub2Iuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgd2lkdGg6ICcxNXB4JyxcbiAgICAgIGhlaWdodDogJzJweCcsXG4gICAgICBib3JkZXJSaWdodDogJzRweCBzb2xpZCAjZmZmJyxcbiAgICAgIHpJbmRleDogMVxuICAgIH0pO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZC5zdHlsZSwge1xuICAgICAgd2lkdGg6ICcxMDBweCcsXG4gICAgICBoZWlnaHQ6ICcxMDBweCcsXG4gICAgICBib3JkZXI6ICcxcHggc29saWQgIzU1NScsXG4gICAgICBtYXJnaW5SaWdodDogJzNweCcsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgfSk7XG4gICAgQ29tbW9uLmV4dGVuZCh2YWx1ZUZpZWxkLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICBiYWNrZ3JvdW5kOiAnbm9uZSdcbiAgICB9KTtcbiAgICBsaW5lYXJHcmFkaWVudCh2YWx1ZUZpZWxkLCAndG9wJywgJ3JnYmEoMCwwLDAsMCknLCAnIzAwMCcpO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9faHVlX2ZpZWxkLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzE1cHgnLFxuICAgICAgaGVpZ2h0OiAnMTAwcHgnLFxuICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICM1NTUnLFxuICAgICAgY3Vyc29yOiAnbnMtcmVzaXplJyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdG9wOiAnM3B4JyxcbiAgICAgIHJpZ2h0OiAnM3B4J1xuICAgIH0pO1xuICAgIGh1ZUdyYWRpZW50KF90aGlzMi5fX2h1ZV9maWVsZCk7XG4gICAgQ29tbW9uLmV4dGVuZChfdGhpczIuX19pbnB1dC5zdHlsZSwge1xuICAgICAgb3V0bGluZTogJ25vbmUnLFxuICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICBib3JkZXI6IDAsXG4gICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICB0ZXh0U2hhZG93OiBfdGhpczIuX19pbnB1dF90ZXh0U2hhZG93ICsgJ3JnYmEoMCwwLDAsMC43KSdcbiAgICB9KTtcbiAgICBkb20uYmluZChfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkLCAnbW91c2Vkb3duJywgZmllbGREb3duKTtcbiAgICBkb20uYmluZChfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkLCAndG91Y2hzdGFydCcsIGZpZWxkRG93bik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fZmllbGRfa25vYiwgJ21vdXNlZG93bicsIGZpZWxkRG93bik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fZmllbGRfa25vYiwgJ3RvdWNoc3RhcnQnLCBmaWVsZERvd24pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2h1ZV9maWVsZCwgJ21vdXNlZG93bicsIGZpZWxkRG93bkgpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2h1ZV9maWVsZCwgJ3RvdWNoc3RhcnQnLCBmaWVsZERvd25IKTtcbiAgICBmdW5jdGlvbiBmaWVsZERvd24oZSkge1xuICAgICAgc2V0U1YoZSk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRTVik7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBzZXRTVik7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgZmllbGRVcFNWKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZmllbGRVcFNWKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmllbGREb3duSChlKSB7XG4gICAgICBzZXRIKGUpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0SCk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBzZXRIKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmaWVsZFVwSCk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIGZpZWxkVXBIKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmllbGRVcFNWKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRTVik7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNobW92ZScsIHNldFNWKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIGZpZWxkVXBTVik7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZmllbGRVcFNWKTtcbiAgICAgIG9uRmluaXNoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpZWxkVXBIKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRIKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAndG91Y2htb3ZlJywgc2V0SCk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmaWVsZFVwSCk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZmllbGRVcEgpO1xuICAgICAgb25GaW5pc2goKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgdmFyIGkgPSBpbnRlcnByZXQodGhpcy52YWx1ZSk7XG4gICAgICBpZiAoaSAhPT0gZmFsc2UpIHtcbiAgICAgICAgX3RoaXMuX19jb2xvci5fX3N0YXRlID0gaTtcbiAgICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IF90aGlzLl9fY29sb3IudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25GaW5pc2goKSB7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZC5hcHBlbmRDaGlsZCh2YWx1ZUZpZWxkKTtcbiAgICBfdGhpczIuX19zZWxlY3Rvci5hcHBlbmRDaGlsZChfdGhpczIuX19maWVsZF9rbm9iKTtcbiAgICBfdGhpczIuX19zZWxlY3Rvci5hcHBlbmRDaGlsZChfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkKTtcbiAgICBfdGhpczIuX19zZWxlY3Rvci5hcHBlbmRDaGlsZChfdGhpczIuX19odWVfZmllbGQpO1xuICAgIF90aGlzMi5fX2h1ZV9maWVsZC5hcHBlbmRDaGlsZChfdGhpczIuX19odWVfa25vYik7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9faW5wdXQpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX3NlbGVjdG9yKTtcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIGZ1bmN0aW9uIHNldFNWKGUpIHtcbiAgICAgIGlmIChlLnR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gLTEpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgdmFyIGZpZWxkUmVjdCA9IF90aGlzLl9fc2F0dXJhdGlvbl9maWVsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBfcmVmID0gZS50b3VjaGVzICYmIGUudG91Y2hlc1swXSB8fCBlLFxuICAgICAgICAgIGNsaWVudFggPSBfcmVmLmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WSA9IF9yZWYuY2xpZW50WTtcbiAgICAgIHZhciBzID0gKGNsaWVudFggLSBmaWVsZFJlY3QubGVmdCkgLyAoZmllbGRSZWN0LnJpZ2h0IC0gZmllbGRSZWN0LmxlZnQpO1xuICAgICAgdmFyIHYgPSAxIC0gKGNsaWVudFkgLSBmaWVsZFJlY3QudG9wKSAvIChmaWVsZFJlY3QuYm90dG9tIC0gZmllbGRSZWN0LnRvcCk7XG4gICAgICBpZiAodiA+IDEpIHtcbiAgICAgICAgdiA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHYgPCAwKSB7XG4gICAgICAgIHYgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHMgPiAxKSB7XG4gICAgICAgIHMgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzIDwgMCkge1xuICAgICAgICBzID0gMDtcbiAgICAgIH1cbiAgICAgIF90aGlzLl9fY29sb3IudiA9IHY7XG4gICAgICBfdGhpcy5fX2NvbG9yLnMgPSBzO1xuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRIKGUpIHtcbiAgICAgIGlmIChlLnR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gLTEpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgdmFyIGZpZWxkUmVjdCA9IF90aGlzLl9faHVlX2ZpZWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIF9yZWYyID0gZS50b3VjaGVzICYmIGUudG91Y2hlc1swXSB8fCBlLFxuICAgICAgICAgIGNsaWVudFkgPSBfcmVmMi5jbGllbnRZO1xuICAgICAgdmFyIGggPSAxIC0gKGNsaWVudFkgLSBmaWVsZFJlY3QudG9wKSAvIChmaWVsZFJlY3QuYm90dG9tIC0gZmllbGRSZWN0LnRvcCk7XG4gICAgICBpZiAoaCA+IDEpIHtcbiAgICAgICAgaCA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGggPCAwKSB7XG4gICAgICAgIGggPSAwO1xuICAgICAgfVxuICAgICAgX3RoaXMuX19jb2xvci5oID0gaCAqIDM2MDtcbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhDb2xvckNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICB2YXIgaSA9IGludGVycHJldCh0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgaWYgKGkgIT09IGZhbHNlKSB7XG4gICAgICAgIHZhciBtaXNtYXRjaCA9IGZhbHNlO1xuICAgICAgICBDb21tb24uZWFjaChDb2xvci5DT01QT05FTlRTLCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgaWYgKCFDb21tb24uaXNVbmRlZmluZWQoaVtjb21wb25lbnRdKSAmJiAhQ29tbW9uLmlzVW5kZWZpbmVkKHRoaXMuX19jb2xvci5fX3N0YXRlW2NvbXBvbmVudF0pICYmIGlbY29tcG9uZW50XSAhPT0gdGhpcy5fX2NvbG9yLl9fc3RhdGVbY29tcG9uZW50XSkge1xuICAgICAgICAgICAgbWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGlmIChtaXNtYXRjaCkge1xuICAgICAgICAgIENvbW1vbi5leHRlbmQodGhpcy5fX2NvbG9yLl9fc3RhdGUsIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBDb21tb24uZXh0ZW5kKHRoaXMuX190ZW1wLl9fc3RhdGUsIHRoaXMuX19jb2xvci5fX3N0YXRlKTtcbiAgICAgIHRoaXMuX190ZW1wLmEgPSAxO1xuICAgICAgdmFyIGZsaXAgPSB0aGlzLl9fY29sb3IudiA8IDAuNSB8fCB0aGlzLl9fY29sb3IucyA+IDAuNSA/IDI1NSA6IDA7XG4gICAgICB2YXIgX2ZsaXAgPSAyNTUgLSBmbGlwO1xuICAgICAgQ29tbW9uLmV4dGVuZCh0aGlzLl9fZmllbGRfa25vYi5zdHlsZSwge1xuICAgICAgICBtYXJnaW5MZWZ0OiAxMDAgKiB0aGlzLl9fY29sb3IucyAtIDcgKyAncHgnLFxuICAgICAgICBtYXJnaW5Ub3A6IDEwMCAqICgxIC0gdGhpcy5fX2NvbG9yLnYpIC0gNyArICdweCcsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5fX3RlbXAudG9IZXhTdHJpbmcoKSxcbiAgICAgICAgYm9yZGVyOiB0aGlzLl9fZmllbGRfa25vYl9ib3JkZXIgKyAncmdiKCcgKyBmbGlwICsgJywnICsgZmxpcCArICcsJyArIGZsaXAgKyAnKSdcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fX2h1ZV9rbm9iLnN0eWxlLm1hcmdpblRvcCA9ICgxIC0gdGhpcy5fX2NvbG9yLmggLyAzNjApICogMTAwICsgJ3B4JztcbiAgICAgIHRoaXMuX190ZW1wLnMgPSAxO1xuICAgICAgdGhpcy5fX3RlbXAudiA9IDE7XG4gICAgICBsaW5lYXJHcmFkaWVudCh0aGlzLl9fc2F0dXJhdGlvbl9maWVsZCwgJ2xlZnQnLCAnI2ZmZicsIHRoaXMuX190ZW1wLnRvSGV4U3RyaW5nKCkpO1xuICAgICAgdGhpcy5fX2lucHV0LnZhbHVlID0gdGhpcy5fX2NvbG9yLnRvU3RyaW5nKCk7XG4gICAgICBDb21tb24uZXh0ZW5kKHRoaXMuX19pbnB1dC5zdHlsZSwge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuX19jb2xvci50b0hleFN0cmluZygpLFxuICAgICAgICBjb2xvcjogJ3JnYignICsgZmxpcCArICcsJyArIGZsaXAgKyAnLCcgKyBmbGlwICsgJyknLFxuICAgICAgICB0ZXh0U2hhZG93OiB0aGlzLl9faW5wdXRfdGV4dFNoYWRvdyArICdyZ2JhKCcgKyBfZmxpcCArICcsJyArIF9mbGlwICsgJywnICsgX2ZsaXAgKyAnLC43KSdcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29sb3JDb250cm9sbGVyO1xufShDb250cm9sbGVyKTtcbnZhciB2ZW5kb3JzID0gWyctbW96LScsICctby0nLCAnLXdlYmtpdC0nLCAnLW1zLScsICcnXTtcbmZ1bmN0aW9uIGxpbmVhckdyYWRpZW50KGVsZW0sIHgsIGEsIGIpIHtcbiAgZWxlbS5zdHlsZS5iYWNrZ3JvdW5kID0gJyc7XG4gIENvbW1vbi5lYWNoKHZlbmRvcnMsIGZ1bmN0aW9uICh2ZW5kb3IpIHtcbiAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6ICcgKyB2ZW5kb3IgKyAnbGluZWFyLWdyYWRpZW50KCcgKyB4ICsgJywgJyArIGEgKyAnIDAlLCAnICsgYiArICcgMTAwJSk7ICc7XG4gIH0pO1xufVxuZnVuY3Rpb24gaHVlR3JhZGllbnQoZWxlbSkge1xuICBlbGVtLnN0eWxlLmJhY2tncm91bmQgPSAnJztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtbW96LWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCAjZmYwMGZmIDE3JSwgIzAwMDBmZiAzNCUsICMwMGZmZmYgNTAlLCAjMDBmZjAwIDY3JSwgI2ZmZmYwMCA4NCUsICNmZjAwMDAgMTAwJSk7JztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7JztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtby1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOyc7XG4gIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLW1zLWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7JztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOyc7XG59XG5cbnZhciBjc3MgPSB7XG4gIGxvYWQ6IGZ1bmN0aW9uIGxvYWQodXJsLCBpbmRvYykge1xuICAgIHZhciBkb2MgPSBpbmRvYyB8fCBkb2N1bWVudDtcbiAgICB2YXIgbGluayA9IGRvYy5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgbGluay50eXBlID0gJ3RleHQvY3NzJztcbiAgICBsaW5rLnJlbCA9ICdzdHlsZXNoZWV0JztcbiAgICBsaW5rLmhyZWYgPSB1cmw7XG4gICAgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQobGluayk7XG4gIH0sXG4gIGluamVjdDogZnVuY3Rpb24gaW5qZWN0KGNzc0NvbnRlbnQsIGluZG9jKSB7XG4gICAgdmFyIGRvYyA9IGluZG9jIHx8IGRvY3VtZW50O1xuICAgIHZhciBpbmplY3RlZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgaW5qZWN0ZWQudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgaW5qZWN0ZWQuaW5uZXJIVE1MID0gY3NzQ29udGVudDtcbiAgICB2YXIgaGVhZCA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgIHRyeSB7XG4gICAgICBoZWFkLmFwcGVuZENoaWxkKGluamVjdGVkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICB9XG59O1xuXG52YXIgc2F2ZURpYWxvZ0NvbnRlbnRzID0gXCI8ZGl2IGlkPVxcXCJkZy1zYXZlXFxcIiBjbGFzcz1cXFwiZGcgZGlhbG9ndWVcXFwiPlxcblxcbiAgSGVyZSdzIHRoZSBuZXcgbG9hZCBwYXJhbWV0ZXIgZm9yIHlvdXIgPGNvZGU+R1VJPC9jb2RlPidzIGNvbnN0cnVjdG9yOlxcblxcbiAgPHRleHRhcmVhIGlkPVxcXCJkZy1uZXctY29uc3RydWN0b3JcXFwiPjwvdGV4dGFyZWE+XFxuXFxuICA8ZGl2IGlkPVxcXCJkZy1zYXZlLWxvY2FsbHlcXFwiPlxcblxcbiAgICA8aW5wdXQgaWQ9XFxcImRnLWxvY2FsLXN0b3JhZ2VcXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIi8+IEF1dG9tYXRpY2FsbHkgc2F2ZVxcbiAgICB2YWx1ZXMgdG8gPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiBvbiBleGl0LlxcblxcbiAgICA8ZGl2IGlkPVxcXCJkZy1sb2NhbC1leHBsYWluXFxcIj5UaGUgdmFsdWVzIHNhdmVkIHRvIDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gd2lsbFxcbiAgICAgIG92ZXJyaWRlIHRob3NlIHBhc3NlZCB0byA8Y29kZT5kYXQuR1VJPC9jb2RlPidzIGNvbnN0cnVjdG9yLiBUaGlzIG1ha2VzIGl0XFxuICAgICAgZWFzaWVyIHRvIHdvcmsgaW5jcmVtZW50YWxseSwgYnV0IDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gaXMgZnJhZ2lsZSxcXG4gICAgICBhbmQgeW91ciBmcmllbmRzIG1heSBub3Qgc2VlIHRoZSBzYW1lIHZhbHVlcyB5b3UgZG8uXFxuXFxuICAgIDwvZGl2PlxcblxcbiAgPC9kaXY+XFxuXFxuPC9kaXY+XCI7XG5cbnZhciBDb250cm9sbGVyRmFjdG9yeSA9IGZ1bmN0aW9uIENvbnRyb2xsZXJGYWN0b3J5KG9iamVjdCwgcHJvcGVydHkpIHtcbiAgdmFyIGluaXRpYWxWYWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gIGlmIChDb21tb24uaXNBcnJheShhcmd1bWVudHNbMl0pIHx8IENvbW1vbi5pc09iamVjdChhcmd1bWVudHNbMl0pKSB7XG4gICAgcmV0dXJuIG5ldyBPcHRpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSk7XG4gIH1cbiAgaWYgKENvbW1vbi5pc051bWJlcihpbml0aWFsVmFsdWUpKSB7XG4gICAgaWYgKENvbW1vbi5pc051bWJlcihhcmd1bWVudHNbMl0pICYmIENvbW1vbi5pc051bWJlcihhcmd1bWVudHNbM10pKSB7XG4gICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKGFyZ3VtZW50c1s0XSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyU2xpZGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdLCBhcmd1bWVudHNbNF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyU2xpZGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcbiAgICB9XG4gICAgaWYgKENvbW1vbi5pc051bWJlcihhcmd1bWVudHNbNF0pKSB7XG4gICAgICByZXR1cm4gbmV3IE51bWJlckNvbnRyb2xsZXJCb3gob2JqZWN0LCBwcm9wZXJ0eSwgeyBtaW46IGFyZ3VtZW50c1syXSwgbWF4OiBhcmd1bWVudHNbM10sIHN0ZXA6IGFyZ3VtZW50c1s0XSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyQm94KG9iamVjdCwgcHJvcGVydHksIHsgbWluOiBhcmd1bWVudHNbMl0sIG1heDogYXJndW1lbnRzWzNdIH0pO1xuICB9XG4gIGlmIChDb21tb24uaXNTdHJpbmcoaW5pdGlhbFZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgU3RyaW5nQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KTtcbiAgfVxuICBpZiAoQ29tbW9uLmlzRnVuY3Rpb24oaW5pdGlhbFZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksICcnKTtcbiAgfVxuICBpZiAoQ29tbW9uLmlzQm9vbGVhbihpbml0aWFsVmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBCb29sZWFuQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjaykge1xuICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xufVxudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHJlcXVlc3RBbmltYXRpb25GcmFtZTtcblxudmFyIENlbnRlcmVkRGl2ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDZW50ZXJlZERpdigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDZW50ZXJlZERpdik7XG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIENvbW1vbi5leHRlbmQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZSwge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjgpJyxcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgICB6SW5kZXg6ICcxMDAwJyxcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICBXZWJraXRUcmFuc2l0aW9uOiAnb3BhY2l0eSAwLjJzIGxpbmVhcicsXG4gICAgICB0cmFuc2l0aW9uOiAnb3BhY2l0eSAwLjJzIGxpbmVhcidcbiAgICB9KTtcbiAgICBkb20ubWFrZUZ1bGxzY3JlZW4odGhpcy5iYWNrZ3JvdW5kRWxlbWVudCk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgQ29tbW9uLmV4dGVuZCh0aGlzLmRvbUVsZW1lbnQuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgZGlzcGxheTogJ25vbmUnLFxuICAgICAgekluZGV4OiAnMTAwMScsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgV2Via2l0VHJhbnNpdGlvbjogJy13ZWJraXQtdHJhbnNmb3JtIDAuMnMgZWFzZS1vdXQsIG9wYWNpdHkgMC4ycyBsaW5lYXInLFxuICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSAwLjJzIGVhc2Utb3V0LCBvcGFjaXR5IDAuMnMgbGluZWFyJ1xuICAgIH0pO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgZG9tLmJpbmQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudCwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuaGlkZSgpO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZUNsYXNzKENlbnRlcmVkRGl2LCBbe1xuICAgIGtleTogJ3Nob3cnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEuMSknO1xuICAgICAgdGhpcy5sYXlvdXQoKTtcbiAgICAgIENvbW1vbi5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICBfdGhpcy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICBfdGhpcy5kb21FbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxKSc7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoaWRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgaGlkZSA9IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICAgIF90aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgX3RoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgZG9tLnVuYmluZChfdGhpcy5kb21FbGVtZW50LCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuICAgICAgICBkb20udW5iaW5kKF90aGlzLmRvbUVsZW1lbnQsICd0cmFuc2l0aW9uZW5kJywgaGlkZSk7XG4gICAgICAgIGRvbS51bmJpbmQoX3RoaXMuZG9tRWxlbWVudCwgJ29UcmFuc2l0aW9uRW5kJywgaGlkZSk7XG4gICAgICB9O1xuICAgICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuICAgICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAndHJhbnNpdGlvbmVuZCcsIGhpZGUpO1xuICAgICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAnb1RyYW5zaXRpb25FbmQnLCBoaWRlKTtcbiAgICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEuMSknO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xheW91dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxheW91dCgpIHtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5sZWZ0ID0gd2luZG93LmlubmVyV2lkdGggLyAyIC0gZG9tLmdldFdpZHRoKHRoaXMuZG9tRWxlbWVudCkgLyAyICsgJ3B4JztcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS50b3AgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyIC0gZG9tLmdldEhlaWdodCh0aGlzLmRvbUVsZW1lbnQpIC8gMiArICdweCc7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDZW50ZXJlZERpdjtcbn0oKTtcblxudmFyIHN0eWxlU2hlZXQgPSBfX18kaW5zZXJ0U3R5bGUoXCIuZGcgdWx7bGlzdC1zdHlsZTpub25lO21hcmdpbjowO3BhZGRpbmc6MDt3aWR0aDoxMDAlO2NsZWFyOmJvdGh9LmRnLmFje3Bvc2l0aW9uOmZpeGVkO3RvcDowO2xlZnQ6MDtyaWdodDowO2hlaWdodDowO3otaW5kZXg6MH0uZGc6bm90KC5hYykgLm1haW57b3ZlcmZsb3c6aGlkZGVufS5kZy5tYWluey13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7LW8tdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7LW1vei10cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcjt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcn0uZGcubWFpbi50YWxsZXItdGhhbi13aW5kb3d7b3ZlcmZsb3cteTphdXRvfS5kZy5tYWluLnRhbGxlci10aGFuLXdpbmRvdyAuY2xvc2UtYnV0dG9ue29wYWNpdHk6MTttYXJnaW4tdG9wOi0xcHg7Ym9yZGVyLXRvcDoxcHggc29saWQgIzJjMmMyY30uZGcubWFpbiB1bC5jbG9zZWQgLmNsb3NlLWJ1dHRvbntvcGFjaXR5OjEgIWltcG9ydGFudH0uZGcubWFpbjpob3ZlciAuY2xvc2UtYnV0dG9uLC5kZy5tYWluIC5jbG9zZS1idXR0b24uZHJhZ3tvcGFjaXR5OjF9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbnstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyOy1vLXRyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyOy1tb3otdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7Ym9yZGVyOjA7bGluZS1oZWlnaHQ6MTlweDtoZWlnaHQ6MjBweDtjdXJzb3I6cG9pbnRlcjt0ZXh0LWFsaWduOmNlbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOiMwMDB9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbi5jbG9zZS10b3B7cG9zaXRpb246cmVsYXRpdmV9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbi5jbG9zZS1ib3R0b217cG9zaXRpb246YWJzb2x1dGV9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMxMTF9LmRnLmF7ZmxvYXQ6cmlnaHQ7bWFyZ2luLXJpZ2h0OjE1cHg7b3ZlcmZsb3cteTp2aXNpYmxlfS5kZy5hLmhhcy1zYXZlPnVsLmNsb3NlLXRvcHttYXJnaW4tdG9wOjB9LmRnLmEuaGFzLXNhdmU+dWwuY2xvc2UtYm90dG9te21hcmdpbi10b3A6MjdweH0uZGcuYS5oYXMtc2F2ZT51bC5jbG9zZWR7bWFyZ2luLXRvcDowfS5kZy5hIC5zYXZlLXJvd3t0b3A6MDt6LWluZGV4OjEwMDJ9LmRnLmEgLnNhdmUtcm93LmNsb3NlLXRvcHtwb3NpdGlvbjpyZWxhdGl2ZX0uZGcuYSAuc2F2ZS1yb3cuY2xvc2UtYm90dG9te3Bvc2l0aW9uOmZpeGVkfS5kZyBsaXstd2Via2l0LXRyYW5zaXRpb246aGVpZ2h0IC4xcyBlYXNlLW91dDstby10cmFuc2l0aW9uOmhlaWdodCAuMXMgZWFzZS1vdXQ7LW1vei10cmFuc2l0aW9uOmhlaWdodCAuMXMgZWFzZS1vdXQ7dHJhbnNpdGlvbjpoZWlnaHQgLjFzIGVhc2Utb3V0Oy13ZWJraXQtdHJhbnNpdGlvbjpvdmVyZmxvdyAuMXMgbGluZWFyOy1vLXRyYW5zaXRpb246b3ZlcmZsb3cgLjFzIGxpbmVhcjstbW96LXRyYW5zaXRpb246b3ZlcmZsb3cgLjFzIGxpbmVhcjt0cmFuc2l0aW9uOm92ZXJmbG93IC4xcyBsaW5lYXJ9LmRnIGxpOm5vdCguZm9sZGVyKXtjdXJzb3I6YXV0bztoZWlnaHQ6MjdweDtsaW5lLWhlaWdodDoyN3B4O3BhZGRpbmc6MCA0cHggMCA1cHh9LmRnIGxpLmZvbGRlcntwYWRkaW5nOjA7Ym9yZGVyLWxlZnQ6NHB4IHNvbGlkIHJnYmEoMCwwLDAsMCl9LmRnIGxpLnRpdGxle2N1cnNvcjpwb2ludGVyO21hcmdpbi1sZWZ0Oi00cHh9LmRnIC5jbG9zZWQgbGk6bm90KC50aXRsZSksLmRnIC5jbG9zZWQgdWwgbGksLmRnIC5jbG9zZWQgdWwgbGk+KntoZWlnaHQ6MDtvdmVyZmxvdzpoaWRkZW47Ym9yZGVyOjB9LmRnIC5jcntjbGVhcjpib3RoO3BhZGRpbmctbGVmdDozcHg7aGVpZ2h0OjI3cHg7b3ZlcmZsb3c6aGlkZGVufS5kZyAucHJvcGVydHktbmFtZXtjdXJzb3I6ZGVmYXVsdDtmbG9hdDpsZWZ0O2NsZWFyOmxlZnQ7d2lkdGg6NDAlO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfS5kZyAuY3tmbG9hdDpsZWZ0O3dpZHRoOjYwJTtwb3NpdGlvbjpyZWxhdGl2ZX0uZGcgLmMgaW5wdXRbdHlwZT10ZXh0XXtib3JkZXI6MDttYXJnaW4tdG9wOjRweDtwYWRkaW5nOjNweDt3aWR0aDoxMDAlO2Zsb2F0OnJpZ2h0fS5kZyAuaGFzLXNsaWRlciBpbnB1dFt0eXBlPXRleHRde3dpZHRoOjMwJTttYXJnaW4tbGVmdDowfS5kZyAuc2xpZGVye2Zsb2F0OmxlZnQ7d2lkdGg6NjYlO21hcmdpbi1sZWZ0Oi01cHg7bWFyZ2luLXJpZ2h0OjA7aGVpZ2h0OjE5cHg7bWFyZ2luLXRvcDo0cHh9LmRnIC5zbGlkZXItZmd7aGVpZ2h0OjEwMCV9LmRnIC5jIGlucHV0W3R5cGU9Y2hlY2tib3hde21hcmdpbi10b3A6N3B4fS5kZyAuYyBzZWxlY3R7bWFyZ2luLXRvcDo1cHh9LmRnIC5jci5mdW5jdGlvbiwuZGcgLmNyLmZ1bmN0aW9uIC5wcm9wZXJ0eS1uYW1lLC5kZyAuY3IuZnVuY3Rpb24gKiwuZGcgLmNyLmJvb2xlYW4sLmRnIC5jci5ib29sZWFuICp7Y3Vyc29yOnBvaW50ZXJ9LmRnIC5jci5jb2xvcntvdmVyZmxvdzp2aXNpYmxlfS5kZyAuc2VsZWN0b3J7ZGlzcGxheTpub25lO3Bvc2l0aW9uOmFic29sdXRlO21hcmdpbi1sZWZ0Oi05cHg7bWFyZ2luLXRvcDoyM3B4O3otaW5kZXg6MTB9LmRnIC5jOmhvdmVyIC5zZWxlY3RvciwuZGcgLnNlbGVjdG9yLmRyYWd7ZGlzcGxheTpibG9ja30uZGcgbGkuc2F2ZS1yb3d7cGFkZGluZzowfS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3BhZGRpbmc6MHB4IDZweH0uZGcuZGlhbG9ndWV7YmFja2dyb3VuZC1jb2xvcjojMjIyO3dpZHRoOjQ2MHB4O3BhZGRpbmc6MTVweDtmb250LXNpemU6MTNweDtsaW5lLWhlaWdodDoxNXB4fSNkZy1uZXctY29uc3RydWN0b3J7cGFkZGluZzoxMHB4O2NvbG9yOiMyMjI7Zm9udC1mYW1pbHk6TW9uYWNvLCBtb25vc3BhY2U7Zm9udC1zaXplOjEwcHg7Ym9yZGVyOjA7cmVzaXplOm5vbmU7Ym94LXNoYWRvdzppbnNldCAxcHggMXB4IDFweCAjODg4O3dvcmQtd3JhcDpicmVhay13b3JkO21hcmdpbjoxMnB4IDA7ZGlzcGxheTpibG9jazt3aWR0aDo0NDBweDtvdmVyZmxvdy15OnNjcm9sbDtoZWlnaHQ6MTAwcHg7cG9zaXRpb246cmVsYXRpdmV9I2RnLWxvY2FsLWV4cGxhaW57ZGlzcGxheTpub25lO2ZvbnQtc2l6ZToxMXB4O2xpbmUtaGVpZ2h0OjE3cHg7Ym9yZGVyLXJhZGl1czozcHg7YmFja2dyb3VuZC1jb2xvcjojMzMzO3BhZGRpbmc6OHB4O21hcmdpbi10b3A6MTBweH0jZGctbG9jYWwtZXhwbGFpbiBjb2Rle2ZvbnQtc2l6ZToxMHB4fSNkYXQtZ3VpLXNhdmUtbG9jYWxseXtkaXNwbGF5Om5vbmV9LmRne2NvbG9yOiNlZWU7Zm9udDoxMXB4ICdMdWNpZGEgR3JhbmRlJywgc2Fucy1zZXJpZjt0ZXh0LXNoYWRvdzowIC0xcHggMCAjMTExfS5kZy5tYWluOjotd2Via2l0LXNjcm9sbGJhcnt3aWR0aDo1cHg7YmFja2dyb3VuZDojMWExYTFhfS5kZy5tYWluOjotd2Via2l0LXNjcm9sbGJhci1jb3JuZXJ7aGVpZ2h0OjA7ZGlzcGxheTpub25lfS5kZy5tYWluOjotd2Via2l0LXNjcm9sbGJhci10aHVtYntib3JkZXItcmFkaXVzOjVweDtiYWNrZ3JvdW5kOiM2NzY3Njd9LmRnIGxpOm5vdCguZm9sZGVyKXtiYWNrZ3JvdW5kOiMxYTFhMWE7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgIzJjMmMyY30uZGcgbGkuc2F2ZS1yb3d7bGluZS1oZWlnaHQ6MjVweDtiYWNrZ3JvdW5kOiNkYWQ1Y2I7Ym9yZGVyOjB9LmRnIGxpLnNhdmUtcm93IHNlbGVjdHttYXJnaW4tbGVmdDo1cHg7d2lkdGg6MTA4cHh9LmRnIGxpLnNhdmUtcm93IC5idXR0b257bWFyZ2luLWxlZnQ6NXB4O21hcmdpbi10b3A6MXB4O2JvcmRlci1yYWRpdXM6MnB4O2ZvbnQtc2l6ZTo5cHg7bGluZS1oZWlnaHQ6N3B4O3BhZGRpbmc6NHB4IDRweCA1cHggNHB4O2JhY2tncm91bmQ6I2M1YmRhZDtjb2xvcjojZmZmO3RleHQtc2hhZG93OjAgMXB4IDAgI2IwYTU4Zjtib3gtc2hhZG93OjAgLTFweCAwICNiMGE1OGY7Y3Vyc29yOnBvaW50ZXJ9LmRnIGxpLnNhdmUtcm93IC5idXR0b24uZ2VhcnN7YmFja2dyb3VuZDojYzViZGFkIHVybChkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFzQUFBQU5DQVlBQUFCLzlaUTdBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQVFKSlJFRlVlTnBpWUtBVS9QLy9Qd0dJQy9BcENBQmlCU0FXK0k4QUNsQWNnS3hRNFQ5aG9NQUVVcnh4MlFTR042K2VnRFgrL3ZXVDRlN044MkFNWW9QQXgvZXZ3V29Zb1NZYkFDWDJzN0t4Q3h6Y3NlekRoM2V2Rm9ERUJZVEVFcXljZ2dXQXpBOUF1VVNRUWdlWVBhOWZQdjYvWVdtL0FjeDVJUGI3dHkvZncrUVpibHc2N3ZEczhSMFlIeVFoZ09ieCt5QUprQnFtRzVkUFBEaDFhUE9HUi9ldWdXMEc0dmxJb1RJZnlGY0ErUWVraGhISmhQZFF4YmlBSWd1TUJUUVpyUEQ3MTA4TTZyb1dZREZRaUlBQXY2QW93LzFiRndYZ2lzK2YyTFVBeW53b0lhTmN6OFhOeDNEbDdNRUpVREdRcHg5Z3RROFlDdWVCK0QyNk9FQ0FBUURhZHQ3ZTQ2RDQyUUFBQUFCSlJVNUVya0pnZ2c9PSkgMnB4IDFweCBuby1yZXBlYXQ7aGVpZ2h0OjdweDt3aWR0aDo4cHh9LmRnIGxpLnNhdmUtcm93IC5idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojYmFiMTllO2JveC1zaGFkb3c6MCAtMXB4IDAgI2IwYTU4Zn0uZGcgbGkuZm9sZGVye2JvcmRlci1ib3R0b206MH0uZGcgbGkudGl0bGV7cGFkZGluZy1sZWZ0OjE2cHg7YmFja2dyb3VuZDojMDAwIHVybChkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhCUUFGQUpFQUFQLy8vL1B6OC8vLy8vLy8veUg1QkFFQUFBSUFMQUFBQUFBRkFBVUFBQUlJbEkraEtnRnhvQ2dBT3c9PSkgNnB4IDEwcHggbm8tcmVwZWF0O2N1cnNvcjpwb2ludGVyO2JvcmRlci1ib3R0b206MXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC4yKX0uZGcgLmNsb3NlZCBsaS50aXRsZXtiYWNrZ3JvdW5kLWltYWdlOnVybChkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhCUUFGQUpFQUFQLy8vL1B6OC8vLy8vLy8veUg1QkFFQUFBSUFMQUFBQUFBRkFBVUFBQUlJbEdJV3FNQ2JXQUVBT3c9PSl9LmRnIC5jci5ib29sZWFue2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjODA2Nzg3fS5kZyAuY3IuY29sb3J7Ym9yZGVyLWxlZnQ6M3B4IHNvbGlkfS5kZyAuY3IuZnVuY3Rpb257Ym9yZGVyLWxlZnQ6M3B4IHNvbGlkICNlNjFkNWZ9LmRnIC5jci5udW1iZXJ7Ym9yZGVyLWxlZnQ6M3B4IHNvbGlkICMyRkExRDZ9LmRnIC5jci5udW1iZXIgaW5wdXRbdHlwZT10ZXh0XXtjb2xvcjojMkZBMUQ2fS5kZyAuY3Iuc3RyaW5ne2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjMWVkMzZmfS5kZyAuY3Iuc3RyaW5nIGlucHV0W3R5cGU9dGV4dF17Y29sb3I6IzFlZDM2Zn0uZGcgLmNyLmZ1bmN0aW9uOmhvdmVyLC5kZyAuY3IuYm9vbGVhbjpob3ZlcntiYWNrZ3JvdW5kOiMxMTF9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF17YmFja2dyb3VuZDojMzAzMDMwO291dGxpbmU6bm9uZX0uZGcgLmMgaW5wdXRbdHlwZT10ZXh0XTpob3ZlcntiYWNrZ3JvdW5kOiMzYzNjM2N9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF06Zm9jdXN7YmFja2dyb3VuZDojNDk0OTQ5O2NvbG9yOiNmZmZ9LmRnIC5jIC5zbGlkZXJ7YmFja2dyb3VuZDojMzAzMDMwO2N1cnNvcjpldy1yZXNpemV9LmRnIC5jIC5zbGlkZXItZmd7YmFja2dyb3VuZDojMkZBMUQ2O21heC13aWR0aDoxMDAlfS5kZyAuYyAuc2xpZGVyOmhvdmVye2JhY2tncm91bmQ6IzNjM2MzY30uZGcgLmMgLnNsaWRlcjpob3ZlciAuc2xpZGVyLWZne2JhY2tncm91bmQ6IzQ0YWJkYX1cXG5cIik7XG5cbmNzcy5pbmplY3Qoc3R5bGVTaGVldCk7XG52YXIgQ1NTX05BTUVTUEFDRSA9ICdkZyc7XG52YXIgSElERV9LRVlfQ09ERSA9IDcyO1xudmFyIENMT1NFX0JVVFRPTl9IRUlHSFQgPSAyMDtcbnZhciBERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUUgPSAnRGVmYXVsdCc7XG52YXIgU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISF3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KCk7XG52YXIgU0FWRV9ESUFMT0dVRSA9IHZvaWQgMDtcbnZhciBhdXRvUGxhY2VWaXJnaW4gPSB0cnVlO1xudmFyIGF1dG9QbGFjZUNvbnRhaW5lciA9IHZvaWQgMDtcbnZhciBoaWRlID0gZmFsc2U7XG52YXIgaGlkZWFibGVHdWlzID0gW107XG52YXIgR1VJID0gZnVuY3Rpb24gR1VJKHBhcnMpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgdmFyIHBhcmFtcyA9IHBhcnMgfHwge307XG4gIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLl9fdWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX3VsKTtcbiAgZG9tLmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCwgQ1NTX05BTUVTUEFDRSk7XG4gIHRoaXMuX19mb2xkZXJzID0ge307XG4gIHRoaXMuX19jb250cm9sbGVycyA9IFtdO1xuICB0aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMgPSBbXTtcbiAgdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVycyA9IFtdO1xuICB0aGlzLl9fbGlzdGVuaW5nID0gW107XG4gIHBhcmFtcyA9IENvbW1vbi5kZWZhdWx0cyhwYXJhbXMsIHtcbiAgICBjbG9zZU9uVG9wOiBmYWxzZSxcbiAgICBhdXRvUGxhY2U6IHRydWUsXG4gICAgd2lkdGg6IEdVSS5ERUZBVUxUX1dJRFRIXG4gIH0pO1xuICBwYXJhbXMgPSBDb21tb24uZGVmYXVsdHMocGFyYW1zLCB7XG4gICAgcmVzaXphYmxlOiBwYXJhbXMuYXV0b1BsYWNlLFxuICAgIGhpZGVhYmxlOiBwYXJhbXMuYXV0b1BsYWNlXG4gIH0pO1xuICBpZiAoIUNvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMubG9hZCkpIHtcbiAgICBpZiAocGFyYW1zLnByZXNldCkge1xuICAgICAgcGFyYW1zLmxvYWQucHJlc2V0ID0gcGFyYW1zLnByZXNldDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGFyYW1zLmxvYWQgPSB7IHByZXNldDogREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FIH07XG4gIH1cbiAgaWYgKENvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSAmJiBwYXJhbXMuaGlkZWFibGUpIHtcbiAgICBoaWRlYWJsZUd1aXMucHVzaCh0aGlzKTtcbiAgfVxuICBwYXJhbXMucmVzaXphYmxlID0gQ29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpICYmIHBhcmFtcy5yZXNpemFibGU7XG4gIGlmIChwYXJhbXMuYXV0b1BsYWNlICYmIENvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMuc2Nyb2xsYWJsZSkpIHtcbiAgICBwYXJhbXMuc2Nyb2xsYWJsZSA9IHRydWU7XG4gIH1cbiAgdmFyIHVzZUxvY2FsU3RvcmFnZSA9IFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UgJiYgbG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaCh0aGlzLCAnaXNMb2NhbCcpKSA9PT0gJ3RydWUnO1xuICB2YXIgc2F2ZVRvTG9jYWxTdG9yYWdlID0gdm9pZCAwO1xuICB2YXIgdGl0bGVSb3cgPSB2b2lkIDA7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsXG4gIHtcbiAgICBwYXJlbnQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gcGFyYW1zLnBhcmVudDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNjcm9sbGFibGU6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gcGFyYW1zLnNjcm9sbGFibGU7XG4gICAgICB9XG4gICAgfSxcbiAgICBhdXRvUGxhY2U6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gcGFyYW1zLmF1dG9QbGFjZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNsb3NlT25Ub3A6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gcGFyYW1zLmNsb3NlT25Ub3A7XG4gICAgICB9XG4gICAgfSxcbiAgICBwcmVzZXQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICBpZiAoX3RoaXMucGFyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmdldFJvb3QoKS5wcmVzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcy5sb2FkLnByZXNldDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2KSB7XG4gICAgICAgIGlmIChfdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICBfdGhpcy5nZXRSb290KCkucHJlc2V0ID0gdjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJhbXMubG9hZC5wcmVzZXQgPSB2O1xuICAgICAgICB9XG4gICAgICAgIHNldFByZXNldFNlbGVjdEluZGV4KHRoaXMpO1xuICAgICAgICBfdGhpcy5yZXZlcnQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdpZHRoOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy53aWR0aDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2KSB7XG4gICAgICAgIHBhcmFtcy53aWR0aCA9IHY7XG4gICAgICAgIHNldFdpZHRoKF90aGlzLCB2KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5hbWU6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gcGFyYW1zLm5hbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgICBwYXJhbXMubmFtZSA9IHY7XG4gICAgICAgIGlmICh0aXRsZVJvdykge1xuICAgICAgICAgIHRpdGxlUm93LmlubmVySFRNTCA9IHBhcmFtcy5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjbG9zZWQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gcGFyYW1zLmNsb3NlZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2KSB7XG4gICAgICAgIHBhcmFtcy5jbG9zZWQgPSB2O1xuICAgICAgICBpZiAocGFyYW1zLmNsb3NlZCkge1xuICAgICAgICAgIGRvbS5hZGRDbGFzcyhfdGhpcy5fX3VsLCBHVUkuQ0xBU1NfQ0xPU0VEKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoX3RoaXMuX191bCwgR1VJLkNMQVNTX0NMT1NFRCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vblJlc2l6ZSgpO1xuICAgICAgICBpZiAoX3RoaXMuX19jbG9zZUJ1dHRvbikge1xuICAgICAgICAgIF90aGlzLl9fY2xvc2VCdXR0b24uaW5uZXJIVE1MID0gdiA/IEdVSS5URVhUX09QRU4gOiBHVUkuVEVYVF9DTE9TRUQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGxvYWQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gcGFyYW1zLmxvYWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VMb2NhbFN0b3JhZ2U6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdXNlTG9jYWxTdG9yYWdlO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKGJvb2wpIHtcbiAgICAgICAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UpIHtcbiAgICAgICAgICB1c2VMb2NhbFN0b3JhZ2UgPSBib29sO1xuICAgICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgICBkb20uYmluZCh3aW5kb3csICd1bmxvYWQnLCBzYXZlVG9Mb2NhbFN0b3JhZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3VubG9hZCcsIHNhdmVUb0xvY2FsU3RvcmFnZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2goX3RoaXMsICdpc0xvY2FsJyksIGJvb2wpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgaWYgKENvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSkge1xuICAgIHRoaXMuY2xvc2VkID0gcGFyYW1zLmNsb3NlZCB8fCBmYWxzZTtcbiAgICBkb20uYWRkQ2xhc3ModGhpcy5kb21FbGVtZW50LCBHVUkuQ0xBU1NfTUFJTik7XG4gICAgZG9tLm1ha2VTZWxlY3RhYmxlKHRoaXMuZG9tRWxlbWVudCwgZmFsc2UpO1xuICAgIGlmIChTVVBQT1JUU19MT0NBTF9TVE9SQUdFKSB7XG4gICAgICBpZiAodXNlTG9jYWxTdG9yYWdlKSB7XG4gICAgICAgIF90aGlzLnVzZUxvY2FsU3RvcmFnZSA9IHRydWU7XG4gICAgICAgIHZhciBzYXZlZEd1aSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2godGhpcywgJ2d1aScpKTtcbiAgICAgICAgaWYgKHNhdmVkR3VpKSB7XG4gICAgICAgICAgcGFyYW1zLmxvYWQgPSBKU09OLnBhcnNlKHNhdmVkR3VpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9fY2xvc2VCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9fY2xvc2VCdXR0b24uaW5uZXJIVE1MID0gR1VJLlRFWFRfQ0xPU0VEO1xuICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19DTE9TRV9CVVRUT04pO1xuICAgIGlmIChwYXJhbXMuY2xvc2VPblRvcCkge1xuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0NMT1NFX1RPUCk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRoaXMuX19jbG9zZUJ1dHRvbiwgdGhpcy5kb21FbGVtZW50LmNoaWxkTm9kZXNbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb20uYWRkQ2xhc3ModGhpcy5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfQ0xPU0VfQk9UVE9NKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fY2xvc2VCdXR0b24pO1xuICAgIH1cbiAgICBkb20uYmluZCh0aGlzLl9fY2xvc2VCdXR0b24sICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmNsb3NlZCA9ICFfdGhpcy5jbG9zZWQ7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBhcmFtcy5jbG9zZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFyYW1zLmNsb3NlZCA9IHRydWU7XG4gICAgfVxuICAgIHZhciB0aXRsZVJvd05hbWUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShwYXJhbXMubmFtZSk7XG4gICAgZG9tLmFkZENsYXNzKHRpdGxlUm93TmFtZSwgJ2NvbnRyb2xsZXItbmFtZScpO1xuICAgIHRpdGxlUm93ID0gYWRkUm93KF90aGlzLCB0aXRsZVJvd05hbWUpO1xuICAgIHZhciBvbkNsaWNrVGl0bGUgPSBmdW5jdGlvbiBvbkNsaWNrVGl0bGUoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgX3RoaXMuY2xvc2VkID0gIV90aGlzLmNsb3NlZDtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fdWwsIEdVSS5DTEFTU19DTE9TRUQpO1xuICAgIGRvbS5hZGRDbGFzcyh0aXRsZVJvdywgJ3RpdGxlJyk7XG4gICAgZG9tLmJpbmQodGl0bGVSb3csICdjbGljaycsIG9uQ2xpY2tUaXRsZSk7XG4gICAgaWYgKCFwYXJhbXMuY2xvc2VkKSB7XG4gICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAocGFyYW1zLmF1dG9QbGFjZSkge1xuICAgIGlmIChDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkpIHtcbiAgICAgIGlmIChhdXRvUGxhY2VWaXJnaW4pIHtcbiAgICAgICAgYXV0b1BsYWNlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRvbS5hZGRDbGFzcyhhdXRvUGxhY2VDb250YWluZXIsIENTU19OQU1FU1BBQ0UpO1xuICAgICAgICBkb20uYWRkQ2xhc3MoYXV0b1BsYWNlQ29udGFpbmVyLCBHVUkuQ0xBU1NfQVVUT19QTEFDRV9DT05UQUlORVIpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGF1dG9QbGFjZUNvbnRhaW5lcik7XG4gICAgICAgIGF1dG9QbGFjZVZpcmdpbiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgYXV0b1BsYWNlQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tRWxlbWVudCk7XG4gICAgICBkb20uYWRkQ2xhc3ModGhpcy5kb21FbGVtZW50LCBHVUkuQ0xBU1NfQVVUT19QTEFDRSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHNldFdpZHRoKF90aGlzLCBwYXJhbXMud2lkdGgpO1xuICAgIH1cbiAgfVxuICB0aGlzLl9fcmVzaXplSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5vblJlc2l6ZURlYm91bmNlZCgpO1xuICB9O1xuICBkb20uYmluZCh3aW5kb3csICdyZXNpemUnLCB0aGlzLl9fcmVzaXplSGFuZGxlcik7XG4gIGRvbS5iaW5kKHRoaXMuX191bCwgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCB0aGlzLl9fcmVzaXplSGFuZGxlcik7XG4gIGRvbS5iaW5kKHRoaXMuX191bCwgJ3RyYW5zaXRpb25lbmQnLCB0aGlzLl9fcmVzaXplSGFuZGxlcik7XG4gIGRvbS5iaW5kKHRoaXMuX191bCwgJ29UcmFuc2l0aW9uRW5kJywgdGhpcy5fX3Jlc2l6ZUhhbmRsZXIpO1xuICB0aGlzLm9uUmVzaXplKCk7XG4gIGlmIChwYXJhbXMucmVzaXphYmxlKSB7XG4gICAgYWRkUmVzaXplSGFuZGxlKHRoaXMpO1xuICB9XG4gIHNhdmVUb0xvY2FsU3RvcmFnZSA9IGZ1bmN0aW9uIHNhdmVUb0xvY2FsU3RvcmFnZSgpIHtcbiAgICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSAmJiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKF90aGlzLCAnaXNMb2NhbCcpKSA9PT0gJ3RydWUnKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKF90aGlzLCAnZ3VpJyksIEpTT04uc3RyaW5naWZ5KF90aGlzLmdldFNhdmVPYmplY3QoKSkpO1xuICAgIH1cbiAgfTtcbiAgdGhpcy5zYXZlVG9Mb2NhbFN0b3JhZ2VJZlBvc3NpYmxlID0gc2F2ZVRvTG9jYWxTdG9yYWdlO1xuICBmdW5jdGlvbiByZXNldFdpZHRoKCkge1xuICAgIHZhciByb290ID0gX3RoaXMuZ2V0Um9vdCgpO1xuICAgIHJvb3Qud2lkdGggKz0gMTtcbiAgICBDb21tb24uZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgcm9vdC53aWR0aCAtPSAxO1xuICAgIH0pO1xuICB9XG4gIGlmICghcGFyYW1zLnBhcmVudCkge1xuICAgIHJlc2V0V2lkdGgoKTtcbiAgfVxufTtcbkdVSS50b2dnbGVIaWRlID0gZnVuY3Rpb24gKCkge1xuICBoaWRlID0gIWhpZGU7XG4gIENvbW1vbi5lYWNoKGhpZGVhYmxlR3VpcywgZnVuY3Rpb24gKGd1aSkge1xuICAgIGd1aS5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBoaWRlID8gJ25vbmUnIDogJyc7XG4gIH0pO1xufTtcbkdVSS5DTEFTU19BVVRPX1BMQUNFID0gJ2EnO1xuR1VJLkNMQVNTX0FVVE9fUExBQ0VfQ09OVEFJTkVSID0gJ2FjJztcbkdVSS5DTEFTU19NQUlOID0gJ21haW4nO1xuR1VJLkNMQVNTX0NPTlRST0xMRVJfUk9XID0gJ2NyJztcbkdVSS5DTEFTU19UT09fVEFMTCA9ICd0YWxsZXItdGhhbi13aW5kb3cnO1xuR1VJLkNMQVNTX0NMT1NFRCA9ICdjbG9zZWQnO1xuR1VJLkNMQVNTX0NMT1NFX0JVVFRPTiA9ICdjbG9zZS1idXR0b24nO1xuR1VJLkNMQVNTX0NMT1NFX1RPUCA9ICdjbG9zZS10b3AnO1xuR1VJLkNMQVNTX0NMT1NFX0JPVFRPTSA9ICdjbG9zZS1ib3R0b20nO1xuR1VJLkNMQVNTX0RSQUcgPSAnZHJhZyc7XG5HVUkuREVGQVVMVF9XSURUSCA9IDI0NTtcbkdVSS5URVhUX0NMT1NFRCA9ICdDbG9zZSBDb250cm9scyc7XG5HVUkuVEVYVF9PUEVOID0gJ09wZW4gQ29udHJvbHMnO1xuR1VJLl9rZXlkb3duSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50LnR5cGUgIT09ICd0ZXh0JyAmJiAoZS53aGljaCA9PT0gSElERV9LRVlfQ09ERSB8fCBlLmtleUNvZGUgPT09IEhJREVfS0VZX0NPREUpKSB7XG4gICAgR1VJLnRvZ2dsZUhpZGUoKTtcbiAgfVxufTtcbmRvbS5iaW5kKHdpbmRvdywgJ2tleWRvd24nLCBHVUkuX2tleWRvd25IYW5kbGVyLCBmYWxzZSk7XG5Db21tb24uZXh0ZW5kKEdVSS5wcm90b3R5cGUsXG57XG4gIGFkZDogZnVuY3Rpb24gYWRkKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gX2FkZCh0aGlzLCBvYmplY3QsIHByb3BlcnR5LCB7XG4gICAgICBmYWN0b3J5QXJnczogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKVxuICAgIH0pO1xuICB9LFxuICBhZGRDb2xvcjogZnVuY3Rpb24gYWRkQ29sb3Iob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiBfYWRkKHRoaXMsIG9iamVjdCwgcHJvcGVydHksIHtcbiAgICAgIGNvbG9yOiB0cnVlXG4gICAgfSk7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGNvbnRyb2xsZXIpIHtcbiAgICB0aGlzLl9fdWwucmVtb3ZlQ2hpbGQoY29udHJvbGxlci5fX2xpKTtcbiAgICB0aGlzLl9fY29udHJvbGxlcnMuc3BsaWNlKHRoaXMuX19jb250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpLCAxKTtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIENvbW1vbi5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5vblJlc2l6ZSgpO1xuICAgIH0pO1xuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IHRoZSByb290IEdVSSBzaG91bGQgYmUgcmVtb3ZlZCB3aXRoIC5kZXN0cm95KCkuICcgKyAnRm9yIHN1YmZvbGRlcnMsIHVzZSBndWkucmVtb3ZlRm9sZGVyKGZvbGRlcikgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXV0b1BsYWNlKSB7XG4gICAgICBhdXRvUGxhY2VDb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5kb21FbGVtZW50KTtcbiAgICB9XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBDb21tb24uZWFjaCh0aGlzLl9fZm9sZGVycywgZnVuY3Rpb24gKHN1YmZvbGRlcikge1xuICAgICAgX3RoaXMucmVtb3ZlRm9sZGVyKHN1YmZvbGRlcik7XG4gICAgfSk7XG4gICAgZG9tLnVuYmluZCh3aW5kb3csICdrZXlkb3duJywgR1VJLl9rZXlkb3duSGFuZGxlciwgZmFsc2UpO1xuICAgIHJlbW92ZUxpc3RlbmVycyh0aGlzKTtcbiAgfSxcbiAgYWRkRm9sZGVyOiBmdW5jdGlvbiBhZGRGb2xkZXIobmFtZSkge1xuICAgIGlmICh0aGlzLl9fZm9sZGVyc1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhbHJlYWR5IGhhdmUgYSBmb2xkZXIgaW4gdGhpcyBHVUkgYnkgdGhlJyArICcgbmFtZSBcIicgKyBuYW1lICsgJ1wiJyk7XG4gICAgfVxuICAgIHZhciBuZXdHdWlQYXJhbXMgPSB7IG5hbWU6IG5hbWUsIHBhcmVudDogdGhpcyB9O1xuICAgIG5ld0d1aVBhcmFtcy5hdXRvUGxhY2UgPSB0aGlzLmF1dG9QbGFjZTtcbiAgICBpZiAodGhpcy5sb2FkICYmXG4gICAgdGhpcy5sb2FkLmZvbGRlcnMgJiZcbiAgICB0aGlzLmxvYWQuZm9sZGVyc1tuYW1lXSkge1xuICAgICAgbmV3R3VpUGFyYW1zLmNsb3NlZCA9IHRoaXMubG9hZC5mb2xkZXJzW25hbWVdLmNsb3NlZDtcbiAgICAgIG5ld0d1aVBhcmFtcy5sb2FkID0gdGhpcy5sb2FkLmZvbGRlcnNbbmFtZV07XG4gICAgfVxuICAgIHZhciBndWkgPSBuZXcgR1VJKG5ld0d1aVBhcmFtcyk7XG4gICAgdGhpcy5fX2ZvbGRlcnNbbmFtZV0gPSBndWk7XG4gICAgdmFyIGxpID0gYWRkUm93KHRoaXMsIGd1aS5kb21FbGVtZW50KTtcbiAgICBkb20uYWRkQ2xhc3MobGksICdmb2xkZXInKTtcbiAgICByZXR1cm4gZ3VpO1xuICB9LFxuICByZW1vdmVGb2xkZXI6IGZ1bmN0aW9uIHJlbW92ZUZvbGRlcihmb2xkZXIpIHtcbiAgICB0aGlzLl9fdWwucmVtb3ZlQ2hpbGQoZm9sZGVyLmRvbUVsZW1lbnQucGFyZW50RWxlbWVudCk7XG4gICAgZGVsZXRlIHRoaXMuX19mb2xkZXJzW2ZvbGRlci5uYW1lXTtcbiAgICBpZiAodGhpcy5sb2FkICYmXG4gICAgdGhpcy5sb2FkLmZvbGRlcnMgJiZcbiAgICB0aGlzLmxvYWQuZm9sZGVyc1tmb2xkZXIubmFtZV0pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmxvYWQuZm9sZGVyc1tmb2xkZXIubmFtZV07XG4gICAgfVxuICAgIHJlbW92ZUxpc3RlbmVycyhmb2xkZXIpO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgQ29tbW9uLmVhY2goZm9sZGVyLl9fZm9sZGVycywgZnVuY3Rpb24gKHN1YmZvbGRlcikge1xuICAgICAgZm9sZGVyLnJlbW92ZUZvbGRlcihzdWJmb2xkZXIpO1xuICAgIH0pO1xuICAgIENvbW1vbi5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5vblJlc2l6ZSgpO1xuICAgIH0pO1xuICB9LFxuICBvcGVuOiBmdW5jdGlvbiBvcGVuKCkge1xuICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gIH0sXG4gIGhpZGU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH0sXG4gIHNob3c6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgfSxcbiAgb25SZXNpemU6IGZ1bmN0aW9uIG9uUmVzaXplKCkge1xuICAgIHZhciByb290ID0gdGhpcy5nZXRSb290KCk7XG4gICAgaWYgKHJvb3Quc2Nyb2xsYWJsZSkge1xuICAgICAgdmFyIHRvcCA9IGRvbS5nZXRPZmZzZXQocm9vdC5fX3VsKS50b3A7XG4gICAgICB2YXIgaCA9IDA7XG4gICAgICBDb21tb24uZWFjaChyb290Ll9fdWwuY2hpbGROb2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKCEocm9vdC5hdXRvUGxhY2UgJiYgbm9kZSA9PT0gcm9vdC5fX3NhdmVfcm93KSkge1xuICAgICAgICAgIGggKz0gZG9tLmdldEhlaWdodChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAod2luZG93LmlubmVySGVpZ2h0IC0gdG9wIC0gQ0xPU0VfQlVUVE9OX0hFSUdIVCA8IGgpIHtcbiAgICAgICAgZG9tLmFkZENsYXNzKHJvb3QuZG9tRWxlbWVudCwgR1VJLkNMQVNTX1RPT19UQUxMKTtcbiAgICAgICAgcm9vdC5fX3VsLnN0eWxlLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAtIHRvcCAtIENMT1NFX0JVVFRPTl9IRUlHSFQgKyAncHgnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKHJvb3QuZG9tRWxlbWVudCwgR1VJLkNMQVNTX1RPT19UQUxMKTtcbiAgICAgICAgcm9vdC5fX3VsLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJvb3QuX19yZXNpemVfaGFuZGxlKSB7XG4gICAgICBDb21tb24uZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICByb290Ll9fcmVzaXplX2hhbmRsZS5zdHlsZS5oZWlnaHQgPSByb290Ll9fdWwub2Zmc2V0SGVpZ2h0ICsgJ3B4JztcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocm9vdC5fX2Nsb3NlQnV0dG9uKSB7XG4gICAgICByb290Ll9fY2xvc2VCdXR0b24uc3R5bGUud2lkdGggPSByb290LndpZHRoICsgJ3B4JztcbiAgICB9XG4gIH0sXG4gIG9uUmVzaXplRGVib3VuY2VkOiBDb21tb24uZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgIHRoaXMub25SZXNpemUoKTtcbiAgfSwgNTApLFxuICByZW1lbWJlcjogZnVuY3Rpb24gcmVtZW1iZXIoKSB7XG4gICAgaWYgKENvbW1vbi5pc1VuZGVmaW5lZChTQVZFX0RJQUxPR1VFKSkge1xuICAgICAgU0FWRV9ESUFMT0dVRSA9IG5ldyBDZW50ZXJlZERpdigpO1xuICAgICAgU0FWRV9ESUFMT0dVRS5kb21FbGVtZW50LmlubmVySFRNTCA9IHNhdmVEaWFsb2dDb250ZW50cztcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW4gb25seSBjYWxsIHJlbWVtYmVyIG9uIGEgdG9wIGxldmVsIEdVSS4nKTtcbiAgICB9XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBDb21tb24uZWFjaChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLCBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAoX3RoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYWRkU2F2ZU1lbnUoX3RoaXMpO1xuICAgICAgfVxuICAgICAgaWYgKF90aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMuaW5kZXhPZihvYmplY3QpID09PSAtMSkge1xuICAgICAgICBfdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodGhpcy5hdXRvUGxhY2UpIHtcbiAgICAgIHNldFdpZHRoKHRoaXMsIHRoaXMud2lkdGgpO1xuICAgIH1cbiAgfSxcbiAgZ2V0Um9vdDogZnVuY3Rpb24gZ2V0Um9vdCgpIHtcbiAgICB2YXIgZ3VpID0gdGhpcztcbiAgICB3aGlsZSAoZ3VpLnBhcmVudCkge1xuICAgICAgZ3VpID0gZ3VpLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGd1aTtcbiAgfSxcbiAgZ2V0U2F2ZU9iamVjdDogZnVuY3Rpb24gZ2V0U2F2ZU9iamVjdCgpIHtcbiAgICB2YXIgdG9SZXR1cm4gPSB0aGlzLmxvYWQ7XG4gICAgdG9SZXR1cm4uY2xvc2VkID0gdGhpcy5jbG9zZWQ7XG4gICAgaWYgKHRoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICB0b1JldHVybi5wcmVzZXQgPSB0aGlzLnByZXNldDtcbiAgICAgIGlmICghdG9SZXR1cm4ucmVtZW1iZXJlZCkge1xuICAgICAgICB0b1JldHVybi5yZW1lbWJlcmVkID0ge307XG4gICAgICB9XG4gICAgICB0b1JldHVybi5yZW1lbWJlcmVkW3RoaXMucHJlc2V0XSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcyk7XG4gICAgfVxuICAgIHRvUmV0dXJuLmZvbGRlcnMgPSB7fTtcbiAgICBDb21tb24uZWFjaCh0aGlzLl9fZm9sZGVycywgZnVuY3Rpb24gKGVsZW1lbnQsIGtleSkge1xuICAgICAgdG9SZXR1cm4uZm9sZGVyc1trZXldID0gZWxlbWVudC5nZXRTYXZlT2JqZWN0KCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvUmV0dXJuO1xuICB9LFxuICBzYXZlOiBmdW5jdGlvbiBzYXZlKCkge1xuICAgIGlmICghdGhpcy5sb2FkLnJlbWVtYmVyZWQpIHtcbiAgICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkID0ge307XG4gICAgfVxuICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkW3RoaXMucHJlc2V0XSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcyk7XG4gICAgbWFya1ByZXNldE1vZGlmaWVkKHRoaXMsIGZhbHNlKTtcbiAgICB0aGlzLnNhdmVUb0xvY2FsU3RvcmFnZUlmUG9zc2libGUoKTtcbiAgfSxcbiAgc2F2ZUFzOiBmdW5jdGlvbiBzYXZlQXMocHJlc2V0TmFtZSkge1xuICAgIGlmICghdGhpcy5sb2FkLnJlbWVtYmVyZWQpIHtcbiAgICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkID0ge307XG4gICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZFtERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUVdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzLCB0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5sb2FkLnJlbWVtYmVyZWRbcHJlc2V0TmFtZV0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMpO1xuICAgIHRoaXMucHJlc2V0ID0gcHJlc2V0TmFtZTtcbiAgICBhZGRQcmVzZXRPcHRpb24odGhpcywgcHJlc2V0TmFtZSwgdHJ1ZSk7XG4gICAgdGhpcy5zYXZlVG9Mb2NhbFN0b3JhZ2VJZlBvc3NpYmxlKCk7XG4gIH0sXG4gIHJldmVydDogZnVuY3Rpb24gcmV2ZXJ0KGd1aSkge1xuICAgIENvbW1vbi5lYWNoKHRoaXMuX19jb250cm9sbGVycywgZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgIGlmICghdGhpcy5nZXRSb290KCkubG9hZC5yZW1lbWJlcmVkKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuc2V0VmFsdWUoY29udHJvbGxlci5pbml0aWFsVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjYWxsU2F2ZWRWYWx1ZShndWkgfHwgdGhpcy5nZXRSb290KCksIGNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRyb2xsZXIuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBjb250cm9sbGVyLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChjb250cm9sbGVyLCBjb250cm9sbGVyLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIENvbW1vbi5lYWNoKHRoaXMuX19mb2xkZXJzLCBmdW5jdGlvbiAoZm9sZGVyKSB7XG4gICAgICBmb2xkZXIucmV2ZXJ0KGZvbGRlcik7XG4gICAgfSk7XG4gICAgaWYgKCFndWkpIHtcbiAgICAgIG1hcmtQcmVzZXRNb2RpZmllZCh0aGlzLmdldFJvb3QoKSwgZmFsc2UpO1xuICAgIH1cbiAgfSxcbiAgbGlzdGVuOiBmdW5jdGlvbiBsaXN0ZW4oY29udHJvbGxlcikge1xuICAgIHZhciBpbml0ID0gdGhpcy5fX2xpc3RlbmluZy5sZW5ndGggPT09IDA7XG4gICAgdGhpcy5fX2xpc3RlbmluZy5wdXNoKGNvbnRyb2xsZXIpO1xuICAgIGlmIChpbml0KSB7XG4gICAgICB1cGRhdGVEaXNwbGF5cyh0aGlzLl9fbGlzdGVuaW5nKTtcbiAgICB9XG4gIH0sXG4gIHVwZGF0ZURpc3BsYXk6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgQ29tbW9uLmVhY2godGhpcy5fX2NvbnRyb2xsZXJzLCBmdW5jdGlvbiAoY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci51cGRhdGVEaXNwbGF5KCk7XG4gICAgfSk7XG4gICAgQ29tbW9uLmVhY2godGhpcy5fX2ZvbGRlcnMsIGZ1bmN0aW9uIChmb2xkZXIpIHtcbiAgICAgIGZvbGRlci51cGRhdGVEaXNwbGF5KCk7XG4gICAgfSk7XG4gIH1cbn0pO1xuZnVuY3Rpb24gYWRkUm93KGd1aSwgbmV3RG9tLCBsaUJlZm9yZSkge1xuICB2YXIgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICBpZiAobmV3RG9tKSB7XG4gICAgbGkuYXBwZW5kQ2hpbGQobmV3RG9tKTtcbiAgfVxuICBpZiAobGlCZWZvcmUpIHtcbiAgICBndWkuX191bC5pbnNlcnRCZWZvcmUobGksIGxpQmVmb3JlKTtcbiAgfSBlbHNlIHtcbiAgICBndWkuX191bC5hcHBlbmRDaGlsZChsaSk7XG4gIH1cbiAgZ3VpLm9uUmVzaXplKCk7XG4gIHJldHVybiBsaTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycyhndWkpIHtcbiAgZG9tLnVuYmluZCh3aW5kb3csICdyZXNpemUnLCBndWkuX19yZXNpemVIYW5kbGVyKTtcbiAgaWYgKGd1aS5zYXZlVG9Mb2NhbFN0b3JhZ2VJZlBvc3NpYmxlKSB7XG4gICAgZG9tLnVuYmluZCh3aW5kb3csICd1bmxvYWQnLCBndWkuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtQcmVzZXRNb2RpZmllZChndWksIG1vZGlmaWVkKSB7XG4gIHZhciBvcHQgPSBndWkuX19wcmVzZXRfc2VsZWN0W2d1aS5fX3ByZXNldF9zZWxlY3Quc2VsZWN0ZWRJbmRleF07XG4gIGlmIChtb2RpZmllZCkge1xuICAgIG9wdC5pbm5lckhUTUwgPSBvcHQudmFsdWUgKyAnKic7XG4gIH0gZWxzZSB7XG4gICAgb3B0LmlubmVySFRNTCA9IG9wdC52YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gYXVnbWVudENvbnRyb2xsZXIoZ3VpLCBsaSwgY29udHJvbGxlcikge1xuICBjb250cm9sbGVyLl9fbGkgPSBsaTtcbiAgY29udHJvbGxlci5fX2d1aSA9IGd1aTtcbiAgQ29tbW9uLmV4dGVuZChjb250cm9sbGVyLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgIG9wdGlvbnM6IGZ1bmN0aW9uIG9wdGlvbnMoX29wdGlvbnMpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBjb250cm9sbGVyLl9fbGkubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gX2FkZChndWksIGNvbnRyb2xsZXIub2JqZWN0LCBjb250cm9sbGVyLnByb3BlcnR5LCB7XG4gICAgICAgICAgYmVmb3JlOiBuZXh0U2libGluZyxcbiAgICAgICAgICBmYWN0b3J5QXJnczogW0NvbW1vbi50b0FycmF5KGFyZ3VtZW50cyldXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKENvbW1vbi5pc0FycmF5KF9vcHRpb25zKSB8fCBDb21tb24uaXNPYmplY3QoX29wdGlvbnMpKSB7XG4gICAgICAgIHZhciBfbmV4dFNpYmxpbmcgPSBjb250cm9sbGVyLl9fbGkubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gX2FkZChndWksIGNvbnRyb2xsZXIub2JqZWN0LCBjb250cm9sbGVyLnByb3BlcnR5LCB7XG4gICAgICAgICAgYmVmb3JlOiBfbmV4dFNpYmxpbmcsXG4gICAgICAgICAgZmFjdG9yeUFyZ3M6IFtfb3B0aW9uc11cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBuYW1lOiBmdW5jdGlvbiBuYW1lKF9uYW1lKSB7XG4gICAgICBjb250cm9sbGVyLl9fbGkuZmlyc3RFbGVtZW50Q2hpbGQuZmlyc3RFbGVtZW50Q2hpbGQuaW5uZXJIVE1MID0gX25hbWU7XG4gICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9LFxuICAgIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKCkge1xuICAgICAgY29udHJvbGxlci5fX2d1aS5saXN0ZW4oY29udHJvbGxlcik7XG4gICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgY29udHJvbGxlci5fX2d1aS5yZW1vdmUoY29udHJvbGxlcik7XG4gICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9XG4gIH0pO1xuICBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIE51bWJlckNvbnRyb2xsZXJTbGlkZXIpIHtcbiAgICB2YXIgYm94ID0gbmV3IE51bWJlckNvbnRyb2xsZXJCb3goY29udHJvbGxlci5vYmplY3QsIGNvbnRyb2xsZXIucHJvcGVydHksIHsgbWluOiBjb250cm9sbGVyLl9fbWluLCBtYXg6IGNvbnRyb2xsZXIuX19tYXgsIHN0ZXA6IGNvbnRyb2xsZXIuX19zdGVwIH0pO1xuICAgIENvbW1vbi5lYWNoKFsndXBkYXRlRGlzcGxheScsICdvbkNoYW5nZScsICdvbkZpbmlzaENoYW5nZScsICdzdGVwJywgJ21pbicsICdtYXgnXSwgZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgdmFyIHBjID0gY29udHJvbGxlclttZXRob2RdO1xuICAgICAgdmFyIHBiID0gYm94W21ldGhvZF07XG4gICAgICBjb250cm9sbGVyW21ldGhvZF0gPSBib3hbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICBwYi5hcHBseShib3gsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gcGMuYXBwbHkoY29udHJvbGxlciwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2hhcy1zbGlkZXInKTtcbiAgICBjb250cm9sbGVyLmRvbUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGJveC5kb21FbGVtZW50LCBjb250cm9sbGVyLmRvbUVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpO1xuICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBOdW1iZXJDb250cm9sbGVyQm94KSB7XG4gICAgdmFyIHIgPSBmdW5jdGlvbiByKHJldHVybmVkKSB7XG4gICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKGNvbnRyb2xsZXIuX19taW4pICYmIENvbW1vbi5pc051bWJlcihjb250cm9sbGVyLl9fbWF4KSkge1xuICAgICAgICB2YXIgb2xkTmFtZSA9IGNvbnRyb2xsZXIuX19saS5maXJzdEVsZW1lbnRDaGlsZC5maXJzdEVsZW1lbnRDaGlsZC5pbm5lckhUTUw7XG4gICAgICAgIHZhciB3YXNMaXN0ZW5pbmcgPSBjb250cm9sbGVyLl9fZ3VpLl9fbGlzdGVuaW5nLmluZGV4T2YoY29udHJvbGxlcikgPiAtMTtcbiAgICAgICAgY29udHJvbGxlci5yZW1vdmUoKTtcbiAgICAgICAgdmFyIG5ld0NvbnRyb2xsZXIgPSBfYWRkKGd1aSwgY29udHJvbGxlci5vYmplY3QsIGNvbnRyb2xsZXIucHJvcGVydHksIHtcbiAgICAgICAgICBiZWZvcmU6IGNvbnRyb2xsZXIuX19saS5uZXh0RWxlbWVudFNpYmxpbmcsXG4gICAgICAgICAgZmFjdG9yeUFyZ3M6IFtjb250cm9sbGVyLl9fbWluLCBjb250cm9sbGVyLl9fbWF4LCBjb250cm9sbGVyLl9fc3RlcF1cbiAgICAgICAgfSk7XG4gICAgICAgIG5ld0NvbnRyb2xsZXIubmFtZShvbGROYW1lKTtcbiAgICAgICAgaWYgKHdhc0xpc3RlbmluZykgbmV3Q29udHJvbGxlci5saXN0ZW4oKTtcbiAgICAgICAgcmV0dXJuIG5ld0NvbnRyb2xsZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0dXJuZWQ7XG4gICAgfTtcbiAgICBjb250cm9sbGVyLm1pbiA9IENvbW1vbi5jb21wb3NlKHIsIGNvbnRyb2xsZXIubWluKTtcbiAgICBjb250cm9sbGVyLm1heCA9IENvbW1vbi5jb21wb3NlKHIsIGNvbnRyb2xsZXIubWF4KTtcbiAgfSBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgQm9vbGVhbkNvbnRyb2xsZXIpIHtcbiAgICBkb20uYmluZChsaSwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgZG9tLmZha2VFdmVudChjb250cm9sbGVyLl9fY2hlY2tib3gsICdjbGljaycpO1xuICAgIH0pO1xuICAgIGRvbS5iaW5kKGNvbnRyb2xsZXIuX19jaGVja2JveCwgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIEZ1bmN0aW9uQ29udHJvbGxlcikge1xuICAgIGRvbS5iaW5kKGxpLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkb20uZmFrZUV2ZW50KGNvbnRyb2xsZXIuX19idXR0b24sICdjbGljaycpO1xuICAgIH0pO1xuICAgIGRvbS5iaW5kKGxpLCAnbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgZG9tLmFkZENsYXNzKGNvbnRyb2xsZXIuX19idXR0b24sICdob3ZlcicpO1xuICAgIH0pO1xuICAgIGRvbS5iaW5kKGxpLCAnbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkb20ucmVtb3ZlQ2xhc3MoY29udHJvbGxlci5fX2J1dHRvbiwgJ2hvdmVyJyk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIENvbG9yQ29udHJvbGxlcikge1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2NvbG9yJyk7XG4gICAgY29udHJvbGxlci51cGRhdGVEaXNwbGF5ID0gQ29tbW9uLmNvbXBvc2UoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgbGkuc3R5bGUuYm9yZGVyTGVmdENvbG9yID0gY29udHJvbGxlci5fX2NvbG9yLnRvU3RyaW5nKCk7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0sIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSk7XG4gICAgY29udHJvbGxlci51cGRhdGVEaXNwbGF5KCk7XG4gIH1cbiAgY29udHJvbGxlci5zZXRWYWx1ZSA9IENvbW1vbi5jb21wb3NlKGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAoZ3VpLmdldFJvb3QoKS5fX3ByZXNldF9zZWxlY3QgJiYgY29udHJvbGxlci5pc01vZGlmaWVkKCkpIHtcbiAgICAgIG1hcmtQcmVzZXRNb2RpZmllZChndWkuZ2V0Um9vdCgpLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfSwgY29udHJvbGxlci5zZXRWYWx1ZSk7XG59XG5mdW5jdGlvbiByZWNhbGxTYXZlZFZhbHVlKGd1aSwgY29udHJvbGxlcikge1xuICB2YXIgcm9vdCA9IGd1aS5nZXRSb290KCk7XG4gIHZhciBtYXRjaGVkSW5kZXggPSByb290Ll9fcmVtZW1iZXJlZE9iamVjdHMuaW5kZXhPZihjb250cm9sbGVyLm9iamVjdCk7XG4gIGlmIChtYXRjaGVkSW5kZXggIT09IC0xKSB7XG4gICAgdmFyIGNvbnRyb2xsZXJNYXAgPSByb290Ll9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzW21hdGNoZWRJbmRleF07XG4gICAgaWYgKGNvbnRyb2xsZXJNYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udHJvbGxlck1hcCA9IHt9O1xuICAgICAgcm9vdC5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1ttYXRjaGVkSW5kZXhdID0gY29udHJvbGxlck1hcDtcbiAgICB9XG4gICAgY29udHJvbGxlck1hcFtjb250cm9sbGVyLnByb3BlcnR5XSA9IGNvbnRyb2xsZXI7XG4gICAgaWYgKHJvb3QubG9hZCAmJiByb290LmxvYWQucmVtZW1iZXJlZCkge1xuICAgICAgdmFyIHByZXNldE1hcCA9IHJvb3QubG9hZC5yZW1lbWJlcmVkO1xuICAgICAgdmFyIHByZXNldCA9IHZvaWQgMDtcbiAgICAgIGlmIChwcmVzZXRNYXBbZ3VpLnByZXNldF0pIHtcbiAgICAgICAgcHJlc2V0ID0gcHJlc2V0TWFwW2d1aS5wcmVzZXRdO1xuICAgICAgfSBlbHNlIGlmIChwcmVzZXRNYXBbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXSkge1xuICAgICAgICBwcmVzZXQgPSBwcmVzZXRNYXBbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVzZXRbbWF0Y2hlZEluZGV4XSAmJiBwcmVzZXRbbWF0Y2hlZEluZGV4XVtjb250cm9sbGVyLnByb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHByZXNldFttYXRjaGVkSW5kZXhdW2NvbnRyb2xsZXIucHJvcGVydHldO1xuICAgICAgICBjb250cm9sbGVyLmluaXRpYWxWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBjb250cm9sbGVyLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9hZGQoZ3VpLCBvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpIHtcbiAgaWYgKG9iamVjdFtwcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0IFwiJyArIG9iamVjdCArICdcIiBoYXMgbm8gcHJvcGVydHkgXCInICsgcHJvcGVydHkgKyAnXCInKTtcbiAgfVxuICB2YXIgY29udHJvbGxlciA9IHZvaWQgMDtcbiAgaWYgKHBhcmFtcy5jb2xvcikge1xuICAgIGNvbnRyb2xsZXIgPSBuZXcgQ29sb3JDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpO1xuICB9IGVsc2Uge1xuICAgIHZhciBmYWN0b3J5QXJncyA9IFtvYmplY3QsIHByb3BlcnR5XS5jb25jYXQocGFyYW1zLmZhY3RvcnlBcmdzKTtcbiAgICBjb250cm9sbGVyID0gQ29udHJvbGxlckZhY3RvcnkuYXBwbHkoZ3VpLCBmYWN0b3J5QXJncyk7XG4gIH1cbiAgaWYgKHBhcmFtcy5iZWZvcmUgaW5zdGFuY2VvZiBDb250cm9sbGVyKSB7XG4gICAgcGFyYW1zLmJlZm9yZSA9IHBhcmFtcy5iZWZvcmUuX19saTtcbiAgfVxuICByZWNhbGxTYXZlZFZhbHVlKGd1aSwgY29udHJvbGxlcik7XG4gIGRvbS5hZGRDbGFzcyhjb250cm9sbGVyLmRvbUVsZW1lbnQsICdjJyk7XG4gIHZhciBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBkb20uYWRkQ2xhc3MobmFtZSwgJ3Byb3BlcnR5LW5hbWUnKTtcbiAgbmFtZS5pbm5lckhUTUwgPSBjb250cm9sbGVyLnByb3BlcnR5O1xuICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChuYW1lKTtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRyb2xsZXIuZG9tRWxlbWVudCk7XG4gIHZhciBsaSA9IGFkZFJvdyhndWksIGNvbnRhaW5lciwgcGFyYW1zLmJlZm9yZSk7XG4gIGRvbS5hZGRDbGFzcyhsaSwgR1VJLkNMQVNTX0NPTlRST0xMRVJfUk9XKTtcbiAgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBDb2xvckNvbnRyb2xsZXIpIHtcbiAgICBkb20uYWRkQ2xhc3MobGksICdjb2xvcicpO1xuICB9IGVsc2Uge1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgX3R5cGVvZihjb250cm9sbGVyLmdldFZhbHVlKCkpKTtcbiAgfVxuICBhdWdtZW50Q29udHJvbGxlcihndWksIGxpLCBjb250cm9sbGVyKTtcbiAgZ3VpLl9fY29udHJvbGxlcnMucHVzaChjb250cm9sbGVyKTtcbiAgcmV0dXJuIGNvbnRyb2xsZXI7XG59XG5mdW5jdGlvbiBnZXRMb2NhbFN0b3JhZ2VIYXNoKGd1aSwga2V5KSB7XG4gIHJldHVybiBkb2N1bWVudC5sb2NhdGlvbi5ocmVmICsgJy4nICsga2V5O1xufVxuZnVuY3Rpb24gYWRkUHJlc2V0T3B0aW9uKGd1aSwgbmFtZSwgc2V0U2VsZWN0ZWQpIHtcbiAgdmFyIG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICBvcHQuaW5uZXJIVE1MID0gbmFtZTtcbiAgb3B0LnZhbHVlID0gbmFtZTtcbiAgZ3VpLl9fcHJlc2V0X3NlbGVjdC5hcHBlbmRDaGlsZChvcHQpO1xuICBpZiAoc2V0U2VsZWN0ZWQpIHtcbiAgICBndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXggPSBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aCAtIDE7XG4gIH1cbn1cbmZ1bmN0aW9uIHNob3dIaWRlRXhwbGFpbihndWksIGV4cGxhaW4pIHtcbiAgZXhwbGFpbi5zdHlsZS5kaXNwbGF5ID0gZ3VpLnVzZUxvY2FsU3RvcmFnZSA/ICdibG9jaycgOiAnbm9uZSc7XG59XG5mdW5jdGlvbiBhZGRTYXZlTWVudShndWkpIHtcbiAgdmFyIGRpdiA9IGd1aS5fX3NhdmVfcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgZG9tLmFkZENsYXNzKGd1aS5kb21FbGVtZW50LCAnaGFzLXNhdmUnKTtcbiAgZ3VpLl9fdWwuaW5zZXJ0QmVmb3JlKGRpdiwgZ3VpLl9fdWwuZmlyc3RDaGlsZCk7XG4gIGRvbS5hZGRDbGFzcyhkaXYsICdzYXZlLXJvdycpO1xuICB2YXIgZ2VhcnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGdlYXJzLmlubmVySFRNTCA9ICcmbmJzcDsnO1xuICBkb20uYWRkQ2xhc3MoZ2VhcnMsICdidXR0b24gZ2VhcnMnKTtcbiAgdmFyIGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgYnV0dG9uLmlubmVySFRNTCA9ICdTYXZlJztcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbiwgJ2J1dHRvbicpO1xuICBkb20uYWRkQ2xhc3MoYnV0dG9uLCAnc2F2ZScpO1xuICB2YXIgYnV0dG9uMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgYnV0dG9uMi5pbm5lckhUTUwgPSAnTmV3JztcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbjIsICdidXR0b24nKTtcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbjIsICdzYXZlLWFzJyk7XG4gIHZhciBidXR0b24zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBidXR0b24zLmlubmVySFRNTCA9ICdSZXZlcnQnO1xuICBkb20uYWRkQ2xhc3MoYnV0dG9uMywgJ2J1dHRvbicpO1xuICBkb20uYWRkQ2xhc3MoYnV0dG9uMywgJ3JldmVydCcpO1xuICB2YXIgc2VsZWN0ID0gZ3VpLl9fcHJlc2V0X3NlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuICBpZiAoZ3VpLmxvYWQgJiYgZ3VpLmxvYWQucmVtZW1iZXJlZCkge1xuICAgIENvbW1vbi5lYWNoKGd1aS5sb2FkLnJlbWVtYmVyZWQsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBhZGRQcmVzZXRPcHRpb24oZ3VpLCBrZXksIGtleSA9PT0gZ3VpLnByZXNldCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYWRkUHJlc2V0T3B0aW9uKGd1aSwgREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FLCBmYWxzZSk7XG4gIH1cbiAgZG9tLmJpbmQoc2VsZWN0LCAnY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgZ3VpLl9fcHJlc2V0X3NlbGVjdFtpbmRleF0uaW5uZXJIVE1MID0gZ3VpLl9fcHJlc2V0X3NlbGVjdFtpbmRleF0udmFsdWU7XG4gICAgfVxuICAgIGd1aS5wcmVzZXQgPSB0aGlzLnZhbHVlO1xuICB9KTtcbiAgZGl2LmFwcGVuZENoaWxkKHNlbGVjdCk7XG4gIGRpdi5hcHBlbmRDaGlsZChnZWFycyk7XG4gIGRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uMik7XG4gIGRpdi5hcHBlbmRDaGlsZChidXR0b24zKTtcbiAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UpIHtcbiAgICB2YXIgZXhwbGFpbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1sb2NhbC1leHBsYWluJyk7XG4gICAgdmFyIGxvY2FsU3RvcmFnZUNoZWNrQm94ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLWxvY2FsLXN0b3JhZ2UnKTtcbiAgICB2YXIgc2F2ZUxvY2FsbHkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctc2F2ZS1sb2NhbGx5Jyk7XG4gICAgc2F2ZUxvY2FsbHkuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2goZ3VpLCAnaXNMb2NhbCcpKSA9PT0gJ3RydWUnKSB7XG4gICAgICBsb2NhbFN0b3JhZ2VDaGVja0JveC5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpO1xuICAgIH1cbiAgICBzaG93SGlkZUV4cGxhaW4oZ3VpLCBleHBsYWluKTtcbiAgICBkb20uYmluZChsb2NhbFN0b3JhZ2VDaGVja0JveCwgJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGd1aS51c2VMb2NhbFN0b3JhZ2UgPSAhZ3VpLnVzZUxvY2FsU3RvcmFnZTtcbiAgICAgIHNob3dIaWRlRXhwbGFpbihndWksIGV4cGxhaW4pO1xuICAgIH0pO1xuICB9XG4gIHZhciBuZXdDb25zdHJ1Y3RvclRleHRBcmVhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLW5ldy1jb25zdHJ1Y3RvcicpO1xuICBkb20uYmluZChuZXdDb25zdHJ1Y3RvclRleHRBcmVhLCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUubWV0YUtleSAmJiAoZS53aGljaCA9PT0gNjcgfHwgZS5rZXlDb2RlID09PSA2NykpIHtcbiAgICAgIFNBVkVfRElBTE9HVUUuaGlkZSgpO1xuICAgIH1cbiAgfSk7XG4gIGRvbS5iaW5kKGdlYXJzLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgbmV3Q29uc3RydWN0b3JUZXh0QXJlYS5pbm5lckhUTUwgPSBKU09OLnN0cmluZ2lmeShndWkuZ2V0U2F2ZU9iamVjdCgpLCB1bmRlZmluZWQsIDIpO1xuICAgIFNBVkVfRElBTE9HVUUuc2hvdygpO1xuICAgIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEuZm9jdXMoKTtcbiAgICBuZXdDb25zdHJ1Y3RvclRleHRBcmVhLnNlbGVjdCgpO1xuICB9KTtcbiAgZG9tLmJpbmQoYnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgZ3VpLnNhdmUoKTtcbiAgfSk7XG4gIGRvbS5iaW5kKGJ1dHRvbjIsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJlc2V0TmFtZSA9IHByb21wdCgnRW50ZXIgYSBuZXcgcHJlc2V0IG5hbWUuJyk7XG4gICAgaWYgKHByZXNldE5hbWUpIHtcbiAgICAgIGd1aS5zYXZlQXMocHJlc2V0TmFtZSk7XG4gICAgfVxuICB9KTtcbiAgZG9tLmJpbmQoYnV0dG9uMywgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIGd1aS5yZXZlcnQoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRSZXNpemVIYW5kbGUoZ3VpKSB7XG4gIHZhciBwbW91c2VYID0gdm9pZCAwO1xuICBndWkuX19yZXNpemVfaGFuZGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIENvbW1vbi5leHRlbmQoZ3VpLl9fcmVzaXplX2hhbmRsZS5zdHlsZSwge1xuICAgIHdpZHRoOiAnNnB4JyxcbiAgICBtYXJnaW5MZWZ0OiAnLTNweCcsXG4gICAgaGVpZ2h0OiAnMjAwcHgnLFxuICAgIGN1cnNvcjogJ2V3LXJlc2l6ZScsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgfSk7XG4gIGZ1bmN0aW9uIGRyYWcoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBndWkud2lkdGggKz0gcG1vdXNlWCAtIGUuY2xpZW50WDtcbiAgICBndWkub25SZXNpemUoKTtcbiAgICBwbW91c2VYID0gZS5jbGllbnRYO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBkcmFnU3RvcCgpIHtcbiAgICBkb20ucmVtb3ZlQ2xhc3MoZ3VpLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19EUkFHKTtcbiAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIGRyYWcpO1xuICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIGRyYWdTdG9wKTtcbiAgfVxuICBmdW5jdGlvbiBkcmFnU3RhcnQoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBwbW91c2VYID0gZS5jbGllbnRYO1xuICAgIGRvbS5hZGRDbGFzcyhndWkuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0RSQUcpO1xuICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIGRyYWcpO1xuICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBkcmFnU3RvcCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRvbS5iaW5kKGd1aS5fX3Jlc2l6ZV9oYW5kbGUsICdtb3VzZWRvd24nLCBkcmFnU3RhcnQpO1xuICBkb20uYmluZChndWkuX19jbG9zZUJ1dHRvbiwgJ21vdXNlZG93bicsIGRyYWdTdGFydCk7XG4gIGd1aS5kb21FbGVtZW50Lmluc2VydEJlZm9yZShndWkuX19yZXNpemVfaGFuZGxlLCBndWkuZG9tRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCk7XG59XG5mdW5jdGlvbiBzZXRXaWR0aChndWksIHcpIHtcbiAgZ3VpLmRvbUVsZW1lbnQuc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgaWYgKGd1aS5fX3NhdmVfcm93ICYmIGd1aS5hdXRvUGxhY2UpIHtcbiAgICBndWkuX19zYXZlX3Jvdy5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICB9XG4gIGlmIChndWkuX19jbG9zZUJ1dHRvbikge1xuICAgIGd1aS5fX2Nsb3NlQnV0dG9uLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRQcmVzZXQoZ3VpLCB1c2VJbml0aWFsVmFsdWVzKSB7XG4gIHZhciB0b1JldHVybiA9IHt9O1xuICBDb21tb24uZWFjaChndWkuX19yZW1lbWJlcmVkT2JqZWN0cywgZnVuY3Rpb24gKHZhbCwgaW5kZXgpIHtcbiAgICB2YXIgc2F2ZWRWYWx1ZXMgPSB7fTtcbiAgICB2YXIgY29udHJvbGxlck1hcCA9IGd1aS5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1tpbmRleF07XG4gICAgQ29tbW9uLmVhY2goY29udHJvbGxlck1hcCwgZnVuY3Rpb24gKGNvbnRyb2xsZXIsIHByb3BlcnR5KSB7XG4gICAgICBzYXZlZFZhbHVlc1twcm9wZXJ0eV0gPSB1c2VJbml0aWFsVmFsdWVzID8gY29udHJvbGxlci5pbml0aWFsVmFsdWUgOiBjb250cm9sbGVyLmdldFZhbHVlKCk7XG4gICAgfSk7XG4gICAgdG9SZXR1cm5baW5kZXhdID0gc2F2ZWRWYWx1ZXM7XG4gIH0pO1xuICByZXR1cm4gdG9SZXR1cm47XG59XG5mdW5jdGlvbiBzZXRQcmVzZXRTZWxlY3RJbmRleChndWkpIHtcbiAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGd1aS5fX3ByZXNldF9zZWxlY3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgaWYgKGd1aS5fX3ByZXNldF9zZWxlY3RbaW5kZXhdLnZhbHVlID09PSBndWkucHJlc2V0KSB7XG4gICAgICBndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXggPSBpbmRleDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZURpc3BsYXlzKGNvbnRyb2xsZXJBcnJheSkge1xuICBpZiAoY29udHJvbGxlckFycmF5Lmxlbmd0aCAhPT0gMCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxLmNhbGwod2luZG93LCBmdW5jdGlvbiAoKSB7XG4gICAgICB1cGRhdGVEaXNwbGF5cyhjb250cm9sbGVyQXJyYXkpO1xuICAgIH0pO1xuICB9XG4gIENvbW1vbi5lYWNoKGNvbnRyb2xsZXJBcnJheSwgZnVuY3Rpb24gKGMpIHtcbiAgICBjLnVwZGF0ZURpc3BsYXkoKTtcbiAgfSk7XG59XG5cbnZhciBjb2xvciA9IHtcbiAgQ29sb3I6IENvbG9yLFxuICBtYXRoOiBDb2xvck1hdGgsXG4gIGludGVycHJldDogaW50ZXJwcmV0XG59O1xudmFyIGNvbnRyb2xsZXJzID0ge1xuICBDb250cm9sbGVyOiBDb250cm9sbGVyLFxuICBCb29sZWFuQ29udHJvbGxlcjogQm9vbGVhbkNvbnRyb2xsZXIsXG4gIE9wdGlvbkNvbnRyb2xsZXI6IE9wdGlvbkNvbnRyb2xsZXIsXG4gIFN0cmluZ0NvbnRyb2xsZXI6IFN0cmluZ0NvbnRyb2xsZXIsXG4gIE51bWJlckNvbnRyb2xsZXI6IE51bWJlckNvbnRyb2xsZXIsXG4gIE51bWJlckNvbnRyb2xsZXJCb3g6IE51bWJlckNvbnRyb2xsZXJCb3gsXG4gIE51bWJlckNvbnRyb2xsZXJTbGlkZXI6IE51bWJlckNvbnRyb2xsZXJTbGlkZXIsXG4gIEZ1bmN0aW9uQ29udHJvbGxlcjogRnVuY3Rpb25Db250cm9sbGVyLFxuICBDb2xvckNvbnRyb2xsZXI6IENvbG9yQ29udHJvbGxlclxufTtcbnZhciBkb20kMSA9IHsgZG9tOiBkb20gfTtcbnZhciBndWkgPSB7IEdVSTogR1VJIH07XG52YXIgR1VJJDEgPSBHVUk7XG52YXIgaW5kZXggPSB7XG4gIGNvbG9yOiBjb2xvcixcbiAgY29udHJvbGxlcnM6IGNvbnRyb2xsZXJzLFxuICBkb206IGRvbSQxLFxuICBndWk6IGd1aSxcbiAgR1VJOiBHVUkkMVxufTtcblxuZXhwb3J0cy5jb2xvciA9IGNvbG9yO1xuZXhwb3J0cy5jb250cm9sbGVycyA9IGNvbnRyb2xsZXJzO1xuZXhwb3J0cy5kb20gPSBkb20kMTtcbmV4cG9ydHMuZ3VpID0gZ3VpO1xuZXhwb3J0cy5HVUkgPSBHVUkkMTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGluZGV4O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0Lmd1aS5qcy5tYXBcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBJRSA4IGhhcyBhIGJyb2tlbiBPYmplY3QuZGVmaW5lUHJvcGVydHkgdGhhdCBvbmx5IHdvcmtzIG9uIERPTSBvYmplY3RzLlxuICAgIGRlZmluZSh7fSwgXCJcIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlZmluZSA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgZGVmaW5lKEdwLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgdG9TdHJpbmdUYWdTeW1ib2wsXG4gICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICk7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgZGVmaW5lKEdwLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIGRlZmluZShHcCwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgaW4gbW9kZXJuIGVuZ2luZXNcbiAgLy8gd2UgY2FuIGV4cGxpY2l0bHkgYWNjZXNzIGdsb2JhbFRoaXMuIEluIG9sZGVyIGVuZ2luZXMgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiKSB7XG4gICAgZ2xvYmFsVGhpcy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xuICB9IGVsc2Uge1xuICAgIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDEwLTIwMjEgVGhyZWUuanMgQXV0aG9yc1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLlRIUkVFID0ge30pKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cblx0Y29uc3QgUkVWSVNJT04gPSAnMTM1Jztcblx0Y29uc3QgTU9VU0UgPSB7XG5cdFx0TEVGVDogMCxcblx0XHRNSURETEU6IDEsXG5cdFx0UklHSFQ6IDIsXG5cdFx0Uk9UQVRFOiAwLFxuXHRcdERPTExZOiAxLFxuXHRcdFBBTjogMlxuXHR9O1xuXHRjb25zdCBUT1VDSCA9IHtcblx0XHRST1RBVEU6IDAsXG5cdFx0UEFOOiAxLFxuXHRcdERPTExZX1BBTjogMixcblx0XHRET0xMWV9ST1RBVEU6IDNcblx0fTtcblx0Y29uc3QgQ3VsbEZhY2VOb25lID0gMDtcblx0Y29uc3QgQ3VsbEZhY2VCYWNrID0gMTtcblx0Y29uc3QgQ3VsbEZhY2VGcm9udCA9IDI7XG5cdGNvbnN0IEN1bGxGYWNlRnJvbnRCYWNrID0gMztcblx0Y29uc3QgQmFzaWNTaGFkb3dNYXAgPSAwO1xuXHRjb25zdCBQQ0ZTaGFkb3dNYXAgPSAxO1xuXHRjb25zdCBQQ0ZTb2Z0U2hhZG93TWFwID0gMjtcblx0Y29uc3QgVlNNU2hhZG93TWFwID0gMztcblx0Y29uc3QgRnJvbnRTaWRlID0gMDtcblx0Y29uc3QgQmFja1NpZGUgPSAxO1xuXHRjb25zdCBEb3VibGVTaWRlID0gMjtcblx0Y29uc3QgRmxhdFNoYWRpbmcgPSAxO1xuXHRjb25zdCBTbW9vdGhTaGFkaW5nID0gMjtcblx0Y29uc3QgTm9CbGVuZGluZyA9IDA7XG5cdGNvbnN0IE5vcm1hbEJsZW5kaW5nID0gMTtcblx0Y29uc3QgQWRkaXRpdmVCbGVuZGluZyA9IDI7XG5cdGNvbnN0IFN1YnRyYWN0aXZlQmxlbmRpbmcgPSAzO1xuXHRjb25zdCBNdWx0aXBseUJsZW5kaW5nID0gNDtcblx0Y29uc3QgQ3VzdG9tQmxlbmRpbmcgPSA1O1xuXHRjb25zdCBBZGRFcXVhdGlvbiA9IDEwMDtcblx0Y29uc3QgU3VidHJhY3RFcXVhdGlvbiA9IDEwMTtcblx0Y29uc3QgUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gPSAxMDI7XG5cdGNvbnN0IE1pbkVxdWF0aW9uID0gMTAzO1xuXHRjb25zdCBNYXhFcXVhdGlvbiA9IDEwNDtcblx0Y29uc3QgWmVyb0ZhY3RvciA9IDIwMDtcblx0Y29uc3QgT25lRmFjdG9yID0gMjAxO1xuXHRjb25zdCBTcmNDb2xvckZhY3RvciA9IDIwMjtcblx0Y29uc3QgT25lTWludXNTcmNDb2xvckZhY3RvciA9IDIwMztcblx0Y29uc3QgU3JjQWxwaGFGYWN0b3IgPSAyMDQ7XG5cdGNvbnN0IE9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XG5cdGNvbnN0IERzdEFscGhhRmFjdG9yID0gMjA2O1xuXHRjb25zdCBPbmVNaW51c0RzdEFscGhhRmFjdG9yID0gMjA3O1xuXHRjb25zdCBEc3RDb2xvckZhY3RvciA9IDIwODtcblx0Y29uc3QgT25lTWludXNEc3RDb2xvckZhY3RvciA9IDIwOTtcblx0Y29uc3QgU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciA9IDIxMDtcblx0Y29uc3QgTmV2ZXJEZXB0aCA9IDA7XG5cdGNvbnN0IEFsd2F5c0RlcHRoID0gMTtcblx0Y29uc3QgTGVzc0RlcHRoID0gMjtcblx0Y29uc3QgTGVzc0VxdWFsRGVwdGggPSAzO1xuXHRjb25zdCBFcXVhbERlcHRoID0gNDtcblx0Y29uc3QgR3JlYXRlckVxdWFsRGVwdGggPSA1O1xuXHRjb25zdCBHcmVhdGVyRGVwdGggPSA2O1xuXHRjb25zdCBOb3RFcXVhbERlcHRoID0gNztcblx0Y29uc3QgTXVsdGlwbHlPcGVyYXRpb24gPSAwO1xuXHRjb25zdCBNaXhPcGVyYXRpb24gPSAxO1xuXHRjb25zdCBBZGRPcGVyYXRpb24gPSAyO1xuXHRjb25zdCBOb1RvbmVNYXBwaW5nID0gMDtcblx0Y29uc3QgTGluZWFyVG9uZU1hcHBpbmcgPSAxO1xuXHRjb25zdCBSZWluaGFyZFRvbmVNYXBwaW5nID0gMjtcblx0Y29uc3QgQ2luZW9uVG9uZU1hcHBpbmcgPSAzO1xuXHRjb25zdCBBQ0VTRmlsbWljVG9uZU1hcHBpbmcgPSA0O1xuXHRjb25zdCBDdXN0b21Ub25lTWFwcGluZyA9IDU7XG5cdGNvbnN0IFVWTWFwcGluZyA9IDMwMDtcblx0Y29uc3QgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nID0gMzAxO1xuXHRjb25zdCBDdWJlUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDI7XG5cdGNvbnN0IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nID0gMzAzO1xuXHRjb25zdCBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyA9IDMwNDtcblx0Y29uc3QgQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDY7XG5cdGNvbnN0IEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nID0gMzA3O1xuXHRjb25zdCBSZXBlYXRXcmFwcGluZyA9IDEwMDA7XG5cdGNvbnN0IENsYW1wVG9FZGdlV3JhcHBpbmcgPSAxMDAxO1xuXHRjb25zdCBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nID0gMTAwMjtcblx0Y29uc3QgTmVhcmVzdEZpbHRlciA9IDEwMDM7XG5cdGNvbnN0IE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyID0gMTAwNDtcblx0Y29uc3QgTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA0O1xuXHRjb25zdCBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyID0gMTAwNTtcblx0Y29uc3QgTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciA9IDEwMDU7XG5cdGNvbnN0IExpbmVhckZpbHRlciA9IDEwMDY7XG5cdGNvbnN0IExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA3O1xuXHRjb25zdCBMaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNztcblx0Y29uc3QgTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyID0gMTAwODtcblx0Y29uc3QgTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyID0gMTAwODtcblx0Y29uc3QgVW5zaWduZWRCeXRlVHlwZSA9IDEwMDk7XG5cdGNvbnN0IEJ5dGVUeXBlID0gMTAxMDtcblx0Y29uc3QgU2hvcnRUeXBlID0gMTAxMTtcblx0Y29uc3QgVW5zaWduZWRTaG9ydFR5cGUgPSAxMDEyO1xuXHRjb25zdCBJbnRUeXBlID0gMTAxMztcblx0Y29uc3QgVW5zaWduZWRJbnRUeXBlID0gMTAxNDtcblx0Y29uc3QgRmxvYXRUeXBlID0gMTAxNTtcblx0Y29uc3QgSGFsZkZsb2F0VHlwZSA9IDEwMTY7XG5cdGNvbnN0IFVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSA9IDEwMTc7XG5cdGNvbnN0IFVuc2lnbmVkU2hvcnQ1NTUxVHlwZSA9IDEwMTg7XG5cdGNvbnN0IFVuc2lnbmVkU2hvcnQ1NjVUeXBlID0gMTAxOTtcblx0Y29uc3QgVW5zaWduZWRJbnQyNDhUeXBlID0gMTAyMDtcblx0Y29uc3QgQWxwaGFGb3JtYXQgPSAxMDIxO1xuXHRjb25zdCBSR0JGb3JtYXQgPSAxMDIyO1xuXHRjb25zdCBSR0JBRm9ybWF0ID0gMTAyMztcblx0Y29uc3QgTHVtaW5hbmNlRm9ybWF0ID0gMTAyNDtcblx0Y29uc3QgTHVtaW5hbmNlQWxwaGFGb3JtYXQgPSAxMDI1O1xuXHRjb25zdCBSR0JFRm9ybWF0ID0gUkdCQUZvcm1hdDtcblx0Y29uc3QgRGVwdGhGb3JtYXQgPSAxMDI2O1xuXHRjb25zdCBEZXB0aFN0ZW5jaWxGb3JtYXQgPSAxMDI3O1xuXHRjb25zdCBSZWRGb3JtYXQgPSAxMDI4O1xuXHRjb25zdCBSZWRJbnRlZ2VyRm9ybWF0ID0gMTAyOTtcblx0Y29uc3QgUkdGb3JtYXQgPSAxMDMwO1xuXHRjb25zdCBSR0ludGVnZXJGb3JtYXQgPSAxMDMxO1xuXHRjb25zdCBSR0JJbnRlZ2VyRm9ybWF0ID0gMTAzMjtcblx0Y29uc3QgUkdCQUludGVnZXJGb3JtYXQgPSAxMDMzO1xuXHRjb25zdCBSR0JfUzNUQ19EWFQxX0Zvcm1hdCA9IDMzNzc2O1xuXHRjb25zdCBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgPSAzMzc3Nztcblx0Y29uc3QgUkdCQV9TM1RDX0RYVDNfRm9ybWF0ID0gMzM3Nzg7XG5cdGNvbnN0IFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCA9IDMzNzc5O1xuXHRjb25zdCBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDM1ODQwO1xuXHRjb25zdCBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IDM1ODQxO1xuXHRjb25zdCBSR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgPSAzNTg0Mjtcblx0Y29uc3QgUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMzU4NDM7XG5cdGNvbnN0IFJHQl9FVEMxX0Zvcm1hdCA9IDM2MTk2O1xuXHRjb25zdCBSR0JfRVRDMl9Gb3JtYXQgPSAzNzQ5Mjtcblx0Y29uc3QgUkdCQV9FVEMyX0VBQ19Gb3JtYXQgPSAzNzQ5Njtcblx0Y29uc3QgUkdCQV9BU1RDXzR4NF9Gb3JtYXQgPSAzNzgwODtcblx0Y29uc3QgUkdCQV9BU1RDXzV4NF9Gb3JtYXQgPSAzNzgwOTtcblx0Y29uc3QgUkdCQV9BU1RDXzV4NV9Gb3JtYXQgPSAzNzgxMDtcblx0Y29uc3QgUkdCQV9BU1RDXzZ4NV9Gb3JtYXQgPSAzNzgxMTtcblx0Y29uc3QgUkdCQV9BU1RDXzZ4Nl9Gb3JtYXQgPSAzNzgxMjtcblx0Y29uc3QgUkdCQV9BU1RDXzh4NV9Gb3JtYXQgPSAzNzgxMztcblx0Y29uc3QgUkdCQV9BU1RDXzh4Nl9Gb3JtYXQgPSAzNzgxNDtcblx0Y29uc3QgUkdCQV9BU1RDXzh4OF9Gb3JtYXQgPSAzNzgxNTtcblx0Y29uc3QgUkdCQV9BU1RDXzEweDVfRm9ybWF0ID0gMzc4MTY7XG5cdGNvbnN0IFJHQkFfQVNUQ18xMHg2X0Zvcm1hdCA9IDM3ODE3O1xuXHRjb25zdCBSR0JBX0FTVENfMTB4OF9Gb3JtYXQgPSAzNzgxODtcblx0Y29uc3QgUkdCQV9BU1RDXzEweDEwX0Zvcm1hdCA9IDM3ODE5O1xuXHRjb25zdCBSR0JBX0FTVENfMTJ4MTBfRm9ybWF0ID0gMzc4MjA7XG5cdGNvbnN0IFJHQkFfQVNUQ18xMngxMl9Gb3JtYXQgPSAzNzgyMTtcblx0Y29uc3QgUkdCQV9CUFRDX0Zvcm1hdCA9IDM2NDkyO1xuXHRjb25zdCBTUkdCOF9BTFBIQThfQVNUQ180eDRfRm9ybWF0ID0gMzc4NDA7XG5cdGNvbnN0IFNSR0I4X0FMUEhBOF9BU1RDXzV4NF9Gb3JtYXQgPSAzNzg0MTtcblx0Y29uc3QgU1JHQjhfQUxQSEE4X0FTVENfNXg1X0Zvcm1hdCA9IDM3ODQyO1xuXHRjb25zdCBTUkdCOF9BTFBIQThfQVNUQ182eDVfRm9ybWF0ID0gMzc4NDM7XG5cdGNvbnN0IFNSR0I4X0FMUEhBOF9BU1RDXzZ4Nl9Gb3JtYXQgPSAzNzg0NDtcblx0Y29uc3QgU1JHQjhfQUxQSEE4X0FTVENfOHg1X0Zvcm1hdCA9IDM3ODQ1O1xuXHRjb25zdCBTUkdCOF9BTFBIQThfQVNUQ184eDZfRm9ybWF0ID0gMzc4NDY7XG5cdGNvbnN0IFNSR0I4X0FMUEhBOF9BU1RDXzh4OF9Gb3JtYXQgPSAzNzg0Nztcblx0Y29uc3QgU1JHQjhfQUxQSEE4X0FTVENfMTB4NV9Gb3JtYXQgPSAzNzg0ODtcblx0Y29uc3QgU1JHQjhfQUxQSEE4X0FTVENfMTB4Nl9Gb3JtYXQgPSAzNzg0OTtcblx0Y29uc3QgU1JHQjhfQUxQSEE4X0FTVENfMTB4OF9Gb3JtYXQgPSAzNzg1MDtcblx0Y29uc3QgU1JHQjhfQUxQSEE4X0FTVENfMTB4MTBfRm9ybWF0ID0gMzc4NTE7XG5cdGNvbnN0IFNSR0I4X0FMUEhBOF9BU1RDXzEyeDEwX0Zvcm1hdCA9IDM3ODUyO1xuXHRjb25zdCBTUkdCOF9BTFBIQThfQVNUQ18xMngxMl9Gb3JtYXQgPSAzNzg1Mztcblx0Y29uc3QgTG9vcE9uY2UgPSAyMjAwO1xuXHRjb25zdCBMb29wUmVwZWF0ID0gMjIwMTtcblx0Y29uc3QgTG9vcFBpbmdQb25nID0gMjIwMjtcblx0Y29uc3QgSW50ZXJwb2xhdGVEaXNjcmV0ZSA9IDIzMDA7XG5cdGNvbnN0IEludGVycG9sYXRlTGluZWFyID0gMjMwMTtcblx0Y29uc3QgSW50ZXJwb2xhdGVTbW9vdGggPSAyMzAyO1xuXHRjb25zdCBaZXJvQ3VydmF0dXJlRW5kaW5nID0gMjQwMDtcblx0Y29uc3QgWmVyb1Nsb3BlRW5kaW5nID0gMjQwMTtcblx0Y29uc3QgV3JhcEFyb3VuZEVuZGluZyA9IDI0MDI7XG5cdGNvbnN0IE5vcm1hbEFuaW1hdGlvbkJsZW5kTW9kZSA9IDI1MDA7XG5cdGNvbnN0IEFkZGl0aXZlQW5pbWF0aW9uQmxlbmRNb2RlID0gMjUwMTtcblx0Y29uc3QgVHJpYW5nbGVzRHJhd01vZGUgPSAwO1xuXHRjb25zdCBUcmlhbmdsZVN0cmlwRHJhd01vZGUgPSAxO1xuXHRjb25zdCBUcmlhbmdsZUZhbkRyYXdNb2RlID0gMjtcblx0Y29uc3QgTGluZWFyRW5jb2RpbmcgPSAzMDAwO1xuXHRjb25zdCBzUkdCRW5jb2RpbmcgPSAzMDAxO1xuXHRjb25zdCBHYW1tYUVuY29kaW5nID0gMzAwNztcblx0Y29uc3QgUkdCRUVuY29kaW5nID0gMzAwMjtcblx0Y29uc3QgUkdCTTdFbmNvZGluZyA9IDMwMDQ7XG5cdGNvbnN0IFJHQk0xNkVuY29kaW5nID0gMzAwNTtcblx0Y29uc3QgUkdCREVuY29kaW5nID0gMzAwNjtcblx0Y29uc3QgQmFzaWNEZXB0aFBhY2tpbmcgPSAzMjAwO1xuXHRjb25zdCBSR0JBRGVwdGhQYWNraW5nID0gMzIwMTtcblx0Y29uc3QgVGFuZ2VudFNwYWNlTm9ybWFsTWFwID0gMDtcblx0Y29uc3QgT2JqZWN0U3BhY2VOb3JtYWxNYXAgPSAxO1xuXHRjb25zdCBaZXJvU3RlbmNpbE9wID0gMDtcblx0Y29uc3QgS2VlcFN0ZW5jaWxPcCA9IDc2ODA7XG5cdGNvbnN0IFJlcGxhY2VTdGVuY2lsT3AgPSA3NjgxO1xuXHRjb25zdCBJbmNyZW1lbnRTdGVuY2lsT3AgPSA3NjgyO1xuXHRjb25zdCBEZWNyZW1lbnRTdGVuY2lsT3AgPSA3NjgzO1xuXHRjb25zdCBJbmNyZW1lbnRXcmFwU3RlbmNpbE9wID0gMzQwNTU7XG5cdGNvbnN0IERlY3JlbWVudFdyYXBTdGVuY2lsT3AgPSAzNDA1Njtcblx0Y29uc3QgSW52ZXJ0U3RlbmNpbE9wID0gNTM4Njtcblx0Y29uc3QgTmV2ZXJTdGVuY2lsRnVuYyA9IDUxMjtcblx0Y29uc3QgTGVzc1N0ZW5jaWxGdW5jID0gNTEzO1xuXHRjb25zdCBFcXVhbFN0ZW5jaWxGdW5jID0gNTE0O1xuXHRjb25zdCBMZXNzRXF1YWxTdGVuY2lsRnVuYyA9IDUxNTtcblx0Y29uc3QgR3JlYXRlclN0ZW5jaWxGdW5jID0gNTE2O1xuXHRjb25zdCBOb3RFcXVhbFN0ZW5jaWxGdW5jID0gNTE3O1xuXHRjb25zdCBHcmVhdGVyRXF1YWxTdGVuY2lsRnVuYyA9IDUxODtcblx0Y29uc3QgQWx3YXlzU3RlbmNpbEZ1bmMgPSA1MTk7XG5cdGNvbnN0IFN0YXRpY0RyYXdVc2FnZSA9IDM1MDQ0O1xuXHRjb25zdCBEeW5hbWljRHJhd1VzYWdlID0gMzUwNDg7XG5cdGNvbnN0IFN0cmVhbURyYXdVc2FnZSA9IDM1MDQwO1xuXHRjb25zdCBTdGF0aWNSZWFkVXNhZ2UgPSAzNTA0NTtcblx0Y29uc3QgRHluYW1pY1JlYWRVc2FnZSA9IDM1MDQ5O1xuXHRjb25zdCBTdHJlYW1SZWFkVXNhZ2UgPSAzNTA0MTtcblx0Y29uc3QgU3RhdGljQ29weVVzYWdlID0gMzUwNDY7XG5cdGNvbnN0IER5bmFtaWNDb3B5VXNhZ2UgPSAzNTA1MDtcblx0Y29uc3QgU3RyZWFtQ29weVVzYWdlID0gMzUwNDI7XG5cdGNvbnN0IEdMU0wxID0gJzEwMCc7XG5cdGNvbnN0IEdMU0wzID0gJzMwMCBlcyc7XG5cblx0LyoqXG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvZXZlbnRkaXNwYXRjaGVyLmpzL1xuXHQgKi9cblx0Y2xhc3MgRXZlbnREaXNwYXRjaGVyIHtcblx0XHRhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG5cdFx0XHRpZiAodGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuXHRcdFx0Y29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXG5cdFx0XHRpZiAobGlzdGVuZXJzW3R5cGVdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0bGlzdGVuZXJzW3R5cGVdID0gW107XG5cdFx0XHR9XG5cblx0XHRcdGlmIChsaXN0ZW5lcnNbdHlwZV0uaW5kZXhPZihsaXN0ZW5lcikgPT09IC0xKSB7XG5cdFx0XHRcdGxpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYXNFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG5cdFx0XHRpZiAodGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcblx0XHRcdGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblx0XHRcdHJldHVybiBsaXN0ZW5lcnNbdHlwZV0gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5lcnNbdHlwZV0uaW5kZXhPZihsaXN0ZW5lcikgIT09IC0xO1xuXHRcdH1cblxuXHRcdHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcblx0XHRcdGlmICh0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXHRcdFx0Y29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXHRcdFx0Y29uc3QgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1t0eXBlXTtcblxuXHRcdFx0aWYgKGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb25zdCBpbmRleCA9IGxpc3RlbmVyQXJyYXkuaW5kZXhPZihsaXN0ZW5lcik7XG5cblx0XHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRcdGxpc3RlbmVyQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcblx0XHRcdGlmICh0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXHRcdFx0Y29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXHRcdFx0Y29uc3QgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1tldmVudC50eXBlXTtcblxuXHRcdFx0aWYgKGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRldmVudC50YXJnZXQgPSB0aGlzOyAvLyBNYWtlIGEgY29weSwgaW4gY2FzZSBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQgd2hpbGUgaXRlcmF0aW5nLlxuXG5cdFx0XHRcdGNvbnN0IGFycmF5ID0gbGlzdGVuZXJBcnJheS5zbGljZSgwKTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGFycmF5W2ldLmNhbGwodGhpcywgZXZlbnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZXZlbnQudGFyZ2V0ID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0fVxuXG5cdGNvbnN0IF9sdXQgPSBbXTtcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG5cdFx0X2x1dFtpXSA9IChpIDwgMTYgPyAnMCcgOiAnJykgKyBpLnRvU3RyaW5nKDE2KTtcblx0fVxuXG5cdGxldCBfc2VlZCA9IDEyMzQ1Njc7XG5cdGNvbnN0IERFRzJSQUQgPSBNYXRoLlBJIC8gMTgwO1xuXHRjb25zdCBSQUQyREVHID0gMTgwIC8gTWF0aC5QSTsgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvaG93LXRvLWNyZWF0ZS1hLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0LzIxOTYzMTM2IzIxOTYzMTM2XG5cblx0ZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKCkge1xuXHRcdGNvbnN0IGQwID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuXHRcdGNvbnN0IGQxID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuXHRcdGNvbnN0IGQyID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuXHRcdGNvbnN0IGQzID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuXHRcdGNvbnN0IHV1aWQgPSBfbHV0W2QwICYgMHhmZl0gKyBfbHV0W2QwID4+IDggJiAweGZmXSArIF9sdXRbZDAgPj4gMTYgJiAweGZmXSArIF9sdXRbZDAgPj4gMjQgJiAweGZmXSArICctJyArIF9sdXRbZDEgJiAweGZmXSArIF9sdXRbZDEgPj4gOCAmIDB4ZmZdICsgJy0nICsgX2x1dFtkMSA+PiAxNiAmIDB4MGYgfCAweDQwXSArIF9sdXRbZDEgPj4gMjQgJiAweGZmXSArICctJyArIF9sdXRbZDIgJiAweDNmIHwgMHg4MF0gKyBfbHV0W2QyID4+IDggJiAweGZmXSArICctJyArIF9sdXRbZDIgPj4gMTYgJiAweGZmXSArIF9sdXRbZDIgPj4gMjQgJiAweGZmXSArIF9sdXRbZDMgJiAweGZmXSArIF9sdXRbZDMgPj4gOCAmIDB4ZmZdICsgX2x1dFtkMyA+PiAxNiAmIDB4ZmZdICsgX2x1dFtkMyA+PiAyNCAmIDB4ZmZdOyAvLyAudG9VcHBlckNhc2UoKSBoZXJlIGZsYXR0ZW5zIGNvbmNhdGVuYXRlZCBzdHJpbmdzIHRvIHNhdmUgaGVhcCBtZW1vcnkgc3BhY2UuXG5cblx0XHRyZXR1cm4gdXVpZC50b1VwcGVyQ2FzZSgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG5cdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2YWx1ZSkpO1xuXHR9IC8vIGNvbXB1dGUgZXVjbGlkaWFuIG1vZHVsbyBvZiBtICUgblxuXHQvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb2R1bG9fb3BlcmF0aW9uXG5cblxuXHRmdW5jdGlvbiBldWNsaWRlYW5Nb2R1bG8obiwgbSkge1xuXHRcdHJldHVybiAobiAlIG0gKyBtKSAlIG07XG5cdH0gLy8gTGluZWFyIG1hcHBpbmcgZnJvbSByYW5nZSA8YTEsIGEyPiB0byByYW5nZSA8YjEsIGIyPlxuXG5cblx0ZnVuY3Rpb24gbWFwTGluZWFyKHgsIGExLCBhMiwgYjEsIGIyKSB7XG5cdFx0cmV0dXJuIGIxICsgKHggLSBhMSkgKiAoYjIgLSBiMSkgLyAoYTIgLSBhMSk7XG5cdH0gLy8gaHR0cHM6Ly93d3cuZ2FtZWRldi5uZXQvdHV0b3JpYWxzL3Byb2dyYW1taW5nL2dlbmVyYWwtYW5kLWdhbWVwbGF5LXByb2dyYW1taW5nL2ludmVyc2UtbGVycC1hLXN1cGVyLXVzZWZ1bC15ZXQtb2Z0ZW4tb3Zlcmxvb2tlZC1mdW5jdGlvbi1yNTIzMC9cblxuXG5cdGZ1bmN0aW9uIGludmVyc2VMZXJwKHgsIHksIHZhbHVlKSB7XG5cdFx0aWYgKHggIT09IHkpIHtcblx0XHRcdHJldHVybiAodmFsdWUgLSB4KSAvICh5IC0geCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0fSAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lYXJfaW50ZXJwb2xhdGlvblxuXG5cblx0ZnVuY3Rpb24gbGVycCh4LCB5LCB0KSB7XG5cdFx0cmV0dXJuICgxIC0gdCkgKiB4ICsgdCAqIHk7XG5cdH0gLy8gaHR0cDovL3d3dy5yb3J5ZHJpc2NvbGwuY29tLzIwMTYvMDMvMDcvZnJhbWUtcmF0ZS1pbmRlcGVuZGVudC1kYW1waW5nLXVzaW5nLWxlcnAvXG5cblxuXHRmdW5jdGlvbiBkYW1wKHgsIHksIGxhbWJkYSwgZHQpIHtcblx0XHRyZXR1cm4gbGVycCh4LCB5LCAxIC0gTWF0aC5leHAoLWxhbWJkYSAqIGR0KSk7XG5cdH0gLy8gaHR0cHM6Ly93d3cuZGVzbW9zLmNvbS9jYWxjdWxhdG9yL3Zjc2pueXo3eDRcblxuXG5cdGZ1bmN0aW9uIHBpbmdwb25nKHgsIGxlbmd0aCA9IDEpIHtcblx0XHRyZXR1cm4gbGVuZ3RoIC0gTWF0aC5hYnMoZXVjbGlkZWFuTW9kdWxvKHgsIGxlbmd0aCAqIDIpIC0gbGVuZ3RoKTtcblx0fSAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXBcblxuXG5cdGZ1bmN0aW9uIHNtb290aHN0ZXAoeCwgbWluLCBtYXgpIHtcblx0XHRpZiAoeCA8PSBtaW4pIHJldHVybiAwO1xuXHRcdGlmICh4ID49IG1heCkgcmV0dXJuIDE7XG5cdFx0eCA9ICh4IC0gbWluKSAvIChtYXggLSBtaW4pO1xuXHRcdHJldHVybiB4ICogeCAqICgzIC0gMiAqIHgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc21vb3RoZXJzdGVwKHgsIG1pbiwgbWF4KSB7XG5cdFx0aWYgKHggPD0gbWluKSByZXR1cm4gMDtcblx0XHRpZiAoeCA+PSBtYXgpIHJldHVybiAxO1xuXHRcdHggPSAoeCAtIG1pbikgLyAobWF4IC0gbWluKTtcblx0XHRyZXR1cm4geCAqIHggKiB4ICogKHggKiAoeCAqIDYgLSAxNSkgKyAxMCk7XG5cdH0gLy8gUmFuZG9tIGludGVnZXIgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxuXG5cblx0ZnVuY3Rpb24gcmFuZEludChsb3csIGhpZ2gpIHtcblx0XHRyZXR1cm4gbG93ICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGhpZ2ggLSBsb3cgKyAxKSk7XG5cdH0gLy8gUmFuZG9tIGZsb2F0IGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcblxuXG5cdGZ1bmN0aW9uIHJhbmRGbG9hdChsb3csIGhpZ2gpIHtcblx0XHRyZXR1cm4gbG93ICsgTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93KTtcblx0fSAvLyBSYW5kb20gZmxvYXQgZnJvbSA8LXJhbmdlLzIsIHJhbmdlLzI+IGludGVydmFsXG5cblxuXHRmdW5jdGlvbiByYW5kRmxvYXRTcHJlYWQocmFuZ2UpIHtcblx0XHRyZXR1cm4gcmFuZ2UgKiAoMC41IC0gTWF0aC5yYW5kb20oKSk7XG5cdH0gLy8gRGV0ZXJtaW5pc3RpYyBwc2V1ZG8tcmFuZG9tIGZsb2F0IGluIHRoZSBpbnRlcnZhbCBbIDAsIDEgXVxuXG5cblx0ZnVuY3Rpb24gc2VlZGVkUmFuZG9tKHMpIHtcblx0XHRpZiAocyAhPT0gdW5kZWZpbmVkKSBfc2VlZCA9IHMgJSAyMTQ3NDgzNjQ3OyAvLyBQYXJrLU1pbGxlciBhbGdvcml0aG1cblxuXHRcdF9zZWVkID0gX3NlZWQgKiAxNjgwNyAlIDIxNDc0ODM2NDc7XG5cdFx0cmV0dXJuIChfc2VlZCAtIDEpIC8gMjE0NzQ4MzY0Njtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlZ1RvUmFkKGRlZ3JlZXMpIHtcblx0XHRyZXR1cm4gZGVncmVlcyAqIERFRzJSQUQ7XG5cdH1cblxuXHRmdW5jdGlvbiByYWRUb0RlZyhyYWRpYW5zKSB7XG5cdFx0cmV0dXJuIHJhZGlhbnMgKiBSQUQyREVHO1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNQb3dlck9mVHdvKHZhbHVlKSB7XG5cdFx0cmV0dXJuICh2YWx1ZSAmIHZhbHVlIC0gMSkgPT09IDAgJiYgdmFsdWUgIT09IDA7XG5cdH1cblxuXHRmdW5jdGlvbiBjZWlsUG93ZXJPZlR3byh2YWx1ZSkge1xuXHRcdHJldHVybiBNYXRoLnBvdygyLCBNYXRoLmNlaWwoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGZsb29yUG93ZXJPZlR3byh2YWx1ZSkge1xuXHRcdHJldHVybiBNYXRoLnBvdygyLCBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyKHEsIGEsIGIsIGMsIG9yZGVyKSB7XG5cdFx0Ly8gSW50cmluc2ljIFByb3BlciBFdWxlciBBbmdsZXMgLSBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXVsZXJfYW5nbGVzXG5cdFx0Ly8gcm90YXRpb25zIGFyZSBhcHBsaWVkIHRvIHRoZSBheGVzIGluIHRoZSBvcmRlciBzcGVjaWZpZWQgYnkgJ29yZGVyJ1xuXHRcdC8vIHJvdGF0aW9uIGJ5IGFuZ2xlICdhJyBpcyBhcHBsaWVkIGZpcnN0LCB0aGVuIGJ5IGFuZ2xlICdiJywgdGhlbiBieSBhbmdsZSAnYydcblx0XHQvLyBhbmdsZXMgYXJlIGluIHJhZGlhbnNcblx0XHRjb25zdCBjb3MgPSBNYXRoLmNvcztcblx0XHRjb25zdCBzaW4gPSBNYXRoLnNpbjtcblx0XHRjb25zdCBjMiA9IGNvcyhiIC8gMik7XG5cdFx0Y29uc3QgczIgPSBzaW4oYiAvIDIpO1xuXHRcdGNvbnN0IGMxMyA9IGNvcygoYSArIGMpIC8gMik7XG5cdFx0Y29uc3QgczEzID0gc2luKChhICsgYykgLyAyKTtcblx0XHRjb25zdCBjMV8zID0gY29zKChhIC0gYykgLyAyKTtcblx0XHRjb25zdCBzMV8zID0gc2luKChhIC0gYykgLyAyKTtcblx0XHRjb25zdCBjM18xID0gY29zKChjIC0gYSkgLyAyKTtcblx0XHRjb25zdCBzM18xID0gc2luKChjIC0gYSkgLyAyKTtcblxuXHRcdHN3aXRjaCAob3JkZXIpIHtcblx0XHRcdGNhc2UgJ1hZWCc6XG5cdFx0XHRcdHEuc2V0KGMyICogczEzLCBzMiAqIGMxXzMsIHMyICogczFfMywgYzIgKiBjMTMpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWVpZJzpcblx0XHRcdFx0cS5zZXQoczIgKiBzMV8zLCBjMiAqIHMxMywgczIgKiBjMV8zLCBjMiAqIGMxMyk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdaWFonOlxuXHRcdFx0XHRxLnNldChzMiAqIGMxXzMsIHMyICogczFfMywgYzIgKiBzMTMsIGMyICogYzEzKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1haWCc6XG5cdFx0XHRcdHEuc2V0KGMyICogczEzLCBzMiAqIHMzXzEsIHMyICogYzNfMSwgYzIgKiBjMTMpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWVhZJzpcblx0XHRcdFx0cS5zZXQoczIgKiBjM18xLCBjMiAqIHMxMywgczIgKiBzM18xLCBjMiAqIGMxMyk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdaWVonOlxuXHRcdFx0XHRxLnNldChzMiAqIHMzXzEsIHMyICogYzNfMSwgYzIgKiBzMTMsIGMyICogYzEzKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuTWF0aFV0aWxzOiAuc2V0UXVhdGVybmlvbkZyb21Qcm9wZXJFdWxlcigpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICcgKyBvcmRlcik7XG5cdFx0fVxuXHR9XG5cblx0dmFyIE1hdGhVdGlscyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0XHRfX3Byb3RvX186IG51bGwsXG5cdFx0REVHMlJBRDogREVHMlJBRCxcblx0XHRSQUQyREVHOiBSQUQyREVHLFxuXHRcdGdlbmVyYXRlVVVJRDogZ2VuZXJhdGVVVUlELFxuXHRcdGNsYW1wOiBjbGFtcCxcblx0XHRldWNsaWRlYW5Nb2R1bG86IGV1Y2xpZGVhbk1vZHVsbyxcblx0XHRtYXBMaW5lYXI6IG1hcExpbmVhcixcblx0XHRpbnZlcnNlTGVycDogaW52ZXJzZUxlcnAsXG5cdFx0bGVycDogbGVycCxcblx0XHRkYW1wOiBkYW1wLFxuXHRcdHBpbmdwb25nOiBwaW5ncG9uZyxcblx0XHRzbW9vdGhzdGVwOiBzbW9vdGhzdGVwLFxuXHRcdHNtb290aGVyc3RlcDogc21vb3RoZXJzdGVwLFxuXHRcdHJhbmRJbnQ6IHJhbmRJbnQsXG5cdFx0cmFuZEZsb2F0OiByYW5kRmxvYXQsXG5cdFx0cmFuZEZsb2F0U3ByZWFkOiByYW5kRmxvYXRTcHJlYWQsXG5cdFx0c2VlZGVkUmFuZG9tOiBzZWVkZWRSYW5kb20sXG5cdFx0ZGVnVG9SYWQ6IGRlZ1RvUmFkLFxuXHRcdHJhZFRvRGVnOiByYWRUb0RlZyxcblx0XHRpc1Bvd2VyT2ZUd286IGlzUG93ZXJPZlR3byxcblx0XHRjZWlsUG93ZXJPZlR3bzogY2VpbFBvd2VyT2ZUd28sXG5cdFx0Zmxvb3JQb3dlck9mVHdvOiBmbG9vclBvd2VyT2ZUd28sXG5cdFx0c2V0UXVhdGVybmlvbkZyb21Qcm9wZXJFdWxlcjogc2V0UXVhdGVybmlvbkZyb21Qcm9wZXJFdWxlclxuXHR9KTtcblxuXHRjbGFzcyBWZWN0b3IyIHtcblx0XHRjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDApIHtcblx0XHRcdHRoaXMueCA9IHg7XG5cdFx0XHR0aGlzLnkgPSB5O1xuXHRcdH1cblxuXHRcdGdldCB3aWR0aCgpIHtcblx0XHRcdHJldHVybiB0aGlzLng7XG5cdFx0fVxuXG5cdFx0c2V0IHdpZHRoKHZhbHVlKSB7XG5cdFx0XHR0aGlzLnggPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRnZXQgaGVpZ2h0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMueTtcblx0XHR9XG5cblx0XHRzZXQgaGVpZ2h0KHZhbHVlKSB7XG5cdFx0XHR0aGlzLnkgPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRzZXQoeCwgeSkge1xuXHRcdFx0dGhpcy54ID0geDtcblx0XHRcdHRoaXMueSA9IHk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRTY2FsYXIoc2NhbGFyKSB7XG5cdFx0XHR0aGlzLnggPSBzY2FsYXI7XG5cdFx0XHR0aGlzLnkgPSBzY2FsYXI7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRYKHgpIHtcblx0XHRcdHRoaXMueCA9IHg7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRZKHkpIHtcblx0XHRcdHRoaXMueSA9IHk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRDb21wb25lbnQoaW5kZXgsIHZhbHVlKSB7XG5cdFx0XHRzd2l0Y2ggKGluZGV4KSB7XG5cdFx0XHRcdGNhc2UgMDpcblx0XHRcdFx0XHR0aGlzLnggPSB2YWx1ZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0dGhpcy55ID0gdmFsdWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Z2V0Q29tcG9uZW50KGluZGV4KSB7XG5cdFx0XHRzd2l0Y2ggKGluZGV4KSB7XG5cdFx0XHRcdGNhc2UgMDpcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy54O1xuXG5cdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy55O1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y2xvbmUoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy54LCB0aGlzLnkpO1xuXHRcdH1cblxuXHRcdGNvcHkodikge1xuXHRcdFx0dGhpcy54ID0gdi54O1xuXHRcdFx0dGhpcy55ID0gdi55O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0YWRkKHYsIHcpIHtcblx0XHRcdGlmICh3ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5WZWN0b3IyOiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmFkZFZlY3RvcnModiwgdyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMueCArPSB2Lng7XG5cdFx0XHR0aGlzLnkgKz0gdi55O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0YWRkU2NhbGFyKHMpIHtcblx0XHRcdHRoaXMueCArPSBzO1xuXHRcdFx0dGhpcy55ICs9IHM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRhZGRWZWN0b3JzKGEsIGIpIHtcblx0XHRcdHRoaXMueCA9IGEueCArIGIueDtcblx0XHRcdHRoaXMueSA9IGEueSArIGIueTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGFkZFNjYWxlZFZlY3Rvcih2LCBzKSB7XG5cdFx0XHR0aGlzLnggKz0gdi54ICogcztcblx0XHRcdHRoaXMueSArPSB2LnkgKiBzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c3ViKHYsIHcpIHtcblx0XHRcdGlmICh3ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5WZWN0b3IyOiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnModiwgdyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0XHR0aGlzLnkgLT0gdi55O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c3ViU2NhbGFyKHMpIHtcblx0XHRcdHRoaXMueCAtPSBzO1xuXHRcdFx0dGhpcy55IC09IHM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzdWJWZWN0b3JzKGEsIGIpIHtcblx0XHRcdHRoaXMueCA9IGEueCAtIGIueDtcblx0XHRcdHRoaXMueSA9IGEueSAtIGIueTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG11bHRpcGx5KHYpIHtcblx0XHRcdHRoaXMueCAqPSB2Lng7XG5cdFx0XHR0aGlzLnkgKj0gdi55O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bXVsdGlwbHlTY2FsYXIoc2NhbGFyKSB7XG5cdFx0XHR0aGlzLnggKj0gc2NhbGFyO1xuXHRcdFx0dGhpcy55ICo9IHNjYWxhcjtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGRpdmlkZSh2KSB7XG5cdFx0XHR0aGlzLnggLz0gdi54O1xuXHRcdFx0dGhpcy55IC89IHYueTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGRpdmlkZVNjYWxhcihzY2FsYXIpIHtcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKDEgLyBzY2FsYXIpO1xuXHRcdH1cblxuXHRcdGFwcGx5TWF0cml4MyhtKSB7XG5cdFx0XHRjb25zdCB4ID0gdGhpcy54LFxuXHRcdFx0XHRcdFx0eSA9IHRoaXMueTtcblx0XHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXHRcdFx0dGhpcy54ID0gZVswXSAqIHggKyBlWzNdICogeSArIGVbNl07XG5cdFx0XHR0aGlzLnkgPSBlWzFdICogeCArIGVbNF0gKiB5ICsgZVs3XTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG1pbih2KSB7XG5cdFx0XHR0aGlzLnggPSBNYXRoLm1pbih0aGlzLngsIHYueCk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLm1pbih0aGlzLnksIHYueSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRtYXgodikge1xuXHRcdFx0dGhpcy54ID0gTWF0aC5tYXgodGhpcy54LCB2LngpO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5tYXgodGhpcy55LCB2LnkpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y2xhbXAobWluLCBtYXgpIHtcblx0XHRcdC8vIGFzc3VtZXMgbWluIDwgbWF4LCBjb21wb25lbnR3aXNlXG5cdFx0XHR0aGlzLnggPSBNYXRoLm1heChtaW4ueCwgTWF0aC5taW4obWF4LngsIHRoaXMueCkpO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5tYXgobWluLnksIE1hdGgubWluKG1heC55LCB0aGlzLnkpKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNsYW1wU2NhbGFyKG1pblZhbCwgbWF4VmFsKSB7XG5cdFx0XHR0aGlzLnggPSBNYXRoLm1heChtaW5WYWwsIE1hdGgubWluKG1heFZhbCwgdGhpcy54KSk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLm1heChtaW5WYWwsIE1hdGgubWluKG1heFZhbCwgdGhpcy55KSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbGFtcExlbmd0aChtaW4sIG1heCkge1xuXHRcdFx0Y29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblx0XHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhcihsZW5ndGggfHwgMSkubXVsdGlwbHlTY2FsYXIoTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIGxlbmd0aCkpKTtcblx0XHR9XG5cblx0XHRmbG9vcigpIHtcblx0XHRcdHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KTtcblx0XHRcdHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNlaWwoKSB7XG5cdFx0XHR0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcblx0XHRcdHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0cm91bmQoKSB7XG5cdFx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRyb3VuZFRvWmVybygpIHtcblx0XHRcdHRoaXMueCA9IHRoaXMueCA8IDAgPyBNYXRoLmNlaWwodGhpcy54KSA6IE1hdGguZmxvb3IodGhpcy54KTtcblx0XHRcdHRoaXMueSA9IHRoaXMueSA8IDAgPyBNYXRoLmNlaWwodGhpcy55KSA6IE1hdGguZmxvb3IodGhpcy55KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG5lZ2F0ZSgpIHtcblx0XHRcdHRoaXMueCA9IC10aGlzLng7XG5cdFx0XHR0aGlzLnkgPSAtdGhpcy55O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZG90KHYpIHtcblx0XHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2Lnk7XG5cdFx0fVxuXG5cdFx0Y3Jvc3Modikge1xuXHRcdFx0cmV0dXJuIHRoaXMueCAqIHYueSAtIHRoaXMueSAqIHYueDtcblx0XHR9XG5cblx0XHRsZW5ndGhTcSgpIHtcblx0XHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnk7XG5cdFx0fVxuXG5cdFx0bGVuZ3RoKCkge1xuXHRcdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkpO1xuXHRcdH1cblxuXHRcdG1hbmhhdHRhbkxlbmd0aCgpIHtcblx0XHRcdHJldHVybiBNYXRoLmFicyh0aGlzLngpICsgTWF0aC5hYnModGhpcy55KTtcblx0XHR9XG5cblx0XHRub3JtYWxpemUoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKSB8fCAxKTtcblx0XHR9XG5cblx0XHRhbmdsZSgpIHtcblx0XHRcdC8vIGNvbXB1dGVzIHRoZSBhbmdsZSBpbiByYWRpYW5zIHdpdGggcmVzcGVjdCB0byB0aGUgcG9zaXRpdmUgeC1heGlzXG5cdFx0XHRjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIoLXRoaXMueSwgLXRoaXMueCkgKyBNYXRoLlBJO1xuXHRcdFx0cmV0dXJuIGFuZ2xlO1xuXHRcdH1cblxuXHRcdGRpc3RhbmNlVG8odikge1xuXHRcdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKHYpKTtcblx0XHR9XG5cblx0XHRkaXN0YW5jZVRvU3F1YXJlZCh2KSB7XG5cdFx0XHRjb25zdCBkeCA9IHRoaXMueCAtIHYueCxcblx0XHRcdFx0XHRcdGR5ID0gdGhpcy55IC0gdi55O1xuXHRcdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuXHRcdH1cblxuXHRcdG1hbmhhdHRhbkRpc3RhbmNlVG8odikge1xuXHRcdFx0cmV0dXJuIE1hdGguYWJzKHRoaXMueCAtIHYueCkgKyBNYXRoLmFicyh0aGlzLnkgLSB2LnkpO1xuXHRcdH1cblxuXHRcdHNldExlbmd0aChsZW5ndGgpIHtcblx0XHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKGxlbmd0aCk7XG5cdFx0fVxuXG5cdFx0bGVycCh2LCBhbHBoYSkge1xuXHRcdFx0dGhpcy54ICs9ICh2LnggLSB0aGlzLngpICogYWxwaGE7XG5cdFx0XHR0aGlzLnkgKz0gKHYueSAtIHRoaXMueSkgKiBhbHBoYTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGxlcnBWZWN0b3JzKHYxLCB2MiwgYWxwaGEpIHtcblx0XHRcdHRoaXMueCA9IHYxLnggKyAodjIueCAtIHYxLngpICogYWxwaGE7XG5cdFx0XHR0aGlzLnkgPSB2MS55ICsgKHYyLnkgLSB2MS55KSAqIGFscGhhO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZXF1YWxzKHYpIHtcblx0XHRcdHJldHVybiB2LnggPT09IHRoaXMueCAmJiB2LnkgPT09IHRoaXMueTtcblx0XHR9XG5cblx0XHRmcm9tQXJyYXkoYXJyYXksIG9mZnNldCA9IDApIHtcblx0XHRcdHRoaXMueCA9IGFycmF5W29mZnNldF07XG5cdFx0XHR0aGlzLnkgPSBhcnJheVtvZmZzZXQgKyAxXTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRvQXJyYXkoYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCkge1xuXHRcdFx0YXJyYXlbb2Zmc2V0XSA9IHRoaXMueDtcblx0XHRcdGFycmF5W29mZnNldCArIDFdID0gdGhpcy55O1xuXHRcdFx0cmV0dXJuIGFycmF5O1xuXHRcdH1cblxuXHRcdGZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0KSB7XG5cdFx0XHRpZiAob2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5WZWN0b3IyOiBvZmZzZXQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIC5mcm9tQnVmZmVyQXR0cmlidXRlKCkuJyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5nZXRYKGluZGV4KTtcblx0XHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5nZXRZKGluZGV4KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHJvdGF0ZUFyb3VuZChjZW50ZXIsIGFuZ2xlKSB7XG5cdFx0XHRjb25zdCBjID0gTWF0aC5jb3MoYW5nbGUpLFxuXHRcdFx0XHRcdFx0cyA9IE1hdGguc2luKGFuZ2xlKTtcblx0XHRcdGNvbnN0IHggPSB0aGlzLnggLSBjZW50ZXIueDtcblx0XHRcdGNvbnN0IHkgPSB0aGlzLnkgLSBjZW50ZXIueTtcblx0XHRcdHRoaXMueCA9IHggKiBjIC0geSAqIHMgKyBjZW50ZXIueDtcblx0XHRcdHRoaXMueSA9IHggKiBzICsgeSAqIGMgKyBjZW50ZXIueTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHJhbmRvbSgpIHtcblx0XHRcdHRoaXMueCA9IE1hdGgucmFuZG9tKCk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLnJhbmRvbSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0KltTeW1ib2wuaXRlcmF0b3JdKCkge1xuXHRcdFx0eWllbGQgdGhpcy54O1xuXHRcdFx0eWllbGQgdGhpcy55O1xuXHRcdH1cblxuXHR9XG5cblx0VmVjdG9yMi5wcm90b3R5cGUuaXNWZWN0b3IyID0gdHJ1ZTtcblxuXHRjbGFzcyBNYXRyaXgzIHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHRoaXMuZWxlbWVudHMgPSBbMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMV07XG5cblx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5NYXRyaXgzOiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLicpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNldChuMTEsIG4xMiwgbjEzLCBuMjEsIG4yMiwgbjIzLCBuMzEsIG4zMiwgbjMzKSB7XG5cdFx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0XHR0ZVswXSA9IG4xMTtcblx0XHRcdHRlWzFdID0gbjIxO1xuXHRcdFx0dGVbMl0gPSBuMzE7XG5cdFx0XHR0ZVszXSA9IG4xMjtcblx0XHRcdHRlWzRdID0gbjIyO1xuXHRcdFx0dGVbNV0gPSBuMzI7XG5cdFx0XHR0ZVs2XSA9IG4xMztcblx0XHRcdHRlWzddID0gbjIzO1xuXHRcdFx0dGVbOF0gPSBuMzM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZGVudGl0eSgpIHtcblx0XHRcdHRoaXMuc2V0KDEsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29weShtKSB7XG5cdFx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0XHRjb25zdCBtZSA9IG0uZWxlbWVudHM7XG5cdFx0XHR0ZVswXSA9IG1lWzBdO1xuXHRcdFx0dGVbMV0gPSBtZVsxXTtcblx0XHRcdHRlWzJdID0gbWVbMl07XG5cdFx0XHR0ZVszXSA9IG1lWzNdO1xuXHRcdFx0dGVbNF0gPSBtZVs0XTtcblx0XHRcdHRlWzVdID0gbWVbNV07XG5cdFx0XHR0ZVs2XSA9IG1lWzZdO1xuXHRcdFx0dGVbN10gPSBtZVs3XTtcblx0XHRcdHRlWzhdID0gbWVbOF07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRleHRyYWN0QmFzaXMoeEF4aXMsIHlBeGlzLCB6QXhpcykge1xuXHRcdFx0eEF4aXMuc2V0RnJvbU1hdHJpeDNDb2x1bW4odGhpcywgMCk7XG5cdFx0XHR5QXhpcy5zZXRGcm9tTWF0cml4M0NvbHVtbih0aGlzLCAxKTtcblx0XHRcdHpBeGlzLnNldEZyb21NYXRyaXgzQ29sdW1uKHRoaXMsIDIpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0RnJvbU1hdHJpeDQobSkge1xuXHRcdFx0Y29uc3QgbWUgPSBtLmVsZW1lbnRzO1xuXHRcdFx0dGhpcy5zZXQobWVbMF0sIG1lWzRdLCBtZVs4XSwgbWVbMV0sIG1lWzVdLCBtZVs5XSwgbWVbMl0sIG1lWzZdLCBtZVsxMF0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bXVsdGlwbHkobSkge1xuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyh0aGlzLCBtKTtcblx0XHR9XG5cblx0XHRwcmVtdWx0aXBseShtKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKG0sIHRoaXMpO1xuXHRcdH1cblxuXHRcdG11bHRpcGx5TWF0cmljZXMoYSwgYikge1xuXHRcdFx0Y29uc3QgYWUgPSBhLmVsZW1lbnRzO1xuXHRcdFx0Y29uc3QgYmUgPSBiLmVsZW1lbnRzO1xuXHRcdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0Y29uc3QgYTExID0gYWVbMF0sXG5cdFx0XHRcdFx0XHRhMTIgPSBhZVszXSxcblx0XHRcdFx0XHRcdGExMyA9IGFlWzZdO1xuXHRcdFx0Y29uc3QgYTIxID0gYWVbMV0sXG5cdFx0XHRcdFx0XHRhMjIgPSBhZVs0XSxcblx0XHRcdFx0XHRcdGEyMyA9IGFlWzddO1xuXHRcdFx0Y29uc3QgYTMxID0gYWVbMl0sXG5cdFx0XHRcdFx0XHRhMzIgPSBhZVs1XSxcblx0XHRcdFx0XHRcdGEzMyA9IGFlWzhdO1xuXHRcdFx0Y29uc3QgYjExID0gYmVbMF0sXG5cdFx0XHRcdFx0XHRiMTIgPSBiZVszXSxcblx0XHRcdFx0XHRcdGIxMyA9IGJlWzZdO1xuXHRcdFx0Y29uc3QgYjIxID0gYmVbMV0sXG5cdFx0XHRcdFx0XHRiMjIgPSBiZVs0XSxcblx0XHRcdFx0XHRcdGIyMyA9IGJlWzddO1xuXHRcdFx0Y29uc3QgYjMxID0gYmVbMl0sXG5cdFx0XHRcdFx0XHRiMzIgPSBiZVs1XSxcblx0XHRcdFx0XHRcdGIzMyA9IGJlWzhdO1xuXHRcdFx0dGVbMF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzE7XG5cdFx0XHR0ZVszXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMjtcblx0XHRcdHRlWzZdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzO1xuXHRcdFx0dGVbMV0gPSBhMjEgKiBiMTEgKyBhMjIgKiBiMjEgKyBhMjMgKiBiMzE7XG5cdFx0XHR0ZVs0XSA9IGEyMSAqIGIxMiArIGEyMiAqIGIyMiArIGEyMyAqIGIzMjtcblx0XHRcdHRlWzddID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzO1xuXHRcdFx0dGVbMl0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzE7XG5cdFx0XHR0ZVs1XSA9IGEzMSAqIGIxMiArIGEzMiAqIGIyMiArIGEzMyAqIGIzMjtcblx0XHRcdHRlWzhdID0gYTMxICogYjEzICsgYTMyICogYjIzICsgYTMzICogYjMzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bXVsdGlwbHlTY2FsYXIocykge1xuXHRcdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0dGVbMF0gKj0gcztcblx0XHRcdHRlWzNdICo9IHM7XG5cdFx0XHR0ZVs2XSAqPSBzO1xuXHRcdFx0dGVbMV0gKj0gcztcblx0XHRcdHRlWzRdICo9IHM7XG5cdFx0XHR0ZVs3XSAqPSBzO1xuXHRcdFx0dGVbMl0gKj0gcztcblx0XHRcdHRlWzVdICo9IHM7XG5cdFx0XHR0ZVs4XSAqPSBzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZGV0ZXJtaW5hbnQoKSB7XG5cdFx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0XHRjb25zdCBhID0gdGVbMF0sXG5cdFx0XHRcdFx0XHRiID0gdGVbMV0sXG5cdFx0XHRcdFx0XHRjID0gdGVbMl0sXG5cdFx0XHRcdFx0XHRkID0gdGVbM10sXG5cdFx0XHRcdFx0XHRlID0gdGVbNF0sXG5cdFx0XHRcdFx0XHRmID0gdGVbNV0sXG5cdFx0XHRcdFx0XHRnID0gdGVbNl0sXG5cdFx0XHRcdFx0XHRoID0gdGVbN10sXG5cdFx0XHRcdFx0XHRpID0gdGVbOF07XG5cdFx0XHRyZXR1cm4gYSAqIGUgKiBpIC0gYSAqIGYgKiBoIC0gYiAqIGQgKiBpICsgYiAqIGYgKiBnICsgYyAqIGQgKiBoIC0gYyAqIGUgKiBnO1xuXHRcdH1cblxuXHRcdGludmVydCgpIHtcblx0XHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cyxcblx0XHRcdFx0XHRcdG4xMSA9IHRlWzBdLFxuXHRcdFx0XHRcdFx0bjIxID0gdGVbMV0sXG5cdFx0XHRcdFx0XHRuMzEgPSB0ZVsyXSxcblx0XHRcdFx0XHRcdG4xMiA9IHRlWzNdLFxuXHRcdFx0XHRcdFx0bjIyID0gdGVbNF0sXG5cdFx0XHRcdFx0XHRuMzIgPSB0ZVs1XSxcblx0XHRcdFx0XHRcdG4xMyA9IHRlWzZdLFxuXHRcdFx0XHRcdFx0bjIzID0gdGVbN10sXG5cdFx0XHRcdFx0XHRuMzMgPSB0ZVs4XSxcblx0XHRcdFx0XHRcdHQxMSA9IG4zMyAqIG4yMiAtIG4zMiAqIG4yMyxcblx0XHRcdFx0XHRcdHQxMiA9IG4zMiAqIG4xMyAtIG4zMyAqIG4xMixcblx0XHRcdFx0XHRcdHQxMyA9IG4yMyAqIG4xMiAtIG4yMiAqIG4xMyxcblx0XHRcdFx0XHRcdGRldCA9IG4xMSAqIHQxMSArIG4yMSAqIHQxMiArIG4zMSAqIHQxMztcblx0XHRcdGlmIChkZXQgPT09IDApIHJldHVybiB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcblx0XHRcdGNvbnN0IGRldEludiA9IDEgLyBkZXQ7XG5cdFx0XHR0ZVswXSA9IHQxMSAqIGRldEludjtcblx0XHRcdHRlWzFdID0gKG4zMSAqIG4yMyAtIG4zMyAqIG4yMSkgKiBkZXRJbnY7XG5cdFx0XHR0ZVsyXSA9IChuMzIgKiBuMjEgLSBuMzEgKiBuMjIpICogZGV0SW52O1xuXHRcdFx0dGVbM10gPSB0MTIgKiBkZXRJbnY7XG5cdFx0XHR0ZVs0XSA9IChuMzMgKiBuMTEgLSBuMzEgKiBuMTMpICogZGV0SW52O1xuXHRcdFx0dGVbNV0gPSAobjMxICogbjEyIC0gbjMyICogbjExKSAqIGRldEludjtcblx0XHRcdHRlWzZdID0gdDEzICogZGV0SW52O1xuXHRcdFx0dGVbN10gPSAobjIxICogbjEzIC0gbjIzICogbjExKSAqIGRldEludjtcblx0XHRcdHRlWzhdID0gKG4yMiAqIG4xMSAtIG4yMSAqIG4xMikgKiBkZXRJbnY7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0cmFuc3Bvc2UoKSB7XG5cdFx0XHRsZXQgdG1wO1xuXHRcdFx0Y29uc3QgbSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0XHR0bXAgPSBtWzFdO1xuXHRcdFx0bVsxXSA9IG1bM107XG5cdFx0XHRtWzNdID0gdG1wO1xuXHRcdFx0dG1wID0gbVsyXTtcblx0XHRcdG1bMl0gPSBtWzZdO1xuXHRcdFx0bVs2XSA9IHRtcDtcblx0XHRcdHRtcCA9IG1bNV07XG5cdFx0XHRtWzVdID0gbVs3XTtcblx0XHRcdG1bN10gPSB0bXA7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRnZXROb3JtYWxNYXRyaXgobWF0cml4NCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeDQobWF0cml4NCkuaW52ZXJ0KCkudHJhbnNwb3NlKCk7XG5cdFx0fVxuXG5cdFx0dHJhbnNwb3NlSW50b0FycmF5KHIpIHtcblx0XHRcdGNvbnN0IG0gPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0clswXSA9IG1bMF07XG5cdFx0XHRyWzFdID0gbVszXTtcblx0XHRcdHJbMl0gPSBtWzZdO1xuXHRcdFx0clszXSA9IG1bMV07XG5cdFx0XHRyWzRdID0gbVs0XTtcblx0XHRcdHJbNV0gPSBtWzddO1xuXHRcdFx0cls2XSA9IG1bMl07XG5cdFx0XHRyWzddID0gbVs1XTtcblx0XHRcdHJbOF0gPSBtWzhdO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0VXZUcmFuc2Zvcm0odHgsIHR5LCBzeCwgc3ksIHJvdGF0aW9uLCBjeCwgY3kpIHtcblx0XHRcdGNvbnN0IGMgPSBNYXRoLmNvcyhyb3RhdGlvbik7XG5cdFx0XHRjb25zdCBzID0gTWF0aC5zaW4ocm90YXRpb24pO1xuXHRcdFx0dGhpcy5zZXQoc3ggKiBjLCBzeCAqIHMsIC1zeCAqIChjICogY3ggKyBzICogY3kpICsgY3ggKyB0eCwgLXN5ICogcywgc3kgKiBjLCAtc3kgKiAoLXMgKiBjeCArIGMgKiBjeSkgKyBjeSArIHR5LCAwLCAwLCAxKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNjYWxlKHN4LCBzeSkge1xuXHRcdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0dGVbMF0gKj0gc3g7XG5cdFx0XHR0ZVszXSAqPSBzeDtcblx0XHRcdHRlWzZdICo9IHN4O1xuXHRcdFx0dGVbMV0gKj0gc3k7XG5cdFx0XHR0ZVs0XSAqPSBzeTtcblx0XHRcdHRlWzddICo9IHN5O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0cm90YXRlKHRoZXRhKSB7XG5cdFx0XHRjb25zdCBjID0gTWF0aC5jb3ModGhldGEpO1xuXHRcdFx0Y29uc3QgcyA9IE1hdGguc2luKHRoZXRhKTtcblx0XHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdGNvbnN0IGExMSA9IHRlWzBdLFxuXHRcdFx0XHRcdFx0YTEyID0gdGVbM10sXG5cdFx0XHRcdFx0XHRhMTMgPSB0ZVs2XTtcblx0XHRcdGNvbnN0IGEyMSA9IHRlWzFdLFxuXHRcdFx0XHRcdFx0YTIyID0gdGVbNF0sXG5cdFx0XHRcdFx0XHRhMjMgPSB0ZVs3XTtcblx0XHRcdHRlWzBdID0gYyAqIGExMSArIHMgKiBhMjE7XG5cdFx0XHR0ZVszXSA9IGMgKiBhMTIgKyBzICogYTIyO1xuXHRcdFx0dGVbNl0gPSBjICogYTEzICsgcyAqIGEyMztcblx0XHRcdHRlWzFdID0gLXMgKiBhMTEgKyBjICogYTIxO1xuXHRcdFx0dGVbNF0gPSAtcyAqIGExMiArIGMgKiBhMjI7XG5cdFx0XHR0ZVs3XSA9IC1zICogYTEzICsgYyAqIGEyMztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRyYW5zbGF0ZSh0eCwgdHkpIHtcblx0XHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdHRlWzBdICs9IHR4ICogdGVbMl07XG5cdFx0XHR0ZVszXSArPSB0eCAqIHRlWzVdO1xuXHRcdFx0dGVbNl0gKz0gdHggKiB0ZVs4XTtcblx0XHRcdHRlWzFdICs9IHR5ICogdGVbMl07XG5cdFx0XHR0ZVs0XSArPSB0eSAqIHRlWzVdO1xuXHRcdFx0dGVbN10gKz0gdHkgKiB0ZVs4XTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGVxdWFscyhtYXRyaXgpIHtcblx0XHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdGNvbnN0IG1lID0gbWF0cml4LmVsZW1lbnRzO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuXHRcdFx0XHRpZiAodGVbaV0gIT09IG1lW2ldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGZyb21BcnJheShhcnJheSwgb2Zmc2V0ID0gMCkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50c1tpXSA9IGFycmF5W2kgKyBvZmZzZXRdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0b0FycmF5KGFycmF5ID0gW10sIG9mZnNldCA9IDApIHtcblx0XHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdGFycmF5W29mZnNldF0gPSB0ZVswXTtcblx0XHRcdGFycmF5W29mZnNldCArIDFdID0gdGVbMV07XG5cdFx0XHRhcnJheVtvZmZzZXQgKyAyXSA9IHRlWzJdO1xuXHRcdFx0YXJyYXlbb2Zmc2V0ICsgM10gPSB0ZVszXTtcblx0XHRcdGFycmF5W29mZnNldCArIDRdID0gdGVbNF07XG5cdFx0XHRhcnJheVtvZmZzZXQgKyA1XSA9IHRlWzVdO1xuXHRcdFx0YXJyYXlbb2Zmc2V0ICsgNl0gPSB0ZVs2XTtcblx0XHRcdGFycmF5W29mZnNldCArIDddID0gdGVbN107XG5cdFx0XHRhcnJheVtvZmZzZXQgKyA4XSA9IHRlWzhdO1xuXHRcdFx0cmV0dXJuIGFycmF5O1xuXHRcdH1cblxuXHRcdGNsb25lKCkge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuZnJvbUFycmF5KHRoaXMuZWxlbWVudHMpO1xuXHRcdH1cblxuXHR9XG5cblx0TWF0cml4My5wcm90b3R5cGUuaXNNYXRyaXgzID0gdHJ1ZTtcblxuXHRmdW5jdGlvbiBhcnJheU1heChhcnJheSkge1xuXHRcdGlmIChhcnJheS5sZW5ndGggPT09IDApIHJldHVybiAtSW5maW5pdHk7XG5cdFx0bGV0IG1heCA9IGFycmF5WzBdO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDEsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcblx0XHRcdGlmIChhcnJheVtpXSA+IG1heCkgbWF4ID0gYXJyYXlbaV07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1heDtcblx0fVxuXG5cdGNvbnN0IFRZUEVEX0FSUkFZUyA9IHtcblx0XHRJbnQ4QXJyYXk6IEludDhBcnJheSxcblx0XHRVaW50OEFycmF5OiBVaW50OEFycmF5LFxuXHRcdFVpbnQ4Q2xhbXBlZEFycmF5OiBVaW50OENsYW1wZWRBcnJheSxcblx0XHRJbnQxNkFycmF5OiBJbnQxNkFycmF5LFxuXHRcdFVpbnQxNkFycmF5OiBVaW50MTZBcnJheSxcblx0XHRJbnQzMkFycmF5OiBJbnQzMkFycmF5LFxuXHRcdFVpbnQzMkFycmF5OiBVaW50MzJBcnJheSxcblx0XHRGbG9hdDMyQXJyYXk6IEZsb2F0MzJBcnJheSxcblx0XHRGbG9hdDY0QXJyYXk6IEZsb2F0NjRBcnJheVxuXHR9O1xuXG5cdGZ1bmN0aW9uIGdldFR5cGVkQXJyYXkodHlwZSwgYnVmZmVyKSB7XG5cdFx0cmV0dXJuIG5ldyBUWVBFRF9BUlJBWVNbdHlwZV0oYnVmZmVyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyhuYW1lKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsIG5hbWUpO1xuXHR9XG5cdC8qKlxuXHRcdCogY3lyYjUzIGhhc2ggZm9yIHN0cmluZyBmcm9tOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTIxNzE0ODBcblx0XHQqXG5cdFx0KiBQdWJsaWMgRG9tYWluLCBAYnJ5YyAtIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vdXNlcnMvODE1NjgwL2JyeWNcblx0XHQqXG5cdFx0KiBJdCBpcyByb3VnaGx5IHNpbWlsYXIgdG8gdGhlIHdlbGwta25vd24gTXVybXVySGFzaC94eEhhc2ggYWxnb3JpdGhtcy4gSXQgdXNlcyBhIGNvbWJpbmF0aW9uXG5cdFx0KiBvZiBtdWx0aXBsaWNhdGlvbiBhbmQgWG9yc2hpZnQgdG8gZ2VuZXJhdGUgdGhlIGhhc2gsIGJ1dCBub3QgYXMgdGhvcm91Z2guIEFzIGEgcmVzdWx0IGl0J3Ncblx0XHQqIGZhc3RlciB0aGFuIGVpdGhlciB3b3VsZCBiZSBpbiBKYXZhU2NyaXB0IGFuZCBzaWduaWZpY2FudGx5IHNpbXBsZXIgdG8gaW1wbGVtZW50LiBLZWVwIGluXG5cdFx0KiBtaW5kIHRoaXMgaXMgbm90IGEgc2VjdXJlIGFsZ29yaXRobSwgaWYgcHJpdmFjeS9zZWN1cml0eSBpcyBhIGNvbmNlcm4sIHRoaXMgaXMgbm90IGZvciB5b3UuXG5cdFx0KlxuXHRcdCogQHBhcmFtIHtzdHJpbmd9IHN0clxuXHRcdCogQHBhcmFtIHtudW1iZXJ9IHNlZWQsIGRlZmF1bHQgMFxuXHRcdCogQHJldHVybnMgbnVtYmVyXG5cdFx0Ki9cblxuXG5cdGZ1bmN0aW9uIGhhc2hTdHJpbmcoc3RyLCBzZWVkID0gMCkge1xuXHRcdGxldCBoMSA9IDB4ZGVhZGJlZWYgXiBzZWVkLFxuXHRcdFx0XHRoMiA9IDB4NDFjNmNlNTcgXiBzZWVkO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDAsIGNoOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjaCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aDEgPSBNYXRoLmltdWwoaDEgXiBjaCwgMjY1NDQzNTc2MSk7XG5cdFx0XHRoMiA9IE1hdGguaW11bChoMiBeIGNoLCAxNTk3MzM0Njc3KTtcblx0XHR9XG5cblx0XHRoMSA9IE1hdGguaW11bChoMSBeIGgxID4+PiAxNiwgMjI0NjgyMjUwNykgXiBNYXRoLmltdWwoaDIgXiBoMiA+Pj4gMTMsIDMyNjY0ODk5MDkpO1xuXHRcdGgyID0gTWF0aC5pbXVsKGgyIF4gaDIgPj4+IDE2LCAyMjQ2ODIyNTA3KSBeIE1hdGguaW11bChoMSBeIGgxID4+PiAxMywgMzI2NjQ4OTkwOSk7XG5cdFx0cmV0dXJuIDQyOTQ5NjcyOTYgKiAoMjA5NzE1MSAmIGgyKSArIChoMSA+Pj4gMCk7XG5cdH1cblxuXHRsZXQgX2NhbnZhcztcblxuXHRjbGFzcyBJbWFnZVV0aWxzIHtcblx0XHRzdGF0aWMgZ2V0RGF0YVVSTChpbWFnZSkge1xuXHRcdFx0aWYgKC9eZGF0YTovaS50ZXN0KGltYWdlLnNyYykpIHtcblx0XHRcdFx0cmV0dXJuIGltYWdlLnNyYztcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCA9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRyZXR1cm4gaW1hZ2Uuc3JjO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgY2FudmFzO1xuXG5cdFx0XHRpZiAoaW1hZ2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuXHRcdFx0XHRjYW52YXMgPSBpbWFnZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChfY2FudmFzID09PSB1bmRlZmluZWQpIF9jYW52YXMgPSBjcmVhdGVFbGVtZW50TlMoJ2NhbnZhcycpO1xuXHRcdFx0XHRfY2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XG5cdFx0XHRcdF9jYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuXG5cdFx0XHRcdGNvbnN0IGNvbnRleHQgPSBfY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cblx0XHRcdFx0aWYgKGltYWdlIGluc3RhbmNlb2YgSW1hZ2VEYXRhKSB7XG5cdFx0XHRcdFx0Y29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2UsIDAsIDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbnZhcyA9IF9jYW52YXM7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjYW52YXMud2lkdGggPiAyMDQ4IHx8IGNhbnZhcy5oZWlnaHQgPiAyMDQ4KSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuSW1hZ2VVdGlscy5nZXREYXRhVVJMOiBJbWFnZSBjb252ZXJ0ZWQgdG8ganBnIGZvciBwZXJmb3JtYW5jZSByZWFzb25zJywgaW1hZ2UpO1xuXHRcdFx0XHRyZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIDAuNik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH1cblxuXHRsZXQgdGV4dHVyZUlkID0gMDtcblxuXHRjbGFzcyBUZXh0dXJlIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcblx0XHRjb25zdHJ1Y3RvcihpbWFnZSA9IFRleHR1cmUuREVGQVVMVF9JTUFHRSwgbWFwcGluZyA9IFRleHR1cmUuREVGQVVMVF9NQVBQSU5HLCB3cmFwUyA9IENsYW1wVG9FZGdlV3JhcHBpbmcsIHdyYXBUID0gQ2xhbXBUb0VkZ2VXcmFwcGluZywgbWFnRmlsdGVyID0gTGluZWFyRmlsdGVyLCBtaW5GaWx0ZXIgPSBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIsIGZvcm1hdCA9IFJHQkFGb3JtYXQsIHR5cGUgPSBVbnNpZ25lZEJ5dGVUeXBlLCBhbmlzb3Ryb3B5ID0gMSwgZW5jb2RpbmcgPSBMaW5lYXJFbmNvZGluZykge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaWQnLCB7XG5cdFx0XHRcdHZhbHVlOiB0ZXh0dXJlSWQrK1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLnV1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcblx0XHRcdHRoaXMubmFtZSA9ICcnO1xuXHRcdFx0dGhpcy5pbWFnZSA9IGltYWdlO1xuXHRcdFx0dGhpcy5taXBtYXBzID0gW107XG5cdFx0XHR0aGlzLm1hcHBpbmcgPSBtYXBwaW5nO1xuXHRcdFx0dGhpcy53cmFwUyA9IHdyYXBTO1xuXHRcdFx0dGhpcy53cmFwVCA9IHdyYXBUO1xuXHRcdFx0dGhpcy5tYWdGaWx0ZXIgPSBtYWdGaWx0ZXI7XG5cdFx0XHR0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlcjtcblx0XHRcdHRoaXMuYW5pc290cm9weSA9IGFuaXNvdHJvcHk7XG5cdFx0XHR0aGlzLmZvcm1hdCA9IGZvcm1hdDtcblx0XHRcdHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBudWxsO1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHRcdHRoaXMub2Zmc2V0ID0gbmV3IFZlY3RvcjIoMCwgMCk7XG5cdFx0XHR0aGlzLnJlcGVhdCA9IG5ldyBWZWN0b3IyKDEsIDEpO1xuXHRcdFx0dGhpcy5jZW50ZXIgPSBuZXcgVmVjdG9yMigwLCAwKTtcblx0XHRcdHRoaXMucm90YXRpb24gPSAwO1xuXHRcdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcblx0XHRcdHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDMoKTtcblx0XHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gdHJ1ZTtcblx0XHRcdHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5mbGlwWSA9IHRydWU7XG5cdFx0XHR0aGlzLnVucGFja0FsaWdubWVudCA9IDQ7IC8vIHZhbGlkIHZhbHVlczogMSwgMiwgNCwgOCAoc2VlIGh0dHA6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsZXMvc2RrL2RvY3MvbWFuL3hodG1sL2dsUGl4ZWxTdG9yZWkueG1sKVxuXHRcdFx0Ly8gVmFsdWVzIG9mIGVuY29kaW5nICE9PSBUSFJFRS5MaW5lYXJFbmNvZGluZyBvbmx5IHN1cHBvcnRlZCBvbiBtYXAsIGVudk1hcCBhbmQgZW1pc3NpdmVNYXAuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gQWxzbyBjaGFuZ2luZyB0aGUgZW5jb2RpbmcgYWZ0ZXIgYWxyZWFkeSB1c2VkIGJ5IGEgTWF0ZXJpYWwgd2lsbCBub3QgYXV0b21hdGljYWxseSBtYWtlIHRoZSBNYXRlcmlhbFxuXHRcdFx0Ly8gdXBkYXRlLiBZb3UgbmVlZCB0byBleHBsaWNpdGx5IGNhbGwgTWF0ZXJpYWwubmVlZHNVcGRhdGUgdG8gdHJpZ2dlciBpdCB0byByZWNvbXBpbGUuXG5cblx0XHRcdHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcblx0XHRcdHRoaXMudXNlckRhdGEgPSB7fTtcblx0XHRcdHRoaXMudmVyc2lvbiA9IDA7XG5cdFx0XHR0aGlzLm9uVXBkYXRlID0gbnVsbDtcblx0XHRcdHRoaXMuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dXBkYXRlTWF0cml4KCkge1xuXHRcdFx0dGhpcy5tYXRyaXguc2V0VXZUcmFuc2Zvcm0odGhpcy5vZmZzZXQueCwgdGhpcy5vZmZzZXQueSwgdGhpcy5yZXBlYXQueCwgdGhpcy5yZXBlYXQueSwgdGhpcy5yb3RhdGlvbiwgdGhpcy5jZW50ZXIueCwgdGhpcy5jZW50ZXIueSk7XG5cdFx0fVxuXG5cdFx0Y2xvbmUoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblx0XHRcdHRoaXMuaW1hZ2UgPSBzb3VyY2UuaW1hZ2U7XG5cdFx0XHR0aGlzLm1pcG1hcHMgPSBzb3VyY2UubWlwbWFwcy5zbGljZSgwKTtcblx0XHRcdHRoaXMubWFwcGluZyA9IHNvdXJjZS5tYXBwaW5nO1xuXHRcdFx0dGhpcy53cmFwUyA9IHNvdXJjZS53cmFwUztcblx0XHRcdHRoaXMud3JhcFQgPSBzb3VyY2Uud3JhcFQ7XG5cdFx0XHR0aGlzLm1hZ0ZpbHRlciA9IHNvdXJjZS5tYWdGaWx0ZXI7XG5cdFx0XHR0aGlzLm1pbkZpbHRlciA9IHNvdXJjZS5taW5GaWx0ZXI7XG5cdFx0XHR0aGlzLmFuaXNvdHJvcHkgPSBzb3VyY2UuYW5pc290cm9weTtcblx0XHRcdHRoaXMuZm9ybWF0ID0gc291cmNlLmZvcm1hdDtcblx0XHRcdHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBzb3VyY2UuaW50ZXJuYWxGb3JtYXQ7XG5cdFx0XHR0aGlzLnR5cGUgPSBzb3VyY2UudHlwZTtcblx0XHRcdHRoaXMub2Zmc2V0LmNvcHkoc291cmNlLm9mZnNldCk7XG5cdFx0XHR0aGlzLnJlcGVhdC5jb3B5KHNvdXJjZS5yZXBlYXQpO1xuXHRcdFx0dGhpcy5jZW50ZXIuY29weShzb3VyY2UuY2VudGVyKTtcblx0XHRcdHRoaXMucm90YXRpb24gPSBzb3VyY2Uucm90YXRpb247XG5cdFx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBzb3VyY2UubWF0cml4QXV0b1VwZGF0ZTtcblx0XHRcdHRoaXMubWF0cml4LmNvcHkoc291cmNlLm1hdHJpeCk7XG5cdFx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IHNvdXJjZS5nZW5lcmF0ZU1pcG1hcHM7XG5cdFx0XHR0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBzb3VyY2UucHJlbXVsdGlwbHlBbHBoYTtcblx0XHRcdHRoaXMuZmxpcFkgPSBzb3VyY2UuZmxpcFk7XG5cdFx0XHR0aGlzLnVucGFja0FsaWdubWVudCA9IHNvdXJjZS51bnBhY2tBbGlnbm1lbnQ7XG5cdFx0XHR0aGlzLmVuY29kaW5nID0gc291cmNlLmVuY29kaW5nO1xuXHRcdFx0dGhpcy51c2VyRGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc291cmNlLnVzZXJEYXRhKSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0b0pTT04obWV0YSkge1xuXHRcdFx0Y29uc3QgaXNSb290T2JqZWN0ID0gbWV0YSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXRhID09PSAnc3RyaW5nJztcblxuXHRcdFx0aWYgKCFpc1Jvb3RPYmplY3QgJiYgbWV0YS50ZXh0dXJlc1t0aGlzLnV1aWRdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmV0dXJuIG1ldGEudGV4dHVyZXNbdGhpcy51dWlkXTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgb3V0cHV0ID0ge1xuXHRcdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHRcdHZlcnNpb246IDQuNSxcblx0XHRcdFx0XHR0eXBlOiAnVGV4dHVyZScsXG5cdFx0XHRcdFx0Z2VuZXJhdG9yOiAnVGV4dHVyZS50b0pTT04nXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHV1aWQ6IHRoaXMudXVpZCxcblx0XHRcdFx0bmFtZTogdGhpcy5uYW1lLFxuXHRcdFx0XHRtYXBwaW5nOiB0aGlzLm1hcHBpbmcsXG5cdFx0XHRcdHJlcGVhdDogW3RoaXMucmVwZWF0LngsIHRoaXMucmVwZWF0LnldLFxuXHRcdFx0XHRvZmZzZXQ6IFt0aGlzLm9mZnNldC54LCB0aGlzLm9mZnNldC55XSxcblx0XHRcdFx0Y2VudGVyOiBbdGhpcy5jZW50ZXIueCwgdGhpcy5jZW50ZXIueV0sXG5cdFx0XHRcdHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxuXHRcdFx0XHR3cmFwOiBbdGhpcy53cmFwUywgdGhpcy53cmFwVF0sXG5cdFx0XHRcdGZvcm1hdDogdGhpcy5mb3JtYXQsXG5cdFx0XHRcdHR5cGU6IHRoaXMudHlwZSxcblx0XHRcdFx0ZW5jb2Rpbmc6IHRoaXMuZW5jb2RpbmcsXG5cdFx0XHRcdG1pbkZpbHRlcjogdGhpcy5taW5GaWx0ZXIsXG5cdFx0XHRcdG1hZ0ZpbHRlcjogdGhpcy5tYWdGaWx0ZXIsXG5cdFx0XHRcdGFuaXNvdHJvcHk6IHRoaXMuYW5pc290cm9weSxcblx0XHRcdFx0ZmxpcFk6IHRoaXMuZmxpcFksXG5cdFx0XHRcdHByZW11bHRpcGx5QWxwaGE6IHRoaXMucHJlbXVsdGlwbHlBbHBoYSxcblx0XHRcdFx0dW5wYWNrQWxpZ25tZW50OiB0aGlzLnVucGFja0FsaWdubWVudFxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKHRoaXMuaW1hZ2UgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQvLyBUT0RPOiBNb3ZlIHRvIFRIUkVFLkltYWdlXG5cdFx0XHRcdGNvbnN0IGltYWdlID0gdGhpcy5pbWFnZTtcblxuXHRcdFx0XHRpZiAoaW1hZ2UudXVpZCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0aW1hZ2UudXVpZCA9IGdlbmVyYXRlVVVJRCgpOyAvLyBVR0hcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghaXNSb290T2JqZWN0ICYmIG1ldGEuaW1hZ2VzW2ltYWdlLnV1aWRdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRsZXQgdXJsO1xuXG5cdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoaW1hZ2UpKSB7XG5cdFx0XHRcdFx0XHQvLyBwcm9jZXNzIGFycmF5IG9mIGltYWdlcyBlLmcuIEN1YmVUZXh0dXJlXG5cdFx0XHRcdFx0XHR1cmwgPSBbXTtcblxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBpbWFnZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0Ly8gY2hlY2sgY3ViZSB0ZXh0dXJlIHdpdGggZGF0YSB0ZXh0dXJlc1xuXHRcdFx0XHRcdFx0XHRpZiAoaW1hZ2VbaV0uaXNEYXRhVGV4dHVyZSkge1xuXHRcdFx0XHRcdFx0XHRcdHVybC5wdXNoKHNlcmlhbGl6ZUltYWdlKGltYWdlW2ldLmltYWdlKSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dXJsLnB1c2goc2VyaWFsaXplSW1hZ2UoaW1hZ2VbaV0pKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBwcm9jZXNzIHNpbmdsZSBpbWFnZVxuXHRcdFx0XHRcdFx0dXJsID0gc2VyaWFsaXplSW1hZ2UoaW1hZ2UpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG1ldGEuaW1hZ2VzW2ltYWdlLnV1aWRdID0ge1xuXHRcdFx0XHRcdFx0dXVpZDogaW1hZ2UudXVpZCxcblx0XHRcdFx0XHRcdHVybDogdXJsXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG91dHB1dC5pbWFnZSA9IGltYWdlLnV1aWQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChKU09OLnN0cmluZ2lmeSh0aGlzLnVzZXJEYXRhKSAhPT0gJ3t9Jykgb3V0cHV0LnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcblxuXHRcdFx0aWYgKCFpc1Jvb3RPYmplY3QpIHtcblx0XHRcdFx0bWV0YS50ZXh0dXJlc1t0aGlzLnV1aWRdID0gb3V0cHV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH1cblxuXHRcdGRpc3Bvc2UoKSB7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoe1xuXHRcdFx0XHR0eXBlOiAnZGlzcG9zZSdcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHRyYW5zZm9ybVV2KHV2KSB7XG5cdFx0XHRpZiAodGhpcy5tYXBwaW5nICE9PSBVVk1hcHBpbmcpIHJldHVybiB1djtcblx0XHRcdHV2LmFwcGx5TWF0cml4Myh0aGlzLm1hdHJpeCk7XG5cblx0XHRcdGlmICh1di54IDwgMCB8fCB1di54ID4gMSkge1xuXHRcdFx0XHRzd2l0Y2ggKHRoaXMud3JhcFMpIHtcblx0XHRcdFx0XHRjYXNlIFJlcGVhdFdyYXBwaW5nOlxuXHRcdFx0XHRcdFx0dXYueCA9IHV2LnggLSBNYXRoLmZsb29yKHV2LngpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIENsYW1wVG9FZGdlV3JhcHBpbmc6XG5cdFx0XHRcdFx0XHR1di54ID0gdXYueCA8IDAgPyAwIDogMTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nOlxuXHRcdFx0XHRcdFx0aWYgKE1hdGguYWJzKE1hdGguZmxvb3IodXYueCkgJSAyKSA9PT0gMSkge1xuXHRcdFx0XHRcdFx0XHR1di54ID0gTWF0aC5jZWlsKHV2LngpIC0gdXYueDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHV2LnggPSB1di54IC0gTWF0aC5mbG9vcih1di54KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHV2LnkgPCAwIHx8IHV2LnkgPiAxKSB7XG5cdFx0XHRcdHN3aXRjaCAodGhpcy53cmFwVCkge1xuXHRcdFx0XHRcdGNhc2UgUmVwZWF0V3JhcHBpbmc6XG5cdFx0XHRcdFx0XHR1di55ID0gdXYueSAtIE1hdGguZmxvb3IodXYueSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgQ2xhbXBUb0VkZ2VXcmFwcGluZzpcblx0XHRcdFx0XHRcdHV2LnkgPSB1di55IDwgMCA/IDAgOiAxO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc6XG5cdFx0XHRcdFx0XHRpZiAoTWF0aC5hYnMoTWF0aC5mbG9vcih1di55KSAlIDIpID09PSAxKSB7XG5cdFx0XHRcdFx0XHRcdHV2LnkgPSBNYXRoLmNlaWwodXYueSkgLSB1di55O1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dXYueSA9IHV2LnkgLSBNYXRoLmZsb29yKHV2LnkpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5mbGlwWSkge1xuXHRcdFx0XHR1di55ID0gMSAtIHV2Lnk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1djtcblx0XHR9XG5cblx0XHRzZXQgbmVlZHNVcGRhdGUodmFsdWUpIHtcblx0XHRcdGlmICh2YWx1ZSA9PT0gdHJ1ZSkgdGhpcy52ZXJzaW9uKys7XG5cdFx0fVxuXG5cdH1cblxuXHRUZXh0dXJlLkRFRkFVTFRfSU1BR0UgPSB1bmRlZmluZWQ7XG5cdFRleHR1cmUuREVGQVVMVF9NQVBQSU5HID0gVVZNYXBwaW5nO1xuXHRUZXh0dXJlLnByb3RvdHlwZS5pc1RleHR1cmUgPSB0cnVlO1xuXG5cdGZ1bmN0aW9uIHNlcmlhbGl6ZUltYWdlKGltYWdlKSB7XG5cdFx0aWYgKHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgfHwgdHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50IHx8IHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCkge1xuXHRcdFx0Ly8gZGVmYXVsdCBpbWFnZXNcblx0XHRcdHJldHVybiBJbWFnZVV0aWxzLmdldERhdGFVUkwoaW1hZ2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoaW1hZ2UuZGF0YSkge1xuXHRcdFx0XHQvLyBpbWFnZXMgb2YgRGF0YVRleHR1cmVcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpbWFnZS5kYXRhKSxcblx0XHRcdFx0XHR3aWR0aDogaW1hZ2Uud2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiBpbWFnZS5oZWlnaHQsXG5cdFx0XHRcdFx0dHlwZTogaW1hZ2UuZGF0YS5jb25zdHJ1Y3Rvci5uYW1lXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlRleHR1cmU6IFVuYWJsZSB0byBzZXJpYWxpemUgVGV4dHVyZS4nKTtcblx0XHRcdFx0cmV0dXJuIHt9O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGNsYXNzIFZlY3RvcjQge1xuXHRcdGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgeiA9IDAsIHcgPSAxKSB7XG5cdFx0XHR0aGlzLnggPSB4O1xuXHRcdFx0dGhpcy55ID0geTtcblx0XHRcdHRoaXMueiA9IHo7XG5cdFx0XHR0aGlzLncgPSB3O1xuXHRcdH1cblxuXHRcdGdldCB3aWR0aCgpIHtcblx0XHRcdHJldHVybiB0aGlzLno7XG5cdFx0fVxuXG5cdFx0c2V0IHdpZHRoKHZhbHVlKSB7XG5cdFx0XHR0aGlzLnogPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRnZXQgaGVpZ2h0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudztcblx0XHR9XG5cblx0XHRzZXQgaGVpZ2h0KHZhbHVlKSB7XG5cdFx0XHR0aGlzLncgPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRzZXQoeCwgeSwgeiwgdykge1xuXHRcdFx0dGhpcy54ID0geDtcblx0XHRcdHRoaXMueSA9IHk7XG5cdFx0XHR0aGlzLnogPSB6O1xuXHRcdFx0dGhpcy53ID0gdztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldFNjYWxhcihzY2FsYXIpIHtcblx0XHRcdHRoaXMueCA9IHNjYWxhcjtcblx0XHRcdHRoaXMueSA9IHNjYWxhcjtcblx0XHRcdHRoaXMueiA9IHNjYWxhcjtcblx0XHRcdHRoaXMudyA9IHNjYWxhcjtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldFgoeCkge1xuXHRcdFx0dGhpcy54ID0geDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldFkoeSkge1xuXHRcdFx0dGhpcy55ID0geTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldFooeikge1xuXHRcdFx0dGhpcy56ID0gejtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldFcodykge1xuXHRcdFx0dGhpcy53ID0gdztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldENvbXBvbmVudChpbmRleCwgdmFsdWUpIHtcblx0XHRcdHN3aXRjaCAoaW5kZXgpIHtcblx0XHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRcdHRoaXMueCA9IHZhbHVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHR0aGlzLnkgPSB2YWx1ZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0dGhpcy56ID0gdmFsdWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAzOlxuXHRcdFx0XHRcdHRoaXMudyA9IHZhbHVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGdldENvbXBvbmVudChpbmRleCkge1xuXHRcdFx0c3dpdGNoIChpbmRleCkge1xuXHRcdFx0XHRjYXNlIDA6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMueDtcblxuXHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMueTtcblxuXHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuejtcblxuXHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNsb25lKCkge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMudyk7XG5cdFx0fVxuXG5cdFx0Y29weSh2KSB7XG5cdFx0XHR0aGlzLnggPSB2Lng7XG5cdFx0XHR0aGlzLnkgPSB2Lnk7XG5cdFx0XHR0aGlzLnogPSB2Lno7XG5cdFx0XHR0aGlzLncgPSB2LncgIT09IHVuZGVmaW5lZCA/IHYudyA6IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRhZGQodiwgdykge1xuXHRcdFx0aWYgKHcgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlZlY3RvcjQ6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyh2LCB3KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy54ICs9IHYueDtcblx0XHRcdHRoaXMueSArPSB2Lnk7XG5cdFx0XHR0aGlzLnogKz0gdi56O1xuXHRcdFx0dGhpcy53ICs9IHYudztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGFkZFNjYWxhcihzKSB7XG5cdFx0XHR0aGlzLnggKz0gcztcblx0XHRcdHRoaXMueSArPSBzO1xuXHRcdFx0dGhpcy56ICs9IHM7XG5cdFx0XHR0aGlzLncgKz0gcztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGFkZFZlY3RvcnMoYSwgYikge1xuXHRcdFx0dGhpcy54ID0gYS54ICsgYi54O1xuXHRcdFx0dGhpcy55ID0gYS55ICsgYi55O1xuXHRcdFx0dGhpcy56ID0gYS56ICsgYi56O1xuXHRcdFx0dGhpcy53ID0gYS53ICsgYi53O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0YWRkU2NhbGVkVmVjdG9yKHYsIHMpIHtcblx0XHRcdHRoaXMueCArPSB2LnggKiBzO1xuXHRcdFx0dGhpcy55ICs9IHYueSAqIHM7XG5cdFx0XHR0aGlzLnogKz0gdi56ICogcztcblx0XHRcdHRoaXMudyArPSB2LncgKiBzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c3ViKHYsIHcpIHtcblx0XHRcdGlmICh3ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5WZWN0b3I0OiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnModiwgdyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0XHR0aGlzLnkgLT0gdi55O1xuXHRcdFx0dGhpcy56IC09IHYuejtcblx0XHRcdHRoaXMudyAtPSB2Lnc7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzdWJTY2FsYXIocykge1xuXHRcdFx0dGhpcy54IC09IHM7XG5cdFx0XHR0aGlzLnkgLT0gcztcblx0XHRcdHRoaXMueiAtPSBzO1xuXHRcdFx0dGhpcy53IC09IHM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzdWJWZWN0b3JzKGEsIGIpIHtcblx0XHRcdHRoaXMueCA9IGEueCAtIGIueDtcblx0XHRcdHRoaXMueSA9IGEueSAtIGIueTtcblx0XHRcdHRoaXMueiA9IGEueiAtIGIuejtcblx0XHRcdHRoaXMudyA9IGEudyAtIGIudztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG11bHRpcGx5KHYpIHtcblx0XHRcdHRoaXMueCAqPSB2Lng7XG5cdFx0XHR0aGlzLnkgKj0gdi55O1xuXHRcdFx0dGhpcy56ICo9IHYuejtcblx0XHRcdHRoaXMudyAqPSB2Lnc7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRtdWx0aXBseVNjYWxhcihzY2FsYXIpIHtcblx0XHRcdHRoaXMueCAqPSBzY2FsYXI7XG5cdFx0XHR0aGlzLnkgKj0gc2NhbGFyO1xuXHRcdFx0dGhpcy56ICo9IHNjYWxhcjtcblx0XHRcdHRoaXMudyAqPSBzY2FsYXI7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRhcHBseU1hdHJpeDQobSkge1xuXHRcdFx0Y29uc3QgeCA9IHRoaXMueCxcblx0XHRcdFx0XHRcdHkgPSB0aGlzLnksXG5cdFx0XHRcdFx0XHR6ID0gdGhpcy56LFxuXHRcdFx0XHRcdFx0dyA9IHRoaXMudztcblx0XHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXHRcdFx0dGhpcy54ID0gZVswXSAqIHggKyBlWzRdICogeSArIGVbOF0gKiB6ICsgZVsxMl0gKiB3O1xuXHRcdFx0dGhpcy55ID0gZVsxXSAqIHggKyBlWzVdICogeSArIGVbOV0gKiB6ICsgZVsxM10gKiB3O1xuXHRcdFx0dGhpcy56ID0gZVsyXSAqIHggKyBlWzZdICogeSArIGVbMTBdICogeiArIGVbMTRdICogdztcblx0XHRcdHRoaXMudyA9IGVbM10gKiB4ICsgZVs3XSAqIHkgKyBlWzExXSAqIHogKyBlWzE1XSAqIHc7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRkaXZpZGVTY2FsYXIoc2NhbGFyKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcigxIC8gc2NhbGFyKTtcblx0XHR9XG5cblx0XHRzZXRBeGlzQW5nbGVGcm9tUXVhdGVybmlvbihxKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvcXVhdGVybmlvblRvQW5nbGUvaW5kZXguaHRtXG5cdFx0XHQvLyBxIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXHRcdFx0dGhpcy53ID0gMiAqIE1hdGguYWNvcyhxLncpO1xuXHRcdFx0Y29uc3QgcyA9IE1hdGguc3FydCgxIC0gcS53ICogcS53KTtcblxuXHRcdFx0aWYgKHMgPCAwLjAwMDEpIHtcblx0XHRcdFx0dGhpcy54ID0gMTtcblx0XHRcdFx0dGhpcy55ID0gMDtcblx0XHRcdFx0dGhpcy56ID0gMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMueCA9IHEueCAvIHM7XG5cdFx0XHRcdHRoaXMueSA9IHEueSAvIHM7XG5cdFx0XHRcdHRoaXMueiA9IHEueiAvIHM7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldEF4aXNBbmdsZUZyb21Sb3RhdGlvbk1hdHJpeChtKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9BbmdsZS9pbmRleC5odG1cblx0XHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cdFx0XHRsZXQgYW5nbGUsIHgsIHksIHo7IC8vIHZhcmlhYmxlcyBmb3IgcmVzdWx0XG5cblx0XHRcdGNvbnN0IGVwc2lsb24gPSAwLjAxLFxuXHRcdFx0XHRcdFx0Ly8gbWFyZ2luIHRvIGFsbG93IGZvciByb3VuZGluZyBlcnJvcnNcblx0XHRcdGVwc2lsb24yID0gMC4xLFxuXHRcdFx0XHRcdFx0Ly8gbWFyZ2luIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gMCBhbmQgMTgwIGRlZ3JlZXNcblx0XHRcdHRlID0gbS5lbGVtZW50cyxcblx0XHRcdFx0XHRcdG0xMSA9IHRlWzBdLFxuXHRcdFx0XHRcdFx0bTEyID0gdGVbNF0sXG5cdFx0XHRcdFx0XHRtMTMgPSB0ZVs4XSxcblx0XHRcdFx0XHRcdG0yMSA9IHRlWzFdLFxuXHRcdFx0XHRcdFx0bTIyID0gdGVbNV0sXG5cdFx0XHRcdFx0XHRtMjMgPSB0ZVs5XSxcblx0XHRcdFx0XHRcdG0zMSA9IHRlWzJdLFxuXHRcdFx0XHRcdFx0bTMyID0gdGVbNl0sXG5cdFx0XHRcdFx0XHRtMzMgPSB0ZVsxMF07XG5cblx0XHRcdGlmIChNYXRoLmFicyhtMTIgLSBtMjEpIDwgZXBzaWxvbiAmJiBNYXRoLmFicyhtMTMgLSBtMzEpIDwgZXBzaWxvbiAmJiBNYXRoLmFicyhtMjMgLSBtMzIpIDwgZXBzaWxvbikge1xuXHRcdFx0XHQvLyBzaW5ndWxhcml0eSBmb3VuZFxuXHRcdFx0XHQvLyBmaXJzdCBjaGVjayBmb3IgaWRlbnRpdHkgbWF0cml4IHdoaWNoIG11c3QgaGF2ZSArMSBmb3IgYWxsIHRlcm1zXG5cdFx0XHRcdC8vIGluIGxlYWRpbmcgZGlhZ29uYWwgYW5kIHplcm8gaW4gb3RoZXIgdGVybXNcblx0XHRcdFx0aWYgKE1hdGguYWJzKG0xMiArIG0yMSkgPCBlcHNpbG9uMiAmJiBNYXRoLmFicyhtMTMgKyBtMzEpIDwgZXBzaWxvbjIgJiYgTWF0aC5hYnMobTIzICsgbTMyKSA8IGVwc2lsb24yICYmIE1hdGguYWJzKG0xMSArIG0yMiArIG0zMyAtIDMpIDwgZXBzaWxvbjIpIHtcblx0XHRcdFx0XHQvLyB0aGlzIHNpbmd1bGFyaXR5IGlzIGlkZW50aXR5IG1hdHJpeCBzbyBhbmdsZSA9IDBcblx0XHRcdFx0XHR0aGlzLnNldCgxLCAwLCAwLCAwKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpczsgLy8gemVybyBhbmdsZSwgYXJiaXRyYXJ5IGF4aXNcblx0XHRcdFx0fSAvLyBvdGhlcndpc2UgdGhpcyBzaW5ndWxhcml0eSBpcyBhbmdsZSA9IDE4MFxuXG5cblx0XHRcdFx0YW5nbGUgPSBNYXRoLlBJO1xuXHRcdFx0XHRjb25zdCB4eCA9IChtMTEgKyAxKSAvIDI7XG5cdFx0XHRcdGNvbnN0IHl5ID0gKG0yMiArIDEpIC8gMjtcblx0XHRcdFx0Y29uc3QgenogPSAobTMzICsgMSkgLyAyO1xuXHRcdFx0XHRjb25zdCB4eSA9IChtMTIgKyBtMjEpIC8gNDtcblx0XHRcdFx0Y29uc3QgeHogPSAobTEzICsgbTMxKSAvIDQ7XG5cdFx0XHRcdGNvbnN0IHl6ID0gKG0yMyArIG0zMikgLyA0O1xuXG5cdFx0XHRcdGlmICh4eCA+IHl5ICYmIHh4ID4genopIHtcblx0XHRcdFx0XHQvLyBtMTEgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybVxuXHRcdFx0XHRcdGlmICh4eCA8IGVwc2lsb24pIHtcblx0XHRcdFx0XHRcdHggPSAwO1xuXHRcdFx0XHRcdFx0eSA9IDAuNzA3MTA2NzgxO1xuXHRcdFx0XHRcdFx0eiA9IDAuNzA3MTA2NzgxO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR4ID0gTWF0aC5zcXJ0KHh4KTtcblx0XHRcdFx0XHRcdHkgPSB4eSAvIHg7XG5cdFx0XHRcdFx0XHR6ID0geHogLyB4O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICh5eSA+IHp6KSB7XG5cdFx0XHRcdFx0Ly8gbTIyIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cblx0XHRcdFx0XHRpZiAoeXkgPCBlcHNpbG9uKSB7XG5cdFx0XHRcdFx0XHR4ID0gMC43MDcxMDY3ODE7XG5cdFx0XHRcdFx0XHR5ID0gMDtcblx0XHRcdFx0XHRcdHogPSAwLjcwNzEwNjc4MTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0eSA9IE1hdGguc3FydCh5eSk7XG5cdFx0XHRcdFx0XHR4ID0geHkgLyB5O1xuXHRcdFx0XHRcdFx0eiA9IHl6IC8geTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gbTMzIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm0gc28gYmFzZSByZXN1bHQgb24gdGhpc1xuXHRcdFx0XHRcdGlmICh6eiA8IGVwc2lsb24pIHtcblx0XHRcdFx0XHRcdHggPSAwLjcwNzEwNjc4MTtcblx0XHRcdFx0XHRcdHkgPSAwLjcwNzEwNjc4MTtcblx0XHRcdFx0XHRcdHogPSAwO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR6ID0gTWF0aC5zcXJ0KHp6KTtcblx0XHRcdFx0XHRcdHggPSB4eiAvIHo7XG5cdFx0XHRcdFx0XHR5ID0geXogLyB6O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuc2V0KHgsIHksIHosIGFuZ2xlKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7IC8vIHJldHVybiAxODAgZGVnIHJvdGF0aW9uXG5cdFx0XHR9IC8vIGFzIHdlIGhhdmUgcmVhY2hlZCBoZXJlIHRoZXJlIGFyZSBubyBzaW5ndWxhcml0aWVzIHNvIHdlIGNhbiBoYW5kbGUgbm9ybWFsbHlcblxuXG5cdFx0XHRsZXQgcyA9IE1hdGguc3FydCgobTMyIC0gbTIzKSAqIChtMzIgLSBtMjMpICsgKG0xMyAtIG0zMSkgKiAobTEzIC0gbTMxKSArIChtMjEgLSBtMTIpICogKG0yMSAtIG0xMikpOyAvLyB1c2VkIHRvIG5vcm1hbGl6ZVxuXG5cdFx0XHRpZiAoTWF0aC5hYnMocykgPCAwLjAwMSkgcyA9IDE7IC8vIHByZXZlbnQgZGl2aWRlIGJ5IHplcm8sIHNob3VsZCBub3QgaGFwcGVuIGlmIG1hdHJpeCBpcyBvcnRob2dvbmFsIGFuZCBzaG91bGQgYmVcblx0XHRcdC8vIGNhdWdodCBieSBzaW5ndWxhcml0eSB0ZXN0IGFib3ZlLCBidXQgSSd2ZSBsZWZ0IGl0IGluIGp1c3QgaW4gY2FzZVxuXG5cdFx0XHR0aGlzLnggPSAobTMyIC0gbTIzKSAvIHM7XG5cdFx0XHR0aGlzLnkgPSAobTEzIC0gbTMxKSAvIHM7XG5cdFx0XHR0aGlzLnogPSAobTIxIC0gbTEyKSAvIHM7XG5cdFx0XHR0aGlzLncgPSBNYXRoLmFjb3MoKG0xMSArIG0yMiArIG0zMyAtIDEpIC8gMik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRtaW4odikge1xuXHRcdFx0dGhpcy54ID0gTWF0aC5taW4odGhpcy54LCB2LngpO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5taW4odGhpcy55LCB2LnkpO1xuXHRcdFx0dGhpcy56ID0gTWF0aC5taW4odGhpcy56LCB2LnopO1xuXHRcdFx0dGhpcy53ID0gTWF0aC5taW4odGhpcy53LCB2LncpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bWF4KHYpIHtcblx0XHRcdHRoaXMueCA9IE1hdGgubWF4KHRoaXMueCwgdi54KTtcblx0XHRcdHRoaXMueSA9IE1hdGgubWF4KHRoaXMueSwgdi55KTtcblx0XHRcdHRoaXMueiA9IE1hdGgubWF4KHRoaXMueiwgdi56KTtcblx0XHRcdHRoaXMudyA9IE1hdGgubWF4KHRoaXMudywgdi53KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNsYW1wKG1pbiwgbWF4KSB7XG5cdFx0XHQvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxuXHRcdFx0dGhpcy54ID0gTWF0aC5tYXgobWluLngsIE1hdGgubWluKG1heC54LCB0aGlzLngpKTtcblx0XHRcdHRoaXMueSA9IE1hdGgubWF4KG1pbi55LCBNYXRoLm1pbihtYXgueSwgdGhpcy55KSk7XG5cdFx0XHR0aGlzLnogPSBNYXRoLm1heChtaW4ueiwgTWF0aC5taW4obWF4LnosIHRoaXMueikpO1xuXHRcdFx0dGhpcy53ID0gTWF0aC5tYXgobWluLncsIE1hdGgubWluKG1heC53LCB0aGlzLncpKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNsYW1wU2NhbGFyKG1pblZhbCwgbWF4VmFsKSB7XG5cdFx0XHR0aGlzLnggPSBNYXRoLm1heChtaW5WYWwsIE1hdGgubWluKG1heFZhbCwgdGhpcy54KSk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLm1heChtaW5WYWwsIE1hdGgubWluKG1heFZhbCwgdGhpcy55KSk7XG5cdFx0XHR0aGlzLnogPSBNYXRoLm1heChtaW5WYWwsIE1hdGgubWluKG1heFZhbCwgdGhpcy56KSk7XG5cdFx0XHR0aGlzLncgPSBNYXRoLm1heChtaW5WYWwsIE1hdGgubWluKG1heFZhbCwgdGhpcy53KSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbGFtcExlbmd0aChtaW4sIG1heCkge1xuXHRcdFx0Y29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblx0XHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhcihsZW5ndGggfHwgMSkubXVsdGlwbHlTY2FsYXIoTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIGxlbmd0aCkpKTtcblx0XHR9XG5cblx0XHRmbG9vcigpIHtcblx0XHRcdHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KTtcblx0XHRcdHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KTtcblx0XHRcdHRoaXMueiA9IE1hdGguZmxvb3IodGhpcy56KTtcblx0XHRcdHRoaXMudyA9IE1hdGguZmxvb3IodGhpcy53KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNlaWwoKSB7XG5cdFx0XHR0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcblx0XHRcdHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xuXHRcdFx0dGhpcy56ID0gTWF0aC5jZWlsKHRoaXMueik7XG5cdFx0XHR0aGlzLncgPSBNYXRoLmNlaWwodGhpcy53KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHJvdW5kKCkge1xuXHRcdFx0dGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpO1xuXHRcdFx0dGhpcy56ID0gTWF0aC5yb3VuZCh0aGlzLnopO1xuXHRcdFx0dGhpcy53ID0gTWF0aC5yb3VuZCh0aGlzLncpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0cm91bmRUb1plcm8oKSB7XG5cdFx0XHR0aGlzLnggPSB0aGlzLnggPCAwID8gTWF0aC5jZWlsKHRoaXMueCkgOiBNYXRoLmZsb29yKHRoaXMueCk7XG5cdFx0XHR0aGlzLnkgPSB0aGlzLnkgPCAwID8gTWF0aC5jZWlsKHRoaXMueSkgOiBNYXRoLmZsb29yKHRoaXMueSk7XG5cdFx0XHR0aGlzLnogPSB0aGlzLnogPCAwID8gTWF0aC5jZWlsKHRoaXMueikgOiBNYXRoLmZsb29yKHRoaXMueik7XG5cdFx0XHR0aGlzLncgPSB0aGlzLncgPCAwID8gTWF0aC5jZWlsKHRoaXMudykgOiBNYXRoLmZsb29yKHRoaXMudyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRuZWdhdGUoKSB7XG5cdFx0XHR0aGlzLnggPSAtdGhpcy54O1xuXHRcdFx0dGhpcy55ID0gLXRoaXMueTtcblx0XHRcdHRoaXMueiA9IC10aGlzLno7XG5cdFx0XHR0aGlzLncgPSAtdGhpcy53O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZG90KHYpIHtcblx0XHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2LnogKyB0aGlzLncgKiB2Lnc7XG5cdFx0fVxuXG5cdFx0bGVuZ3RoU3EoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53O1xuXHRcdH1cblxuXHRcdGxlbmd0aCgpIHtcblx0XHRcdHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53KTtcblx0XHR9XG5cblx0XHRtYW5oYXR0YW5MZW5ndGgoKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5hYnModGhpcy54KSArIE1hdGguYWJzKHRoaXMueSkgKyBNYXRoLmFicyh0aGlzLnopICsgTWF0aC5hYnModGhpcy53KTtcblx0XHR9XG5cblx0XHRub3JtYWxpemUoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKSB8fCAxKTtcblx0XHR9XG5cblx0XHRzZXRMZW5ndGgobGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihsZW5ndGgpO1xuXHRcdH1cblxuXHRcdGxlcnAodiwgYWxwaGEpIHtcblx0XHRcdHRoaXMueCArPSAodi54IC0gdGhpcy54KSAqIGFscGhhO1xuXHRcdFx0dGhpcy55ICs9ICh2LnkgLSB0aGlzLnkpICogYWxwaGE7XG5cdFx0XHR0aGlzLnogKz0gKHYueiAtIHRoaXMueikgKiBhbHBoYTtcblx0XHRcdHRoaXMudyArPSAodi53IC0gdGhpcy53KSAqIGFscGhhO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bGVycFZlY3RvcnModjEsIHYyLCBhbHBoYSkge1xuXHRcdFx0dGhpcy54ID0gdjEueCArICh2Mi54IC0gdjEueCkgKiBhbHBoYTtcblx0XHRcdHRoaXMueSA9IHYxLnkgKyAodjIueSAtIHYxLnkpICogYWxwaGE7XG5cdFx0XHR0aGlzLnogPSB2MS56ICsgKHYyLnogLSB2MS56KSAqIGFscGhhO1xuXHRcdFx0dGhpcy53ID0gdjEudyArICh2Mi53IC0gdjEudykgKiBhbHBoYTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGVxdWFscyh2KSB7XG5cdFx0XHRyZXR1cm4gdi54ID09PSB0aGlzLnggJiYgdi55ID09PSB0aGlzLnkgJiYgdi56ID09PSB0aGlzLnogJiYgdi53ID09PSB0aGlzLnc7XG5cdFx0fVxuXG5cdFx0ZnJvbUFycmF5KGFycmF5LCBvZmZzZXQgPSAwKSB7XG5cdFx0XHR0aGlzLnggPSBhcnJheVtvZmZzZXRdO1xuXHRcdFx0dGhpcy55ID0gYXJyYXlbb2Zmc2V0ICsgMV07XG5cdFx0XHR0aGlzLnogPSBhcnJheVtvZmZzZXQgKyAyXTtcblx0XHRcdHRoaXMudyA9IGFycmF5W29mZnNldCArIDNdO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dG9BcnJheShhcnJheSA9IFtdLCBvZmZzZXQgPSAwKSB7XG5cdFx0XHRhcnJheVtvZmZzZXRdID0gdGhpcy54O1xuXHRcdFx0YXJyYXlbb2Zmc2V0ICsgMV0gPSB0aGlzLnk7XG5cdFx0XHRhcnJheVtvZmZzZXQgKyAyXSA9IHRoaXMuejtcblx0XHRcdGFycmF5W29mZnNldCArIDNdID0gdGhpcy53O1xuXHRcdFx0cmV0dXJuIGFycmF5O1xuXHRcdH1cblxuXHRcdGZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0KSB7XG5cdFx0XHRpZiAob2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5WZWN0b3I0OiBvZmZzZXQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIC5mcm9tQnVmZmVyQXR0cmlidXRlKCkuJyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5nZXRYKGluZGV4KTtcblx0XHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5nZXRZKGluZGV4KTtcblx0XHRcdHRoaXMueiA9IGF0dHJpYnV0ZS5nZXRaKGluZGV4KTtcblx0XHRcdHRoaXMudyA9IGF0dHJpYnV0ZS5nZXRXKGluZGV4KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHJhbmRvbSgpIHtcblx0XHRcdHRoaXMueCA9IE1hdGgucmFuZG9tKCk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLnJhbmRvbSgpO1xuXHRcdFx0dGhpcy56ID0gTWF0aC5yYW5kb20oKTtcblx0XHRcdHRoaXMudyA9IE1hdGgucmFuZG9tKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG5cdFx0XHR5aWVsZCB0aGlzLng7XG5cdFx0XHR5aWVsZCB0aGlzLnk7XG5cdFx0XHR5aWVsZCB0aGlzLno7XG5cdFx0XHR5aWVsZCB0aGlzLnc7XG5cdFx0fVxuXG5cdH1cblxuXHRWZWN0b3I0LnByb3RvdHlwZS5pc1ZlY3RvcjQgPSB0cnVlO1xuXG5cdC8qXG5cdCBJbiBvcHRpb25zLCB3ZSBjYW4gc3BlY2lmeTpcblx0ICogVGV4dHVyZSBwYXJhbWV0ZXJzIGZvciBhbiBhdXRvLWdlbmVyYXRlZCB0YXJnZXQgdGV4dHVyZVxuXHQgKiBkZXB0aEJ1ZmZlci9zdGVuY2lsQnVmZmVyOiBCb29sZWFucyB0byBpbmRpY2F0ZSBpZiB3ZSBzaG91bGQgZ2VuZXJhdGUgdGhlc2UgYnVmZmVyc1xuXHQqL1xuXG5cdGNsYXNzIFdlYkdMUmVuZGVyVGFyZ2V0IGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcblx0XHRjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCBvcHRpb25zID0ge30pIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblx0XHRcdHRoaXMuZGVwdGggPSAxO1xuXHRcdFx0dGhpcy5zY2lzc29yID0gbmV3IFZlY3RvcjQoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cdFx0XHR0aGlzLnNjaXNzb3JUZXN0ID0gZmFsc2U7XG5cdFx0XHR0aGlzLnZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cdFx0XHR0aGlzLnRleHR1cmUgPSBuZXcgVGV4dHVyZSh1bmRlZmluZWQsIG9wdGlvbnMubWFwcGluZywgb3B0aW9ucy53cmFwUywgb3B0aW9ucy53cmFwVCwgb3B0aW9ucy5tYWdGaWx0ZXIsIG9wdGlvbnMubWluRmlsdGVyLCBvcHRpb25zLmZvcm1hdCwgb3B0aW9ucy50eXBlLCBvcHRpb25zLmFuaXNvdHJvcHksIG9wdGlvbnMuZW5jb2RpbmcpO1xuXHRcdFx0dGhpcy50ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9IHRydWU7XG5cdFx0XHR0aGlzLnRleHR1cmUuaW1hZ2UgPSB7XG5cdFx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0XHRcdGRlcHRoOiAxXG5cdFx0XHR9O1xuXHRcdFx0dGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IG9wdGlvbnMuZ2VuZXJhdGVNaXBtYXBzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmdlbmVyYXRlTWlwbWFwcyA6IGZhbHNlO1xuXHRcdFx0dGhpcy50ZXh0dXJlLmludGVybmFsRm9ybWF0ID0gb3B0aW9ucy5pbnRlcm5hbEZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5pbnRlcm5hbEZvcm1hdCA6IG51bGw7XG5cdFx0XHR0aGlzLnRleHR1cmUubWluRmlsdGVyID0gb3B0aW9ucy5taW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWluRmlsdGVyIDogTGluZWFyRmlsdGVyO1xuXHRcdFx0dGhpcy5kZXB0aEJ1ZmZlciA9IG9wdGlvbnMuZGVwdGhCdWZmZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVwdGhCdWZmZXIgOiB0cnVlO1xuXHRcdFx0dGhpcy5zdGVuY2lsQnVmZmVyID0gb3B0aW9ucy5zdGVuY2lsQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgOiBmYWxzZTtcblx0XHRcdHRoaXMuZGVwdGhUZXh0dXJlID0gb3B0aW9ucy5kZXB0aFRleHR1cmUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVwdGhUZXh0dXJlIDogbnVsbDtcblx0XHR9XG5cblx0XHRzZXRUZXh0dXJlKHRleHR1cmUpIHtcblx0XHRcdHRleHR1cmUuaW1hZ2UgPSB7XG5cdFx0XHRcdHdpZHRoOiB0aGlzLndpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuXHRcdFx0XHRkZXB0aDogdGhpcy5kZXB0aFxuXHRcdFx0fTtcblx0XHRcdHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG5cdFx0fVxuXG5cdFx0c2V0U2l6ZSh3aWR0aCwgaGVpZ2h0LCBkZXB0aCA9IDEpIHtcblx0XHRcdGlmICh0aGlzLndpZHRoICE9PSB3aWR0aCB8fCB0aGlzLmhlaWdodCAhPT0gaGVpZ2h0IHx8IHRoaXMuZGVwdGggIT09IGRlcHRoKSB7XG5cdFx0XHRcdHRoaXMud2lkdGggPSB3aWR0aDtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XHRcdHRoaXMuZGVwdGggPSBkZXB0aDtcblx0XHRcdFx0dGhpcy50ZXh0dXJlLmltYWdlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRcdHRoaXMudGV4dHVyZS5pbWFnZS5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XHRcdHRoaXMudGV4dHVyZS5pbWFnZS5kZXB0aCA9IGRlcHRoO1xuXHRcdFx0XHR0aGlzLmRpc3Bvc2UoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy52aWV3cG9ydC5zZXQoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cdFx0XHR0aGlzLnNjaXNzb3Iuc2V0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXHRcdH1cblxuXHRcdGNsb25lKCkge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0dGhpcy53aWR0aCA9IHNvdXJjZS53aWR0aDtcblx0XHRcdHRoaXMuaGVpZ2h0ID0gc291cmNlLmhlaWdodDtcblx0XHRcdHRoaXMuZGVwdGggPSBzb3VyY2UuZGVwdGg7XG5cdFx0XHR0aGlzLnZpZXdwb3J0LmNvcHkoc291cmNlLnZpZXdwb3J0KTtcblx0XHRcdHRoaXMudGV4dHVyZSA9IHNvdXJjZS50ZXh0dXJlLmNsb25lKCk7XG5cdFx0XHR0aGlzLnRleHR1cmUuaW1hZ2UgPSB7IC4uLnRoaXMudGV4dHVyZS5pbWFnZVxuXHRcdFx0fTsgLy8gU2VlICMyMDMyOC5cblxuXHRcdFx0dGhpcy5kZXB0aEJ1ZmZlciA9IHNvdXJjZS5kZXB0aEJ1ZmZlcjtcblx0XHRcdHRoaXMuc3RlbmNpbEJ1ZmZlciA9IHNvdXJjZS5zdGVuY2lsQnVmZmVyO1xuXHRcdFx0dGhpcy5kZXB0aFRleHR1cmUgPSBzb3VyY2UuZGVwdGhUZXh0dXJlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZGlzcG9zZSgpIHtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudCh7XG5cdFx0XHRcdHR5cGU6ICdkaXNwb3NlJ1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdH1cblxuXHRXZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUuaXNXZWJHTFJlbmRlclRhcmdldCA9IHRydWU7XG5cblx0Y2xhc3MgV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMgZXh0ZW5kcyBXZWJHTFJlbmRlclRhcmdldCB7XG5cdFx0Y29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCwgY291bnQpIHtcblx0XHRcdHN1cGVyKHdpZHRoLCBoZWlnaHQpO1xuXHRcdFx0Y29uc3QgdGV4dHVyZSA9IHRoaXMudGV4dHVyZTtcblx0XHRcdHRoaXMudGV4dHVyZSA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0XHRcdFx0dGhpcy50ZXh0dXJlW2ldID0gdGV4dHVyZS5jbG9uZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNldFNpemUod2lkdGgsIGhlaWdodCwgZGVwdGggPSAxKSB7XG5cdFx0XHRpZiAodGhpcy53aWR0aCAhPT0gd2lkdGggfHwgdGhpcy5oZWlnaHQgIT09IGhlaWdodCB8fCB0aGlzLmRlcHRoICE9PSBkZXB0aCkge1xuXHRcdFx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdFx0XHR0aGlzLmRlcHRoID0gZGVwdGg7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gdGhpcy50ZXh0dXJlLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHR0aGlzLnRleHR1cmVbaV0uaW1hZ2Uud2lkdGggPSB3aWR0aDtcblx0XHRcdFx0XHR0aGlzLnRleHR1cmVbaV0uaW1hZ2UuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdFx0XHRcdHRoaXMudGV4dHVyZVtpXS5pbWFnZS5kZXB0aCA9IGRlcHRoO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5kaXNwb3NlKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudmlld3BvcnQuc2V0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXHRcdFx0dGhpcy5zY2lzc29yLnNldCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHR0aGlzLmRpc3Bvc2UoKTtcblx0XHRcdHRoaXMud2lkdGggPSBzb3VyY2Uud2lkdGg7XG5cdFx0XHR0aGlzLmhlaWdodCA9IHNvdXJjZS5oZWlnaHQ7XG5cdFx0XHR0aGlzLmRlcHRoID0gc291cmNlLmRlcHRoO1xuXHRcdFx0dGhpcy52aWV3cG9ydC5zZXQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHRcdFx0dGhpcy5zY2lzc29yLnNldCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cdFx0XHR0aGlzLmRlcHRoQnVmZmVyID0gc291cmNlLmRlcHRoQnVmZmVyO1xuXHRcdFx0dGhpcy5zdGVuY2lsQnVmZmVyID0gc291cmNlLnN0ZW5jaWxCdWZmZXI7XG5cdFx0XHR0aGlzLmRlcHRoVGV4dHVyZSA9IHNvdXJjZS5kZXB0aFRleHR1cmU7XG5cdFx0XHR0aGlzLnRleHR1cmUubGVuZ3RoID0gMDtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gc291cmNlLnRleHR1cmUubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHR0aGlzLnRleHR1cmVbaV0gPSBzb3VyY2UudGV4dHVyZVtpXS5jbG9uZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdFdlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzLnByb3RvdHlwZS5pc1dlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzID0gdHJ1ZTtcblxuXHRjbGFzcyBXZWJHTE11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0IGV4dGVuZHMgV2ViR0xSZW5kZXJUYXJnZXQge1xuXHRcdGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgPSB7fSkge1xuXHRcdFx0c3VwZXIod2lkdGgsIGhlaWdodCwgb3B0aW9ucyk7XG5cdFx0XHR0aGlzLnNhbXBsZXMgPSA0O1xuXHRcdFx0dGhpcy5pZ25vcmVEZXB0aEZvck11bHRpc2FtcGxlQ29weSA9IG9wdGlvbnMuaWdub3JlRGVwdGggIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaWdub3JlRGVwdGggOiB0cnVlO1xuXHRcdFx0dGhpcy51c2VSZW5kZXJUb1RleHR1cmUgPSBvcHRpb25zLnVzZVJlbmRlclRvVGV4dHVyZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy51c2VSZW5kZXJUb1RleHR1cmUgOiBmYWxzZTtcblx0XHRcdHRoaXMudXNlUmVuZGVyYnVmZmVyID0gdGhpcy51c2VSZW5kZXJUb1RleHR1cmUgPT09IGZhbHNlO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5LmNhbGwodGhpcywgc291cmNlKTtcblx0XHRcdHRoaXMuc2FtcGxlcyA9IHNvdXJjZS5zYW1wbGVzO1xuXHRcdFx0dGhpcy51c2VSZW5kZXJUb1RleHR1cmUgPSBzb3VyY2UudXNlUmVuZGVyVG9UZXh0dXJlO1xuXHRcdFx0dGhpcy51c2VSZW5kZXJidWZmZXIgPSBzb3VyY2UudXNlUmVuZGVyYnVmZmVyO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRXZWJHTE11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5pc1dlYkdMTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQgPSB0cnVlO1xuXG5cdGNsYXNzIFF1YXRlcm5pb24ge1xuXHRcdGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgeiA9IDAsIHcgPSAxKSB7XG5cdFx0XHR0aGlzLl94ID0geDtcblx0XHRcdHRoaXMuX3kgPSB5O1xuXHRcdFx0dGhpcy5feiA9IHo7XG5cdFx0XHR0aGlzLl93ID0gdztcblx0XHR9XG5cblx0XHRzdGF0aWMgc2xlcnAocWEsIHFiLCBxbSwgdCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5RdWF0ZXJuaW9uOiBTdGF0aWMgLnNsZXJwKCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIHFtLnNsZXJwUXVhdGVybmlvbnMoIHFhLCBxYiwgdCApIGluc3RlYWQuJyk7XG5cdFx0XHRyZXR1cm4gcW0uc2xlcnBRdWF0ZXJuaW9ucyhxYSwgcWIsIHQpO1xuXHRcdH1cblxuXHRcdHN0YXRpYyBzbGVycEZsYXQoZHN0LCBkc3RPZmZzZXQsIHNyYzAsIHNyY09mZnNldDAsIHNyYzEsIHNyY09mZnNldDEsIHQpIHtcblx0XHRcdC8vIGZ1enotZnJlZSwgYXJyYXktYmFzZWQgUXVhdGVybmlvbiBTTEVSUCBvcGVyYXRpb25cblx0XHRcdGxldCB4MCA9IHNyYzBbc3JjT2Zmc2V0MCArIDBdLFxuXHRcdFx0XHRcdHkwID0gc3JjMFtzcmNPZmZzZXQwICsgMV0sXG5cdFx0XHRcdFx0ejAgPSBzcmMwW3NyY09mZnNldDAgKyAyXSxcblx0XHRcdFx0XHR3MCA9IHNyYzBbc3JjT2Zmc2V0MCArIDNdO1xuXHRcdFx0Y29uc3QgeDEgPSBzcmMxW3NyY09mZnNldDEgKyAwXSxcblx0XHRcdFx0XHRcdHkxID0gc3JjMVtzcmNPZmZzZXQxICsgMV0sXG5cdFx0XHRcdFx0XHR6MSA9IHNyYzFbc3JjT2Zmc2V0MSArIDJdLFxuXHRcdFx0XHRcdFx0dzEgPSBzcmMxW3NyY09mZnNldDEgKyAzXTtcblxuXHRcdFx0aWYgKHQgPT09IDApIHtcblx0XHRcdFx0ZHN0W2RzdE9mZnNldCArIDBdID0geDA7XG5cdFx0XHRcdGRzdFtkc3RPZmZzZXQgKyAxXSA9IHkwO1xuXHRcdFx0XHRkc3RbZHN0T2Zmc2V0ICsgMl0gPSB6MDtcblx0XHRcdFx0ZHN0W2RzdE9mZnNldCArIDNdID0gdzA7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHQgPT09IDEpIHtcblx0XHRcdFx0ZHN0W2RzdE9mZnNldCArIDBdID0geDE7XG5cdFx0XHRcdGRzdFtkc3RPZmZzZXQgKyAxXSA9IHkxO1xuXHRcdFx0XHRkc3RbZHN0T2Zmc2V0ICsgMl0gPSB6MTtcblx0XHRcdFx0ZHN0W2RzdE9mZnNldCArIDNdID0gdzE7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHcwICE9PSB3MSB8fCB4MCAhPT0geDEgfHwgeTAgIT09IHkxIHx8IHowICE9PSB6MSkge1xuXHRcdFx0XHRsZXQgcyA9IDEgLSB0O1xuXHRcdFx0XHRjb25zdCBjb3MgPSB4MCAqIHgxICsgeTAgKiB5MSArIHowICogejEgKyB3MCAqIHcxLFxuXHRcdFx0XHRcdFx0XHRkaXIgPSBjb3MgPj0gMCA/IDEgOiAtMSxcblx0XHRcdFx0XHRcdFx0c3FyU2luID0gMSAtIGNvcyAqIGNvczsgLy8gU2tpcCB0aGUgU2xlcnAgZm9yIHRpbnkgc3RlcHMgdG8gYXZvaWQgbnVtZXJpYyBwcm9ibGVtczpcblxuXHRcdFx0XHRpZiAoc3FyU2luID4gTnVtYmVyLkVQU0lMT04pIHtcblx0XHRcdFx0XHRjb25zdCBzaW4gPSBNYXRoLnNxcnQoc3FyU2luKSxcblx0XHRcdFx0XHRcdFx0XHRsZW4gPSBNYXRoLmF0YW4yKHNpbiwgY29zICogZGlyKTtcblx0XHRcdFx0XHRzID0gTWF0aC5zaW4ocyAqIGxlbikgLyBzaW47XG5cdFx0XHRcdFx0dCA9IE1hdGguc2luKHQgKiBsZW4pIC8gc2luO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgdERpciA9IHQgKiBkaXI7XG5cdFx0XHRcdHgwID0geDAgKiBzICsgeDEgKiB0RGlyO1xuXHRcdFx0XHR5MCA9IHkwICogcyArIHkxICogdERpcjtcblx0XHRcdFx0ejAgPSB6MCAqIHMgKyB6MSAqIHREaXI7XG5cdFx0XHRcdHcwID0gdzAgKiBzICsgdzEgKiB0RGlyOyAvLyBOb3JtYWxpemUgaW4gY2FzZSB3ZSBqdXN0IGRpZCBhIGxlcnA6XG5cblx0XHRcdFx0aWYgKHMgPT09IDEgLSB0KSB7XG5cdFx0XHRcdFx0Y29uc3QgZiA9IDEgLyBNYXRoLnNxcnQoeDAgKiB4MCArIHkwICogeTAgKyB6MCAqIHowICsgdzAgKiB3MCk7XG5cdFx0XHRcdFx0eDAgKj0gZjtcblx0XHRcdFx0XHR5MCAqPSBmO1xuXHRcdFx0XHRcdHowICo9IGY7XG5cdFx0XHRcdFx0dzAgKj0gZjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRkc3RbZHN0T2Zmc2V0XSA9IHgwO1xuXHRcdFx0ZHN0W2RzdE9mZnNldCArIDFdID0geTA7XG5cdFx0XHRkc3RbZHN0T2Zmc2V0ICsgMl0gPSB6MDtcblx0XHRcdGRzdFtkc3RPZmZzZXQgKyAzXSA9IHcwO1xuXHRcdH1cblxuXHRcdHN0YXRpYyBtdWx0aXBseVF1YXRlcm5pb25zRmxhdChkc3QsIGRzdE9mZnNldCwgc3JjMCwgc3JjT2Zmc2V0MCwgc3JjMSwgc3JjT2Zmc2V0MSkge1xuXHRcdFx0Y29uc3QgeDAgPSBzcmMwW3NyY09mZnNldDBdO1xuXHRcdFx0Y29uc3QgeTAgPSBzcmMwW3NyY09mZnNldDAgKyAxXTtcblx0XHRcdGNvbnN0IHowID0gc3JjMFtzcmNPZmZzZXQwICsgMl07XG5cdFx0XHRjb25zdCB3MCA9IHNyYzBbc3JjT2Zmc2V0MCArIDNdO1xuXHRcdFx0Y29uc3QgeDEgPSBzcmMxW3NyY09mZnNldDFdO1xuXHRcdFx0Y29uc3QgeTEgPSBzcmMxW3NyY09mZnNldDEgKyAxXTtcblx0XHRcdGNvbnN0IHoxID0gc3JjMVtzcmNPZmZzZXQxICsgMl07XG5cdFx0XHRjb25zdCB3MSA9IHNyYzFbc3JjT2Zmc2V0MSArIDNdO1xuXHRcdFx0ZHN0W2RzdE9mZnNldF0gPSB4MCAqIHcxICsgdzAgKiB4MSArIHkwICogejEgLSB6MCAqIHkxO1xuXHRcdFx0ZHN0W2RzdE9mZnNldCArIDFdID0geTAgKiB3MSArIHcwICogeTEgKyB6MCAqIHgxIC0geDAgKiB6MTtcblx0XHRcdGRzdFtkc3RPZmZzZXQgKyAyXSA9IHowICogdzEgKyB3MCAqIHoxICsgeDAgKiB5MSAtIHkwICogeDE7XG5cdFx0XHRkc3RbZHN0T2Zmc2V0ICsgM10gPSB3MCAqIHcxIC0geDAgKiB4MSAtIHkwICogeTEgLSB6MCAqIHoxO1xuXHRcdFx0cmV0dXJuIGRzdDtcblx0XHR9XG5cblx0XHRnZXQgeCgpIHtcblx0XHRcdHJldHVybiB0aGlzLl94O1xuXHRcdH1cblxuXHRcdHNldCB4KHZhbHVlKSB7XG5cdFx0XHR0aGlzLl94ID0gdmFsdWU7XG5cblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblx0XHR9XG5cblx0XHRnZXQgeSgpIHtcblx0XHRcdHJldHVybiB0aGlzLl95O1xuXHRcdH1cblxuXHRcdHNldCB5KHZhbHVlKSB7XG5cdFx0XHR0aGlzLl95ID0gdmFsdWU7XG5cblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblx0XHR9XG5cblx0XHRnZXQgeigpIHtcblx0XHRcdHJldHVybiB0aGlzLl96O1xuXHRcdH1cblxuXHRcdHNldCB6KHZhbHVlKSB7XG5cdFx0XHR0aGlzLl96ID0gdmFsdWU7XG5cblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblx0XHR9XG5cblx0XHRnZXQgdygpIHtcblx0XHRcdHJldHVybiB0aGlzLl93O1xuXHRcdH1cblxuXHRcdHNldCB3KHZhbHVlKSB7XG5cdFx0XHR0aGlzLl93ID0gdmFsdWU7XG5cblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblx0XHR9XG5cblx0XHRzZXQoeCwgeSwgeiwgdykge1xuXHRcdFx0dGhpcy5feCA9IHg7XG5cdFx0XHR0aGlzLl95ID0geTtcblx0XHRcdHRoaXMuX3ogPSB6O1xuXHRcdFx0dGhpcy5fdyA9IHc7XG5cblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y2xvbmUoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fdyk7XG5cdFx0fVxuXG5cdFx0Y29weShxdWF0ZXJuaW9uKSB7XG5cdFx0XHR0aGlzLl94ID0gcXVhdGVybmlvbi54O1xuXHRcdFx0dGhpcy5feSA9IHF1YXRlcm5pb24ueTtcblx0XHRcdHRoaXMuX3ogPSBxdWF0ZXJuaW9uLno7XG5cdFx0XHR0aGlzLl93ID0gcXVhdGVybmlvbi53O1xuXG5cdFx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldEZyb21FdWxlcihldWxlciwgdXBkYXRlKSB7XG5cdFx0XHRpZiAoIShldWxlciAmJiBldWxlci5pc0V1bGVyKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RIUkVFLlF1YXRlcm5pb246IC5zZXRGcm9tRXVsZXIoKSBub3cgZXhwZWN0cyBhbiBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB4ID0gZXVsZXIuX3gsXG5cdFx0XHRcdFx0XHR5ID0gZXVsZXIuX3ksXG5cdFx0XHRcdFx0XHR6ID0gZXVsZXIuX3osXG5cdFx0XHRcdFx0XHRvcmRlciA9IGV1bGVyLl9vcmRlcjsgLy8gaHR0cDovL3d3dy5tYXRod29ya3MuY29tL21hdGxhYmNlbnRyYWwvZmlsZWV4Y2hhbmdlL1xuXHRcdFx0Ly8gXHQyMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9cblx0XHRcdC8vXHRjb250ZW50L1NwaW5DYWxjLm1cblxuXHRcdFx0Y29uc3QgY29zID0gTWF0aC5jb3M7XG5cdFx0XHRjb25zdCBzaW4gPSBNYXRoLnNpbjtcblx0XHRcdGNvbnN0IGMxID0gY29zKHggLyAyKTtcblx0XHRcdGNvbnN0IGMyID0gY29zKHkgLyAyKTtcblx0XHRcdGNvbnN0IGMzID0gY29zKHogLyAyKTtcblx0XHRcdGNvbnN0IHMxID0gc2luKHggLyAyKTtcblx0XHRcdGNvbnN0IHMyID0gc2luKHkgLyAyKTtcblx0XHRcdGNvbnN0IHMzID0gc2luKHogLyAyKTtcblxuXHRcdFx0c3dpdGNoIChvcmRlcikge1xuXHRcdFx0XHRjYXNlICdYWVonOlxuXHRcdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG5cdFx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnWVhaJzpcblx0XHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG5cdFx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcblx0XHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1pYWSc6XG5cdFx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcblx0XHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdaWVgnOlxuXHRcdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG5cdFx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuXHRcdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnWVpYJzpcblx0XHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG5cdFx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcblx0XHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1haWSc6XG5cdFx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcblx0XHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICcgKyBvcmRlcik7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh1cGRhdGUgIT09IGZhbHNlKSB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRGcm9tQXhpc0FuZ2xlKGF4aXMsIGFuZ2xlKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvYW5nbGVUb1F1YXRlcm5pb24vaW5kZXguaHRtXG5cdFx0XHQvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxuXHRcdFx0Y29uc3QgaGFsZkFuZ2xlID0gYW5nbGUgLyAyLFxuXHRcdFx0XHRcdFx0cyA9IE1hdGguc2luKGhhbGZBbmdsZSk7XG5cdFx0XHR0aGlzLl94ID0gYXhpcy54ICogcztcblx0XHRcdHRoaXMuX3kgPSBheGlzLnkgKiBzO1xuXHRcdFx0dGhpcy5feiA9IGF4aXMueiAqIHM7XG5cdFx0XHR0aGlzLl93ID0gTWF0aC5jb3MoaGFsZkFuZ2xlKTtcblxuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRGcm9tUm90YXRpb25NYXRyaXgobSkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvUXVhdGVybmlvbi9pbmRleC5odG1cblx0XHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cdFx0XHRjb25zdCB0ZSA9IG0uZWxlbWVudHMsXG5cdFx0XHRcdFx0XHRtMTEgPSB0ZVswXSxcblx0XHRcdFx0XHRcdG0xMiA9IHRlWzRdLFxuXHRcdFx0XHRcdFx0bTEzID0gdGVbOF0sXG5cdFx0XHRcdFx0XHRtMjEgPSB0ZVsxXSxcblx0XHRcdFx0XHRcdG0yMiA9IHRlWzVdLFxuXHRcdFx0XHRcdFx0bTIzID0gdGVbOV0sXG5cdFx0XHRcdFx0XHRtMzEgPSB0ZVsyXSxcblx0XHRcdFx0XHRcdG0zMiA9IHRlWzZdLFxuXHRcdFx0XHRcdFx0bTMzID0gdGVbMTBdLFxuXHRcdFx0XHRcdFx0dHJhY2UgPSBtMTEgKyBtMjIgKyBtMzM7XG5cblx0XHRcdGlmICh0cmFjZSA+IDApIHtcblx0XHRcdFx0Y29uc3QgcyA9IDAuNSAvIE1hdGguc3FydCh0cmFjZSArIDEuMCk7XG5cdFx0XHRcdHRoaXMuX3cgPSAwLjI1IC8gcztcblx0XHRcdFx0dGhpcy5feCA9IChtMzIgLSBtMjMpICogcztcblx0XHRcdFx0dGhpcy5feSA9IChtMTMgLSBtMzEpICogcztcblx0XHRcdFx0dGhpcy5feiA9IChtMjEgLSBtMTIpICogcztcblx0XHRcdH0gZWxzZSBpZiAobTExID4gbTIyICYmIG0xMSA+IG0zMykge1xuXHRcdFx0XHRjb25zdCBzID0gMi4wICogTWF0aC5zcXJ0KDEuMCArIG0xMSAtIG0yMiAtIG0zMyk7XG5cdFx0XHRcdHRoaXMuX3cgPSAobTMyIC0gbTIzKSAvIHM7XG5cdFx0XHRcdHRoaXMuX3ggPSAwLjI1ICogcztcblx0XHRcdFx0dGhpcy5feSA9IChtMTIgKyBtMjEpIC8gcztcblx0XHRcdFx0dGhpcy5feiA9IChtMTMgKyBtMzEpIC8gcztcblx0XHRcdH0gZWxzZSBpZiAobTIyID4gbTMzKSB7XG5cdFx0XHRcdGNvbnN0IHMgPSAyLjAgKiBNYXRoLnNxcnQoMS4wICsgbTIyIC0gbTExIC0gbTMzKTtcblx0XHRcdFx0dGhpcy5fdyA9IChtMTMgLSBtMzEpIC8gcztcblx0XHRcdFx0dGhpcy5feCA9IChtMTIgKyBtMjEpIC8gcztcblx0XHRcdFx0dGhpcy5feSA9IDAuMjUgKiBzO1xuXHRcdFx0XHR0aGlzLl96ID0gKG0yMyArIG0zMikgLyBzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgcyA9IDIuMCAqIE1hdGguc3FydCgxLjAgKyBtMzMgLSBtMTEgLSBtMjIpO1xuXHRcdFx0XHR0aGlzLl93ID0gKG0yMSAtIG0xMikgLyBzO1xuXHRcdFx0XHR0aGlzLl94ID0gKG0xMyArIG0zMSkgLyBzO1xuXHRcdFx0XHR0aGlzLl95ID0gKG0yMyArIG0zMikgLyBzO1xuXHRcdFx0XHR0aGlzLl96ID0gMC4yNSAqIHM7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0RnJvbVVuaXRWZWN0b3JzKHZGcm9tLCB2VG8pIHtcblx0XHRcdC8vIGFzc3VtZXMgZGlyZWN0aW9uIHZlY3RvcnMgdkZyb20gYW5kIHZUbyBhcmUgbm9ybWFsaXplZFxuXHRcdFx0bGV0IHIgPSB2RnJvbS5kb3QodlRvKSArIDE7XG5cblx0XHRcdGlmIChyIDwgTnVtYmVyLkVQU0lMT04pIHtcblx0XHRcdFx0Ly8gdkZyb20gYW5kIHZUbyBwb2ludCBpbiBvcHBvc2l0ZSBkaXJlY3Rpb25zXG5cdFx0XHRcdHIgPSAwO1xuXG5cdFx0XHRcdGlmIChNYXRoLmFicyh2RnJvbS54KSA+IE1hdGguYWJzKHZGcm9tLnopKSB7XG5cdFx0XHRcdFx0dGhpcy5feCA9IC12RnJvbS55O1xuXHRcdFx0XHRcdHRoaXMuX3kgPSB2RnJvbS54O1xuXHRcdFx0XHRcdHRoaXMuX3ogPSAwO1xuXHRcdFx0XHRcdHRoaXMuX3cgPSByO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0XHRcdHRoaXMuX3kgPSAtdkZyb20uejtcblx0XHRcdFx0XHR0aGlzLl96ID0gdkZyb20ueTtcblx0XHRcdFx0XHR0aGlzLl93ID0gcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gY3Jvc3NWZWN0b3JzKCB2RnJvbSwgdlRvICk7IC8vIGlubGluZWQgdG8gYXZvaWQgY3ljbGljIGRlcGVuZGVuY3kgb24gVmVjdG9yM1xuXHRcdFx0XHR0aGlzLl94ID0gdkZyb20ueSAqIHZUby56IC0gdkZyb20ueiAqIHZUby55O1xuXHRcdFx0XHR0aGlzLl95ID0gdkZyb20ueiAqIHZUby54IC0gdkZyb20ueCAqIHZUby56O1xuXHRcdFx0XHR0aGlzLl96ID0gdkZyb20ueCAqIHZUby55IC0gdkZyb20ueSAqIHZUby54O1xuXHRcdFx0XHR0aGlzLl93ID0gcjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCk7XG5cdFx0fVxuXG5cdFx0YW5nbGVUbyhxKSB7XG5cdFx0XHRyZXR1cm4gMiAqIE1hdGguYWNvcyhNYXRoLmFicyhjbGFtcCh0aGlzLmRvdChxKSwgLTEsIDEpKSk7XG5cdFx0fVxuXG5cdFx0cm90YXRlVG93YXJkcyhxLCBzdGVwKSB7XG5cdFx0XHRjb25zdCBhbmdsZSA9IHRoaXMuYW5nbGVUbyhxKTtcblx0XHRcdGlmIChhbmdsZSA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cdFx0XHRjb25zdCB0ID0gTWF0aC5taW4oMSwgc3RlcCAvIGFuZ2xlKTtcblx0XHRcdHRoaXMuc2xlcnAocSwgdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZGVudGl0eSgpIHtcblx0XHRcdHJldHVybiB0aGlzLnNldCgwLCAwLCAwLCAxKTtcblx0XHR9XG5cblx0XHRpbnZlcnQoKSB7XG5cdFx0XHQvLyBxdWF0ZXJuaW9uIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxuXHRcdFx0cmV0dXJuIHRoaXMuY29uanVnYXRlKCk7XG5cdFx0fVxuXG5cdFx0Y29uanVnYXRlKCkge1xuXHRcdFx0dGhpcy5feCAqPSAtMTtcblx0XHRcdHRoaXMuX3kgKj0gLTE7XG5cdFx0XHR0aGlzLl96ICo9IC0xO1xuXG5cdFx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGRvdCh2KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5feCAqIHYuX3ggKyB0aGlzLl95ICogdi5feSArIHRoaXMuX3ogKiB2Ll96ICsgdGhpcy5fdyAqIHYuX3c7XG5cdFx0fVxuXG5cdFx0bGVuZ3RoU3EoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3c7XG5cdFx0fVxuXG5cdFx0bGVuZ3RoKCkge1xuXHRcdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdyk7XG5cdFx0fVxuXG5cdFx0bm9ybWFsaXplKCkge1xuXHRcdFx0bGV0IGwgPSB0aGlzLmxlbmd0aCgpO1xuXG5cdFx0XHRpZiAobCA9PT0gMCkge1xuXHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0dGhpcy5feSA9IDA7XG5cdFx0XHRcdHRoaXMuX3ogPSAwO1xuXHRcdFx0XHR0aGlzLl93ID0gMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGwgPSAxIC8gbDtcblx0XHRcdFx0dGhpcy5feCA9IHRoaXMuX3ggKiBsO1xuXHRcdFx0XHR0aGlzLl95ID0gdGhpcy5feSAqIGw7XG5cdFx0XHRcdHRoaXMuX3ogPSB0aGlzLl96ICogbDtcblx0XHRcdFx0dGhpcy5fdyA9IHRoaXMuX3cgKiBsO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG11bHRpcGx5KHEsIHApIHtcblx0XHRcdGlmIChwICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5RdWF0ZXJuaW9uOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVF1YXRlcm5pb25zKCBhLCBiICkgaW5zdGVhZC4nKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyhxLCBwKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyh0aGlzLCBxKTtcblx0XHR9XG5cblx0XHRwcmVtdWx0aXBseShxKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKHEsIHRoaXMpO1xuXHRcdH1cblxuXHRcdG11bHRpcGx5UXVhdGVybmlvbnMoYSwgYikge1xuXHRcdFx0Ly8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtXG5cdFx0XHRjb25zdCBxYXggPSBhLl94LFxuXHRcdFx0XHRcdFx0cWF5ID0gYS5feSxcblx0XHRcdFx0XHRcdHFheiA9IGEuX3osXG5cdFx0XHRcdFx0XHRxYXcgPSBhLl93O1xuXHRcdFx0Y29uc3QgcWJ4ID0gYi5feCxcblx0XHRcdFx0XHRcdHFieSA9IGIuX3ksXG5cdFx0XHRcdFx0XHRxYnogPSBiLl96LFxuXHRcdFx0XHRcdFx0cWJ3ID0gYi5fdztcblx0XHRcdHRoaXMuX3ggPSBxYXggKiBxYncgKyBxYXcgKiBxYnggKyBxYXkgKiBxYnogLSBxYXogKiBxYnk7XG5cdFx0XHR0aGlzLl95ID0gcWF5ICogcWJ3ICsgcWF3ICogcWJ5ICsgcWF6ICogcWJ4IC0gcWF4ICogcWJ6O1xuXHRcdFx0dGhpcy5feiA9IHFheiAqIHFidyArIHFhdyAqIHFieiArIHFheCAqIHFieSAtIHFheSAqIHFieDtcblx0XHRcdHRoaXMuX3cgPSBxYXcgKiBxYncgLSBxYXggKiBxYnggLSBxYXkgKiBxYnkgLSBxYXogKiBxYno7XG5cblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2xlcnAocWIsIHQpIHtcblx0XHRcdGlmICh0ID09PSAwKSByZXR1cm4gdGhpcztcblx0XHRcdGlmICh0ID09PSAxKSByZXR1cm4gdGhpcy5jb3B5KHFiKTtcblx0XHRcdGNvbnN0IHggPSB0aGlzLl94LFxuXHRcdFx0XHRcdFx0eSA9IHRoaXMuX3ksXG5cdFx0XHRcdFx0XHR6ID0gdGhpcy5feixcblx0XHRcdFx0XHRcdHcgPSB0aGlzLl93OyAvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL3NsZXJwL1xuXG5cdFx0XHRsZXQgY29zSGFsZlRoZXRhID0gdyAqIHFiLl93ICsgeCAqIHFiLl94ICsgeSAqIHFiLl95ICsgeiAqIHFiLl96O1xuXG5cdFx0XHRpZiAoY29zSGFsZlRoZXRhIDwgMCkge1xuXHRcdFx0XHR0aGlzLl93ID0gLXFiLl93O1xuXHRcdFx0XHR0aGlzLl94ID0gLXFiLl94O1xuXHRcdFx0XHR0aGlzLl95ID0gLXFiLl95O1xuXHRcdFx0XHR0aGlzLl96ID0gLXFiLl96O1xuXHRcdFx0XHRjb3NIYWxmVGhldGEgPSAtY29zSGFsZlRoZXRhO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5jb3B5KHFiKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNvc0hhbGZUaGV0YSA+PSAxLjApIHtcblx0XHRcdFx0dGhpcy5fdyA9IHc7XG5cdFx0XHRcdHRoaXMuX3ggPSB4O1xuXHRcdFx0XHR0aGlzLl95ID0geTtcblx0XHRcdFx0dGhpcy5feiA9IHo7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzcXJTaW5IYWxmVGhldGEgPSAxLjAgLSBjb3NIYWxmVGhldGEgKiBjb3NIYWxmVGhldGE7XG5cblx0XHRcdGlmIChzcXJTaW5IYWxmVGhldGEgPD0gTnVtYmVyLkVQU0lMT04pIHtcblx0XHRcdFx0Y29uc3QgcyA9IDEgLSB0O1xuXHRcdFx0XHR0aGlzLl93ID0gcyAqIHcgKyB0ICogdGhpcy5fdztcblx0XHRcdFx0dGhpcy5feCA9IHMgKiB4ICsgdCAqIHRoaXMuX3g7XG5cdFx0XHRcdHRoaXMuX3kgPSBzICogeSArIHQgKiB0aGlzLl95O1xuXHRcdFx0XHR0aGlzLl96ID0gcyAqIHogKyB0ICogdGhpcy5fejtcblx0XHRcdFx0dGhpcy5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNpbkhhbGZUaGV0YSA9IE1hdGguc3FydChzcXJTaW5IYWxmVGhldGEpO1xuXHRcdFx0Y29uc3QgaGFsZlRoZXRhID0gTWF0aC5hdGFuMihzaW5IYWxmVGhldGEsIGNvc0hhbGZUaGV0YSk7XG5cdFx0XHRjb25zdCByYXRpb0EgPSBNYXRoLnNpbigoMSAtIHQpICogaGFsZlRoZXRhKSAvIHNpbkhhbGZUaGV0YSxcblx0XHRcdFx0XHRcdHJhdGlvQiA9IE1hdGguc2luKHQgKiBoYWxmVGhldGEpIC8gc2luSGFsZlRoZXRhO1xuXHRcdFx0dGhpcy5fdyA9IHcgKiByYXRpb0EgKyB0aGlzLl93ICogcmF0aW9CO1xuXHRcdFx0dGhpcy5feCA9IHggKiByYXRpb0EgKyB0aGlzLl94ICogcmF0aW9CO1xuXHRcdFx0dGhpcy5feSA9IHkgKiByYXRpb0EgKyB0aGlzLl95ICogcmF0aW9CO1xuXHRcdFx0dGhpcy5feiA9IHogKiByYXRpb0EgKyB0aGlzLl96ICogcmF0aW9CO1xuXG5cdFx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNsZXJwUXVhdGVybmlvbnMocWEsIHFiLCB0KSB7XG5cdFx0XHR0aGlzLmNvcHkocWEpLnNsZXJwKHFiLCB0KTtcblx0XHR9XG5cblx0XHRyYW5kb20oKSB7XG5cdFx0XHQvLyBEZXJpdmVkIGZyb20gaHR0cDovL3BsYW5uaW5nLmNzLnVpdWMuZWR1L25vZGUxOTguaHRtbFxuXHRcdFx0Ly8gTm90ZSwgdGhpcyBzb3VyY2UgdXNlcyB3LCB4LCB5LCB6IG9yZGVyaW5nLFxuXHRcdFx0Ly8gc28gd2Ugc3dhcCB0aGUgb3JkZXIgYmVsb3cuXG5cdFx0XHRjb25zdCB1MSA9IE1hdGgucmFuZG9tKCk7XG5cdFx0XHRjb25zdCBzcXJ0MXUxID0gTWF0aC5zcXJ0KDEgLSB1MSk7XG5cdFx0XHRjb25zdCBzcXJ0dTEgPSBNYXRoLnNxcnQodTEpO1xuXHRcdFx0Y29uc3QgdTIgPSAyICogTWF0aC5QSSAqIE1hdGgucmFuZG9tKCk7XG5cdFx0XHRjb25zdCB1MyA9IDIgKiBNYXRoLlBJICogTWF0aC5yYW5kb20oKTtcblx0XHRcdHJldHVybiB0aGlzLnNldChzcXJ0MXUxICogTWF0aC5jb3ModTIpLCBzcXJ0dTEgKiBNYXRoLnNpbih1MyksIHNxcnR1MSAqIE1hdGguY29zKHUzKSwgc3FydDF1MSAqIE1hdGguc2luKHUyKSk7XG5cdFx0fVxuXG5cdFx0ZXF1YWxzKHF1YXRlcm5pb24pIHtcblx0XHRcdHJldHVybiBxdWF0ZXJuaW9uLl94ID09PSB0aGlzLl94ICYmIHF1YXRlcm5pb24uX3kgPT09IHRoaXMuX3kgJiYgcXVhdGVybmlvbi5feiA9PT0gdGhpcy5feiAmJiBxdWF0ZXJuaW9uLl93ID09PSB0aGlzLl93O1xuXHRcdH1cblxuXHRcdGZyb21BcnJheShhcnJheSwgb2Zmc2V0ID0gMCkge1xuXHRcdFx0dGhpcy5feCA9IGFycmF5W29mZnNldF07XG5cdFx0XHR0aGlzLl95ID0gYXJyYXlbb2Zmc2V0ICsgMV07XG5cdFx0XHR0aGlzLl96ID0gYXJyYXlbb2Zmc2V0ICsgMl07XG5cdFx0XHR0aGlzLl93ID0gYXJyYXlbb2Zmc2V0ICsgM107XG5cblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dG9BcnJheShhcnJheSA9IFtdLCBvZmZzZXQgPSAwKSB7XG5cdFx0XHRhcnJheVtvZmZzZXRdID0gdGhpcy5feDtcblx0XHRcdGFycmF5W29mZnNldCArIDFdID0gdGhpcy5feTtcblx0XHRcdGFycmF5W29mZnNldCArIDJdID0gdGhpcy5fejtcblx0XHRcdGFycmF5W29mZnNldCArIDNdID0gdGhpcy5fdztcblx0XHRcdHJldHVybiBhcnJheTtcblx0XHR9XG5cblx0XHRmcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgaW5kZXgpIHtcblx0XHRcdHRoaXMuX3ggPSBhdHRyaWJ1dGUuZ2V0WChpbmRleCk7XG5cdFx0XHR0aGlzLl95ID0gYXR0cmlidXRlLmdldFkoaW5kZXgpO1xuXHRcdFx0dGhpcy5feiA9IGF0dHJpYnV0ZS5nZXRaKGluZGV4KTtcblx0XHRcdHRoaXMuX3cgPSBhdHRyaWJ1dGUuZ2V0VyhpbmRleCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRfb25DaGFuZ2UoY2FsbGJhY2spIHtcblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdF9vbkNoYW5nZUNhbGxiYWNrKCkge31cblxuXHR9XG5cblx0UXVhdGVybmlvbi5wcm90b3R5cGUuaXNRdWF0ZXJuaW9uID0gdHJ1ZTtcblxuXHRjbGFzcyBWZWN0b3IzIHtcblx0XHRjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHogPSAwKSB7XG5cdFx0XHR0aGlzLnggPSB4O1xuXHRcdFx0dGhpcy55ID0geTtcblx0XHRcdHRoaXMueiA9IHo7XG5cdFx0fVxuXG5cdFx0c2V0KHgsIHksIHopIHtcblx0XHRcdGlmICh6ID09PSB1bmRlZmluZWQpIHogPSB0aGlzLno7IC8vIHNwcml0ZS5zY2FsZS5zZXQoeCx5KVxuXG5cdFx0XHR0aGlzLnggPSB4O1xuXHRcdFx0dGhpcy55ID0geTtcblx0XHRcdHRoaXMueiA9IHo7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRTY2FsYXIoc2NhbGFyKSB7XG5cdFx0XHR0aGlzLnggPSBzY2FsYXI7XG5cdFx0XHR0aGlzLnkgPSBzY2FsYXI7XG5cdFx0XHR0aGlzLnogPSBzY2FsYXI7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRYKHgpIHtcblx0XHRcdHRoaXMueCA9IHg7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRZKHkpIHtcblx0XHRcdHRoaXMueSA9IHk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRaKHopIHtcblx0XHRcdHRoaXMueiA9IHo7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRDb21wb25lbnQoaW5kZXgsIHZhbHVlKSB7XG5cdFx0XHRzd2l0Y2ggKGluZGV4KSB7XG5cdFx0XHRcdGNhc2UgMDpcblx0XHRcdFx0XHR0aGlzLnggPSB2YWx1ZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0dGhpcy55ID0gdmFsdWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdHRoaXMueiA9IHZhbHVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGdldENvbXBvbmVudChpbmRleCkge1xuXHRcdFx0c3dpdGNoIChpbmRleCkge1xuXHRcdFx0XHRjYXNlIDA6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMueDtcblxuXHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMueTtcblxuXHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuejtcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNsb25lKCkge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMueCwgdGhpcy55LCB0aGlzLnopO1xuXHRcdH1cblxuXHRcdGNvcHkodikge1xuXHRcdFx0dGhpcy54ID0gdi54O1xuXHRcdFx0dGhpcy55ID0gdi55O1xuXHRcdFx0dGhpcy56ID0gdi56O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0YWRkKHYsIHcpIHtcblx0XHRcdGlmICh3ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5WZWN0b3IzOiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmFkZFZlY3RvcnModiwgdyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMueCArPSB2Lng7XG5cdFx0XHR0aGlzLnkgKz0gdi55O1xuXHRcdFx0dGhpcy56ICs9IHYuejtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGFkZFNjYWxhcihzKSB7XG5cdFx0XHR0aGlzLnggKz0gcztcblx0XHRcdHRoaXMueSArPSBzO1xuXHRcdFx0dGhpcy56ICs9IHM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRhZGRWZWN0b3JzKGEsIGIpIHtcblx0XHRcdHRoaXMueCA9IGEueCArIGIueDtcblx0XHRcdHRoaXMueSA9IGEueSArIGIueTtcblx0XHRcdHRoaXMueiA9IGEueiArIGIuejtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGFkZFNjYWxlZFZlY3Rvcih2LCBzKSB7XG5cdFx0XHR0aGlzLnggKz0gdi54ICogcztcblx0XHRcdHRoaXMueSArPSB2LnkgKiBzO1xuXHRcdFx0dGhpcy56ICs9IHYueiAqIHM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzdWIodiwgdykge1xuXHRcdFx0aWYgKHcgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlZlY3RvcjM6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyh2LCB3KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy54IC09IHYueDtcblx0XHRcdHRoaXMueSAtPSB2Lnk7XG5cdFx0XHR0aGlzLnogLT0gdi56O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c3ViU2NhbGFyKHMpIHtcblx0XHRcdHRoaXMueCAtPSBzO1xuXHRcdFx0dGhpcy55IC09IHM7XG5cdFx0XHR0aGlzLnogLT0gcztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHN1YlZlY3RvcnMoYSwgYikge1xuXHRcdFx0dGhpcy54ID0gYS54IC0gYi54O1xuXHRcdFx0dGhpcy55ID0gYS55IC0gYi55O1xuXHRcdFx0dGhpcy56ID0gYS56IC0gYi56O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bXVsdGlwbHkodiwgdykge1xuXHRcdFx0aWYgKHcgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlZlY3RvcjM6IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5VmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5VmVjdG9ycyh2LCB3KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy54ICo9IHYueDtcblx0XHRcdHRoaXMueSAqPSB2Lnk7XG5cdFx0XHR0aGlzLnogKj0gdi56O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bXVsdGlwbHlTY2FsYXIoc2NhbGFyKSB7XG5cdFx0XHR0aGlzLnggKj0gc2NhbGFyO1xuXHRcdFx0dGhpcy55ICo9IHNjYWxhcjtcblx0XHRcdHRoaXMueiAqPSBzY2FsYXI7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRtdWx0aXBseVZlY3RvcnMoYSwgYikge1xuXHRcdFx0dGhpcy54ID0gYS54ICogYi54O1xuXHRcdFx0dGhpcy55ID0gYS55ICogYi55O1xuXHRcdFx0dGhpcy56ID0gYS56ICogYi56O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0YXBwbHlFdWxlcihldWxlcikge1xuXHRcdFx0aWYgKCEoZXVsZXIgJiYgZXVsZXIuaXNFdWxlcikpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuVmVjdG9yMzogLmFwcGx5RXVsZXIoKSBub3cgZXhwZWN0cyBhbiBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oX3F1YXRlcm5pb24kNC5zZXRGcm9tRXVsZXIoZXVsZXIpKTtcblx0XHR9XG5cblx0XHRhcHBseUF4aXNBbmdsZShheGlzLCBhbmdsZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKF9xdWF0ZXJuaW9uJDQuc2V0RnJvbUF4aXNBbmdsZShheGlzLCBhbmdsZSkpO1xuXHRcdH1cblxuXHRcdGFwcGx5TWF0cml4MyhtKSB7XG5cdFx0XHRjb25zdCB4ID0gdGhpcy54LFxuXHRcdFx0XHRcdFx0eSA9IHRoaXMueSxcblx0XHRcdFx0XHRcdHogPSB0aGlzLno7XG5cdFx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcblx0XHRcdHRoaXMueCA9IGVbMF0gKiB4ICsgZVszXSAqIHkgKyBlWzZdICogejtcblx0XHRcdHRoaXMueSA9IGVbMV0gKiB4ICsgZVs0XSAqIHkgKyBlWzddICogejtcblx0XHRcdHRoaXMueiA9IGVbMl0gKiB4ICsgZVs1XSAqIHkgKyBlWzhdICogejtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGFwcGx5Tm9ybWFsTWF0cml4KG0pIHtcblx0XHRcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4MyhtKS5ub3JtYWxpemUoKTtcblx0XHR9XG5cblx0XHRhcHBseU1hdHJpeDQobSkge1xuXHRcdFx0Y29uc3QgeCA9IHRoaXMueCxcblx0XHRcdFx0XHRcdHkgPSB0aGlzLnksXG5cdFx0XHRcdFx0XHR6ID0gdGhpcy56O1xuXHRcdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cdFx0XHRjb25zdCB3ID0gMSAvIChlWzNdICogeCArIGVbN10gKiB5ICsgZVsxMV0gKiB6ICsgZVsxNV0pO1xuXHRcdFx0dGhpcy54ID0gKGVbMF0gKiB4ICsgZVs0XSAqIHkgKyBlWzhdICogeiArIGVbMTJdKSAqIHc7XG5cdFx0XHR0aGlzLnkgPSAoZVsxXSAqIHggKyBlWzVdICogeSArIGVbOV0gKiB6ICsgZVsxM10pICogdztcblx0XHRcdHRoaXMueiA9IChlWzJdICogeCArIGVbNl0gKiB5ICsgZVsxMF0gKiB6ICsgZVsxNF0pICogdztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGFwcGx5UXVhdGVybmlvbihxKSB7XG5cdFx0XHRjb25zdCB4ID0gdGhpcy54LFxuXHRcdFx0XHRcdFx0eSA9IHRoaXMueSxcblx0XHRcdFx0XHRcdHogPSB0aGlzLno7XG5cdFx0XHRjb25zdCBxeCA9IHEueCxcblx0XHRcdFx0XHRcdHF5ID0gcS55LFxuXHRcdFx0XHRcdFx0cXogPSBxLnosXG5cdFx0XHRcdFx0XHRxdyA9IHEudzsgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWN0b3JcblxuXHRcdFx0Y29uc3QgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG5cdFx0XHRjb25zdCBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcblx0XHRcdGNvbnN0IGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuXHRcdFx0Y29uc3QgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6OyAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG5cblx0XHRcdHRoaXMueCA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG5cdFx0XHR0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuXHRcdFx0dGhpcy56ID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHByb2plY3QoY2FtZXJhKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQoY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSkuYXBwbHlNYXRyaXg0KGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4KTtcblx0XHR9XG5cblx0XHR1bnByb2plY3QoY2FtZXJhKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQoY2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlKS5hcHBseU1hdHJpeDQoY2FtZXJhLm1hdHJpeFdvcmxkKTtcblx0XHR9XG5cblx0XHR0cmFuc2Zvcm1EaXJlY3Rpb24obSkge1xuXHRcdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgYWZmaW5lIG1hdHJpeFxuXHRcdFx0Ly8gdmVjdG9yIGludGVycHJldGVkIGFzIGEgZGlyZWN0aW9uXG5cdFx0XHRjb25zdCB4ID0gdGhpcy54LFxuXHRcdFx0XHRcdFx0eSA9IHRoaXMueSxcblx0XHRcdFx0XHRcdHogPSB0aGlzLno7XG5cdFx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcblx0XHRcdHRoaXMueCA9IGVbMF0gKiB4ICsgZVs0XSAqIHkgKyBlWzhdICogejtcblx0XHRcdHRoaXMueSA9IGVbMV0gKiB4ICsgZVs1XSAqIHkgKyBlWzldICogejtcblx0XHRcdHRoaXMueiA9IGVbMl0gKiB4ICsgZVs2XSAqIHkgKyBlWzEwXSAqIHo7XG5cdFx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKTtcblx0XHR9XG5cblx0XHRkaXZpZGUodikge1xuXHRcdFx0dGhpcy54IC89IHYueDtcblx0XHRcdHRoaXMueSAvPSB2Lnk7XG5cdFx0XHR0aGlzLnogLz0gdi56O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZGl2aWRlU2NhbGFyKHNjYWxhcikge1xuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoMSAvIHNjYWxhcik7XG5cdFx0fVxuXG5cdFx0bWluKHYpIHtcblx0XHRcdHRoaXMueCA9IE1hdGgubWluKHRoaXMueCwgdi54KTtcblx0XHRcdHRoaXMueSA9IE1hdGgubWluKHRoaXMueSwgdi55KTtcblx0XHRcdHRoaXMueiA9IE1hdGgubWluKHRoaXMueiwgdi56KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG1heCh2KSB7XG5cdFx0XHR0aGlzLnggPSBNYXRoLm1heCh0aGlzLngsIHYueCk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLm1heCh0aGlzLnksIHYueSk7XG5cdFx0XHR0aGlzLnogPSBNYXRoLm1heCh0aGlzLnosIHYueik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbGFtcChtaW4sIG1heCkge1xuXHRcdFx0Ly8gYXNzdW1lcyBtaW4gPCBtYXgsIGNvbXBvbmVudHdpc2Vcblx0XHRcdHRoaXMueCA9IE1hdGgubWF4KG1pbi54LCBNYXRoLm1pbihtYXgueCwgdGhpcy54KSk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLm1heChtaW4ueSwgTWF0aC5taW4obWF4LnksIHRoaXMueSkpO1xuXHRcdFx0dGhpcy56ID0gTWF0aC5tYXgobWluLnosIE1hdGgubWluKG1heC56LCB0aGlzLnopKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNsYW1wU2NhbGFyKG1pblZhbCwgbWF4VmFsKSB7XG5cdFx0XHR0aGlzLnggPSBNYXRoLm1heChtaW5WYWwsIE1hdGgubWluKG1heFZhbCwgdGhpcy54KSk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLm1heChtaW5WYWwsIE1hdGgubWluKG1heFZhbCwgdGhpcy55KSk7XG5cdFx0XHR0aGlzLnogPSBNYXRoLm1heChtaW5WYWwsIE1hdGgubWluKG1heFZhbCwgdGhpcy56KSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbGFtcExlbmd0aChtaW4sIG1heCkge1xuXHRcdFx0Y29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblx0XHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhcihsZW5ndGggfHwgMSkubXVsdGlwbHlTY2FsYXIoTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIGxlbmd0aCkpKTtcblx0XHR9XG5cblx0XHRmbG9vcigpIHtcblx0XHRcdHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KTtcblx0XHRcdHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KTtcblx0XHRcdHRoaXMueiA9IE1hdGguZmxvb3IodGhpcy56KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNlaWwoKSB7XG5cdFx0XHR0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcblx0XHRcdHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xuXHRcdFx0dGhpcy56ID0gTWF0aC5jZWlsKHRoaXMueik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRyb3VuZCgpIHtcblx0XHRcdHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcblx0XHRcdHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcblx0XHRcdHRoaXMueiA9IE1hdGgucm91bmQodGhpcy56KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHJvdW5kVG9aZXJvKCkge1xuXHRcdFx0dGhpcy54ID0gdGhpcy54IDwgMCA/IE1hdGguY2VpbCh0aGlzLngpIDogTWF0aC5mbG9vcih0aGlzLngpO1xuXHRcdFx0dGhpcy55ID0gdGhpcy55IDwgMCA/IE1hdGguY2VpbCh0aGlzLnkpIDogTWF0aC5mbG9vcih0aGlzLnkpO1xuXHRcdFx0dGhpcy56ID0gdGhpcy56IDwgMCA/IE1hdGguY2VpbCh0aGlzLnopIDogTWF0aC5mbG9vcih0aGlzLnopO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bmVnYXRlKCkge1xuXHRcdFx0dGhpcy54ID0gLXRoaXMueDtcblx0XHRcdHRoaXMueSA9IC10aGlzLnk7XG5cdFx0XHR0aGlzLnogPSAtdGhpcy56O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZG90KHYpIHtcblx0XHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2Lno7XG5cdFx0fSAvLyBUT0RPIGxlbmd0aFNxdWFyZWQ/XG5cblxuXHRcdGxlbmd0aFNxKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMuejtcblx0XHR9XG5cblx0XHRsZW5ndGgoKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueik7XG5cdFx0fVxuXG5cdFx0bWFuaGF0dGFuTGVuZ3RoKCkge1xuXHRcdFx0cmV0dXJuIE1hdGguYWJzKHRoaXMueCkgKyBNYXRoLmFicyh0aGlzLnkpICsgTWF0aC5hYnModGhpcy56KTtcblx0XHR9XG5cblx0XHRub3JtYWxpemUoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKSB8fCAxKTtcblx0XHR9XG5cblx0XHRzZXRMZW5ndGgobGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihsZW5ndGgpO1xuXHRcdH1cblxuXHRcdGxlcnAodiwgYWxwaGEpIHtcblx0XHRcdHRoaXMueCArPSAodi54IC0gdGhpcy54KSAqIGFscGhhO1xuXHRcdFx0dGhpcy55ICs9ICh2LnkgLSB0aGlzLnkpICogYWxwaGE7XG5cdFx0XHR0aGlzLnogKz0gKHYueiAtIHRoaXMueikgKiBhbHBoYTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGxlcnBWZWN0b3JzKHYxLCB2MiwgYWxwaGEpIHtcblx0XHRcdHRoaXMueCA9IHYxLnggKyAodjIueCAtIHYxLngpICogYWxwaGE7XG5cdFx0XHR0aGlzLnkgPSB2MS55ICsgKHYyLnkgLSB2MS55KSAqIGFscGhhO1xuXHRcdFx0dGhpcy56ID0gdjEueiArICh2Mi56IC0gdjEueikgKiBhbHBoYTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNyb3NzKHYsIHcpIHtcblx0XHRcdGlmICh3ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5WZWN0b3IzOiAuY3Jvc3MoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5jcm9zc1ZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnModiwgdyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyh0aGlzLCB2KTtcblx0XHR9XG5cblx0XHRjcm9zc1ZlY3RvcnMoYSwgYikge1xuXHRcdFx0Y29uc3QgYXggPSBhLngsXG5cdFx0XHRcdFx0XHRheSA9IGEueSxcblx0XHRcdFx0XHRcdGF6ID0gYS56O1xuXHRcdFx0Y29uc3QgYnggPSBiLngsXG5cdFx0XHRcdFx0XHRieSA9IGIueSxcblx0XHRcdFx0XHRcdGJ6ID0gYi56O1xuXHRcdFx0dGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XG5cdFx0XHR0aGlzLnkgPSBheiAqIGJ4IC0gYXggKiBiejtcblx0XHRcdHRoaXMueiA9IGF4ICogYnkgLSBheSAqIGJ4O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0cHJvamVjdE9uVmVjdG9yKHYpIHtcblx0XHRcdGNvbnN0IGRlbm9taW5hdG9yID0gdi5sZW5ndGhTcSgpO1xuXHRcdFx0aWYgKGRlbm9taW5hdG9yID09PSAwKSByZXR1cm4gdGhpcy5zZXQoMCwgMCwgMCk7XG5cdFx0XHRjb25zdCBzY2FsYXIgPSB2LmRvdCh0aGlzKSAvIGRlbm9taW5hdG9yO1xuXHRcdFx0cmV0dXJuIHRoaXMuY29weSh2KS5tdWx0aXBseVNjYWxhcihzY2FsYXIpO1xuXHRcdH1cblxuXHRcdHByb2plY3RPblBsYW5lKHBsYW5lTm9ybWFsKSB7XG5cdFx0XHRfdmVjdG9yJGMuY29weSh0aGlzKS5wcm9qZWN0T25WZWN0b3IocGxhbmVOb3JtYWwpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5zdWIoX3ZlY3RvciRjKTtcblx0XHR9XG5cblx0XHRyZWZsZWN0KG5vcm1hbCkge1xuXHRcdFx0Ly8gcmVmbGVjdCBpbmNpZGVudCB2ZWN0b3Igb2ZmIHBsYW5lIG9ydGhvZ29uYWwgdG8gbm9ybWFsXG5cdFx0XHQvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBoYXZlIHVuaXQgbGVuZ3RoXG5cdFx0XHRyZXR1cm4gdGhpcy5zdWIoX3ZlY3RvciRjLmNvcHkobm9ybWFsKS5tdWx0aXBseVNjYWxhcigyICogdGhpcy5kb3Qobm9ybWFsKSkpO1xuXHRcdH1cblxuXHRcdGFuZ2xlVG8odikge1xuXHRcdFx0Y29uc3QgZGVub21pbmF0b3IgPSBNYXRoLnNxcnQodGhpcy5sZW5ndGhTcSgpICogdi5sZW5ndGhTcSgpKTtcblx0XHRcdGlmIChkZW5vbWluYXRvciA9PT0gMCkgcmV0dXJuIE1hdGguUEkgLyAyO1xuXHRcdFx0Y29uc3QgdGhldGEgPSB0aGlzLmRvdCh2KSAvIGRlbm9taW5hdG9yOyAvLyBjbGFtcCwgdG8gaGFuZGxlIG51bWVyaWNhbCBwcm9ibGVtc1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5hY29zKGNsYW1wKHRoZXRhLCAtMSwgMSkpO1xuXHRcdH1cblxuXHRcdGRpc3RhbmNlVG8odikge1xuXHRcdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKHYpKTtcblx0XHR9XG5cblx0XHRkaXN0YW5jZVRvU3F1YXJlZCh2KSB7XG5cdFx0XHRjb25zdCBkeCA9IHRoaXMueCAtIHYueCxcblx0XHRcdFx0XHRcdGR5ID0gdGhpcy55IC0gdi55LFxuXHRcdFx0XHRcdFx0ZHogPSB0aGlzLnogLSB2Lno7XG5cdFx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6O1xuXHRcdH1cblxuXHRcdG1hbmhhdHRhbkRpc3RhbmNlVG8odikge1xuXHRcdFx0cmV0dXJuIE1hdGguYWJzKHRoaXMueCAtIHYueCkgKyBNYXRoLmFicyh0aGlzLnkgLSB2LnkpICsgTWF0aC5hYnModGhpcy56IC0gdi56KTtcblx0XHR9XG5cblx0XHRzZXRGcm9tU3BoZXJpY2FsKHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnNldEZyb21TcGhlcmljYWxDb29yZHMocy5yYWRpdXMsIHMucGhpLCBzLnRoZXRhKTtcblx0XHR9XG5cblx0XHRzZXRGcm9tU3BoZXJpY2FsQ29vcmRzKHJhZGl1cywgcGhpLCB0aGV0YSkge1xuXHRcdFx0Y29uc3Qgc2luUGhpUmFkaXVzID0gTWF0aC5zaW4ocGhpKSAqIHJhZGl1cztcblx0XHRcdHRoaXMueCA9IHNpblBoaVJhZGl1cyAqIE1hdGguc2luKHRoZXRhKTtcblx0XHRcdHRoaXMueSA9IE1hdGguY29zKHBoaSkgKiByYWRpdXM7XG5cdFx0XHR0aGlzLnogPSBzaW5QaGlSYWRpdXMgKiBNYXRoLmNvcyh0aGV0YSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRGcm9tQ3lsaW5kcmljYWwoYykge1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0RnJvbUN5bGluZHJpY2FsQ29vcmRzKGMucmFkaXVzLCBjLnRoZXRhLCBjLnkpO1xuXHRcdH1cblxuXHRcdHNldEZyb21DeWxpbmRyaWNhbENvb3JkcyhyYWRpdXMsIHRoZXRhLCB5KSB7XG5cdFx0XHR0aGlzLnggPSByYWRpdXMgKiBNYXRoLnNpbih0aGV0YSk7XG5cdFx0XHR0aGlzLnkgPSB5O1xuXHRcdFx0dGhpcy56ID0gcmFkaXVzICogTWF0aC5jb3ModGhldGEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0RnJvbU1hdHJpeFBvc2l0aW9uKG0pIHtcblx0XHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXHRcdFx0dGhpcy54ID0gZVsxMl07XG5cdFx0XHR0aGlzLnkgPSBlWzEzXTtcblx0XHRcdHRoaXMueiA9IGVbMTRdO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0RnJvbU1hdHJpeFNjYWxlKG0pIHtcblx0XHRcdGNvbnN0IHN4ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKG0sIDApLmxlbmd0aCgpO1xuXHRcdFx0Y29uc3Qgc3kgPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4obSwgMSkubGVuZ3RoKCk7XG5cdFx0XHRjb25zdCBzeiA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbihtLCAyKS5sZW5ndGgoKTtcblx0XHRcdHRoaXMueCA9IHN4O1xuXHRcdFx0dGhpcy55ID0gc3k7XG5cdFx0XHR0aGlzLnogPSBzejtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldEZyb21NYXRyaXhDb2x1bW4obSwgaW5kZXgpIHtcblx0XHRcdHJldHVybiB0aGlzLmZyb21BcnJheShtLmVsZW1lbnRzLCBpbmRleCAqIDQpO1xuXHRcdH1cblxuXHRcdHNldEZyb21NYXRyaXgzQ29sdW1uKG0sIGluZGV4KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5mcm9tQXJyYXkobS5lbGVtZW50cywgaW5kZXggKiAzKTtcblx0XHR9XG5cblx0XHRlcXVhbHModikge1xuXHRcdFx0cmV0dXJuIHYueCA9PT0gdGhpcy54ICYmIHYueSA9PT0gdGhpcy55ICYmIHYueiA9PT0gdGhpcy56O1xuXHRcdH1cblxuXHRcdGZyb21BcnJheShhcnJheSwgb2Zmc2V0ID0gMCkge1xuXHRcdFx0dGhpcy54ID0gYXJyYXlbb2Zmc2V0XTtcblx0XHRcdHRoaXMueSA9IGFycmF5W29mZnNldCArIDFdO1xuXHRcdFx0dGhpcy56ID0gYXJyYXlbb2Zmc2V0ICsgMl07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0b0FycmF5KGFycmF5ID0gW10sIG9mZnNldCA9IDApIHtcblx0XHRcdGFycmF5W29mZnNldF0gPSB0aGlzLng7XG5cdFx0XHRhcnJheVtvZmZzZXQgKyAxXSA9IHRoaXMueTtcblx0XHRcdGFycmF5W29mZnNldCArIDJdID0gdGhpcy56O1xuXHRcdFx0cmV0dXJuIGFycmF5O1xuXHRcdH1cblxuXHRcdGZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0KSB7XG5cdFx0XHRpZiAob2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5WZWN0b3IzOiBvZmZzZXQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIC5mcm9tQnVmZmVyQXR0cmlidXRlKCkuJyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5nZXRYKGluZGV4KTtcblx0XHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5nZXRZKGluZGV4KTtcblx0XHRcdHRoaXMueiA9IGF0dHJpYnV0ZS5nZXRaKGluZGV4KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHJhbmRvbSgpIHtcblx0XHRcdHRoaXMueCA9IE1hdGgucmFuZG9tKCk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLnJhbmRvbSgpO1xuXHRcdFx0dGhpcy56ID0gTWF0aC5yYW5kb20oKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHJhbmRvbURpcmVjdGlvbigpIHtcblx0XHRcdC8vIERlcml2ZWQgZnJvbSBodHRwczovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9TcGhlcmVQb2ludFBpY2tpbmcuaHRtbFxuXHRcdFx0Y29uc3QgdSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDI7XG5cdFx0XHRjb25zdCB0ID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xuXHRcdFx0Y29uc3QgZiA9IE1hdGguc3FydCgxIC0gdSAqKiAyKTtcblx0XHRcdHRoaXMueCA9IGYgKiBNYXRoLmNvcyh0KTtcblx0XHRcdHRoaXMueSA9IGYgKiBNYXRoLnNpbih0KTtcblx0XHRcdHRoaXMueiA9IHU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG5cdFx0XHR5aWVsZCB0aGlzLng7XG5cdFx0XHR5aWVsZCB0aGlzLnk7XG5cdFx0XHR5aWVsZCB0aGlzLno7XG5cdFx0fVxuXG5cdH1cblxuXHRWZWN0b3IzLnByb3RvdHlwZS5pc1ZlY3RvcjMgPSB0cnVlO1xuXG5cdGNvbnN0IF92ZWN0b3IkYyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9xdWF0ZXJuaW9uJDQgPSAvKkBfX1BVUkVfXyovbmV3IFF1YXRlcm5pb24oKTtcblxuXHRjbGFzcyBCb3gzIHtcblx0XHRjb25zdHJ1Y3RvcihtaW4gPSBuZXcgVmVjdG9yMygrSW5maW5pdHksICtJbmZpbml0eSwgK0luZmluaXR5KSwgbWF4ID0gbmV3IFZlY3RvcjMoLUluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eSkpIHtcblx0XHRcdHRoaXMubWluID0gbWluO1xuXHRcdFx0dGhpcy5tYXggPSBtYXg7XG5cdFx0fVxuXG5cdFx0c2V0KG1pbiwgbWF4KSB7XG5cdFx0XHR0aGlzLm1pbi5jb3B5KG1pbik7XG5cdFx0XHR0aGlzLm1heC5jb3B5KG1heCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRGcm9tQXJyYXkoYXJyYXkpIHtcblx0XHRcdGxldCBtaW5YID0gK0luZmluaXR5O1xuXHRcdFx0bGV0IG1pblkgPSArSW5maW5pdHk7XG5cdFx0XHRsZXQgbWluWiA9ICtJbmZpbml0eTtcblx0XHRcdGxldCBtYXhYID0gLUluZmluaXR5O1xuXHRcdFx0bGV0IG1heFkgPSAtSW5maW5pdHk7XG5cdFx0XHRsZXQgbWF4WiA9IC1JbmZpbml0eTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICs9IDMpIHtcblx0XHRcdFx0Y29uc3QgeCA9IGFycmF5W2ldO1xuXHRcdFx0XHRjb25zdCB5ID0gYXJyYXlbaSArIDFdO1xuXHRcdFx0XHRjb25zdCB6ID0gYXJyYXlbaSArIDJdO1xuXHRcdFx0XHRpZiAoeCA8IG1pblgpIG1pblggPSB4O1xuXHRcdFx0XHRpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xuXHRcdFx0XHRpZiAoeiA8IG1pblopIG1pblogPSB6O1xuXHRcdFx0XHRpZiAoeCA+IG1heFgpIG1heFggPSB4O1xuXHRcdFx0XHRpZiAoeSA+IG1heFkpIG1heFkgPSB5O1xuXHRcdFx0XHRpZiAoeiA+IG1heFopIG1heFogPSB6O1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm1pbi5zZXQobWluWCwgbWluWSwgbWluWik7XG5cdFx0XHR0aGlzLm1heC5zZXQobWF4WCwgbWF4WSwgbWF4Wik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRGcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSkge1xuXHRcdFx0bGV0IG1pblggPSArSW5maW5pdHk7XG5cdFx0XHRsZXQgbWluWSA9ICtJbmZpbml0eTtcblx0XHRcdGxldCBtaW5aID0gK0luZmluaXR5O1xuXHRcdFx0bGV0IG1heFggPSAtSW5maW5pdHk7XG5cdFx0XHRsZXQgbWF4WSA9IC1JbmZpbml0eTtcblx0XHRcdGxldCBtYXhaID0gLUluZmluaXR5O1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGF0dHJpYnV0ZS5jb3VudDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjb25zdCB4ID0gYXR0cmlidXRlLmdldFgoaSk7XG5cdFx0XHRcdGNvbnN0IHkgPSBhdHRyaWJ1dGUuZ2V0WShpKTtcblx0XHRcdFx0Y29uc3QgeiA9IGF0dHJpYnV0ZS5nZXRaKGkpO1xuXHRcdFx0XHRpZiAoeCA8IG1pblgpIG1pblggPSB4O1xuXHRcdFx0XHRpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xuXHRcdFx0XHRpZiAoeiA8IG1pblopIG1pblogPSB6O1xuXHRcdFx0XHRpZiAoeCA+IG1heFgpIG1heFggPSB4O1xuXHRcdFx0XHRpZiAoeSA+IG1heFkpIG1heFkgPSB5O1xuXHRcdFx0XHRpZiAoeiA+IG1heFopIG1heFogPSB6O1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm1pbi5zZXQobWluWCwgbWluWSwgbWluWik7XG5cdFx0XHR0aGlzLm1heC5zZXQobWF4WCwgbWF4WSwgbWF4Wik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRGcm9tUG9pbnRzKHBvaW50cykge1xuXHRcdFx0dGhpcy5tYWtlRW1wdHkoKTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KHBvaW50c1tpXSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldEZyb21DZW50ZXJBbmRTaXplKGNlbnRlciwgc2l6ZSkge1xuXHRcdFx0Y29uc3QgaGFsZlNpemUgPSBfdmVjdG9yJGIuY29weShzaXplKS5tdWx0aXBseVNjYWxhcigwLjUpO1xuXG5cdFx0XHR0aGlzLm1pbi5jb3B5KGNlbnRlcikuc3ViKGhhbGZTaXplKTtcblx0XHRcdHRoaXMubWF4LmNvcHkoY2VudGVyKS5hZGQoaGFsZlNpemUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0RnJvbU9iamVjdChvYmplY3QpIHtcblx0XHRcdHRoaXMubWFrZUVtcHR5KCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5leHBhbmRCeU9iamVjdChvYmplY3QpO1xuXHRcdH1cblxuXHRcdGNsb25lKCkge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcblx0XHR9XG5cblx0XHRjb3B5KGJveCkge1xuXHRcdFx0dGhpcy5taW4uY29weShib3gubWluKTtcblx0XHRcdHRoaXMubWF4LmNvcHkoYm94Lm1heCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRtYWtlRW1wdHkoKSB7XG5cdFx0XHR0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9IHRoaXMubWluLnogPSArSW5maW5pdHk7XG5cdFx0XHR0aGlzLm1heC54ID0gdGhpcy5tYXgueSA9IHRoaXMubWF4LnogPSAtSW5maW5pdHk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpc0VtcHR5KCkge1xuXHRcdFx0Ly8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcblx0XHRcdHJldHVybiB0aGlzLm1heC54IDwgdGhpcy5taW4ueCB8fCB0aGlzLm1heC55IDwgdGhpcy5taW4ueSB8fCB0aGlzLm1heC56IDwgdGhpcy5taW4uejtcblx0XHR9XG5cblx0XHRnZXRDZW50ZXIodGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyB0YXJnZXQuc2V0KDAsIDAsIDApIDogdGFyZ2V0LmFkZFZlY3RvcnModGhpcy5taW4sIHRoaXMubWF4KS5tdWx0aXBseVNjYWxhcigwLjUpO1xuXHRcdH1cblxuXHRcdGdldFNpemUodGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyB0YXJnZXQuc2V0KDAsIDAsIDApIDogdGFyZ2V0LnN1YlZlY3RvcnModGhpcy5tYXgsIHRoaXMubWluKTtcblx0XHR9XG5cblx0XHRleHBhbmRCeVBvaW50KHBvaW50KSB7XG5cdFx0XHR0aGlzLm1pbi5taW4ocG9pbnQpO1xuXHRcdFx0dGhpcy5tYXgubWF4KHBvaW50KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGV4cGFuZEJ5VmVjdG9yKHZlY3Rvcikge1xuXHRcdFx0dGhpcy5taW4uc3ViKHZlY3Rvcik7XG5cdFx0XHR0aGlzLm1heC5hZGQodmVjdG9yKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGV4cGFuZEJ5U2NhbGFyKHNjYWxhcikge1xuXHRcdFx0dGhpcy5taW4uYWRkU2NhbGFyKC1zY2FsYXIpO1xuXHRcdFx0dGhpcy5tYXguYWRkU2NhbGFyKHNjYWxhcik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRleHBhbmRCeU9iamVjdChvYmplY3QpIHtcblx0XHRcdC8vIENvbXB1dGVzIHRoZSB3b3JsZC1heGlzLWFsaWduZWQgYm91bmRpbmcgYm94IG9mIGFuIG9iamVjdCAoaW5jbHVkaW5nIGl0cyBjaGlsZHJlbiksXG5cdFx0XHQvLyBhY2NvdW50aW5nIGZvciBib3RoIHRoZSBvYmplY3QncywgYW5kIGNoaWxkcmVuJ3MsIHdvcmxkIHRyYW5zZm9ybXNcblx0XHRcdG9iamVjdC51cGRhdGVXb3JsZE1hdHJpeChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cblx0XHRcdGlmIChnZW9tZXRyeSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmIChnZW9tZXRyeS5ib3VuZGluZ0JveCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2JveCQzLmNvcHkoZ2VvbWV0cnkuYm91bmRpbmdCb3gpO1xuXG5cdFx0XHRcdF9ib3gkMy5hcHBseU1hdHJpeDQob2JqZWN0Lm1hdHJpeFdvcmxkKTtcblxuXHRcdFx0XHR0aGlzLnVuaW9uKF9ib3gkMyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR0aGlzLmV4cGFuZEJ5T2JqZWN0KGNoaWxkcmVuW2ldKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29udGFpbnNQb2ludChwb2ludCkge1xuXHRcdFx0cmV0dXJuIHBvaW50LnggPCB0aGlzLm1pbi54IHx8IHBvaW50LnggPiB0aGlzLm1heC54IHx8IHBvaW50LnkgPCB0aGlzLm1pbi55IHx8IHBvaW50LnkgPiB0aGlzLm1heC55IHx8IHBvaW50LnogPCB0aGlzLm1pbi56IHx8IHBvaW50LnogPiB0aGlzLm1heC56ID8gZmFsc2UgOiB0cnVlO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5zQm94KGJveCkge1xuXHRcdFx0cmV0dXJuIHRoaXMubWluLnggPD0gYm94Lm1pbi54ICYmIGJveC5tYXgueCA8PSB0aGlzLm1heC54ICYmIHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICYmIGJveC5tYXgueSA8PSB0aGlzLm1heC55ICYmIHRoaXMubWluLnogPD0gYm94Lm1pbi56ICYmIGJveC5tYXgueiA8PSB0aGlzLm1heC56O1xuXHRcdH1cblxuXHRcdGdldFBhcmFtZXRlcihwb2ludCwgdGFyZ2V0KSB7XG5cdFx0XHQvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxuXHRcdFx0Ly8gaGFzIGEgc2l6ZSBkaW1lbnNpb24gb2YgMC5cblx0XHRcdHJldHVybiB0YXJnZXQuc2V0KChwb2ludC54IC0gdGhpcy5taW4ueCkgLyAodGhpcy5tYXgueCAtIHRoaXMubWluLngpLCAocG9pbnQueSAtIHRoaXMubWluLnkpIC8gKHRoaXMubWF4LnkgLSB0aGlzLm1pbi55KSwgKHBvaW50LnogLSB0aGlzLm1pbi56KSAvICh0aGlzLm1heC56IC0gdGhpcy5taW4ueikpO1xuXHRcdH1cblxuXHRcdGludGVyc2VjdHNCb3goYm94KSB7XG5cdFx0XHQvLyB1c2luZyA2IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9ucy5cblx0XHRcdHJldHVybiBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHwgYm94Lm1heC55IDwgdGhpcy5taW4ueSB8fCBib3gubWluLnkgPiB0aGlzLm1heC55IHx8IGJveC5tYXgueiA8IHRoaXMubWluLnogfHwgYm94Lm1pbi56ID4gdGhpcy5tYXgueiA/IGZhbHNlIDogdHJ1ZTtcblx0XHR9XG5cblx0XHRpbnRlcnNlY3RzU3BoZXJlKHNwaGVyZSkge1xuXHRcdFx0Ly8gRmluZCB0aGUgcG9pbnQgb24gdGhlIEFBQkIgY2xvc2VzdCB0byB0aGUgc3BoZXJlIGNlbnRlci5cblx0XHRcdHRoaXMuY2xhbXBQb2ludChzcGhlcmUuY2VudGVyLCBfdmVjdG9yJGIpOyAvLyBJZiB0aGF0IHBvaW50IGlzIGluc2lkZSB0aGUgc3BoZXJlLCB0aGUgQUFCQiBhbmQgc3BoZXJlIGludGVyc2VjdC5cblxuXHRcdFx0cmV0dXJuIF92ZWN0b3IkYi5kaXN0YW5jZVRvU3F1YXJlZChzcGhlcmUuY2VudGVyKSA8PSBzcGhlcmUucmFkaXVzICogc3BoZXJlLnJhZGl1cztcblx0XHR9XG5cblx0XHRpbnRlcnNlY3RzUGxhbmUocGxhbmUpIHtcblx0XHRcdC8vIFdlIGNvbXB1dGUgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gZG90IHByb2R1Y3QgdmFsdWVzLiBJZiB0aG9zZSB2YWx1ZXNcblx0XHRcdC8vIGFyZSBvbiB0aGUgc2FtZSBzaWRlIChiYWNrIG9yIGZyb250KSBvZiB0aGUgcGxhbmUsIHRoZW4gdGhlcmUgaXMgbm8gaW50ZXJzZWN0aW9uLlxuXHRcdFx0bGV0IG1pbiwgbWF4O1xuXG5cdFx0XHRpZiAocGxhbmUubm9ybWFsLnggPiAwKSB7XG5cdFx0XHRcdG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDtcblx0XHRcdFx0bWF4ID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1heC54O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWluID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1heC54O1xuXHRcdFx0XHRtYXggPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWluLng7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChwbGFuZS5ub3JtYWwueSA+IDApIHtcblx0XHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5taW4ueTtcblx0XHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWF4Lnk7XG5cdFx0XHRcdG1heCArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWluLnk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChwbGFuZS5ub3JtYWwueiA+IDApIHtcblx0XHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5taW4uejtcblx0XHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5tYXguejtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWF4Lno7XG5cdFx0XHRcdG1heCArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtaW4gPD0gLXBsYW5lLmNvbnN0YW50ICYmIG1heCA+PSAtcGxhbmUuY29uc3RhbnQ7XG5cdFx0fVxuXG5cdFx0aW50ZXJzZWN0c1RyaWFuZ2xlKHRyaWFuZ2xlKSB7XG5cdFx0XHRpZiAodGhpcy5pc0VtcHR5KCkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSAvLyBjb21wdXRlIGJveCBjZW50ZXIgYW5kIGV4dGVudHNcblxuXG5cdFx0XHR0aGlzLmdldENlbnRlcihfY2VudGVyKTtcblxuXHRcdFx0X2V4dGVudHMuc3ViVmVjdG9ycyh0aGlzLm1heCwgX2NlbnRlcik7IC8vIHRyYW5zbGF0ZSB0cmlhbmdsZSB0byBhYWJiIG9yaWdpblxuXG5cblx0XHRcdF92MCQyLnN1YlZlY3RvcnModHJpYW5nbGUuYSwgX2NlbnRlcik7XG5cblx0XHRcdF92MSQ3LnN1YlZlY3RvcnModHJpYW5nbGUuYiwgX2NlbnRlcik7XG5cblx0XHRcdF92MiQzLnN1YlZlY3RvcnModHJpYW5nbGUuYywgX2NlbnRlcik7IC8vIGNvbXB1dGUgZWRnZSB2ZWN0b3JzIGZvciB0cmlhbmdsZVxuXG5cblx0XHRcdF9mMC5zdWJWZWN0b3JzKF92MSQ3LCBfdjAkMik7XG5cblx0XHRcdF9mMS5zdWJWZWN0b3JzKF92MiQzLCBfdjEkNyk7XG5cblx0XHRcdF9mMi5zdWJWZWN0b3JzKF92MCQyLCBfdjIkMyk7IC8vIHRlc3QgYWdhaW5zdCBheGVzIHRoYXQgYXJlIGdpdmVuIGJ5IGNyb3NzIHByb2R1Y3QgY29tYmluYXRpb25zIG9mIHRoZSBlZGdlcyBvZiB0aGUgdHJpYW5nbGUgYW5kIHRoZSBlZGdlcyBvZiB0aGUgYWFiYlxuXHRcdFx0Ly8gbWFrZSBhbiBheGlzIHRlc3Rpbmcgb2YgZWFjaCBvZiB0aGUgMyBzaWRlcyBvZiB0aGUgYWFiYiBhZ2FpbnN0IGVhY2ggb2YgdGhlIDMgc2lkZXMgb2YgdGhlIHRyaWFuZ2xlID0gOSBheGlzIG9mIHNlcGFyYXRpb25cblx0XHRcdC8vIGF4aXNfaWogPSB1X2kgeCBmX2ogKHUwLCB1MSwgdTIgPSBmYWNlIG5vcm1hbHMgb2YgYWFiYiA9IHgseSx6IGF4ZXMgdmVjdG9ycyBzaW5jZSBhYWJiIGlzIGF4aXMgYWxpZ25lZClcblxuXG5cdFx0XHRsZXQgYXhlcyA9IFswLCAtX2YwLnosIF9mMC55LCAwLCAtX2YxLnosIF9mMS55LCAwLCAtX2YyLnosIF9mMi55LCBfZjAueiwgMCwgLV9mMC54LCBfZjEueiwgMCwgLV9mMS54LCBfZjIueiwgMCwgLV9mMi54LCAtX2YwLnksIF9mMC54LCAwLCAtX2YxLnksIF9mMS54LCAwLCAtX2YyLnksIF9mMi54LCAwXTtcblxuXHRcdFx0aWYgKCFzYXRGb3JBeGVzKGF4ZXMsIF92MCQyLCBfdjEkNywgX3YyJDMsIF9leHRlbnRzKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IC8vIHRlc3QgMyBmYWNlIG5vcm1hbHMgZnJvbSB0aGUgYWFiYlxuXG5cblx0XHRcdGF4ZXMgPSBbMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMV07XG5cblx0XHRcdGlmICghc2F0Rm9yQXhlcyhheGVzLCBfdjAkMiwgX3YxJDcsIF92MiQzLCBfZXh0ZW50cykpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSAvLyBmaW5hbGx5IHRlc3RpbmcgdGhlIGZhY2Ugbm9ybWFsIG9mIHRoZSB0cmlhbmdsZVxuXHRcdFx0Ly8gdXNlIGFscmVhZHkgZXhpc3RpbmcgdHJpYW5nbGUgZWRnZSB2ZWN0b3JzIGhlcmVcblxuXG5cdFx0XHRfdHJpYW5nbGVOb3JtYWwuY3Jvc3NWZWN0b3JzKF9mMCwgX2YxKTtcblxuXHRcdFx0YXhlcyA9IFtfdHJpYW5nbGVOb3JtYWwueCwgX3RyaWFuZ2xlTm9ybWFsLnksIF90cmlhbmdsZU5vcm1hbC56XTtcblx0XHRcdHJldHVybiBzYXRGb3JBeGVzKGF4ZXMsIF92MCQyLCBfdjEkNywgX3YyJDMsIF9leHRlbnRzKTtcblx0XHR9XG5cblx0XHRjbGFtcFBvaW50KHBvaW50LCB0YXJnZXQpIHtcblx0XHRcdHJldHVybiB0YXJnZXQuY29weShwb2ludCkuY2xhbXAodGhpcy5taW4sIHRoaXMubWF4KTtcblx0XHR9XG5cblx0XHRkaXN0YW5jZVRvUG9pbnQocG9pbnQpIHtcblx0XHRcdGNvbnN0IGNsYW1wZWRQb2ludCA9IF92ZWN0b3IkYi5jb3B5KHBvaW50KS5jbGFtcCh0aGlzLm1pbiwgdGhpcy5tYXgpO1xuXG5cdFx0XHRyZXR1cm4gY2xhbXBlZFBvaW50LnN1Yihwb2ludCkubGVuZ3RoKCk7XG5cdFx0fVxuXG5cdFx0Z2V0Qm91bmRpbmdTcGhlcmUodGFyZ2V0KSB7XG5cdFx0XHR0aGlzLmdldENlbnRlcih0YXJnZXQuY2VudGVyKTtcblx0XHRcdHRhcmdldC5yYWRpdXMgPSB0aGlzLmdldFNpemUoX3ZlY3RvciRiKS5sZW5ndGgoKSAqIDAuNTtcblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cdFx0fVxuXG5cdFx0aW50ZXJzZWN0KGJveCkge1xuXHRcdFx0dGhpcy5taW4ubWF4KGJveC5taW4pO1xuXHRcdFx0dGhpcy5tYXgubWluKGJveC5tYXgpOyAvLyBlbnN1cmUgdGhhdCBpZiB0aGVyZSBpcyBubyBvdmVybGFwLCB0aGUgcmVzdWx0IGlzIGZ1bGx5IGVtcHR5LCBub3Qgc2xpZ2h0bHkgZW1wdHkgd2l0aCBub24taW5mLytpbmYgdmFsdWVzIHRoYXQgd2lsbCBjYXVzZSBzdWJzZXF1ZW5jZSBpbnRlcnNlY3RzIHRvIGVycm9uZW91c2x5IHJldHVybiB2YWxpZCB2YWx1ZXMuXG5cblx0XHRcdGlmICh0aGlzLmlzRW1wdHkoKSkgdGhpcy5tYWtlRW1wdHkoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHVuaW9uKGJveCkge1xuXHRcdFx0dGhpcy5taW4ubWluKGJveC5taW4pO1xuXHRcdFx0dGhpcy5tYXgubWF4KGJveC5tYXgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0YXBwbHlNYXRyaXg0KG1hdHJpeCkge1xuXHRcdFx0Ly8gdHJhbnNmb3JtIG9mIGVtcHR5IGJveCBpcyBhbiBlbXB0eSBib3guXG5cdFx0XHRpZiAodGhpcy5pc0VtcHR5KCkpIHJldHVybiB0aGlzOyAvLyBOT1RFOiBJIGFtIHVzaW5nIGEgYmluYXJ5IHBhdHRlcm4gdG8gc3BlY2lmeSBhbGwgMl4zIGNvbWJpbmF0aW9ucyBiZWxvd1xuXG5cdFx0XHRfcG9pbnRzWzBdLnNldCh0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQobWF0cml4KTsgLy8gMDAwXG5cblxuXHRcdFx0X3BvaW50c1sxXS5zZXQodGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KG1hdHJpeCk7IC8vIDAwMVxuXG5cblx0XHRcdF9wb2ludHNbMl0uc2V0KHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWluLnopLmFwcGx5TWF0cml4NChtYXRyaXgpOyAvLyAwMTBcblxuXG5cdFx0XHRfcG9pbnRzWzNdLnNldCh0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1heC56KS5hcHBseU1hdHJpeDQobWF0cml4KTsgLy8gMDExXG5cblxuXHRcdFx0X3BvaW50c1s0XS5zZXQodGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueikuYXBwbHlNYXRyaXg0KG1hdHJpeCk7IC8vIDEwMFxuXG5cblx0XHRcdF9wb2ludHNbNV0uc2V0KHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWF4LnopLmFwcGx5TWF0cml4NChtYXRyaXgpOyAvLyAxMDFcblxuXG5cdFx0XHRfcG9pbnRzWzZdLnNldCh0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQobWF0cml4KTsgLy8gMTEwXG5cblxuXHRcdFx0X3BvaW50c1s3XS5zZXQodGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KG1hdHJpeCk7IC8vIDExMVxuXG5cblx0XHRcdHRoaXMuc2V0RnJvbVBvaW50cyhfcG9pbnRzKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRyYW5zbGF0ZShvZmZzZXQpIHtcblx0XHRcdHRoaXMubWluLmFkZChvZmZzZXQpO1xuXHRcdFx0dGhpcy5tYXguYWRkKG9mZnNldCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRlcXVhbHMoYm94KSB7XG5cdFx0XHRyZXR1cm4gYm94Lm1pbi5lcXVhbHModGhpcy5taW4pICYmIGJveC5tYXguZXF1YWxzKHRoaXMubWF4KTtcblx0XHR9XG5cblx0fVxuXG5cdEJveDMucHJvdG90eXBlLmlzQm94MyA9IHRydWU7XG5cdGNvbnN0IF9wb2ludHMgPSBbLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCksIC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpLCAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKSwgLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCksIC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpLCAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKSwgLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCksIC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpXTtcblxuXHRjb25zdCBfdmVjdG9yJGIgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfYm94JDMgPSAvKkBfX1BVUkVfXyovbmV3IEJveDMoKTsgLy8gdHJpYW5nbGUgY2VudGVyZWQgdmVydGljZXNcblxuXG5cdGNvbnN0IF92MCQyID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3YxJDcgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfdjIkMyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpOyAvLyB0cmlhbmdsZSBlZGdlIHZlY3RvcnNcblxuXG5cdGNvbnN0IF9mMCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9mMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9mMiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9jZW50ZXIgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfZXh0ZW50cyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF90cmlhbmdsZU5vcm1hbCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF90ZXN0QXhpcyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGZ1bmN0aW9uIHNhdEZvckF4ZXMoYXhlcywgdjAsIHYxLCB2MiwgZXh0ZW50cykge1xuXHRcdGZvciAobGV0IGkgPSAwLCBqID0gYXhlcy5sZW5ndGggLSAzOyBpIDw9IGo7IGkgKz0gMykge1xuXHRcdFx0X3Rlc3RBeGlzLmZyb21BcnJheShheGVzLCBpKTsgLy8gcHJvamVjdCB0aGUgYWFiYiBvbnRvIHRoZSBzZXBlcmF0aW5nIGF4aXNcblxuXG5cdFx0XHRjb25zdCByID0gZXh0ZW50cy54ICogTWF0aC5hYnMoX3Rlc3RBeGlzLngpICsgZXh0ZW50cy55ICogTWF0aC5hYnMoX3Rlc3RBeGlzLnkpICsgZXh0ZW50cy56ICogTWF0aC5hYnMoX3Rlc3RBeGlzLnopOyAvLyBwcm9qZWN0IGFsbCAzIHZlcnRpY2VzIG9mIHRoZSB0cmlhbmdsZSBvbnRvIHRoZSBzZXBlcmF0aW5nIGF4aXNcblxuXHRcdFx0Y29uc3QgcDAgPSB2MC5kb3QoX3Rlc3RBeGlzKTtcblx0XHRcdGNvbnN0IHAxID0gdjEuZG90KF90ZXN0QXhpcyk7XG5cdFx0XHRjb25zdCBwMiA9IHYyLmRvdChfdGVzdEF4aXMpOyAvLyBhY3R1YWwgdGVzdCwgYmFzaWNhbGx5IHNlZSBpZiBlaXRoZXIgb2YgdGhlIG1vc3QgZXh0cmVtZSBvZiB0aGUgdHJpYW5nbGUgcG9pbnRzIGludGVyc2VjdHMgclxuXG5cdFx0XHRpZiAoTWF0aC5tYXgoLU1hdGgubWF4KHAwLCBwMSwgcDIpLCBNYXRoLm1pbihwMCwgcDEsIHAyKSkgPiByKSB7XG5cdFx0XHRcdC8vIHBvaW50cyBvZiB0aGUgcHJvamVjdGVkIHRyaWFuZ2xlIGFyZSBvdXRzaWRlIHRoZSBwcm9qZWN0ZWQgaGFsZi1sZW5ndGggb2YgdGhlIGFhYmJcblx0XHRcdFx0Ly8gdGhlIGF4aXMgaXMgc2VwZXJhdGluZyBhbmQgd2UgY2FuIGV4aXRcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Y29uc3QgX2JveCQyID0gLypAX19QVVJFX18qL25ldyBCb3gzKCk7XG5cblx0Y29uc3QgX3YxJDYgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfdG9GYXJ0aGVzdFBvaW50ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3RvUG9pbnQgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjbGFzcyBTcGhlcmUge1xuXHRcdGNvbnN0cnVjdG9yKGNlbnRlciA9IG5ldyBWZWN0b3IzKCksIHJhZGl1cyA9IC0xKSB7XG5cdFx0XHR0aGlzLmNlbnRlciA9IGNlbnRlcjtcblx0XHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xuXHRcdH1cblxuXHRcdHNldChjZW50ZXIsIHJhZGl1cykge1xuXHRcdFx0dGhpcy5jZW50ZXIuY29weShjZW50ZXIpO1xuXHRcdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRGcm9tUG9pbnRzKHBvaW50cywgb3B0aW9uYWxDZW50ZXIpIHtcblx0XHRcdGNvbnN0IGNlbnRlciA9IHRoaXMuY2VudGVyO1xuXG5cdFx0XHRpZiAob3B0aW9uYWxDZW50ZXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjZW50ZXIuY29weShvcHRpb25hbENlbnRlcik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfYm94JDIuc2V0RnJvbVBvaW50cyhwb2ludHMpLmdldENlbnRlcihjZW50ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgbWF4UmFkaXVzU3EgPSAwO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRtYXhSYWRpdXNTcSA9IE1hdGgubWF4KG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQocG9pbnRzW2ldKSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMucmFkaXVzID0gTWF0aC5zcXJ0KG1heFJhZGl1c1NxKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNvcHkoc3BoZXJlKSB7XG5cdFx0XHR0aGlzLmNlbnRlci5jb3B5KHNwaGVyZS5jZW50ZXIpO1xuXHRcdFx0dGhpcy5yYWRpdXMgPSBzcGhlcmUucmFkaXVzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0aXNFbXB0eSgpIHtcblx0XHRcdHJldHVybiB0aGlzLnJhZGl1cyA8IDA7XG5cdFx0fVxuXG5cdFx0bWFrZUVtcHR5KCkge1xuXHRcdFx0dGhpcy5jZW50ZXIuc2V0KDAsIDAsIDApO1xuXHRcdFx0dGhpcy5yYWRpdXMgPSAtMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcblx0XHRcdHJldHVybiBwb2ludC5kaXN0YW5jZVRvU3F1YXJlZCh0aGlzLmNlbnRlcikgPD0gdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cztcblx0XHR9XG5cblx0XHRkaXN0YW5jZVRvUG9pbnQocG9pbnQpIHtcblx0XHRcdHJldHVybiBwb2ludC5kaXN0YW5jZVRvKHRoaXMuY2VudGVyKSAtIHRoaXMucmFkaXVzO1xuXHRcdH1cblxuXHRcdGludGVyc2VjdHNTcGhlcmUoc3BoZXJlKSB7XG5cdFx0XHRjb25zdCByYWRpdXNTdW0gPSB0aGlzLnJhZGl1cyArIHNwaGVyZS5yYWRpdXM7XG5cdFx0XHRyZXR1cm4gc3BoZXJlLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCh0aGlzLmNlbnRlcikgPD0gcmFkaXVzU3VtICogcmFkaXVzU3VtO1xuXHRcdH1cblxuXHRcdGludGVyc2VjdHNCb3goYm94KSB7XG5cdFx0XHRyZXR1cm4gYm94LmludGVyc2VjdHNTcGhlcmUodGhpcyk7XG5cdFx0fVxuXG5cdFx0aW50ZXJzZWN0c1BsYW5lKHBsYW5lKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5hYnMocGxhbmUuZGlzdGFuY2VUb1BvaW50KHRoaXMuY2VudGVyKSkgPD0gdGhpcy5yYWRpdXM7XG5cdFx0fVxuXG5cdFx0Y2xhbXBQb2ludChwb2ludCwgdGFyZ2V0KSB7XG5cdFx0XHRjb25zdCBkZWx0YUxlbmd0aFNxID0gdGhpcy5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQocG9pbnQpO1xuXHRcdFx0dGFyZ2V0LmNvcHkocG9pbnQpO1xuXG5cdFx0XHRpZiAoZGVsdGFMZW5ndGhTcSA+IHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMpIHtcblx0XHRcdFx0dGFyZ2V0LnN1Yih0aGlzLmNlbnRlcikubm9ybWFsaXplKCk7XG5cdFx0XHRcdHRhcmdldC5tdWx0aXBseVNjYWxhcih0aGlzLnJhZGl1cykuYWRkKHRoaXMuY2VudGVyKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRnZXRCb3VuZGluZ0JveCh0YXJnZXQpIHtcblx0XHRcdGlmICh0aGlzLmlzRW1wdHkoKSkge1xuXHRcdFx0XHQvLyBFbXB0eSBzcGhlcmUgcHJvZHVjZXMgZW1wdHkgYm91bmRpbmcgYm94XG5cdFx0XHRcdHRhcmdldC5tYWtlRW1wdHkoKTtcblx0XHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHRcdH1cblxuXHRcdFx0dGFyZ2V0LnNldCh0aGlzLmNlbnRlciwgdGhpcy5jZW50ZXIpO1xuXHRcdFx0dGFyZ2V0LmV4cGFuZEJ5U2NhbGFyKHRoaXMucmFkaXVzKTtcblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cdFx0fVxuXG5cdFx0YXBwbHlNYXRyaXg0KG1hdHJpeCkge1xuXHRcdFx0dGhpcy5jZW50ZXIuYXBwbHlNYXRyaXg0KG1hdHJpeCk7XG5cdFx0XHR0aGlzLnJhZGl1cyA9IHRoaXMucmFkaXVzICogbWF0cml4LmdldE1heFNjYWxlT25BeGlzKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0cmFuc2xhdGUob2Zmc2V0KSB7XG5cdFx0XHR0aGlzLmNlbnRlci5hZGQob2Zmc2V0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGV4cGFuZEJ5UG9pbnQocG9pbnQpIHtcblx0XHRcdC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2p1ai9NYXRoR2VvTGliL2Jsb2IvMjk0MGI5OWI5OWNmZTU3NWRkNDUxMDNlZjIwZjQwMTlkZWUxNWI1NC9zcmMvR2VvbWV0cnkvU3BoZXJlLmNwcCNMNjQ5LUw2NzFcblx0XHRcdF90b1BvaW50LnN1YlZlY3RvcnMocG9pbnQsIHRoaXMuY2VudGVyKTtcblxuXHRcdFx0Y29uc3QgbGVuZ3RoU3EgPSBfdG9Qb2ludC5sZW5ndGhTcSgpO1xuXG5cdFx0XHRpZiAobGVuZ3RoU3EgPiB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzKSB7XG5cdFx0XHRcdGNvbnN0IGxlbmd0aCA9IE1hdGguc3FydChsZW5ndGhTcSk7XG5cdFx0XHRcdGNvbnN0IG1pc3NpbmdSYWRpdXNIYWxmID0gKGxlbmd0aCAtIHRoaXMucmFkaXVzKSAqIDAuNTsgLy8gTnVkZ2UgdGhpcyBzcGhlcmUgdG93YXJkcyB0aGUgdGFyZ2V0IHBvaW50LiBBZGQgaGFsZiB0aGUgbWlzc2luZyBkaXN0YW5jZSB0byByYWRpdXMsXG5cdFx0XHRcdC8vIGFuZCB0aGUgb3RoZXIgaGFsZiB0byBwb3NpdGlvbi4gVGhpcyBnaXZlcyBhIHRpZ2h0ZXIgZW5jbG9zdXJlLCBpbnN0ZWFkIG9mIGlmXG5cdFx0XHRcdC8vIHRoZSB3aG9sZSBtaXNzaW5nIGRpc3RhbmNlIHdlcmUganVzdCBhZGRlZCB0byByYWRpdXMuXG5cblx0XHRcdFx0dGhpcy5jZW50ZXIuYWRkKF90b1BvaW50Lm11bHRpcGx5U2NhbGFyKG1pc3NpbmdSYWRpdXNIYWxmIC8gbGVuZ3RoKSk7XG5cdFx0XHRcdHRoaXMucmFkaXVzICs9IG1pc3NpbmdSYWRpdXNIYWxmO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR1bmlvbihzcGhlcmUpIHtcblx0XHRcdC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2p1ai9NYXRoR2VvTGliL2Jsb2IvMjk0MGI5OWI5OWNmZTU3NWRkNDUxMDNlZjIwZjQwMTlkZWUxNWI1NC9zcmMvR2VvbWV0cnkvU3BoZXJlLmNwcCNMNzU5LUw3Njlcblx0XHRcdC8vIFRvIGVuY2xvc2UgYW5vdGhlciBzcGhlcmUgaW50byB0aGlzIHNwaGVyZSwgd2Ugb25seSBuZWVkIHRvIGVuY2xvc2UgdHdvIHBvaW50czpcblx0XHRcdC8vIDEpIEVuY2xvc2UgdGhlIGZhcnRoZXN0IHBvaW50IG9uIHRoZSBvdGhlciBzcGhlcmUgaW50byB0aGlzIHNwaGVyZS5cblx0XHRcdC8vIDIpIEVuY2xvc2UgdGhlIG9wcG9zaXRlIHBvaW50IG9mIHRoZSBmYXJ0aGVzdCBwb2ludCBpbnRvIHRoaXMgc3BoZXJlLlxuXHRcdFx0X3RvRmFydGhlc3RQb2ludC5zdWJWZWN0b3JzKHNwaGVyZS5jZW50ZXIsIHRoaXMuY2VudGVyKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihzcGhlcmUucmFkaXVzKTtcblxuXHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KF92MSQ2LmNvcHkoc3BoZXJlLmNlbnRlcikuYWRkKF90b0ZhcnRoZXN0UG9pbnQpKTtcblx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludChfdjEkNi5jb3B5KHNwaGVyZS5jZW50ZXIpLnN1YihfdG9GYXJ0aGVzdFBvaW50KSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRlcXVhbHMoc3BoZXJlKSB7XG5cdFx0XHRyZXR1cm4gc3BoZXJlLmNlbnRlci5lcXVhbHModGhpcy5jZW50ZXIpICYmIHNwaGVyZS5yYWRpdXMgPT09IHRoaXMucmFkaXVzO1xuXHRcdH1cblxuXHRcdGNsb25lKCkge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcblx0XHR9XG5cblx0fVxuXG5cdGNvbnN0IF92ZWN0b3IkYSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9zZWdDZW50ZXIgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfc2VnRGlyID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX2RpZmYgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfZWRnZTEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfZWRnZTIgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfbm9ybWFsJDEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjbGFzcyBSYXkge1xuXHRcdGNvbnN0cnVjdG9yKG9yaWdpbiA9IG5ldyBWZWN0b3IzKCksIGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIC0xKSkge1xuXHRcdFx0dGhpcy5vcmlnaW4gPSBvcmlnaW47XG5cdFx0XHR0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcblx0XHR9XG5cblx0XHRzZXQob3JpZ2luLCBkaXJlY3Rpb24pIHtcblx0XHRcdHRoaXMub3JpZ2luLmNvcHkob3JpZ2luKTtcblx0XHRcdHRoaXMuZGlyZWN0aW9uLmNvcHkoZGlyZWN0aW9uKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNvcHkocmF5KSB7XG5cdFx0XHR0aGlzLm9yaWdpbi5jb3B5KHJheS5vcmlnaW4pO1xuXHRcdFx0dGhpcy5kaXJlY3Rpb24uY29weShyYXkuZGlyZWN0aW9uKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGF0KHQsIHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KHRoaXMuZGlyZWN0aW9uKS5tdWx0aXBseVNjYWxhcih0KS5hZGQodGhpcy5vcmlnaW4pO1xuXHRcdH1cblxuXHRcdGxvb2tBdCh2KSB7XG5cdFx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KHYpLnN1Yih0aGlzLm9yaWdpbikubm9ybWFsaXplKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRyZWNhc3QodCkge1xuXHRcdFx0dGhpcy5vcmlnaW4uY29weSh0aGlzLmF0KHQsIF92ZWN0b3IkYSkpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y2xvc2VzdFBvaW50VG9Qb2ludChwb2ludCwgdGFyZ2V0KSB7XG5cdFx0XHR0YXJnZXQuc3ViVmVjdG9ycyhwb2ludCwgdGhpcy5vcmlnaW4pO1xuXHRcdFx0Y29uc3QgZGlyZWN0aW9uRGlzdGFuY2UgPSB0YXJnZXQuZG90KHRoaXMuZGlyZWN0aW9uKTtcblxuXHRcdFx0aWYgKGRpcmVjdGlvbkRpc3RhbmNlIDwgMCkge1xuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkodGhpcy5vcmlnaW4pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkodGhpcy5kaXJlY3Rpb24pLm11bHRpcGx5U2NhbGFyKGRpcmVjdGlvbkRpc3RhbmNlKS5hZGQodGhpcy5vcmlnaW4pO1xuXHRcdH1cblxuXHRcdGRpc3RhbmNlVG9Qb2ludChwb2ludCkge1xuXHRcdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlU3FUb1BvaW50KHBvaW50KSk7XG5cdFx0fVxuXG5cdFx0ZGlzdGFuY2VTcVRvUG9pbnQocG9pbnQpIHtcblx0XHRcdGNvbnN0IGRpcmVjdGlvbkRpc3RhbmNlID0gX3ZlY3RvciRhLnN1YlZlY3RvcnMocG9pbnQsIHRoaXMub3JpZ2luKS5kb3QodGhpcy5kaXJlY3Rpb24pOyAvLyBwb2ludCBiZWhpbmQgdGhlIHJheVxuXG5cblx0XHRcdGlmIChkaXJlY3Rpb25EaXN0YW5jZSA8IDApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luLmRpc3RhbmNlVG9TcXVhcmVkKHBvaW50KTtcblx0XHRcdH1cblxuXHRcdFx0X3ZlY3RvciRhLmNvcHkodGhpcy5kaXJlY3Rpb24pLm11bHRpcGx5U2NhbGFyKGRpcmVjdGlvbkRpc3RhbmNlKS5hZGQodGhpcy5vcmlnaW4pO1xuXG5cdFx0XHRyZXR1cm4gX3ZlY3RvciRhLmRpc3RhbmNlVG9TcXVhcmVkKHBvaW50KTtcblx0XHR9XG5cblx0XHRkaXN0YW5jZVNxVG9TZWdtZW50KHYwLCB2MSwgb3B0aW9uYWxQb2ludE9uUmF5LCBvcHRpb25hbFBvaW50T25TZWdtZW50KSB7XG5cdFx0XHQvLyBmcm9tIGh0dHA6Ly93d3cuZ2VvbWV0cmljdG9vbHMuY29tL0dURW5naW5lL0luY2x1ZGUvTWF0aGVtYXRpY3MvR3RlRGlzdFJheVNlZ21lbnQuaFxuXHRcdFx0Ly8gSXQgcmV0dXJucyB0aGUgbWluIGRpc3RhbmNlIGJldHdlZW4gdGhlIHJheSBhbmQgdGhlIHNlZ21lbnRcblx0XHRcdC8vIGRlZmluZWQgYnkgdjAgYW5kIHYxXG5cdFx0XHQvLyBJdCBjYW4gYWxzbyBzZXQgdHdvIG9wdGlvbmFsIHRhcmdldHMgOlxuXHRcdFx0Ly8gLSBUaGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgcmF5XG5cdFx0XHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBzZWdtZW50XG5cdFx0XHRfc2VnQ2VudGVyLmNvcHkodjApLmFkZCh2MSkubXVsdGlwbHlTY2FsYXIoMC41KTtcblxuXHRcdFx0X3NlZ0Rpci5jb3B5KHYxKS5zdWIodjApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRfZGlmZi5jb3B5KHRoaXMub3JpZ2luKS5zdWIoX3NlZ0NlbnRlcik7XG5cblx0XHRcdGNvbnN0IHNlZ0V4dGVudCA9IHYwLmRpc3RhbmNlVG8odjEpICogMC41O1xuXHRcdFx0Y29uc3QgYTAxID0gLXRoaXMuZGlyZWN0aW9uLmRvdChfc2VnRGlyKTtcblxuXHRcdFx0Y29uc3QgYjAgPSBfZGlmZi5kb3QodGhpcy5kaXJlY3Rpb24pO1xuXG5cdFx0XHRjb25zdCBiMSA9IC1fZGlmZi5kb3QoX3NlZ0Rpcik7XG5cblx0XHRcdGNvbnN0IGMgPSBfZGlmZi5sZW5ndGhTcSgpO1xuXG5cdFx0XHRjb25zdCBkZXQgPSBNYXRoLmFicygxIC0gYTAxICogYTAxKTtcblx0XHRcdGxldCBzMCwgczEsIHNxckRpc3QsIGV4dERldDtcblxuXHRcdFx0aWYgKGRldCA+IDApIHtcblx0XHRcdFx0Ly8gVGhlIHJheSBhbmQgc2VnbWVudCBhcmUgbm90IHBhcmFsbGVsLlxuXHRcdFx0XHRzMCA9IGEwMSAqIGIxIC0gYjA7XG5cdFx0XHRcdHMxID0gYTAxICogYjAgLSBiMTtcblx0XHRcdFx0ZXh0RGV0ID0gc2VnRXh0ZW50ICogZGV0O1xuXG5cdFx0XHRcdGlmIChzMCA+PSAwKSB7XG5cdFx0XHRcdFx0aWYgKHMxID49IC1leHREZXQpIHtcblx0XHRcdFx0XHRcdGlmIChzMSA8PSBleHREZXQpIHtcblx0XHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDBcblx0XHRcdFx0XHRcdFx0Ly8gTWluaW11bSBhdCBpbnRlcmlvciBwb2ludHMgb2YgcmF5IGFuZCBzZWdtZW50LlxuXHRcdFx0XHRcdFx0XHRjb25zdCBpbnZEZXQgPSAxIC8gZGV0O1xuXHRcdFx0XHRcdFx0XHRzMCAqPSBpbnZEZXQ7XG5cdFx0XHRcdFx0XHRcdHMxICo9IGludkRldDtcblx0XHRcdFx0XHRcdFx0c3FyRGlzdCA9IHMwICogKHMwICsgYTAxICogczEgKyAyICogYjApICsgczEgKiAoYTAxICogczAgKyBzMSArIDIgKiBiMSkgKyBjO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDFcblx0XHRcdFx0XHRcdFx0czEgPSBzZWdFeHRlbnQ7XG5cdFx0XHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoMCwgLShhMDEgKiBzMSArIGIwKSk7XG5cdFx0XHRcdFx0XHRcdHNxckRpc3QgPSAtczAgKiBzMCArIHMxICogKHMxICsgMiAqIGIxKSArIGM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIHJlZ2lvbiA1XG5cdFx0XHRcdFx0XHRzMSA9IC1zZWdFeHRlbnQ7XG5cdFx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KDAsIC0oYTAxICogczEgKyBiMCkpO1xuXHRcdFx0XHRcdFx0c3FyRGlzdCA9IC1zMCAqIHMwICsgczEgKiAoczEgKyAyICogYjEpICsgYztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHMxIDw9IC1leHREZXQpIHtcblx0XHRcdFx0XHRcdC8vIHJlZ2lvbiA0XG5cdFx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KDAsIC0oLWEwMSAqIHNlZ0V4dGVudCArIGIwKSk7XG5cdFx0XHRcdFx0XHRzMSA9IHMwID4gMCA/IC1zZWdFeHRlbnQgOiBNYXRoLm1pbihNYXRoLm1heCgtc2VnRXh0ZW50LCAtYjEpLCBzZWdFeHRlbnQpO1xuXHRcdFx0XHRcdFx0c3FyRGlzdCA9IC1zMCAqIHMwICsgczEgKiAoczEgKyAyICogYjEpICsgYztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHMxIDw9IGV4dERldCkge1xuXHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDNcblx0XHRcdFx0XHRcdHMwID0gMDtcblx0XHRcdFx0XHRcdHMxID0gTWF0aC5taW4oTWF0aC5tYXgoLXNlZ0V4dGVudCwgLWIxKSwgc2VnRXh0ZW50KTtcblx0XHRcdFx0XHRcdHNxckRpc3QgPSBzMSAqIChzMSArIDIgKiBiMSkgKyBjO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyByZWdpb24gMlxuXHRcdFx0XHRcdFx0czAgPSBNYXRoLm1heCgwLCAtKGEwMSAqIHNlZ0V4dGVudCArIGIwKSk7XG5cdFx0XHRcdFx0XHRzMSA9IHMwID4gMCA/IHNlZ0V4dGVudCA6IE1hdGgubWluKE1hdGgubWF4KC1zZWdFeHRlbnQsIC1iMSksIHNlZ0V4dGVudCk7XG5cdFx0XHRcdFx0XHRzcXJEaXN0ID0gLXMwICogczAgKyBzMSAqIChzMSArIDIgKiBiMSkgKyBjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gUmF5IGFuZCBzZWdtZW50IGFyZSBwYXJhbGxlbC5cblx0XHRcdFx0czEgPSBhMDEgPiAwID8gLXNlZ0V4dGVudCA6IHNlZ0V4dGVudDtcblx0XHRcdFx0czAgPSBNYXRoLm1heCgwLCAtKGEwMSAqIHMxICsgYjApKTtcblx0XHRcdFx0c3FyRGlzdCA9IC1zMCAqIHMwICsgczEgKiAoczEgKyAyICogYjEpICsgYztcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdGlvbmFsUG9pbnRPblJheSkge1xuXHRcdFx0XHRvcHRpb25hbFBvaW50T25SYXkuY29weSh0aGlzLmRpcmVjdGlvbikubXVsdGlwbHlTY2FsYXIoczApLmFkZCh0aGlzLm9yaWdpbik7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRpb25hbFBvaW50T25TZWdtZW50KSB7XG5cdFx0XHRcdG9wdGlvbmFsUG9pbnRPblNlZ21lbnQuY29weShfc2VnRGlyKS5tdWx0aXBseVNjYWxhcihzMSkuYWRkKF9zZWdDZW50ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc3FyRGlzdDtcblx0XHR9XG5cblx0XHRpbnRlcnNlY3RTcGhlcmUoc3BoZXJlLCB0YXJnZXQpIHtcblx0XHRcdF92ZWN0b3IkYS5zdWJWZWN0b3JzKHNwaGVyZS5jZW50ZXIsIHRoaXMub3JpZ2luKTtcblxuXHRcdFx0Y29uc3QgdGNhID0gX3ZlY3RvciRhLmRvdCh0aGlzLmRpcmVjdGlvbik7XG5cblx0XHRcdGNvbnN0IGQyID0gX3ZlY3RvciRhLmRvdChfdmVjdG9yJGEpIC0gdGNhICogdGNhO1xuXHRcdFx0Y29uc3QgcmFkaXVzMiA9IHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzO1xuXHRcdFx0aWYgKGQyID4gcmFkaXVzMikgcmV0dXJuIG51bGw7XG5cdFx0XHRjb25zdCB0aGMgPSBNYXRoLnNxcnQocmFkaXVzMiAtIGQyKTsgLy8gdDAgPSBmaXJzdCBpbnRlcnNlY3QgcG9pbnQgLSBlbnRyYW5jZSBvbiBmcm9udCBvZiBzcGhlcmVcblxuXHRcdFx0Y29uc3QgdDAgPSB0Y2EgLSB0aGM7IC8vIHQxID0gc2Vjb25kIGludGVyc2VjdCBwb2ludCAtIGV4aXQgcG9pbnQgb24gYmFjayBvZiBzcGhlcmVcblxuXHRcdFx0Y29uc3QgdDEgPSB0Y2EgKyB0aGM7IC8vIHRlc3QgdG8gc2VlIGlmIGJvdGggdDAgYW5kIHQxIGFyZSBiZWhpbmQgdGhlIHJheSAtIGlmIHNvLCByZXR1cm4gbnVsbFxuXG5cdFx0XHRpZiAodDAgPCAwICYmIHQxIDwgMCkgcmV0dXJuIG51bGw7IC8vIHRlc3QgdG8gc2VlIGlmIHQwIGlzIGJlaGluZCB0aGUgcmF5OlxuXHRcdFx0Ly8gaWYgaXQgaXMsIHRoZSByYXkgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHNvIHJldHVybiB0aGUgc2Vjb25kIGV4aXQgcG9pbnQgc2NhbGVkIGJ5IHQxLFxuXHRcdFx0Ly8gaW4gb3JkZXIgdG8gYWx3YXlzIHJldHVybiBhbiBpbnRlcnNlY3QgcG9pbnQgdGhhdCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LlxuXG5cdFx0XHRpZiAodDAgPCAwKSByZXR1cm4gdGhpcy5hdCh0MSwgdGFyZ2V0KTsgLy8gZWxzZSB0MCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LCBzbyByZXR1cm4gdGhlIGZpcnN0IGNvbGxpc2lvbiBwb2ludCBzY2FsZWQgYnkgdDBcblxuXHRcdFx0cmV0dXJuIHRoaXMuYXQodDAsIHRhcmdldCk7XG5cdFx0fVxuXG5cdFx0aW50ZXJzZWN0c1NwaGVyZShzcGhlcmUpIHtcblx0XHRcdHJldHVybiB0aGlzLmRpc3RhbmNlU3FUb1BvaW50KHNwaGVyZS5jZW50ZXIpIDw9IHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzO1xuXHRcdH1cblxuXHRcdGRpc3RhbmNlVG9QbGFuZShwbGFuZSkge1xuXHRcdFx0Y29uc3QgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KHRoaXMuZGlyZWN0aW9uKTtcblxuXHRcdFx0aWYgKGRlbm9taW5hdG9yID09PSAwKSB7XG5cdFx0XHRcdC8vIGxpbmUgaXMgY29wbGFuYXIsIHJldHVybiBvcmlnaW5cblx0XHRcdFx0aWYgKHBsYW5lLmRpc3RhbmNlVG9Qb2ludCh0aGlzLm9yaWdpbikgPT09IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fSAvLyBOdWxsIGlzIHByZWZlcmFibGUgdG8gdW5kZWZpbmVkIHNpbmNlIHVuZGVmaW5lZCBtZWFucy4uLi4gaXQgaXMgdW5kZWZpbmVkXG5cblxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdCA9IC0odGhpcy5vcmlnaW4uZG90KHBsYW5lLm5vcm1hbCkgKyBwbGFuZS5jb25zdGFudCkgLyBkZW5vbWluYXRvcjsgLy8gUmV0dXJuIGlmIHRoZSByYXkgbmV2ZXIgaW50ZXJzZWN0cyB0aGUgcGxhbmVcblxuXHRcdFx0cmV0dXJuIHQgPj0gMCA/IHQgOiBudWxsO1xuXHRcdH1cblxuXHRcdGludGVyc2VjdFBsYW5lKHBsYW5lLCB0YXJnZXQpIHtcblx0XHRcdGNvbnN0IHQgPSB0aGlzLmRpc3RhbmNlVG9QbGFuZShwbGFuZSk7XG5cblx0XHRcdGlmICh0ID09PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5hdCh0LCB0YXJnZXQpO1xuXHRcdH1cblxuXHRcdGludGVyc2VjdHNQbGFuZShwbGFuZSkge1xuXHRcdFx0Ly8gY2hlY2sgaWYgdGhlIHJheSBsaWVzIG9uIHRoZSBwbGFuZSBmaXJzdFxuXHRcdFx0Y29uc3QgZGlzdFRvUG9pbnQgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQodGhpcy5vcmlnaW4pO1xuXG5cdFx0XHRpZiAoZGlzdFRvUG9pbnQgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGRlbm9taW5hdG9yID0gcGxhbmUubm9ybWFsLmRvdCh0aGlzLmRpcmVjdGlvbik7XG5cblx0XHRcdGlmIChkZW5vbWluYXRvciAqIGRpc3RUb1BvaW50IDwgMCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0gLy8gcmF5IG9yaWdpbiBpcyBiZWhpbmQgdGhlIHBsYW5lIChhbmQgaXMgcG9pbnRpbmcgYmVoaW5kIGl0KVxuXG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpbnRlcnNlY3RCb3goYm94LCB0YXJnZXQpIHtcblx0XHRcdGxldCB0bWluLCB0bWF4LCB0eW1pbiwgdHltYXgsIHR6bWluLCB0em1heDtcblx0XHRcdGNvbnN0IGludmRpcnggPSAxIC8gdGhpcy5kaXJlY3Rpb24ueCxcblx0XHRcdFx0XHRcdGludmRpcnkgPSAxIC8gdGhpcy5kaXJlY3Rpb24ueSxcblx0XHRcdFx0XHRcdGludmRpcnogPSAxIC8gdGhpcy5kaXJlY3Rpb24uejtcblx0XHRcdGNvbnN0IG9yaWdpbiA9IHRoaXMub3JpZ2luO1xuXG5cdFx0XHRpZiAoaW52ZGlyeCA+PSAwKSB7XG5cdFx0XHRcdHRtaW4gPSAoYm94Lm1pbi54IC0gb3JpZ2luLngpICogaW52ZGlyeDtcblx0XHRcdFx0dG1heCA9IChib3gubWF4LnggLSBvcmlnaW4ueCkgKiBpbnZkaXJ4O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1pbiA9IChib3gubWF4LnggLSBvcmlnaW4ueCkgKiBpbnZkaXJ4O1xuXHRcdFx0XHR0bWF4ID0gKGJveC5taW4ueCAtIG9yaWdpbi54KSAqIGludmRpcng7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpbnZkaXJ5ID49IDApIHtcblx0XHRcdFx0dHltaW4gPSAoYm94Lm1pbi55IC0gb3JpZ2luLnkpICogaW52ZGlyeTtcblx0XHRcdFx0dHltYXggPSAoYm94Lm1heC55IC0gb3JpZ2luLnkpICogaW52ZGlyeTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR5bWluID0gKGJveC5tYXgueSAtIG9yaWdpbi55KSAqIGludmRpcnk7XG5cdFx0XHRcdHR5bWF4ID0gKGJveC5taW4ueSAtIG9yaWdpbi55KSAqIGludmRpcnk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0bWluID4gdHltYXggfHwgdHltaW4gPiB0bWF4KSByZXR1cm4gbnVsbDsgLy8gVGhlc2UgbGluZXMgYWxzbyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdG1pbiBvciB0bWF4IGlzIE5hTlxuXHRcdFx0Ly8gKHJlc3VsdCBvZiAwICogSW5maW5pdHkpLiB4ICE9PSB4IHJldHVybnMgdHJ1ZSBpZiB4IGlzIE5hTlxuXG5cdFx0XHRpZiAodHltaW4gPiB0bWluIHx8IHRtaW4gIT09IHRtaW4pIHRtaW4gPSB0eW1pbjtcblx0XHRcdGlmICh0eW1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCkgdG1heCA9IHR5bWF4O1xuXG5cdFx0XHRpZiAoaW52ZGlyeiA+PSAwKSB7XG5cdFx0XHRcdHR6bWluID0gKGJveC5taW4ueiAtIG9yaWdpbi56KSAqIGludmRpcno7XG5cdFx0XHRcdHR6bWF4ID0gKGJveC5tYXgueiAtIG9yaWdpbi56KSAqIGludmRpcno7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0em1pbiA9IChib3gubWF4LnogLSBvcmlnaW4ueikgKiBpbnZkaXJ6O1xuXHRcdFx0XHR0em1heCA9IChib3gubWluLnogLSBvcmlnaW4ueikgKiBpbnZkaXJ6O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodG1pbiA+IHR6bWF4IHx8IHR6bWluID4gdG1heCkgcmV0dXJuIG51bGw7XG5cdFx0XHRpZiAodHptaW4gPiB0bWluIHx8IHRtaW4gIT09IHRtaW4pIHRtaW4gPSB0em1pbjtcblx0XHRcdGlmICh0em1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCkgdG1heCA9IHR6bWF4OyAvL3JldHVybiBwb2ludCBjbG9zZXN0IHRvIHRoZSByYXkgKHBvc2l0aXZlIHNpZGUpXG5cblx0XHRcdGlmICh0bWF4IDwgMCkgcmV0dXJuIG51bGw7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdCh0bWluID49IDAgPyB0bWluIDogdG1heCwgdGFyZ2V0KTtcblx0XHR9XG5cblx0XHRpbnRlcnNlY3RzQm94KGJveCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0Qm94KGJveCwgX3ZlY3RvciRhKSAhPT0gbnVsbDtcblx0XHR9XG5cblx0XHRpbnRlcnNlY3RUcmlhbmdsZShhLCBiLCBjLCBiYWNrZmFjZUN1bGxpbmcsIHRhcmdldCkge1xuXHRcdFx0Ly8gQ29tcHV0ZSB0aGUgb2Zmc2V0IG9yaWdpbiwgZWRnZXMsIGFuZCBub3JtYWwuXG5cdFx0XHQvLyBmcm9tIGh0dHA6Ly93d3cuZ2VvbWV0cmljdG9vbHMuY29tL0dURW5naW5lL0luY2x1ZGUvTWF0aGVtYXRpY3MvR3RlSW50clJheTNUcmlhbmdsZTMuaFxuXHRcdFx0X2VkZ2UxLnN1YlZlY3RvcnMoYiwgYSk7XG5cblx0XHRcdF9lZGdlMi5zdWJWZWN0b3JzKGMsIGEpO1xuXG5cdFx0XHRfbm9ybWFsJDEuY3Jvc3NWZWN0b3JzKF9lZGdlMSwgX2VkZ2UyKTsgLy8gU29sdmUgUSArIHQqRCA9IGIxKkUxICsgYjIqRTIgKFEgPSBrRGlmZiwgRCA9IHJheSBkaXJlY3Rpb24sXG5cdFx0XHQvLyBFMSA9IGtFZGdlMSwgRTIgPSBrRWRnZTIsIE4gPSBDcm9zcyhFMSxFMikpIGJ5XG5cdFx0XHQvL1x0IHxEb3QoRCxOKXwqYjEgPSBzaWduKERvdChELE4pKSpEb3QoRCxDcm9zcyhRLEUyKSlcblx0XHRcdC8vXHQgfERvdChELE4pfCpiMiA9IHNpZ24oRG90KEQsTikpKkRvdChELENyb3NzKEUxLFEpKVxuXHRcdFx0Ly9cdCB8RG90KEQsTil8KnQgPSAtc2lnbihEb3QoRCxOKSkqRG90KFEsTilcblxuXG5cdFx0XHRsZXQgRGROID0gdGhpcy5kaXJlY3Rpb24uZG90KF9ub3JtYWwkMSk7XG5cdFx0XHRsZXQgc2lnbjtcblxuXHRcdFx0aWYgKERkTiA+IDApIHtcblx0XHRcdFx0aWYgKGJhY2tmYWNlQ3VsbGluZykgcmV0dXJuIG51bGw7XG5cdFx0XHRcdHNpZ24gPSAxO1xuXHRcdFx0fSBlbHNlIGlmIChEZE4gPCAwKSB7XG5cdFx0XHRcdHNpZ24gPSAtMTtcblx0XHRcdFx0RGROID0gLURkTjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRfZGlmZi5zdWJWZWN0b3JzKHRoaXMub3JpZ2luLCBhKTtcblxuXHRcdFx0Y29uc3QgRGRReEUyID0gc2lnbiAqIHRoaXMuZGlyZWN0aW9uLmRvdChfZWRnZTIuY3Jvc3NWZWN0b3JzKF9kaWZmLCBfZWRnZTIpKTsgLy8gYjEgPCAwLCBubyBpbnRlcnNlY3Rpb25cblxuXHRcdFx0aWYgKERkUXhFMiA8IDApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IERkRTF4USA9IHNpZ24gKiB0aGlzLmRpcmVjdGlvbi5kb3QoX2VkZ2UxLmNyb3NzKF9kaWZmKSk7IC8vIGIyIDwgMCwgbm8gaW50ZXJzZWN0aW9uXG5cblx0XHRcdGlmIChEZEUxeFEgPCAwKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSAvLyBiMStiMiA+IDEsIG5vIGludGVyc2VjdGlvblxuXG5cblx0XHRcdGlmIChEZFF4RTIgKyBEZEUxeFEgPiBEZE4pIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9IC8vIExpbmUgaW50ZXJzZWN0cyB0cmlhbmdsZSwgY2hlY2sgaWYgcmF5IGRvZXMuXG5cblxuXHRcdFx0Y29uc3QgUWROID0gLXNpZ24gKiBfZGlmZi5kb3QoX25vcm1hbCQxKTsgLy8gdCA8IDAsIG5vIGludGVyc2VjdGlvblxuXG5cblx0XHRcdGlmIChRZE4gPCAwKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSAvLyBSYXkgaW50ZXJzZWN0cyB0cmlhbmdsZS5cblxuXG5cdFx0XHRyZXR1cm4gdGhpcy5hdChRZE4gLyBEZE4sIHRhcmdldCk7XG5cdFx0fVxuXG5cdFx0YXBwbHlNYXRyaXg0KG1hdHJpeDQpIHtcblx0XHRcdHRoaXMub3JpZ2luLmFwcGx5TWF0cml4NChtYXRyaXg0KTtcblx0XHRcdHRoaXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbihtYXRyaXg0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGVxdWFscyhyYXkpIHtcblx0XHRcdHJldHVybiByYXkub3JpZ2luLmVxdWFscyh0aGlzLm9yaWdpbikgJiYgcmF5LmRpcmVjdGlvbi5lcXVhbHModGhpcy5kaXJlY3Rpb24pO1xuXHRcdH1cblxuXHRcdGNsb25lKCkge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIE1hdHJpeDQge1xuXHRcdGNvbnN0cnVjdG9yKCkge1xuXHRcdFx0dGhpcy5lbGVtZW50cyA9IFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcblxuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLk1hdHJpeDQ6IHRoZSBjb25zdHJ1Y3RvciBubyBsb25nZXIgcmVhZHMgYXJndW1lbnRzLiB1c2UgLnNldCgpIGluc3RlYWQuJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2V0KG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCkge1xuXHRcdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0dGVbMF0gPSBuMTE7XG5cdFx0XHR0ZVs0XSA9IG4xMjtcblx0XHRcdHRlWzhdID0gbjEzO1xuXHRcdFx0dGVbMTJdID0gbjE0O1xuXHRcdFx0dGVbMV0gPSBuMjE7XG5cdFx0XHR0ZVs1XSA9IG4yMjtcblx0XHRcdHRlWzldID0gbjIzO1xuXHRcdFx0dGVbMTNdID0gbjI0O1xuXHRcdFx0dGVbMl0gPSBuMzE7XG5cdFx0XHR0ZVs2XSA9IG4zMjtcblx0XHRcdHRlWzEwXSA9IG4zMztcblx0XHRcdHRlWzE0XSA9IG4zNDtcblx0XHRcdHRlWzNdID0gbjQxO1xuXHRcdFx0dGVbN10gPSBuNDI7XG5cdFx0XHR0ZVsxMV0gPSBuNDM7XG5cdFx0XHR0ZVsxNV0gPSBuNDQ7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZGVudGl0eSgpIHtcblx0XHRcdHRoaXMuc2V0KDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y2xvbmUoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IE1hdHJpeDQoKS5mcm9tQXJyYXkodGhpcy5lbGVtZW50cyk7XG5cdFx0fVxuXG5cdFx0Y29weShtKSB7XG5cdFx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0XHRjb25zdCBtZSA9IG0uZWxlbWVudHM7XG5cdFx0XHR0ZVswXSA9IG1lWzBdO1xuXHRcdFx0dGVbMV0gPSBtZVsxXTtcblx0XHRcdHRlWzJdID0gbWVbMl07XG5cdFx0XHR0ZVszXSA9IG1lWzNdO1xuXHRcdFx0dGVbNF0gPSBtZVs0XTtcblx0XHRcdHRlWzVdID0gbWVbNV07XG5cdFx0XHR0ZVs2XSA9IG1lWzZdO1xuXHRcdFx0dGVbN10gPSBtZVs3XTtcblx0XHRcdHRlWzhdID0gbWVbOF07XG5cdFx0XHR0ZVs5XSA9IG1lWzldO1xuXHRcdFx0dGVbMTBdID0gbWVbMTBdO1xuXHRcdFx0dGVbMTFdID0gbWVbMTFdO1xuXHRcdFx0dGVbMTJdID0gbWVbMTJdO1xuXHRcdFx0dGVbMTNdID0gbWVbMTNdO1xuXHRcdFx0dGVbMTRdID0gbWVbMTRdO1xuXHRcdFx0dGVbMTVdID0gbWVbMTVdO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29weVBvc2l0aW9uKG0pIHtcblx0XHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cyxcblx0XHRcdFx0XHRcdG1lID0gbS5lbGVtZW50cztcblx0XHRcdHRlWzEyXSA9IG1lWzEyXTtcblx0XHRcdHRlWzEzXSA9IG1lWzEzXTtcblx0XHRcdHRlWzE0XSA9IG1lWzE0XTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldEZyb21NYXRyaXgzKG0pIHtcblx0XHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblx0XHRcdHRoaXMuc2V0KG1lWzBdLCBtZVszXSwgbWVbNl0sIDAsIG1lWzFdLCBtZVs0XSwgbWVbN10sIDAsIG1lWzJdLCBtZVs1XSwgbWVbOF0sIDAsIDAsIDAsIDAsIDEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZXh0cmFjdEJhc2lzKHhBeGlzLCB5QXhpcywgekF4aXMpIHtcblx0XHRcdHhBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4odGhpcywgMCk7XG5cdFx0XHR5QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKHRoaXMsIDEpO1xuXHRcdFx0ekF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbih0aGlzLCAyKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG1ha2VCYXNpcyh4QXhpcywgeUF4aXMsIHpBeGlzKSB7XG5cdFx0XHR0aGlzLnNldCh4QXhpcy54LCB5QXhpcy54LCB6QXhpcy54LCAwLCB4QXhpcy55LCB5QXhpcy55LCB6QXhpcy55LCAwLCB4QXhpcy56LCB5QXhpcy56LCB6QXhpcy56LCAwLCAwLCAwLCAwLCAxKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGV4dHJhY3RSb3RhdGlvbihtKSB7XG5cdFx0XHQvLyB0aGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IHJlZmxlY3Rpb24gbWF0cmljZXNcblx0XHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblxuXHRcdFx0Y29uc3Qgc2NhbGVYID0gMSAvIF92MSQ1LnNldEZyb21NYXRyaXhDb2x1bW4obSwgMCkubGVuZ3RoKCk7XG5cblx0XHRcdGNvbnN0IHNjYWxlWSA9IDEgLyBfdjEkNS5zZXRGcm9tTWF0cml4Q29sdW1uKG0sIDEpLmxlbmd0aCgpO1xuXG5cdFx0XHRjb25zdCBzY2FsZVogPSAxIC8gX3YxJDUuc2V0RnJvbU1hdHJpeENvbHVtbihtLCAyKS5sZW5ndGgoKTtcblxuXHRcdFx0dGVbMF0gPSBtZVswXSAqIHNjYWxlWDtcblx0XHRcdHRlWzFdID0gbWVbMV0gKiBzY2FsZVg7XG5cdFx0XHR0ZVsyXSA9IG1lWzJdICogc2NhbGVYO1xuXHRcdFx0dGVbM10gPSAwO1xuXHRcdFx0dGVbNF0gPSBtZVs0XSAqIHNjYWxlWTtcblx0XHRcdHRlWzVdID0gbWVbNV0gKiBzY2FsZVk7XG5cdFx0XHR0ZVs2XSA9IG1lWzZdICogc2NhbGVZO1xuXHRcdFx0dGVbN10gPSAwO1xuXHRcdFx0dGVbOF0gPSBtZVs4XSAqIHNjYWxlWjtcblx0XHRcdHRlWzldID0gbWVbOV0gKiBzY2FsZVo7XG5cdFx0XHR0ZVsxMF0gPSBtZVsxMF0gKiBzY2FsZVo7XG5cdFx0XHR0ZVsxMV0gPSAwO1xuXHRcdFx0dGVbMTJdID0gMDtcblx0XHRcdHRlWzEzXSA9IDA7XG5cdFx0XHR0ZVsxNF0gPSAwO1xuXHRcdFx0dGVbMTVdID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG1ha2VSb3RhdGlvbkZyb21FdWxlcihldWxlcikge1xuXHRcdFx0aWYgKCEoZXVsZXIgJiYgZXVsZXIuaXNFdWxlcikpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuTWF0cml4NDogLm1ha2VSb3RhdGlvbkZyb21FdWxlcigpIG5vdyBleHBlY3RzIGEgRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0Y29uc3QgeCA9IGV1bGVyLngsXG5cdFx0XHRcdFx0XHR5ID0gZXVsZXIueSxcblx0XHRcdFx0XHRcdHogPSBldWxlci56O1xuXHRcdFx0Y29uc3QgYSA9IE1hdGguY29zKHgpLFxuXHRcdFx0XHRcdFx0YiA9IE1hdGguc2luKHgpO1xuXHRcdFx0Y29uc3QgYyA9IE1hdGguY29zKHkpLFxuXHRcdFx0XHRcdFx0ZCA9IE1hdGguc2luKHkpO1xuXHRcdFx0Y29uc3QgZSA9IE1hdGguY29zKHopLFxuXHRcdFx0XHRcdFx0ZiA9IE1hdGguc2luKHopO1xuXG5cdFx0XHRpZiAoZXVsZXIub3JkZXIgPT09ICdYWVonKSB7XG5cdFx0XHRcdGNvbnN0IGFlID0gYSAqIGUsXG5cdFx0XHRcdFx0XHRcdGFmID0gYSAqIGYsXG5cdFx0XHRcdFx0XHRcdGJlID0gYiAqIGUsXG5cdFx0XHRcdFx0XHRcdGJmID0gYiAqIGY7XG5cdFx0XHRcdHRlWzBdID0gYyAqIGU7XG5cdFx0XHRcdHRlWzRdID0gLWMgKiBmO1xuXHRcdFx0XHR0ZVs4XSA9IGQ7XG5cdFx0XHRcdHRlWzFdID0gYWYgKyBiZSAqIGQ7XG5cdFx0XHRcdHRlWzVdID0gYWUgLSBiZiAqIGQ7XG5cdFx0XHRcdHRlWzldID0gLWIgKiBjO1xuXHRcdFx0XHR0ZVsyXSA9IGJmIC0gYWUgKiBkO1xuXHRcdFx0XHR0ZVs2XSA9IGJlICsgYWYgKiBkO1xuXHRcdFx0XHR0ZVsxMF0gPSBhICogYztcblx0XHRcdH0gZWxzZSBpZiAoZXVsZXIub3JkZXIgPT09ICdZWFonKSB7XG5cdFx0XHRcdGNvbnN0IGNlID0gYyAqIGUsXG5cdFx0XHRcdFx0XHRcdGNmID0gYyAqIGYsXG5cdFx0XHRcdFx0XHRcdGRlID0gZCAqIGUsXG5cdFx0XHRcdFx0XHRcdGRmID0gZCAqIGY7XG5cdFx0XHRcdHRlWzBdID0gY2UgKyBkZiAqIGI7XG5cdFx0XHRcdHRlWzRdID0gZGUgKiBiIC0gY2Y7XG5cdFx0XHRcdHRlWzhdID0gYSAqIGQ7XG5cdFx0XHRcdHRlWzFdID0gYSAqIGY7XG5cdFx0XHRcdHRlWzVdID0gYSAqIGU7XG5cdFx0XHRcdHRlWzldID0gLWI7XG5cdFx0XHRcdHRlWzJdID0gY2YgKiBiIC0gZGU7XG5cdFx0XHRcdHRlWzZdID0gZGYgKyBjZSAqIGI7XG5cdFx0XHRcdHRlWzEwXSA9IGEgKiBjO1xuXHRcdFx0fSBlbHNlIGlmIChldWxlci5vcmRlciA9PT0gJ1pYWScpIHtcblx0XHRcdFx0Y29uc3QgY2UgPSBjICogZSxcblx0XHRcdFx0XHRcdFx0Y2YgPSBjICogZixcblx0XHRcdFx0XHRcdFx0ZGUgPSBkICogZSxcblx0XHRcdFx0XHRcdFx0ZGYgPSBkICogZjtcblx0XHRcdFx0dGVbMF0gPSBjZSAtIGRmICogYjtcblx0XHRcdFx0dGVbNF0gPSAtYSAqIGY7XG5cdFx0XHRcdHRlWzhdID0gZGUgKyBjZiAqIGI7XG5cdFx0XHRcdHRlWzFdID0gY2YgKyBkZSAqIGI7XG5cdFx0XHRcdHRlWzVdID0gYSAqIGU7XG5cdFx0XHRcdHRlWzldID0gZGYgLSBjZSAqIGI7XG5cdFx0XHRcdHRlWzJdID0gLWEgKiBkO1xuXHRcdFx0XHR0ZVs2XSA9IGI7XG5cdFx0XHRcdHRlWzEwXSA9IGEgKiBjO1xuXHRcdFx0fSBlbHNlIGlmIChldWxlci5vcmRlciA9PT0gJ1pZWCcpIHtcblx0XHRcdFx0Y29uc3QgYWUgPSBhICogZSxcblx0XHRcdFx0XHRcdFx0YWYgPSBhICogZixcblx0XHRcdFx0XHRcdFx0YmUgPSBiICogZSxcblx0XHRcdFx0XHRcdFx0YmYgPSBiICogZjtcblx0XHRcdFx0dGVbMF0gPSBjICogZTtcblx0XHRcdFx0dGVbNF0gPSBiZSAqIGQgLSBhZjtcblx0XHRcdFx0dGVbOF0gPSBhZSAqIGQgKyBiZjtcblx0XHRcdFx0dGVbMV0gPSBjICogZjtcblx0XHRcdFx0dGVbNV0gPSBiZiAqIGQgKyBhZTtcblx0XHRcdFx0dGVbOV0gPSBhZiAqIGQgLSBiZTtcblx0XHRcdFx0dGVbMl0gPSAtZDtcblx0XHRcdFx0dGVbNl0gPSBiICogYztcblx0XHRcdFx0dGVbMTBdID0gYSAqIGM7XG5cdFx0XHR9IGVsc2UgaWYgKGV1bGVyLm9yZGVyID09PSAnWVpYJykge1xuXHRcdFx0XHRjb25zdCBhYyA9IGEgKiBjLFxuXHRcdFx0XHRcdFx0XHRhZCA9IGEgKiBkLFxuXHRcdFx0XHRcdFx0XHRiYyA9IGIgKiBjLFxuXHRcdFx0XHRcdFx0XHRiZCA9IGIgKiBkO1xuXHRcdFx0XHR0ZVswXSA9IGMgKiBlO1xuXHRcdFx0XHR0ZVs0XSA9IGJkIC0gYWMgKiBmO1xuXHRcdFx0XHR0ZVs4XSA9IGJjICogZiArIGFkO1xuXHRcdFx0XHR0ZVsxXSA9IGY7XG5cdFx0XHRcdHRlWzVdID0gYSAqIGU7XG5cdFx0XHRcdHRlWzldID0gLWIgKiBlO1xuXHRcdFx0XHR0ZVsyXSA9IC1kICogZTtcblx0XHRcdFx0dGVbNl0gPSBhZCAqIGYgKyBiYztcblx0XHRcdFx0dGVbMTBdID0gYWMgLSBiZCAqIGY7XG5cdFx0XHR9IGVsc2UgaWYgKGV1bGVyLm9yZGVyID09PSAnWFpZJykge1xuXHRcdFx0XHRjb25zdCBhYyA9IGEgKiBjLFxuXHRcdFx0XHRcdFx0XHRhZCA9IGEgKiBkLFxuXHRcdFx0XHRcdFx0XHRiYyA9IGIgKiBjLFxuXHRcdFx0XHRcdFx0XHRiZCA9IGIgKiBkO1xuXHRcdFx0XHR0ZVswXSA9IGMgKiBlO1xuXHRcdFx0XHR0ZVs0XSA9IC1mO1xuXHRcdFx0XHR0ZVs4XSA9IGQgKiBlO1xuXHRcdFx0XHR0ZVsxXSA9IGFjICogZiArIGJkO1xuXHRcdFx0XHR0ZVs1XSA9IGEgKiBlO1xuXHRcdFx0XHR0ZVs5XSA9IGFkICogZiAtIGJjO1xuXHRcdFx0XHR0ZVsyXSA9IGJjICogZiAtIGFkO1xuXHRcdFx0XHR0ZVs2XSA9IGIgKiBlO1xuXHRcdFx0XHR0ZVsxMF0gPSBiZCAqIGYgKyBhYztcblx0XHRcdH0gLy8gYm90dG9tIHJvd1xuXG5cblx0XHRcdHRlWzNdID0gMDtcblx0XHRcdHRlWzddID0gMDtcblx0XHRcdHRlWzExXSA9IDA7IC8vIGxhc3QgY29sdW1uXG5cblx0XHRcdHRlWzEyXSA9IDA7XG5cdFx0XHR0ZVsxM10gPSAwO1xuXHRcdFx0dGVbMTRdID0gMDtcblx0XHRcdHRlWzE1XSA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRtYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbihxKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb21wb3NlKF96ZXJvLCBxLCBfb25lKTtcblx0XHR9XG5cblx0XHRsb29rQXQoZXllLCB0YXJnZXQsIHVwKSB7XG5cdFx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRcdF96LnN1YlZlY3RvcnMoZXllLCB0YXJnZXQpO1xuXG5cdFx0XHRpZiAoX3oubGVuZ3RoU3EoKSA9PT0gMCkge1xuXHRcdFx0XHQvLyBleWUgYW5kIHRhcmdldCBhcmUgaW4gdGhlIHNhbWUgcG9zaXRpb25cblx0XHRcdFx0X3oueiA9IDE7XG5cdFx0XHR9XG5cblx0XHRcdF96Lm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRfeC5jcm9zc1ZlY3RvcnModXAsIF96KTtcblxuXHRcdFx0aWYgKF94Lmxlbmd0aFNxKCkgPT09IDApIHtcblx0XHRcdFx0Ly8gdXAgYW5kIHogYXJlIHBhcmFsbGVsXG5cdFx0XHRcdGlmIChNYXRoLmFicyh1cC56KSA9PT0gMSkge1xuXHRcdFx0XHRcdF96LnggKz0gMC4wMDAxO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF96LnogKz0gMC4wMDAxO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X3oubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0X3guY3Jvc3NWZWN0b3JzKHVwLCBfeik7XG5cdFx0XHR9XG5cblx0XHRcdF94Lm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRfeS5jcm9zc1ZlY3RvcnMoX3osIF94KTtcblxuXHRcdFx0dGVbMF0gPSBfeC54O1xuXHRcdFx0dGVbNF0gPSBfeS54O1xuXHRcdFx0dGVbOF0gPSBfei54O1xuXHRcdFx0dGVbMV0gPSBfeC55O1xuXHRcdFx0dGVbNV0gPSBfeS55O1xuXHRcdFx0dGVbOV0gPSBfei55O1xuXHRcdFx0dGVbMl0gPSBfeC56O1xuXHRcdFx0dGVbNl0gPSBfeS56O1xuXHRcdFx0dGVbMTBdID0gX3ouejtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG11bHRpcGx5KG0sIG4pIHtcblx0XHRcdGlmIChuICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseU1hdHJpY2VzKCBhLCBiICkgaW5zdGVhZC4nKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyhtLCBuKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyh0aGlzLCBtKTtcblx0XHR9XG5cblx0XHRwcmVtdWx0aXBseShtKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKG0sIHRoaXMpO1xuXHRcdH1cblxuXHRcdG11bHRpcGx5TWF0cmljZXMoYSwgYikge1xuXHRcdFx0Y29uc3QgYWUgPSBhLmVsZW1lbnRzO1xuXHRcdFx0Y29uc3QgYmUgPSBiLmVsZW1lbnRzO1xuXHRcdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0Y29uc3QgYTExID0gYWVbMF0sXG5cdFx0XHRcdFx0XHRhMTIgPSBhZVs0XSxcblx0XHRcdFx0XHRcdGExMyA9IGFlWzhdLFxuXHRcdFx0XHRcdFx0YTE0ID0gYWVbMTJdO1xuXHRcdFx0Y29uc3QgYTIxID0gYWVbMV0sXG5cdFx0XHRcdFx0XHRhMjIgPSBhZVs1XSxcblx0XHRcdFx0XHRcdGEyMyA9IGFlWzldLFxuXHRcdFx0XHRcdFx0YTI0ID0gYWVbMTNdO1xuXHRcdFx0Y29uc3QgYTMxID0gYWVbMl0sXG5cdFx0XHRcdFx0XHRhMzIgPSBhZVs2XSxcblx0XHRcdFx0XHRcdGEzMyA9IGFlWzEwXSxcblx0XHRcdFx0XHRcdGEzNCA9IGFlWzE0XTtcblx0XHRcdGNvbnN0IGE0MSA9IGFlWzNdLFxuXHRcdFx0XHRcdFx0YTQyID0gYWVbN10sXG5cdFx0XHRcdFx0XHRhNDMgPSBhZVsxMV0sXG5cdFx0XHRcdFx0XHRhNDQgPSBhZVsxNV07XG5cdFx0XHRjb25zdCBiMTEgPSBiZVswXSxcblx0XHRcdFx0XHRcdGIxMiA9IGJlWzRdLFxuXHRcdFx0XHRcdFx0YjEzID0gYmVbOF0sXG5cdFx0XHRcdFx0XHRiMTQgPSBiZVsxMl07XG5cdFx0XHRjb25zdCBiMjEgPSBiZVsxXSxcblx0XHRcdFx0XHRcdGIyMiA9IGJlWzVdLFxuXHRcdFx0XHRcdFx0YjIzID0gYmVbOV0sXG5cdFx0XHRcdFx0XHRiMjQgPSBiZVsxM107XG5cdFx0XHRjb25zdCBiMzEgPSBiZVsyXSxcblx0XHRcdFx0XHRcdGIzMiA9IGJlWzZdLFxuXHRcdFx0XHRcdFx0YjMzID0gYmVbMTBdLFxuXHRcdFx0XHRcdFx0YjM0ID0gYmVbMTRdO1xuXHRcdFx0Y29uc3QgYjQxID0gYmVbM10sXG5cdFx0XHRcdFx0XHRiNDIgPSBiZVs3XSxcblx0XHRcdFx0XHRcdGI0MyA9IGJlWzExXSxcblx0XHRcdFx0XHRcdGI0NCA9IGJlWzE1XTtcblx0XHRcdHRlWzBdID0gYTExICogYjExICsgYTEyICogYjIxICsgYTEzICogYjMxICsgYTE0ICogYjQxO1xuXHRcdFx0dGVbNF0gPSBhMTEgKiBiMTIgKyBhMTIgKiBiMjIgKyBhMTMgKiBiMzIgKyBhMTQgKiBiNDI7XG5cdFx0XHR0ZVs4XSA9IGExMSAqIGIxMyArIGExMiAqIGIyMyArIGExMyAqIGIzMyArIGExNCAqIGI0Mztcblx0XHRcdHRlWzEyXSA9IGExMSAqIGIxNCArIGExMiAqIGIyNCArIGExMyAqIGIzNCArIGExNCAqIGI0NDtcblx0XHRcdHRlWzFdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxICsgYTI0ICogYjQxO1xuXHRcdFx0dGVbNV0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XG5cdFx0XHR0ZVs5XSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMyArIGEyNCAqIGI0Mztcblx0XHRcdHRlWzEzXSA9IGEyMSAqIGIxNCArIGEyMiAqIGIyNCArIGEyMyAqIGIzNCArIGEyNCAqIGI0NDtcblx0XHRcdHRlWzJdID0gYTMxICogYjExICsgYTMyICogYjIxICsgYTMzICogYjMxICsgYTM0ICogYjQxO1xuXHRcdFx0dGVbNl0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzIgKyBhMzQgKiBiNDI7XG5cdFx0XHR0ZVsxMF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzMgKyBhMzQgKiBiNDM7XG5cdFx0XHR0ZVsxNF0gPSBhMzEgKiBiMTQgKyBhMzIgKiBiMjQgKyBhMzMgKiBiMzQgKyBhMzQgKiBiNDQ7XG5cdFx0XHR0ZVszXSA9IGE0MSAqIGIxMSArIGE0MiAqIGIyMSArIGE0MyAqIGIzMSArIGE0NCAqIGI0MTtcblx0XHRcdHRlWzddID0gYTQxICogYjEyICsgYTQyICogYjIyICsgYTQzICogYjMyICsgYTQ0ICogYjQyO1xuXHRcdFx0dGVbMTFdID0gYTQxICogYjEzICsgYTQyICogYjIzICsgYTQzICogYjMzICsgYTQ0ICogYjQzO1xuXHRcdFx0dGVbMTVdID0gYTQxICogYjE0ICsgYTQyICogYjI0ICsgYTQzICogYjM0ICsgYTQ0ICogYjQ0O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bXVsdGlwbHlTY2FsYXIocykge1xuXHRcdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0dGVbMF0gKj0gcztcblx0XHRcdHRlWzRdICo9IHM7XG5cdFx0XHR0ZVs4XSAqPSBzO1xuXHRcdFx0dGVbMTJdICo9IHM7XG5cdFx0XHR0ZVsxXSAqPSBzO1xuXHRcdFx0dGVbNV0gKj0gcztcblx0XHRcdHRlWzldICo9IHM7XG5cdFx0XHR0ZVsxM10gKj0gcztcblx0XHRcdHRlWzJdICo9IHM7XG5cdFx0XHR0ZVs2XSAqPSBzO1xuXHRcdFx0dGVbMTBdICo9IHM7XG5cdFx0XHR0ZVsxNF0gKj0gcztcblx0XHRcdHRlWzNdICo9IHM7XG5cdFx0XHR0ZVs3XSAqPSBzO1xuXHRcdFx0dGVbMTFdICo9IHM7XG5cdFx0XHR0ZVsxNV0gKj0gcztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGRldGVybWluYW50KCkge1xuXHRcdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0Y29uc3QgbjExID0gdGVbMF0sXG5cdFx0XHRcdFx0XHRuMTIgPSB0ZVs0XSxcblx0XHRcdFx0XHRcdG4xMyA9IHRlWzhdLFxuXHRcdFx0XHRcdFx0bjE0ID0gdGVbMTJdO1xuXHRcdFx0Y29uc3QgbjIxID0gdGVbMV0sXG5cdFx0XHRcdFx0XHRuMjIgPSB0ZVs1XSxcblx0XHRcdFx0XHRcdG4yMyA9IHRlWzldLFxuXHRcdFx0XHRcdFx0bjI0ID0gdGVbMTNdO1xuXHRcdFx0Y29uc3QgbjMxID0gdGVbMl0sXG5cdFx0XHRcdFx0XHRuMzIgPSB0ZVs2XSxcblx0XHRcdFx0XHRcdG4zMyA9IHRlWzEwXSxcblx0XHRcdFx0XHRcdG4zNCA9IHRlWzE0XTtcblx0XHRcdGNvbnN0IG40MSA9IHRlWzNdLFxuXHRcdFx0XHRcdFx0bjQyID0gdGVbN10sXG5cdFx0XHRcdFx0XHRuNDMgPSB0ZVsxMV0sXG5cdFx0XHRcdFx0XHRuNDQgPSB0ZVsxNV07IC8vVE9ETzogbWFrZSB0aGlzIG1vcmUgZWZmaWNpZW50XG5cdFx0XHQvLyggYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtIClcblxuXHRcdFx0cmV0dXJuIG40MSAqICgrbjE0ICogbjIzICogbjMyIC0gbjEzICogbjI0ICogbjMyIC0gbjE0ICogbjIyICogbjMzICsgbjEyICogbjI0ICogbjMzICsgbjEzICogbjIyICogbjM0IC0gbjEyICogbjIzICogbjM0KSArIG40MiAqICgrbjExICogbjIzICogbjM0IC0gbjExICogbjI0ICogbjMzICsgbjE0ICogbjIxICogbjMzIC0gbjEzICogbjIxICogbjM0ICsgbjEzICogbjI0ICogbjMxIC0gbjE0ICogbjIzICogbjMxKSArIG40MyAqICgrbjExICogbjI0ICogbjMyIC0gbjExICogbjIyICogbjM0IC0gbjE0ICogbjIxICogbjMyICsgbjEyICogbjIxICogbjM0ICsgbjE0ICogbjIyICogbjMxIC0gbjEyICogbjI0ICogbjMxKSArIG40NCAqICgtbjEzICogbjIyICogbjMxIC0gbjExICogbjIzICogbjMyICsgbjExICogbjIyICogbjMzICsgbjEzICogbjIxICogbjMyIC0gbjEyICogbjIxICogbjMzICsgbjEyICogbjIzICogbjMxKTtcblx0XHR9XG5cblx0XHR0cmFuc3Bvc2UoKSB7XG5cdFx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0XHRsZXQgdG1wO1xuXHRcdFx0dG1wID0gdGVbMV07XG5cdFx0XHR0ZVsxXSA9IHRlWzRdO1xuXHRcdFx0dGVbNF0gPSB0bXA7XG5cdFx0XHR0bXAgPSB0ZVsyXTtcblx0XHRcdHRlWzJdID0gdGVbOF07XG5cdFx0XHR0ZVs4XSA9IHRtcDtcblx0XHRcdHRtcCA9IHRlWzZdO1xuXHRcdFx0dGVbNl0gPSB0ZVs5XTtcblx0XHRcdHRlWzldID0gdG1wO1xuXHRcdFx0dG1wID0gdGVbM107XG5cdFx0XHR0ZVszXSA9IHRlWzEyXTtcblx0XHRcdHRlWzEyXSA9IHRtcDtcblx0XHRcdHRtcCA9IHRlWzddO1xuXHRcdFx0dGVbN10gPSB0ZVsxM107XG5cdFx0XHR0ZVsxM10gPSB0bXA7XG5cdFx0XHR0bXAgPSB0ZVsxMV07XG5cdFx0XHR0ZVsxMV0gPSB0ZVsxNF07XG5cdFx0XHR0ZVsxNF0gPSB0bXA7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRQb3NpdGlvbih4LCB5LCB6KSB7XG5cdFx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRcdGlmICh4LmlzVmVjdG9yMykge1xuXHRcdFx0XHR0ZVsxMl0gPSB4Lng7XG5cdFx0XHRcdHRlWzEzXSA9IHgueTtcblx0XHRcdFx0dGVbMTRdID0geC56O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGVbMTJdID0geDtcblx0XHRcdFx0dGVbMTNdID0geTtcblx0XHRcdFx0dGVbMTRdID0gejtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0aW52ZXJ0KCkge1xuXHRcdFx0Ly8gYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtXG5cdFx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHMsXG5cdFx0XHRcdFx0XHRuMTEgPSB0ZVswXSxcblx0XHRcdFx0XHRcdG4yMSA9IHRlWzFdLFxuXHRcdFx0XHRcdFx0bjMxID0gdGVbMl0sXG5cdFx0XHRcdFx0XHRuNDEgPSB0ZVszXSxcblx0XHRcdFx0XHRcdG4xMiA9IHRlWzRdLFxuXHRcdFx0XHRcdFx0bjIyID0gdGVbNV0sXG5cdFx0XHRcdFx0XHRuMzIgPSB0ZVs2XSxcblx0XHRcdFx0XHRcdG40MiA9IHRlWzddLFxuXHRcdFx0XHRcdFx0bjEzID0gdGVbOF0sXG5cdFx0XHRcdFx0XHRuMjMgPSB0ZVs5XSxcblx0XHRcdFx0XHRcdG4zMyA9IHRlWzEwXSxcblx0XHRcdFx0XHRcdG40MyA9IHRlWzExXSxcblx0XHRcdFx0XHRcdG4xNCA9IHRlWzEyXSxcblx0XHRcdFx0XHRcdG4yNCA9IHRlWzEzXSxcblx0XHRcdFx0XHRcdG4zNCA9IHRlWzE0XSxcblx0XHRcdFx0XHRcdG40NCA9IHRlWzE1XSxcblx0XHRcdFx0XHRcdHQxMSA9IG4yMyAqIG4zNCAqIG40MiAtIG4yNCAqIG4zMyAqIG40MiArIG4yNCAqIG4zMiAqIG40MyAtIG4yMiAqIG4zNCAqIG40MyAtIG4yMyAqIG4zMiAqIG40NCArIG4yMiAqIG4zMyAqIG40NCxcblx0XHRcdFx0XHRcdHQxMiA9IG4xNCAqIG4zMyAqIG40MiAtIG4xMyAqIG4zNCAqIG40MiAtIG4xNCAqIG4zMiAqIG40MyArIG4xMiAqIG4zNCAqIG40MyArIG4xMyAqIG4zMiAqIG40NCAtIG4xMiAqIG4zMyAqIG40NCxcblx0XHRcdFx0XHRcdHQxMyA9IG4xMyAqIG4yNCAqIG40MiAtIG4xNCAqIG4yMyAqIG40MiArIG4xNCAqIG4yMiAqIG40MyAtIG4xMiAqIG4yNCAqIG40MyAtIG4xMyAqIG4yMiAqIG40NCArIG4xMiAqIG4yMyAqIG40NCxcblx0XHRcdFx0XHRcdHQxNCA9IG4xNCAqIG4yMyAqIG4zMiAtIG4xMyAqIG4yNCAqIG4zMiAtIG4xNCAqIG4yMiAqIG4zMyArIG4xMiAqIG4yNCAqIG4zMyArIG4xMyAqIG4yMiAqIG4zNCAtIG4xMiAqIG4yMyAqIG4zNDtcblx0XHRcdGNvbnN0IGRldCA9IG4xMSAqIHQxMSArIG4yMSAqIHQxMiArIG4zMSAqIHQxMyArIG40MSAqIHQxNDtcblx0XHRcdGlmIChkZXQgPT09IDApIHJldHVybiB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcblx0XHRcdGNvbnN0IGRldEludiA9IDEgLyBkZXQ7XG5cdFx0XHR0ZVswXSA9IHQxMSAqIGRldEludjtcblx0XHRcdHRlWzFdID0gKG4yNCAqIG4zMyAqIG40MSAtIG4yMyAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMSAqIG40MyArIG4yMSAqIG4zNCAqIG40MyArIG4yMyAqIG4zMSAqIG40NCAtIG4yMSAqIG4zMyAqIG40NCkgKiBkZXRJbnY7XG5cdFx0XHR0ZVsyXSA9IChuMjIgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzIgKiBuNDEgKyBuMjQgKiBuMzEgKiBuNDIgLSBuMjEgKiBuMzQgKiBuNDIgLSBuMjIgKiBuMzEgKiBuNDQgKyBuMjEgKiBuMzIgKiBuNDQpICogZGV0SW52O1xuXHRcdFx0dGVbM10gPSAobjIzICogbjMyICogbjQxIC0gbjIyICogbjMzICogbjQxIC0gbjIzICogbjMxICogbjQyICsgbjIxICogbjMzICogbjQyICsgbjIyICogbjMxICogbjQzIC0gbjIxICogbjMyICogbjQzKSAqIGRldEludjtcblx0XHRcdHRlWzRdID0gdDEyICogZGV0SW52O1xuXHRcdFx0dGVbNV0gPSAobjEzICogbjM0ICogbjQxIC0gbjE0ICogbjMzICogbjQxICsgbjE0ICogbjMxICogbjQzIC0gbjExICogbjM0ICogbjQzIC0gbjEzICogbjMxICogbjQ0ICsgbjExICogbjMzICogbjQ0KSAqIGRldEludjtcblx0XHRcdHRlWzZdID0gKG4xNCAqIG4zMiAqIG40MSAtIG4xMiAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMSAqIG40MiArIG4xMSAqIG4zNCAqIG40MiArIG4xMiAqIG4zMSAqIG40NCAtIG4xMSAqIG4zMiAqIG40NCkgKiBkZXRJbnY7XG5cdFx0XHR0ZVs3XSA9IChuMTIgKiBuMzMgKiBuNDEgLSBuMTMgKiBuMzIgKiBuNDEgKyBuMTMgKiBuMzEgKiBuNDIgLSBuMTEgKiBuMzMgKiBuNDIgLSBuMTIgKiBuMzEgKiBuNDMgKyBuMTEgKiBuMzIgKiBuNDMpICogZGV0SW52O1xuXHRcdFx0dGVbOF0gPSB0MTMgKiBkZXRJbnY7XG5cdFx0XHR0ZVs5XSA9IChuMTQgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjQgKiBuNDEgLSBuMTQgKiBuMjEgKiBuNDMgKyBuMTEgKiBuMjQgKiBuNDMgKyBuMTMgKiBuMjEgKiBuNDQgLSBuMTEgKiBuMjMgKiBuNDQpICogZGV0SW52O1xuXHRcdFx0dGVbMTBdID0gKG4xMiAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMiAqIG40MSArIG4xNCAqIG4yMSAqIG40MiAtIG4xMSAqIG4yNCAqIG40MiAtIG4xMiAqIG4yMSAqIG40NCArIG4xMSAqIG4yMiAqIG40NCkgKiBkZXRJbnY7XG5cdFx0XHR0ZVsxMV0gPSAobjEzICogbjIyICogbjQxIC0gbjEyICogbjIzICogbjQxIC0gbjEzICogbjIxICogbjQyICsgbjExICogbjIzICogbjQyICsgbjEyICogbjIxICogbjQzIC0gbjExICogbjIyICogbjQzKSAqIGRldEludjtcblx0XHRcdHRlWzEyXSA9IHQxNCAqIGRldEludjtcblx0XHRcdHRlWzEzXSA9IChuMTMgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjMgKiBuMzEgKyBuMTQgKiBuMjEgKiBuMzMgLSBuMTEgKiBuMjQgKiBuMzMgLSBuMTMgKiBuMjEgKiBuMzQgKyBuMTEgKiBuMjMgKiBuMzQpICogZGV0SW52O1xuXHRcdFx0dGVbMTRdID0gKG4xNCAqIG4yMiAqIG4zMSAtIG4xMiAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMSAqIG4zMiArIG4xMSAqIG4yNCAqIG4zMiArIG4xMiAqIG4yMSAqIG4zNCAtIG4xMSAqIG4yMiAqIG4zNCkgKiBkZXRJbnY7XG5cdFx0XHR0ZVsxNV0gPSAobjEyICogbjIzICogbjMxIC0gbjEzICogbjIyICogbjMxICsgbjEzICogbjIxICogbjMyIC0gbjExICogbjIzICogbjMyIC0gbjEyICogbjIxICogbjMzICsgbjExICogbjIyICogbjMzKSAqIGRldEludjtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNjYWxlKHYpIHtcblx0XHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdGNvbnN0IHggPSB2LngsXG5cdFx0XHRcdFx0XHR5ID0gdi55LFxuXHRcdFx0XHRcdFx0eiA9IHYuejtcblx0XHRcdHRlWzBdICo9IHg7XG5cdFx0XHR0ZVs0XSAqPSB5O1xuXHRcdFx0dGVbOF0gKj0gejtcblx0XHRcdHRlWzFdICo9IHg7XG5cdFx0XHR0ZVs1XSAqPSB5O1xuXHRcdFx0dGVbOV0gKj0gejtcblx0XHRcdHRlWzJdICo9IHg7XG5cdFx0XHR0ZVs2XSAqPSB5O1xuXHRcdFx0dGVbMTBdICo9IHo7XG5cdFx0XHR0ZVszXSAqPSB4O1xuXHRcdFx0dGVbN10gKj0geTtcblx0XHRcdHRlWzExXSAqPSB6O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Z2V0TWF4U2NhbGVPbkF4aXMoKSB7XG5cdFx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0XHRjb25zdCBzY2FsZVhTcSA9IHRlWzBdICogdGVbMF0gKyB0ZVsxXSAqIHRlWzFdICsgdGVbMl0gKiB0ZVsyXTtcblx0XHRcdGNvbnN0IHNjYWxlWVNxID0gdGVbNF0gKiB0ZVs0XSArIHRlWzVdICogdGVbNV0gKyB0ZVs2XSAqIHRlWzZdO1xuXHRcdFx0Y29uc3Qgc2NhbGVaU3EgPSB0ZVs4XSAqIHRlWzhdICsgdGVbOV0gKiB0ZVs5XSArIHRlWzEwXSAqIHRlWzEwXTtcblx0XHRcdHJldHVybiBNYXRoLnNxcnQoTWF0aC5tYXgoc2NhbGVYU3EsIHNjYWxlWVNxLCBzY2FsZVpTcSkpO1xuXHRcdH1cblxuXHRcdG1ha2VUcmFuc2xhdGlvbih4LCB5LCB6KSB7XG5cdFx0XHR0aGlzLnNldCgxLCAwLCAwLCB4LCAwLCAxLCAwLCB5LCAwLCAwLCAxLCB6LCAwLCAwLCAwLCAxKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG1ha2VSb3RhdGlvblgodGhldGEpIHtcblx0XHRcdGNvbnN0IGMgPSBNYXRoLmNvcyh0aGV0YSksXG5cdFx0XHRcdFx0XHRzID0gTWF0aC5zaW4odGhldGEpO1xuXHRcdFx0dGhpcy5zZXQoMSwgMCwgMCwgMCwgMCwgYywgLXMsIDAsIDAsIHMsIGMsIDAsIDAsIDAsIDAsIDEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bWFrZVJvdGF0aW9uWSh0aGV0YSkge1xuXHRcdFx0Y29uc3QgYyA9IE1hdGguY29zKHRoZXRhKSxcblx0XHRcdFx0XHRcdHMgPSBNYXRoLnNpbih0aGV0YSk7XG5cdFx0XHR0aGlzLnNldChjLCAwLCBzLCAwLCAwLCAxLCAwLCAwLCAtcywgMCwgYywgMCwgMCwgMCwgMCwgMSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRtYWtlUm90YXRpb25aKHRoZXRhKSB7XG5cdFx0XHRjb25zdCBjID0gTWF0aC5jb3ModGhldGEpLFxuXHRcdFx0XHRcdFx0cyA9IE1hdGguc2luKHRoZXRhKTtcblx0XHRcdHRoaXMuc2V0KGMsIC1zLCAwLCAwLCBzLCBjLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG1ha2VSb3RhdGlvbkF4aXMoYXhpcywgYW5nbGUpIHtcblx0XHRcdC8vIEJhc2VkIG9uIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvcmVmZXJlbmNlL2FydGljbGVzL2FydGljbGUxMTk5LmFzcFxuXHRcdFx0Y29uc3QgYyA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRcdGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZSk7XG5cdFx0XHRjb25zdCB0ID0gMSAtIGM7XG5cdFx0XHRjb25zdCB4ID0gYXhpcy54LFxuXHRcdFx0XHRcdFx0eSA9IGF4aXMueSxcblx0XHRcdFx0XHRcdHogPSBheGlzLno7XG5cdFx0XHRjb25zdCB0eCA9IHQgKiB4LFxuXHRcdFx0XHRcdFx0dHkgPSB0ICogeTtcblx0XHRcdHRoaXMuc2V0KHR4ICogeCArIGMsIHR4ICogeSAtIHMgKiB6LCB0eCAqIHogKyBzICogeSwgMCwgdHggKiB5ICsgcyAqIHosIHR5ICogeSArIGMsIHR5ICogeiAtIHMgKiB4LCAwLCB0eCAqIHogLSBzICogeSwgdHkgKiB6ICsgcyAqIHgsIHQgKiB6ICogeiArIGMsIDAsIDAsIDAsIDAsIDEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bWFrZVNjYWxlKHgsIHksIHopIHtcblx0XHRcdHRoaXMuc2V0KHgsIDAsIDAsIDAsIDAsIHksIDAsIDAsIDAsIDAsIHosIDAsIDAsIDAsIDAsIDEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bWFrZVNoZWFyKHh5LCB4eiwgeXgsIHl6LCB6eCwgenkpIHtcblx0XHRcdHRoaXMuc2V0KDEsIHl4LCB6eCwgMCwgeHksIDEsIHp5LCAwLCB4eiwgeXosIDEsIDAsIDAsIDAsIDAsIDEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29tcG9zZShwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUpIHtcblx0XHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdGNvbnN0IHggPSBxdWF0ZXJuaW9uLl94LFxuXHRcdFx0XHRcdFx0eSA9IHF1YXRlcm5pb24uX3ksXG5cdFx0XHRcdFx0XHR6ID0gcXVhdGVybmlvbi5feixcblx0XHRcdFx0XHRcdHcgPSBxdWF0ZXJuaW9uLl93O1xuXHRcdFx0Y29uc3QgeDIgPSB4ICsgeCxcblx0XHRcdFx0XHRcdHkyID0geSArIHksXG5cdFx0XHRcdFx0XHR6MiA9IHogKyB6O1xuXHRcdFx0Y29uc3QgeHggPSB4ICogeDIsXG5cdFx0XHRcdFx0XHR4eSA9IHggKiB5Mixcblx0XHRcdFx0XHRcdHh6ID0geCAqIHoyO1xuXHRcdFx0Y29uc3QgeXkgPSB5ICogeTIsXG5cdFx0XHRcdFx0XHR5eiA9IHkgKiB6Mixcblx0XHRcdFx0XHRcdHp6ID0geiAqIHoyO1xuXHRcdFx0Y29uc3Qgd3ggPSB3ICogeDIsXG5cdFx0XHRcdFx0XHR3eSA9IHcgKiB5Mixcblx0XHRcdFx0XHRcdHd6ID0gdyAqIHoyO1xuXHRcdFx0Y29uc3Qgc3ggPSBzY2FsZS54LFxuXHRcdFx0XHRcdFx0c3kgPSBzY2FsZS55LFxuXHRcdFx0XHRcdFx0c3ogPSBzY2FsZS56O1xuXHRcdFx0dGVbMF0gPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcblx0XHRcdHRlWzFdID0gKHh5ICsgd3opICogc3g7XG5cdFx0XHR0ZVsyXSA9ICh4eiAtIHd5KSAqIHN4O1xuXHRcdFx0dGVbM10gPSAwO1xuXHRcdFx0dGVbNF0gPSAoeHkgLSB3eikgKiBzeTtcblx0XHRcdHRlWzVdID0gKDEgLSAoeHggKyB6eikpICogc3k7XG5cdFx0XHR0ZVs2XSA9ICh5eiArIHd4KSAqIHN5O1xuXHRcdFx0dGVbN10gPSAwO1xuXHRcdFx0dGVbOF0gPSAoeHogKyB3eSkgKiBzejtcblx0XHRcdHRlWzldID0gKHl6IC0gd3gpICogc3o7XG5cdFx0XHR0ZVsxMF0gPSAoMSAtICh4eCArIHl5KSkgKiBzejtcblx0XHRcdHRlWzExXSA9IDA7XG5cdFx0XHR0ZVsxMl0gPSBwb3NpdGlvbi54O1xuXHRcdFx0dGVbMTNdID0gcG9zaXRpb24ueTtcblx0XHRcdHRlWzE0XSA9IHBvc2l0aW9uLno7XG5cdFx0XHR0ZVsxNV0gPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZGVjb21wb3NlKHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSkge1xuXHRcdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHRsZXQgc3ggPSBfdjEkNS5zZXQodGVbMF0sIHRlWzFdLCB0ZVsyXSkubGVuZ3RoKCk7XG5cblx0XHRcdGNvbnN0IHN5ID0gX3YxJDUuc2V0KHRlWzRdLCB0ZVs1XSwgdGVbNl0pLmxlbmd0aCgpO1xuXG5cdFx0XHRjb25zdCBzeiA9IF92MSQ1LnNldCh0ZVs4XSwgdGVbOV0sIHRlWzEwXSkubGVuZ3RoKCk7IC8vIGlmIGRldGVybWluZSBpcyBuZWdhdGl2ZSwgd2UgbmVlZCB0byBpbnZlcnQgb25lIHNjYWxlXG5cblxuXHRcdFx0Y29uc3QgZGV0ID0gdGhpcy5kZXRlcm1pbmFudCgpO1xuXHRcdFx0aWYgKGRldCA8IDApIHN4ID0gLXN4O1xuXHRcdFx0cG9zaXRpb24ueCA9IHRlWzEyXTtcblx0XHRcdHBvc2l0aW9uLnkgPSB0ZVsxM107XG5cdFx0XHRwb3NpdGlvbi56ID0gdGVbMTRdOyAvLyBzY2FsZSB0aGUgcm90YXRpb24gcGFydFxuXG5cdFx0XHRfbTEkMi5jb3B5KHRoaXMpO1xuXG5cdFx0XHRjb25zdCBpbnZTWCA9IDEgLyBzeDtcblx0XHRcdGNvbnN0IGludlNZID0gMSAvIHN5O1xuXHRcdFx0Y29uc3QgaW52U1ogPSAxIC8gc3o7XG5cdFx0XHRfbTEkMi5lbGVtZW50c1swXSAqPSBpbnZTWDtcblx0XHRcdF9tMSQyLmVsZW1lbnRzWzFdICo9IGludlNYO1xuXHRcdFx0X20xJDIuZWxlbWVudHNbMl0gKj0gaW52U1g7XG5cdFx0XHRfbTEkMi5lbGVtZW50c1s0XSAqPSBpbnZTWTtcblx0XHRcdF9tMSQyLmVsZW1lbnRzWzVdICo9IGludlNZO1xuXHRcdFx0X20xJDIuZWxlbWVudHNbNl0gKj0gaW52U1k7XG5cdFx0XHRfbTEkMi5lbGVtZW50c1s4XSAqPSBpbnZTWjtcblx0XHRcdF9tMSQyLmVsZW1lbnRzWzldICo9IGludlNaO1xuXHRcdFx0X20xJDIuZWxlbWVudHNbMTBdICo9IGludlNaO1xuXHRcdFx0cXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoX20xJDIpO1xuXHRcdFx0c2NhbGUueCA9IHN4O1xuXHRcdFx0c2NhbGUueSA9IHN5O1xuXHRcdFx0c2NhbGUueiA9IHN6O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bWFrZVBlcnNwZWN0aXZlKGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyKSB7XG5cdFx0XHRpZiAoZmFyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5NYXRyaXg0OiAubWFrZVBlcnNwZWN0aXZlKCkgaGFzIGJlZW4gcmVkZWZpbmVkIGFuZCBoYXMgYSBuZXcgc2lnbmF0dXJlLiBQbGVhc2UgY2hlY2sgdGhlIGRvY3MuJyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdGNvbnN0IHggPSAyICogbmVhciAvIChyaWdodCAtIGxlZnQpO1xuXHRcdFx0Y29uc3QgeSA9IDIgKiBuZWFyIC8gKHRvcCAtIGJvdHRvbSk7XG5cdFx0XHRjb25zdCBhID0gKHJpZ2h0ICsgbGVmdCkgLyAocmlnaHQgLSBsZWZ0KTtcblx0XHRcdGNvbnN0IGIgPSAodG9wICsgYm90dG9tKSAvICh0b3AgLSBib3R0b20pO1xuXHRcdFx0Y29uc3QgYyA9IC0oZmFyICsgbmVhcikgLyAoZmFyIC0gbmVhcik7XG5cdFx0XHRjb25zdCBkID0gLTIgKiBmYXIgKiBuZWFyIC8gKGZhciAtIG5lYXIpO1xuXHRcdFx0dGVbMF0gPSB4O1xuXHRcdFx0dGVbNF0gPSAwO1xuXHRcdFx0dGVbOF0gPSBhO1xuXHRcdFx0dGVbMTJdID0gMDtcblx0XHRcdHRlWzFdID0gMDtcblx0XHRcdHRlWzVdID0geTtcblx0XHRcdHRlWzldID0gYjtcblx0XHRcdHRlWzEzXSA9IDA7XG5cdFx0XHR0ZVsyXSA9IDA7XG5cdFx0XHR0ZVs2XSA9IDA7XG5cdFx0XHR0ZVsxMF0gPSBjO1xuXHRcdFx0dGVbMTRdID0gZDtcblx0XHRcdHRlWzNdID0gMDtcblx0XHRcdHRlWzddID0gMDtcblx0XHRcdHRlWzExXSA9IC0xO1xuXHRcdFx0dGVbMTVdID0gMDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG1ha2VPcnRob2dyYXBoaWMobGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIpIHtcblx0XHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdGNvbnN0IHcgPSAxLjAgLyAocmlnaHQgLSBsZWZ0KTtcblx0XHRcdGNvbnN0IGggPSAxLjAgLyAodG9wIC0gYm90dG9tKTtcblx0XHRcdGNvbnN0IHAgPSAxLjAgLyAoZmFyIC0gbmVhcik7XG5cdFx0XHRjb25zdCB4ID0gKHJpZ2h0ICsgbGVmdCkgKiB3O1xuXHRcdFx0Y29uc3QgeSA9ICh0b3AgKyBib3R0b20pICogaDtcblx0XHRcdGNvbnN0IHogPSAoZmFyICsgbmVhcikgKiBwO1xuXHRcdFx0dGVbMF0gPSAyICogdztcblx0XHRcdHRlWzRdID0gMDtcblx0XHRcdHRlWzhdID0gMDtcblx0XHRcdHRlWzEyXSA9IC14O1xuXHRcdFx0dGVbMV0gPSAwO1xuXHRcdFx0dGVbNV0gPSAyICogaDtcblx0XHRcdHRlWzldID0gMDtcblx0XHRcdHRlWzEzXSA9IC15O1xuXHRcdFx0dGVbMl0gPSAwO1xuXHRcdFx0dGVbNl0gPSAwO1xuXHRcdFx0dGVbMTBdID0gLTIgKiBwO1xuXHRcdFx0dGVbMTRdID0gLXo7XG5cdFx0XHR0ZVszXSA9IDA7XG5cdFx0XHR0ZVs3XSA9IDA7XG5cdFx0XHR0ZVsxMV0gPSAwO1xuXHRcdFx0dGVbMTVdID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGVxdWFscyhtYXRyaXgpIHtcblx0XHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdGNvbnN0IG1lID0gbWF0cml4LmVsZW1lbnRzO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcblx0XHRcdFx0aWYgKHRlW2ldICE9PSBtZVtpXSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRmcm9tQXJyYXkoYXJyYXksIG9mZnNldCA9IDApIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnRzW2ldID0gYXJyYXlbaSArIG9mZnNldF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRvQXJyYXkoYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCkge1xuXHRcdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0YXJyYXlbb2Zmc2V0XSA9IHRlWzBdO1xuXHRcdFx0YXJyYXlbb2Zmc2V0ICsgMV0gPSB0ZVsxXTtcblx0XHRcdGFycmF5W29mZnNldCArIDJdID0gdGVbMl07XG5cdFx0XHRhcnJheVtvZmZzZXQgKyAzXSA9IHRlWzNdO1xuXHRcdFx0YXJyYXlbb2Zmc2V0ICsgNF0gPSB0ZVs0XTtcblx0XHRcdGFycmF5W29mZnNldCArIDVdID0gdGVbNV07XG5cdFx0XHRhcnJheVtvZmZzZXQgKyA2XSA9IHRlWzZdO1xuXHRcdFx0YXJyYXlbb2Zmc2V0ICsgN10gPSB0ZVs3XTtcblx0XHRcdGFycmF5W29mZnNldCArIDhdID0gdGVbOF07XG5cdFx0XHRhcnJheVtvZmZzZXQgKyA5XSA9IHRlWzldO1xuXHRcdFx0YXJyYXlbb2Zmc2V0ICsgMTBdID0gdGVbMTBdO1xuXHRcdFx0YXJyYXlbb2Zmc2V0ICsgMTFdID0gdGVbMTFdO1xuXHRcdFx0YXJyYXlbb2Zmc2V0ICsgMTJdID0gdGVbMTJdO1xuXHRcdFx0YXJyYXlbb2Zmc2V0ICsgMTNdID0gdGVbMTNdO1xuXHRcdFx0YXJyYXlbb2Zmc2V0ICsgMTRdID0gdGVbMTRdO1xuXHRcdFx0YXJyYXlbb2Zmc2V0ICsgMTVdID0gdGVbMTVdO1xuXHRcdFx0cmV0dXJuIGFycmF5O1xuXHRcdH1cblxuXHR9XG5cblx0TWF0cml4NC5wcm90b3R5cGUuaXNNYXRyaXg0ID0gdHJ1ZTtcblxuXHRjb25zdCBfdjEkNSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9tMSQyID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5cblx0Y29uc3QgX3plcm8gPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG5cblx0Y29uc3QgX29uZSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygxLCAxLCAxKTtcblxuXHRjb25zdCBfeCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF95ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3ogPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfbWF0cml4JDEgPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDQoKTtcblxuXHRjb25zdCBfcXVhdGVybmlvbiQzID0gLypAX19QVVJFX18qL25ldyBRdWF0ZXJuaW9uKCk7XG5cblx0Y2xhc3MgRXVsZXIge1xuXHRcdGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgeiA9IDAsIG9yZGVyID0gRXVsZXIuRGVmYXVsdE9yZGVyKSB7XG5cdFx0XHR0aGlzLl94ID0geDtcblx0XHRcdHRoaXMuX3kgPSB5O1xuXHRcdFx0dGhpcy5feiA9IHo7XG5cdFx0XHR0aGlzLl9vcmRlciA9IG9yZGVyO1xuXHRcdH1cblxuXHRcdGdldCB4KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3g7XG5cdFx0fVxuXG5cdFx0c2V0IHgodmFsdWUpIHtcblx0XHRcdHRoaXMuX3ggPSB2YWx1ZTtcblxuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXHRcdH1cblxuXHRcdGdldCB5KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3k7XG5cdFx0fVxuXG5cdFx0c2V0IHkodmFsdWUpIHtcblx0XHRcdHRoaXMuX3kgPSB2YWx1ZTtcblxuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXHRcdH1cblxuXHRcdGdldCB6KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3o7XG5cdFx0fVxuXG5cdFx0c2V0IHoodmFsdWUpIHtcblx0XHRcdHRoaXMuX3ogPSB2YWx1ZTtcblxuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXHRcdH1cblxuXHRcdGdldCBvcmRlcigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9vcmRlcjtcblx0XHR9XG5cblx0XHRzZXQgb3JkZXIodmFsdWUpIHtcblx0XHRcdHRoaXMuX29yZGVyID0gdmFsdWU7XG5cblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblx0XHR9XG5cblx0XHRzZXQoeCwgeSwgeiwgb3JkZXIgPSB0aGlzLl9vcmRlcikge1xuXHRcdFx0dGhpcy5feCA9IHg7XG5cdFx0XHR0aGlzLl95ID0geTtcblx0XHRcdHRoaXMuX3ogPSB6O1xuXHRcdFx0dGhpcy5fb3JkZXIgPSBvcmRlcjtcblxuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl9vcmRlcik7XG5cdFx0fVxuXG5cdFx0Y29weShldWxlcikge1xuXHRcdFx0dGhpcy5feCA9IGV1bGVyLl94O1xuXHRcdFx0dGhpcy5feSA9IGV1bGVyLl95O1xuXHRcdFx0dGhpcy5feiA9IGV1bGVyLl96O1xuXHRcdFx0dGhpcy5fb3JkZXIgPSBldWxlci5fb3JkZXI7XG5cblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0RnJvbVJvdGF0aW9uTWF0cml4KG0sIG9yZGVyID0gdGhpcy5fb3JkZXIsIHVwZGF0ZSA9IHRydWUpIHtcblx0XHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cdFx0XHRjb25zdCB0ZSA9IG0uZWxlbWVudHM7XG5cdFx0XHRjb25zdCBtMTEgPSB0ZVswXSxcblx0XHRcdFx0XHRcdG0xMiA9IHRlWzRdLFxuXHRcdFx0XHRcdFx0bTEzID0gdGVbOF07XG5cdFx0XHRjb25zdCBtMjEgPSB0ZVsxXSxcblx0XHRcdFx0XHRcdG0yMiA9IHRlWzVdLFxuXHRcdFx0XHRcdFx0bTIzID0gdGVbOV07XG5cdFx0XHRjb25zdCBtMzEgPSB0ZVsyXSxcblx0XHRcdFx0XHRcdG0zMiA9IHRlWzZdLFxuXHRcdFx0XHRcdFx0bTMzID0gdGVbMTBdO1xuXG5cdFx0XHRzd2l0Y2ggKG9yZGVyKSB7XG5cdFx0XHRcdGNhc2UgJ1hZWic6XG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbihjbGFtcChtMTMsIC0xLCAxKSk7XG5cblx0XHRcdFx0XHRpZiAoTWF0aC5hYnMobTEzKSA8IDAuOTk5OTk5OSkge1xuXHRcdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoLW0yMywgbTMzKTtcblx0XHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKC1tMTIsIG0xMSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKG0zMiwgbTIyKTtcblx0XHRcdFx0XHRcdHRoaXMuX3ogPSAwO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1lYWic6XG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbigtY2xhbXAobTIzLCAtMSwgMSkpO1xuXG5cdFx0XHRcdFx0aWYgKE1hdGguYWJzKG0yMykgPCAwLjk5OTk5OTkpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKG0xMywgbTMzKTtcblx0XHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKG0yMSwgbTIyKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoLW0zMSwgbTExKTtcblx0XHRcdFx0XHRcdHRoaXMuX3ogPSAwO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1pYWSc6XG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbihjbGFtcChtMzIsIC0xLCAxKSk7XG5cblx0XHRcdFx0XHRpZiAoTWF0aC5hYnMobTMyKSA8IDAuOTk5OTk5OSkge1xuXHRcdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoLW0zMSwgbTMzKTtcblx0XHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKC1tMTIsIG0yMik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuX3kgPSAwO1xuXHRcdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIobTIxLCBtMTEpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1pZWCc6XG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbigtY2xhbXAobTMxLCAtMSwgMSkpO1xuXG5cdFx0XHRcdFx0aWYgKE1hdGguYWJzKG0zMSkgPCAwLjk5OTk5OTkpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKG0zMiwgbTMzKTtcblx0XHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKG0yMSwgbTExKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMigtbTEyLCBtMjIpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1laWCc6XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbihjbGFtcChtMjEsIC0xLCAxKSk7XG5cblx0XHRcdFx0XHRpZiAoTWF0aC5hYnMobTIxKSA8IDAuOTk5OTk5OSkge1xuXHRcdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoLW0yMywgbTIyKTtcblx0XHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKC1tMzEsIG0xMSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIobTEzLCBtMzMpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1haWSc6XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbigtY2xhbXAobTEyLCAtMSwgMSkpO1xuXG5cdFx0XHRcdFx0aWYgKE1hdGguYWJzKG0xMikgPCAwLjk5OTk5OTkpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKG0zMiwgbTIyKTtcblx0XHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKG0xMywgbTExKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoLW0yMywgbTMzKTtcblx0XHRcdFx0XHRcdHRoaXMuX3kgPSAwO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5FdWxlcjogLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICcgKyBvcmRlcik7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX29yZGVyID0gb3JkZXI7XG5cdFx0XHRpZiAodXBkYXRlID09PSB0cnVlKSB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRGcm9tUXVhdGVybmlvbihxLCBvcmRlciwgdXBkYXRlKSB7XG5cdFx0XHRfbWF0cml4JDEubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24ocSk7XG5cblx0XHRcdHJldHVybiB0aGlzLnNldEZyb21Sb3RhdGlvbk1hdHJpeChfbWF0cml4JDEsIG9yZGVyLCB1cGRhdGUpO1xuXHRcdH1cblxuXHRcdHNldEZyb21WZWN0b3IzKHYsIG9yZGVyID0gdGhpcy5fb3JkZXIpIHtcblx0XHRcdHJldHVybiB0aGlzLnNldCh2LngsIHYueSwgdi56LCBvcmRlcik7XG5cdFx0fVxuXG5cdFx0cmVvcmRlcihuZXdPcmRlcikge1xuXHRcdFx0Ly8gV0FSTklORzogdGhpcyBkaXNjYXJkcyByZXZvbHV0aW9uIGluZm9ybWF0aW9uIC1iaG91c3RvblxuXHRcdFx0X3F1YXRlcm5pb24kMy5zZXRGcm9tRXVsZXIodGhpcyk7XG5cblx0XHRcdHJldHVybiB0aGlzLnNldEZyb21RdWF0ZXJuaW9uKF9xdWF0ZXJuaW9uJDMsIG5ld09yZGVyKTtcblx0XHR9XG5cblx0XHRlcXVhbHMoZXVsZXIpIHtcblx0XHRcdHJldHVybiBldWxlci5feCA9PT0gdGhpcy5feCAmJiBldWxlci5feSA9PT0gdGhpcy5feSAmJiBldWxlci5feiA9PT0gdGhpcy5feiAmJiBldWxlci5fb3JkZXIgPT09IHRoaXMuX29yZGVyO1xuXHRcdH1cblxuXHRcdGZyb21BcnJheShhcnJheSkge1xuXHRcdFx0dGhpcy5feCA9IGFycmF5WzBdO1xuXHRcdFx0dGhpcy5feSA9IGFycmF5WzFdO1xuXHRcdFx0dGhpcy5feiA9IGFycmF5WzJdO1xuXHRcdFx0aWYgKGFycmF5WzNdICE9PSB1bmRlZmluZWQpIHRoaXMuX29yZGVyID0gYXJyYXlbM107XG5cblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dG9BcnJheShhcnJheSA9IFtdLCBvZmZzZXQgPSAwKSB7XG5cdFx0XHRhcnJheVtvZmZzZXRdID0gdGhpcy5feDtcblx0XHRcdGFycmF5W29mZnNldCArIDFdID0gdGhpcy5feTtcblx0XHRcdGFycmF5W29mZnNldCArIDJdID0gdGhpcy5fejtcblx0XHRcdGFycmF5W29mZnNldCArIDNdID0gdGhpcy5fb3JkZXI7XG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cdFx0fVxuXG5cdFx0dG9WZWN0b3IzKG9wdGlvbmFsUmVzdWx0KSB7XG5cdFx0XHRpZiAob3B0aW9uYWxSZXN1bHQpIHtcblx0XHRcdFx0cmV0dXJuIG9wdGlvbmFsUmVzdWx0LnNldCh0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRfb25DaGFuZ2UoY2FsbGJhY2spIHtcblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdF9vbkNoYW5nZUNhbGxiYWNrKCkge31cblxuXHR9XG5cblx0RXVsZXIucHJvdG90eXBlLmlzRXVsZXIgPSB0cnVlO1xuXHRFdWxlci5EZWZhdWx0T3JkZXIgPSAnWFlaJztcblx0RXVsZXIuUm90YXRpb25PcmRlcnMgPSBbJ1hZWicsICdZWlgnLCAnWlhZJywgJ1haWScsICdZWFonLCAnWllYJ107XG5cblx0Y2xhc3MgTGF5ZXJzIHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHRoaXMubWFzayA9IDEgfCAwO1xuXHRcdH1cblxuXHRcdHNldChjaGFubmVsKSB7XG5cdFx0XHR0aGlzLm1hc2sgPSAoMSA8PCBjaGFubmVsIHwgMCkgPj4+IDA7XG5cdFx0fVxuXG5cdFx0ZW5hYmxlKGNoYW5uZWwpIHtcblx0XHRcdHRoaXMubWFzayB8PSAxIDw8IGNoYW5uZWwgfCAwO1xuXHRcdH1cblxuXHRcdGVuYWJsZUFsbCgpIHtcblx0XHRcdHRoaXMubWFzayA9IDB4ZmZmZmZmZmYgfCAwO1xuXHRcdH1cblxuXHRcdHRvZ2dsZShjaGFubmVsKSB7XG5cdFx0XHR0aGlzLm1hc2sgXj0gMSA8PCBjaGFubmVsIHwgMDtcblx0XHR9XG5cblx0XHRkaXNhYmxlKGNoYW5uZWwpIHtcblx0XHRcdHRoaXMubWFzayAmPSB+KDEgPDwgY2hhbm5lbCB8IDApO1xuXHRcdH1cblxuXHRcdGRpc2FibGVBbGwoKSB7XG5cdFx0XHR0aGlzLm1hc2sgPSAwO1xuXHRcdH1cblxuXHRcdHRlc3QobGF5ZXJzKSB7XG5cdFx0XHRyZXR1cm4gKHRoaXMubWFzayAmIGxheWVycy5tYXNrKSAhPT0gMDtcblx0XHR9XG5cblx0XHRpc0VuYWJsZWQoY2hhbm5lbCkge1xuXHRcdFx0cmV0dXJuICh0aGlzLm1hc2sgJiAoMSA8PCBjaGFubmVsIHwgMCkpICE9PSAwO1xuXHRcdH1cblxuXHR9XG5cblx0bGV0IF9vYmplY3QzRElkID0gMDtcblxuXHRjb25zdCBfdjEkNCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9xMSA9IC8qQF9fUFVSRV9fKi9uZXcgUXVhdGVybmlvbigpO1xuXG5cdGNvbnN0IF9tMSQxID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5cblx0Y29uc3QgX3RhcmdldCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9wb3NpdGlvbiQzID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3NjYWxlJDIgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfcXVhdGVybmlvbiQyID0gLypAX19QVVJFX18qL25ldyBRdWF0ZXJuaW9uKCk7XG5cblx0Y29uc3QgX3hBeGlzID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKDEsIDAsIDApO1xuXG5cdGNvbnN0IF95QXhpcyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygwLCAxLCAwKTtcblxuXHRjb25zdCBfekF4aXMgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoMCwgMCwgMSk7XG5cblx0Y29uc3QgX2FkZGVkRXZlbnQgPSB7XG5cdFx0dHlwZTogJ2FkZGVkJ1xuXHR9O1xuXHRjb25zdCBfcmVtb3ZlZEV2ZW50ID0ge1xuXHRcdHR5cGU6ICdyZW1vdmVkJ1xuXHR9O1xuXG5cdGNsYXNzIE9iamVjdDNEIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lkJywge1xuXHRcdFx0XHR2YWx1ZTogX29iamVjdDNESWQrK1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLnV1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcblx0XHRcdHRoaXMubmFtZSA9ICcnO1xuXHRcdFx0dGhpcy50eXBlID0gJ09iamVjdDNEJztcblx0XHRcdHRoaXMucGFyZW50ID0gbnVsbDtcblx0XHRcdHRoaXMuY2hpbGRyZW4gPSBbXTtcblx0XHRcdHRoaXMudXAgPSBPYmplY3QzRC5EZWZhdWx0VXAuY2xvbmUoKTtcblx0XHRcdGNvbnN0IHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IHJvdGF0aW9uID0gbmV3IEV1bGVyKCk7XG5cdFx0XHRjb25zdCBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblx0XHRcdGNvbnN0IHNjYWxlID0gbmV3IFZlY3RvcjMoMSwgMSwgMSk7XG5cblx0XHRcdGZ1bmN0aW9uIG9uUm90YXRpb25DaGFuZ2UoKSB7XG5cdFx0XHRcdHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKHJvdGF0aW9uLCBmYWxzZSk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIG9uUXVhdGVybmlvbkNoYW5nZSgpIHtcblx0XHRcdFx0cm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24ocXVhdGVybmlvbiwgdW5kZWZpbmVkLCBmYWxzZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJvdGF0aW9uLl9vbkNoYW5nZShvblJvdGF0aW9uQ2hhbmdlKTtcblxuXHRcdFx0cXVhdGVybmlvbi5fb25DaGFuZ2Uob25RdWF0ZXJuaW9uQ2hhbmdlKTtcblxuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuXHRcdFx0XHRwb3NpdGlvbjoge1xuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHZhbHVlOiBwb3NpdGlvblxuXHRcdFx0XHR9LFxuXHRcdFx0XHRyb3RhdGlvbjoge1xuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHZhbHVlOiByb3RhdGlvblxuXHRcdFx0XHR9LFxuXHRcdFx0XHRxdWF0ZXJuaW9uOiB7XG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IHF1YXRlcm5pb25cblx0XHRcdFx0fSxcblx0XHRcdFx0c2NhbGU6IHtcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogc2NhbGVcblx0XHRcdFx0fSxcblx0XHRcdFx0bW9kZWxWaWV3TWF0cml4OiB7XG5cdFx0XHRcdFx0dmFsdWU6IG5ldyBNYXRyaXg0KClcblx0XHRcdFx0fSxcblx0XHRcdFx0bm9ybWFsTWF0cml4OiB7XG5cdFx0XHRcdFx0dmFsdWU6IG5ldyBNYXRyaXgzKClcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLm1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkID0gbmV3IE1hdHJpeDQoKTtcblx0XHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IE9iamVjdDNELkRlZmF1bHRNYXRyaXhBdXRvVXBkYXRlO1xuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XG5cdFx0XHR0aGlzLmxheWVycyA9IG5ldyBMYXllcnMoKTtcblx0XHRcdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cdFx0XHR0aGlzLmNhc3RTaGFkb3cgPSBmYWxzZTtcblx0XHRcdHRoaXMucmVjZWl2ZVNoYWRvdyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5mcnVzdHVtQ3VsbGVkID0gdHJ1ZTtcblx0XHRcdHRoaXMucmVuZGVyT3JkZXIgPSAwO1xuXHRcdFx0dGhpcy5hbmltYXRpb25zID0gW107XG5cdFx0XHR0aGlzLnVzZXJEYXRhID0ge307XG5cdFx0fVxuXG5cdFx0b25CZWZvcmVSZW5kZXIoKSB7fVxuXG5cdFx0b25BZnRlclJlbmRlcigpIHt9XG5cblx0XHRhcHBseU1hdHJpeDQobWF0cml4KSB7XG5cdFx0XHRpZiAodGhpcy5tYXRyaXhBdXRvVXBkYXRlKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXHRcdFx0dGhpcy5tYXRyaXgucHJlbXVsdGlwbHkobWF0cml4KTtcblx0XHRcdHRoaXMubWF0cml4LmRlY29tcG9zZSh0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHRoaXMuc2NhbGUpO1xuXHRcdH1cblxuXHRcdGFwcGx5UXVhdGVybmlvbihxKSB7XG5cdFx0XHR0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkocSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRSb3RhdGlvbkZyb21BeGlzQW5nbGUoYXhpcywgYW5nbGUpIHtcblx0XHRcdC8vIGFzc3VtZXMgYXhpcyBpcyBub3JtYWxpemVkXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZShheGlzLCBhbmdsZSk7XG5cdFx0fVxuXG5cdFx0c2V0Um90YXRpb25Gcm9tRXVsZXIoZXVsZXIpIHtcblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoZXVsZXIsIHRydWUpO1xuXHRcdH1cblxuXHRcdHNldFJvdGF0aW9uRnJvbU1hdHJpeChtKSB7XG5cdFx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChtKTtcblx0XHR9XG5cblx0XHRzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHEpIHtcblx0XHRcdC8vIGFzc3VtZXMgcSBpcyBub3JtYWxpemVkXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24uY29weShxKTtcblx0XHR9XG5cblx0XHRyb3RhdGVPbkF4aXMoYXhpcywgYW5nbGUpIHtcblx0XHRcdC8vIHJvdGF0ZSBvYmplY3Qgb24gYXhpcyBpbiBvYmplY3Qgc3BhY2Vcblx0XHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cdFx0XHRfcTEuc2V0RnJvbUF4aXNBbmdsZShheGlzLCBhbmdsZSk7XG5cblx0XHRcdHRoaXMucXVhdGVybmlvbi5tdWx0aXBseShfcTEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0cm90YXRlT25Xb3JsZEF4aXMoYXhpcywgYW5nbGUpIHtcblx0XHRcdC8vIHJvdGF0ZSBvYmplY3Qgb24gYXhpcyBpbiB3b3JsZCBzcGFjZVxuXHRcdFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblx0XHRcdC8vIG1ldGhvZCBhc3N1bWVzIG5vIHJvdGF0ZWQgcGFyZW50XG5cdFx0XHRfcTEuc2V0RnJvbUF4aXNBbmdsZShheGlzLCBhbmdsZSk7XG5cblx0XHRcdHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseShfcTEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0cm90YXRlWChhbmdsZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKF94QXhpcywgYW5nbGUpO1xuXHRcdH1cblxuXHRcdHJvdGF0ZVkoYW5nbGUpIHtcblx0XHRcdHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyhfeUF4aXMsIGFuZ2xlKTtcblx0XHR9XG5cblx0XHRyb3RhdGVaKGFuZ2xlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoX3pBeGlzLCBhbmdsZSk7XG5cdFx0fVxuXG5cdFx0dHJhbnNsYXRlT25BeGlzKGF4aXMsIGRpc3RhbmNlKSB7XG5cdFx0XHQvLyB0cmFuc2xhdGUgb2JqZWN0IGJ5IGRpc3RhbmNlIGFsb25nIGF4aXMgaW4gb2JqZWN0IHNwYWNlXG5cdFx0XHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXHRcdFx0X3YxJDQuY29weShheGlzKS5hcHBseVF1YXRlcm5pb24odGhpcy5xdWF0ZXJuaW9uKTtcblxuXHRcdFx0dGhpcy5wb3NpdGlvbi5hZGQoX3YxJDQubXVsdGlwbHlTY2FsYXIoZGlzdGFuY2UpKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRyYW5zbGF0ZVgoZGlzdGFuY2UpIHtcblx0XHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyhfeEF4aXMsIGRpc3RhbmNlKTtcblx0XHR9XG5cblx0XHR0cmFuc2xhdGVZKGRpc3RhbmNlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoX3lBeGlzLCBkaXN0YW5jZSk7XG5cdFx0fVxuXG5cdFx0dHJhbnNsYXRlWihkaXN0YW5jZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKF96QXhpcywgZGlzdGFuY2UpO1xuXHRcdH1cblxuXHRcdGxvY2FsVG9Xb3JsZCh2ZWN0b3IpIHtcblx0XHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4V29ybGQpO1xuXHRcdH1cblxuXHRcdHdvcmxkVG9Mb2NhbCh2ZWN0b3IpIHtcblx0XHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KF9tMSQxLmNvcHkodGhpcy5tYXRyaXhXb3JsZCkuaW52ZXJ0KCkpO1xuXHRcdH1cblxuXHRcdGxvb2tBdCh4LCB5LCB6KSB7XG5cdFx0XHQvLyBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IG9iamVjdHMgaGF2aW5nIG5vbi11bmlmb3JtbHktc2NhbGVkIHBhcmVudChzKVxuXHRcdFx0aWYgKHguaXNWZWN0b3IzKSB7XG5cdFx0XHRcdF90YXJnZXQuY29weSh4KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF90YXJnZXQuc2V0KHgsIHksIHopO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblx0XHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuXG5cdFx0XHRfcG9zaXRpb24kMy5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5tYXRyaXhXb3JsZCk7XG5cblx0XHRcdGlmICh0aGlzLmlzQ2FtZXJhIHx8IHRoaXMuaXNMaWdodCkge1xuXHRcdFx0XHRfbTEkMS5sb29rQXQoX3Bvc2l0aW9uJDMsIF90YXJnZXQsIHRoaXMudXApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X20xJDEubG9va0F0KF90YXJnZXQsIF9wb3NpdGlvbiQzLCB0aGlzLnVwKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChfbTEkMSk7XG5cblx0XHRcdGlmIChwYXJlbnQpIHtcblx0XHRcdFx0X20xJDEuZXh0cmFjdFJvdGF0aW9uKHBhcmVudC5tYXRyaXhXb3JsZCk7XG5cblx0XHRcdFx0X3ExLnNldEZyb21Sb3RhdGlvbk1hdHJpeChfbTEkMSk7XG5cblx0XHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KF9xMS5pbnZlcnQoKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YWRkKG9iamVjdCkge1xuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5hZGQoYXJndW1lbnRzW2ldKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob2JqZWN0ID09PSB0aGlzKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IGNhblxcJ3QgYmUgYWRkZWQgYXMgYSBjaGlsZCBvZiBpdHNlbGYuJywgb2JqZWN0KTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvYmplY3QgJiYgb2JqZWN0LmlzT2JqZWN0M0QpIHtcblx0XHRcdFx0aWYgKG9iamVjdC5wYXJlbnQgIT09IG51bGwpIHtcblx0XHRcdFx0XHRvYmplY3QucGFyZW50LnJlbW92ZShvYmplY3QpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0b2JqZWN0LnBhcmVudCA9IHRoaXM7XG5cdFx0XHRcdHRoaXMuY2hpbGRyZW4ucHVzaChvYmplY3QpO1xuXHRcdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudChfYWRkZWRFdmVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuT2JqZWN0M0QuJywgb2JqZWN0KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0cmVtb3ZlKG9iamVjdCkge1xuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5yZW1vdmUoYXJndW1lbnRzW2ldKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihvYmplY3QpO1xuXG5cdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdG9iamVjdC5wYXJlbnQgPSBudWxsO1xuXHRcdFx0XHR0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdG9iamVjdC5kaXNwYXRjaEV2ZW50KF9yZW1vdmVkRXZlbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRyZW1vdmVGcm9tUGFyZW50KCkge1xuXHRcdFx0Y29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cblx0XHRcdGlmIChwYXJlbnQgIT09IG51bGwpIHtcblx0XHRcdFx0cGFyZW50LnJlbW92ZSh0aGlzKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y2xlYXIoKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29uc3Qgb2JqZWN0ID0gdGhpcy5jaGlsZHJlbltpXTtcblx0XHRcdFx0b2JqZWN0LnBhcmVudCA9IG51bGw7XG5cdFx0XHRcdG9iamVjdC5kaXNwYXRjaEV2ZW50KF9yZW1vdmVkRXZlbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmNoaWxkcmVuLmxlbmd0aCA9IDA7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRhdHRhY2gob2JqZWN0KSB7XG5cdFx0XHQvLyBhZGRzIG9iamVjdCBhcyBhIGNoaWxkIG9mIHRoaXMsIHdoaWxlIG1haW50YWluaW5nIHRoZSBvYmplY3QncyB3b3JsZCB0cmFuc2Zvcm1cblx0XHRcdC8vIE5vdGU6IFRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgc2NlbmUgZ3JhcGhzIGhhdmluZyBub24tdW5pZm9ybWx5LXNjYWxlZCBub2RlcyhzKVxuXHRcdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCh0cnVlLCBmYWxzZSk7XG5cblx0XHRcdF9tMSQxLmNvcHkodGhpcy5tYXRyaXhXb3JsZCkuaW52ZXJ0KCk7XG5cblx0XHRcdGlmIChvYmplY3QucGFyZW50ICE9PSBudWxsKSB7XG5cdFx0XHRcdG9iamVjdC5wYXJlbnQudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuXG5cdFx0XHRcdF9tMSQxLm11bHRpcGx5KG9iamVjdC5wYXJlbnQubWF0cml4V29ybGQpO1xuXHRcdFx0fVxuXG5cdFx0XHRvYmplY3QuYXBwbHlNYXRyaXg0KF9tMSQxKTtcblx0XHRcdHRoaXMuYWRkKG9iamVjdCk7XG5cdFx0XHRvYmplY3QudXBkYXRlV29ybGRNYXRyaXgoZmFsc2UsIHRydWUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Z2V0T2JqZWN0QnlJZChpZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSgnaWQnLCBpZCk7XG5cdFx0fVxuXG5cdFx0Z2V0T2JqZWN0QnlOYW1lKG5hbWUpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldE9iamVjdEJ5UHJvcGVydHkoJ25hbWUnLCBuYW1lKTtcblx0XHR9XG5cblx0XHRnZXRPYmplY3RCeVByb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG5cdFx0XHRpZiAodGhpc1tuYW1lXSA9PT0gdmFsdWUpIHJldHVybiB0aGlzO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcblx0XHRcdFx0Y29uc3Qgb2JqZWN0ID0gY2hpbGQuZ2V0T2JqZWN0QnlQcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG5cblx0XHRcdFx0aWYgKG9iamVjdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iamVjdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdGdldFdvcmxkUG9zaXRpb24odGFyZ2V0KSB7XG5cdFx0XHR0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcblx0XHRcdHJldHVybiB0YXJnZXQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubWF0cml4V29ybGQpO1xuXHRcdH1cblxuXHRcdGdldFdvcmxkUXVhdGVybmlvbih0YXJnZXQpIHtcblx0XHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoX3Bvc2l0aW9uJDMsIHRhcmdldCwgX3NjYWxlJDIpO1xuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRnZXRXb3JsZFNjYWxlKHRhcmdldCkge1xuXHRcdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCh0cnVlLCBmYWxzZSk7XG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZShfcG9zaXRpb24kMywgX3F1YXRlcm5pb24kMiwgdGFyZ2V0KTtcblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cdFx0fVxuXG5cdFx0Z2V0V29ybGREaXJlY3Rpb24odGFyZ2V0KSB7XG5cdFx0XHR0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcblx0XHRcdGNvbnN0IGUgPSB0aGlzLm1hdHJpeFdvcmxkLmVsZW1lbnRzO1xuXHRcdFx0cmV0dXJuIHRhcmdldC5zZXQoZVs4XSwgZVs5XSwgZVsxMF0pLm5vcm1hbGl6ZSgpO1xuXHRcdH1cblxuXHRcdHJheWNhc3QoKSB7fVxuXG5cdFx0dHJhdmVyc2UoY2FsbGJhY2spIHtcblx0XHRcdGNhbGxiYWNrKHRoaXMpO1xuXHRcdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjaGlsZHJlbltpXS50cmF2ZXJzZShjYWxsYmFjayk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dHJhdmVyc2VWaXNpYmxlKGNhbGxiYWNrKSB7XG5cdFx0XHRpZiAodGhpcy52aXNpYmxlID09PSBmYWxzZSkgcmV0dXJuO1xuXHRcdFx0Y2FsbGJhY2sodGhpcyk7XG5cdFx0XHRjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNoaWxkcmVuW2ldLnRyYXZlcnNlVmlzaWJsZShjYWxsYmFjayk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dHJhdmVyc2VBbmNlc3RvcnMoY2FsbGJhY2spIHtcblx0XHRcdGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG5cdFx0XHRpZiAocGFyZW50ICE9PSBudWxsKSB7XG5cdFx0XHRcdGNhbGxiYWNrKHBhcmVudCk7XG5cdFx0XHRcdHBhcmVudC50cmF2ZXJzZUFuY2VzdG9ycyhjYWxsYmFjayk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dXBkYXRlTWF0cml4KCkge1xuXHRcdFx0dGhpcy5tYXRyaXguY29tcG9zZSh0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHRoaXMuc2NhbGUpO1xuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHR9XG5cblx0XHR1cGRhdGVNYXRyaXhXb3JsZChmb3JjZSkge1xuXHRcdFx0aWYgKHRoaXMubWF0cml4QXV0b1VwZGF0ZSkgdGhpcy51cGRhdGVNYXRyaXgoKTtcblxuXHRcdFx0aWYgKHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSB8fCBmb3JjZSkge1xuXHRcdFx0XHRpZiAodGhpcy5wYXJlbnQgPT09IG51bGwpIHtcblx0XHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkodGhpcy5tYXRyaXgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyh0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdH0gLy8gdXBkYXRlIGNoaWxkcmVuXG5cblxuXHRcdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjaGlsZHJlbltpXS51cGRhdGVNYXRyaXhXb3JsZChmb3JjZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dXBkYXRlV29ybGRNYXRyaXgodXBkYXRlUGFyZW50cywgdXBkYXRlQ2hpbGRyZW4pIHtcblx0XHRcdGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG5cdFx0XHRpZiAodXBkYXRlUGFyZW50cyA9PT0gdHJ1ZSAmJiBwYXJlbnQgIT09IG51bGwpIHtcblx0XHRcdFx0cGFyZW50LnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMubWF0cml4QXV0b1VwZGF0ZSkgdGhpcy51cGRhdGVNYXRyaXgoKTtcblxuXHRcdFx0aWYgKHRoaXMucGFyZW50ID09PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGQuY29weSh0aGlzLm1hdHJpeCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXModGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4KTtcblx0XHRcdH0gLy8gdXBkYXRlIGNoaWxkcmVuXG5cblxuXHRcdFx0aWYgKHVwZGF0ZUNoaWxkcmVuID09PSB0cnVlKSB7XG5cdFx0XHRcdGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGNoaWxkcmVuW2ldLnVwZGF0ZVdvcmxkTWF0cml4KGZhbHNlLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRvSlNPTihtZXRhKSB7XG5cdFx0XHQvLyBtZXRhIGlzIGEgc3RyaW5nIHdoZW4gY2FsbGVkIGZyb20gSlNPTi5zdHJpbmdpZnlcblx0XHRcdGNvbnN0IGlzUm9vdE9iamVjdCA9IG1ldGEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbWV0YSA9PT0gJ3N0cmluZyc7XG5cdFx0XHRjb25zdCBvdXRwdXQgPSB7fTsgLy8gbWV0YSBpcyBhIGhhc2ggdXNlZCB0byBjb2xsZWN0IGdlb21ldHJpZXMsIG1hdGVyaWFscy5cblx0XHRcdC8vIG5vdCBwcm92aWRpbmcgaXQgaW1wbGllcyB0aGF0IHRoaXMgaXMgdGhlIHJvb3Qgb2JqZWN0XG5cdFx0XHQvLyBiZWluZyBzZXJpYWxpemVkLlxuXG5cdFx0XHRpZiAoaXNSb290T2JqZWN0KSB7XG5cdFx0XHRcdC8vIGluaXRpYWxpemUgbWV0YSBvYmpcblx0XHRcdFx0bWV0YSA9IHtcblx0XHRcdFx0XHRnZW9tZXRyaWVzOiB7fSxcblx0XHRcdFx0XHRtYXRlcmlhbHM6IHt9LFxuXHRcdFx0XHRcdHRleHR1cmVzOiB7fSxcblx0XHRcdFx0XHRpbWFnZXM6IHt9LFxuXHRcdFx0XHRcdHNoYXBlczoge30sXG5cdFx0XHRcdFx0c2tlbGV0b25zOiB7fSxcblx0XHRcdFx0XHRhbmltYXRpb25zOiB7fVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRvdXRwdXQubWV0YWRhdGEgPSB7XG5cdFx0XHRcdFx0dmVyc2lvbjogNC41LFxuXHRcdFx0XHRcdHR5cGU6ICdPYmplY3QnLFxuXHRcdFx0XHRcdGdlbmVyYXRvcjogJ09iamVjdDNELnRvSlNPTidcblx0XHRcdFx0fTtcblx0XHRcdH0gLy8gc3RhbmRhcmQgT2JqZWN0M0Qgc2VyaWFsaXphdGlvblxuXG5cblx0XHRcdGNvbnN0IG9iamVjdCA9IHt9O1xuXHRcdFx0b2JqZWN0LnV1aWQgPSB0aGlzLnV1aWQ7XG5cdFx0XHRvYmplY3QudHlwZSA9IHRoaXMudHlwZTtcblx0XHRcdGlmICh0aGlzLm5hbWUgIT09ICcnKSBvYmplY3QubmFtZSA9IHRoaXMubmFtZTtcblx0XHRcdGlmICh0aGlzLmNhc3RTaGFkb3cgPT09IHRydWUpIG9iamVjdC5jYXN0U2hhZG93ID0gdHJ1ZTtcblx0XHRcdGlmICh0aGlzLnJlY2VpdmVTaGFkb3cgPT09IHRydWUpIG9iamVjdC5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcblx0XHRcdGlmICh0aGlzLnZpc2libGUgPT09IGZhbHNlKSBvYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuXHRcdFx0aWYgKHRoaXMuZnJ1c3R1bUN1bGxlZCA9PT0gZmFsc2UpIG9iamVjdC5mcnVzdHVtQ3VsbGVkID0gZmFsc2U7XG5cdFx0XHRpZiAodGhpcy5yZW5kZXJPcmRlciAhPT0gMCkgb2JqZWN0LnJlbmRlck9yZGVyID0gdGhpcy5yZW5kZXJPcmRlcjtcblx0XHRcdGlmIChKU09OLnN0cmluZ2lmeSh0aGlzLnVzZXJEYXRhKSAhPT0gJ3t9Jykgb2JqZWN0LnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcblx0XHRcdG9iamVjdC5sYXllcnMgPSB0aGlzLmxheWVycy5tYXNrO1xuXHRcdFx0b2JqZWN0Lm1hdHJpeCA9IHRoaXMubWF0cml4LnRvQXJyYXkoKTtcblx0XHRcdGlmICh0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPT09IGZhbHNlKSBvYmplY3QubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlOyAvLyBvYmplY3Qgc3BlY2lmaWMgcHJvcGVydGllc1xuXG5cdFx0XHRpZiAodGhpcy5pc0luc3RhbmNlZE1lc2gpIHtcblx0XHRcdFx0b2JqZWN0LnR5cGUgPSAnSW5zdGFuY2VkTWVzaCc7XG5cdFx0XHRcdG9iamVjdC5jb3VudCA9IHRoaXMuY291bnQ7XG5cdFx0XHRcdG9iamVjdC5pbnN0YW5jZU1hdHJpeCA9IHRoaXMuaW5zdGFuY2VNYXRyaXgudG9KU09OKCk7XG5cdFx0XHRcdGlmICh0aGlzLmluc3RhbmNlQ29sb3IgIT09IG51bGwpIG9iamVjdC5pbnN0YW5jZUNvbG9yID0gdGhpcy5pbnN0YW5jZUNvbG9yLnRvSlNPTigpO1xuXHRcdFx0fSAvL1xuXG5cblx0XHRcdGZ1bmN0aW9uIHNlcmlhbGl6ZShsaWJyYXJ5LCBlbGVtZW50KSB7XG5cdFx0XHRcdGlmIChsaWJyYXJ5W2VsZW1lbnQudXVpZF0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGxpYnJhcnlbZWxlbWVudC51dWlkXSA9IGVsZW1lbnQudG9KU09OKG1ldGEpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW1lbnQudXVpZDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuaXNTY2VuZSkge1xuXHRcdFx0XHRpZiAodGhpcy5iYWNrZ3JvdW5kKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuYmFja2dyb3VuZC5pc0NvbG9yKSB7XG5cdFx0XHRcdFx0XHRvYmplY3QuYmFja2dyb3VuZCA9IHRoaXMuYmFja2dyb3VuZC50b0pTT04oKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuYmFja2dyb3VuZC5pc1RleHR1cmUpIHtcblx0XHRcdFx0XHRcdG9iamVjdC5iYWNrZ3JvdW5kID0gdGhpcy5iYWNrZ3JvdW5kLnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLmVudmlyb25tZW50ICYmIHRoaXMuZW52aXJvbm1lbnQuaXNUZXh0dXJlKSB7XG5cdFx0XHRcdFx0b2JqZWN0LmVudmlyb25tZW50ID0gdGhpcy5lbnZpcm9ubWVudC50b0pTT04obWV0YSkudXVpZDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0aGlzLmlzTWVzaCB8fCB0aGlzLmlzTGluZSB8fCB0aGlzLmlzUG9pbnRzKSB7XG5cdFx0XHRcdG9iamVjdC5nZW9tZXRyeSA9IHNlcmlhbGl6ZShtZXRhLmdlb21ldHJpZXMsIHRoaXMuZ2VvbWV0cnkpO1xuXHRcdFx0XHRjb25zdCBwYXJhbWV0ZXJzID0gdGhpcy5nZW9tZXRyeS5wYXJhbWV0ZXJzO1xuXG5cdFx0XHRcdGlmIChwYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgJiYgcGFyYW1ldGVycy5zaGFwZXMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnN0IHNoYXBlcyA9IHBhcmFtZXRlcnMuc2hhcGVzO1xuXG5cdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoc2hhcGVzKSkge1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHNoYXBlID0gc2hhcGVzW2ldO1xuXHRcdFx0XHRcdFx0XHRzZXJpYWxpemUobWV0YS5zaGFwZXMsIHNoYXBlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VyaWFsaXplKG1ldGEuc2hhcGVzLCBzaGFwZXMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5pc1NraW5uZWRNZXNoKSB7XG5cdFx0XHRcdG9iamVjdC5iaW5kTW9kZSA9IHRoaXMuYmluZE1vZGU7XG5cdFx0XHRcdG9iamVjdC5iaW5kTWF0cml4ID0gdGhpcy5iaW5kTWF0cml4LnRvQXJyYXkoKTtcblxuXHRcdFx0XHRpZiAodGhpcy5za2VsZXRvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0c2VyaWFsaXplKG1ldGEuc2tlbGV0b25zLCB0aGlzLnNrZWxldG9uKTtcblx0XHRcdFx0XHRvYmplY3Quc2tlbGV0b24gPSB0aGlzLnNrZWxldG9uLnV1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMubWF0ZXJpYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm1hdGVyaWFsKSkge1xuXHRcdFx0XHRcdGNvbnN0IHV1aWRzID0gW107XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMubWF0ZXJpYWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR1dWlkcy5wdXNoKHNlcmlhbGl6ZShtZXRhLm1hdGVyaWFscywgdGhpcy5tYXRlcmlhbFtpXSkpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG9iamVjdC5tYXRlcmlhbCA9IHV1aWRzO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG9iamVjdC5tYXRlcmlhbCA9IHNlcmlhbGl6ZShtZXRhLm1hdGVyaWFscywgdGhpcy5tYXRlcmlhbCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gLy9cblxuXG5cdFx0XHRpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdG9iamVjdC5jaGlsZHJlbiA9IFtdO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdG9iamVjdC5jaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0udG9KU09OKG1ldGEpLm9iamVjdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gLy9cblxuXG5cdFx0XHRpZiAodGhpcy5hbmltYXRpb25zLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0b2JqZWN0LmFuaW1hdGlvbnMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYW5pbWF0aW9ucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc1tpXTtcblx0XHRcdFx0XHRvYmplY3QuYW5pbWF0aW9ucy5wdXNoKHNlcmlhbGl6ZShtZXRhLmFuaW1hdGlvbnMsIGFuaW1hdGlvbikpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc1Jvb3RPYmplY3QpIHtcblx0XHRcdFx0Y29uc3QgZ2VvbWV0cmllcyA9IGV4dHJhY3RGcm9tQ2FjaGUobWV0YS5nZW9tZXRyaWVzKTtcblx0XHRcdFx0Y29uc3QgbWF0ZXJpYWxzID0gZXh0cmFjdEZyb21DYWNoZShtZXRhLm1hdGVyaWFscyk7XG5cdFx0XHRcdGNvbnN0IHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZShtZXRhLnRleHR1cmVzKTtcblx0XHRcdFx0Y29uc3QgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZShtZXRhLmltYWdlcyk7XG5cdFx0XHRcdGNvbnN0IHNoYXBlcyA9IGV4dHJhY3RGcm9tQ2FjaGUobWV0YS5zaGFwZXMpO1xuXHRcdFx0XHRjb25zdCBza2VsZXRvbnMgPSBleHRyYWN0RnJvbUNhY2hlKG1ldGEuc2tlbGV0b25zKTtcblx0XHRcdFx0Y29uc3QgYW5pbWF0aW9ucyA9IGV4dHJhY3RGcm9tQ2FjaGUobWV0YS5hbmltYXRpb25zKTtcblx0XHRcdFx0aWYgKGdlb21ldHJpZXMubGVuZ3RoID4gMCkgb3V0cHV0Lmdlb21ldHJpZXMgPSBnZW9tZXRyaWVzO1xuXHRcdFx0XHRpZiAobWF0ZXJpYWxzLmxlbmd0aCA+IDApIG91dHB1dC5tYXRlcmlhbHMgPSBtYXRlcmlhbHM7XG5cdFx0XHRcdGlmICh0ZXh0dXJlcy5sZW5ndGggPiAwKSBvdXRwdXQudGV4dHVyZXMgPSB0ZXh0dXJlcztcblx0XHRcdFx0aWYgKGltYWdlcy5sZW5ndGggPiAwKSBvdXRwdXQuaW1hZ2VzID0gaW1hZ2VzO1xuXHRcdFx0XHRpZiAoc2hhcGVzLmxlbmd0aCA+IDApIG91dHB1dC5zaGFwZXMgPSBzaGFwZXM7XG5cdFx0XHRcdGlmIChza2VsZXRvbnMubGVuZ3RoID4gMCkgb3V0cHV0LnNrZWxldG9ucyA9IHNrZWxldG9ucztcblx0XHRcdFx0aWYgKGFuaW1hdGlvbnMubGVuZ3RoID4gMCkgb3V0cHV0LmFuaW1hdGlvbnMgPSBhbmltYXRpb25zO1xuXHRcdFx0fVxuXG5cdFx0XHRvdXRwdXQub2JqZWN0ID0gb2JqZWN0O1xuXHRcdFx0cmV0dXJuIG91dHB1dDsgLy8gZXh0cmFjdCBkYXRhIGZyb20gdGhlIGNhY2hlIGhhc2hcblx0XHRcdC8vIHJlbW92ZSBtZXRhZGF0YSBvbiBlYWNoIGl0ZW1cblx0XHRcdC8vIGFuZCByZXR1cm4gYXMgYXJyYXlcblxuXHRcdFx0ZnVuY3Rpb24gZXh0cmFjdEZyb21DYWNoZShjYWNoZSkge1xuXHRcdFx0XHRjb25zdCB2YWx1ZXMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBjYWNoZSkge1xuXHRcdFx0XHRcdGNvbnN0IGRhdGEgPSBjYWNoZVtrZXldO1xuXHRcdFx0XHRcdGRlbGV0ZSBkYXRhLm1ldGFkYXRhO1xuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKGRhdGEpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjbG9uZShyZWN1cnNpdmUpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcywgcmVjdXJzaXZlKTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSwgcmVjdXJzaXZlID0gdHJ1ZSkge1xuXHRcdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XG5cdFx0XHR0aGlzLnVwLmNvcHkoc291cmNlLnVwKTtcblx0XHRcdHRoaXMucG9zaXRpb24uY29weShzb3VyY2UucG9zaXRpb24pO1xuXHRcdFx0dGhpcy5yb3RhdGlvbi5vcmRlciA9IHNvdXJjZS5yb3RhdGlvbi5vcmRlcjtcblx0XHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KHNvdXJjZS5xdWF0ZXJuaW9uKTtcblx0XHRcdHRoaXMuc2NhbGUuY29weShzb3VyY2Uuc2NhbGUpO1xuXHRcdFx0dGhpcy5tYXRyaXguY29weShzb3VyY2UubWF0cml4KTtcblx0XHRcdHRoaXMubWF0cml4V29ybGQuY29weShzb3VyY2UubWF0cml4V29ybGQpO1xuXHRcdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBzb3VyY2UubWF0cml4V29ybGROZWVkc1VwZGF0ZTtcblx0XHRcdHRoaXMubGF5ZXJzLm1hc2sgPSBzb3VyY2UubGF5ZXJzLm1hc2s7XG5cdFx0XHR0aGlzLnZpc2libGUgPSBzb3VyY2UudmlzaWJsZTtcblx0XHRcdHRoaXMuY2FzdFNoYWRvdyA9IHNvdXJjZS5jYXN0U2hhZG93O1xuXHRcdFx0dGhpcy5yZWNlaXZlU2hhZG93ID0gc291cmNlLnJlY2VpdmVTaGFkb3c7XG5cdFx0XHR0aGlzLmZydXN0dW1DdWxsZWQgPSBzb3VyY2UuZnJ1c3R1bUN1bGxlZDtcblx0XHRcdHRoaXMucmVuZGVyT3JkZXIgPSBzb3VyY2UucmVuZGVyT3JkZXI7XG5cdFx0XHR0aGlzLnVzZXJEYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzb3VyY2UudXNlckRhdGEpKTtcblxuXHRcdFx0aWYgKHJlY3Vyc2l2ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IGNoaWxkID0gc291cmNlLmNoaWxkcmVuW2ldO1xuXHRcdFx0XHRcdHRoaXMuYWRkKGNoaWxkLmNsb25lKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0T2JqZWN0M0QuRGVmYXVsdFVwID0gbmV3IFZlY3RvcjMoMCwgMSwgMCk7XG5cdE9iamVjdDNELkRlZmF1bHRNYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcblx0T2JqZWN0M0QucHJvdG90eXBlLmlzT2JqZWN0M0QgPSB0cnVlO1xuXG5cdGNvbnN0IF92MCQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3YxJDMgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfdjIkMiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF92MyQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3ZhYiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF92YWMgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfdmJjID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3ZhcCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF92YnAgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfdmNwID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y2xhc3MgVHJpYW5nbGUge1xuXHRcdGNvbnN0cnVjdG9yKGEgPSBuZXcgVmVjdG9yMygpLCBiID0gbmV3IFZlY3RvcjMoKSwgYyA9IG5ldyBWZWN0b3IzKCkpIHtcblx0XHRcdHRoaXMuYSA9IGE7XG5cdFx0XHR0aGlzLmIgPSBiO1xuXHRcdFx0dGhpcy5jID0gYztcblx0XHR9XG5cblx0XHRzdGF0aWMgZ2V0Tm9ybWFsKGEsIGIsIGMsIHRhcmdldCkge1xuXHRcdFx0dGFyZ2V0LnN1YlZlY3RvcnMoYywgYik7XG5cblx0XHRcdF92MCQxLnN1YlZlY3RvcnMoYSwgYik7XG5cblx0XHRcdHRhcmdldC5jcm9zcyhfdjAkMSk7XG5cdFx0XHRjb25zdCB0YXJnZXRMZW5ndGhTcSA9IHRhcmdldC5sZW5ndGhTcSgpO1xuXG5cdFx0XHRpZiAodGFyZ2V0TGVuZ3RoU3EgPiAwKSB7XG5cdFx0XHRcdHJldHVybiB0YXJnZXQubXVsdGlwbHlTY2FsYXIoMSAvIE1hdGguc3FydCh0YXJnZXRMZW5ndGhTcSkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LnNldCgwLCAwLCAwKTtcblx0XHR9IC8vIHN0YXRpYy9pbnN0YW5jZSBtZXRob2QgdG8gY2FsY3VsYXRlIGJhcnljZW50cmljIGNvb3JkaW5hdGVzXG5cdFx0Ly8gYmFzZWQgb246IGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wb2ludGlucG9seS9kZWZhdWx0Lmh0bWxcblxuXG5cdFx0c3RhdGljIGdldEJhcnljb29yZChwb2ludCwgYSwgYiwgYywgdGFyZ2V0KSB7XG5cdFx0XHRfdjAkMS5zdWJWZWN0b3JzKGMsIGEpO1xuXG5cdFx0XHRfdjEkMy5zdWJWZWN0b3JzKGIsIGEpO1xuXG5cdFx0XHRfdjIkMi5zdWJWZWN0b3JzKHBvaW50LCBhKTtcblxuXHRcdFx0Y29uc3QgZG90MDAgPSBfdjAkMS5kb3QoX3YwJDEpO1xuXG5cdFx0XHRjb25zdCBkb3QwMSA9IF92MCQxLmRvdChfdjEkMyk7XG5cblx0XHRcdGNvbnN0IGRvdDAyID0gX3YwJDEuZG90KF92MiQyKTtcblxuXHRcdFx0Y29uc3QgZG90MTEgPSBfdjEkMy5kb3QoX3YxJDMpO1xuXG5cdFx0XHRjb25zdCBkb3QxMiA9IF92MSQzLmRvdChfdjIkMik7XG5cblx0XHRcdGNvbnN0IGRlbm9tID0gZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDE7IC8vIGNvbGxpbmVhciBvciBzaW5ndWxhciB0cmlhbmdsZVxuXG5cdFx0XHRpZiAoZGVub20gPT09IDApIHtcblx0XHRcdFx0Ly8gYXJiaXRyYXJ5IGxvY2F0aW9uIG91dHNpZGUgb2YgdHJpYW5nbGU/XG5cdFx0XHRcdC8vIG5vdCBzdXJlIGlmIHRoaXMgaXMgdGhlIGJlc3QgaWRlYSwgbWF5YmUgc2hvdWxkIGJlIHJldHVybmluZyB1bmRlZmluZWRcblx0XHRcdFx0cmV0dXJuIHRhcmdldC5zZXQoLTIsIC0xLCAtMSk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGludkRlbm9tID0gMSAvIGRlbm9tO1xuXHRcdFx0Y29uc3QgdSA9IChkb3QxMSAqIGRvdDAyIC0gZG90MDEgKiBkb3QxMikgKiBpbnZEZW5vbTtcblx0XHRcdGNvbnN0IHYgPSAoZG90MDAgKiBkb3QxMiAtIGRvdDAxICogZG90MDIpICogaW52RGVub207IC8vIGJhcnljZW50cmljIGNvb3JkaW5hdGVzIG11c3QgYWx3YXlzIHN1bSB0byAxXG5cblx0XHRcdHJldHVybiB0YXJnZXQuc2V0KDEgLSB1IC0gdiwgdiwgdSk7XG5cdFx0fVxuXG5cdFx0c3RhdGljIGNvbnRhaW5zUG9pbnQocG9pbnQsIGEsIGIsIGMpIHtcblx0XHRcdHRoaXMuZ2V0QmFyeWNvb3JkKHBvaW50LCBhLCBiLCBjLCBfdjMkMSk7XG5cdFx0XHRyZXR1cm4gX3YzJDEueCA+PSAwICYmIF92MyQxLnkgPj0gMCAmJiBfdjMkMS54ICsgX3YzJDEueSA8PSAxO1xuXHRcdH1cblxuXHRcdHN0YXRpYyBnZXRVVihwb2ludCwgcDEsIHAyLCBwMywgdXYxLCB1djIsIHV2MywgdGFyZ2V0KSB7XG5cdFx0XHR0aGlzLmdldEJhcnljb29yZChwb2ludCwgcDEsIHAyLCBwMywgX3YzJDEpO1xuXHRcdFx0dGFyZ2V0LnNldCgwLCAwKTtcblx0XHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IodXYxLCBfdjMkMS54KTtcblx0XHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IodXYyLCBfdjMkMS55KTtcblx0XHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IodXYzLCBfdjMkMS56KTtcblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cdFx0fVxuXG5cdFx0c3RhdGljIGlzRnJvbnRGYWNpbmcoYSwgYiwgYywgZGlyZWN0aW9uKSB7XG5cdFx0XHRfdjAkMS5zdWJWZWN0b3JzKGMsIGIpO1xuXG5cdFx0XHRfdjEkMy5zdWJWZWN0b3JzKGEsIGIpOyAvLyBzdHJpY3RseSBmcm9udCBmYWNpbmdcblxuXG5cdFx0XHRyZXR1cm4gX3YwJDEuY3Jvc3MoX3YxJDMpLmRvdChkaXJlY3Rpb24pIDwgMCA/IHRydWUgOiBmYWxzZTtcblx0XHR9XG5cblx0XHRzZXQoYSwgYiwgYykge1xuXHRcdFx0dGhpcy5hLmNvcHkoYSk7XG5cdFx0XHR0aGlzLmIuY29weShiKTtcblx0XHRcdHRoaXMuYy5jb3B5KGMpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0RnJvbVBvaW50c0FuZEluZGljZXMocG9pbnRzLCBpMCwgaTEsIGkyKSB7XG5cdFx0XHR0aGlzLmEuY29weShwb2ludHNbaTBdKTtcblx0XHRcdHRoaXMuYi5jb3B5KHBvaW50c1tpMV0pO1xuXHRcdFx0dGhpcy5jLmNvcHkocG9pbnRzW2kyXSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRGcm9tQXR0cmlidXRlQW5kSW5kaWNlcyhhdHRyaWJ1dGUsIGkwLCBpMSwgaTIpIHtcblx0XHRcdHRoaXMuYS5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgaTApO1xuXHRcdFx0dGhpcy5iLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBpMSk7XG5cdFx0XHR0aGlzLmMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGkyKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNsb25lKCkge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcblx0XHR9XG5cblx0XHRjb3B5KHRyaWFuZ2xlKSB7XG5cdFx0XHR0aGlzLmEuY29weSh0cmlhbmdsZS5hKTtcblx0XHRcdHRoaXMuYi5jb3B5KHRyaWFuZ2xlLmIpO1xuXHRcdFx0dGhpcy5jLmNvcHkodHJpYW5nbGUuYyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRnZXRBcmVhKCkge1xuXHRcdFx0X3YwJDEuc3ViVmVjdG9ycyh0aGlzLmMsIHRoaXMuYik7XG5cblx0XHRcdF92MSQzLnN1YlZlY3RvcnModGhpcy5hLCB0aGlzLmIpO1xuXG5cdFx0XHRyZXR1cm4gX3YwJDEuY3Jvc3MoX3YxJDMpLmxlbmd0aCgpICogMC41O1xuXHRcdH1cblxuXHRcdGdldE1pZHBvaW50KHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldC5hZGRWZWN0b3JzKHRoaXMuYSwgdGhpcy5iKS5hZGQodGhpcy5jKS5tdWx0aXBseVNjYWxhcigxIC8gMyk7XG5cdFx0fVxuXG5cdFx0Z2V0Tm9ybWFsKHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIFRyaWFuZ2xlLmdldE5vcm1hbCh0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB0YXJnZXQpO1xuXHRcdH1cblxuXHRcdGdldFBsYW5lKHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldC5zZXRGcm9tQ29wbGFuYXJQb2ludHModGhpcy5hLCB0aGlzLmIsIHRoaXMuYyk7XG5cdFx0fVxuXG5cdFx0Z2V0QmFyeWNvb3JkKHBvaW50LCB0YXJnZXQpIHtcblx0XHRcdHJldHVybiBUcmlhbmdsZS5nZXRCYXJ5Y29vcmQocG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRhcmdldCk7XG5cdFx0fVxuXG5cdFx0Z2V0VVYocG9pbnQsIHV2MSwgdXYyLCB1djMsIHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIFRyaWFuZ2xlLmdldFVWKHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB1djEsIHV2MiwgdXYzLCB0YXJnZXQpO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcblx0XHRcdHJldHVybiBUcmlhbmdsZS5jb250YWluc1BvaW50KHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jKTtcblx0XHR9XG5cblx0XHRpc0Zyb250RmFjaW5nKGRpcmVjdGlvbikge1xuXHRcdFx0cmV0dXJuIFRyaWFuZ2xlLmlzRnJvbnRGYWNpbmcodGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgZGlyZWN0aW9uKTtcblx0XHR9XG5cblx0XHRpbnRlcnNlY3RzQm94KGJveCkge1xuXHRcdFx0cmV0dXJuIGJveC5pbnRlcnNlY3RzVHJpYW5nbGUodGhpcyk7XG5cdFx0fVxuXG5cdFx0Y2xvc2VzdFBvaW50VG9Qb2ludChwLCB0YXJnZXQpIHtcblx0XHRcdGNvbnN0IGEgPSB0aGlzLmEsXG5cdFx0XHRcdFx0XHRiID0gdGhpcy5iLFxuXHRcdFx0XHRcdFx0YyA9IHRoaXMuYztcblx0XHRcdGxldCB2LCB3OyAvLyBhbGdvcml0aG0gdGhhbmtzIHRvIFJlYWwtVGltZSBDb2xsaXNpb24gRGV0ZWN0aW9uIGJ5IENocmlzdGVyIEVyaWNzb24sXG5cdFx0XHQvLyBwdWJsaXNoZWQgYnkgTW9yZ2FuIEthdWZtYW5uIFB1Ymxpc2hlcnMsIChjKSAyMDA1IEVsc2V2aWVyIEluYy4sXG5cdFx0XHQvLyB1bmRlciB0aGUgYWNjb21wYW55aW5nIGxpY2Vuc2U7IHNlZSBjaGFwdGVyIDUuMS41IGZvciBkZXRhaWxlZCBleHBsYW5hdGlvbi5cblx0XHRcdC8vIGJhc2ljYWxseSwgd2UncmUgZGlzdGluZ3Vpc2hpbmcgd2hpY2ggb2YgdGhlIHZvcm9ub2kgcmVnaW9ucyBvZiB0aGUgdHJpYW5nbGVcblx0XHRcdC8vIHRoZSBwb2ludCBsaWVzIGluIHdpdGggdGhlIG1pbmltdW0gYW1vdW50IG9mIHJlZHVuZGFudCBjb21wdXRhdGlvbi5cblxuXHRcdFx0X3ZhYi5zdWJWZWN0b3JzKGIsIGEpO1xuXG5cdFx0XHRfdmFjLnN1YlZlY3RvcnMoYywgYSk7XG5cblx0XHRcdF92YXAuc3ViVmVjdG9ycyhwLCBhKTtcblxuXHRcdFx0Y29uc3QgZDEgPSBfdmFiLmRvdChfdmFwKTtcblxuXHRcdFx0Y29uc3QgZDIgPSBfdmFjLmRvdChfdmFwKTtcblxuXHRcdFx0aWYgKGQxIDw9IDAgJiYgZDIgPD0gMCkge1xuXHRcdFx0XHQvLyB2ZXJ0ZXggcmVnaW9uIG9mIEE7IGJhcnljZW50cmljIGNvb3JkcyAoMSwgMCwgMClcblx0XHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KGEpO1xuXHRcdFx0fVxuXG5cdFx0XHRfdmJwLnN1YlZlY3RvcnMocCwgYik7XG5cblx0XHRcdGNvbnN0IGQzID0gX3ZhYi5kb3QoX3ZicCk7XG5cblx0XHRcdGNvbnN0IGQ0ID0gX3ZhYy5kb3QoX3ZicCk7XG5cblx0XHRcdGlmIChkMyA+PSAwICYmIGQ0IDw9IGQzKSB7XG5cdFx0XHRcdC8vIHZlcnRleCByZWdpb24gb2YgQjsgYmFyeWNlbnRyaWMgY29vcmRzICgwLCAxLCAwKVxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoYik7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHZjID0gZDEgKiBkNCAtIGQzICogZDI7XG5cblx0XHRcdGlmICh2YyA8PSAwICYmIGQxID49IDAgJiYgZDMgPD0gMCkge1xuXHRcdFx0XHR2ID0gZDEgLyAoZDEgLSBkMyk7IC8vIGVkZ2UgcmVnaW9uIG9mIEFCOyBiYXJ5Y2VudHJpYyBjb29yZHMgKDEtdiwgdiwgMClcblxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoYSkuYWRkU2NhbGVkVmVjdG9yKF92YWIsIHYpO1xuXHRcdFx0fVxuXG5cdFx0XHRfdmNwLnN1YlZlY3RvcnMocCwgYyk7XG5cblx0XHRcdGNvbnN0IGQ1ID0gX3ZhYi5kb3QoX3ZjcCk7XG5cblx0XHRcdGNvbnN0IGQ2ID0gX3ZhYy5kb3QoX3ZjcCk7XG5cblx0XHRcdGlmIChkNiA+PSAwICYmIGQ1IDw9IGQ2KSB7XG5cdFx0XHRcdC8vIHZlcnRleCByZWdpb24gb2YgQzsgYmFyeWNlbnRyaWMgY29vcmRzICgwLCAwLCAxKVxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoYyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHZiID0gZDUgKiBkMiAtIGQxICogZDY7XG5cblx0XHRcdGlmICh2YiA8PSAwICYmIGQyID49IDAgJiYgZDYgPD0gMCkge1xuXHRcdFx0XHR3ID0gZDIgLyAoZDIgLSBkNik7IC8vIGVkZ2UgcmVnaW9uIG9mIEFDOyBiYXJ5Y2VudHJpYyBjb29yZHMgKDEtdywgMCwgdylcblxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoYSkuYWRkU2NhbGVkVmVjdG9yKF92YWMsIHcpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB2YSA9IGQzICogZDYgLSBkNSAqIGQ0O1xuXG5cdFx0XHRpZiAodmEgPD0gMCAmJiBkNCAtIGQzID49IDAgJiYgZDUgLSBkNiA+PSAwKSB7XG5cdFx0XHRcdF92YmMuc3ViVmVjdG9ycyhjLCBiKTtcblxuXHRcdFx0XHR3ID0gKGQ0IC0gZDMpIC8gKGQ0IC0gZDMgKyAoZDUgLSBkNikpOyAvLyBlZGdlIHJlZ2lvbiBvZiBCQzsgYmFyeWNlbnRyaWMgY29vcmRzICgwLCAxLXcsIHcpXG5cblx0XHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KGIpLmFkZFNjYWxlZFZlY3RvcihfdmJjLCB3KTsgLy8gZWRnZSByZWdpb24gb2YgQkNcblx0XHRcdH0gLy8gZmFjZSByZWdpb25cblxuXG5cdFx0XHRjb25zdCBkZW5vbSA9IDEgLyAodmEgKyB2YiArIHZjKTsgLy8gdSA9IHZhICogZGVub21cblxuXHRcdFx0diA9IHZiICogZGVub207XG5cdFx0XHR3ID0gdmMgKiBkZW5vbTtcblx0XHRcdHJldHVybiB0YXJnZXQuY29weShhKS5hZGRTY2FsZWRWZWN0b3IoX3ZhYiwgdikuYWRkU2NhbGVkVmVjdG9yKF92YWMsIHcpO1xuXHRcdH1cblxuXHRcdGVxdWFscyh0cmlhbmdsZSkge1xuXHRcdFx0cmV0dXJuIHRyaWFuZ2xlLmEuZXF1YWxzKHRoaXMuYSkgJiYgdHJpYW5nbGUuYi5lcXVhbHModGhpcy5iKSAmJiB0cmlhbmdsZS5jLmVxdWFscyh0aGlzLmMpO1xuXHRcdH1cblxuXHR9XG5cblx0bGV0IG1hdGVyaWFsSWQgPSAwO1xuXG5cdGNsYXNzIE1hdGVyaWFsIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lkJywge1xuXHRcdFx0XHR2YWx1ZTogbWF0ZXJpYWxJZCsrXG5cdFx0XHR9KTtcblx0XHRcdHRoaXMudXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXHRcdFx0dGhpcy5uYW1lID0gJyc7XG5cdFx0XHR0aGlzLnR5cGUgPSAnTWF0ZXJpYWwnO1xuXHRcdFx0dGhpcy5mb2cgPSB0cnVlO1xuXHRcdFx0dGhpcy5ibGVuZGluZyA9IE5vcm1hbEJsZW5kaW5nO1xuXHRcdFx0dGhpcy5zaWRlID0gRnJvbnRTaWRlO1xuXHRcdFx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBmYWxzZTtcblx0XHRcdHRoaXMub3BhY2l0eSA9IDE7XG5cdFx0XHR0aGlzLmZvcm1hdCA9IFJHQkFGb3JtYXQ7XG5cdFx0XHR0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XG5cdFx0XHR0aGlzLmJsZW5kU3JjID0gU3JjQWxwaGFGYWN0b3I7XG5cdFx0XHR0aGlzLmJsZW5kRHN0ID0gT25lTWludXNTcmNBbHBoYUZhY3Rvcjtcblx0XHRcdHRoaXMuYmxlbmRFcXVhdGlvbiA9IEFkZEVxdWF0aW9uO1xuXHRcdFx0dGhpcy5ibGVuZFNyY0FscGhhID0gbnVsbDtcblx0XHRcdHRoaXMuYmxlbmREc3RBbHBoYSA9IG51bGw7XG5cdFx0XHR0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XG5cdFx0XHR0aGlzLmRlcHRoRnVuYyA9IExlc3NFcXVhbERlcHRoO1xuXHRcdFx0dGhpcy5kZXB0aFRlc3QgPSB0cnVlO1xuXHRcdFx0dGhpcy5kZXB0aFdyaXRlID0gdHJ1ZTtcblx0XHRcdHRoaXMuc3RlbmNpbFdyaXRlTWFzayA9IDB4ZmY7XG5cdFx0XHR0aGlzLnN0ZW5jaWxGdW5jID0gQWx3YXlzU3RlbmNpbEZ1bmM7XG5cdFx0XHR0aGlzLnN0ZW5jaWxSZWYgPSAwO1xuXHRcdFx0dGhpcy5zdGVuY2lsRnVuY01hc2sgPSAweGZmO1xuXHRcdFx0dGhpcy5zdGVuY2lsRmFpbCA9IEtlZXBTdGVuY2lsT3A7XG5cdFx0XHR0aGlzLnN0ZW5jaWxaRmFpbCA9IEtlZXBTdGVuY2lsT3A7XG5cdFx0XHR0aGlzLnN0ZW5jaWxaUGFzcyA9IEtlZXBTdGVuY2lsT3A7XG5cdFx0XHR0aGlzLnN0ZW5jaWxXcml0ZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5jbGlwcGluZ1BsYW5lcyA9IG51bGw7XG5cdFx0XHR0aGlzLmNsaXBJbnRlcnNlY3Rpb24gPSBmYWxzZTtcblx0XHRcdHRoaXMuY2xpcFNoYWRvd3MgPSBmYWxzZTtcblx0XHRcdHRoaXMuc2hhZG93U2lkZSA9IG51bGw7XG5cdFx0XHR0aGlzLmNvbG9yV3JpdGUgPSB0cnVlO1xuXHRcdFx0dGhpcy5wcmVjaXNpb24gPSBudWxsOyAvLyBvdmVycmlkZSB0aGUgcmVuZGVyZXIncyBkZWZhdWx0IHByZWNpc2lvbiBmb3IgdGhpcyBtYXRlcmlhbFxuXG5cdFx0XHR0aGlzLnBvbHlnb25PZmZzZXQgPSBmYWxzZTtcblx0XHRcdHRoaXMucG9seWdvbk9mZnNldEZhY3RvciA9IDA7XG5cdFx0XHR0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IDA7XG5cdFx0XHR0aGlzLmRpdGhlcmluZyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5hbHBoYVRvQ292ZXJhZ2UgPSBmYWxzZTtcblx0XHRcdHRoaXMucHJlbXVsdGlwbGllZEFscGhhID0gZmFsc2U7XG5cdFx0XHR0aGlzLnZpc2libGUgPSB0cnVlO1xuXHRcdFx0dGhpcy50b25lTWFwcGVkID0gdHJ1ZTtcblx0XHRcdHRoaXMudXNlckRhdGEgPSB7fTtcblx0XHRcdHRoaXMudmVyc2lvbiA9IDA7XG5cdFx0XHR0aGlzLl9hbHBoYVRlc3QgPSAwO1xuXHRcdH1cblxuXHRcdGdldCBhbHBoYVRlc3QoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fYWxwaGFUZXN0O1xuXHRcdH1cblxuXHRcdHNldCBhbHBoYVRlc3QodmFsdWUpIHtcblx0XHRcdGlmICh0aGlzLl9hbHBoYVRlc3QgPiAwICE9PSB2YWx1ZSA+IDApIHtcblx0XHRcdFx0dGhpcy52ZXJzaW9uKys7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2FscGhhVGVzdCA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdG9uQnVpbGQoKSB7fVxuXG5cdFx0b25CZWZvcmVSZW5kZXIoKSB7fVxuXG5cdFx0b25CZWZvcmVDb21waWxlKCkge31cblxuXHRcdGN1c3RvbVByb2dyYW1DYWNoZUtleSgpIHtcblx0XHRcdHJldHVybiB0aGlzLm9uQmVmb3JlQ29tcGlsZS50b1N0cmluZygpO1xuXHRcdH1cblxuXHRcdHNldFZhbHVlcyh2YWx1ZXMpIHtcblx0XHRcdGlmICh2YWx1ZXMgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZXMpIHtcblx0XHRcdFx0Y29uc3QgbmV3VmFsdWUgPSB2YWx1ZXNba2V5XTtcblxuXHRcdFx0XHRpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuTWF0ZXJpYWw6IFxcJycgKyBrZXkgKyAnXFwnIHBhcmFtZXRlciBpcyB1bmRlZmluZWQuJyk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH0gLy8gZm9yIGJhY2t3YXJkIGNvbXBhdGFiaWxpdHkgaWYgc2hhZGluZyBpcyBzZXQgaW4gdGhlIGNvbnN0cnVjdG9yXG5cblxuXHRcdFx0XHRpZiAoa2V5ID09PSAnc2hhZGluZycpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAuc2hhZGluZyBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdGhlIGJvb2xlYW4gLmZsYXRTaGFkaW5nIGluc3RlYWQuJyk7XG5cdFx0XHRcdFx0dGhpcy5mbGF0U2hhZGluZyA9IG5ld1ZhbHVlID09PSBGbGF0U2hhZGluZyA/IHRydWUgOiBmYWxzZTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXNba2V5XTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiBcXCcnICsga2V5ICsgJ1xcJyBpcyBub3QgYSBwcm9wZXJ0eSBvZiB0aGlzIG1hdGVyaWFsLicpO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSAmJiBjdXJyZW50VmFsdWUuaXNDb2xvcikge1xuXHRcdFx0XHRcdGN1cnJlbnRWYWx1ZS5zZXQobmV3VmFsdWUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGN1cnJlbnRWYWx1ZSAmJiBjdXJyZW50VmFsdWUuaXNWZWN0b3IzICYmIG5ld1ZhbHVlICYmIG5ld1ZhbHVlLmlzVmVjdG9yMykge1xuXHRcdFx0XHRcdGN1cnJlbnRWYWx1ZS5jb3B5KG5ld1ZhbHVlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzW2tleV0gPSBuZXdWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRvSlNPTihtZXRhKSB7XG5cdFx0XHRjb25zdCBpc1Jvb3QgPSBtZXRhID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1ldGEgPT09ICdzdHJpbmcnO1xuXG5cdFx0XHRpZiAoaXNSb290KSB7XG5cdFx0XHRcdG1ldGEgPSB7XG5cdFx0XHRcdFx0dGV4dHVyZXM6IHt9LFxuXHRcdFx0XHRcdGltYWdlczoge31cblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdFx0bWV0YWRhdGE6IHtcblx0XHRcdFx0XHR2ZXJzaW9uOiA0LjUsXG5cdFx0XHRcdFx0dHlwZTogJ01hdGVyaWFsJyxcblx0XHRcdFx0XHRnZW5lcmF0b3I6ICdNYXRlcmlhbC50b0pTT04nXG5cdFx0XHRcdH1cblx0XHRcdH07IC8vIHN0YW5kYXJkIE1hdGVyaWFsIHNlcmlhbGl6YXRpb25cblxuXHRcdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xuXHRcdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xuXHRcdFx0aWYgKHRoaXMubmFtZSAhPT0gJycpIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcblx0XHRcdGlmICh0aGlzLmNvbG9yICYmIHRoaXMuY29sb3IuaXNDb2xvcikgZGF0YS5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XG5cdFx0XHRpZiAodGhpcy5yb3VnaG5lc3MgIT09IHVuZGVmaW5lZCkgZGF0YS5yb3VnaG5lc3MgPSB0aGlzLnJvdWdobmVzcztcblx0XHRcdGlmICh0aGlzLm1ldGFsbmVzcyAhPT0gdW5kZWZpbmVkKSBkYXRhLm1ldGFsbmVzcyA9IHRoaXMubWV0YWxuZXNzO1xuXHRcdFx0aWYgKHRoaXMuc2hlZW4gIT09IHVuZGVmaW5lZCkgZGF0YS5zaGVlbiA9IHRoaXMuc2hlZW47XG5cdFx0XHRpZiAodGhpcy5zaGVlbkNvbG9yICYmIHRoaXMuc2hlZW5Db2xvci5pc0NvbG9yKSBkYXRhLnNoZWVuQ29sb3IgPSB0aGlzLnNoZWVuQ29sb3IuZ2V0SGV4KCk7XG5cdFx0XHRpZiAodGhpcy5zaGVlblJvdWdobmVzcyAhPT0gdW5kZWZpbmVkKSBkYXRhLnNoZWVuUm91Z2huZXNzID0gdGhpcy5zaGVlblJvdWdobmVzcztcblx0XHRcdGlmICh0aGlzLmVtaXNzaXZlICYmIHRoaXMuZW1pc3NpdmUuaXNDb2xvcikgZGF0YS5lbWlzc2l2ZSA9IHRoaXMuZW1pc3NpdmUuZ2V0SGV4KCk7XG5cdFx0XHRpZiAodGhpcy5lbWlzc2l2ZUludGVuc2l0eSAmJiB0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ICE9PSAxKSBkYXRhLmVtaXNzaXZlSW50ZW5zaXR5ID0gdGhpcy5lbWlzc2l2ZUludGVuc2l0eTtcblx0XHRcdGlmICh0aGlzLnNwZWN1bGFyICYmIHRoaXMuc3BlY3VsYXIuaXNDb2xvcikgZGF0YS5zcGVjdWxhciA9IHRoaXMuc3BlY3VsYXIuZ2V0SGV4KCk7XG5cdFx0XHRpZiAodGhpcy5zcGVjdWxhckludGVuc2l0eSAhPT0gdW5kZWZpbmVkKSBkYXRhLnNwZWN1bGFySW50ZW5zaXR5ID0gdGhpcy5zcGVjdWxhckludGVuc2l0eTtcblx0XHRcdGlmICh0aGlzLnNwZWN1bGFyQ29sb3IgJiYgdGhpcy5zcGVjdWxhckNvbG9yLmlzQ29sb3IpIGRhdGEuc3BlY3VsYXJDb2xvciA9IHRoaXMuc3BlY3VsYXJDb2xvci5nZXRIZXgoKTtcblx0XHRcdGlmICh0aGlzLnNoaW5pbmVzcyAhPT0gdW5kZWZpbmVkKSBkYXRhLnNoaW5pbmVzcyA9IHRoaXMuc2hpbmluZXNzO1xuXHRcdFx0aWYgKHRoaXMuY2xlYXJjb2F0ICE9PSB1bmRlZmluZWQpIGRhdGEuY2xlYXJjb2F0ID0gdGhpcy5jbGVhcmNvYXQ7XG5cdFx0XHRpZiAodGhpcy5jbGVhcmNvYXRSb3VnaG5lc3MgIT09IHVuZGVmaW5lZCkgZGF0YS5jbGVhcmNvYXRSb3VnaG5lc3MgPSB0aGlzLmNsZWFyY29hdFJvdWdobmVzcztcblxuXHRcdFx0aWYgKHRoaXMuY2xlYXJjb2F0TWFwICYmIHRoaXMuY2xlYXJjb2F0TWFwLmlzVGV4dHVyZSkge1xuXHRcdFx0XHRkYXRhLmNsZWFyY29hdE1hcCA9IHRoaXMuY2xlYXJjb2F0TWFwLnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgJiYgdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAuaXNUZXh0dXJlKSB7XG5cdFx0XHRcdGRhdGEuY2xlYXJjb2F0Um91Z2huZXNzTWFwID0gdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmNsZWFyY29hdE5vcm1hbE1hcCAmJiB0aGlzLmNsZWFyY29hdE5vcm1hbE1hcC5pc1RleHR1cmUpIHtcblx0XHRcdFx0ZGF0YS5jbGVhcmNvYXROb3JtYWxNYXAgPSB0aGlzLmNsZWFyY29hdE5vcm1hbE1hcC50b0pTT04obWV0YSkudXVpZDtcblx0XHRcdFx0ZGF0YS5jbGVhcmNvYXROb3JtYWxTY2FsZSA9IHRoaXMuY2xlYXJjb2F0Tm9ybWFsU2NhbGUudG9BcnJheSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5tYXAgJiYgdGhpcy5tYXAuaXNUZXh0dXJlKSBkYXRhLm1hcCA9IHRoaXMubWFwLnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdFx0aWYgKHRoaXMubWF0Y2FwICYmIHRoaXMubWF0Y2FwLmlzVGV4dHVyZSkgZGF0YS5tYXRjYXAgPSB0aGlzLm1hdGNhcC50b0pTT04obWV0YSkudXVpZDtcblx0XHRcdGlmICh0aGlzLmFscGhhTWFwICYmIHRoaXMuYWxwaGFNYXAuaXNUZXh0dXJlKSBkYXRhLmFscGhhTWFwID0gdGhpcy5hbHBoYU1hcC50b0pTT04obWV0YSkudXVpZDtcblxuXHRcdFx0aWYgKHRoaXMubGlnaHRNYXAgJiYgdGhpcy5saWdodE1hcC5pc1RleHR1cmUpIHtcblx0XHRcdFx0ZGF0YS5saWdodE1hcCA9IHRoaXMubGlnaHRNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG5cdFx0XHRcdGRhdGEubGlnaHRNYXBJbnRlbnNpdHkgPSB0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5hb01hcCAmJiB0aGlzLmFvTWFwLmlzVGV4dHVyZSkge1xuXHRcdFx0XHRkYXRhLmFvTWFwID0gdGhpcy5hb01hcC50b0pTT04obWV0YSkudXVpZDtcblx0XHRcdFx0ZGF0YS5hb01hcEludGVuc2l0eSA9IHRoaXMuYW9NYXBJbnRlbnNpdHk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmJ1bXBNYXAgJiYgdGhpcy5idW1wTWFwLmlzVGV4dHVyZSkge1xuXHRcdFx0XHRkYXRhLmJ1bXBNYXAgPSB0aGlzLmJ1bXBNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG5cdFx0XHRcdGRhdGEuYnVtcFNjYWxlID0gdGhpcy5idW1wU2NhbGU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLm5vcm1hbE1hcCAmJiB0aGlzLm5vcm1hbE1hcC5pc1RleHR1cmUpIHtcblx0XHRcdFx0ZGF0YS5ub3JtYWxNYXAgPSB0aGlzLm5vcm1hbE1hcC50b0pTT04obWV0YSkudXVpZDtcblx0XHRcdFx0ZGF0YS5ub3JtYWxNYXBUeXBlID0gdGhpcy5ub3JtYWxNYXBUeXBlO1xuXHRcdFx0XHRkYXRhLm5vcm1hbFNjYWxlID0gdGhpcy5ub3JtYWxTY2FsZS50b0FycmF5KCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmRpc3BsYWNlbWVudE1hcCAmJiB0aGlzLmRpc3BsYWNlbWVudE1hcC5pc1RleHR1cmUpIHtcblx0XHRcdFx0ZGF0YS5kaXNwbGFjZW1lbnRNYXAgPSB0aGlzLmRpc3BsYWNlbWVudE1hcC50b0pTT04obWV0YSkudXVpZDtcblx0XHRcdFx0ZGF0YS5kaXNwbGFjZW1lbnRTY2FsZSA9IHRoaXMuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0XHRcdGRhdGEuZGlzcGxhY2VtZW50QmlhcyA9IHRoaXMuZGlzcGxhY2VtZW50Qmlhcztcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMucm91Z2huZXNzTWFwICYmIHRoaXMucm91Z2huZXNzTWFwLmlzVGV4dHVyZSkgZGF0YS5yb3VnaG5lc3NNYXAgPSB0aGlzLnJvdWdobmVzc01hcC50b0pTT04obWV0YSkudXVpZDtcblx0XHRcdGlmICh0aGlzLm1ldGFsbmVzc01hcCAmJiB0aGlzLm1ldGFsbmVzc01hcC5pc1RleHR1cmUpIGRhdGEubWV0YWxuZXNzTWFwID0gdGhpcy5tZXRhbG5lc3NNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG5cdFx0XHRpZiAodGhpcy5lbWlzc2l2ZU1hcCAmJiB0aGlzLmVtaXNzaXZlTWFwLmlzVGV4dHVyZSkgZGF0YS5lbWlzc2l2ZU1hcCA9IHRoaXMuZW1pc3NpdmVNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG5cdFx0XHRpZiAodGhpcy5zcGVjdWxhck1hcCAmJiB0aGlzLnNwZWN1bGFyTWFwLmlzVGV4dHVyZSkgZGF0YS5zcGVjdWxhck1hcCA9IHRoaXMuc3BlY3VsYXJNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG5cdFx0XHRpZiAodGhpcy5zcGVjdWxhckludGVuc2l0eU1hcCAmJiB0aGlzLnNwZWN1bGFySW50ZW5zaXR5TWFwLmlzVGV4dHVyZSkgZGF0YS5zcGVjdWxhckludGVuc2l0eU1hcCA9IHRoaXMuc3BlY3VsYXJJbnRlbnNpdHlNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG5cdFx0XHRpZiAodGhpcy5zcGVjdWxhckNvbG9yTWFwICYmIHRoaXMuc3BlY3VsYXJDb2xvck1hcC5pc1RleHR1cmUpIGRhdGEuc3BlY3VsYXJDb2xvck1hcCA9IHRoaXMuc3BlY3VsYXJDb2xvck1hcC50b0pTT04obWV0YSkudXVpZDtcblxuXHRcdFx0aWYgKHRoaXMuZW52TWFwICYmIHRoaXMuZW52TWFwLmlzVGV4dHVyZSkge1xuXHRcdFx0XHRkYXRhLmVudk1hcCA9IHRoaXMuZW52TWFwLnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdFx0XHRpZiAodGhpcy5jb21iaW5lICE9PSB1bmRlZmluZWQpIGRhdGEuY29tYmluZSA9IHRoaXMuY29tYmluZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuZW52TWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQpIGRhdGEuZW52TWFwSW50ZW5zaXR5ID0gdGhpcy5lbnZNYXBJbnRlbnNpdHk7XG5cdFx0XHRpZiAodGhpcy5yZWZsZWN0aXZpdHkgIT09IHVuZGVmaW5lZCkgZGF0YS5yZWZsZWN0aXZpdHkgPSB0aGlzLnJlZmxlY3Rpdml0eTtcblx0XHRcdGlmICh0aGlzLnJlZnJhY3Rpb25SYXRpbyAhPT0gdW5kZWZpbmVkKSBkYXRhLnJlZnJhY3Rpb25SYXRpbyA9IHRoaXMucmVmcmFjdGlvblJhdGlvO1xuXG5cdFx0XHRpZiAodGhpcy5ncmFkaWVudE1hcCAmJiB0aGlzLmdyYWRpZW50TWFwLmlzVGV4dHVyZSkge1xuXHRcdFx0XHRkYXRhLmdyYWRpZW50TWFwID0gdGhpcy5ncmFkaWVudE1hcC50b0pTT04obWV0YSkudXVpZDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMudHJhbnNtaXNzaW9uICE9PSB1bmRlZmluZWQpIGRhdGEudHJhbnNtaXNzaW9uID0gdGhpcy50cmFuc21pc3Npb247XG5cdFx0XHRpZiAodGhpcy50cmFuc21pc3Npb25NYXAgJiYgdGhpcy50cmFuc21pc3Npb25NYXAuaXNUZXh0dXJlKSBkYXRhLnRyYW5zbWlzc2lvbk1hcCA9IHRoaXMudHJhbnNtaXNzaW9uTWFwLnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdFx0aWYgKHRoaXMudGhpY2tuZXNzICE9PSB1bmRlZmluZWQpIGRhdGEudGhpY2tuZXNzID0gdGhpcy50aGlja25lc3M7XG5cdFx0XHRpZiAodGhpcy50aGlja25lc3NNYXAgJiYgdGhpcy50aGlja25lc3NNYXAuaXNUZXh0dXJlKSBkYXRhLnRoaWNrbmVzc01hcCA9IHRoaXMudGhpY2tuZXNzTWFwLnRvSlNPTihtZXRhKS51dWlkO1xuXHRcdFx0aWYgKHRoaXMuYXR0ZW51YXRpb25EaXN0YW5jZSAhPT0gdW5kZWZpbmVkKSBkYXRhLmF0dGVudWF0aW9uRGlzdGFuY2UgPSB0aGlzLmF0dGVudWF0aW9uRGlzdGFuY2U7XG5cdFx0XHRpZiAodGhpcy5hdHRlbnVhdGlvbkNvbG9yICE9PSB1bmRlZmluZWQpIGRhdGEuYXR0ZW51YXRpb25Db2xvciA9IHRoaXMuYXR0ZW51YXRpb25Db2xvci5nZXRIZXgoKTtcblx0XHRcdGlmICh0aGlzLnNpemUgIT09IHVuZGVmaW5lZCkgZGF0YS5zaXplID0gdGhpcy5zaXplO1xuXHRcdFx0aWYgKHRoaXMuc2hhZG93U2lkZSAhPT0gbnVsbCkgZGF0YS5zaGFkb3dTaWRlID0gdGhpcy5zaGFkb3dTaWRlO1xuXHRcdFx0aWYgKHRoaXMuc2l6ZUF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQpIGRhdGEuc2l6ZUF0dGVudWF0aW9uID0gdGhpcy5zaXplQXR0ZW51YXRpb247XG5cdFx0XHRpZiAodGhpcy5ibGVuZGluZyAhPT0gTm9ybWFsQmxlbmRpbmcpIGRhdGEuYmxlbmRpbmcgPSB0aGlzLmJsZW5kaW5nO1xuXHRcdFx0aWYgKHRoaXMuc2lkZSAhPT0gRnJvbnRTaWRlKSBkYXRhLnNpZGUgPSB0aGlzLnNpZGU7XG5cdFx0XHRpZiAodGhpcy52ZXJ0ZXhDb2xvcnMpIGRhdGEudmVydGV4Q29sb3JzID0gdHJ1ZTtcblx0XHRcdGlmICh0aGlzLm9wYWNpdHkgPCAxKSBkYXRhLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG5cdFx0XHRpZiAodGhpcy5mb3JtYXQgIT09IFJHQkFGb3JtYXQpIGRhdGEuZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XG5cdFx0XHRpZiAodGhpcy50cmFuc3BhcmVudCA9PT0gdHJ1ZSkgZGF0YS50cmFuc3BhcmVudCA9IHRoaXMudHJhbnNwYXJlbnQ7XG5cdFx0XHRkYXRhLmRlcHRoRnVuYyA9IHRoaXMuZGVwdGhGdW5jO1xuXHRcdFx0ZGF0YS5kZXB0aFRlc3QgPSB0aGlzLmRlcHRoVGVzdDtcblx0XHRcdGRhdGEuZGVwdGhXcml0ZSA9IHRoaXMuZGVwdGhXcml0ZTtcblx0XHRcdGRhdGEuY29sb3JXcml0ZSA9IHRoaXMuY29sb3JXcml0ZTtcblx0XHRcdGRhdGEuc3RlbmNpbFdyaXRlID0gdGhpcy5zdGVuY2lsV3JpdGU7XG5cdFx0XHRkYXRhLnN0ZW5jaWxXcml0ZU1hc2sgPSB0aGlzLnN0ZW5jaWxXcml0ZU1hc2s7XG5cdFx0XHRkYXRhLnN0ZW5jaWxGdW5jID0gdGhpcy5zdGVuY2lsRnVuYztcblx0XHRcdGRhdGEuc3RlbmNpbFJlZiA9IHRoaXMuc3RlbmNpbFJlZjtcblx0XHRcdGRhdGEuc3RlbmNpbEZ1bmNNYXNrID0gdGhpcy5zdGVuY2lsRnVuY01hc2s7XG5cdFx0XHRkYXRhLnN0ZW5jaWxGYWlsID0gdGhpcy5zdGVuY2lsRmFpbDtcblx0XHRcdGRhdGEuc3RlbmNpbFpGYWlsID0gdGhpcy5zdGVuY2lsWkZhaWw7XG5cdFx0XHRkYXRhLnN0ZW5jaWxaUGFzcyA9IHRoaXMuc3RlbmNpbFpQYXNzOyAvLyByb3RhdGlvbiAoU3ByaXRlTWF0ZXJpYWwpXG5cblx0XHRcdGlmICh0aGlzLnJvdGF0aW9uICYmIHRoaXMucm90YXRpb24gIT09IDApIGRhdGEucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuXHRcdFx0aWYgKHRoaXMucG9seWdvbk9mZnNldCA9PT0gdHJ1ZSkgZGF0YS5wb2x5Z29uT2Zmc2V0ID0gdHJ1ZTtcblx0XHRcdGlmICh0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgIT09IDApIGRhdGEucG9seWdvbk9mZnNldEZhY3RvciA9IHRoaXMucG9seWdvbk9mZnNldEZhY3Rvcjtcblx0XHRcdGlmICh0aGlzLnBvbHlnb25PZmZzZXRVbml0cyAhPT0gMCkgZGF0YS5wb2x5Z29uT2Zmc2V0VW5pdHMgPSB0aGlzLnBvbHlnb25PZmZzZXRVbml0cztcblx0XHRcdGlmICh0aGlzLmxpbmV3aWR0aCAmJiB0aGlzLmxpbmV3aWR0aCAhPT0gMSkgZGF0YS5saW5ld2lkdGggPSB0aGlzLmxpbmV3aWR0aDtcblx0XHRcdGlmICh0aGlzLmRhc2hTaXplICE9PSB1bmRlZmluZWQpIGRhdGEuZGFzaFNpemUgPSB0aGlzLmRhc2hTaXplO1xuXHRcdFx0aWYgKHRoaXMuZ2FwU2l6ZSAhPT0gdW5kZWZpbmVkKSBkYXRhLmdhcFNpemUgPSB0aGlzLmdhcFNpemU7XG5cdFx0XHRpZiAodGhpcy5zY2FsZSAhPT0gdW5kZWZpbmVkKSBkYXRhLnNjYWxlID0gdGhpcy5zY2FsZTtcblx0XHRcdGlmICh0aGlzLmRpdGhlcmluZyA9PT0gdHJ1ZSkgZGF0YS5kaXRoZXJpbmcgPSB0cnVlO1xuXHRcdFx0aWYgKHRoaXMuYWxwaGFUZXN0ID4gMCkgZGF0YS5hbHBoYVRlc3QgPSB0aGlzLmFscGhhVGVzdDtcblx0XHRcdGlmICh0aGlzLmFscGhhVG9Db3ZlcmFnZSA9PT0gdHJ1ZSkgZGF0YS5hbHBoYVRvQ292ZXJhZ2UgPSB0aGlzLmFscGhhVG9Db3ZlcmFnZTtcblx0XHRcdGlmICh0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9PT0gdHJ1ZSkgZGF0YS5wcmVtdWx0aXBsaWVkQWxwaGEgPSB0aGlzLnByZW11bHRpcGxpZWRBbHBoYTtcblx0XHRcdGlmICh0aGlzLndpcmVmcmFtZSA9PT0gdHJ1ZSkgZGF0YS53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcblx0XHRcdGlmICh0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA+IDEpIGRhdGEud2lyZWZyYW1lTGluZXdpZHRoID0gdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdFx0XHRpZiAodGhpcy53aXJlZnJhbWVMaW5lY2FwICE9PSAncm91bmQnKSBkYXRhLndpcmVmcmFtZUxpbmVjYXAgPSB0aGlzLndpcmVmcmFtZUxpbmVjYXA7XG5cdFx0XHRpZiAodGhpcy53aXJlZnJhbWVMaW5lam9pbiAhPT0gJ3JvdW5kJykgZGF0YS53aXJlZnJhbWVMaW5lam9pbiA9IHRoaXMud2lyZWZyYW1lTGluZWpvaW47XG5cdFx0XHRpZiAodGhpcy5mbGF0U2hhZGluZyA9PT0gdHJ1ZSkgZGF0YS5mbGF0U2hhZGluZyA9IHRoaXMuZmxhdFNoYWRpbmc7XG5cdFx0XHRpZiAodGhpcy52aXNpYmxlID09PSBmYWxzZSkgZGF0YS52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHRpZiAodGhpcy50b25lTWFwcGVkID09PSBmYWxzZSkgZGF0YS50b25lTWFwcGVkID0gZmFsc2U7XG5cdFx0XHRpZiAoSlNPTi5zdHJpbmdpZnkodGhpcy51c2VyRGF0YSkgIT09ICd7fScpIGRhdGEudXNlckRhdGEgPSB0aGlzLnVzZXJEYXRhOyAvLyBUT0RPOiBDb3BpZWQgZnJvbSBPYmplY3QzRC50b0pTT05cblxuXHRcdFx0ZnVuY3Rpb24gZXh0cmFjdEZyb21DYWNoZShjYWNoZSkge1xuXHRcdFx0XHRjb25zdCB2YWx1ZXMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBjYWNoZSkge1xuXHRcdFx0XHRcdGNvbnN0IGRhdGEgPSBjYWNoZVtrZXldO1xuXHRcdFx0XHRcdGRlbGV0ZSBkYXRhLm1ldGFkYXRhO1xuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKGRhdGEpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzUm9vdCkge1xuXHRcdFx0XHRjb25zdCB0ZXh0dXJlcyA9IGV4dHJhY3RGcm9tQ2FjaGUobWV0YS50ZXh0dXJlcyk7XG5cdFx0XHRcdGNvbnN0IGltYWdlcyA9IGV4dHJhY3RGcm9tQ2FjaGUobWV0YS5pbWFnZXMpO1xuXHRcdFx0XHRpZiAodGV4dHVyZXMubGVuZ3RoID4gMCkgZGF0YS50ZXh0dXJlcyA9IHRleHR1cmVzO1xuXHRcdFx0XHRpZiAoaW1hZ2VzLmxlbmd0aCA+IDApIGRhdGEuaW1hZ2VzID0gaW1hZ2VzO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXHRcdFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXHRcdFx0dGhpcy5ibGVuZGluZyA9IHNvdXJjZS5ibGVuZGluZztcblx0XHRcdHRoaXMuc2lkZSA9IHNvdXJjZS5zaWRlO1xuXHRcdFx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXHRcdFx0dGhpcy5vcGFjaXR5ID0gc291cmNlLm9wYWNpdHk7XG5cdFx0XHR0aGlzLmZvcm1hdCA9IHNvdXJjZS5mb3JtYXQ7XG5cdFx0XHR0aGlzLnRyYW5zcGFyZW50ID0gc291cmNlLnRyYW5zcGFyZW50O1xuXHRcdFx0dGhpcy5ibGVuZFNyYyA9IHNvdXJjZS5ibGVuZFNyYztcblx0XHRcdHRoaXMuYmxlbmREc3QgPSBzb3VyY2UuYmxlbmREc3Q7XG5cdFx0XHR0aGlzLmJsZW5kRXF1YXRpb24gPSBzb3VyY2UuYmxlbmRFcXVhdGlvbjtcblx0XHRcdHRoaXMuYmxlbmRTcmNBbHBoYSA9IHNvdXJjZS5ibGVuZFNyY0FscGhhO1xuXHRcdFx0dGhpcy5ibGVuZERzdEFscGhhID0gc291cmNlLmJsZW5kRHN0QWxwaGE7XG5cdFx0XHR0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IHNvdXJjZS5ibGVuZEVxdWF0aW9uQWxwaGE7XG5cdFx0XHR0aGlzLmRlcHRoRnVuYyA9IHNvdXJjZS5kZXB0aEZ1bmM7XG5cdFx0XHR0aGlzLmRlcHRoVGVzdCA9IHNvdXJjZS5kZXB0aFRlc3Q7XG5cdFx0XHR0aGlzLmRlcHRoV3JpdGUgPSBzb3VyY2UuZGVwdGhXcml0ZTtcblx0XHRcdHRoaXMuc3RlbmNpbFdyaXRlTWFzayA9IHNvdXJjZS5zdGVuY2lsV3JpdGVNYXNrO1xuXHRcdFx0dGhpcy5zdGVuY2lsRnVuYyA9IHNvdXJjZS5zdGVuY2lsRnVuYztcblx0XHRcdHRoaXMuc3RlbmNpbFJlZiA9IHNvdXJjZS5zdGVuY2lsUmVmO1xuXHRcdFx0dGhpcy5zdGVuY2lsRnVuY01hc2sgPSBzb3VyY2Uuc3RlbmNpbEZ1bmNNYXNrO1xuXHRcdFx0dGhpcy5zdGVuY2lsRmFpbCA9IHNvdXJjZS5zdGVuY2lsRmFpbDtcblx0XHRcdHRoaXMuc3RlbmNpbFpGYWlsID0gc291cmNlLnN0ZW5jaWxaRmFpbDtcblx0XHRcdHRoaXMuc3RlbmNpbFpQYXNzID0gc291cmNlLnN0ZW5jaWxaUGFzcztcblx0XHRcdHRoaXMuc3RlbmNpbFdyaXRlID0gc291cmNlLnN0ZW5jaWxXcml0ZTtcblx0XHRcdGNvbnN0IHNyY1BsYW5lcyA9IHNvdXJjZS5jbGlwcGluZ1BsYW5lcztcblx0XHRcdGxldCBkc3RQbGFuZXMgPSBudWxsO1xuXG5cdFx0XHRpZiAoc3JjUGxhbmVzICE9PSBudWxsKSB7XG5cdFx0XHRcdGNvbnN0IG4gPSBzcmNQbGFuZXMubGVuZ3RoO1xuXHRcdFx0XHRkc3RQbGFuZXMgPSBuZXcgQXJyYXkobik7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgIT09IG47ICsraSkge1xuXHRcdFx0XHRcdGRzdFBsYW5lc1tpXSA9IHNyY1BsYW5lc1tpXS5jbG9uZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuY2xpcHBpbmdQbGFuZXMgPSBkc3RQbGFuZXM7XG5cdFx0XHR0aGlzLmNsaXBJbnRlcnNlY3Rpb24gPSBzb3VyY2UuY2xpcEludGVyc2VjdGlvbjtcblx0XHRcdHRoaXMuY2xpcFNoYWRvd3MgPSBzb3VyY2UuY2xpcFNoYWRvd3M7XG5cdFx0XHR0aGlzLnNoYWRvd1NpZGUgPSBzb3VyY2Uuc2hhZG93U2lkZTtcblx0XHRcdHRoaXMuY29sb3JXcml0ZSA9IHNvdXJjZS5jb2xvcldyaXRlO1xuXHRcdFx0dGhpcy5wcmVjaXNpb24gPSBzb3VyY2UucHJlY2lzaW9uO1xuXHRcdFx0dGhpcy5wb2x5Z29uT2Zmc2V0ID0gc291cmNlLnBvbHlnb25PZmZzZXQ7XG5cdFx0XHR0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSBzb3VyY2UucG9seWdvbk9mZnNldEZhY3Rvcjtcblx0XHRcdHRoaXMucG9seWdvbk9mZnNldFVuaXRzID0gc291cmNlLnBvbHlnb25PZmZzZXRVbml0cztcblx0XHRcdHRoaXMuZGl0aGVyaW5nID0gc291cmNlLmRpdGhlcmluZztcblx0XHRcdHRoaXMuYWxwaGFUZXN0ID0gc291cmNlLmFscGhhVGVzdDtcblx0XHRcdHRoaXMuYWxwaGFUb0NvdmVyYWdlID0gc291cmNlLmFscGhhVG9Db3ZlcmFnZTtcblx0XHRcdHRoaXMucHJlbXVsdGlwbGllZEFscGhhID0gc291cmNlLnByZW11bHRpcGxpZWRBbHBoYTtcblx0XHRcdHRoaXMudmlzaWJsZSA9IHNvdXJjZS52aXNpYmxlO1xuXHRcdFx0dGhpcy50b25lTWFwcGVkID0gc291cmNlLnRvbmVNYXBwZWQ7XG5cdFx0XHR0aGlzLnVzZXJEYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzb3VyY2UudXNlckRhdGEpKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGRpc3Bvc2UoKSB7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoe1xuXHRcdFx0XHR0eXBlOiAnZGlzcG9zZSdcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHNldCBuZWVkc1VwZGF0ZSh2YWx1ZSkge1xuXHRcdFx0aWYgKHZhbHVlID09PSB0cnVlKSB0aGlzLnZlcnNpb24rKztcblx0XHR9XG5cblx0fVxuXG5cdE1hdGVyaWFsLnByb3RvdHlwZS5pc01hdGVyaWFsID0gdHJ1ZTtcblxuXHRjb25zdCBfY29sb3JLZXl3b3JkcyA9IHtcblx0XHQnYWxpY2VibHVlJzogMHhGMEY4RkYsXG5cdFx0J2FudGlxdWV3aGl0ZSc6IDB4RkFFQkQ3LFxuXHRcdCdhcXVhJzogMHgwMEZGRkYsXG5cdFx0J2FxdWFtYXJpbmUnOiAweDdGRkZENCxcblx0XHQnYXp1cmUnOiAweEYwRkZGRixcblx0XHQnYmVpZ2UnOiAweEY1RjVEQyxcblx0XHQnYmlzcXVlJzogMHhGRkU0QzQsXG5cdFx0J2JsYWNrJzogMHgwMDAwMDAsXG5cdFx0J2JsYW5jaGVkYWxtb25kJzogMHhGRkVCQ0QsXG5cdFx0J2JsdWUnOiAweDAwMDBGRixcblx0XHQnYmx1ZXZpb2xldCc6IDB4OEEyQkUyLFxuXHRcdCdicm93bic6IDB4QTUyQTJBLFxuXHRcdCdidXJseXdvb2QnOiAweERFQjg4Nyxcblx0XHQnY2FkZXRibHVlJzogMHg1RjlFQTAsXG5cdFx0J2NoYXJ0cmV1c2UnOiAweDdGRkYwMCxcblx0XHQnY2hvY29sYXRlJzogMHhEMjY5MUUsXG5cdFx0J2NvcmFsJzogMHhGRjdGNTAsXG5cdFx0J2Nvcm5mbG93ZXJibHVlJzogMHg2NDk1RUQsXG5cdFx0J2Nvcm5zaWxrJzogMHhGRkY4REMsXG5cdFx0J2NyaW1zb24nOiAweERDMTQzQyxcblx0XHQnY3lhbic6IDB4MDBGRkZGLFxuXHRcdCdkYXJrYmx1ZSc6IDB4MDAwMDhCLFxuXHRcdCdkYXJrY3lhbic6IDB4MDA4QjhCLFxuXHRcdCdkYXJrZ29sZGVucm9kJzogMHhCODg2MEIsXG5cdFx0J2RhcmtncmF5JzogMHhBOUE5QTksXG5cdFx0J2RhcmtncmVlbic6IDB4MDA2NDAwLFxuXHRcdCdkYXJrZ3JleSc6IDB4QTlBOUE5LFxuXHRcdCdkYXJra2hha2knOiAweEJEQjc2Qixcblx0XHQnZGFya21hZ2VudGEnOiAweDhCMDA4Qixcblx0XHQnZGFya29saXZlZ3JlZW4nOiAweDU1NkIyRixcblx0XHQnZGFya29yYW5nZSc6IDB4RkY4QzAwLFxuXHRcdCdkYXJrb3JjaGlkJzogMHg5OTMyQ0MsXG5cdFx0J2RhcmtyZWQnOiAweDhCMDAwMCxcblx0XHQnZGFya3NhbG1vbic6IDB4RTk5NjdBLFxuXHRcdCdkYXJrc2VhZ3JlZW4nOiAweDhGQkM4Rixcblx0XHQnZGFya3NsYXRlYmx1ZSc6IDB4NDgzRDhCLFxuXHRcdCdkYXJrc2xhdGVncmF5JzogMHgyRjRGNEYsXG5cdFx0J2RhcmtzbGF0ZWdyZXknOiAweDJGNEY0Rixcblx0XHQnZGFya3R1cnF1b2lzZSc6IDB4MDBDRUQxLFxuXHRcdCdkYXJrdmlvbGV0JzogMHg5NDAwRDMsXG5cdFx0J2RlZXBwaW5rJzogMHhGRjE0OTMsXG5cdFx0J2RlZXBza3libHVlJzogMHgwMEJGRkYsXG5cdFx0J2RpbWdyYXknOiAweDY5Njk2OSxcblx0XHQnZGltZ3JleSc6IDB4Njk2OTY5LFxuXHRcdCdkb2RnZXJibHVlJzogMHgxRTkwRkYsXG5cdFx0J2ZpcmVicmljayc6IDB4QjIyMjIyLFxuXHRcdCdmbG9yYWx3aGl0ZSc6IDB4RkZGQUYwLFxuXHRcdCdmb3Jlc3RncmVlbic6IDB4MjI4QjIyLFxuXHRcdCdmdWNoc2lhJzogMHhGRjAwRkYsXG5cdFx0J2dhaW5zYm9ybyc6IDB4RENEQ0RDLFxuXHRcdCdnaG9zdHdoaXRlJzogMHhGOEY4RkYsXG5cdFx0J2dvbGQnOiAweEZGRDcwMCxcblx0XHQnZ29sZGVucm9kJzogMHhEQUE1MjAsXG5cdFx0J2dyYXknOiAweDgwODA4MCxcblx0XHQnZ3JlZW4nOiAweDAwODAwMCxcblx0XHQnZ3JlZW55ZWxsb3cnOiAweEFERkYyRixcblx0XHQnZ3JleSc6IDB4ODA4MDgwLFxuXHRcdCdob25leWRldyc6IDB4RjBGRkYwLFxuXHRcdCdob3RwaW5rJzogMHhGRjY5QjQsXG5cdFx0J2luZGlhbnJlZCc6IDB4Q0Q1QzVDLFxuXHRcdCdpbmRpZ28nOiAweDRCMDA4Mixcblx0XHQnaXZvcnknOiAweEZGRkZGMCxcblx0XHQna2hha2knOiAweEYwRTY4Qyxcblx0XHQnbGF2ZW5kZXInOiAweEU2RTZGQSxcblx0XHQnbGF2ZW5kZXJibHVzaCc6IDB4RkZGMEY1LFxuXHRcdCdsYXduZ3JlZW4nOiAweDdDRkMwMCxcblx0XHQnbGVtb25jaGlmZm9uJzogMHhGRkZBQ0QsXG5cdFx0J2xpZ2h0Ymx1ZSc6IDB4QUREOEU2LFxuXHRcdCdsaWdodGNvcmFsJzogMHhGMDgwODAsXG5cdFx0J2xpZ2h0Y3lhbic6IDB4RTBGRkZGLFxuXHRcdCdsaWdodGdvbGRlbnJvZHllbGxvdyc6IDB4RkFGQUQyLFxuXHRcdCdsaWdodGdyYXknOiAweEQzRDNEMyxcblx0XHQnbGlnaHRncmVlbic6IDB4OTBFRTkwLFxuXHRcdCdsaWdodGdyZXknOiAweEQzRDNEMyxcblx0XHQnbGlnaHRwaW5rJzogMHhGRkI2QzEsXG5cdFx0J2xpZ2h0c2FsbW9uJzogMHhGRkEwN0EsXG5cdFx0J2xpZ2h0c2VhZ3JlZW4nOiAweDIwQjJBQSxcblx0XHQnbGlnaHRza3libHVlJzogMHg4N0NFRkEsXG5cdFx0J2xpZ2h0c2xhdGVncmF5JzogMHg3Nzg4OTksXG5cdFx0J2xpZ2h0c2xhdGVncmV5JzogMHg3Nzg4OTksXG5cdFx0J2xpZ2h0c3RlZWxibHVlJzogMHhCMEM0REUsXG5cdFx0J2xpZ2h0eWVsbG93JzogMHhGRkZGRTAsXG5cdFx0J2xpbWUnOiAweDAwRkYwMCxcblx0XHQnbGltZWdyZWVuJzogMHgzMkNEMzIsXG5cdFx0J2xpbmVuJzogMHhGQUYwRTYsXG5cdFx0J21hZ2VudGEnOiAweEZGMDBGRixcblx0XHQnbWFyb29uJzogMHg4MDAwMDAsXG5cdFx0J21lZGl1bWFxdWFtYXJpbmUnOiAweDY2Q0RBQSxcblx0XHQnbWVkaXVtYmx1ZSc6IDB4MDAwMENELFxuXHRcdCdtZWRpdW1vcmNoaWQnOiAweEJBNTVEMyxcblx0XHQnbWVkaXVtcHVycGxlJzogMHg5MzcwREIsXG5cdFx0J21lZGl1bXNlYWdyZWVuJzogMHgzQ0IzNzEsXG5cdFx0J21lZGl1bXNsYXRlYmx1ZSc6IDB4N0I2OEVFLFxuXHRcdCdtZWRpdW1zcHJpbmdncmVlbic6IDB4MDBGQTlBLFxuXHRcdCdtZWRpdW10dXJxdW9pc2UnOiAweDQ4RDFDQyxcblx0XHQnbWVkaXVtdmlvbGV0cmVkJzogMHhDNzE1ODUsXG5cdFx0J21pZG5pZ2h0Ymx1ZSc6IDB4MTkxOTcwLFxuXHRcdCdtaW50Y3JlYW0nOiAweEY1RkZGQSxcblx0XHQnbWlzdHlyb3NlJzogMHhGRkU0RTEsXG5cdFx0J21vY2Nhc2luJzogMHhGRkU0QjUsXG5cdFx0J25hdmFqb3doaXRlJzogMHhGRkRFQUQsXG5cdFx0J25hdnknOiAweDAwMDA4MCxcblx0XHQnb2xkbGFjZSc6IDB4RkRGNUU2LFxuXHRcdCdvbGl2ZSc6IDB4ODA4MDAwLFxuXHRcdCdvbGl2ZWRyYWInOiAweDZCOEUyMyxcblx0XHQnb3JhbmdlJzogMHhGRkE1MDAsXG5cdFx0J29yYW5nZXJlZCc6IDB4RkY0NTAwLFxuXHRcdCdvcmNoaWQnOiAweERBNzBENixcblx0XHQncGFsZWdvbGRlbnJvZCc6IDB4RUVFOEFBLFxuXHRcdCdwYWxlZ3JlZW4nOiAweDk4RkI5OCxcblx0XHQncGFsZXR1cnF1b2lzZSc6IDB4QUZFRUVFLFxuXHRcdCdwYWxldmlvbGV0cmVkJzogMHhEQjcwOTMsXG5cdFx0J3BhcGF5YXdoaXAnOiAweEZGRUZENSxcblx0XHQncGVhY2hwdWZmJzogMHhGRkRBQjksXG5cdFx0J3BlcnUnOiAweENEODUzRixcblx0XHQncGluayc6IDB4RkZDMENCLFxuXHRcdCdwbHVtJzogMHhEREEwREQsXG5cdFx0J3Bvd2RlcmJsdWUnOiAweEIwRTBFNixcblx0XHQncHVycGxlJzogMHg4MDAwODAsXG5cdFx0J3JlYmVjY2FwdXJwbGUnOiAweDY2MzM5OSxcblx0XHQncmVkJzogMHhGRjAwMDAsXG5cdFx0J3Jvc3licm93bic6IDB4QkM4RjhGLFxuXHRcdCdyb3lhbGJsdWUnOiAweDQxNjlFMSxcblx0XHQnc2FkZGxlYnJvd24nOiAweDhCNDUxMyxcblx0XHQnc2FsbW9uJzogMHhGQTgwNzIsXG5cdFx0J3NhbmR5YnJvd24nOiAweEY0QTQ2MCxcblx0XHQnc2VhZ3JlZW4nOiAweDJFOEI1Nyxcblx0XHQnc2Vhc2hlbGwnOiAweEZGRjVFRSxcblx0XHQnc2llbm5hJzogMHhBMDUyMkQsXG5cdFx0J3NpbHZlcic6IDB4QzBDMEMwLFxuXHRcdCdza3libHVlJzogMHg4N0NFRUIsXG5cdFx0J3NsYXRlYmx1ZSc6IDB4NkE1QUNELFxuXHRcdCdzbGF0ZWdyYXknOiAweDcwODA5MCxcblx0XHQnc2xhdGVncmV5JzogMHg3MDgwOTAsXG5cdFx0J3Nub3cnOiAweEZGRkFGQSxcblx0XHQnc3ByaW5nZ3JlZW4nOiAweDAwRkY3Rixcblx0XHQnc3RlZWxibHVlJzogMHg0NjgyQjQsXG5cdFx0J3Rhbic6IDB4RDJCNDhDLFxuXHRcdCd0ZWFsJzogMHgwMDgwODAsXG5cdFx0J3RoaXN0bGUnOiAweEQ4QkZEOCxcblx0XHQndG9tYXRvJzogMHhGRjYzNDcsXG5cdFx0J3R1cnF1b2lzZSc6IDB4NDBFMEQwLFxuXHRcdCd2aW9sZXQnOiAweEVFODJFRSxcblx0XHQnd2hlYXQnOiAweEY1REVCMyxcblx0XHQnd2hpdGUnOiAweEZGRkZGRixcblx0XHQnd2hpdGVzbW9rZSc6IDB4RjVGNUY1LFxuXHRcdCd5ZWxsb3cnOiAweEZGRkYwMCxcblx0XHQneWVsbG93Z3JlZW4nOiAweDlBQ0QzMlxuXHR9O1xuXHRjb25zdCBfaHNsQSA9IHtcblx0XHRoOiAwLFxuXHRcdHM6IDAsXG5cdFx0bDogMFxuXHR9O1xuXHRjb25zdCBfaHNsQiA9IHtcblx0XHRoOiAwLFxuXHRcdHM6IDAsXG5cdFx0bDogMFxuXHR9O1xuXG5cdGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuXHRcdGlmICh0IDwgMCkgdCArPSAxO1xuXHRcdGlmICh0ID4gMSkgdCAtPSAxO1xuXHRcdGlmICh0IDwgMSAvIDYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuXHRcdGlmICh0IDwgMSAvIDIpIHJldHVybiBxO1xuXHRcdGlmICh0IDwgMiAvIDMpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiAoMiAvIDMgLSB0KTtcblx0XHRyZXR1cm4gcDtcblx0fVxuXG5cdGZ1bmN0aW9uIFNSR0JUb0xpbmVhcihjKSB7XG5cdFx0cmV0dXJuIGMgPCAwLjA0MDQ1ID8gYyAqIDAuMDc3Mzk5MzgwOCA6IE1hdGgucG93KGMgKiAwLjk0Nzg2NzI5ODYgKyAwLjA1MjEzMjcwMTQsIDIuNCk7XG5cdH1cblxuXHRmdW5jdGlvbiBMaW5lYXJUb1NSR0IoYykge1xuXHRcdHJldHVybiBjIDwgMC4wMDMxMzA4ID8gYyAqIDEyLjkyIDogMS4wNTUgKiBNYXRoLnBvdyhjLCAwLjQxNjY2KSAtIDAuMDU1O1xuXHR9XG5cblx0Y2xhc3MgQ29sb3Ige1xuXHRcdGNvbnN0cnVjdG9yKHIsIGcsIGIpIHtcblx0XHRcdGlmIChnID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIHIgaXMgVEhSRUUuQ29sb3IsIGhleCBvciBzdHJpbmdcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0KHIpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRSR0IociwgZywgYik7XG5cdFx0fVxuXG5cdFx0c2V0KHZhbHVlKSB7XG5cdFx0XHRpZiAodmFsdWUgJiYgdmFsdWUuaXNDb2xvcikge1xuXHRcdFx0XHR0aGlzLmNvcHkodmFsdWUpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdHRoaXMuc2V0SGV4KHZhbHVlKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHR0aGlzLnNldFN0eWxlKHZhbHVlKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0U2NhbGFyKHNjYWxhcikge1xuXHRcdFx0dGhpcy5yID0gc2NhbGFyO1xuXHRcdFx0dGhpcy5nID0gc2NhbGFyO1xuXHRcdFx0dGhpcy5iID0gc2NhbGFyO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0SGV4KGhleCkge1xuXHRcdFx0aGV4ID0gTWF0aC5mbG9vcihoZXgpO1xuXHRcdFx0dGhpcy5yID0gKGhleCA+PiAxNiAmIDI1NSkgLyAyNTU7XG5cdFx0XHR0aGlzLmcgPSAoaGV4ID4+IDggJiAyNTUpIC8gMjU1O1xuXHRcdFx0dGhpcy5iID0gKGhleCAmIDI1NSkgLyAyNTU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRSR0IociwgZywgYikge1xuXHRcdFx0dGhpcy5yID0gcjtcblx0XHRcdHRoaXMuZyA9IGc7XG5cdFx0XHR0aGlzLmIgPSBiO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0SFNMKGgsIHMsIGwpIHtcblx0XHRcdC8vIGgscyxsIHJhbmdlcyBhcmUgaW4gMC4wIC0gMS4wXG5cdFx0XHRoID0gZXVjbGlkZWFuTW9kdWxvKGgsIDEpO1xuXHRcdFx0cyA9IGNsYW1wKHMsIDAsIDEpO1xuXHRcdFx0bCA9IGNsYW1wKGwsIDAsIDEpO1xuXG5cdFx0XHRpZiAocyA9PT0gMCkge1xuXHRcdFx0XHR0aGlzLnIgPSB0aGlzLmcgPSB0aGlzLmIgPSBsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgcCA9IGwgPD0gMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuXHRcdFx0XHRjb25zdCBxID0gMiAqIGwgLSBwO1xuXHRcdFx0XHR0aGlzLnIgPSBodWUycmdiKHEsIHAsIGggKyAxIC8gMyk7XG5cdFx0XHRcdHRoaXMuZyA9IGh1ZTJyZ2IocSwgcCwgaCk7XG5cdFx0XHRcdHRoaXMuYiA9IGh1ZTJyZ2IocSwgcCwgaCAtIDEgLyAzKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0U3R5bGUoc3R5bGUpIHtcblx0XHRcdGZ1bmN0aW9uIGhhbmRsZUFscGhhKHN0cmluZykge1xuXHRcdFx0XHRpZiAoc3RyaW5nID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuXHRcdFx0XHRpZiAocGFyc2VGbG9hdChzdHJpbmcpIDwgMSkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQ29sb3I6IEFscGhhIGNvbXBvbmVudCBvZiAnICsgc3R5bGUgKyAnIHdpbGwgYmUgaWdub3JlZC4nKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgbTtcblxuXHRcdFx0aWYgKG0gPSAvXigoPzpyZ2J8aHNsKWE/KVxcKChbXlxcKV0qKVxcKS8uZXhlYyhzdHlsZSkpIHtcblx0XHRcdFx0Ly8gcmdiIC8gaHNsXG5cdFx0XHRcdGxldCBjb2xvcjtcblx0XHRcdFx0Y29uc3QgbmFtZSA9IG1bMV07XG5cdFx0XHRcdGNvbnN0IGNvbXBvbmVudHMgPSBtWzJdO1xuXG5cdFx0XHRcdHN3aXRjaCAobmFtZSkge1xuXHRcdFx0XHRcdGNhc2UgJ3JnYic6XG5cdFx0XHRcdFx0Y2FzZSAncmdiYSc6XG5cdFx0XHRcdFx0XHRpZiAoY29sb3IgPSAvXlxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqKD86LFxccyooXFxkKlxcLj9cXGQrKVxccyopPyQvLmV4ZWMoY29tcG9uZW50cykpIHtcblx0XHRcdFx0XHRcdFx0Ly8gcmdiKDI1NSwwLDApIHJnYmEoMjU1LDAsMCwwLjUpXG5cdFx0XHRcdFx0XHRcdHRoaXMuciA9IE1hdGgubWluKDI1NSwgcGFyc2VJbnQoY29sb3JbMV0sIDEwKSkgLyAyNTU7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZyA9IE1hdGgubWluKDI1NSwgcGFyc2VJbnQoY29sb3JbMl0sIDEwKSkgLyAyNTU7XG5cdFx0XHRcdFx0XHRcdHRoaXMuYiA9IE1hdGgubWluKDI1NSwgcGFyc2VJbnQoY29sb3JbM10sIDEwKSkgLyAyNTU7XG5cdFx0XHRcdFx0XHRcdGhhbmRsZUFscGhhKGNvbG9yWzRdKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChjb2xvciA9IC9eXFxzKihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyooPzosXFxzKihcXGQqXFwuP1xcZCspXFxzKik/JC8uZXhlYyhjb21wb25lbnRzKSkge1xuXHRcdFx0XHRcdFx0XHQvLyByZ2IoMTAwJSwwJSwwJSkgcmdiYSgxMDAlLDAlLDAlLDAuNSlcblx0XHRcdFx0XHRcdFx0dGhpcy5yID0gTWF0aC5taW4oMTAwLCBwYXJzZUludChjb2xvclsxXSwgMTApKSAvIDEwMDtcblx0XHRcdFx0XHRcdFx0dGhpcy5nID0gTWF0aC5taW4oMTAwLCBwYXJzZUludChjb2xvclsyXSwgMTApKSAvIDEwMDtcblx0XHRcdFx0XHRcdFx0dGhpcy5iID0gTWF0aC5taW4oMTAwLCBwYXJzZUludChjb2xvclszXSwgMTApKSAvIDEwMDtcblx0XHRcdFx0XHRcdFx0aGFuZGxlQWxwaGEoY29sb3JbNF0pO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdoc2wnOlxuXHRcdFx0XHRcdGNhc2UgJ2hzbGEnOlxuXHRcdFx0XHRcdFx0aWYgKGNvbG9yID0gL15cXHMqKFxcZCpcXC4/XFxkKylcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqKD86LFxccyooXFxkKlxcLj9cXGQrKVxccyopPyQvLmV4ZWMoY29tcG9uZW50cykpIHtcblx0XHRcdFx0XHRcdFx0Ly8gaHNsKDEyMCw1MCUsNTAlKSBoc2xhKDEyMCw1MCUsNTAlLDAuNSlcblx0XHRcdFx0XHRcdFx0Y29uc3QgaCA9IHBhcnNlRmxvYXQoY29sb3JbMV0pIC8gMzYwO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBzID0gcGFyc2VJbnQoY29sb3JbMl0sIDEwKSAvIDEwMDtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbCA9IHBhcnNlSW50KGNvbG9yWzNdLCAxMCkgLyAxMDA7XG5cdFx0XHRcdFx0XHRcdGhhbmRsZUFscGhhKGNvbG9yWzRdKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0SFNMKGgsIHMsIGwpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChtID0gL15cXCMoW0EtRmEtZlxcZF0rKSQvLmV4ZWMoc3R5bGUpKSB7XG5cdFx0XHRcdC8vIGhleCBjb2xvclxuXHRcdFx0XHRjb25zdCBoZXggPSBtWzFdO1xuXHRcdFx0XHRjb25zdCBzaXplID0gaGV4Lmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoc2l6ZSA9PT0gMykge1xuXHRcdFx0XHRcdC8vICNmZjBcblx0XHRcdFx0XHR0aGlzLnIgPSBwYXJzZUludChoZXguY2hhckF0KDApICsgaGV4LmNoYXJBdCgwKSwgMTYpIC8gMjU1O1xuXHRcdFx0XHRcdHRoaXMuZyA9IHBhcnNlSW50KGhleC5jaGFyQXQoMSkgKyBoZXguY2hhckF0KDEpLCAxNikgLyAyNTU7XG5cdFx0XHRcdFx0dGhpcy5iID0gcGFyc2VJbnQoaGV4LmNoYXJBdCgyKSArIGhleC5jaGFyQXQoMiksIDE2KSAvIDI1NTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSBlbHNlIGlmIChzaXplID09PSA2KSB7XG5cdFx0XHRcdFx0Ly8gI2ZmMDAwMFxuXHRcdFx0XHRcdHRoaXMuciA9IHBhcnNlSW50KGhleC5jaGFyQXQoMCkgKyBoZXguY2hhckF0KDEpLCAxNikgLyAyNTU7XG5cdFx0XHRcdFx0dGhpcy5nID0gcGFyc2VJbnQoaGV4LmNoYXJBdCgyKSArIGhleC5jaGFyQXQoMyksIDE2KSAvIDI1NTtcblx0XHRcdFx0XHR0aGlzLmIgPSBwYXJzZUludChoZXguY2hhckF0KDQpICsgaGV4LmNoYXJBdCg1KSwgMTYpIC8gMjU1O1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzdHlsZSAmJiBzdHlsZS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnNldENvbG9yTmFtZShzdHlsZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldENvbG9yTmFtZShzdHlsZSkge1xuXHRcdFx0Ly8gY29sb3Iga2V5d29yZHNcblx0XHRcdGNvbnN0IGhleCA9IF9jb2xvcktleXdvcmRzW3N0eWxlLnRvTG93ZXJDYXNlKCldO1xuXG5cdFx0XHRpZiAoaGV4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Ly8gcmVkXG5cdFx0XHRcdHRoaXMuc2V0SGV4KGhleCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyB1bmtub3duIGNvbG9yXG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQ29sb3I6IFVua25vd24gY29sb3IgJyArIHN0eWxlKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y2xvbmUoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG5cdFx0fVxuXG5cdFx0Y29weShjb2xvcikge1xuXHRcdFx0dGhpcy5yID0gY29sb3Iucjtcblx0XHRcdHRoaXMuZyA9IGNvbG9yLmc7XG5cdFx0XHR0aGlzLmIgPSBjb2xvci5iO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29weUdhbW1hVG9MaW5lYXIoY29sb3IsIGdhbW1hRmFjdG9yID0gMi4wKSB7XG5cdFx0XHR0aGlzLnIgPSBNYXRoLnBvdyhjb2xvci5yLCBnYW1tYUZhY3Rvcik7XG5cdFx0XHR0aGlzLmcgPSBNYXRoLnBvdyhjb2xvci5nLCBnYW1tYUZhY3Rvcik7XG5cdFx0XHR0aGlzLmIgPSBNYXRoLnBvdyhjb2xvci5iLCBnYW1tYUZhY3Rvcik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb3B5TGluZWFyVG9HYW1tYShjb2xvciwgZ2FtbWFGYWN0b3IgPSAyLjApIHtcblx0XHRcdGNvbnN0IHNhZmVJbnZlcnNlID0gZ2FtbWFGYWN0b3IgPiAwID8gMS4wIC8gZ2FtbWFGYWN0b3IgOiAxLjA7XG5cdFx0XHR0aGlzLnIgPSBNYXRoLnBvdyhjb2xvci5yLCBzYWZlSW52ZXJzZSk7XG5cdFx0XHR0aGlzLmcgPSBNYXRoLnBvdyhjb2xvci5nLCBzYWZlSW52ZXJzZSk7XG5cdFx0XHR0aGlzLmIgPSBNYXRoLnBvdyhjb2xvci5iLCBzYWZlSW52ZXJzZSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb252ZXJ0R2FtbWFUb0xpbmVhcihnYW1tYUZhY3Rvcikge1xuXHRcdFx0dGhpcy5jb3B5R2FtbWFUb0xpbmVhcih0aGlzLCBnYW1tYUZhY3Rvcik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb252ZXJ0TGluZWFyVG9HYW1tYShnYW1tYUZhY3Rvcikge1xuXHRcdFx0dGhpcy5jb3B5TGluZWFyVG9HYW1tYSh0aGlzLCBnYW1tYUZhY3Rvcik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb3B5U1JHQlRvTGluZWFyKGNvbG9yKSB7XG5cdFx0XHR0aGlzLnIgPSBTUkdCVG9MaW5lYXIoY29sb3Iucik7XG5cdFx0XHR0aGlzLmcgPSBTUkdCVG9MaW5lYXIoY29sb3IuZyk7XG5cdFx0XHR0aGlzLmIgPSBTUkdCVG9MaW5lYXIoY29sb3IuYik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb3B5TGluZWFyVG9TUkdCKGNvbG9yKSB7XG5cdFx0XHR0aGlzLnIgPSBMaW5lYXJUb1NSR0IoY29sb3Iucik7XG5cdFx0XHR0aGlzLmcgPSBMaW5lYXJUb1NSR0IoY29sb3IuZyk7XG5cdFx0XHR0aGlzLmIgPSBMaW5lYXJUb1NSR0IoY29sb3IuYik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb252ZXJ0U1JHQlRvTGluZWFyKCkge1xuXHRcdFx0dGhpcy5jb3B5U1JHQlRvTGluZWFyKHRoaXMpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29udmVydExpbmVhclRvU1JHQigpIHtcblx0XHRcdHRoaXMuY29weUxpbmVhclRvU1JHQih0aGlzKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGdldEhleCgpIHtcblx0XHRcdHJldHVybiB0aGlzLnIgKiAyNTUgPDwgMTYgXiB0aGlzLmcgKiAyNTUgPDwgOCBeIHRoaXMuYiAqIDI1NSA8PCAwO1xuXHRcdH1cblxuXHRcdGdldEhleFN0cmluZygpIHtcblx0XHRcdHJldHVybiAoJzAwMDAwMCcgKyB0aGlzLmdldEhleCgpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTYpO1xuXHRcdH1cblxuXHRcdGdldEhTTCh0YXJnZXQpIHtcblx0XHRcdC8vIGgscyxsIHJhbmdlcyBhcmUgaW4gMC4wIC0gMS4wXG5cdFx0XHRjb25zdCByID0gdGhpcy5yLFxuXHRcdFx0XHRcdFx0ZyA9IHRoaXMuZyxcblx0XHRcdFx0XHRcdGIgPSB0aGlzLmI7XG5cdFx0XHRjb25zdCBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcblx0XHRcdGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuXHRcdFx0bGV0IGh1ZSwgc2F0dXJhdGlvbjtcblx0XHRcdGNvbnN0IGxpZ2h0bmVzcyA9IChtaW4gKyBtYXgpIC8gMi4wO1xuXG5cdFx0XHRpZiAobWluID09PSBtYXgpIHtcblx0XHRcdFx0aHVlID0gMDtcblx0XHRcdFx0c2F0dXJhdGlvbiA9IDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBkZWx0YSA9IG1heCAtIG1pbjtcblx0XHRcdFx0c2F0dXJhdGlvbiA9IGxpZ2h0bmVzcyA8PSAwLjUgPyBkZWx0YSAvIChtYXggKyBtaW4pIDogZGVsdGEgLyAoMiAtIG1heCAtIG1pbik7XG5cblx0XHRcdFx0c3dpdGNoIChtYXgpIHtcblx0XHRcdFx0XHRjYXNlIHI6XG5cdFx0XHRcdFx0XHRodWUgPSAoZyAtIGIpIC8gZGVsdGEgKyAoZyA8IGIgPyA2IDogMCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgZzpcblx0XHRcdFx0XHRcdGh1ZSA9IChiIC0gcikgLyBkZWx0YSArIDI7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgYjpcblx0XHRcdFx0XHRcdGh1ZSA9IChyIC0gZykgLyBkZWx0YSArIDQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGh1ZSAvPSA2O1xuXHRcdFx0fVxuXG5cdFx0XHR0YXJnZXQuaCA9IGh1ZTtcblx0XHRcdHRhcmdldC5zID0gc2F0dXJhdGlvbjtcblx0XHRcdHRhcmdldC5sID0gbGlnaHRuZXNzO1xuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRnZXRTdHlsZSgpIHtcblx0XHRcdHJldHVybiAncmdiKCcgKyAodGhpcy5yICogMjU1IHwgMCkgKyAnLCcgKyAodGhpcy5nICogMjU1IHwgMCkgKyAnLCcgKyAodGhpcy5iICogMjU1IHwgMCkgKyAnKSc7XG5cdFx0fVxuXG5cdFx0b2Zmc2V0SFNMKGgsIHMsIGwpIHtcblx0XHRcdHRoaXMuZ2V0SFNMKF9oc2xBKTtcblx0XHRcdF9oc2xBLmggKz0gaDtcblx0XHRcdF9oc2xBLnMgKz0gcztcblx0XHRcdF9oc2xBLmwgKz0gbDtcblx0XHRcdHRoaXMuc2V0SFNMKF9oc2xBLmgsIF9oc2xBLnMsIF9oc2xBLmwpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0YWRkKGNvbG9yKSB7XG5cdFx0XHR0aGlzLnIgKz0gY29sb3Iucjtcblx0XHRcdHRoaXMuZyArPSBjb2xvci5nO1xuXHRcdFx0dGhpcy5iICs9IGNvbG9yLmI7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRhZGRDb2xvcnMoY29sb3IxLCBjb2xvcjIpIHtcblx0XHRcdHRoaXMuciA9IGNvbG9yMS5yICsgY29sb3IyLnI7XG5cdFx0XHR0aGlzLmcgPSBjb2xvcjEuZyArIGNvbG9yMi5nO1xuXHRcdFx0dGhpcy5iID0gY29sb3IxLmIgKyBjb2xvcjIuYjtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGFkZFNjYWxhcihzKSB7XG5cdFx0XHR0aGlzLnIgKz0gcztcblx0XHRcdHRoaXMuZyArPSBzO1xuXHRcdFx0dGhpcy5iICs9IHM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzdWIoY29sb3IpIHtcblx0XHRcdHRoaXMuciA9IE1hdGgubWF4KDAsIHRoaXMuciAtIGNvbG9yLnIpO1xuXHRcdFx0dGhpcy5nID0gTWF0aC5tYXgoMCwgdGhpcy5nIC0gY29sb3IuZyk7XG5cdFx0XHR0aGlzLmIgPSBNYXRoLm1heCgwLCB0aGlzLmIgLSBjb2xvci5iKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG11bHRpcGx5KGNvbG9yKSB7XG5cdFx0XHR0aGlzLnIgKj0gY29sb3Iucjtcblx0XHRcdHRoaXMuZyAqPSBjb2xvci5nO1xuXHRcdFx0dGhpcy5iICo9IGNvbG9yLmI7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRtdWx0aXBseVNjYWxhcihzKSB7XG5cdFx0XHR0aGlzLnIgKj0gcztcblx0XHRcdHRoaXMuZyAqPSBzO1xuXHRcdFx0dGhpcy5iICo9IHM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRsZXJwKGNvbG9yLCBhbHBoYSkge1xuXHRcdFx0dGhpcy5yICs9IChjb2xvci5yIC0gdGhpcy5yKSAqIGFscGhhO1xuXHRcdFx0dGhpcy5nICs9IChjb2xvci5nIC0gdGhpcy5nKSAqIGFscGhhO1xuXHRcdFx0dGhpcy5iICs9IChjb2xvci5iIC0gdGhpcy5iKSAqIGFscGhhO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bGVycENvbG9ycyhjb2xvcjEsIGNvbG9yMiwgYWxwaGEpIHtcblx0XHRcdHRoaXMuciA9IGNvbG9yMS5yICsgKGNvbG9yMi5yIC0gY29sb3IxLnIpICogYWxwaGE7XG5cdFx0XHR0aGlzLmcgPSBjb2xvcjEuZyArIChjb2xvcjIuZyAtIGNvbG9yMS5nKSAqIGFscGhhO1xuXHRcdFx0dGhpcy5iID0gY29sb3IxLmIgKyAoY29sb3IyLmIgLSBjb2xvcjEuYikgKiBhbHBoYTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGxlcnBIU0woY29sb3IsIGFscGhhKSB7XG5cdFx0XHR0aGlzLmdldEhTTChfaHNsQSk7XG5cdFx0XHRjb2xvci5nZXRIU0woX2hzbEIpO1xuXHRcdFx0Y29uc3QgaCA9IGxlcnAoX2hzbEEuaCwgX2hzbEIuaCwgYWxwaGEpO1xuXHRcdFx0Y29uc3QgcyA9IGxlcnAoX2hzbEEucywgX2hzbEIucywgYWxwaGEpO1xuXHRcdFx0Y29uc3QgbCA9IGxlcnAoX2hzbEEubCwgX2hzbEIubCwgYWxwaGEpO1xuXHRcdFx0dGhpcy5zZXRIU0woaCwgcywgbCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRlcXVhbHMoYykge1xuXHRcdFx0cmV0dXJuIGMuciA9PT0gdGhpcy5yICYmIGMuZyA9PT0gdGhpcy5nICYmIGMuYiA9PT0gdGhpcy5iO1xuXHRcdH1cblxuXHRcdGZyb21BcnJheShhcnJheSwgb2Zmc2V0ID0gMCkge1xuXHRcdFx0dGhpcy5yID0gYXJyYXlbb2Zmc2V0XTtcblx0XHRcdHRoaXMuZyA9IGFycmF5W29mZnNldCArIDFdO1xuXHRcdFx0dGhpcy5iID0gYXJyYXlbb2Zmc2V0ICsgMl07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0b0FycmF5KGFycmF5ID0gW10sIG9mZnNldCA9IDApIHtcblx0XHRcdGFycmF5W29mZnNldF0gPSB0aGlzLnI7XG5cdFx0XHRhcnJheVtvZmZzZXQgKyAxXSA9IHRoaXMuZztcblx0XHRcdGFycmF5W29mZnNldCArIDJdID0gdGhpcy5iO1xuXHRcdFx0cmV0dXJuIGFycmF5O1xuXHRcdH1cblxuXHRcdGZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBpbmRleCkge1xuXHRcdFx0dGhpcy5yID0gYXR0cmlidXRlLmdldFgoaW5kZXgpO1xuXHRcdFx0dGhpcy5nID0gYXR0cmlidXRlLmdldFkoaW5kZXgpO1xuXHRcdFx0dGhpcy5iID0gYXR0cmlidXRlLmdldFooaW5kZXgpO1xuXG5cdFx0XHRpZiAoYXR0cmlidXRlLm5vcm1hbGl6ZWQgPT09IHRydWUpIHtcblx0XHRcdFx0Ly8gYXNzdW1pbmcgVWludDhBcnJheVxuXHRcdFx0XHR0aGlzLnIgLz0gMjU1O1xuXHRcdFx0XHR0aGlzLmcgLz0gMjU1O1xuXHRcdFx0XHR0aGlzLmIgLz0gMjU1O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0b0pTT04oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRIZXgoKTtcblx0XHR9XG5cblx0fVxuXG5cdENvbG9yLk5BTUVTID0gX2NvbG9yS2V5d29yZHM7XG5cdENvbG9yLnByb3RvdHlwZS5pc0NvbG9yID0gdHJ1ZTtcblx0Q29sb3IucHJvdG90eXBlLnIgPSAxO1xuXHRDb2xvci5wcm90b3R5cGUuZyA9IDE7XG5cdENvbG9yLnByb3RvdHlwZS5iID0gMTtcblxuXHQvKipcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICpcdGNvbG9yOiA8aGV4Pixcblx0ICpcdG9wYWNpdHk6IDxmbG9hdD4sXG5cdCAqXHRtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqXHRsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcdGxpZ2h0TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG5cdCAqXG5cdCAqXHRhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcdGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG5cdCAqXG5cdCAqXHRzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICpcdGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKlx0ZW52TWFwOiBuZXcgVEhSRUUuQ3ViZVRleHR1cmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxuXHQgKlx0Y29tYmluZTogVEhSRUUuTXVsdGlwbHksXG5cdCAqXHRyZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG5cdCAqXHRyZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHRkZXB0aFRlc3Q6IDxib29sPixcblx0ICpcdGRlcHRoV3JpdGU6IDxib29sPixcblx0ICpcblx0ICpcdHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuXHQgKlx0d2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuXHQgKiB9XG5cdCAqL1xuXG5cdGNsYXNzIE1lc2hCYXNpY01hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXHRcdGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnTWVzaEJhc2ljTWF0ZXJpYWwnO1xuXHRcdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvcigweGZmZmZmZik7IC8vIGVtaXNzaXZlXG5cblx0XHRcdHRoaXMubWFwID0gbnVsbDtcblx0XHRcdHRoaXMubGlnaHRNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcblx0XHRcdHRoaXMuYW9NYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblx0XHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmVudk1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmNvbWJpbmUgPSBNdWx0aXBseU9wZXJhdGlvbjtcblx0XHRcdHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcblx0XHRcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblx0XHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cdFx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cdFx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuXHRcdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG5cdFx0XHR0aGlzLnNldFZhbHVlcyhwYXJhbWV0ZXJzKTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0dGhpcy5jb2xvci5jb3B5KHNvdXJjZS5jb2xvcik7XG5cdFx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cdFx0XHR0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xuXHRcdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcblx0XHRcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XG5cdFx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xuXHRcdFx0dGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcblx0XHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cdFx0XHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XG5cdFx0XHR0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcblx0XHRcdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcblx0XHRcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcblx0XHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuXHRcdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0TWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaEJhc2ljTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdGNvbnN0IF92ZWN0b3IkOSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF92ZWN0b3IyJDEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjIoKTtcblxuXHRjbGFzcyBCdWZmZXJBdHRyaWJ1dGUge1xuXHRcdGNvbnN0cnVjdG9yKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogYXJyYXkgc2hvdWxkIGJlIGEgVHlwZWQgQXJyYXkuJyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubmFtZSA9ICcnO1xuXHRcdFx0dGhpcy5hcnJheSA9IGFycmF5O1xuXHRcdFx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xuXHRcdFx0dGhpcy5jb3VudCA9IGFycmF5ICE9PSB1bmRlZmluZWQgPyBhcnJheS5sZW5ndGggLyBpdGVtU2l6ZSA6IDA7XG5cdFx0XHR0aGlzLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkID09PSB0cnVlO1xuXHRcdFx0dGhpcy51c2FnZSA9IFN0YXRpY0RyYXdVc2FnZTtcblx0XHRcdHRoaXMudXBkYXRlUmFuZ2UgPSB7XG5cdFx0XHRcdG9mZnNldDogMCxcblx0XHRcdFx0Y291bnQ6IC0xXG5cdFx0XHR9O1xuXHRcdFx0dGhpcy52ZXJzaW9uID0gMDtcblx0XHR9XG5cblx0XHRvblVwbG9hZENhbGxiYWNrKCkge31cblxuXHRcdHNldCBuZWVkc1VwZGF0ZSh2YWx1ZSkge1xuXHRcdFx0aWYgKHZhbHVlID09PSB0cnVlKSB0aGlzLnZlcnNpb24rKztcblx0XHR9XG5cblx0XHRzZXRVc2FnZSh2YWx1ZSkge1xuXHRcdFx0dGhpcy51c2FnZSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXHRcdFx0dGhpcy5hcnJheSA9IG5ldyBzb3VyY2UuYXJyYXkuY29uc3RydWN0b3Ioc291cmNlLmFycmF5KTtcblx0XHRcdHRoaXMuaXRlbVNpemUgPSBzb3VyY2UuaXRlbVNpemU7XG5cdFx0XHR0aGlzLmNvdW50ID0gc291cmNlLmNvdW50O1xuXHRcdFx0dGhpcy5ub3JtYWxpemVkID0gc291cmNlLm5vcm1hbGl6ZWQ7XG5cdFx0XHR0aGlzLnVzYWdlID0gc291cmNlLnVzYWdlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29weUF0KGluZGV4MSwgYXR0cmlidXRlLCBpbmRleDIpIHtcblx0XHRcdGluZGV4MSAqPSB0aGlzLml0ZW1TaXplO1xuXHRcdFx0aW5kZXgyICo9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLml0ZW1TaXplOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuYXJyYXlbaW5kZXgxICsgaV0gPSBhdHRyaWJ1dGUuYXJyYXlbaW5kZXgyICsgaV07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNvcHlBcnJheShhcnJheSkge1xuXHRcdFx0dGhpcy5hcnJheS5zZXQoYXJyYXkpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29weUNvbG9yc0FycmF5KGNvbG9ycykge1xuXHRcdFx0Y29uc3QgYXJyYXkgPSB0aGlzLmFycmF5O1xuXHRcdFx0bGV0IG9mZnNldCA9IDA7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gY29sb3JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRsZXQgY29sb3IgPSBjb2xvcnNbaV07XG5cblx0XHRcdFx0aWYgKGNvbG9yID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5Q29sb3JzQXJyYXkoKTogY29sb3IgaXMgdW5kZWZpbmVkJywgaSk7XG5cdFx0XHRcdFx0Y29sb3IgPSBuZXcgQ29sb3IoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFycmF5W29mZnNldCsrXSA9IGNvbG9yLnI7XG5cdFx0XHRcdGFycmF5W29mZnNldCsrXSA9IGNvbG9yLmc7XG5cdFx0XHRcdGFycmF5W29mZnNldCsrXSA9IGNvbG9yLmI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNvcHlWZWN0b3Iyc0FycmF5KHZlY3RvcnMpIHtcblx0XHRcdGNvbnN0IGFycmF5ID0gdGhpcy5hcnJheTtcblx0XHRcdGxldCBvZmZzZXQgPSAwO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGxldCB2ZWN0b3IgPSB2ZWN0b3JzW2ldO1xuXG5cdFx0XHRcdGlmICh2ZWN0b3IgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Iyc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpKTtcblx0XHRcdFx0XHR2ZWN0b3IgPSBuZXcgVmVjdG9yMigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YXJyYXlbb2Zmc2V0KytdID0gdmVjdG9yLng7XG5cdFx0XHRcdGFycmF5W29mZnNldCsrXSA9IHZlY3Rvci55O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb3B5VmVjdG9yM3NBcnJheSh2ZWN0b3JzKSB7XG5cdFx0XHRjb25zdCBhcnJheSA9IHRoaXMuYXJyYXk7XG5cdFx0XHRsZXQgb2Zmc2V0ID0gMDtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRsZXQgdmVjdG9yID0gdmVjdG9yc1tpXTtcblxuXHRcdFx0XHRpZiAodmVjdG9yID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkJywgaSk7XG5cdFx0XHRcdFx0dmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFycmF5W29mZnNldCsrXSA9IHZlY3Rvci54O1xuXHRcdFx0XHRhcnJheVtvZmZzZXQrK10gPSB2ZWN0b3IueTtcblx0XHRcdFx0YXJyYXlbb2Zmc2V0KytdID0gdmVjdG9yLno7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNvcHlWZWN0b3I0c0FycmF5KHZlY3RvcnMpIHtcblx0XHRcdGNvbnN0IGFycmF5ID0gdGhpcy5hcnJheTtcblx0XHRcdGxldCBvZmZzZXQgPSAwO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGxldCB2ZWN0b3IgPSB2ZWN0b3JzW2ldO1xuXG5cdFx0XHRcdGlmICh2ZWN0b3IgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3I0c0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpKTtcblx0XHRcdFx0XHR2ZWN0b3IgPSBuZXcgVmVjdG9yNCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YXJyYXlbb2Zmc2V0KytdID0gdmVjdG9yLng7XG5cdFx0XHRcdGFycmF5W29mZnNldCsrXSA9IHZlY3Rvci55O1xuXHRcdFx0XHRhcnJheVtvZmZzZXQrK10gPSB2ZWN0b3Iuejtcblx0XHRcdFx0YXJyYXlbb2Zmc2V0KytdID0gdmVjdG9yLnc7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGFwcGx5TWF0cml4MyhtKSB7XG5cdFx0XHRpZiAodGhpcy5pdGVtU2l6ZSA9PT0gMikge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRfdmVjdG9yMiQxLmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcywgaSk7XG5cblx0XHRcdFx0XHRfdmVjdG9yMiQxLmFwcGx5TWF0cml4MyhtKTtcblxuXHRcdFx0XHRcdHRoaXMuc2V0WFkoaSwgX3ZlY3RvcjIkMS54LCBfdmVjdG9yMiQxLnkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuaXRlbVNpemUgPT09IDMpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmNvdW50OyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0X3ZlY3RvciQ5LmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcywgaSk7XG5cblx0XHRcdFx0XHRfdmVjdG9yJDkuYXBwbHlNYXRyaXgzKG0pO1xuXG5cdFx0XHRcdFx0dGhpcy5zZXRYWVooaSwgX3ZlY3RvciQ5LngsIF92ZWN0b3IkOS55LCBfdmVjdG9yJDkueik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0YXBwbHlNYXRyaXg0KG0pIHtcblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5jb3VudDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRfdmVjdG9yJDkueCA9IHRoaXMuZ2V0WChpKTtcblx0XHRcdFx0X3ZlY3RvciQ5LnkgPSB0aGlzLmdldFkoaSk7XG5cdFx0XHRcdF92ZWN0b3IkOS56ID0gdGhpcy5nZXRaKGkpO1xuXG5cdFx0XHRcdF92ZWN0b3IkOS5hcHBseU1hdHJpeDQobSk7XG5cblx0XHRcdFx0dGhpcy5zZXRYWVooaSwgX3ZlY3RvciQ5LngsIF92ZWN0b3IkOS55LCBfdmVjdG9yJDkueik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGFwcGx5Tm9ybWFsTWF0cml4KG0pIHtcblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5jb3VudDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRfdmVjdG9yJDkueCA9IHRoaXMuZ2V0WChpKTtcblx0XHRcdFx0X3ZlY3RvciQ5LnkgPSB0aGlzLmdldFkoaSk7XG5cdFx0XHRcdF92ZWN0b3IkOS56ID0gdGhpcy5nZXRaKGkpO1xuXG5cdFx0XHRcdF92ZWN0b3IkOS5hcHBseU5vcm1hbE1hdHJpeChtKTtcblxuXHRcdFx0XHR0aGlzLnNldFhZWihpLCBfdmVjdG9yJDkueCwgX3ZlY3RvciQ5LnksIF92ZWN0b3IkOS56KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dHJhbnNmb3JtRGlyZWN0aW9uKG0pIHtcblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5jb3VudDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRfdmVjdG9yJDkueCA9IHRoaXMuZ2V0WChpKTtcblx0XHRcdFx0X3ZlY3RvciQ5LnkgPSB0aGlzLmdldFkoaSk7XG5cdFx0XHRcdF92ZWN0b3IkOS56ID0gdGhpcy5nZXRaKGkpO1xuXG5cdFx0XHRcdF92ZWN0b3IkOS50cmFuc2Zvcm1EaXJlY3Rpb24obSk7XG5cblx0XHRcdFx0dGhpcy5zZXRYWVooaSwgX3ZlY3RvciQ5LngsIF92ZWN0b3IkOS55LCBfdmVjdG9yJDkueik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldCh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuXHRcdFx0dGhpcy5hcnJheS5zZXQodmFsdWUsIG9mZnNldCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRnZXRYKGluZGV4KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcnJheVtpbmRleCAqIHRoaXMuaXRlbVNpemVdO1xuXHRcdH1cblxuXHRcdHNldFgoaW5kZXgsIHgpIHtcblx0XHRcdHRoaXMuYXJyYXlbaW5kZXggKiB0aGlzLml0ZW1TaXplXSA9IHg7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRnZXRZKGluZGV4KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcnJheVtpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxXTtcblx0XHR9XG5cblx0XHRzZXRZKGluZGV4LCB5KSB7XG5cdFx0XHR0aGlzLmFycmF5W2luZGV4ICogdGhpcy5pdGVtU2l6ZSArIDFdID0geTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGdldFooaW5kZXgpIHtcblx0XHRcdHJldHVybiB0aGlzLmFycmF5W2luZGV4ICogdGhpcy5pdGVtU2l6ZSArIDJdO1xuXHRcdH1cblxuXHRcdHNldFooaW5kZXgsIHopIHtcblx0XHRcdHRoaXMuYXJyYXlbaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMl0gPSB6O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Z2V0VyhpbmRleCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXJyYXlbaW5kZXggKiB0aGlzLml0ZW1TaXplICsgM107XG5cdFx0fVxuXG5cdFx0c2V0VyhpbmRleCwgdykge1xuXHRcdFx0dGhpcy5hcnJheVtpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzXSA9IHc7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRYWShpbmRleCwgeCwgeSkge1xuXHRcdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblx0XHRcdHRoaXMuYXJyYXlbaW5kZXggKyAwXSA9IHg7XG5cdFx0XHR0aGlzLmFycmF5W2luZGV4ICsgMV0gPSB5O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0WFlaKGluZGV4LCB4LCB5LCB6KSB7XG5cdFx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXHRcdFx0dGhpcy5hcnJheVtpbmRleCArIDBdID0geDtcblx0XHRcdHRoaXMuYXJyYXlbaW5kZXggKyAxXSA9IHk7XG5cdFx0XHR0aGlzLmFycmF5W2luZGV4ICsgMl0gPSB6O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0WFlaVyhpbmRleCwgeCwgeSwgeiwgdykge1xuXHRcdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblx0XHRcdHRoaXMuYXJyYXlbaW5kZXggKyAwXSA9IHg7XG5cdFx0XHR0aGlzLmFycmF5W2luZGV4ICsgMV0gPSB5O1xuXHRcdFx0dGhpcy5hcnJheVtpbmRleCArIDJdID0gejtcblx0XHRcdHRoaXMuYXJyYXlbaW5kZXggKyAzXSA9IHc7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRvblVwbG9hZChjYWxsYmFjaykge1xuXHRcdFx0dGhpcy5vblVwbG9hZENhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmFycmF5LCB0aGlzLml0ZW1TaXplKS5jb3B5KHRoaXMpO1xuXHRcdH1cblxuXHRcdHRvSlNPTigpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRcdGl0ZW1TaXplOiB0aGlzLml0ZW1TaXplLFxuXHRcdFx0XHR0eXBlOiB0aGlzLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXG5cdFx0XHRcdGFycmF5OiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLmFycmF5KSxcblx0XHRcdFx0bm9ybWFsaXplZDogdGhpcy5ub3JtYWxpemVkXG5cdFx0XHR9O1xuXHRcdFx0aWYgKHRoaXMubmFtZSAhPT0gJycpIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcblx0XHRcdGlmICh0aGlzLnVzYWdlICE9PSBTdGF0aWNEcmF3VXNhZ2UpIGRhdGEudXNhZ2UgPSB0aGlzLnVzYWdlO1xuXHRcdFx0aWYgKHRoaXMudXBkYXRlUmFuZ2Uub2Zmc2V0ICE9PSAwIHx8IHRoaXMudXBkYXRlUmFuZ2UuY291bnQgIT09IC0xKSBkYXRhLnVwZGF0ZVJhbmdlID0gdGhpcy51cGRhdGVSYW5nZTtcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHR9XG5cblx0QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5pc0J1ZmZlckF0dHJpYnV0ZSA9IHRydWU7IC8vXG5cblx0Y2xhc3MgSW50OEJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cdFx0Y29uc3RydWN0b3IoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKSB7XG5cdFx0XHRzdXBlcihuZXcgSW50OEFycmF5KGFycmF5KSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgVWludDhCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXHRcdGNvbnN0cnVjdG9yKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuXHRcdFx0c3VwZXIobmV3IFVpbnQ4QXJyYXkoYXJyYXkpLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCk7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBVaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXHRcdGNvbnN0cnVjdG9yKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuXHRcdFx0c3VwZXIobmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGFycmF5KSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgSW50MTZCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXHRcdGNvbnN0cnVjdG9yKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuXHRcdFx0c3VwZXIobmV3IEludDE2QXJyYXkoYXJyYXkpLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCk7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBVaW50MTZCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXHRcdGNvbnN0cnVjdG9yKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuXHRcdFx0c3VwZXIobmV3IFVpbnQxNkFycmF5KGFycmF5KSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgSW50MzJCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXHRcdGNvbnN0cnVjdG9yKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuXHRcdFx0c3VwZXIobmV3IEludDMyQXJyYXkoYXJyYXkpLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCk7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBVaW50MzJCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXHRcdGNvbnN0cnVjdG9yKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuXHRcdFx0c3VwZXIobmV3IFVpbnQzMkFycmF5KGFycmF5KSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cdFx0Y29uc3RydWN0b3IoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKSB7XG5cdFx0XHRzdXBlcihuZXcgVWludDE2QXJyYXkoYXJyYXkpLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCk7XG5cdFx0fVxuXG5cdH1cblxuXHRGbG9hdDE2QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5pc0Zsb2F0MTZCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuXG5cdGNsYXNzIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXHRcdGNvbnN0cnVjdG9yKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuXHRcdFx0c3VwZXIobmV3IEZsb2F0MzJBcnJheShhcnJheSksIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIEZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXHRcdGNvbnN0cnVjdG9yKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuXHRcdFx0c3VwZXIobmV3IEZsb2F0NjRBcnJheShhcnJheSksIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcblx0XHR9XG5cblx0fSAvL1xuXG5cdGxldCBfaWQgPSAwO1xuXG5cdGNvbnN0IF9tMSA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuXG5cdGNvbnN0IF9vYmogPSAvKkBfX1BVUkVfXyovbmV3IE9iamVjdDNEKCk7XG5cblx0Y29uc3QgX29mZnNldCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9ib3gkMSA9IC8qQF9fUFVSRV9fKi9uZXcgQm94MygpO1xuXG5cdGNvbnN0IF9ib3hNb3JwaFRhcmdldHMgPSAvKkBfX1BVUkVfXyovbmV3IEJveDMoKTtcblxuXHRjb25zdCBfdmVjdG9yJDggPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjbGFzcyBCdWZmZXJHZW9tZXRyeSBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpZCcsIHtcblx0XHRcdFx0dmFsdWU6IF9pZCsrXG5cdFx0XHR9KTtcblx0XHRcdHRoaXMudXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXHRcdFx0dGhpcy5uYW1lID0gJyc7XG5cdFx0XHR0aGlzLnR5cGUgPSAnQnVmZmVyR2VvbWV0cnknO1xuXHRcdFx0dGhpcy5pbmRleCA9IG51bGw7XG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcblx0XHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzID0ge307XG5cdFx0XHR0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gZmFsc2U7XG5cdFx0XHR0aGlzLmdyb3VwcyA9IFtdO1xuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblx0XHRcdHRoaXMuZHJhd1JhbmdlID0ge1xuXHRcdFx0XHRzdGFydDogMCxcblx0XHRcdFx0Y291bnQ6IEluZmluaXR5XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy51c2VyRGF0YSA9IHt9O1xuXHRcdH1cblxuXHRcdGdldEluZGV4KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaW5kZXg7XG5cdFx0fVxuXG5cdFx0c2V0SW5kZXgoaW5kZXgpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGluZGV4KSkge1xuXHRcdFx0XHR0aGlzLmluZGV4ID0gbmV3IChhcnJheU1heChpbmRleCkgPiA2NTUzNSA/IFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSA6IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSkoaW5kZXgsIDEpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5pbmRleCA9IGluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRnZXRBdHRyaWJ1dGUobmFtZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcblx0XHR9XG5cblx0XHRzZXRBdHRyaWJ1dGUobmFtZSwgYXR0cmlidXRlKSB7XG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXNbbmFtZV0gPSBhdHRyaWJ1dGU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRkZWxldGVBdHRyaWJ1dGUobmFtZSkge1xuXHRcdFx0ZGVsZXRlIHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGhhc0F0dHJpYnV0ZShuYW1lKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW25hbWVdICE9PSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0YWRkR3JvdXAoc3RhcnQsIGNvdW50LCBtYXRlcmlhbEluZGV4ID0gMCkge1xuXHRcdFx0dGhpcy5ncm91cHMucHVzaCh7XG5cdFx0XHRcdHN0YXJ0OiBzdGFydCxcblx0XHRcdFx0Y291bnQ6IGNvdW50LFxuXHRcdFx0XHRtYXRlcmlhbEluZGV4OiBtYXRlcmlhbEluZGV4XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRjbGVhckdyb3VwcygpIHtcblx0XHRcdHRoaXMuZ3JvdXBzID0gW107XG5cdFx0fVxuXG5cdFx0c2V0RHJhd1JhbmdlKHN0YXJ0LCBjb3VudCkge1xuXHRcdFx0dGhpcy5kcmF3UmFuZ2Uuc3RhcnQgPSBzdGFydDtcblx0XHRcdHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gY291bnQ7XG5cdFx0fVxuXG5cdFx0YXBwbHlNYXRyaXg0KG1hdHJpeCkge1xuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdGlmIChwb3NpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHBvc2l0aW9uLmFwcGx5TWF0cml4NChtYXRyaXgpO1xuXHRcdFx0XHRwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG5vcm1hbCA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XG5cblx0XHRcdGlmIChub3JtYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb25zdCBub3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeChtYXRyaXgpO1xuXHRcdFx0XHRub3JtYWwuYXBwbHlOb3JtYWxNYXRyaXgobm9ybWFsTWF0cml4KTtcblx0XHRcdFx0bm9ybWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdGFuZ2VudCA9IHRoaXMuYXR0cmlidXRlcy50YW5nZW50O1xuXG5cdFx0XHRpZiAodGFuZ2VudCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRhbmdlbnQudHJhbnNmb3JtRGlyZWN0aW9uKG1hdHJpeCk7XG5cdFx0XHRcdHRhbmdlbnQubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRhcHBseVF1YXRlcm5pb24ocSkge1xuXHRcdFx0X20xLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHEpO1xuXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4NChfbTEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0cm90YXRlWChhbmdsZSkge1xuXHRcdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB4LWF4aXNcblx0XHRcdF9tMS5tYWtlUm90YXRpb25YKGFuZ2xlKTtcblxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeDQoX20xKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHJvdGF0ZVkoYW5nbGUpIHtcblx0XHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeS1heGlzXG5cdFx0XHRfbTEubWFrZVJvdGF0aW9uWShhbmdsZSk7XG5cblx0XHRcdHRoaXMuYXBwbHlNYXRyaXg0KF9tMSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRyb3RhdGVaKGFuZ2xlKSB7XG5cdFx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHotYXhpc1xuXHRcdFx0X20xLm1ha2VSb3RhdGlvblooYW5nbGUpO1xuXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4NChfbTEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dHJhbnNsYXRlKHgsIHksIHopIHtcblx0XHRcdC8vIHRyYW5zbGF0ZSBnZW9tZXRyeVxuXHRcdFx0X20xLm1ha2VUcmFuc2xhdGlvbih4LCB5LCB6KTtcblxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeDQoX20xKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNjYWxlKHgsIHksIHopIHtcblx0XHRcdC8vIHNjYWxlIGdlb21ldHJ5XG5cdFx0XHRfbTEubWFrZVNjYWxlKHgsIHksIHopO1xuXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4NChfbTEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bG9va0F0KHZlY3Rvcikge1xuXHRcdFx0X29iai5sb29rQXQodmVjdG9yKTtcblxuXHRcdFx0X29iai51cGRhdGVNYXRyaXgoKTtcblxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeDQoX29iai5tYXRyaXgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y2VudGVyKCkge1xuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblx0XHRcdHRoaXMuYm91bmRpbmdCb3guZ2V0Q2VudGVyKF9vZmZzZXQpLm5lZ2F0ZSgpO1xuXHRcdFx0dGhpcy50cmFuc2xhdGUoX29mZnNldC54LCBfb2Zmc2V0LnksIF9vZmZzZXQueik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRGcm9tUG9pbnRzKHBvaW50cykge1xuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuXHRcdFx0XHRwb3NpdGlvbi5wdXNoKHBvaW50LngsIHBvaW50LnksIHBvaW50LnogfHwgMCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uLCAzKSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb21wdXRlQm91bmRpbmdCb3goKSB7XG5cdFx0XHRpZiAodGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbmV3IEJveDMoKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbiA9IHRoaXMubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRpZiAocG9zaXRpb24gJiYgcG9zaXRpb24uaXNHTEJ1ZmZlckF0dHJpYnV0ZSkge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTogR0xCdWZmZXJBdHRyaWJ1dGUgcmVxdWlyZXMgYSBtYW51YWwgYm91bmRpbmcgYm94LiBBbHRlcm5hdGl2ZWx5IHNldCBcIm1lc2guZnJ1c3R1bUN1bGxlZFwiIHRvIFwiZmFsc2VcIi4nLCB0aGlzKTtcblx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveC5zZXQobmV3IFZlY3RvcjMoLUluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eSksIG5ldyBWZWN0b3IzKCtJbmZpbml0eSwgK0luZmluaXR5LCArSW5maW5pdHkpKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocG9zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94LnNldEZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb24pOyAvLyBwcm9jZXNzIG1vcnBoIGF0dHJpYnV0ZXMgaWYgcHJlc2VudFxuXG5cdFx0XHRcdGlmIChtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbikge1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb25baV07XG5cblx0XHRcdFx0XHRcdF9ib3gkMS5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoQXR0cmlidXRlKTtcblxuXHRcdFx0XHRcdFx0aWYgKHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUpIHtcblx0XHRcdFx0XHRcdFx0X3ZlY3RvciQ4LmFkZFZlY3RvcnModGhpcy5ib3VuZGluZ0JveC5taW4sIF9ib3gkMS5taW4pO1xuXG5cdFx0XHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludChfdmVjdG9yJDgpO1xuXG5cdFx0XHRcdFx0XHRcdF92ZWN0b3IkOC5hZGRWZWN0b3JzKHRoaXMuYm91bmRpbmdCb3gubWF4LCBfYm94JDEubWF4KTtcblxuXHRcdFx0XHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQoX3ZlY3RvciQ4KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludChfYm94JDEubWluKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KF9ib3gkMS5tYXgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveC5tYWtlRW1wdHkoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzTmFOKHRoaXMuYm91bmRpbmdCb3gubWluLngpIHx8IGlzTmFOKHRoaXMuYm91bmRpbmdCb3gubWluLnkpIHx8IGlzTmFOKHRoaXMuYm91bmRpbmdCb3gubWluLnopKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpOiBDb21wdXRlZCBtaW4vbWF4IGhhdmUgTmFOIHZhbHVlcy4gVGhlIFwicG9zaXRpb25cIiBhdHRyaWJ1dGUgaXMgbGlrZWx5IHRvIGhhdmUgTmFOIHZhbHVlcy4nLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb21wdXRlQm91bmRpbmdTcGhlcmUoKSB7XG5cdFx0XHRpZiAodGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBwb3NpdGlvbiA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uID0gdGhpcy5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdGlmIChwb3NpdGlvbiAmJiBwb3NpdGlvbi5pc0dMQnVmZmVyQXR0cmlidXRlKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBHTEJ1ZmZlckF0dHJpYnV0ZSByZXF1aXJlcyBhIG1hbnVhbCBib3VuZGluZyBzcGhlcmUuIEFsdGVybmF0aXZlbHkgc2V0IFwibWVzaC5mcnVzdHVtQ3VsbGVkXCIgdG8gXCJmYWxzZVwiLicsIHRoaXMpO1xuXHRcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlLnNldChuZXcgVmVjdG9yMygpLCBJbmZpbml0eSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHBvc2l0aW9uKSB7XG5cdFx0XHRcdC8vIGZpcnN0LCBmaW5kIHRoZSBjZW50ZXIgb2YgdGhlIGJvdW5kaW5nIHNwaGVyZVxuXHRcdFx0XHRjb25zdCBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcblxuXHRcdFx0XHRfYm94JDEuc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbik7IC8vIHByb2Nlc3MgbW9ycGggYXR0cmlidXRlcyBpZiBwcmVzZW50XG5cblxuXHRcdFx0XHRpZiAobW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24pIHtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbi5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uW2ldO1xuXG5cdFx0XHRcdFx0XHRfYm94TW9ycGhUYXJnZXRzLnNldEZyb21CdWZmZXJBdHRyaWJ1dGUobW9ycGhBdHRyaWJ1dGUpO1xuXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZSkge1xuXHRcdFx0XHRcdFx0XHRfdmVjdG9yJDguYWRkVmVjdG9ycyhfYm94JDEubWluLCBfYm94TW9ycGhUYXJnZXRzLm1pbik7XG5cblx0XHRcdFx0XHRcdFx0X2JveCQxLmV4cGFuZEJ5UG9pbnQoX3ZlY3RvciQ4KTtcblxuXHRcdFx0XHRcdFx0XHRfdmVjdG9yJDguYWRkVmVjdG9ycyhfYm94JDEubWF4LCBfYm94TW9ycGhUYXJnZXRzLm1heCk7XG5cblx0XHRcdFx0XHRcdFx0X2JveCQxLmV4cGFuZEJ5UG9pbnQoX3ZlY3RvciQ4KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdF9ib3gkMS5leHBhbmRCeVBvaW50KF9ib3hNb3JwaFRhcmdldHMubWluKTtcblxuXHRcdFx0XHRcdFx0XHRfYm94JDEuZXhwYW5kQnlQb2ludChfYm94TW9ycGhUYXJnZXRzLm1heCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2JveCQxLmdldENlbnRlcihjZW50ZXIpOyAvLyBzZWNvbmQsIHRyeSB0byBmaW5kIGEgYm91bmRpbmdTcGhlcmUgd2l0aCBhIHJhZGl1cyBzbWFsbGVyIHRoYW4gdGhlXG5cdFx0XHRcdC8vIGJvdW5kaW5nU3BoZXJlIG9mIHRoZSBib3VuZGluZ0JveDogc3FydCgzKSBzbWFsbGVyIGluIHRoZSBiZXN0IGNhc2VcblxuXG5cdFx0XHRcdGxldCBtYXhSYWRpdXNTcSA9IDA7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gcG9zaXRpb24uY291bnQ7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdFx0X3ZlY3RvciQ4LmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb24sIGkpO1xuXG5cdFx0XHRcdFx0bWF4UmFkaXVzU3EgPSBNYXRoLm1heChtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKF92ZWN0b3IkOCkpO1xuXHRcdFx0XHR9IC8vIHByb2Nlc3MgbW9ycGggYXR0cmlidXRlcyBpZiBwcmVzZW50XG5cblxuXHRcdFx0XHRpZiAobW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24pIHtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbi5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uW2ldO1xuXHRcdFx0XHRcdFx0Y29uc3QgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBqID0gMCwgamwgPSBtb3JwaEF0dHJpYnV0ZS5jb3VudDsgaiA8IGpsOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0X3ZlY3RvciQ4LmZyb21CdWZmZXJBdHRyaWJ1dGUobW9ycGhBdHRyaWJ1dGUsIGopO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChtb3JwaFRhcmdldHNSZWxhdGl2ZSkge1xuXHRcdFx0XHRcdFx0XHRcdF9vZmZzZXQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbiwgaik7XG5cblx0XHRcdFx0XHRcdFx0XHRfdmVjdG9yJDguYWRkKF9vZmZzZXQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0bWF4UmFkaXVzU3EgPSBNYXRoLm1heChtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKF92ZWN0b3IkOCkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzID0gTWF0aC5zcXJ0KG1heFJhZGl1c1NxKTtcblxuXHRcdFx0XHRpZiAoaXNOYU4odGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMpKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IENvbXB1dGVkIHJhZGl1cyBpcyBOYU4uIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb21wdXRlVGFuZ2VudHMoKSB7XG5cdFx0XHRjb25zdCBpbmRleCA9IHRoaXMuaW5kZXg7XG5cdFx0XHRjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzOyAvLyBiYXNlZCBvbiBodHRwOi8vd3d3LnRlcmF0aG9uLmNvbS9jb2RlL3RhbmdlbnQuaHRtbFxuXHRcdFx0Ly8gKHBlciB2ZXJ0ZXggdGFuZ2VudHMpXG5cblx0XHRcdGlmIChpbmRleCA9PT0gbnVsbCB8fCBhdHRyaWJ1dGVzLnBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgYXR0cmlidXRlcy5ub3JtYWwgPT09IHVuZGVmaW5lZCB8fCBhdHRyaWJ1dGVzLnV2ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlVGFuZ2VudHMoKSBmYWlsZWQuIE1pc3NpbmcgcmVxdWlyZWQgYXR0cmlidXRlcyAoaW5kZXgsIHBvc2l0aW9uLCBub3JtYWwgb3IgdXYpJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xuXHRcdFx0Y29uc3QgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblx0XHRcdGNvbnN0IG5vcm1hbHMgPSBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcblx0XHRcdGNvbnN0IHV2cyA9IGF0dHJpYnV0ZXMudXYuYXJyYXk7XG5cdFx0XHRjb25zdCBuVmVydGljZXMgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMztcblxuXHRcdFx0aWYgKGF0dHJpYnV0ZXMudGFuZ2VudCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCd0YW5nZW50JywgbmV3IEJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KDQgKiBuVmVydGljZXMpLCA0KSk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHRhbmdlbnRzID0gYXR0cmlidXRlcy50YW5nZW50LmFycmF5O1xuXHRcdFx0Y29uc3QgdGFuMSA9IFtdLFxuXHRcdFx0XHRcdFx0dGFuMiA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5WZXJ0aWNlczsgaSsrKSB7XG5cdFx0XHRcdHRhbjFbaV0gPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHR0YW4yW2ldID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdkEgPSBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRcdFx0dkIgPSBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRcdFx0dkMgPSBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRcdFx0dXZBID0gbmV3IFZlY3RvcjIoKSxcblx0XHRcdFx0XHRcdHV2QiA9IG5ldyBWZWN0b3IyKCksXG5cdFx0XHRcdFx0XHR1dkMgPSBuZXcgVmVjdG9yMigpLFxuXHRcdFx0XHRcdFx0c2RpciA9IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHR0ZGlyID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlVHJpYW5nbGUoYSwgYiwgYykge1xuXHRcdFx0XHR2QS5mcm9tQXJyYXkocG9zaXRpb25zLCBhICogMyk7XG5cdFx0XHRcdHZCLmZyb21BcnJheShwb3NpdGlvbnMsIGIgKiAzKTtcblx0XHRcdFx0dkMuZnJvbUFycmF5KHBvc2l0aW9ucywgYyAqIDMpO1xuXHRcdFx0XHR1dkEuZnJvbUFycmF5KHV2cywgYSAqIDIpO1xuXHRcdFx0XHR1dkIuZnJvbUFycmF5KHV2cywgYiAqIDIpO1xuXHRcdFx0XHR1dkMuZnJvbUFycmF5KHV2cywgYyAqIDIpO1xuXHRcdFx0XHR2Qi5zdWIodkEpO1xuXHRcdFx0XHR2Qy5zdWIodkEpO1xuXHRcdFx0XHR1dkIuc3ViKHV2QSk7XG5cdFx0XHRcdHV2Qy5zdWIodXZBKTtcblx0XHRcdFx0Y29uc3QgciA9IDEuMCAvICh1dkIueCAqIHV2Qy55IC0gdXZDLnggKiB1dkIueSk7IC8vIHNpbGVudGx5IGlnbm9yZSBkZWdlbmVyYXRlIHV2IHRyaWFuZ2xlcyBoYXZpbmcgY29pbmNpZGVudCBvciBjb2xpbmVhciB2ZXJ0aWNlc1xuXG5cdFx0XHRcdGlmICghaXNGaW5pdGUocikpIHJldHVybjtcblx0XHRcdFx0c2Rpci5jb3B5KHZCKS5tdWx0aXBseVNjYWxhcih1dkMueSkuYWRkU2NhbGVkVmVjdG9yKHZDLCAtdXZCLnkpLm11bHRpcGx5U2NhbGFyKHIpO1xuXHRcdFx0XHR0ZGlyLmNvcHkodkMpLm11bHRpcGx5U2NhbGFyKHV2Qi54KS5hZGRTY2FsZWRWZWN0b3IodkIsIC11dkMueCkubXVsdGlwbHlTY2FsYXIocik7XG5cdFx0XHRcdHRhbjFbYV0uYWRkKHNkaXIpO1xuXHRcdFx0XHR0YW4xW2JdLmFkZChzZGlyKTtcblx0XHRcdFx0dGFuMVtjXS5hZGQoc2Rpcik7XG5cdFx0XHRcdHRhbjJbYV0uYWRkKHRkaXIpO1xuXHRcdFx0XHR0YW4yW2JdLmFkZCh0ZGlyKTtcblx0XHRcdFx0dGFuMltjXS5hZGQodGRpcik7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBncm91cHMgPSB0aGlzLmdyb3VwcztcblxuXHRcdFx0aWYgKGdyb3Vwcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0Z3JvdXBzID0gW3tcblx0XHRcdFx0XHRzdGFydDogMCxcblx0XHRcdFx0XHRjb3VudDogaW5kaWNlcy5sZW5ndGhcblx0XHRcdFx0fV07XG5cdFx0XHR9XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG5cdFx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzW2ldO1xuXHRcdFx0XHRjb25zdCBzdGFydCA9IGdyb3VwLnN0YXJ0O1xuXHRcdFx0XHRjb25zdCBjb3VudCA9IGdyb3VwLmNvdW50O1xuXG5cdFx0XHRcdGZvciAobGV0IGogPSBzdGFydCwgamwgPSBzdGFydCArIGNvdW50OyBqIDwgamw7IGogKz0gMykge1xuXHRcdFx0XHRcdGhhbmRsZVRyaWFuZ2xlKGluZGljZXNbaiArIDBdLCBpbmRpY2VzW2ogKyAxXSwgaW5kaWNlc1tqICsgMl0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHRtcCA9IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHR0bXAyID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IG4gPSBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRcdFx0bjIgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRmdW5jdGlvbiBoYW5kbGVWZXJ0ZXgodikge1xuXHRcdFx0XHRuLmZyb21BcnJheShub3JtYWxzLCB2ICogMyk7XG5cdFx0XHRcdG4yLmNvcHkobik7XG5cdFx0XHRcdGNvbnN0IHQgPSB0YW4xW3ZdOyAvLyBHcmFtLVNjaG1pZHQgb3J0aG9nb25hbGl6ZVxuXG5cdFx0XHRcdHRtcC5jb3B5KHQpO1xuXHRcdFx0XHR0bXAuc3ViKG4ubXVsdGlwbHlTY2FsYXIobi5kb3QodCkpKS5ub3JtYWxpemUoKTsgLy8gQ2FsY3VsYXRlIGhhbmRlZG5lc3NcblxuXHRcdFx0XHR0bXAyLmNyb3NzVmVjdG9ycyhuMiwgdCk7XG5cdFx0XHRcdGNvbnN0IHRlc3QgPSB0bXAyLmRvdCh0YW4yW3ZdKTtcblx0XHRcdFx0Y29uc3QgdyA9IHRlc3QgPCAwLjAgPyAtMS4wIDogMS4wO1xuXHRcdFx0XHR0YW5nZW50c1t2ICogNF0gPSB0bXAueDtcblx0XHRcdFx0dGFuZ2VudHNbdiAqIDQgKyAxXSA9IHRtcC55O1xuXHRcdFx0XHR0YW5nZW50c1t2ICogNCArIDJdID0gdG1wLno7XG5cdFx0XHRcdHRhbmdlbnRzW3YgKiA0ICsgM10gPSB3O1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBncm91cHMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuXHRcdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1tpXTtcblx0XHRcdFx0Y29uc3Qgc3RhcnQgPSBncm91cC5zdGFydDtcblx0XHRcdFx0Y29uc3QgY291bnQgPSBncm91cC5jb3VudDtcblxuXHRcdFx0XHRmb3IgKGxldCBqID0gc3RhcnQsIGpsID0gc3RhcnQgKyBjb3VudDsgaiA8IGpsOyBqICs9IDMpIHtcblx0XHRcdFx0XHRoYW5kbGVWZXJ0ZXgoaW5kaWNlc1tqICsgMF0pO1xuXHRcdFx0XHRcdGhhbmRsZVZlcnRleChpbmRpY2VzW2ogKyAxXSk7XG5cdFx0XHRcdFx0aGFuZGxlVmVydGV4KGluZGljZXNbaiArIDJdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCkge1xuXHRcdFx0Y29uc3QgaW5kZXggPSB0aGlzLmluZGV4O1xuXHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSB0aGlzLmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKTtcblxuXHRcdFx0aWYgKHBvc2l0aW9uQXR0cmlidXRlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0bGV0IG5vcm1hbEF0dHJpYnV0ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdub3JtYWwnKTtcblxuXHRcdFx0XHRpZiAobm9ybWFsQXR0cmlidXRlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25BdHRyaWJ1dGUuY291bnQgKiAzKSwgMyk7XG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ25vcm1hbCcsIG5vcm1hbEF0dHJpYnV0ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gcmVzZXQgZXhpc3Rpbmcgbm9ybWFscyB0byB6ZXJvXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gbm9ybWFsQXR0cmlidXRlLmNvdW50OyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWihpLCAwLCAwLCAwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBwQSA9IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHRcdHBCID0gbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0XHRcdFx0cEMgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHRjb25zdCBuQSA9IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHRcdG5CID0gbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0XHRcdFx0bkMgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHRjb25zdCBjYiA9IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHRcdGFiID0gbmV3IFZlY3RvcjMoKTsgLy8gaW5kZXhlZCBlbGVtZW50c1xuXG5cdFx0XHRcdGlmIChpbmRleCkge1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGluZGV4LmNvdW50OyBpIDwgaWw7IGkgKz0gMykge1xuXHRcdFx0XHRcdFx0Y29uc3QgdkEgPSBpbmRleC5nZXRYKGkgKyAwKTtcblx0XHRcdFx0XHRcdGNvbnN0IHZCID0gaW5kZXguZ2V0WChpICsgMSk7XG5cdFx0XHRcdFx0XHRjb25zdCB2QyA9IGluZGV4LmdldFgoaSArIDIpO1xuXHRcdFx0XHRcdFx0cEEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbkF0dHJpYnV0ZSwgdkEpO1xuXHRcdFx0XHRcdFx0cEIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbkF0dHJpYnV0ZSwgdkIpO1xuXHRcdFx0XHRcdFx0cEMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbkF0dHJpYnV0ZSwgdkMpO1xuXHRcdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyhwQywgcEIpO1xuXHRcdFx0XHRcdFx0YWIuc3ViVmVjdG9ycyhwQSwgcEIpO1xuXHRcdFx0XHRcdFx0Y2IuY3Jvc3MoYWIpO1xuXHRcdFx0XHRcdFx0bkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShub3JtYWxBdHRyaWJ1dGUsIHZBKTtcblx0XHRcdFx0XHRcdG5CLmZyb21CdWZmZXJBdHRyaWJ1dGUobm9ybWFsQXR0cmlidXRlLCB2Qik7XG5cdFx0XHRcdFx0XHRuQy5mcm9tQnVmZmVyQXR0cmlidXRlKG5vcm1hbEF0dHJpYnV0ZSwgdkMpO1xuXHRcdFx0XHRcdFx0bkEuYWRkKGNiKTtcblx0XHRcdFx0XHRcdG5CLmFkZChjYik7XG5cdFx0XHRcdFx0XHRuQy5hZGQoY2IpO1xuXHRcdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWih2QSwgbkEueCwgbkEueSwgbkEueik7XG5cdFx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKHZCLCBuQi54LCBuQi55LCBuQi56KTtcblx0XHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVoodkMsIG5DLngsIG5DLnksIG5DLnopO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBub24taW5kZXhlZCBlbGVtZW50cyAodW5jb25uZWN0ZWQgdHJpYW5nbGUgc291cClcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudDsgaSA8IGlsOyBpICs9IDMpIHtcblx0XHRcdFx0XHRcdHBBLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyaWJ1dGUsIGkgKyAwKTtcblx0XHRcdFx0XHRcdHBCLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyaWJ1dGUsIGkgKyAxKTtcblx0XHRcdFx0XHRcdHBDLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyaWJ1dGUsIGkgKyAyKTtcblx0XHRcdFx0XHRcdGNiLnN1YlZlY3RvcnMocEMsIHBCKTtcblx0XHRcdFx0XHRcdGFiLnN1YlZlY3RvcnMocEEsIHBCKTtcblx0XHRcdFx0XHRcdGNiLmNyb3NzKGFiKTtcblx0XHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVooaSArIDAsIGNiLngsIGNiLnksIGNiLnopO1xuXHRcdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWihpICsgMSwgY2IueCwgY2IueSwgY2Iueik7XG5cdFx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKGkgKyAyLCBjYi54LCBjYi55LCBjYi56KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLm5vcm1hbGl6ZU5vcm1hbHMoKTtcblx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRtZXJnZShnZW9tZXRyeSwgb2Zmc2V0KSB7XG5cdFx0XHRpZiAoIShnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5KSkge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5CdWZmZXJHZW9tZXRyeS5tZXJnZSgpOiBnZW9tZXRyeSBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkuJywgZ2VvbWV0cnkpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRvZmZzZXQgPSAwO1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5Lm1lcmdlKCk6IE92ZXJ3cml0aW5nIG9yaWdpbmFsIGdlb21ldHJ5LCBzdGFydGluZyBhdCBvZmZzZXQ9MC4gJyArICdVc2UgQnVmZmVyR2VvbWV0cnlVdGlscy5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmb3IgbG9zc2xlc3MgbWVyZ2UuJyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cblx0XHRcdGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0aWYgKGdlb21ldHJ5LmF0dHJpYnV0ZXNba2V5XSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlMSA9IGF0dHJpYnV0ZXNba2V5XTtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlQXJyYXkxID0gYXR0cmlidXRlMS5hcnJheTtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlMiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNba2V5XTtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlQXJyYXkyID0gYXR0cmlidXRlMi5hcnJheTtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlT2Zmc2V0ID0gYXR0cmlidXRlMi5pdGVtU2l6ZSAqIG9mZnNldDtcblx0XHRcdFx0Y29uc3QgbGVuZ3RoID0gTWF0aC5taW4oYXR0cmlidXRlQXJyYXkyLmxlbmd0aCwgYXR0cmlidXRlQXJyYXkxLmxlbmd0aCAtIGF0dHJpYnV0ZU9mZnNldCk7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGogPSBhdHRyaWJ1dGVPZmZzZXQ7IGkgPCBsZW5ndGg7IGkrKywgaisrKSB7XG5cdFx0XHRcdFx0YXR0cmlidXRlQXJyYXkxW2pdID0gYXR0cmlidXRlQXJyYXkyW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG5vcm1hbGl6ZU5vcm1hbHMoKSB7XG5cdFx0XHRjb25zdCBub3JtYWxzID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gbm9ybWFscy5jb3VudDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0X3ZlY3RvciQ4LmZyb21CdWZmZXJBdHRyaWJ1dGUobm9ybWFscywgaSk7XG5cblx0XHRcdFx0X3ZlY3RvciQ4Lm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdG5vcm1hbHMuc2V0WFlaKGksIF92ZWN0b3IkOC54LCBfdmVjdG9yJDgueSwgX3ZlY3RvciQ4LnopO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRvTm9uSW5kZXhlZCgpIHtcblx0XHRcdGZ1bmN0aW9uIGNvbnZlcnRCdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBpbmRpY2VzKSB7XG5cdFx0XHRcdGNvbnN0IGFycmF5ID0gYXR0cmlidXRlLmFycmF5O1xuXHRcdFx0XHRjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblx0XHRcdFx0Y29uc3Qgbm9ybWFsaXplZCA9IGF0dHJpYnV0ZS5ub3JtYWxpemVkO1xuXHRcdFx0XHRjb25zdCBhcnJheTIgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IoaW5kaWNlcy5sZW5ndGggKiBpdGVtU2l6ZSk7XG5cdFx0XHRcdGxldCBpbmRleCA9IDAsXG5cdFx0XHRcdFx0XHRpbmRleDIgPSAwO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUpIHtcblx0XHRcdFx0XHRcdGluZGV4ID0gaW5kaWNlc1tpXSAqIGF0dHJpYnV0ZS5kYXRhLnN0cmlkZSArIGF0dHJpYnV0ZS5vZmZzZXQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGluZGV4ID0gaW5kaWNlc1tpXSAqIGl0ZW1TaXplO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgaXRlbVNpemU7IGorKykge1xuXHRcdFx0XHRcdFx0YXJyYXkyW2luZGV4MisrXSA9IGFycmF5W2luZGV4KytdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBuZXcgQnVmZmVyQXR0cmlidXRlKGFycmF5MiwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuXHRcdFx0fSAvL1xuXG5cblx0XHRcdGlmICh0aGlzLmluZGV4ID09PSBudWxsKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQnVmZmVyR2VvbWV0cnkudG9Ob25JbmRleGVkKCk6IEJ1ZmZlckdlb21ldHJ5IGlzIGFscmVhZHkgbm9uLWluZGV4ZWQuJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBnZW9tZXRyeTIgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRcdGNvbnN0IGluZGljZXMgPSB0aGlzLmluZGV4LmFycmF5O1xuXHRcdFx0Y29uc3QgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlczsgLy8gYXR0cmlidXRlc1xuXG5cdFx0XHRmb3IgKGNvbnN0IG5hbWUgaW4gYXR0cmlidXRlcykge1xuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuXHRcdFx0XHRjb25zdCBuZXdBdHRyaWJ1dGUgPSBjb252ZXJ0QnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgaW5kaWNlcyk7XG5cdFx0XHRcdGdlb21ldHJ5Mi5zZXRBdHRyaWJ1dGUobmFtZSwgbmV3QXR0cmlidXRlKTtcblx0XHRcdH0gLy8gbW9ycGggYXR0cmlidXRlc1xuXG5cblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IHRoaXMubW9ycGhBdHRyaWJ1dGVzO1xuXG5cdFx0XHRmb3IgKGNvbnN0IG5hbWUgaW4gbW9ycGhBdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdGNvbnN0IG1vcnBoQXJyYXkgPSBbXTtcblx0XHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNbbmFtZV07IC8vIG1vcnBoQXR0cmlidXRlOiBhcnJheSBvZiBGbG9hdDMyQnVmZmVyQXR0cmlidXRlc1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZVtpXTtcblx0XHRcdFx0XHRjb25zdCBuZXdBdHRyaWJ1dGUgPSBjb252ZXJ0QnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgaW5kaWNlcyk7XG5cdFx0XHRcdFx0bW9ycGhBcnJheS5wdXNoKG5ld0F0dHJpYnV0ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnZW9tZXRyeTIubW9ycGhBdHRyaWJ1dGVzW25hbWVdID0gbW9ycGhBcnJheTtcblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkyLm1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gdGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZTsgLy8gZ3JvdXBzXG5cblx0XHRcdGNvbnN0IGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbaV07XG5cdFx0XHRcdGdlb21ldHJ5Mi5hZGRHcm91cChncm91cC5zdGFydCwgZ3JvdXAuY291bnQsIGdyb3VwLm1hdGVyaWFsSW5kZXgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZ2VvbWV0cnkyO1xuXHRcdH1cblxuXHRcdHRvSlNPTigpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdFx0dmVyc2lvbjogNC41LFxuXHRcdFx0XHRcdHR5cGU6ICdCdWZmZXJHZW9tZXRyeScsXG5cdFx0XHRcdFx0Z2VuZXJhdG9yOiAnQnVmZmVyR2VvbWV0cnkudG9KU09OJ1xuXHRcdFx0XHR9XG5cdFx0XHR9OyAvLyBzdGFuZGFyZCBCdWZmZXJHZW9tZXRyeSBzZXJpYWxpemF0aW9uXG5cblx0XHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcblx0XHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcblx0XHRcdGlmICh0aGlzLm5hbWUgIT09ICcnKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XG5cdFx0XHRpZiAoT2JqZWN0LmtleXModGhpcy51c2VyRGF0YSkubGVuZ3RoID4gMCkgZGF0YS51c2VyRGF0YSA9IHRoaXMudXNlckRhdGE7XG5cblx0XHRcdGlmICh0aGlzLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb25zdCBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xuXG5cdFx0XHRcdGZvciAoY29uc3Qga2V5IGluIHBhcmFtZXRlcnMpIHtcblx0XHRcdFx0XHRpZiAocGFyYW1ldGVyc1trZXldICE9PSB1bmRlZmluZWQpIGRhdGFba2V5XSA9IHBhcmFtZXRlcnNba2V5XTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0fSAvLyBmb3Igc2ltcGxpY2l0eSB0aGUgY29kZSBhc3N1bWVzIGF0dHJpYnV0ZXMgYXJlIG5vdCBzaGFyZWQgYWNyb3NzIGdlb21ldHJpZXMsIHNlZSAjMTU4MTFcblxuXG5cdFx0XHRkYXRhLmRhdGEgPSB7XG5cdFx0XHRcdGF0dHJpYnV0ZXM6IHt9XG5cdFx0XHR9O1xuXHRcdFx0Y29uc3QgaW5kZXggPSB0aGlzLmluZGV4O1xuXG5cdFx0XHRpZiAoaW5kZXggIT09IG51bGwpIHtcblx0XHRcdFx0ZGF0YS5kYXRhLmluZGV4ID0ge1xuXHRcdFx0XHRcdHR5cGU6IGluZGV4LmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXG5cdFx0XHRcdFx0YXJyYXk6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGluZGV4LmFycmF5KVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNba2V5XTtcblx0XHRcdFx0ZGF0YS5kYXRhLmF0dHJpYnV0ZXNba2V5XSA9IGF0dHJpYnV0ZS50b0pTT04oZGF0YS5kYXRhKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzID0ge307XG5cdFx0XHRsZXQgaGFzTW9ycGhBdHRyaWJ1dGVzID0gZmFsc2U7XG5cblx0XHRcdGZvciAoY29uc3Qga2V5IGluIHRoaXMubW9ycGhBdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZUFycmF5ID0gdGhpcy5tb3JwaEF0dHJpYnV0ZXNba2V5XTtcblx0XHRcdFx0Y29uc3QgYXJyYXkgPSBbXTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBhdHRyaWJ1dGVBcnJheS5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlQXJyYXlbaV07XG5cdFx0XHRcdFx0YXJyYXkucHVzaChhdHRyaWJ1dGUudG9KU09OKGRhdGEuZGF0YSkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGFycmF5Lmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRtb3JwaEF0dHJpYnV0ZXNba2V5XSA9IGFycmF5O1xuXHRcdFx0XHRcdGhhc01vcnBoQXR0cmlidXRlcyA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGhhc01vcnBoQXR0cmlidXRlcykge1xuXHRcdFx0XHRkYXRhLmRhdGEubW9ycGhBdHRyaWJ1dGVzID0gbW9ycGhBdHRyaWJ1dGVzO1xuXHRcdFx0XHRkYXRhLmRhdGEubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBncm91cHMgPSB0aGlzLmdyb3VwcztcblxuXHRcdFx0aWYgKGdyb3Vwcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGRhdGEuZGF0YS5ncm91cHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGdyb3VwcykpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBib3VuZGluZ1NwaGVyZSA9IHRoaXMuYm91bmRpbmdTcGhlcmU7XG5cblx0XHRcdGlmIChib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRkYXRhLmRhdGEuYm91bmRpbmdTcGhlcmUgPSB7XG5cdFx0XHRcdFx0Y2VudGVyOiBib3VuZGluZ1NwaGVyZS5jZW50ZXIudG9BcnJheSgpLFxuXHRcdFx0XHRcdHJhZGl1czogYm91bmRpbmdTcGhlcmUucmFkaXVzXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdGNsb25lKCkge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0Ly8gcmVzZXRcblx0XHRcdHRoaXMuaW5kZXggPSBudWxsO1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzID0ge307XG5cdFx0XHR0aGlzLm1vcnBoQXR0cmlidXRlcyA9IHt9O1xuXHRcdFx0dGhpcy5ncm91cHMgPSBbXTtcblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7IC8vIHVzZWQgZm9yIHN0b3JpbmcgY2xvbmVkLCBzaGFyZWQgZGF0YVxuXG5cdFx0XHRjb25zdCBkYXRhID0ge307IC8vIG5hbWVcblxuXHRcdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7IC8vIGluZGV4XG5cblx0XHRcdGNvbnN0IGluZGV4ID0gc291cmNlLmluZGV4O1xuXG5cdFx0XHRpZiAoaW5kZXggIT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5zZXRJbmRleChpbmRleC5jbG9uZShkYXRhKSk7XG5cdFx0XHR9IC8vIGF0dHJpYnV0ZXNcblxuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGVzID0gc291cmNlLmF0dHJpYnV0ZXM7XG5cblx0XHRcdGZvciAoY29uc3QgbmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG5cdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJpYnV0ZS5jbG9uZShkYXRhKSk7XG5cdFx0XHR9IC8vIG1vcnBoIGF0dHJpYnV0ZXNcblxuXG5cdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSBzb3VyY2UubW9ycGhBdHRyaWJ1dGVzO1xuXG5cdFx0XHRmb3IgKGNvbnN0IG5hbWUgaW4gbW9ycGhBdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdGNvbnN0IGFycmF5ID0gW107XG5cdFx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzW25hbWVdOyAvLyBtb3JwaEF0dHJpYnV0ZTogYXJyYXkgb2YgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZXNcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGFycmF5LnB1c2gobW9ycGhBdHRyaWJ1dGVbaV0uY2xvbmUoZGF0YSkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5tb3JwaEF0dHJpYnV0ZXNbbmFtZV0gPSBhcnJheTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHNvdXJjZS5tb3JwaFRhcmdldHNSZWxhdGl2ZTsgLy8gZ3JvdXBzXG5cblx0XHRcdGNvbnN0IGdyb3VwcyA9IHNvdXJjZS5ncm91cHM7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1tpXTtcblx0XHRcdFx0dGhpcy5hZGRHcm91cChncm91cC5zdGFydCwgZ3JvdXAuY291bnQsIGdyb3VwLm1hdGVyaWFsSW5kZXgpO1xuXHRcdFx0fSAvLyBib3VuZGluZyBib3hcblxuXG5cdFx0XHRjb25zdCBib3VuZGluZ0JveCA9IHNvdXJjZS5ib3VuZGluZ0JveDtcblxuXHRcdFx0aWYgKGJvdW5kaW5nQm94ICE9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBib3VuZGluZ0JveC5jbG9uZSgpO1xuXHRcdFx0fSAvLyBib3VuZGluZyBzcGhlcmVcblxuXG5cdFx0XHRjb25zdCBib3VuZGluZ1NwaGVyZSA9IHNvdXJjZS5ib3VuZGluZ1NwaGVyZTtcblxuXHRcdFx0aWYgKGJvdW5kaW5nU3BoZXJlICE9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xuXHRcdFx0fSAvLyBkcmF3IHJhbmdlXG5cblxuXHRcdFx0dGhpcy5kcmF3UmFuZ2Uuc3RhcnQgPSBzb3VyY2UuZHJhd1JhbmdlLnN0YXJ0O1xuXHRcdFx0dGhpcy5kcmF3UmFuZ2UuY291bnQgPSBzb3VyY2UuZHJhd1JhbmdlLmNvdW50OyAvLyB1c2VyIGRhdGFcblxuXHRcdFx0dGhpcy51c2VyRGF0YSA9IHNvdXJjZS51c2VyRGF0YTsgLy8gZ2VvbWV0cnkgZ2VuZXJhdG9yIHBhcmFtZXRlcnNcblxuXHRcdFx0aWYgKHNvdXJjZS5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQpIHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZS5wYXJhbWV0ZXJzKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGRpc3Bvc2UoKSB7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoe1xuXHRcdFx0XHR0eXBlOiAnZGlzcG9zZSdcblx0XHRcdH0pO1xuXHRcdH1cblxuXHR9XG5cblx0QnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmlzQnVmZmVyR2VvbWV0cnkgPSB0cnVlO1xuXG5cdGNvbnN0IF9pbnZlcnNlTWF0cml4JDIgPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDQoKTtcblxuXHRjb25zdCBfcmF5JDIgPSAvKkBfX1BVUkVfXyovbmV3IFJheSgpO1xuXG5cdGNvbnN0IF9zcGhlcmUkMyA9IC8qQF9fUFVSRV9fKi9uZXcgU3BoZXJlKCk7XG5cblx0Y29uc3QgX3ZBJDEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfdkIkMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF92QyQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3RlbXBBID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3RlbXBCID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3RlbXBDID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX21vcnBoQSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9tb3JwaEIgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfbW9ycGhDID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3V2QSQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IyKCk7XG5cblx0Y29uc3QgX3V2QiQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IyKCk7XG5cblx0Y29uc3QgX3V2QyQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IyKCk7XG5cblx0Y29uc3QgX2ludGVyc2VjdGlvblBvaW50ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX2ludGVyc2VjdGlvblBvaW50V29ybGQgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjbGFzcyBNZXNoIGV4dGVuZHMgT2JqZWN0M0Qge1xuXHRcdGNvbnN0cnVjdG9yKGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCksIG1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCkpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnTWVzaCc7XG5cdFx0XHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG5cdFx0XHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cdFx0XHR0aGlzLnVwZGF0ZU1vcnBoVGFyZ2V0cygpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cblx0XHRcdGlmIChzb3VyY2UubW9ycGhUYXJnZXRJbmZsdWVuY2VzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBzb3VyY2UubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnNsaWNlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzb3VyY2UubW9ycGhUYXJnZXREaWN0aW9uYXJ5ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2UubW9ycGhUYXJnZXREaWN0aW9uYXJ5KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tYXRlcmlhbCA9IHNvdXJjZS5tYXRlcmlhbDtcblx0XHRcdHRoaXMuZ2VvbWV0cnkgPSBzb3VyY2UuZ2VvbWV0cnk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR1cGRhdGVNb3JwaFRhcmdldHMoKSB7XG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cblx0XHRcdGlmIChnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5KSB7XG5cdFx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcblx0XHRcdFx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG1vcnBoQXR0cmlidXRlcyk7XG5cblx0XHRcdFx0aWYgKGtleXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzW2tleXNbMF1dO1xuXG5cdFx0XHRcdFx0aWYgKG1vcnBoQXR0cmlidXRlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XG5cdFx0XHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xuXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBtID0gMCwgbWwgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IG0gPCBtbDsgbSsrKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG5hbWUgPSBtb3JwaEF0dHJpYnV0ZVttXS5uYW1lIHx8IFN0cmluZyhtKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCgwKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbbmFtZV0gPSBtO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xuXG5cdFx0XHRcdGlmIChtb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCAmJiBtb3JwaFRhcmdldHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLk1lc2gudXBkYXRlTW9ycGhUYXJnZXRzKCkgbm8gbG9uZ2VyIHN1cHBvcnRzIFRIUkVFLkdlb21ldHJ5LiBVc2UgVEhSRUUuQnVmZmVyR2VvbWV0cnkgaW5zdGVhZC4nKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJheWNhc3QocmF5Y2FzdGVyLCBpbnRlcnNlY3RzKSB7XG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0XHRjb25zdCBtYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XG5cdFx0XHRjb25zdCBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XG5cdFx0XHRpZiAobWF0ZXJpYWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcblxuXHRcdFx0aWYgKGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdFx0X3NwaGVyZSQzLmNvcHkoZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUpO1xuXG5cdFx0XHRfc3BoZXJlJDMuYXBwbHlNYXRyaXg0KG1hdHJpeFdvcmxkKTtcblxuXHRcdFx0aWYgKHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0c1NwaGVyZShfc3BoZXJlJDMpID09PSBmYWxzZSkgcmV0dXJuOyAvL1xuXG5cdFx0XHRfaW52ZXJzZU1hdHJpeCQyLmNvcHkobWF0cml4V29ybGQpLmludmVydCgpO1xuXG5cdFx0XHRfcmF5JDIuY29weShyYXljYXN0ZXIucmF5KS5hcHBseU1hdHJpeDQoX2ludmVyc2VNYXRyaXgkMik7IC8vIENoZWNrIGJvdW5kaW5nQm94IGJlZm9yZSBjb250aW51aW5nXG5cblxuXHRcdFx0aWYgKGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsKSB7XG5cdFx0XHRcdGlmIChfcmF5JDIuaW50ZXJzZWN0c0JveChnZW9tZXRyeS5ib3VuZGluZ0JveCkgPT09IGZhbHNlKSByZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGxldCBpbnRlcnNlY3Rpb247XG5cblx0XHRcdGlmIChnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5KSB7XG5cdFx0XHRcdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdFx0Y29uc3QgbW9ycGhQb3NpdGlvbiA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdFx0Y29uc3QgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcblx0XHRcdFx0Y29uc3QgdXYgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnV2O1xuXHRcdFx0XHRjb25zdCB1djIgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnV2Mjtcblx0XHRcdFx0Y29uc3QgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXHRcdFx0XHRjb25zdCBkcmF3UmFuZ2UgPSBnZW9tZXRyeS5kcmF3UmFuZ2U7XG5cblx0XHRcdFx0aWYgKGluZGV4ICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0Ly8gaW5kZXhlZCBidWZmZXIgZ2VvbWV0cnlcblx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShtYXRlcmlhbCkpIHtcblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzW2ldO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbZ3JvdXAubWF0ZXJpYWxJbmRleF07XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoZ3JvdXAuc3RhcnQsIGRyYXdSYW5nZS5zdGFydCk7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKGluZGV4LmNvdW50LCBNYXRoLm1pbihncm91cC5zdGFydCArIGdyb3VwLmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpKTtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKGxldCBqID0gc3RhcnQsIGpsID0gZW5kOyBqIDwgamw7IGogKz0gMykge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGEgPSBpbmRleC5nZXRYKGopO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGIgPSBpbmRleC5nZXRYKGogKyAxKTtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBjID0gaW5kZXguZ2V0WChqICsgMik7XG5cdFx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uID0gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbih0aGlzLCBncm91cE1hdGVyaWFsLCByYXljYXN0ZXIsIF9yYXkkMiwgcG9zaXRpb24sIG1vcnBoUG9zaXRpb24sIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLCB1diwgdXYyLCBhLCBiLCBjKTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChpbnRlcnNlY3Rpb24pIHtcblx0XHRcdFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBNYXRoLmZsb29yKGogLyAzKTsgLy8gdHJpYW5nbGUgbnVtYmVyIGluIGluZGV4ZWQgYnVmZmVyIHNlbWFudGljc1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZS5tYXRlcmlhbEluZGV4ID0gZ3JvdXAubWF0ZXJpYWxJbmRleDtcblx0XHRcdFx0XHRcdFx0XHRcdGludGVyc2VjdHMucHVzaChpbnRlcnNlY3Rpb24pO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zdCBzdGFydCA9IE1hdGgubWF4KDAsIGRyYXdSYW5nZS5zdGFydCk7XG5cdFx0XHRcdFx0XHRjb25zdCBlbmQgPSBNYXRoLm1pbihpbmRleC5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcblxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IHN0YXJ0LCBpbCA9IGVuZDsgaSA8IGlsOyBpICs9IDMpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgYSA9IGluZGV4LmdldFgoaSk7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGIgPSBpbmRleC5nZXRYKGkgKyAxKTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgYyA9IGluZGV4LmdldFgoaSArIDIpO1xuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKHRoaXMsIG1hdGVyaWFsLCByYXljYXN0ZXIsIF9yYXkkMiwgcG9zaXRpb24sIG1vcnBoUG9zaXRpb24sIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLCB1diwgdXYyLCBhLCBiLCBjKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoaW50ZXJzZWN0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IE1hdGguZmxvb3IoaSAvIDMpOyAvLyB0cmlhbmdsZSBudW1iZXIgaW4gaW5kZXhlZCBidWZmZXIgc2VtYW50aWNzXG5cblx0XHRcdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goaW50ZXJzZWN0aW9uKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChwb3NpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Ly8gbm9uLWluZGV4ZWQgYnVmZmVyIGdlb21ldHJ5XG5cdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkobWF0ZXJpYWwpKSB7XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBncm91cHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1tpXTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsW2dyb3VwLm1hdGVyaWFsSW5kZXhdO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBzdGFydCA9IE1hdGgubWF4KGdyb3VwLnN0YXJ0LCBkcmF3UmFuZ2Uuc3RhcnQpO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBlbmQgPSBNYXRoLm1pbihwb3NpdGlvbi5jb3VudCwgTWF0aC5taW4oZ3JvdXAuc3RhcnQgKyBncm91cC5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KSk7XG5cblx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgaiA9IHN0YXJ0LCBqbCA9IGVuZDsgaiA8IGpsOyBqICs9IDMpIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBhID0gajtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBiID0gaiArIDE7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgYyA9IGogKyAyO1xuXHRcdFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24odGhpcywgZ3JvdXBNYXRlcmlhbCwgcmF5Y2FzdGVyLCBfcmF5JDIsIHBvc2l0aW9uLCBtb3JwaFBvc2l0aW9uLCBtb3JwaFRhcmdldHNSZWxhdGl2ZSwgdXYsIHV2MiwgYSwgYiwgYyk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoaW50ZXJzZWN0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gTWF0aC5mbG9vcihqIC8gMyk7IC8vIHRyaWFuZ2xlIG51bWJlciBpbiBub24taW5kZXhlZCBidWZmZXIgc2VtYW50aWNzXG5cblx0XHRcdFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi5mYWNlLm1hdGVyaWFsSW5kZXggPSBncm91cC5tYXRlcmlhbEluZGV4O1xuXHRcdFx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKGludGVyc2VjdGlvbik7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgZHJhd1JhbmdlLnN0YXJ0KTtcblx0XHRcdFx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKHBvc2l0aW9uLmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gc3RhcnQsIGlsID0gZW5kOyBpIDwgaWw7IGkgKz0gMykge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBhID0gaTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgYiA9IGkgKyAxO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBjID0gaSArIDI7XG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24odGhpcywgbWF0ZXJpYWwsIHJheWNhc3RlciwgX3JheSQyLCBwb3NpdGlvbiwgbW9ycGhQb3NpdGlvbiwgbW9ycGhUYXJnZXRzUmVsYXRpdmUsIHV2LCB1djIsIGEsIGIsIGMpO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChpbnRlcnNlY3Rpb24pIHtcblx0XHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gTWF0aC5mbG9vcihpIC8gMyk7IC8vIHRyaWFuZ2xlIG51bWJlciBpbiBub24taW5kZXhlZCBidWZmZXIgc2VtYW50aWNzXG5cblx0XHRcdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goaW50ZXJzZWN0aW9uKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChnZW9tZXRyeS5pc0dlb21ldHJ5KSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLk1lc2gucmF5Y2FzdCgpIG5vIGxvbmdlciBzdXBwb3J0cyBUSFJFRS5HZW9tZXRyeS4gVXNlIFRIUkVFLkJ1ZmZlckdlb21ldHJ5IGluc3RlYWQuJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH1cblxuXHRNZXNoLnByb3RvdHlwZS5pc01lc2ggPSB0cnVlO1xuXG5cdGZ1bmN0aW9uIGNoZWNrSW50ZXJzZWN0aW9uKG9iamVjdCwgbWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5LCBwQSwgcEIsIHBDLCBwb2ludCkge1xuXHRcdGxldCBpbnRlcnNlY3Q7XG5cblx0XHRpZiAobWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUpIHtcblx0XHRcdGludGVyc2VjdCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZShwQywgcEIsIHBBLCB0cnVlLCBwb2ludCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGludGVyc2VjdCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZShwQSwgcEIsIHBDLCBtYXRlcmlhbC5zaWRlICE9PSBEb3VibGVTaWRlLCBwb2ludCk7XG5cdFx0fVxuXG5cdFx0aWYgKGludGVyc2VjdCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cblx0XHRfaW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5jb3B5KHBvaW50KTtcblxuXHRcdF9pbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmFwcGx5TWF0cml4NChvYmplY3QubWF0cml4V29ybGQpO1xuXG5cdFx0Y29uc3QgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKF9pbnRlcnNlY3Rpb25Qb2ludFdvcmxkKTtcblx0XHRpZiAoZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIpIHJldHVybiBudWxsO1xuXHRcdHJldHVybiB7XG5cdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG5cdFx0XHRwb2ludDogX2ludGVyc2VjdGlvblBvaW50V29ybGQuY2xvbmUoKSxcblx0XHRcdG9iamVjdDogb2JqZWN0XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24ob2JqZWN0LCBtYXRlcmlhbCwgcmF5Y2FzdGVyLCByYXksIHBvc2l0aW9uLCBtb3JwaFBvc2l0aW9uLCBtb3JwaFRhcmdldHNSZWxhdGl2ZSwgdXYsIHV2MiwgYSwgYiwgYykge1xuXHRcdF92QSQxLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb24sIGEpO1xuXG5cdFx0X3ZCJDEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbiwgYik7XG5cblx0XHRfdkMkMS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uLCBjKTtcblxuXHRcdGNvbnN0IG1vcnBoSW5mbHVlbmNlcyA9IG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cblx0XHRpZiAobW9ycGhQb3NpdGlvbiAmJiBtb3JwaEluZmx1ZW5jZXMpIHtcblx0XHRcdF9tb3JwaEEuc2V0KDAsIDAsIDApO1xuXG5cdFx0XHRfbW9ycGhCLnNldCgwLCAwLCAwKTtcblxuXHRcdFx0X21vcnBoQy5zZXQoMCwgMCwgMCk7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IG1vcnBoUG9zaXRpb24ubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBpbmZsdWVuY2UgPSBtb3JwaEluZmx1ZW5jZXNbaV07XG5cdFx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhQb3NpdGlvbltpXTtcblx0XHRcdFx0aWYgKGluZmx1ZW5jZSA9PT0gMCkgY29udGludWU7XG5cblx0XHRcdFx0X3RlbXBBLmZyb21CdWZmZXJBdHRyaWJ1dGUobW9ycGhBdHRyaWJ1dGUsIGEpO1xuXG5cdFx0XHRcdF90ZW1wQi5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoQXR0cmlidXRlLCBiKTtcblxuXHRcdFx0XHRfdGVtcEMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaEF0dHJpYnV0ZSwgYyk7XG5cblx0XHRcdFx0aWYgKG1vcnBoVGFyZ2V0c1JlbGF0aXZlKSB7XG5cdFx0XHRcdFx0X21vcnBoQS5hZGRTY2FsZWRWZWN0b3IoX3RlbXBBLCBpbmZsdWVuY2UpO1xuXG5cdFx0XHRcdFx0X21vcnBoQi5hZGRTY2FsZWRWZWN0b3IoX3RlbXBCLCBpbmZsdWVuY2UpO1xuXG5cdFx0XHRcdFx0X21vcnBoQy5hZGRTY2FsZWRWZWN0b3IoX3RlbXBDLCBpbmZsdWVuY2UpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9tb3JwaEEuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQS5zdWIoX3ZBJDEpLCBpbmZsdWVuY2UpO1xuXG5cdFx0XHRcdFx0X21vcnBoQi5hZGRTY2FsZWRWZWN0b3IoX3RlbXBCLnN1YihfdkIkMSksIGluZmx1ZW5jZSk7XG5cblx0XHRcdFx0XHRfbW9ycGhDLmFkZFNjYWxlZFZlY3RvcihfdGVtcEMuc3ViKF92QyQxKSwgaW5mbHVlbmNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRfdkEkMS5hZGQoX21vcnBoQSk7XG5cblx0XHRcdF92QiQxLmFkZChfbW9ycGhCKTtcblxuXHRcdFx0X3ZDJDEuYWRkKF9tb3JwaEMpO1xuXHRcdH1cblxuXHRcdGlmIChvYmplY3QuaXNTa2lubmVkTWVzaCkge1xuXHRcdFx0b2JqZWN0LmJvbmVUcmFuc2Zvcm0oYSwgX3ZBJDEpO1xuXHRcdFx0b2JqZWN0LmJvbmVUcmFuc2Zvcm0oYiwgX3ZCJDEpO1xuXHRcdFx0b2JqZWN0LmJvbmVUcmFuc2Zvcm0oYywgX3ZDJDEpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGludGVyc2VjdGlvbiA9IGNoZWNrSW50ZXJzZWN0aW9uKG9iamVjdCwgbWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5LCBfdkEkMSwgX3ZCJDEsIF92QyQxLCBfaW50ZXJzZWN0aW9uUG9pbnQpO1xuXG5cdFx0aWYgKGludGVyc2VjdGlvbikge1xuXHRcdFx0aWYgKHV2KSB7XG5cdFx0XHRcdF91dkEkMS5mcm9tQnVmZmVyQXR0cmlidXRlKHV2LCBhKTtcblxuXHRcdFx0XHRfdXZCJDEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh1diwgYik7XG5cblx0XHRcdFx0X3V2QyQxLmZyb21CdWZmZXJBdHRyaWJ1dGUodXYsIGMpO1xuXG5cdFx0XHRcdGludGVyc2VjdGlvbi51diA9IFRyaWFuZ2xlLmdldFVWKF9pbnRlcnNlY3Rpb25Qb2ludCwgX3ZBJDEsIF92QiQxLCBfdkMkMSwgX3V2QSQxLCBfdXZCJDEsIF91dkMkMSwgbmV3IFZlY3RvcjIoKSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh1djIpIHtcblx0XHRcdFx0X3V2QSQxLmZyb21CdWZmZXJBdHRyaWJ1dGUodXYyLCBhKTtcblxuXHRcdFx0XHRfdXZCJDEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh1djIsIGIpO1xuXG5cdFx0XHRcdF91dkMkMS5mcm9tQnVmZmVyQXR0cmlidXRlKHV2MiwgYyk7XG5cblx0XHRcdFx0aW50ZXJzZWN0aW9uLnV2MiA9IFRyaWFuZ2xlLmdldFVWKF9pbnRlcnNlY3Rpb25Qb2ludCwgX3ZBJDEsIF92QiQxLCBfdkMkMSwgX3V2QSQxLCBfdXZCJDEsIF91dkMkMSwgbmV3IFZlY3RvcjIoKSk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGZhY2UgPSB7XG5cdFx0XHRcdGE6IGEsXG5cdFx0XHRcdGI6IGIsXG5cdFx0XHRcdGM6IGMsXG5cdFx0XHRcdG5vcm1hbDogbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0bWF0ZXJpYWxJbmRleDogMFxuXHRcdFx0fTtcblx0XHRcdFRyaWFuZ2xlLmdldE5vcm1hbChfdkEkMSwgX3ZCJDEsIF92QyQxLCBmYWNlLm5vcm1hbCk7XG5cdFx0XHRpbnRlcnNlY3Rpb24uZmFjZSA9IGZhY2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGludGVyc2VjdGlvbjtcblx0fVxuXG5cdGNsYXNzIEJveEdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXHRcdGNvbnN0cnVjdG9yKHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgZGVwdGggPSAxLCB3aWR0aFNlZ21lbnRzID0gMSwgaGVpZ2h0U2VnbWVudHMgPSAxLCBkZXB0aFNlZ21lbnRzID0gMSkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdCb3hHZW9tZXRyeSc7XG5cdFx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0XHRcdGRlcHRoOiBkZXB0aCxcblx0XHRcdFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcblx0XHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuXHRcdFx0XHRkZXB0aFNlZ21lbnRzOiBkZXB0aFNlZ21lbnRzXG5cdFx0XHR9O1xuXHRcdFx0Y29uc3Qgc2NvcGUgPSB0aGlzOyAvLyBzZWdtZW50c1xuXG5cdFx0XHR3aWR0aFNlZ21lbnRzID0gTWF0aC5mbG9vcih3aWR0aFNlZ21lbnRzKTtcblx0XHRcdGhlaWdodFNlZ21lbnRzID0gTWF0aC5mbG9vcihoZWlnaHRTZWdtZW50cyk7XG5cdFx0XHRkZXB0aFNlZ21lbnRzID0gTWF0aC5mbG9vcihkZXB0aFNlZ21lbnRzKTsgLy8gYnVmZmVyc1xuXG5cdFx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdFx0Y29uc3QgdXZzID0gW107IC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdFx0bGV0IG51bWJlck9mVmVydGljZXMgPSAwO1xuXHRcdFx0bGV0IGdyb3VwU3RhcnQgPSAwOyAvLyBidWlsZCBlYWNoIHNpZGUgb2YgdGhlIGJveCBnZW9tZXRyeVxuXG5cdFx0XHRidWlsZFBsYW5lKCd6JywgJ3knLCAneCcsIC0xLCAtMSwgZGVwdGgsIGhlaWdodCwgd2lkdGgsIGRlcHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCAwKTsgLy8gcHhcblxuXHRcdFx0YnVpbGRQbGFuZSgneicsICd5JywgJ3gnLCAxLCAtMSwgZGVwdGgsIGhlaWdodCwgLXdpZHRoLCBkZXB0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgMSk7IC8vIG54XG5cblx0XHRcdGJ1aWxkUGxhbmUoJ3gnLCAneicsICd5JywgMSwgMSwgd2lkdGgsIGRlcHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGRlcHRoU2VnbWVudHMsIDIpOyAvLyBweVxuXG5cdFx0XHRidWlsZFBsYW5lKCd4JywgJ3onLCAneScsIDEsIC0xLCB3aWR0aCwgZGVwdGgsIC1oZWlnaHQsIHdpZHRoU2VnbWVudHMsIGRlcHRoU2VnbWVudHMsIDMpOyAvLyBueVxuXG5cdFx0XHRidWlsZFBsYW5lKCd4JywgJ3knLCAneicsIDEsIC0xLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIDQpOyAvLyBwelxuXG5cdFx0XHRidWlsZFBsYW5lKCd4JywgJ3knLCAneicsIC0xLCAtMSwgd2lkdGgsIGhlaWdodCwgLWRlcHRoLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgNSk7IC8vIG56XG5cdFx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0XHR0aGlzLnNldEluZGV4KGluZGljZXMpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShub3JtYWxzLCAzKSk7XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTtcblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGRQbGFuZSh1LCB2LCB3LCB1ZGlyLCB2ZGlyLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgZ3JpZFgsIGdyaWRZLCBtYXRlcmlhbEluZGV4KSB7XG5cdFx0XHRcdGNvbnN0IHNlZ21lbnRXaWR0aCA9IHdpZHRoIC8gZ3JpZFg7XG5cdFx0XHRcdGNvbnN0IHNlZ21lbnRIZWlnaHQgPSBoZWlnaHQgLyBncmlkWTtcblx0XHRcdFx0Y29uc3Qgd2lkdGhIYWxmID0gd2lkdGggLyAyO1xuXHRcdFx0XHRjb25zdCBoZWlnaHRIYWxmID0gaGVpZ2h0IC8gMjtcblx0XHRcdFx0Y29uc3QgZGVwdGhIYWxmID0gZGVwdGggLyAyO1xuXHRcdFx0XHRjb25zdCBncmlkWDEgPSBncmlkWCArIDE7XG5cdFx0XHRcdGNvbnN0IGdyaWRZMSA9IGdyaWRZICsgMTtcblx0XHRcdFx0bGV0IHZlcnRleENvdW50ZXIgPSAwO1xuXHRcdFx0XHRsZXQgZ3JvdXBDb3VudCA9IDA7XG5cdFx0XHRcdGNvbnN0IHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7IC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdFx0XHRmb3IgKGxldCBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgeSA9IGl5ICogc2VnbWVudEhlaWdodCAtIGhlaWdodEhhbGY7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpeCA9IDA7IGl4IDwgZ3JpZFgxOyBpeCsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB4ID0gaXggKiBzZWdtZW50V2lkdGggLSB3aWR0aEhhbGY7IC8vIHNldCB2YWx1ZXMgdG8gY29ycmVjdCB2ZWN0b3IgY29tcG9uZW50XG5cblx0XHRcdFx0XHRcdHZlY3Rvclt1XSA9IHggKiB1ZGlyO1xuXHRcdFx0XHRcdFx0dmVjdG9yW3ZdID0geSAqIHZkaXI7XG5cdFx0XHRcdFx0XHR2ZWN0b3Jbd10gPSBkZXB0aEhhbGY7IC8vIG5vdyBhcHBseSB2ZWN0b3IgdG8gdmVydGV4IGJ1ZmZlclxuXG5cdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnopOyAvLyBzZXQgdmFsdWVzIHRvIGNvcnJlY3QgdmVjdG9yIGNvbXBvbmVudFxuXG5cdFx0XHRcdFx0XHR2ZWN0b3JbdV0gPSAwO1xuXHRcdFx0XHRcdFx0dmVjdG9yW3ZdID0gMDtcblx0XHRcdFx0XHRcdHZlY3Rvclt3XSA9IGRlcHRoID4gMCA/IDEgOiAtMTsgLy8gbm93IGFwcGx5IHZlY3RvciB0byBub3JtYWwgYnVmZmVyXG5cblx0XHRcdFx0XHRcdG5vcm1hbHMucHVzaCh2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56KTsgLy8gdXZzXG5cblx0XHRcdFx0XHRcdHV2cy5wdXNoKGl4IC8gZ3JpZFgpO1xuXHRcdFx0XHRcdFx0dXZzLnB1c2goMSAtIGl5IC8gZ3JpZFkpOyAvLyBjb3VudGVyc1xuXG5cdFx0XHRcdFx0XHR2ZXJ0ZXhDb3VudGVyICs9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IC8vIGluZGljZXNcblx0XHRcdFx0Ly8gMS4geW91IG5lZWQgdGhyZWUgaW5kaWNlcyB0byBkcmF3IGEgc2luZ2xlIGZhY2Vcblx0XHRcdFx0Ly8gMi4gYSBzaW5nbGUgc2VnbWVudCBjb25zaXN0cyBvZiB0d28gZmFjZXNcblx0XHRcdFx0Ly8gMy4gc28gd2UgbmVlZCB0byBnZW5lcmF0ZSBzaXggKDIqMykgaW5kaWNlcyBwZXIgc2VnbWVudFxuXG5cblx0XHRcdFx0Zm9yIChsZXQgaXkgPSAwOyBpeSA8IGdyaWRZOyBpeSsrKSB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaXggPSAwOyBpeCA8IGdyaWRYOyBpeCsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBhID0gbnVtYmVyT2ZWZXJ0aWNlcyArIGl4ICsgZ3JpZFgxICogaXk7XG5cdFx0XHRcdFx0XHRjb25zdCBiID0gbnVtYmVyT2ZWZXJ0aWNlcyArIGl4ICsgZ3JpZFgxICogKGl5ICsgMSk7XG5cdFx0XHRcdFx0XHRjb25zdCBjID0gbnVtYmVyT2ZWZXJ0aWNlcyArIChpeCArIDEpICsgZ3JpZFgxICogKGl5ICsgMSk7XG5cdFx0XHRcdFx0XHRjb25zdCBkID0gbnVtYmVyT2ZWZXJ0aWNlcyArIChpeCArIDEpICsgZ3JpZFgxICogaXk7IC8vIGZhY2VzXG5cblx0XHRcdFx0XHRcdGluZGljZXMucHVzaChhLCBiLCBkKTtcblx0XHRcdFx0XHRcdGluZGljZXMucHVzaChiLCBjLCBkKTsgLy8gaW5jcmVhc2UgY291bnRlclxuXG5cdFx0XHRcdFx0XHRncm91cENvdW50ICs9IDY7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IC8vIGFkZCBhIGdyb3VwIHRvIHRoZSBnZW9tZXRyeS4gdGhpcyB3aWxsIGVuc3VyZSBtdWx0aSBtYXRlcmlhbCBzdXBwb3J0XG5cblxuXHRcdFx0XHRzY29wZS5hZGRHcm91cChncm91cFN0YXJ0LCBncm91cENvdW50LCBtYXRlcmlhbEluZGV4KTsgLy8gY2FsY3VsYXRlIG5ldyBzdGFydCB2YWx1ZSBmb3IgZ3JvdXBzXG5cblx0XHRcdFx0Z3JvdXBTdGFydCArPSBncm91cENvdW50OyAvLyB1cGRhdGUgdG90YWwgbnVtYmVyIG9mIHZlcnRpY2VzXG5cblx0XHRcdFx0bnVtYmVyT2ZWZXJ0aWNlcyArPSB2ZXJ0ZXhDb3VudGVyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHN0YXRpYyBmcm9tSlNPTihkYXRhKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEJveEdlb21ldHJ5KGRhdGEud2lkdGgsIGRhdGEuaGVpZ2h0LCBkYXRhLmRlcHRoLCBkYXRhLndpZHRoU2VnbWVudHMsIGRhdGEuaGVpZ2h0U2VnbWVudHMsIGRhdGEuZGVwdGhTZWdtZW50cyk7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogVW5pZm9ybSBVdGlsaXRpZXNcblx0ICovXG5cdGZ1bmN0aW9uIGNsb25lVW5pZm9ybXMoc3JjKSB7XG5cdFx0Y29uc3QgZHN0ID0ge307XG5cblx0XHRmb3IgKGNvbnN0IHUgaW4gc3JjKSB7XG5cdFx0XHRkc3RbdV0gPSB7fTtcblxuXHRcdFx0Zm9yIChjb25zdCBwIGluIHNyY1t1XSkge1xuXHRcdFx0XHRjb25zdCBwcm9wZXJ0eSA9IHNyY1t1XVtwXTtcblxuXHRcdFx0XHRpZiAocHJvcGVydHkgJiYgKHByb3BlcnR5LmlzQ29sb3IgfHwgcHJvcGVydHkuaXNNYXRyaXgzIHx8IHByb3BlcnR5LmlzTWF0cml4NCB8fCBwcm9wZXJ0eS5pc1ZlY3RvcjIgfHwgcHJvcGVydHkuaXNWZWN0b3IzIHx8IHByb3BlcnR5LmlzVmVjdG9yNCB8fCBwcm9wZXJ0eS5pc1RleHR1cmUgfHwgcHJvcGVydHkuaXNRdWF0ZXJuaW9uKSkge1xuXHRcdFx0XHRcdGRzdFt1XVtwXSA9IHByb3BlcnR5LmNsb25lKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwcm9wZXJ0eSkpIHtcblx0XHRcdFx0XHRkc3RbdV1bcF0gPSBwcm9wZXJ0eS5zbGljZSgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRzdFt1XVtwXSA9IHByb3BlcnR5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRzdDtcblx0fVxuXHRmdW5jdGlvbiBtZXJnZVVuaWZvcm1zKHVuaWZvcm1zKSB7XG5cdFx0Y29uc3QgbWVyZ2VkID0ge307XG5cblx0XHRmb3IgKGxldCB1ID0gMDsgdSA8IHVuaWZvcm1zLmxlbmd0aDsgdSsrKSB7XG5cdFx0XHRjb25zdCB0bXAgPSBjbG9uZVVuaWZvcm1zKHVuaWZvcm1zW3VdKTtcblxuXHRcdFx0Zm9yIChjb25zdCBwIGluIHRtcCkge1xuXHRcdFx0XHRtZXJnZWRbcF0gPSB0bXBbcF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lcmdlZDtcblx0fSAvLyBMZWdhY3lcblxuXHRjb25zdCBVbmlmb3Jtc1V0aWxzID0ge1xuXHRcdGNsb25lOiBjbG9uZVVuaWZvcm1zLFxuXHRcdG1lcmdlOiBtZXJnZVVuaWZvcm1zXG5cdH07XG5cblx0dmFyIGRlZmF1bHRfdmVydGV4ID0gXCJ2b2lkIG1haW4oKSB7XFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbn1cIjtcblxuXHR2YXIgZGVmYXVsdF9mcmFnbWVudCA9IFwidm9pZCBtYWluKCkge1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAwLjAsIDEuMCApO1xcbn1cIjtcblxuXHQvKipcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICpcdGRlZmluZXM6IHsgXCJsYWJlbFwiIDogXCJ2YWx1ZVwiIH0sXG5cdCAqXHR1bmlmb3JtczogeyBcInBhcmFtZXRlcjFcIjogeyB2YWx1ZTogMS4wIH0sIFwicGFyYW1ldGVyMlwiOiB7IHZhbHVlMjogMiB9IH0sXG5cdCAqXG5cdCAqXHRmcmFnbWVudFNoYWRlcjogPHN0cmluZz4sXG5cdCAqXHR2ZXJ0ZXhTaGFkZXI6IDxzdHJpbmc+LFxuXHQgKlxuXHQgKlx0d2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG5cdCAqXHR3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHRsaWdodHM6IDxib29sPlxuXHQgKiB9XG5cdCAqL1xuXG5cdGNsYXNzIFNoYWRlck1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXHRcdGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnU2hhZGVyTWF0ZXJpYWwnO1xuXHRcdFx0dGhpcy5kZWZpbmVzID0ge307XG5cdFx0XHR0aGlzLnVuaWZvcm1zID0ge307XG5cdFx0XHR0aGlzLnZlcnRleFNoYWRlciA9IGRlZmF1bHRfdmVydGV4O1xuXHRcdFx0dGhpcy5mcmFnbWVudFNoYWRlciA9IGRlZmF1bHRfZnJhZ21lbnQ7XG5cdFx0XHR0aGlzLmxpbmV3aWR0aCA9IDE7XG5cdFx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXHRcdFx0dGhpcy5mb2cgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBmb2dcblxuXHRcdFx0dGhpcy5saWdodHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBsaWdodHNcblxuXHRcdFx0dGhpcy5jbGlwcGluZyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHVzZXItZGVmaW5lZCBjbGlwcGluZyBwbGFuZXNcblxuXHRcdFx0dGhpcy5leHRlbnNpb25zID0ge1xuXHRcdFx0XHRkZXJpdmF0aXZlczogZmFsc2UsXG5cdFx0XHRcdC8vIHNldCB0byB1c2UgZGVyaXZhdGl2ZXNcblx0XHRcdFx0ZnJhZ0RlcHRoOiBmYWxzZSxcblx0XHRcdFx0Ly8gc2V0IHRvIHVzZSBmcmFnbWVudCBkZXB0aCB2YWx1ZXNcblx0XHRcdFx0ZHJhd0J1ZmZlcnM6IGZhbHNlLFxuXHRcdFx0XHQvLyBzZXQgdG8gdXNlIGRyYXcgYnVmZmVyc1xuXHRcdFx0XHRzaGFkZXJUZXh0dXJlTE9EOiBmYWxzZSAvLyBzZXQgdG8gdXNlIHNoYWRlciB0ZXh0dXJlIExPRFxuXG5cdFx0XHR9OyAvLyBXaGVuIHJlbmRlcmVkIGdlb21ldHJ5IGRvZXNuJ3QgaW5jbHVkZSB0aGVzZSBhdHRyaWJ1dGVzIGJ1dCB0aGUgbWF0ZXJpYWwgZG9lcyxcblx0XHRcdC8vIHVzZSB0aGVzZSBkZWZhdWx0IHZhbHVlcyBpbiBXZWJHTC4gVGhpcyBhdm9pZHMgZXJyb3JzIHdoZW4gYnVmZmVyIGRhdGEgaXMgbWlzc2luZy5cblxuXHRcdFx0dGhpcy5kZWZhdWx0QXR0cmlidXRlVmFsdWVzID0ge1xuXHRcdFx0XHQnY29sb3InOiBbMSwgMSwgMV0sXG5cdFx0XHRcdCd1dic6IFswLCAwXSxcblx0XHRcdFx0J3V2Mic6IFswLCAwXVxuXHRcdFx0fTtcblx0XHRcdHRoaXMuaW5kZXgwQXR0cmlidXRlTmFtZSA9IHVuZGVmaW5lZDtcblx0XHRcdHRoaXMudW5pZm9ybXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHR0aGlzLmdsc2xWZXJzaW9uID0gbnVsbDtcblxuXHRcdFx0aWYgKHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAocGFyYW1ldGVycy5hdHRyaWJ1dGVzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5TaGFkZXJNYXRlcmlhbDogYXR0cmlidXRlcyBzaG91bGQgbm93IGJlIGRlZmluZWQgaW4gVEhSRUUuQnVmZmVyR2VvbWV0cnkgaW5zdGVhZC4nKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLmZyYWdtZW50U2hhZGVyID0gc291cmNlLmZyYWdtZW50U2hhZGVyO1xuXHRcdFx0dGhpcy52ZXJ0ZXhTaGFkZXIgPSBzb3VyY2UudmVydGV4U2hhZGVyO1xuXHRcdFx0dGhpcy51bmlmb3JtcyA9IGNsb25lVW5pZm9ybXMoc291cmNlLnVuaWZvcm1zKTtcblx0XHRcdHRoaXMuZGVmaW5lcyA9IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZS5kZWZpbmVzKTtcblx0XHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHRcdHRoaXMubGlnaHRzID0gc291cmNlLmxpZ2h0cztcblx0XHRcdHRoaXMuY2xpcHBpbmcgPSBzb3VyY2UuY2xpcHBpbmc7XG5cdFx0XHR0aGlzLmV4dGVuc2lvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2UuZXh0ZW5zaW9ucyk7XG5cdFx0XHR0aGlzLmdsc2xWZXJzaW9uID0gc291cmNlLmdsc2xWZXJzaW9uO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dG9KU09OKG1ldGEpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04obWV0YSk7XG5cdFx0XHRkYXRhLmdsc2xWZXJzaW9uID0gdGhpcy5nbHNsVmVyc2lvbjtcblx0XHRcdGRhdGEudW5pZm9ybXMgPSB7fTtcblxuXHRcdFx0Zm9yIChjb25zdCBuYW1lIGluIHRoaXMudW5pZm9ybXMpIHtcblx0XHRcdFx0Y29uc3QgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXNbbmFtZV07XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gdW5pZm9ybS52YWx1ZTtcblxuXHRcdFx0XHRpZiAodmFsdWUgJiYgdmFsdWUuaXNUZXh0dXJlKSB7XG5cdFx0XHRcdFx0ZGF0YS51bmlmb3Jtc1tuYW1lXSA9IHtcblx0XHRcdFx0XHRcdHR5cGU6ICd0Jyxcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZS50b0pTT04obWV0YSkudXVpZFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgJiYgdmFsdWUuaXNDb2xvcikge1xuXHRcdFx0XHRcdGRhdGEudW5pZm9ybXNbbmFtZV0gPSB7XG5cdFx0XHRcdFx0XHR0eXBlOiAnYycsXG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUuZ2V0SGV4KClcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlICYmIHZhbHVlLmlzVmVjdG9yMikge1xuXHRcdFx0XHRcdGRhdGEudW5pZm9ybXNbbmFtZV0gPSB7XG5cdFx0XHRcdFx0XHR0eXBlOiAndjInLFxuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLnRvQXJyYXkoKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgJiYgdmFsdWUuaXNWZWN0b3IzKSB7XG5cdFx0XHRcdFx0ZGF0YS51bmlmb3Jtc1tuYW1lXSA9IHtcblx0XHRcdFx0XHRcdHR5cGU6ICd2MycsXG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUudG9BcnJheSgpXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSAmJiB2YWx1ZS5pc1ZlY3RvcjQpIHtcblx0XHRcdFx0XHRkYXRhLnVuaWZvcm1zW25hbWVdID0ge1xuXHRcdFx0XHRcdFx0dHlwZTogJ3Y0Jyxcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZS50b0FycmF5KClcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlICYmIHZhbHVlLmlzTWF0cml4Mykge1xuXHRcdFx0XHRcdGRhdGEudW5pZm9ybXNbbmFtZV0gPSB7XG5cdFx0XHRcdFx0XHR0eXBlOiAnbTMnLFxuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLnRvQXJyYXkoKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgJiYgdmFsdWUuaXNNYXRyaXg0KSB7XG5cdFx0XHRcdFx0ZGF0YS51bmlmb3Jtc1tuYW1lXSA9IHtcblx0XHRcdFx0XHRcdHR5cGU6ICdtNCcsXG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUudG9BcnJheSgpXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhLnVuaWZvcm1zW25hbWVdID0ge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdFx0fTsgLy8gbm90ZTogdGhlIGFycmF5IHZhcmlhbnRzIHYydiwgdjN2LCB2NHYsIG00diBhbmQgdHYgYXJlIG5vdCBzdXBwb3J0ZWQgc28gZmFyXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKE9iamVjdC5rZXlzKHRoaXMuZGVmaW5lcykubGVuZ3RoID4gMCkgZGF0YS5kZWZpbmVzID0gdGhpcy5kZWZpbmVzO1xuXHRcdFx0ZGF0YS52ZXJ0ZXhTaGFkZXIgPSB0aGlzLnZlcnRleFNoYWRlcjtcblx0XHRcdGRhdGEuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U2hhZGVyO1xuXHRcdFx0Y29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuXG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmV4dGVuc2lvbnMpIHtcblx0XHRcdFx0aWYgKHRoaXMuZXh0ZW5zaW9uc1trZXldID09PSB0cnVlKSBleHRlbnNpb25zW2tleV0gPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoT2JqZWN0LmtleXMoZXh0ZW5zaW9ucykubGVuZ3RoID4gMCkgZGF0YS5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHR9XG5cblx0U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmlzU2hhZGVyTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdGNsYXNzIENhbWVyYSBleHRlbmRzIE9iamVjdDNEIHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnQ2FtZXJhJztcblx0XHRcdHRoaXMubWF0cml4V29ybGRJbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcblx0XHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSwgcmVjdXJzaXZlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSwgcmVjdXJzaXZlKTtcblx0XHRcdHRoaXMubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoc291cmNlLm1hdHJpeFdvcmxkSW52ZXJzZSk7XG5cdFx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXguY29weShzb3VyY2UucHJvamVjdGlvbk1hdHJpeCk7XG5cdFx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlLmNvcHkoc291cmNlLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGdldFdvcmxkRGlyZWN0aW9uKHRhcmdldCkge1xuXHRcdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCh0cnVlLCBmYWxzZSk7XG5cdFx0XHRjb25zdCBlID0gdGhpcy5tYXRyaXhXb3JsZC5lbGVtZW50cztcblx0XHRcdHJldHVybiB0YXJnZXQuc2V0KC1lWzhdLCAtZVs5XSwgLWVbMTBdKS5ub3JtYWxpemUoKTtcblx0XHR9XG5cblx0XHR1cGRhdGVNYXRyaXhXb3JsZChmb3JjZSkge1xuXHRcdFx0c3VwZXIudXBkYXRlTWF0cml4V29ybGQoZm9yY2UpO1xuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weSh0aGlzLm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcblx0XHR9XG5cblx0XHR1cGRhdGVXb3JsZE1hdHJpeCh1cGRhdGVQYXJlbnRzLCB1cGRhdGVDaGlsZHJlbikge1xuXHRcdFx0c3VwZXIudXBkYXRlV29ybGRNYXRyaXgodXBkYXRlUGFyZW50cywgdXBkYXRlQ2hpbGRyZW4pO1xuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weSh0aGlzLm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG5cdFx0fVxuXG5cdH1cblxuXHRDYW1lcmEucHJvdG90eXBlLmlzQ2FtZXJhID0gdHJ1ZTtcblxuXHRjbGFzcyBQZXJzcGVjdGl2ZUNhbWVyYSBleHRlbmRzIENhbWVyYSB7XG5cdFx0Y29uc3RydWN0b3IoZm92ID0gNTAsIGFzcGVjdCA9IDEsIG5lYXIgPSAwLjEsIGZhciA9IDIwMDApIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnUGVyc3BlY3RpdmVDYW1lcmEnO1xuXHRcdFx0dGhpcy5mb3YgPSBmb3Y7XG5cdFx0XHR0aGlzLnpvb20gPSAxO1xuXHRcdFx0dGhpcy5uZWFyID0gbmVhcjtcblx0XHRcdHRoaXMuZmFyID0gZmFyO1xuXHRcdFx0dGhpcy5mb2N1cyA9IDEwO1xuXHRcdFx0dGhpcy5hc3BlY3QgPSBhc3BlY3Q7XG5cdFx0XHR0aGlzLnZpZXcgPSBudWxsO1xuXHRcdFx0dGhpcy5maWxtR2F1Z2UgPSAzNTsgLy8gd2lkdGggb2YgdGhlIGZpbG0gKGRlZmF1bHQgaW4gbWlsbGltZXRlcnMpXG5cblx0XHRcdHRoaXMuZmlsbU9mZnNldCA9IDA7IC8vIGhvcml6b250YWwgZmlsbSBvZmZzZXQgKHNhbWUgdW5pdCBhcyBnYXVnZSlcblxuXHRcdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UsIHJlY3Vyc2l2ZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UsIHJlY3Vyc2l2ZSk7XG5cdFx0XHR0aGlzLmZvdiA9IHNvdXJjZS5mb3Y7XG5cdFx0XHR0aGlzLnpvb20gPSBzb3VyY2Uuem9vbTtcblx0XHRcdHRoaXMubmVhciA9IHNvdXJjZS5uZWFyO1xuXHRcdFx0dGhpcy5mYXIgPSBzb3VyY2UuZmFyO1xuXHRcdFx0dGhpcy5mb2N1cyA9IHNvdXJjZS5mb2N1cztcblx0XHRcdHRoaXMuYXNwZWN0ID0gc291cmNlLmFzcGVjdDtcblx0XHRcdHRoaXMudmlldyA9IHNvdXJjZS52aWV3ID09PSBudWxsID8gbnVsbCA6IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZS52aWV3KTtcblx0XHRcdHRoaXMuZmlsbUdhdWdlID0gc291cmNlLmZpbG1HYXVnZTtcblx0XHRcdHRoaXMuZmlsbU9mZnNldCA9IHNvdXJjZS5maWxtT2Zmc2V0O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdC8qKlxuXHRcdCAqIFNldHMgdGhlIEZPViBieSBmb2NhbCBsZW5ndGggaW4gcmVzcGVjdCB0byB0aGUgY3VycmVudCAuZmlsbUdhdWdlLlxuXHRcdCAqXG5cdFx0ICogVGhlIGRlZmF1bHQgZmlsbSBnYXVnZSBpcyAzNSwgc28gdGhhdCB0aGUgZm9jYWwgbGVuZ3RoIGNhbiBiZSBzcGVjaWZpZWQgZm9yXG5cdFx0ICogYSAzNW1tIChmdWxsIGZyYW1lKSBjYW1lcmEuXG5cdFx0ICpcblx0XHQgKiBWYWx1ZXMgZm9yIGZvY2FsIGxlbmd0aCBhbmQgZmlsbSBnYXVnZSBtdXN0IGhhdmUgdGhlIHNhbWUgdW5pdC5cblx0XHQgKi9cblxuXG5cdFx0c2V0Rm9jYWxMZW5ndGgoZm9jYWxMZW5ndGgpIHtcblx0XHRcdC8qKiBzZWUge0BsaW5rIGh0dHA6Ly93d3cuYm9iYXRraW5zLmNvbS9waG90b2dyYXBoeS90ZWNobmljYWwvZmllbGRfb2Zfdmlldy5odG1sfSAqL1xuXHRcdFx0Y29uc3QgdkV4dGVudFNsb3BlID0gMC41ICogdGhpcy5nZXRGaWxtSGVpZ2h0KCkgLyBmb2NhbExlbmd0aDtcblx0XHRcdHRoaXMuZm92ID0gUkFEMkRFRyAqIDIgKiBNYXRoLmF0YW4odkV4dGVudFNsb3BlKTtcblx0XHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXHRcdH1cblx0XHQvKipcblx0XHQgKiBDYWxjdWxhdGVzIHRoZSBmb2NhbCBsZW5ndGggZnJvbSB0aGUgY3VycmVudCAuZm92IGFuZCAuZmlsbUdhdWdlLlxuXHRcdCAqL1xuXG5cblx0XHRnZXRGb2NhbExlbmd0aCgpIHtcblx0XHRcdGNvbnN0IHZFeHRlbnRTbG9wZSA9IE1hdGgudGFuKERFRzJSQUQgKiAwLjUgKiB0aGlzLmZvdik7XG5cdFx0XHRyZXR1cm4gMC41ICogdGhpcy5nZXRGaWxtSGVpZ2h0KCkgLyB2RXh0ZW50U2xvcGU7XG5cdFx0fVxuXG5cdFx0Z2V0RWZmZWN0aXZlRk9WKCkge1xuXHRcdFx0cmV0dXJuIFJBRDJERUcgKiAyICogTWF0aC5hdGFuKE1hdGgudGFuKERFRzJSQUQgKiAwLjUgKiB0aGlzLmZvdikgLyB0aGlzLnpvb20pO1xuXHRcdH1cblxuXHRcdGdldEZpbG1XaWR0aCgpIHtcblx0XHRcdC8vIGZpbG0gbm90IGNvbXBsZXRlbHkgY292ZXJlZCBpbiBwb3J0cmFpdCBmb3JtYXQgKGFzcGVjdCA8IDEpXG5cdFx0XHRyZXR1cm4gdGhpcy5maWxtR2F1Z2UgKiBNYXRoLm1pbih0aGlzLmFzcGVjdCwgMSk7XG5cdFx0fVxuXG5cdFx0Z2V0RmlsbUhlaWdodCgpIHtcblx0XHRcdC8vIGZpbG0gbm90IGNvbXBsZXRlbHkgY292ZXJlZCBpbiBsYW5kc2NhcGUgZm9ybWF0IChhc3BlY3QgPiAxKVxuXHRcdFx0cmV0dXJuIHRoaXMuZmlsbUdhdWdlIC8gTWF0aC5tYXgodGhpcy5hc3BlY3QsIDEpO1xuXHRcdH1cblx0XHQvKipcblx0XHQgKiBTZXRzIGFuIG9mZnNldCBpbiBhIGxhcmdlciBmcnVzdHVtLiBUaGlzIGlzIHVzZWZ1bCBmb3IgbXVsdGktd2luZG93IG9yXG5cdFx0ICogbXVsdGktbW9uaXRvci9tdWx0aS1tYWNoaW5lIHNldHVwcy5cblx0XHQgKlxuXHRcdCAqIEZvciBleGFtcGxlLCBpZiB5b3UgaGF2ZSAzeDIgbW9uaXRvcnMgYW5kIGVhY2ggbW9uaXRvciBpcyAxOTIweDEwODAgYW5kXG5cdFx0ICogdGhlIG1vbml0b3JzIGFyZSBpbiBncmlkIGxpa2UgdGhpc1xuXHRcdCAqXG5cdFx0ICpcdCArLS0tKy0tLSstLS0rXG5cdFx0ICpcdCB8IEEgfCBCIHwgQyB8XG5cdFx0ICpcdCArLS0tKy0tLSstLS0rXG5cdFx0ICpcdCB8IEQgfCBFIHwgRiB8XG5cdFx0ICpcdCArLS0tKy0tLSstLS0rXG5cdFx0ICpcblx0XHQgKiB0aGVuIGZvciBlYWNoIG1vbml0b3IgeW91IHdvdWxkIGNhbGwgaXQgbGlrZSB0aGlzXG5cdFx0ICpcblx0XHQgKlx0IGNvbnN0IHcgPSAxOTIwO1xuXHRcdCAqXHQgY29uc3QgaCA9IDEwODA7XG5cdFx0ICpcdCBjb25zdCBmdWxsV2lkdGggPSB3ICogMztcblx0XHQgKlx0IGNvbnN0IGZ1bGxIZWlnaHQgPSBoICogMjtcblx0XHQgKlxuXHRcdCAqXHQgLS1BLS1cblx0XHQgKlx0IGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAwLCBoICogMCwgdywgaCApO1xuXHRcdCAqXHQgLS1CLS1cblx0XHQgKlx0IGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMCwgdywgaCApO1xuXHRcdCAqXHQgLS1DLS1cblx0XHQgKlx0IGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAyLCBoICogMCwgdywgaCApO1xuXHRcdCAqXHQgLS1ELS1cblx0XHQgKlx0IGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAwLCBoICogMSwgdywgaCApO1xuXHRcdCAqXHQgLS1FLS1cblx0XHQgKlx0IGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMSwgdywgaCApO1xuXHRcdCAqXHQgLS1GLS1cblx0XHQgKlx0IGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAyLCBoICogMSwgdywgaCApO1xuXHRcdCAqXG5cdFx0ICpcdCBOb3RlIHRoZXJlIGlzIG5vIHJlYXNvbiBtb25pdG9ycyBoYXZlIHRvIGJlIHRoZSBzYW1lIHNpemUgb3IgaW4gYSBncmlkLlxuXHRcdCAqL1xuXG5cblx0XHRzZXRWaWV3T2Zmc2V0KGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdFx0dGhpcy5hc3BlY3QgPSBmdWxsV2lkdGggLyBmdWxsSGVpZ2h0O1xuXG5cdFx0XHRpZiAodGhpcy52aWV3ID09PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMudmlldyA9IHtcblx0XHRcdFx0XHRlbmFibGVkOiB0cnVlLFxuXHRcdFx0XHRcdGZ1bGxXaWR0aDogMSxcblx0XHRcdFx0XHRmdWxsSGVpZ2h0OiAxLFxuXHRcdFx0XHRcdG9mZnNldFg6IDAsXG5cdFx0XHRcdFx0b2Zmc2V0WTogMCxcblx0XHRcdFx0XHR3aWR0aDogMSxcblx0XHRcdFx0XHRoZWlnaHQ6IDFcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy52aWV3LmVuYWJsZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy52aWV3LmZ1bGxXaWR0aCA9IGZ1bGxXaWR0aDtcblx0XHRcdHRoaXMudmlldy5mdWxsSGVpZ2h0ID0gZnVsbEhlaWdodDtcblx0XHRcdHRoaXMudmlldy5vZmZzZXRYID0geDtcblx0XHRcdHRoaXMudmlldy5vZmZzZXRZID0geTtcblx0XHRcdHRoaXMudmlldy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0dGhpcy52aWV3LmhlaWdodCA9IGhlaWdodDtcblx0XHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXHRcdH1cblxuXHRcdGNsZWFyVmlld09mZnNldCgpIHtcblx0XHRcdGlmICh0aGlzLnZpZXcgIT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy52aWV3LmVuYWJsZWQgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0fVxuXG5cdFx0dXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpIHtcblx0XHRcdGNvbnN0IG5lYXIgPSB0aGlzLm5lYXI7XG5cdFx0XHRsZXQgdG9wID0gbmVhciAqIE1hdGgudGFuKERFRzJSQUQgKiAwLjUgKiB0aGlzLmZvdikgLyB0aGlzLnpvb207XG5cdFx0XHRsZXQgaGVpZ2h0ID0gMiAqIHRvcDtcblx0XHRcdGxldCB3aWR0aCA9IHRoaXMuYXNwZWN0ICogaGVpZ2h0O1xuXHRcdFx0bGV0IGxlZnQgPSAtMC41ICogd2lkdGg7XG5cdFx0XHRjb25zdCB2aWV3ID0gdGhpcy52aWV3O1xuXG5cdFx0XHRpZiAodGhpcy52aWV3ICE9PSBudWxsICYmIHRoaXMudmlldy5lbmFibGVkKSB7XG5cdFx0XHRcdGNvbnN0IGZ1bGxXaWR0aCA9IHZpZXcuZnVsbFdpZHRoLFxuXHRcdFx0XHRcdFx0XHRmdWxsSGVpZ2h0ID0gdmlldy5mdWxsSGVpZ2h0O1xuXHRcdFx0XHRsZWZ0ICs9IHZpZXcub2Zmc2V0WCAqIHdpZHRoIC8gZnVsbFdpZHRoO1xuXHRcdFx0XHR0b3AgLT0gdmlldy5vZmZzZXRZICogaGVpZ2h0IC8gZnVsbEhlaWdodDtcblx0XHRcdFx0d2lkdGggKj0gdmlldy53aWR0aCAvIGZ1bGxXaWR0aDtcblx0XHRcdFx0aGVpZ2h0ICo9IHZpZXcuaGVpZ2h0IC8gZnVsbEhlaWdodDtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2tldyA9IHRoaXMuZmlsbU9mZnNldDtcblx0XHRcdGlmIChza2V3ICE9PSAwKSBsZWZ0ICs9IG5lYXIgKiBza2V3IC8gdGhpcy5nZXRGaWxtV2lkdGgoKTtcblx0XHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlUGVyc3BlY3RpdmUobGVmdCwgbGVmdCArIHdpZHRoLCB0b3AsIHRvcCAtIGhlaWdodCwgbmVhciwgdGhpcy5mYXIpO1xuXHRcdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KHRoaXMucHJvamVjdGlvbk1hdHJpeCkuaW52ZXJ0KCk7XG5cdFx0fVxuXG5cdFx0dG9KU09OKG1ldGEpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04obWV0YSk7XG5cdFx0XHRkYXRhLm9iamVjdC5mb3YgPSB0aGlzLmZvdjtcblx0XHRcdGRhdGEub2JqZWN0Lnpvb20gPSB0aGlzLnpvb207XG5cdFx0XHRkYXRhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xuXHRcdFx0ZGF0YS5vYmplY3QuZmFyID0gdGhpcy5mYXI7XG5cdFx0XHRkYXRhLm9iamVjdC5mb2N1cyA9IHRoaXMuZm9jdXM7XG5cdFx0XHRkYXRhLm9iamVjdC5hc3BlY3QgPSB0aGlzLmFzcGVjdDtcblx0XHRcdGlmICh0aGlzLnZpZXcgIT09IG51bGwpIGRhdGEub2JqZWN0LnZpZXcgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnZpZXcpO1xuXHRcdFx0ZGF0YS5vYmplY3QuZmlsbUdhdWdlID0gdGhpcy5maWxtR2F1Z2U7XG5cdFx0XHRkYXRhLm9iamVjdC5maWxtT2Zmc2V0ID0gdGhpcy5maWxtT2Zmc2V0O1xuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdH1cblxuXHRQZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuaXNQZXJzcGVjdGl2ZUNhbWVyYSA9IHRydWU7XG5cblx0Y29uc3QgZm92ID0gOTAsXG5cdFx0XHRcdGFzcGVjdCA9IDE7XG5cblx0Y2xhc3MgQ3ViZUNhbWVyYSBleHRlbmRzIE9iamVjdDNEIHtcblx0XHRjb25zdHJ1Y3RvcihuZWFyLCBmYXIsIHJlbmRlclRhcmdldCkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdDdWJlQ2FtZXJhJztcblxuXHRcdFx0aWYgKHJlbmRlclRhcmdldC5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCAhPT0gdHJ1ZSkge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5DdWJlQ2FtZXJhOiBUaGUgY29uc3RydWN0b3Igbm93IGV4cGVjdHMgYW4gaW5zdGFuY2Ugb2YgV2ViR0xDdWJlUmVuZGVyVGFyZ2V0IGFzIHRoaXJkIHBhcmFtZXRlci4nKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcblx0XHRcdGNvbnN0IGNhbWVyYVBYID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIpO1xuXHRcdFx0Y2FtZXJhUFgubGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cdFx0XHRjYW1lcmFQWC51cC5zZXQoMCwgLTEsIDApO1xuXHRcdFx0Y2FtZXJhUFgubG9va0F0KG5ldyBWZWN0b3IzKDEsIDAsIDApKTtcblx0XHRcdHRoaXMuYWRkKGNhbWVyYVBYKTtcblx0XHRcdGNvbnN0IGNhbWVyYU5YID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIpO1xuXHRcdFx0Y2FtZXJhTlgubGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cdFx0XHRjYW1lcmFOWC51cC5zZXQoMCwgLTEsIDApO1xuXHRcdFx0Y2FtZXJhTlgubG9va0F0KG5ldyBWZWN0b3IzKC0xLCAwLCAwKSk7XG5cdFx0XHR0aGlzLmFkZChjYW1lcmFOWCk7XG5cdFx0XHRjb25zdCBjYW1lcmFQWSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYShmb3YsIGFzcGVjdCwgbmVhciwgZmFyKTtcblx0XHRcdGNhbWVyYVBZLmxheWVycyA9IHRoaXMubGF5ZXJzO1xuXHRcdFx0Y2FtZXJhUFkudXAuc2V0KDAsIDAsIDEpO1xuXHRcdFx0Y2FtZXJhUFkubG9va0F0KG5ldyBWZWN0b3IzKDAsIDEsIDApKTtcblx0XHRcdHRoaXMuYWRkKGNhbWVyYVBZKTtcblx0XHRcdGNvbnN0IGNhbWVyYU5ZID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIpO1xuXHRcdFx0Y2FtZXJhTlkubGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cdFx0XHRjYW1lcmFOWS51cC5zZXQoMCwgMCwgLTEpO1xuXHRcdFx0Y2FtZXJhTlkubG9va0F0KG5ldyBWZWN0b3IzKDAsIC0xLCAwKSk7XG5cdFx0XHR0aGlzLmFkZChjYW1lcmFOWSk7XG5cdFx0XHRjb25zdCBjYW1lcmFQWiA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYShmb3YsIGFzcGVjdCwgbmVhciwgZmFyKTtcblx0XHRcdGNhbWVyYVBaLmxheWVycyA9IHRoaXMubGF5ZXJzO1xuXHRcdFx0Y2FtZXJhUFoudXAuc2V0KDAsIC0xLCAwKTtcblx0XHRcdGNhbWVyYVBaLmxvb2tBdChuZXcgVmVjdG9yMygwLCAwLCAxKSk7XG5cdFx0XHR0aGlzLmFkZChjYW1lcmFQWik7XG5cdFx0XHRjb25zdCBjYW1lcmFOWiA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYShmb3YsIGFzcGVjdCwgbmVhciwgZmFyKTtcblx0XHRcdGNhbWVyYU5aLmxheWVycyA9IHRoaXMubGF5ZXJzO1xuXHRcdFx0Y2FtZXJhTloudXAuc2V0KDAsIC0xLCAwKTtcblx0XHRcdGNhbWVyYU5aLmxvb2tBdChuZXcgVmVjdG9yMygwLCAwLCAtMSkpO1xuXHRcdFx0dGhpcy5hZGQoY2FtZXJhTlopO1xuXHRcdH1cblxuXHRcdHVwZGF0ZShyZW5kZXJlciwgc2NlbmUpIHtcblx0XHRcdGlmICh0aGlzLnBhcmVudCA9PT0gbnVsbCkgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXHRcdFx0Y29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQ7XG5cdFx0XHRjb25zdCBbY2FtZXJhUFgsIGNhbWVyYU5YLCBjYW1lcmFQWSwgY2FtZXJhTlksIGNhbWVyYVBaLCBjYW1lcmFOWl0gPSB0aGlzLmNoaWxkcmVuO1xuXHRcdFx0Y29uc3QgY3VycmVudFhyRW5hYmxlZCA9IHJlbmRlcmVyLnhyLmVuYWJsZWQ7XG5cdFx0XHRjb25zdCBjdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cdFx0XHRyZW5kZXJlci54ci5lbmFibGVkID0gZmFsc2U7XG5cdFx0XHRjb25zdCBnZW5lcmF0ZU1pcG1hcHMgPSByZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM7XG5cdFx0XHRyZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQsIDApO1xuXHRcdFx0cmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmFQWCk7XG5cdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0LCAxKTtcblx0XHRcdHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhTlgpO1xuXHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCwgMik7XG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYVBZKTtcblx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQsIDMpO1xuXHRcdFx0cmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmFOWSk7XG5cdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0LCA0KTtcblx0XHRcdHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhUFopO1xuXHRcdFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZ2VuZXJhdGVNaXBtYXBzO1xuXHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCwgNSk7XG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYU5aKTtcblx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChjdXJyZW50UmVuZGVyVGFyZ2V0KTtcblx0XHRcdHJlbmRlcmVyLnhyLmVuYWJsZWQgPSBjdXJyZW50WHJFbmFibGVkO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgQ3ViZVRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblx0XHRjb25zdHJ1Y3RvcihpbWFnZXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgZW5jb2RpbmcpIHtcblx0XHRcdGltYWdlcyA9IGltYWdlcyAhPT0gdW5kZWZpbmVkID8gaW1hZ2VzIDogW107XG5cdFx0XHRtYXBwaW5nID0gbWFwcGluZyAhPT0gdW5kZWZpbmVkID8gbWFwcGluZyA6IEN1YmVSZWZsZWN0aW9uTWFwcGluZztcblx0XHRcdHN1cGVyKGltYWdlcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyk7XG5cdFx0XHR0aGlzLmZsaXBZID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Z2V0IGltYWdlcygpIHtcblx0XHRcdHJldHVybiB0aGlzLmltYWdlO1xuXHRcdH1cblxuXHRcdHNldCBpbWFnZXModmFsdWUpIHtcblx0XHRcdHRoaXMuaW1hZ2UgPSB2YWx1ZTtcblx0XHR9XG5cblx0fVxuXG5cdEN1YmVUZXh0dXJlLnByb3RvdHlwZS5pc0N1YmVUZXh0dXJlID0gdHJ1ZTtcblxuXHRjbGFzcyBXZWJHTEN1YmVSZW5kZXJUYXJnZXQgZXh0ZW5kcyBXZWJHTFJlbmRlclRhcmdldCB7XG5cdFx0Y29uc3RydWN0b3Ioc2l6ZSwgb3B0aW9ucywgZHVtbXkpIHtcblx0XHRcdGlmIChOdW1iZXIuaXNJbnRlZ2VyKG9wdGlvbnMpKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xDdWJlUmVuZGVyVGFyZ2V0OiBjb25zdHJ1Y3RvciBzaWduYXR1cmUgaXMgbm93IFdlYkdMQ3ViZVJlbmRlclRhcmdldCggc2l6ZSwgb3B0aW9ucyApJyk7XG5cdFx0XHRcdG9wdGlvbnMgPSBkdW1teTtcblx0XHRcdH1cblxuXHRcdFx0c3VwZXIoc2l6ZSwgc2l6ZSwgb3B0aW9ucyk7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gQnkgY29udmVudGlvbiAtLSBsaWtlbHkgYmFzZWQgb24gdGhlIFJlbmRlck1hbiBzcGVjIGZyb20gdGhlIDE5OTAncyAtLSBjdWJlIG1hcHMgYXJlIHNwZWNpZmllZCBieSBXZWJHTCAoYW5kIHRocmVlLmpzKVxuXHRcdFx0Ly8gaW4gYSBjb29yZGluYXRlIHN5c3RlbSBpbiB3aGljaCBwb3NpdGl2ZS14IGlzIHRvIHRoZSByaWdodCB3aGVuIGxvb2tpbmcgdXAgdGhlIHBvc2l0aXZlLXogYXhpcyAtLSBpbiBvdGhlciB3b3Jkcyxcblx0XHRcdC8vIGluIGEgbGVmdC1oYW5kZWQgY29vcmRpbmF0ZSBzeXN0ZW0uIEJ5IGNvbnRpbnVpbmcgdGhpcyBjb252ZW50aW9uLCBwcmVleGlzdGluZyBjdWJlIG1hcHMgY29udGludWVkIHRvIHJlbmRlciBjb3JyZWN0bHkuXG5cdFx0XHQvLyB0aHJlZS5qcyB1c2VzIGEgcmlnaHQtaGFuZGVkIGNvb3JkaW5hdGUgc3lzdGVtLiBTbyBlbnZpcm9ubWVudCBtYXBzIHVzZWQgaW4gdGhyZWUuanMgYXBwZWFyIHRvIGhhdmUgcHggYW5kIG54IHN3YXBwZWRcblx0XHRcdC8vIGFuZCB0aGUgZmxhZyBpc1JlbmRlclRhcmdldFRleHR1cmUgY29udHJvbHMgdGhpcyBjb252ZXJzaW9uLiBUaGUgZmxpcCBpcyBub3QgcmVxdWlyZWQgd2hlbiB1c2luZyBXZWJHTEN1YmVSZW5kZXJUYXJnZXQudGV4dHVyZVxuXHRcdFx0Ly8gYXMgYSBjdWJlIHRleHR1cmUgKHRoaXMgaXMgZGV0ZWN0ZWQgd2hlbiBpc1JlbmRlclRhcmdldFRleHR1cmUgaXMgc2V0IHRvIHRydWUgZm9yIGN1YmUgdGV4dHVyZXMpLlxuXG5cdFx0XHR0aGlzLnRleHR1cmUgPSBuZXcgQ3ViZVRleHR1cmUodW5kZWZpbmVkLCBvcHRpb25zLm1hcHBpbmcsIG9wdGlvbnMud3JhcFMsIG9wdGlvbnMud3JhcFQsIG9wdGlvbnMubWFnRmlsdGVyLCBvcHRpb25zLm1pbkZpbHRlciwgb3B0aW9ucy5mb3JtYXQsIG9wdGlvbnMudHlwZSwgb3B0aW9ucy5hbmlzb3Ryb3B5LCBvcHRpb25zLmVuY29kaW5nKTtcblx0XHRcdHRoaXMudGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgPSB0cnVlO1xuXHRcdFx0dGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IG9wdGlvbnMuZ2VuZXJhdGVNaXBtYXBzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmdlbmVyYXRlTWlwbWFwcyA6IGZhbHNlO1xuXHRcdFx0dGhpcy50ZXh0dXJlLm1pbkZpbHRlciA9IG9wdGlvbnMubWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1pbkZpbHRlciA6IExpbmVhckZpbHRlcjtcblx0XHRcdHRoaXMudGV4dHVyZS5fbmVlZHNGbGlwRW52TWFwID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0ZnJvbUVxdWlyZWN0YW5ndWxhclRleHR1cmUocmVuZGVyZXIsIHRleHR1cmUpIHtcblx0XHRcdHRoaXMudGV4dHVyZS50eXBlID0gdGV4dHVyZS50eXBlO1xuXHRcdFx0dGhpcy50ZXh0dXJlLmZvcm1hdCA9IFJHQkFGb3JtYXQ7IC8vIHNlZSAjMTg4NTlcblxuXHRcdFx0dGhpcy50ZXh0dXJlLmVuY29kaW5nID0gdGV4dHVyZS5lbmNvZGluZztcblx0XHRcdHRoaXMudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcztcblx0XHRcdHRoaXMudGV4dHVyZS5taW5GaWx0ZXIgPSB0ZXh0dXJlLm1pbkZpbHRlcjtcblx0XHRcdHRoaXMudGV4dHVyZS5tYWdGaWx0ZXIgPSB0ZXh0dXJlLm1hZ0ZpbHRlcjtcblx0XHRcdGNvbnN0IHNoYWRlciA9IHtcblx0XHRcdFx0dW5pZm9ybXM6IHtcblx0XHRcdFx0XHR0RXF1aXJlY3Q6IHtcblx0XHRcdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6XG5cdFx0XHRcdC8qIGdsc2wgKi9cblx0XHRcdFx0YFxuXG5cdFx0XHRcdHZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247XG5cblx0XHRcdFx0dmVjMyB0cmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgZGlyLCBpbiBtYXQ0IG1hdHJpeCApIHtcblxuXHRcdFx0XHRcdHJldHVybiBub3JtYWxpemUoICggbWF0cml4ICogdmVjNCggZGlyLCAwLjAgKSApLnh5eiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2b2lkIG1haW4oKSB7XG5cblx0XHRcdFx0XHR2V29ybGREaXJlY3Rpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1xuXG5cdFx0XHRcdFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cblx0XHRcdFx0XHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XG5cblx0XHRcdFx0fVxuXHRcdFx0YCxcblx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6XG5cdFx0XHRcdC8qIGdsc2wgKi9cblx0XHRcdFx0YFxuXG5cdFx0XHRcdHVuaWZvcm0gc2FtcGxlcjJEIHRFcXVpcmVjdDtcblxuXHRcdFx0XHR2YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uO1xuXG5cdFx0XHRcdCNpbmNsdWRlIDxjb21tb24+XG5cblx0XHRcdFx0dm9pZCBtYWluKCkge1xuXG5cdFx0XHRcdFx0dmVjMyBkaXJlY3Rpb24gPSBub3JtYWxpemUoIHZXb3JsZERpcmVjdGlvbiApO1xuXG5cdFx0XHRcdFx0dmVjMiBzYW1wbGVVViA9IGVxdWlyZWN0VXYoIGRpcmVjdGlvbiApO1xuXG5cdFx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCB0RXF1aXJlY3QsIHNhbXBsZVVWICk7XG5cblx0XHRcdFx0fVxuXHRcdFx0YFxuXHRcdFx0fTtcblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJveEdlb21ldHJ5KDUsIDUsIDUpO1xuXHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgU2hhZGVyTWF0ZXJpYWwoe1xuXHRcdFx0XHRuYW1lOiAnQ3ViZW1hcEZyb21FcXVpcmVjdCcsXG5cdFx0XHRcdHVuaWZvcm1zOiBjbG9uZVVuaWZvcm1zKHNoYWRlci51bmlmb3JtcyksXG5cdFx0XHRcdHZlcnRleFNoYWRlcjogc2hhZGVyLnZlcnRleFNoYWRlcixcblx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IHNoYWRlci5mcmFnbWVudFNoYWRlcixcblx0XHRcdFx0c2lkZTogQmFja1NpZGUsXG5cdFx0XHRcdGJsZW5kaW5nOiBOb0JsZW5kaW5nXG5cdFx0XHR9KTtcblx0XHRcdG1hdGVyaWFsLnVuaWZvcm1zLnRFcXVpcmVjdC52YWx1ZSA9IHRleHR1cmU7XG5cdFx0XHRjb25zdCBtZXNoID0gbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHRcdGNvbnN0IGN1cnJlbnRNaW5GaWx0ZXIgPSB0ZXh0dXJlLm1pbkZpbHRlcjsgLy8gQXZvaWQgYmx1cnJlZCBwb2xlc1xuXG5cdFx0XHRpZiAodGV4dHVyZS5taW5GaWx0ZXIgPT09IExpbmVhck1pcG1hcExpbmVhckZpbHRlcikgdGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG5cdFx0XHRjb25zdCBjYW1lcmEgPSBuZXcgQ3ViZUNhbWVyYSgxLCAxMCwgdGhpcyk7XG5cdFx0XHRjYW1lcmEudXBkYXRlKHJlbmRlcmVyLCBtZXNoKTtcblx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gY3VycmVudE1pbkZpbHRlcjtcblx0XHRcdG1lc2guZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdFx0bWVzaC5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbGVhcihyZW5kZXJlciwgY29sb3IsIGRlcHRoLCBzdGVuY2lsKSB7XG5cdFx0XHRjb25zdCBjdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG5cdFx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLCBpKTtcblx0XHRcdFx0cmVuZGVyZXIuY2xlYXIoY29sb3IsIGRlcHRoLCBzdGVuY2lsKTtcblx0XHRcdH1cblxuXHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KGN1cnJlbnRSZW5kZXJUYXJnZXQpO1xuXHRcdH1cblxuXHR9XG5cblx0V2ViR0xDdWJlUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCA9IHRydWU7XG5cblx0Y29uc3QgX3ZlY3RvcjEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfdmVjdG9yMiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9ub3JtYWxNYXRyaXggPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDMoKTtcblxuXHRjbGFzcyBQbGFuZSB7XG5cdFx0Y29uc3RydWN0b3Iobm9ybWFsID0gbmV3IFZlY3RvcjMoMSwgMCwgMCksIGNvbnN0YW50ID0gMCkge1xuXHRcdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXHRcdFx0dGhpcy5ub3JtYWwgPSBub3JtYWw7XG5cdFx0XHR0aGlzLmNvbnN0YW50ID0gY29uc3RhbnQ7XG5cdFx0fVxuXG5cdFx0c2V0KG5vcm1hbCwgY29uc3RhbnQpIHtcblx0XHRcdHRoaXMubm9ybWFsLmNvcHkobm9ybWFsKTtcblx0XHRcdHRoaXMuY29uc3RhbnQgPSBjb25zdGFudDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldENvbXBvbmVudHMoeCwgeSwgeiwgdykge1xuXHRcdFx0dGhpcy5ub3JtYWwuc2V0KHgsIHksIHopO1xuXHRcdFx0dGhpcy5jb25zdGFudCA9IHc7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludChub3JtYWwsIHBvaW50KSB7XG5cdFx0XHR0aGlzLm5vcm1hbC5jb3B5KG5vcm1hbCk7XG5cdFx0XHR0aGlzLmNvbnN0YW50ID0gLXBvaW50LmRvdCh0aGlzLm5vcm1hbCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRGcm9tQ29wbGFuYXJQb2ludHMoYSwgYiwgYykge1xuXHRcdFx0Y29uc3Qgbm9ybWFsID0gX3ZlY3RvcjEuc3ViVmVjdG9ycyhjLCBiKS5jcm9zcyhfdmVjdG9yMi5zdWJWZWN0b3JzKGEsIGIpKS5ub3JtYWxpemUoKTsgLy8gUTogc2hvdWxkIGFuIGVycm9yIGJlIHRocm93biBpZiBub3JtYWwgaXMgemVybyAoZS5nLiBkZWdlbmVyYXRlIHBsYW5lKT9cblxuXG5cdFx0XHR0aGlzLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KG5vcm1hbCwgYSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb3B5KHBsYW5lKSB7XG5cdFx0XHR0aGlzLm5vcm1hbC5jb3B5KHBsYW5lLm5vcm1hbCk7XG5cdFx0XHR0aGlzLmNvbnN0YW50ID0gcGxhbmUuY29uc3RhbnQ7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRub3JtYWxpemUoKSB7XG5cdFx0XHQvLyBOb3RlOiB3aWxsIGxlYWQgdG8gYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgcGxhbmUgaXMgaW52YWxpZC5cblx0XHRcdGNvbnN0IGludmVyc2VOb3JtYWxMZW5ndGggPSAxLjAgLyB0aGlzLm5vcm1hbC5sZW5ndGgoKTtcblx0XHRcdHRoaXMubm9ybWFsLm11bHRpcGx5U2NhbGFyKGludmVyc2VOb3JtYWxMZW5ndGgpO1xuXHRcdFx0dGhpcy5jb25zdGFudCAqPSBpbnZlcnNlTm9ybWFsTGVuZ3RoO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bmVnYXRlKCkge1xuXHRcdFx0dGhpcy5jb25zdGFudCAqPSAtMTtcblx0XHRcdHRoaXMubm9ybWFsLm5lZ2F0ZSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZGlzdGFuY2VUb1BvaW50KHBvaW50KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5ub3JtYWwuZG90KHBvaW50KSArIHRoaXMuY29uc3RhbnQ7XG5cdFx0fVxuXG5cdFx0ZGlzdGFuY2VUb1NwaGVyZShzcGhlcmUpIHtcblx0XHRcdHJldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludChzcGhlcmUuY2VudGVyKSAtIHNwaGVyZS5yYWRpdXM7XG5cdFx0fVxuXG5cdFx0cHJvamVjdFBvaW50KHBvaW50LCB0YXJnZXQpIHtcblx0XHRcdHJldHVybiB0YXJnZXQuY29weSh0aGlzLm5vcm1hbCkubXVsdGlwbHlTY2FsYXIoLXRoaXMuZGlzdGFuY2VUb1BvaW50KHBvaW50KSkuYWRkKHBvaW50KTtcblx0XHR9XG5cblx0XHRpbnRlcnNlY3RMaW5lKGxpbmUsIHRhcmdldCkge1xuXHRcdFx0Y29uc3QgZGlyZWN0aW9uID0gbGluZS5kZWx0YShfdmVjdG9yMSk7XG5cdFx0XHRjb25zdCBkZW5vbWluYXRvciA9IHRoaXMubm9ybWFsLmRvdChkaXJlY3Rpb24pO1xuXG5cdFx0XHRpZiAoZGVub21pbmF0b3IgPT09IDApIHtcblx0XHRcdFx0Ly8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxuXHRcdFx0XHRpZiAodGhpcy5kaXN0YW5jZVRvUG9pbnQobGluZS5zdGFydCkgPT09IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkobGluZS5zdGFydCk7XG5cdFx0XHRcdH0gLy8gVW5zdXJlIGlmIHRoaXMgaXMgdGhlIGNvcnJlY3QgbWV0aG9kIHRvIGhhbmRsZSB0aGlzIGNhc2UuXG5cblxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdCA9IC0obGluZS5zdGFydC5kb3QodGhpcy5ub3JtYWwpICsgdGhpcy5jb25zdGFudCkgLyBkZW5vbWluYXRvcjtcblxuXHRcdFx0aWYgKHQgPCAwIHx8IHQgPiAxKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoZGlyZWN0aW9uKS5tdWx0aXBseVNjYWxhcih0KS5hZGQobGluZS5zdGFydCk7XG5cdFx0fVxuXG5cdFx0aW50ZXJzZWN0c0xpbmUobGluZSkge1xuXHRcdFx0Ly8gTm90ZTogdGhpcyB0ZXN0cyBpZiBhIGxpbmUgaW50ZXJzZWN0cyB0aGUgcGxhbmUsIG5vdCB3aGV0aGVyIGl0IChvciBpdHMgZW5kLXBvaW50cykgYXJlIGNvcGxhbmFyIHdpdGggaXQuXG5cdFx0XHRjb25zdCBzdGFydFNpZ24gPSB0aGlzLmRpc3RhbmNlVG9Qb2ludChsaW5lLnN0YXJ0KTtcblx0XHRcdGNvbnN0IGVuZFNpZ24gPSB0aGlzLmRpc3RhbmNlVG9Qb2ludChsaW5lLmVuZCk7XG5cdFx0XHRyZXR1cm4gc3RhcnRTaWduIDwgMCAmJiBlbmRTaWduID4gMCB8fCBlbmRTaWduIDwgMCAmJiBzdGFydFNpZ24gPiAwO1xuXHRcdH1cblxuXHRcdGludGVyc2VjdHNCb3goYm94KSB7XG5cdFx0XHRyZXR1cm4gYm94LmludGVyc2VjdHNQbGFuZSh0aGlzKTtcblx0XHR9XG5cblx0XHRpbnRlcnNlY3RzU3BoZXJlKHNwaGVyZSkge1xuXHRcdFx0cmV0dXJuIHNwaGVyZS5pbnRlcnNlY3RzUGxhbmUodGhpcyk7XG5cdFx0fVxuXG5cdFx0Y29wbGFuYXJQb2ludCh0YXJnZXQpIHtcblx0XHRcdHJldHVybiB0YXJnZXQuY29weSh0aGlzLm5vcm1hbCkubXVsdGlwbHlTY2FsYXIoLXRoaXMuY29uc3RhbnQpO1xuXHRcdH1cblxuXHRcdGFwcGx5TWF0cml4NChtYXRyaXgsIG9wdGlvbmFsTm9ybWFsTWF0cml4KSB7XG5cdFx0XHRjb25zdCBub3JtYWxNYXRyaXggPSBvcHRpb25hbE5vcm1hbE1hdHJpeCB8fCBfbm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeChtYXRyaXgpO1xuXG5cdFx0XHRjb25zdCByZWZlcmVuY2VQb2ludCA9IHRoaXMuY29wbGFuYXJQb2ludChfdmVjdG9yMSkuYXBwbHlNYXRyaXg0KG1hdHJpeCk7XG5cdFx0XHRjb25zdCBub3JtYWwgPSB0aGlzLm5vcm1hbC5hcHBseU1hdHJpeDMobm9ybWFsTWF0cml4KS5ub3JtYWxpemUoKTtcblx0XHRcdHRoaXMuY29uc3RhbnQgPSAtcmVmZXJlbmNlUG9pbnQuZG90KG5vcm1hbCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0cmFuc2xhdGUob2Zmc2V0KSB7XG5cdFx0XHR0aGlzLmNvbnN0YW50IC09IG9mZnNldC5kb3QodGhpcy5ub3JtYWwpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZXF1YWxzKHBsYW5lKSB7XG5cdFx0XHRyZXR1cm4gcGxhbmUubm9ybWFsLmVxdWFscyh0aGlzLm5vcm1hbCkgJiYgcGxhbmUuY29uc3RhbnQgPT09IHRoaXMuY29uc3RhbnQ7XG5cdFx0fVxuXG5cdFx0Y2xvbmUoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpO1xuXHRcdH1cblxuXHR9XG5cblx0UGxhbmUucHJvdG90eXBlLmlzUGxhbmUgPSB0cnVlO1xuXG5cdGNvbnN0IF9zcGhlcmUkMiA9IC8qQF9fUFVSRV9fKi9uZXcgU3BoZXJlKCk7XG5cblx0Y29uc3QgX3ZlY3RvciQ3ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y2xhc3MgRnJ1c3R1bSB7XG5cdFx0Y29uc3RydWN0b3IocDAgPSBuZXcgUGxhbmUoKSwgcDEgPSBuZXcgUGxhbmUoKSwgcDIgPSBuZXcgUGxhbmUoKSwgcDMgPSBuZXcgUGxhbmUoKSwgcDQgPSBuZXcgUGxhbmUoKSwgcDUgPSBuZXcgUGxhbmUoKSkge1xuXHRcdFx0dGhpcy5wbGFuZXMgPSBbcDAsIHAxLCBwMiwgcDMsIHA0LCBwNV07XG5cdFx0fVxuXG5cdFx0c2V0KHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUpIHtcblx0XHRcdGNvbnN0IHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXHRcdFx0cGxhbmVzWzBdLmNvcHkocDApO1xuXHRcdFx0cGxhbmVzWzFdLmNvcHkocDEpO1xuXHRcdFx0cGxhbmVzWzJdLmNvcHkocDIpO1xuXHRcdFx0cGxhbmVzWzNdLmNvcHkocDMpO1xuXHRcdFx0cGxhbmVzWzRdLmNvcHkocDQpO1xuXHRcdFx0cGxhbmVzWzVdLmNvcHkocDUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29weShmcnVzdHVtKSB7XG5cdFx0XHRjb25zdCBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcblx0XHRcdFx0cGxhbmVzW2ldLmNvcHkoZnJ1c3R1bS5wbGFuZXNbaV0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRGcm9tUHJvamVjdGlvbk1hdHJpeChtKSB7XG5cdFx0XHRjb25zdCBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblx0XHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblx0XHRcdGNvbnN0IG1lMCA9IG1lWzBdLFxuXHRcdFx0XHRcdFx0bWUxID0gbWVbMV0sXG5cdFx0XHRcdFx0XHRtZTIgPSBtZVsyXSxcblx0XHRcdFx0XHRcdG1lMyA9IG1lWzNdO1xuXHRcdFx0Y29uc3QgbWU0ID0gbWVbNF0sXG5cdFx0XHRcdFx0XHRtZTUgPSBtZVs1XSxcblx0XHRcdFx0XHRcdG1lNiA9IG1lWzZdLFxuXHRcdFx0XHRcdFx0bWU3ID0gbWVbN107XG5cdFx0XHRjb25zdCBtZTggPSBtZVs4XSxcblx0XHRcdFx0XHRcdG1lOSA9IG1lWzldLFxuXHRcdFx0XHRcdFx0bWUxMCA9IG1lWzEwXSxcblx0XHRcdFx0XHRcdG1lMTEgPSBtZVsxMV07XG5cdFx0XHRjb25zdCBtZTEyID0gbWVbMTJdLFxuXHRcdFx0XHRcdFx0bWUxMyA9IG1lWzEzXSxcblx0XHRcdFx0XHRcdG1lMTQgPSBtZVsxNF0sXG5cdFx0XHRcdFx0XHRtZTE1ID0gbWVbMTVdO1xuXHRcdFx0cGxhbmVzWzBdLnNldENvbXBvbmVudHMobWUzIC0gbWUwLCBtZTcgLSBtZTQsIG1lMTEgLSBtZTgsIG1lMTUgLSBtZTEyKS5ub3JtYWxpemUoKTtcblx0XHRcdHBsYW5lc1sxXS5zZXRDb21wb25lbnRzKG1lMyArIG1lMCwgbWU3ICsgbWU0LCBtZTExICsgbWU4LCBtZTE1ICsgbWUxMikubm9ybWFsaXplKCk7XG5cdFx0XHRwbGFuZXNbMl0uc2V0Q29tcG9uZW50cyhtZTMgKyBtZTEsIG1lNyArIG1lNSwgbWUxMSArIG1lOSwgbWUxNSArIG1lMTMpLm5vcm1hbGl6ZSgpO1xuXHRcdFx0cGxhbmVzWzNdLnNldENvbXBvbmVudHMobWUzIC0gbWUxLCBtZTcgLSBtZTUsIG1lMTEgLSBtZTksIG1lMTUgLSBtZTEzKS5ub3JtYWxpemUoKTtcblx0XHRcdHBsYW5lc1s0XS5zZXRDb21wb25lbnRzKG1lMyAtIG1lMiwgbWU3IC0gbWU2LCBtZTExIC0gbWUxMCwgbWUxNSAtIG1lMTQpLm5vcm1hbGl6ZSgpO1xuXHRcdFx0cGxhbmVzWzVdLnNldENvbXBvbmVudHMobWUzICsgbWUyLCBtZTcgKyBtZTYsIG1lMTEgKyBtZTEwLCBtZTE1ICsgbWUxNCkubm9ybWFsaXplKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpbnRlcnNlY3RzT2JqZWN0KG9iamVjdCkge1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cdFx0XHRpZiAoZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwpIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0XHRfc3BoZXJlJDIuY29weShnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSkuYXBwbHlNYXRyaXg0KG9iamVjdC5tYXRyaXhXb3JsZCk7XG5cblx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoX3NwaGVyZSQyKTtcblx0XHR9XG5cblx0XHRpbnRlcnNlY3RzU3ByaXRlKHNwcml0ZSkge1xuXHRcdFx0X3NwaGVyZSQyLmNlbnRlci5zZXQoMCwgMCwgMCk7XG5cblx0XHRcdF9zcGhlcmUkMi5yYWRpdXMgPSAwLjcwNzEwNjc4MTE4NjU0NzY7XG5cblx0XHRcdF9zcGhlcmUkMi5hcHBseU1hdHJpeDQoc3ByaXRlLm1hdHJpeFdvcmxkKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZShfc3BoZXJlJDIpO1xuXHRcdH1cblxuXHRcdGludGVyc2VjdHNTcGhlcmUoc3BoZXJlKSB7XG5cdFx0XHRjb25zdCBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblx0XHRcdGNvbnN0IGNlbnRlciA9IHNwaGVyZS5jZW50ZXI7XG5cdFx0XHRjb25zdCBuZWdSYWRpdXMgPSAtc3BoZXJlLnJhZGl1cztcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcblx0XHRcdFx0Y29uc3QgZGlzdGFuY2UgPSBwbGFuZXNbaV0uZGlzdGFuY2VUb1BvaW50KGNlbnRlcik7XG5cblx0XHRcdFx0aWYgKGRpc3RhbmNlIDwgbmVnUmFkaXVzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGludGVyc2VjdHNCb3goYm94KSB7XG5cdFx0XHRjb25zdCBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcblx0XHRcdFx0Y29uc3QgcGxhbmUgPSBwbGFuZXNbaV07IC8vIGNvcm5lciBhdCBtYXggZGlzdGFuY2VcblxuXHRcdFx0XHRfdmVjdG9yJDcueCA9IHBsYW5lLm5vcm1hbC54ID4gMCA/IGJveC5tYXgueCA6IGJveC5taW4ueDtcblx0XHRcdFx0X3ZlY3RvciQ3LnkgPSBwbGFuZS5ub3JtYWwueSA+IDAgPyBib3gubWF4LnkgOiBib3gubWluLnk7XG5cdFx0XHRcdF92ZWN0b3IkNy56ID0gcGxhbmUubm9ybWFsLnogPiAwID8gYm94Lm1heC56IDogYm94Lm1pbi56O1xuXG5cdFx0XHRcdGlmIChwbGFuZS5kaXN0YW5jZVRvUG9pbnQoX3ZlY3RvciQ3KSA8IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Y29udGFpbnNQb2ludChwb2ludCkge1xuXHRcdFx0Y29uc3QgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG5cdFx0XHRcdGlmIChwbGFuZXNbaV0uZGlzdGFuY2VUb1BvaW50KHBvaW50KSA8IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Y2xvbmUoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpO1xuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gV2ViR0xBbmltYXRpb24oKSB7XG5cdFx0bGV0IGNvbnRleHQgPSBudWxsO1xuXHRcdGxldCBpc0FuaW1hdGluZyA9IGZhbHNlO1xuXHRcdGxldCBhbmltYXRpb25Mb29wID0gbnVsbDtcblx0XHRsZXQgcmVxdWVzdElkID0gbnVsbDtcblxuXHRcdGZ1bmN0aW9uIG9uQW5pbWF0aW9uRnJhbWUodGltZSwgZnJhbWUpIHtcblx0XHRcdGFuaW1hdGlvbkxvb3AodGltZSwgZnJhbWUpO1xuXHRcdFx0cmVxdWVzdElkID0gY29udGV4dC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUob25BbmltYXRpb25GcmFtZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmIChpc0FuaW1hdGluZyA9PT0gdHJ1ZSkgcmV0dXJuO1xuXHRcdFx0XHRpZiAoYW5pbWF0aW9uTG9vcCA9PT0gbnVsbCkgcmV0dXJuO1xuXHRcdFx0XHRyZXF1ZXN0SWQgPSBjb250ZXh0LnJlcXVlc3RBbmltYXRpb25GcmFtZShvbkFuaW1hdGlvbkZyYW1lKTtcblx0XHRcdFx0aXNBbmltYXRpbmcgPSB0cnVlO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29udGV4dC5jYW5jZWxBbmltYXRpb25GcmFtZShyZXF1ZXN0SWQpO1xuXHRcdFx0XHRpc0FuaW1hdGluZyA9IGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdHNldEFuaW1hdGlvbkxvb3A6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0XHRhbmltYXRpb25Mb29wID0gY2FsbGJhY2s7XG5cdFx0XHR9LFxuXHRcdFx0c2V0Q29udGV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGNvbnRleHQgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gV2ViR0xBdHRyaWJ1dGVzKGdsLCBjYXBhYmlsaXRpZXMpIHtcblx0XHRjb25zdCBpc1dlYkdMMiA9IGNhcGFiaWxpdGllcy5pc1dlYkdMMjtcblx0XHRjb25zdCBidWZmZXJzID0gbmV3IFdlYWtNYXAoKTtcblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlcihhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUpIHtcblx0XHRcdGNvbnN0IGFycmF5ID0gYXR0cmlidXRlLmFycmF5O1xuXHRcdFx0Y29uc3QgdXNhZ2UgPSBhdHRyaWJ1dGUudXNhZ2U7XG5cdFx0XHRjb25zdCBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblx0XHRcdGdsLmJpbmRCdWZmZXIoYnVmZmVyVHlwZSwgYnVmZmVyKTtcblx0XHRcdGdsLmJ1ZmZlckRhdGEoYnVmZmVyVHlwZSwgYXJyYXksIHVzYWdlKTtcblx0XHRcdGF0dHJpYnV0ZS5vblVwbG9hZENhbGxiYWNrKCk7XG5cdFx0XHRsZXQgdHlwZSA9IGdsLkZMT0FUO1xuXG5cdFx0XHRpZiAoYXJyYXkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcblx0XHRcdFx0dHlwZSA9IGdsLkZMT0FUO1xuXHRcdFx0fSBlbHNlIGlmIChhcnJheSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMQXR0cmlidXRlczogVW5zdXBwb3J0ZWQgZGF0YSBidWZmZXIgZm9ybWF0OiBGbG9hdDY0QXJyYXkuJyk7XG5cdFx0XHR9IGVsc2UgaWYgKGFycmF5IGluc3RhbmNlb2YgVWludDE2QXJyYXkpIHtcblx0XHRcdFx0aWYgKGF0dHJpYnV0ZS5pc0Zsb2F0MTZCdWZmZXJBdHRyaWJ1dGUpIHtcblx0XHRcdFx0XHRpZiAoaXNXZWJHTDIpIHtcblx0XHRcdFx0XHRcdHR5cGUgPSBnbC5IQUxGX0ZMT0FUO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMQXR0cmlidXRlczogVXNhZ2Ugb2YgRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSByZXF1aXJlcyBXZWJHTDIuJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9TSE9SVDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChhcnJheSBpbnN0YW5jZW9mIEludDE2QXJyYXkpIHtcblx0XHRcdFx0dHlwZSA9IGdsLlNIT1JUO1xuXHRcdFx0fSBlbHNlIGlmIChhcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSB7XG5cdFx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9JTlQ7XG5cdFx0XHR9IGVsc2UgaWYgKGFycmF5IGluc3RhbmNlb2YgSW50MzJBcnJheSkge1xuXHRcdFx0XHR0eXBlID0gZ2wuSU5UO1xuXHRcdFx0fSBlbHNlIGlmIChhcnJheSBpbnN0YW5jZW9mIEludDhBcnJheSkge1xuXHRcdFx0XHR0eXBlID0gZ2wuQllURTtcblx0XHRcdH0gZWxzZSBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG5cdFx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFO1xuXHRcdFx0fSBlbHNlIGlmIChhcnJheSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB7XG5cdFx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRidWZmZXI6IGJ1ZmZlcixcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0Ynl0ZXNQZXJFbGVtZW50OiBhcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcblx0XHRcdFx0dmVyc2lvbjogYXR0cmlidXRlLnZlcnNpb25cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlQnVmZmVyKGJ1ZmZlciwgYXR0cmlidXRlLCBidWZmZXJUeXBlKSB7XG5cdFx0XHRjb25zdCBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcblx0XHRcdGNvbnN0IHVwZGF0ZVJhbmdlID0gYXR0cmlidXRlLnVwZGF0ZVJhbmdlO1xuXHRcdFx0Z2wuYmluZEJ1ZmZlcihidWZmZXJUeXBlLCBidWZmZXIpO1xuXG5cdFx0XHRpZiAodXBkYXRlUmFuZ2UuY291bnQgPT09IC0xKSB7XG5cdFx0XHRcdC8vIE5vdCB1c2luZyB1cGRhdGUgcmFuZ2VzXG5cdFx0XHRcdGdsLmJ1ZmZlclN1YkRhdGEoYnVmZmVyVHlwZSwgMCwgYXJyYXkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGlzV2ViR0wyKSB7XG5cdFx0XHRcdFx0Z2wuYnVmZmVyU3ViRGF0YShidWZmZXJUeXBlLCB1cGRhdGVSYW5nZS5vZmZzZXQgKiBhcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgYXJyYXksIHVwZGF0ZVJhbmdlLm9mZnNldCwgdXBkYXRlUmFuZ2UuY291bnQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGdsLmJ1ZmZlclN1YkRhdGEoYnVmZmVyVHlwZSwgdXBkYXRlUmFuZ2Uub2Zmc2V0ICogYXJyYXkuQllURVNfUEVSX0VMRU1FTlQsIGFycmF5LnN1YmFycmF5KHVwZGF0ZVJhbmdlLm9mZnNldCwgdXBkYXRlUmFuZ2Uub2Zmc2V0ICsgdXBkYXRlUmFuZ2UuY291bnQpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHVwZGF0ZVJhbmdlLmNvdW50ID0gLTE7IC8vIHJlc2V0IHJhbmdlXG5cdFx0XHR9XG5cdFx0fSAvL1xuXG5cblx0XHRmdW5jdGlvbiBnZXQoYXR0cmlidXRlKSB7XG5cdFx0XHRpZiAoYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUpIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZS5kYXRhO1xuXHRcdFx0cmV0dXJuIGJ1ZmZlcnMuZ2V0KGF0dHJpYnV0ZSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlKGF0dHJpYnV0ZSkge1xuXHRcdFx0aWYgKGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKSBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGUuZGF0YTtcblx0XHRcdGNvbnN0IGRhdGEgPSBidWZmZXJzLmdldChhdHRyaWJ1dGUpO1xuXG5cdFx0XHRpZiAoZGF0YSkge1xuXHRcdFx0XHRnbC5kZWxldGVCdWZmZXIoZGF0YS5idWZmZXIpO1xuXHRcdFx0XHRidWZmZXJzLmRlbGV0ZShhdHRyaWJ1dGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZShhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUpIHtcblx0XHRcdGlmIChhdHRyaWJ1dGUuaXNHTEJ1ZmZlckF0dHJpYnV0ZSkge1xuXHRcdFx0XHRjb25zdCBjYWNoZWQgPSBidWZmZXJzLmdldChhdHRyaWJ1dGUpO1xuXG5cdFx0XHRcdGlmICghY2FjaGVkIHx8IGNhY2hlZC52ZXJzaW9uIDwgYXR0cmlidXRlLnZlcnNpb24pIHtcblx0XHRcdFx0XHRidWZmZXJzLnNldChhdHRyaWJ1dGUsIHtcblx0XHRcdFx0XHRcdGJ1ZmZlcjogYXR0cmlidXRlLmJ1ZmZlcixcblx0XHRcdFx0XHRcdHR5cGU6IGF0dHJpYnV0ZS50eXBlLFxuXHRcdFx0XHRcdFx0Ynl0ZXNQZXJFbGVtZW50OiBhdHRyaWJ1dGUuZWxlbWVudFNpemUsXG5cdFx0XHRcdFx0XHR2ZXJzaW9uOiBhdHRyaWJ1dGUudmVyc2lvblxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUpIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZS5kYXRhO1xuXHRcdFx0Y29uc3QgZGF0YSA9IGJ1ZmZlcnMuZ2V0KGF0dHJpYnV0ZSk7XG5cblx0XHRcdGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0YnVmZmVycy5zZXQoYXR0cmlidXRlLCBjcmVhdGVCdWZmZXIoYXR0cmlidXRlLCBidWZmZXJUeXBlKSk7XG5cdFx0XHR9IGVsc2UgaWYgKGRhdGEudmVyc2lvbiA8IGF0dHJpYnV0ZS52ZXJzaW9uKSB7XG5cdFx0XHRcdHVwZGF0ZUJ1ZmZlcihkYXRhLmJ1ZmZlciwgYXR0cmlidXRlLCBidWZmZXJUeXBlKTtcblx0XHRcdFx0ZGF0YS52ZXJzaW9uID0gYXR0cmlidXRlLnZlcnNpb247XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGdldDogZ2V0LFxuXHRcdFx0cmVtb3ZlOiByZW1vdmUsXG5cdFx0XHR1cGRhdGU6IHVwZGF0ZVxuXHRcdH07XG5cdH1cblxuXHRjbGFzcyBQbGFuZUdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXHRcdGNvbnN0cnVjdG9yKHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgd2lkdGhTZWdtZW50cyA9IDEsIGhlaWdodFNlZ21lbnRzID0gMSkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdQbGFuZUdlb21ldHJ5Jztcblx0XHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRcdFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcblx0XHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzXG5cdFx0XHR9O1xuXHRcdFx0Y29uc3Qgd2lkdGhfaGFsZiA9IHdpZHRoIC8gMjtcblx0XHRcdGNvbnN0IGhlaWdodF9oYWxmID0gaGVpZ2h0IC8gMjtcblx0XHRcdGNvbnN0IGdyaWRYID0gTWF0aC5mbG9vcih3aWR0aFNlZ21lbnRzKTtcblx0XHRcdGNvbnN0IGdyaWRZID0gTWF0aC5mbG9vcihoZWlnaHRTZWdtZW50cyk7XG5cdFx0XHRjb25zdCBncmlkWDEgPSBncmlkWCArIDE7XG5cdFx0XHRjb25zdCBncmlkWTEgPSBncmlkWSArIDE7XG5cdFx0XHRjb25zdCBzZWdtZW50X3dpZHRoID0gd2lkdGggLyBncmlkWDtcblx0XHRcdGNvbnN0IHNlZ21lbnRfaGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFk7IC8vXG5cblx0XHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblx0XHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0XHRjb25zdCB1dnMgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaXkgPSAwOyBpeSA8IGdyaWRZMTsgaXkrKykge1xuXHRcdFx0XHRjb25zdCB5ID0gaXkgKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmO1xuXG5cdFx0XHRcdGZvciAobGV0IGl4ID0gMDsgaXggPCBncmlkWDE7IGl4KyspIHtcblx0XHRcdFx0XHRjb25zdCB4ID0gaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZjtcblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKHgsIC15LCAwKTtcblx0XHRcdFx0XHRub3JtYWxzLnB1c2goMCwgMCwgMSk7XG5cdFx0XHRcdFx0dXZzLnB1c2goaXggLyBncmlkWCk7XG5cdFx0XHRcdFx0dXZzLnB1c2goMSAtIGl5IC8gZ3JpZFkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAobGV0IGl5ID0gMDsgaXkgPCBncmlkWTsgaXkrKykge1xuXHRcdFx0XHRmb3IgKGxldCBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4KyspIHtcblx0XHRcdFx0XHRjb25zdCBhID0gaXggKyBncmlkWDEgKiBpeTtcblx0XHRcdFx0XHRjb25zdCBiID0gaXggKyBncmlkWDEgKiAoaXkgKyAxKTtcblx0XHRcdFx0XHRjb25zdCBjID0gaXggKyAxICsgZ3JpZFgxICogKGl5ICsgMSk7XG5cdFx0XHRcdFx0Y29uc3QgZCA9IGl4ICsgMSArIGdyaWRYMSAqIGl5O1xuXHRcdFx0XHRcdGluZGljZXMucHVzaChhLCBiLCBkKTtcblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goYiwgYywgZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zZXRJbmRleChpbmRpY2VzKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobm9ybWFscywgMykpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodXZzLCAyKSk7XG5cdFx0fVxuXG5cdFx0c3RhdGljIGZyb21KU09OKGRhdGEpIHtcblx0XHRcdHJldHVybiBuZXcgUGxhbmVHZW9tZXRyeShkYXRhLndpZHRoLCBkYXRhLmhlaWdodCwgZGF0YS53aWR0aFNlZ21lbnRzLCBkYXRhLmhlaWdodFNlZ21lbnRzKTtcblx0XHR9XG5cblx0fVxuXG5cdHZhciBhbHBoYW1hcF9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcdGRpZmZ1c2VDb2xvci5hICo9IHRleHR1cmUyRCggYWxwaGFNYXAsIHZVdiApLmc7XFxuI2VuZGlmXCI7XG5cblx0dmFyIGFscGhhbWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBhbHBoYU1hcDtcXG4jZW5kaWZcIjtcblxuXHR2YXIgYWxwaGF0ZXN0X2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0FMUEhBVEVTVFxcblxcdGlmICggZGlmZnVzZUNvbG9yLmEgPCBhbHBoYVRlc3QgKSBkaXNjYXJkO1xcbiNlbmRpZlwiO1xuXG5cdHZhciBhbHBoYXRlc3RfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9BTFBIQVRFU1RcXG5cXHR1bmlmb3JtIGZsb2F0IGFscGhhVGVzdDtcXG4jZW5kaWZcIjtcblxuXHR2YXIgYW9tYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQU9NQVBcXG5cXHRmbG9hdCBhbWJpZW50T2NjbHVzaW9uID0gKCB0ZXh0dXJlMkQoIGFvTWFwLCB2VXYyICkuciAtIDEuMCApICogYW9NYXBJbnRlbnNpdHkgKyAxLjA7XFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICo9IGFtYmllbnRPY2NsdXNpb247XFxuXFx0I2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiBkZWZpbmVkKCBTVEFOREFSRCApXFxuXFx0XFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIgKSApO1xcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKj0gY29tcHV0ZVNwZWN1bGFyT2NjbHVzaW9uKCBkb3ROViwgYW1iaWVudE9jY2x1c2lvbiwgbWF0ZXJpYWwucm91Z2huZXNzICk7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cblx0dmFyIGFvbWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQU9NQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBhb01hcDtcXG5cXHR1bmlmb3JtIGZsb2F0IGFvTWFwSW50ZW5zaXR5O1xcbiNlbmRpZlwiO1xuXG5cdHZhciBiZWdpbl92ZXJ0ZXggPSBcInZlYzMgdHJhbnNmb3JtZWQgPSB2ZWMzKCBwb3NpdGlvbiApO1wiO1xuXG5cdHZhciBiZWdpbm5vcm1hbF92ZXJ0ZXggPSBcInZlYzMgb2JqZWN0Tm9ybWFsID0gdmVjMyggbm9ybWFsICk7XFxuI2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0dmVjMyBvYmplY3RUYW5nZW50ID0gdmVjMyggdGFuZ2VudC54eXogKTtcXG4jZW5kaWZcIjtcblxuXHR2YXIgYnNkZnMgPSBcInZlYzMgQlJERl9MYW1iZXJ0KCBjb25zdCBpbiB2ZWMzIGRpZmZ1c2VDb2xvciApIHtcXG5cXHRyZXR1cm4gUkVDSVBST0NBTF9QSSAqIGRpZmZ1c2VDb2xvcjtcXG59XFxudmVjMyBGX1NjaGxpY2soIGNvbnN0IGluIHZlYzMgZjAsIGNvbnN0IGluIGZsb2F0IGY5MCwgY29uc3QgaW4gZmxvYXQgZG90VkggKSB7XFxuXFx0ZmxvYXQgZnJlc25lbCA9IGV4cDIoICggLSA1LjU1NDczICogZG90VkggLSA2Ljk4MzE2ICkgKiBkb3RWSCApO1xcblxcdHJldHVybiBmMCAqICggMS4wIC0gZnJlc25lbCApICsgKCBmOTAgKiBmcmVzbmVsICk7XFxufVxcbmZsb2F0IFZfR0dYX1NtaXRoQ29ycmVsYXRlZCggY29uc3QgaW4gZmxvYXQgYWxwaGEsIGNvbnN0IGluIGZsb2F0IGRvdE5MLCBjb25zdCBpbiBmbG9hdCBkb3ROViApIHtcXG5cXHRmbG9hdCBhMiA9IHBvdzIoIGFscGhhICk7XFxuXFx0ZmxvYXQgZ3YgPSBkb3ROTCAqIHNxcnQoIGEyICsgKCAxLjAgLSBhMiApICogcG93MiggZG90TlYgKSApO1xcblxcdGZsb2F0IGdsID0gZG90TlYgKiBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqIHBvdzIoIGRvdE5MICkgKTtcXG5cXHRyZXR1cm4gMC41IC8gbWF4KCBndiArIGdsLCBFUFNJTE9OICk7XFxufVxcbmZsb2F0IERfR0dYKCBjb25zdCBpbiBmbG9hdCBhbHBoYSwgY29uc3QgaW4gZmxvYXQgZG90TkggKSB7XFxuXFx0ZmxvYXQgYTIgPSBwb3cyKCBhbHBoYSApO1xcblxcdGZsb2F0IGRlbm9tID0gcG93MiggZG90TkggKSAqICggYTIgLSAxLjAgKSArIDEuMDtcXG5cXHRyZXR1cm4gUkVDSVBST0NBTF9QSSAqIGEyIC8gcG93MiggZGVub20gKTtcXG59XFxudmVjMyBCUkRGX0dHWCggY29uc3QgaW4gdmVjMyBsaWdodERpciwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gdmVjMyBmMCwgY29uc3QgaW4gZmxvYXQgZjkwLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0ZmxvYXQgYWxwaGEgPSBwb3cyKCByb3VnaG5lc3MgKTtcXG5cXHR2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGxpZ2h0RGlyICsgdmlld0RpciApO1xcblxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBsaWdodERpciApICk7XFxuXFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIHZpZXdEaXIgKSApO1xcblxcdGZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBoYWxmRGlyICkgKTtcXG5cXHRmbG9hdCBkb3RWSCA9IHNhdHVyYXRlKCBkb3QoIHZpZXdEaXIsIGhhbGZEaXIgKSApO1xcblxcdHZlYzMgRiA9IEZfU2NobGljayggZjAsIGY5MCwgZG90VkggKTtcXG5cXHRmbG9hdCBWID0gVl9HR1hfU21pdGhDb3JyZWxhdGVkKCBhbHBoYSwgZG90TkwsIGRvdE5WICk7XFxuXFx0ZmxvYXQgRCA9IERfR0dYKCBhbHBoYSwgZG90TkggKTtcXG5cXHRyZXR1cm4gRiAqICggViAqIEQgKTtcXG59XFxudmVjMiBMVENfVXYoIGNvbnN0IGluIHZlYzMgTiwgY29uc3QgaW4gdmVjMyBWLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0Y29uc3QgZmxvYXQgTFVUX1NJWkUgPSA2NC4wO1xcblxcdGNvbnN0IGZsb2F0IExVVF9TQ0FMRSA9ICggTFVUX1NJWkUgLSAxLjAgKSAvIExVVF9TSVpFO1xcblxcdGNvbnN0IGZsb2F0IExVVF9CSUFTID0gMC41IC8gTFVUX1NJWkU7XFxuXFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBOLCBWICkgKTtcXG5cXHR2ZWMyIHV2ID0gdmVjMiggcm91Z2huZXNzLCBzcXJ0KCAxLjAgLSBkb3ROViApICk7XFxuXFx0dXYgPSB1diAqIExVVF9TQ0FMRSArIExVVF9CSUFTO1xcblxcdHJldHVybiB1djtcXG59XFxuZmxvYXQgTFRDX0NsaXBwZWRTcGhlcmVGb3JtRmFjdG9yKCBjb25zdCBpbiB2ZWMzIGYgKSB7XFxuXFx0ZmxvYXQgbCA9IGxlbmd0aCggZiApO1xcblxcdHJldHVybiBtYXgoICggbCAqIGwgKyBmLnogKSAvICggbCArIDEuMCApLCAwLjAgKTtcXG59XFxudmVjMyBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvbnN0IGluIHZlYzMgdjEsIGNvbnN0IGluIHZlYzMgdjIgKSB7XFxuXFx0ZmxvYXQgeCA9IGRvdCggdjEsIHYyICk7XFxuXFx0ZmxvYXQgeSA9IGFicyggeCApO1xcblxcdGZsb2F0IGEgPSAwLjg1NDM5ODUgKyAoIDAuNDk2NTE1NSArIDAuMDE0NTIwNiAqIHkgKSAqIHk7XFxuXFx0ZmxvYXQgYiA9IDMuNDE3NTk0MCArICggNC4xNjE2NzI0ICsgeSApICogeTtcXG5cXHRmbG9hdCB2ID0gYSAvIGI7XFxuXFx0ZmxvYXQgdGhldGFfc2ludGhldGEgPSAoIHggPiAwLjAgKSA/IHYgOiAwLjUgKiBpbnZlcnNlc3FydCggbWF4KCAxLjAgLSB4ICogeCwgMWUtNyApICkgLSB2O1xcblxcdHJldHVybiBjcm9zcyggdjEsIHYyICkgKiB0aGV0YV9zaW50aGV0YTtcXG59XFxudmVjMyBMVENfRXZhbHVhdGUoIGNvbnN0IGluIHZlYzMgTiwgY29uc3QgaW4gdmVjMyBWLCBjb25zdCBpbiB2ZWMzIFAsIGNvbnN0IGluIG1hdDMgbUludiwgY29uc3QgaW4gdmVjMyByZWN0Q29vcmRzWyA0IF0gKSB7XFxuXFx0dmVjMyB2MSA9IHJlY3RDb29yZHNbIDEgXSAtIHJlY3RDb29yZHNbIDAgXTtcXG5cXHR2ZWMzIHYyID0gcmVjdENvb3Jkc1sgMyBdIC0gcmVjdENvb3Jkc1sgMCBdO1xcblxcdHZlYzMgbGlnaHROb3JtYWwgPSBjcm9zcyggdjEsIHYyICk7XFxuXFx0aWYoIGRvdCggbGlnaHROb3JtYWwsIFAgLSByZWN0Q29vcmRzWyAwIF0gKSA8IDAuMCApIHJldHVybiB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWMzIFQxLCBUMjtcXG5cXHRUMSA9IG5vcm1hbGl6ZSggViAtIE4gKiBkb3QoIFYsIE4gKSApO1xcblxcdFQyID0gLSBjcm9zcyggTiwgVDEgKTtcXG5cXHRtYXQzIG1hdCA9IG1JbnYgKiB0cmFuc3Bvc2VNYXQzKCBtYXQzKCBUMSwgVDIsIE4gKSApO1xcblxcdHZlYzMgY29vcmRzWyA0IF07XFxuXFx0Y29vcmRzWyAwIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDAgXSAtIFAgKTtcXG5cXHRjb29yZHNbIDEgXSA9IG1hdCAqICggcmVjdENvb3Jkc1sgMSBdIC0gUCApO1xcblxcdGNvb3Jkc1sgMiBdID0gbWF0ICogKCByZWN0Q29vcmRzWyAyIF0gLSBQICk7XFxuXFx0Y29vcmRzWyAzIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDMgXSAtIFAgKTtcXG5cXHRjb29yZHNbIDAgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAwIF0gKTtcXG5cXHRjb29yZHNbIDEgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAxIF0gKTtcXG5cXHRjb29yZHNbIDIgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAyIF0gKTtcXG5cXHRjb29yZHNbIDMgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAzIF0gKTtcXG5cXHR2ZWMzIHZlY3RvckZvcm1GYWN0b3IgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAwIF0sIGNvb3Jkc1sgMSBdICk7XFxuXFx0dmVjdG9yRm9ybUZhY3RvciArPSBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvb3Jkc1sgMSBdLCBjb29yZHNbIDIgXSApO1xcblxcdHZlY3RvckZvcm1GYWN0b3IgKz0gTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb29yZHNbIDIgXSwgY29vcmRzWyAzIF0gKTtcXG5cXHR2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAzIF0sIGNvb3Jkc1sgMCBdICk7XFxuXFx0ZmxvYXQgcmVzdWx0ID0gTFRDX0NsaXBwZWRTcGhlcmVGb3JtRmFjdG9yKCB2ZWN0b3JGb3JtRmFjdG9yICk7XFxuXFx0cmV0dXJuIHZlYzMoIHJlc3VsdCApO1xcbn1cXG5mbG9hdCBHX0JsaW5uUGhvbmdfSW1wbGljaXQoICkge1xcblxcdHJldHVybiAwLjI1O1xcbn1cXG5mbG9hdCBEX0JsaW5uUGhvbmcoIGNvbnN0IGluIGZsb2F0IHNoaW5pbmVzcywgY29uc3QgaW4gZmxvYXQgZG90TkggKSB7XFxuXFx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiAoIHNoaW5pbmVzcyAqIDAuNSArIDEuMCApICogcG93KCBkb3ROSCwgc2hpbmluZXNzICk7XFxufVxcbnZlYzMgQlJERl9CbGlublBob25nKCBjb25zdCBpbiB2ZWMzIGxpZ2h0RGlyLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNoaW5pbmVzcyApIHtcXG5cXHR2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGxpZ2h0RGlyICsgdmlld0RpciApO1xcblxcdGZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBoYWxmRGlyICkgKTtcXG5cXHRmbG9hdCBkb3RWSCA9IHNhdHVyYXRlKCBkb3QoIHZpZXdEaXIsIGhhbGZEaXIgKSApO1xcblxcdHZlYzMgRiA9IEZfU2NobGljayggc3BlY3VsYXJDb2xvciwgMS4wLCBkb3RWSCApO1xcblxcdGZsb2F0IEcgPSBHX0JsaW5uUGhvbmdfSW1wbGljaXQoICk7XFxuXFx0ZmxvYXQgRCA9IERfQmxpbm5QaG9uZyggc2hpbmluZXNzLCBkb3ROSCApO1xcblxcdHJldHVybiBGICogKCBHICogRCApO1xcbn1cXG4jaWYgZGVmaW5lZCggVVNFX1NIRUVOIClcXG5mbG9hdCBEX0NoYXJsaWUoIGZsb2F0IHJvdWdobmVzcywgZmxvYXQgZG90TkggKSB7XFxuXFx0ZmxvYXQgYWxwaGEgPSBwb3cyKCByb3VnaG5lc3MgKTtcXG5cXHRmbG9hdCBpbnZBbHBoYSA9IDEuMCAvIGFscGhhO1xcblxcdGZsb2F0IGNvczJoID0gZG90TkggKiBkb3ROSDtcXG5cXHRmbG9hdCBzaW4yaCA9IG1heCggMS4wIC0gY29zMmgsIDAuMDA3ODEyNSApO1xcblxcdHJldHVybiAoIDIuMCArIGludkFscGhhICkgKiBwb3coIHNpbjJoLCBpbnZBbHBoYSAqIDAuNSApIC8gKCAyLjAgKiBQSSApO1xcbn1cXG5mbG9hdCBWX05ldWJlbHQoIGZsb2F0IGRvdE5WLCBmbG9hdCBkb3ROTCApIHtcXG5cXHRyZXR1cm4gc2F0dXJhdGUoIDEuMCAvICggNC4wICogKCBkb3ROTCArIGRvdE5WIC0gZG90TkwgKiBkb3ROViApICkgKTtcXG59XFxudmVjMyBCUkRGX1NoZWVuKCBjb25zdCBpbiB2ZWMzIGxpZ2h0RGlyLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCB2ZWMzIHNoZWVuQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNoZWVuUm91Z2huZXNzICkge1xcblxcdHZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggbGlnaHREaXIgKyB2aWV3RGlyICk7XFxuXFx0ZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTtcXG5cXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7XFxuXFx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGhhbGZEaXIgKSApO1xcblxcdGZsb2F0IEQgPSBEX0NoYXJsaWUoIHNoZWVuUm91Z2huZXNzLCBkb3ROSCApO1xcblxcdGZsb2F0IFYgPSBWX05ldWJlbHQoIGRvdE5WLCBkb3ROTCApO1xcblxcdHJldHVybiBzaGVlbkNvbG9yICogKCBEICogViApO1xcbn1cXG4jZW5kaWZcIjtcblxuXHR2YXIgYnVtcG1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0JVTVBNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBidW1wTWFwO1xcblxcdHVuaWZvcm0gZmxvYXQgYnVtcFNjYWxlO1xcblxcdHZlYzIgZEhkeHlfZndkKCkge1xcblxcdFxcdHZlYzIgZFNUZHggPSBkRmR4KCB2VXYgKTtcXG5cXHRcXHR2ZWMyIGRTVGR5ID0gZEZkeSggdlV2ICk7XFxuXFx0XFx0ZmxvYXQgSGxsID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKS54O1xcblxcdFxcdGZsb2F0IGRCeCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHggKS54IC0gSGxsO1xcblxcdFxcdGZsb2F0IGRCeSA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHkgKS54IC0gSGxsO1xcblxcdFxcdHJldHVybiB2ZWMyKCBkQngsIGRCeSApO1xcblxcdH1cXG5cXHR2ZWMzIHBlcnR1cmJOb3JtYWxBcmIoIHZlYzMgc3VyZl9wb3MsIHZlYzMgc3VyZl9ub3JtLCB2ZWMyIGRIZHh5LCBmbG9hdCBmYWNlRGlyZWN0aW9uICkge1xcblxcdFxcdHZlYzMgdlNpZ21hWCA9IHZlYzMoIGRGZHgoIHN1cmZfcG9zLnggKSwgZEZkeCggc3VyZl9wb3MueSApLCBkRmR4KCBzdXJmX3Bvcy56ICkgKTtcXG5cXHRcXHR2ZWMzIHZTaWdtYVkgPSB2ZWMzKCBkRmR5KCBzdXJmX3Bvcy54ICksIGRGZHkoIHN1cmZfcG9zLnkgKSwgZEZkeSggc3VyZl9wb3MueiApICk7XFxuXFx0XFx0dmVjMyB2TiA9IHN1cmZfbm9ybTtcXG5cXHRcXHR2ZWMzIFIxID0gY3Jvc3MoIHZTaWdtYVksIHZOICk7XFxuXFx0XFx0dmVjMyBSMiA9IGNyb3NzKCB2TiwgdlNpZ21hWCApO1xcblxcdFxcdGZsb2F0IGZEZXQgPSBkb3QoIHZTaWdtYVgsIFIxICkgKiBmYWNlRGlyZWN0aW9uO1xcblxcdFxcdHZlYzMgdkdyYWQgPSBzaWduKCBmRGV0ICkgKiAoIGRIZHh5LnggKiBSMSArIGRIZHh5LnkgKiBSMiApO1xcblxcdFxcdHJldHVybiBub3JtYWxpemUoIGFicyggZkRldCApICogc3VyZl9ub3JtIC0gdkdyYWQgKTtcXG5cXHR9XFxuI2VuZGlmXCI7XG5cblx0dmFyIGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudCA9IFwiI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwXFxuXFx0dmVjNCBwbGFuZTtcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgVU5JT05fQ0xJUFBJTkdfUExBTkVTOyBpICsrICkge1xcblxcdFxcdHBsYW5lID0gY2xpcHBpbmdQbGFuZXNbIGkgXTtcXG5cXHRcXHRpZiAoIGRvdCggdkNsaXBQb3NpdGlvbiwgcGxhbmUueHl6ICkgPiBwbGFuZS53ICkgZGlzY2FyZDtcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG5cXHQjaWYgVU5JT05fQ0xJUFBJTkdfUExBTkVTIDwgTlVNX0NMSVBQSU5HX1BMQU5FU1xcblxcdFxcdGJvb2wgY2xpcHBlZCA9IHRydWU7XFxuXFx0XFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdFxcdGZvciAoIGludCBpID0gVU5JT05fQ0xJUFBJTkdfUExBTkVTOyBpIDwgTlVNX0NMSVBQSU5HX1BMQU5FUzsgaSArKyApIHtcXG5cXHRcXHRcXHRwbGFuZSA9IGNsaXBwaW5nUGxhbmVzWyBpIF07XFxuXFx0XFx0XFx0Y2xpcHBlZCA9ICggZG90KCB2Q2xpcFBvc2l0aW9uLCBwbGFuZS54eXogKSA+IHBsYW5lLncgKSAmJiBjbGlwcGVkO1xcblxcdFxcdH1cXG5cXHRcXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdFxcdGlmICggY2xpcHBlZCApIGRpc2NhcmQ7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cblx0dmFyIGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50ID0gXCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDBcXG5cXHR2YXJ5aW5nIHZlYzMgdkNsaXBQb3NpdGlvbjtcXG5cXHR1bmlmb3JtIHZlYzQgY2xpcHBpbmdQbGFuZXNbIE5VTV9DTElQUElOR19QTEFORVMgXTtcXG4jZW5kaWZcIjtcblxuXHR2YXIgY2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4ID0gXCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDBcXG5cXHR2YXJ5aW5nIHZlYzMgdkNsaXBQb3NpdGlvbjtcXG4jZW5kaWZcIjtcblxuXHR2YXIgY2xpcHBpbmdfcGxhbmVzX3ZlcnRleCA9IFwiI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwXFxuXFx0dkNsaXBQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxuI2VuZGlmXCI7XG5cblx0dmFyIGNvbG9yX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVVNFX0NPTE9SX0FMUEhBIClcXG5cXHRkaWZmdXNlQ29sb3IgKj0gdkNvbG9yO1xcbiNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApXFxuXFx0ZGlmZnVzZUNvbG9yLnJnYiAqPSB2Q29sb3I7XFxuI2VuZGlmXCI7XG5cblx0dmFyIGNvbG9yX3BhcnNfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBVU0VfQ09MT1JfQUxQSEEgKVxcblxcdHZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuI2VsaWYgZGVmaW5lZCggVVNFX0NPTE9SIClcXG5cXHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xcbiNlbmRpZlwiO1xuXG5cdHZhciBjb2xvcl9wYXJzX3ZlcnRleCA9IFwiI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApXFxuXFx0dmFyeWluZyB2ZWM0IHZDb2xvcjtcXG4jZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKSB8fCBkZWZpbmVkKCBVU0VfSU5TVEFOQ0lOR19DT0xPUiApXFxuXFx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcXG4jZW5kaWZcIjtcblxuXHR2YXIgY29sb3JfdmVydGV4ID0gXCIjaWYgZGVmaW5lZCggVVNFX0NPTE9SX0FMUEhBIClcXG5cXHR2Q29sb3IgPSB2ZWM0KCAxLjAgKTtcXG4jZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKSB8fCBkZWZpbmVkKCBVU0VfSU5TVEFOQ0lOR19DT0xPUiApXFxuXFx0dkNvbG9yID0gdmVjMyggMS4wICk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9DT0xPUlxcblxcdHZDb2xvciAqPSBjb2xvcjtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0lOU1RBTkNJTkdfQ09MT1JcXG5cXHR2Q29sb3IueHl6ICo9IGluc3RhbmNlQ29sb3IueHl6O1xcbiNlbmRpZlwiO1xuXG5cdHZhciBjb21tb24gPSBcIiNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1ODk3OTNcXG4jZGVmaW5lIFBJMiA2LjI4MzE4NTMwNzE3OTU4NlxcbiNkZWZpbmUgUElfSEFMRiAxLjU3MDc5NjMyNjc5NDg5NjZcXG4jZGVmaW5lIFJFQ0lQUk9DQUxfUEkgMC4zMTgzMDk4ODYxODM3OTA3XFxuI2RlZmluZSBSRUNJUFJPQ0FMX1BJMiAwLjE1OTE1NDk0MzA5MTg5NTM1XFxuI2RlZmluZSBFUFNJTE9OIDFlLTZcXG4jaWZuZGVmIHNhdHVyYXRlXFxuI2RlZmluZSBzYXR1cmF0ZSggYSApIGNsYW1wKCBhLCAwLjAsIDEuMCApXFxuI2VuZGlmXFxuI2RlZmluZSB3aGl0ZUNvbXBsZW1lbnQoIGEgKSAoIDEuMCAtIHNhdHVyYXRlKCBhICkgKVxcbmZsb2F0IHBvdzIoIGNvbnN0IGluIGZsb2F0IHggKSB7IHJldHVybiB4Kng7IH1cXG5mbG9hdCBwb3czKCBjb25zdCBpbiBmbG9hdCB4ICkgeyByZXR1cm4geCp4Kng7IH1cXG5mbG9hdCBwb3c0KCBjb25zdCBpbiBmbG9hdCB4ICkgeyBmbG9hdCB4MiA9IHgqeDsgcmV0dXJuIHgyKngyOyB9XFxuZmxvYXQgbWF4MyggY29uc3QgaW4gdmVjMyB2ICkgeyByZXR1cm4gbWF4KCBtYXgoIHYueCwgdi55ICksIHYueiApOyB9XFxuZmxvYXQgYXZlcmFnZSggY29uc3QgaW4gdmVjMyBjb2xvciApIHsgcmV0dXJuIGRvdCggY29sb3IsIHZlYzMoIDAuMzMzMyApICk7IH1cXG5oaWdocCBmbG9hdCByYW5kKCBjb25zdCBpbiB2ZWMyIHV2ICkge1xcblxcdGNvbnN0IGhpZ2hwIGZsb2F0IGEgPSAxMi45ODk4LCBiID0gNzguMjMzLCBjID0gNDM3NTguNTQ1MztcXG5cXHRoaWdocCBmbG9hdCBkdCA9IGRvdCggdXYueHksIHZlYzIoIGEsYiApICksIHNuID0gbW9kKCBkdCwgUEkgKTtcXG5cXHRyZXR1cm4gZnJhY3QoIHNpbiggc24gKSAqIGMgKTtcXG59XFxuI2lmZGVmIEhJR0hfUFJFQ0lTSU9OXFxuXFx0ZmxvYXQgcHJlY2lzaW9uU2FmZUxlbmd0aCggdmVjMyB2ICkgeyByZXR1cm4gbGVuZ3RoKCB2ICk7IH1cXG4jZWxzZVxcblxcdGZsb2F0IHByZWNpc2lvblNhZmVMZW5ndGgoIHZlYzMgdiApIHtcXG5cXHRcXHRmbG9hdCBtYXhDb21wb25lbnQgPSBtYXgzKCBhYnMoIHYgKSApO1xcblxcdFxcdHJldHVybiBsZW5ndGgoIHYgLyBtYXhDb21wb25lbnQgKSAqIG1heENvbXBvbmVudDtcXG5cXHR9XFxuI2VuZGlmXFxuc3RydWN0IEluY2lkZW50TGlnaHQge1xcblxcdHZlYzMgY29sb3I7XFxuXFx0dmVjMyBkaXJlY3Rpb247XFxuXFx0Ym9vbCB2aXNpYmxlO1xcbn07XFxuc3RydWN0IFJlZmxlY3RlZExpZ2h0IHtcXG5cXHR2ZWMzIGRpcmVjdERpZmZ1c2U7XFxuXFx0dmVjMyBkaXJlY3RTcGVjdWxhcjtcXG5cXHR2ZWMzIGluZGlyZWN0RGlmZnVzZTtcXG5cXHR2ZWMzIGluZGlyZWN0U3BlY3VsYXI7XFxufTtcXG5zdHJ1Y3QgR2VvbWV0cmljQ29udGV4dCB7XFxuXFx0dmVjMyBwb3NpdGlvbjtcXG5cXHR2ZWMzIG5vcm1hbDtcXG5cXHR2ZWMzIHZpZXdEaXI7XFxuI2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHR2ZWMzIGNsZWFyY29hdE5vcm1hbDtcXG4jZW5kaWZcXG59O1xcbnZlYzMgdHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7XFxuXFx0cmV0dXJuIG5vcm1hbGl6ZSggKCBtYXRyaXggKiB2ZWM0KCBkaXIsIDAuMCApICkueHl6ICk7XFxufVxcbnZlYzMgaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBkaXIsIGluIG1hdDQgbWF0cml4ICkge1xcblxcdHJldHVybiBub3JtYWxpemUoICggdmVjNCggZGlyLCAwLjAgKSAqIG1hdHJpeCApLnh5eiApO1xcbn1cXG5tYXQzIHRyYW5zcG9zZU1hdDMoIGNvbnN0IGluIG1hdDMgbSApIHtcXG5cXHRtYXQzIHRtcDtcXG5cXHR0bXBbIDAgXSA9IHZlYzMoIG1bIDAgXS54LCBtWyAxIF0ueCwgbVsgMiBdLnggKTtcXG5cXHR0bXBbIDEgXSA9IHZlYzMoIG1bIDAgXS55LCBtWyAxIF0ueSwgbVsgMiBdLnkgKTtcXG5cXHR0bXBbIDIgXSA9IHZlYzMoIG1bIDAgXS56LCBtWyAxIF0ueiwgbVsgMiBdLnogKTtcXG5cXHRyZXR1cm4gdG1wO1xcbn1cXG5mbG9hdCBsaW5lYXJUb1JlbGF0aXZlTHVtaW5hbmNlKCBjb25zdCBpbiB2ZWMzIGNvbG9yICkge1xcblxcdHZlYzMgd2VpZ2h0cyA9IHZlYzMoIDAuMjEyNiwgMC43MTUyLCAwLjA3MjIgKTtcXG5cXHRyZXR1cm4gZG90KCB3ZWlnaHRzLCBjb2xvci5yZ2IgKTtcXG59XFxuYm9vbCBpc1BlcnNwZWN0aXZlTWF0cml4KCBtYXQ0IG0gKSB7XFxuXFx0cmV0dXJuIG1bIDIgXVsgMyBdID09IC0gMS4wO1xcbn1cXG52ZWMyIGVxdWlyZWN0VXYoIGluIHZlYzMgZGlyICkge1xcblxcdGZsb2F0IHUgPSBhdGFuKCBkaXIueiwgZGlyLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1xcblxcdGZsb2F0IHYgPSBhc2luKCBjbGFtcCggZGlyLnksIC0gMS4wLCAxLjAgKSApICogUkVDSVBST0NBTF9QSSArIDAuNTtcXG5cXHRyZXR1cm4gdmVjMiggdSwgdiApO1xcbn1cIjtcblxuXHR2YXIgY3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50ID0gXCIjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRV9VVlxcblxcdCNkZWZpbmUgY3ViZVVWX21heE1pcExldmVsIDguMFxcblxcdCNkZWZpbmUgY3ViZVVWX21pbk1pcExldmVsIDQuMFxcblxcdCNkZWZpbmUgY3ViZVVWX21heFRpbGVTaXplIDI1Ni4wXFxuXFx0I2RlZmluZSBjdWJlVVZfbWluVGlsZVNpemUgMTYuMFxcblxcdGZsb2F0IGdldEZhY2UoIHZlYzMgZGlyZWN0aW9uICkge1xcblxcdFxcdHZlYzMgYWJzRGlyZWN0aW9uID0gYWJzKCBkaXJlY3Rpb24gKTtcXG5cXHRcXHRmbG9hdCBmYWNlID0gLSAxLjA7XFxuXFx0XFx0aWYgKCBhYnNEaXJlY3Rpb24ueCA+IGFic0RpcmVjdGlvbi56ICkge1xcblxcdFxcdFxcdGlmICggYWJzRGlyZWN0aW9uLnggPiBhYnNEaXJlY3Rpb24ueSApXFxuXFx0XFx0XFx0XFx0ZmFjZSA9IGRpcmVjdGlvbi54ID4gMC4wID8gMC4wIDogMy4wO1xcblxcdFxcdFxcdGVsc2VcXG5cXHRcXHRcXHRcXHRmYWNlID0gZGlyZWN0aW9uLnkgPiAwLjAgPyAxLjAgOiA0LjA7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRpZiAoIGFic0RpcmVjdGlvbi56ID4gYWJzRGlyZWN0aW9uLnkgKVxcblxcdFxcdFxcdFxcdGZhY2UgPSBkaXJlY3Rpb24ueiA+IDAuMCA/IDIuMCA6IDUuMDtcXG5cXHRcXHRcXHRlbHNlXFxuXFx0XFx0XFx0XFx0ZmFjZSA9IGRpcmVjdGlvbi55ID4gMC4wID8gMS4wIDogNC4wO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gZmFjZTtcXG5cXHR9XFxuXFx0dmVjMiBnZXRVViggdmVjMyBkaXJlY3Rpb24sIGZsb2F0IGZhY2UgKSB7XFxuXFx0XFx0dmVjMiB1djtcXG5cXHRcXHRpZiAoIGZhY2UgPT0gMC4wICkge1xcblxcdFxcdFxcdHV2ID0gdmVjMiggZGlyZWN0aW9uLnosIGRpcmVjdGlvbi55ICkgLyBhYnMoIGRpcmVjdGlvbi54ICk7XFxuXFx0XFx0fSBlbHNlIGlmICggZmFjZSA9PSAxLjAgKSB7XFxuXFx0XFx0XFx0dXYgPSB2ZWMyKCAtIGRpcmVjdGlvbi54LCAtIGRpcmVjdGlvbi56ICkgLyBhYnMoIGRpcmVjdGlvbi55ICk7XFxuXFx0XFx0fSBlbHNlIGlmICggZmFjZSA9PSAyLjAgKSB7XFxuXFx0XFx0XFx0dXYgPSB2ZWMyKCAtIGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueSApIC8gYWJzKCBkaXJlY3Rpb24ueiApO1xcblxcdFxcdH0gZWxzZSBpZiAoIGZhY2UgPT0gMy4wICkge1xcblxcdFxcdFxcdHV2ID0gdmVjMiggLSBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnkgKSAvIGFicyggZGlyZWN0aW9uLnggKTtcXG5cXHRcXHR9IGVsc2UgaWYgKCBmYWNlID09IDQuMCApIHtcXG5cXHRcXHRcXHR1diA9IHZlYzIoIC0gZGlyZWN0aW9uLngsIGRpcmVjdGlvbi56ICkgLyBhYnMoIGRpcmVjdGlvbi55ICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR1diA9IHZlYzIoIGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueSApIC8gYWJzKCBkaXJlY3Rpb24ueiApO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gMC41ICogKCB1diArIDEuMCApO1xcblxcdH1cXG5cXHR2ZWMzIGJpbGluZWFyQ3ViZVVWKCBzYW1wbGVyMkQgZW52TWFwLCB2ZWMzIGRpcmVjdGlvbiwgZmxvYXQgbWlwSW50ICkge1xcblxcdFxcdGZsb2F0IGZhY2UgPSBnZXRGYWNlKCBkaXJlY3Rpb24gKTtcXG5cXHRcXHRmbG9hdCBmaWx0ZXJJbnQgPSBtYXgoIGN1YmVVVl9taW5NaXBMZXZlbCAtIG1pcEludCwgMC4wICk7XFxuXFx0XFx0bWlwSW50ID0gbWF4KCBtaXBJbnQsIGN1YmVVVl9taW5NaXBMZXZlbCApO1xcblxcdFxcdGZsb2F0IGZhY2VTaXplID0gZXhwMiggbWlwSW50ICk7XFxuXFx0XFx0ZmxvYXQgdGV4ZWxTaXplID0gMS4wIC8gKCAzLjAgKiBjdWJlVVZfbWF4VGlsZVNpemUgKTtcXG5cXHRcXHR2ZWMyIHV2ID0gZ2V0VVYoIGRpcmVjdGlvbiwgZmFjZSApICogKCBmYWNlU2l6ZSAtIDEuMCApO1xcblxcdFxcdHZlYzIgZiA9IGZyYWN0KCB1diApO1xcblxcdFxcdHV2ICs9IDAuNSAtIGY7XFxuXFx0XFx0aWYgKCBmYWNlID4gMi4wICkge1xcblxcdFxcdFxcdHV2LnkgKz0gZmFjZVNpemU7XFxuXFx0XFx0XFx0ZmFjZSAtPSAzLjA7XFxuXFx0XFx0fVxcblxcdFxcdHV2LnggKz0gZmFjZSAqIGZhY2VTaXplO1xcblxcdFxcdGlmICggbWlwSW50IDwgY3ViZVVWX21heE1pcExldmVsICkge1xcblxcdFxcdFxcdHV2LnkgKz0gMi4wICogY3ViZVVWX21heFRpbGVTaXplO1xcblxcdFxcdH1cXG5cXHRcXHR1di55ICs9IGZpbHRlckludCAqIDIuMCAqIGN1YmVVVl9taW5UaWxlU2l6ZTtcXG5cXHRcXHR1di54ICs9IDMuMCAqIG1heCggMC4wLCBjdWJlVVZfbWF4VGlsZVNpemUgLSAyLjAgKiBmYWNlU2l6ZSApO1xcblxcdFxcdHV2ICo9IHRleGVsU2l6ZTtcXG5cXHRcXHR2ZWMzIHRsID0gZW52TWFwVGV4ZWxUb0xpbmVhciggdGV4dHVyZTJEKCBlbnZNYXAsIHV2ICkgKS5yZ2I7XFxuXFx0XFx0dXYueCArPSB0ZXhlbFNpemU7XFxuXFx0XFx0dmVjMyB0ciA9IGVudk1hcFRleGVsVG9MaW5lYXIoIHRleHR1cmUyRCggZW52TWFwLCB1diApICkucmdiO1xcblxcdFxcdHV2LnkgKz0gdGV4ZWxTaXplO1xcblxcdFxcdHZlYzMgYnIgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCB0ZXh0dXJlMkQoIGVudk1hcCwgdXYgKSApLnJnYjtcXG5cXHRcXHR1di54IC09IHRleGVsU2l6ZTtcXG5cXHRcXHR2ZWMzIGJsID0gZW52TWFwVGV4ZWxUb0xpbmVhciggdGV4dHVyZTJEKCBlbnZNYXAsIHV2ICkgKS5yZ2I7XFxuXFx0XFx0dmVjMyB0bSA9IG1peCggdGwsIHRyLCBmLnggKTtcXG5cXHRcXHR2ZWMzIGJtID0gbWl4KCBibCwgYnIsIGYueCApO1xcblxcdFxcdHJldHVybiBtaXgoIHRtLCBibSwgZi55ICk7XFxuXFx0fVxcblxcdCNkZWZpbmUgcjAgMS4wXFxuXFx0I2RlZmluZSB2MCAwLjMzOVxcblxcdCNkZWZpbmUgbTAgLSAyLjBcXG5cXHQjZGVmaW5lIHIxIDAuOFxcblxcdCNkZWZpbmUgdjEgMC4yNzZcXG5cXHQjZGVmaW5lIG0xIC0gMS4wXFxuXFx0I2RlZmluZSByNCAwLjRcXG5cXHQjZGVmaW5lIHY0IDAuMDQ2XFxuXFx0I2RlZmluZSBtNCAyLjBcXG5cXHQjZGVmaW5lIHI1IDAuMzA1XFxuXFx0I2RlZmluZSB2NSAwLjAxNlxcblxcdCNkZWZpbmUgbTUgMy4wXFxuXFx0I2RlZmluZSByNiAwLjIxXFxuXFx0I2RlZmluZSB2NiAwLjAwMzhcXG5cXHQjZGVmaW5lIG02IDQuMFxcblxcdGZsb2F0IHJvdWdobmVzc1RvTWlwKCBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0XFx0ZmxvYXQgbWlwID0gMC4wO1xcblxcdFxcdGlmICggcm91Z2huZXNzID49IHIxICkge1xcblxcdFxcdFxcdG1pcCA9ICggcjAgLSByb3VnaG5lc3MgKSAqICggbTEgLSBtMCApIC8gKCByMCAtIHIxICkgKyBtMDtcXG5cXHRcXHR9IGVsc2UgaWYgKCByb3VnaG5lc3MgPj0gcjQgKSB7XFxuXFx0XFx0XFx0bWlwID0gKCByMSAtIHJvdWdobmVzcyApICogKCBtNCAtIG0xICkgLyAoIHIxIC0gcjQgKSArIG0xO1xcblxcdFxcdH0gZWxzZSBpZiAoIHJvdWdobmVzcyA+PSByNSApIHtcXG5cXHRcXHRcXHRtaXAgPSAoIHI0IC0gcm91Z2huZXNzICkgKiAoIG01IC0gbTQgKSAvICggcjQgLSByNSApICsgbTQ7XFxuXFx0XFx0fSBlbHNlIGlmICggcm91Z2huZXNzID49IHI2ICkge1xcblxcdFxcdFxcdG1pcCA9ICggcjUgLSByb3VnaG5lc3MgKSAqICggbTYgLSBtNSApIC8gKCByNSAtIHI2ICkgKyBtNTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdG1pcCA9IC0gMi4wICogbG9nMiggMS4xNiAqIHJvdWdobmVzcyApO1xcdFxcdH1cXG5cXHRcXHRyZXR1cm4gbWlwO1xcblxcdH1cXG5cXHR2ZWM0IHRleHR1cmVDdWJlVVYoIHNhbXBsZXIyRCBlbnZNYXAsIHZlYzMgc2FtcGxlRGlyLCBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0XFx0ZmxvYXQgbWlwID0gY2xhbXAoIHJvdWdobmVzc1RvTWlwKCByb3VnaG5lc3MgKSwgbTAsIGN1YmVVVl9tYXhNaXBMZXZlbCApO1xcblxcdFxcdGZsb2F0IG1pcEYgPSBmcmFjdCggbWlwICk7XFxuXFx0XFx0ZmxvYXQgbWlwSW50ID0gZmxvb3IoIG1pcCApO1xcblxcdFxcdHZlYzMgY29sb3IwID0gYmlsaW5lYXJDdWJlVVYoIGVudk1hcCwgc2FtcGxlRGlyLCBtaXBJbnQgKTtcXG5cXHRcXHRpZiAoIG1pcEYgPT0gMC4wICkge1xcblxcdFxcdFxcdHJldHVybiB2ZWM0KCBjb2xvcjAsIDEuMCApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0dmVjMyBjb2xvcjEgPSBiaWxpbmVhckN1YmVVViggZW52TWFwLCBzYW1wbGVEaXIsIG1pcEludCArIDEuMCApO1xcblxcdFxcdFxcdHJldHVybiB2ZWM0KCBtaXgoIGNvbG9yMCwgY29sb3IxLCBtaXBGICksIDEuMCApO1xcblxcdFxcdH1cXG5cXHR9XFxuI2VuZGlmXCI7XG5cblx0dmFyIGRlZmF1bHRub3JtYWxfdmVydGV4ID0gXCJ2ZWMzIHRyYW5zZm9ybWVkTm9ybWFsID0gb2JqZWN0Tm9ybWFsO1xcbiNpZmRlZiBVU0VfSU5TVEFOQ0lOR1xcblxcdG1hdDMgbSA9IG1hdDMoIGluc3RhbmNlTWF0cml4ICk7XFxuXFx0dHJhbnNmb3JtZWROb3JtYWwgLz0gdmVjMyggZG90KCBtWyAwIF0sIG1bIDAgXSApLCBkb3QoIG1bIDEgXSwgbVsgMSBdICksIGRvdCggbVsgMiBdLCBtWyAyIF0gKSApO1xcblxcdHRyYW5zZm9ybWVkTm9ybWFsID0gbSAqIHRyYW5zZm9ybWVkTm9ybWFsO1xcbiNlbmRpZlxcbnRyYW5zZm9ybWVkTm9ybWFsID0gbm9ybWFsTWF0cml4ICogdHJhbnNmb3JtZWROb3JtYWw7XFxuI2lmZGVmIEZMSVBfU0lERURcXG5cXHR0cmFuc2Zvcm1lZE5vcm1hbCA9IC0gdHJhbnNmb3JtZWROb3JtYWw7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0dmVjMyB0cmFuc2Zvcm1lZFRhbmdlbnQgPSAoIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIG9iamVjdFRhbmdlbnQsIDAuMCApICkueHl6O1xcblxcdCNpZmRlZiBGTElQX1NJREVEXFxuXFx0XFx0dHJhbnNmb3JtZWRUYW5nZW50ID0gLSB0cmFuc2Zvcm1lZFRhbmdlbnQ7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cblx0dmFyIGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBkaXNwbGFjZW1lbnRNYXA7XFxuXFx0dW5pZm9ybSBmbG9hdCBkaXNwbGFjZW1lbnRTY2FsZTtcXG5cXHR1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudEJpYXM7XFxuI2VuZGlmXCI7XG5cblx0dmFyIGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxuXFx0dHJhbnNmb3JtZWQgKz0gbm9ybWFsaXplKCBvYmplY3ROb3JtYWwgKSAqICggdGV4dHVyZTJEKCBkaXNwbGFjZW1lbnRNYXAsIHZVdiApLnggKiBkaXNwbGFjZW1lbnRTY2FsZSArIGRpc3BsYWNlbWVudEJpYXMgKTtcXG4jZW5kaWZcIjtcblxuXHR2YXIgZW1pc3NpdmVtYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfRU1JU1NJVkVNQVBcXG5cXHR2ZWM0IGVtaXNzaXZlQ29sb3IgPSB0ZXh0dXJlMkQoIGVtaXNzaXZlTWFwLCB2VXYgKTtcXG5cXHRlbWlzc2l2ZUNvbG9yLnJnYiA9IGVtaXNzaXZlTWFwVGV4ZWxUb0xpbmVhciggZW1pc3NpdmVDb2xvciApLnJnYjtcXG5cXHR0b3RhbEVtaXNzaXZlUmFkaWFuY2UgKj0gZW1pc3NpdmVDb2xvci5yZ2I7XFxuI2VuZGlmXCI7XG5cblx0dmFyIGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfRU1JU1NJVkVNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBlbWlzc2l2ZU1hcDtcXG4jZW5kaWZcIjtcblxuXHR2YXIgZW5jb2RpbmdzX2ZyYWdtZW50ID0gXCJnbF9GcmFnQ29sb3IgPSBsaW5lYXJUb091dHB1dFRleGVsKCBnbF9GcmFnQ29sb3IgKTtcIjtcblxuXHR2YXIgZW5jb2RpbmdzX3BhcnNfZnJhZ21lbnQgPSBcIlxcbnZlYzQgTGluZWFyVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUgKSB7XFxuXFx0cmV0dXJuIHZhbHVlO1xcbn1cXG52ZWM0IEdhbW1hVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUsIGluIGZsb2F0IGdhbW1hRmFjdG9yICkge1xcblxcdHJldHVybiB2ZWM0KCBwb3coIHZhbHVlLnJnYiwgdmVjMyggZ2FtbWFGYWN0b3IgKSApLCB2YWx1ZS5hICk7XFxufVxcbnZlYzQgTGluZWFyVG9HYW1tYSggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgZ2FtbWFGYWN0b3IgKSB7XFxuXFx0cmV0dXJuIHZlYzQoIHBvdyggdmFsdWUucmdiLCB2ZWMzKCAxLjAgLyBnYW1tYUZhY3RvciApICksIHZhbHVlLmEgKTtcXG59XFxudmVjNCBzUkdCVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUgKSB7XFxuXFx0cmV0dXJuIHZlYzQoIG1peCggcG93KCB2YWx1ZS5yZ2IgKiAwLjk0Nzg2NzI5ODYgKyB2ZWMzKCAwLjA1MjEzMjcwMTQgKSwgdmVjMyggMi40ICkgKSwgdmFsdWUucmdiICogMC4wNzczOTkzODA4LCB2ZWMzKCBsZXNzVGhhbkVxdWFsKCB2YWx1ZS5yZ2IsIHZlYzMoIDAuMDQwNDUgKSApICkgKSwgdmFsdWUuYSApO1xcbn1cXG52ZWM0IExpbmVhclRvc1JHQiggaW4gdmVjNCB2YWx1ZSApIHtcXG5cXHRyZXR1cm4gdmVjNCggbWl4KCBwb3coIHZhbHVlLnJnYiwgdmVjMyggMC40MTY2NiApICkgKiAxLjA1NSAtIHZlYzMoIDAuMDU1ICksIHZhbHVlLnJnYiAqIDEyLjkyLCB2ZWMzKCBsZXNzVGhhbkVxdWFsKCB2YWx1ZS5yZ2IsIHZlYzMoIDAuMDAzMTMwOCApICkgKSApLCB2YWx1ZS5hICk7XFxufVxcbnZlYzQgUkdCRVRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlICkge1xcblxcdHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgKiBleHAyKCB2YWx1ZS5hICogMjU1LjAgLSAxMjguMCApLCAxLjAgKTtcXG59XFxudmVjNCBMaW5lYXJUb1JHQkUoIGluIHZlYzQgdmFsdWUgKSB7XFxuXFx0ZmxvYXQgbWF4Q29tcG9uZW50ID0gbWF4KCBtYXgoIHZhbHVlLnIsIHZhbHVlLmcgKSwgdmFsdWUuYiApO1xcblxcdGZsb2F0IGZFeHAgPSBjbGFtcCggY2VpbCggbG9nMiggbWF4Q29tcG9uZW50ICkgKSwgLTEyOC4wLCAxMjcuMCApO1xcblxcdHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgLyBleHAyKCBmRXhwICksICggZkV4cCArIDEyOC4wICkgLyAyNTUuMCApO1xcbn1cXG52ZWM0IFJHQk1Ub0xpbmVhciggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgbWF4UmFuZ2UgKSB7XFxuXFx0cmV0dXJuIHZlYzQoIHZhbHVlLnJnYiAqIHZhbHVlLmEgKiBtYXhSYW5nZSwgMS4wICk7XFxufVxcbnZlYzQgTGluZWFyVG9SR0JNKCBpbiB2ZWM0IHZhbHVlLCBpbiBmbG9hdCBtYXhSYW5nZSApIHtcXG5cXHRmbG9hdCBtYXhSR0IgPSBtYXgoIHZhbHVlLnIsIG1heCggdmFsdWUuZywgdmFsdWUuYiApICk7XFxuXFx0ZmxvYXQgTSA9IGNsYW1wKCBtYXhSR0IgLyBtYXhSYW5nZSwgMC4wLCAxLjAgKTtcXG5cXHRNID0gY2VpbCggTSAqIDI1NS4wICkgLyAyNTUuMDtcXG5cXHRyZXR1cm4gdmVjNCggdmFsdWUucmdiIC8gKCBNICogbWF4UmFuZ2UgKSwgTSApO1xcbn1cXG52ZWM0IFJHQkRUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgbWF4UmFuZ2UgKSB7XFxuXFx0cmV0dXJuIHZlYzQoIHZhbHVlLnJnYiAqICggKCBtYXhSYW5nZSAvIDI1NS4wICkgLyB2YWx1ZS5hICksIDEuMCApO1xcbn1cXG52ZWM0IExpbmVhclRvUkdCRCggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgbWF4UmFuZ2UgKSB7XFxuXFx0ZmxvYXQgbWF4UkdCID0gbWF4KCB2YWx1ZS5yLCBtYXgoIHZhbHVlLmcsIHZhbHVlLmIgKSApO1xcblxcdGZsb2F0IEQgPSBtYXgoIG1heFJhbmdlIC8gbWF4UkdCLCAxLjAgKTtcXG5cXHREID0gY2xhbXAoIGZsb29yKCBEICkgLyAyNTUuMCwgMC4wLCAxLjAgKTtcXG5cXHRyZXR1cm4gdmVjNCggdmFsdWUucmdiICogKCBEICogKCAyNTUuMCAvIG1heFJhbmdlICkgKSwgRCApO1xcbn1cIjtcblxuXHR2YXIgZW52bWFwX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcdCNpZmRlZiBFTlZfV09STERQT1NcXG5cXHRcXHR2ZWMzIGNhbWVyYVRvRnJhZztcXG5cXHRcXHRpZiAoIGlzT3J0aG9ncmFwaGljICkge1xcblxcdFxcdFxcdGNhbWVyYVRvRnJhZyA9IG5vcm1hbGl6ZSggdmVjMyggLSB2aWV3TWF0cml4WyAwIF1bIDIgXSwgLSB2aWV3TWF0cml4WyAxIF1bIDIgXSwgLSB2aWV3TWF0cml4WyAyIF1bIDIgXSApICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRjYW1lcmFUb0ZyYWcgPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uIC0gY2FtZXJhUG9zaXRpb24gKTtcXG5cXHRcXHR9XFxuXFx0XFx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcdFxcdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxuXFx0XFx0XFx0dmVjMyByZWZsZWN0VmVjID0gcmVmbGVjdCggY2FtZXJhVG9GcmFnLCB3b3JsZE5vcm1hbCApO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0dmVjMyByZWZsZWN0VmVjID0gcmVmcmFjdCggY2FtZXJhVG9GcmFnLCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0I2Vsc2VcXG5cXHRcXHR2ZWMzIHJlZmxlY3RWZWMgPSB2UmVmbGVjdDtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblxcdFxcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCB2ZWMzKCBmbGlwRW52TWFwICogcmVmbGVjdFZlYy54LCByZWZsZWN0VmVjLnl6ICkgKTtcXG5cXHRcXHRlbnZDb2xvciA9IGVudk1hcFRleGVsVG9MaW5lYXIoIGVudkNvbG9yICk7XFxuXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApXFxuXFx0XFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmVDdWJlVVYoIGVudk1hcCwgcmVmbGVjdFZlYywgMC4wICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHR2ZWM0IGVudkNvbG9yID0gdmVjNCggMC4wICk7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIEVOVk1BUF9CTEVORElOR19NVUxUSVBMWVxcblxcdFxcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIG91dGdvaW5nTGlnaHQgKiBlbnZDb2xvci54eXosIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHkgKTtcXG5cXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfQkxFTkRJTkdfTUlYIClcXG5cXHRcXHRvdXRnb2luZ0xpZ2h0ID0gbWl4KCBvdXRnb2luZ0xpZ2h0LCBlbnZDb2xvci54eXosIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHkgKTtcXG5cXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfQkxFTkRJTkdfQUREIClcXG5cXHRcXHRvdXRnb2luZ0xpZ2h0ICs9IGVudkNvbG9yLnh5eiAqIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHk7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cblx0dmFyIGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXHR1bmlmb3JtIGZsb2F0IGVudk1hcEludGVuc2l0eTtcXG5cXHR1bmlmb3JtIGZsb2F0IGZsaXBFbnZNYXA7XFxuXFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcXG5cXHQjZWxzZVxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDtcXG5cXHQjZW5kaWZcXG5cXHRcXG4jZW5kaWZcIjtcblxuXHR2YXIgZW52bWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFx0dW5pZm9ybSBmbG9hdCByZWZsZWN0aXZpdHk7XFxuXFx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HIClcXG5cXHRcXHQjZGVmaW5lIEVOVl9XT1JMRFBPU1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBFTlZfV09STERQT1NcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuXFx0XFx0dW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XFxuXFx0I2Vsc2VcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cblx0dmFyIGVudm1hcF9wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXHQjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHxkZWZpbmVkKCBQSE9ORyApXFxuXFx0XFx0I2RlZmluZSBFTlZfV09STERQT1NcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgRU5WX1dPUkxEUE9TXFxuXFx0XFx0XFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcblxcdCNlbHNlXFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZSZWZsZWN0O1xcblxcdFxcdHVuaWZvcm0gZmxvYXQgcmVmcmFjdGlvblJhdGlvO1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG5cdHZhciBlbnZtYXBfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcdCNpZmRlZiBFTlZfV09STERQT1NcXG5cXHRcXHR2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1xcblxcdCNlbHNlXFxuXFx0XFx0dmVjMyBjYW1lcmFUb1ZlcnRleDtcXG5cXHRcXHRpZiAoIGlzT3J0aG9ncmFwaGljICkge1xcblxcdFxcdFxcdGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB2ZWMzKCAtIHZpZXdNYXRyaXhbIDAgXVsgMiBdLCAtIHZpZXdNYXRyaXhbIDEgXVsgMiBdLCAtIHZpZXdNYXRyaXhbIDIgXVsgMiBdICkgKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB3b3JsZFBvc2l0aW9uLnh5eiAtIGNhbWVyYVBvc2l0aW9uICk7XFxuXFx0XFx0fVxcblxcdFxcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCB0cmFuc2Zvcm1lZE5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcdFxcdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxuXFx0XFx0XFx0dlJlZmxlY3QgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHZSZWZsZWN0ID0gcmVmcmFjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxuXHR2YXIgZm9nX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9GT0dcXG5cXHR2Rm9nRGVwdGggPSAtIG12UG9zaXRpb24uejtcXG4jZW5kaWZcIjtcblxuXHR2YXIgZm9nX3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0ZPR1xcblxcdHZhcnlpbmcgZmxvYXQgdkZvZ0RlcHRoO1xcbiNlbmRpZlwiO1xuXG5cdHZhciBmb2dfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfRk9HXFxuXFx0I2lmZGVmIEZPR19FWFAyXFxuXFx0XFx0ZmxvYXQgZm9nRmFjdG9yID0gMS4wIC0gZXhwKCAtIGZvZ0RlbnNpdHkgKiBmb2dEZW5zaXR5ICogdkZvZ0RlcHRoICogdkZvZ0RlcHRoICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRmbG9hdCBmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIHZGb2dEZXB0aCApO1xcblxcdCNlbmRpZlxcblxcdGdsX0ZyYWdDb2xvci5yZ2IgPSBtaXgoIGdsX0ZyYWdDb2xvci5yZ2IsIGZvZ0NvbG9yLCBmb2dGYWN0b3IgKTtcXG4jZW5kaWZcIjtcblxuXHR2YXIgZm9nX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfRk9HXFxuXFx0dW5pZm9ybSB2ZWMzIGZvZ0NvbG9yO1xcblxcdHZhcnlpbmcgZmxvYXQgdkZvZ0RlcHRoO1xcblxcdCNpZmRlZiBGT0dfRVhQMlxcblxcdFxcdHVuaWZvcm0gZmxvYXQgZm9nRGVuc2l0eTtcXG5cXHQjZWxzZVxcblxcdFxcdHVuaWZvcm0gZmxvYXQgZm9nTmVhcjtcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IGZvZ0ZhcjtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxuXHR2YXIgZ3JhZGllbnRtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9HUkFESUVOVE1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGdyYWRpZW50TWFwO1xcbiNlbmRpZlxcbnZlYzMgZ2V0R3JhZGllbnRJcnJhZGlhbmNlKCB2ZWMzIG5vcm1hbCwgdmVjMyBsaWdodERpcmVjdGlvbiApIHtcXG5cXHRmbG9hdCBkb3ROTCA9IGRvdCggbm9ybWFsLCBsaWdodERpcmVjdGlvbiApO1xcblxcdHZlYzIgY29vcmQgPSB2ZWMyKCBkb3ROTCAqIDAuNSArIDAuNSwgMC4wICk7XFxuXFx0I2lmZGVmIFVTRV9HUkFESUVOVE1BUFxcblxcdFxcdHJldHVybiB0ZXh0dXJlMkQoIGdyYWRpZW50TWFwLCBjb29yZCApLnJnYjtcXG5cXHQjZWxzZVxcblxcdFxcdHJldHVybiAoIGNvb3JkLnggPCAwLjcgKSA/IHZlYzMoIDAuNyApIDogdmVjMyggMS4wICk7XFxuXFx0I2VuZGlmXFxufVwiO1xuXG5cdHZhciBsaWdodG1hcF9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcdHZlYzQgbGlnaHRNYXBUZXhlbCA9IHRleHR1cmUyRCggbGlnaHRNYXAsIHZVdjIgKTtcXG5cXHR2ZWMzIGxpZ2h0TWFwSXJyYWRpYW5jZSA9IGxpZ2h0TWFwVGV4ZWxUb0xpbmVhciggbGlnaHRNYXBUZXhlbCApLnJnYiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1xcblxcdCNpZm5kZWYgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUU1xcblxcdFxcdGxpZ2h0TWFwSXJyYWRpYW5jZSAqPSBQSTtcXG5cXHQjZW5kaWZcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gbGlnaHRNYXBJcnJhZGlhbmNlO1xcbiNlbmRpZlwiO1xuXG5cdHZhciBsaWdodG1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbGlnaHRNYXA7XFxuXFx0dW5pZm9ybSBmbG9hdCBsaWdodE1hcEludGVuc2l0eTtcXG4jZW5kaWZcIjtcblxuXHR2YXIgbGlnaHRzX2xhbWJlcnRfdmVydGV4ID0gXCJ2ZWMzIGRpZmZ1c2UgPSB2ZWMzKCAxLjAgKTtcXG5HZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5O1xcbmdlb21ldHJ5LnBvc2l0aW9uID0gbXZQb3NpdGlvbi54eXo7XFxuZ2VvbWV0cnkubm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcbmdlb21ldHJ5LnZpZXdEaXIgPSAoIGlzT3J0aG9ncmFwaGljICkgPyB2ZWMzKCAwLCAwLCAxICkgOiBub3JtYWxpemUoIC1tdlBvc2l0aW9uLnh5eiApO1xcbkdlb21ldHJpY0NvbnRleHQgYmFja0dlb21ldHJ5O1xcbmJhY2tHZW9tZXRyeS5wb3NpdGlvbiA9IGdlb21ldHJ5LnBvc2l0aW9uO1xcbmJhY2tHZW9tZXRyeS5ub3JtYWwgPSAtZ2VvbWV0cnkubm9ybWFsO1xcbmJhY2tHZW9tZXRyeS52aWV3RGlyID0gZ2VvbWV0cnkudmlld0RpcjtcXG52TGlnaHRGcm9udCA9IHZlYzMoIDAuMCApO1xcbnZJbmRpcmVjdEZyb250ID0gdmVjMyggMC4wICk7XFxuI2lmZGVmIERPVUJMRV9TSURFRFxcblxcdHZMaWdodEJhY2sgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2SW5kaXJlY3RCYWNrID0gdmVjMyggMC4wICk7XFxuI2VuZGlmXFxuSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodDtcXG5mbG9hdCBkb3ROTDtcXG52ZWMzIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG52SW5kaXJlY3RGcm9udCArPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApO1xcbnZJbmRpcmVjdEZyb250ICs9IGdldExpZ2h0UHJvYmVJcnJhZGlhbmNlKCBsaWdodFByb2JlLCBnZW9tZXRyeS5ub3JtYWwgKTtcXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0dkluZGlyZWN0QmFjayArPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApO1xcblxcdHZJbmRpcmVjdEJhY2sgKz0gZ2V0TGlnaHRQcm9iZUlycmFkaWFuY2UoIGxpZ2h0UHJvYmUsIGJhY2tHZW9tZXRyeS5ub3JtYWwgKTtcXG4jZW5kaWZcXG4jaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRnZXRQb2ludExpZ2h0SW5mbyggcG9pbnRMaWdodHNbIGkgXSwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxuXFx0XFx0ZG90TkwgPSBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICk7XFxuXFx0XFx0ZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlID0gZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0XFx0dkxpZ2h0RnJvbnQgKz0gc2F0dXJhdGUoIGRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxuXFx0XFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcdFxcdFxcdHZMaWdodEJhY2sgKz0gc2F0dXJhdGUoIC0gZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG4jZW5kaWZcXG4jaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0Z2V0U3BvdExpZ2h0SW5mbyggc3BvdExpZ2h0c1sgaSBdLCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXG5cXHRcXHRkb3ROTCA9IGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKTtcXG5cXHRcXHRkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2UgPSBkaXJlY3RMaWdodC5jb2xvcjtcXG5cXHRcXHR2TGlnaHRGcm9udCArPSBzYXR1cmF0ZSggZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cXHRcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0XFx0dkxpZ2h0QmFjayArPSBzYXR1cmF0ZSggLSBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcbiNlbmRpZlxcbiNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0Z2V0RGlyZWN0aW9uYWxMaWdodEluZm8oIGRpcmVjdGlvbmFsTGlnaHRzWyBpIF0sIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcblxcdFxcdGRvdE5MID0gZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApO1xcblxcdFxcdGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZSA9IGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdFxcdHZMaWdodEZyb250ICs9IHNhdHVyYXRlKCBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcblxcdFxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXHRcXHRcXHR2TGlnaHRCYWNrICs9IHNhdHVyYXRlKCAtIGRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuI2VuZGlmXFxuI2lmIE5VTV9IRU1JX0xJR0hUUyA+IDBcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0hFTUlfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHZJbmRpcmVjdEZyb250ICs9IGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGhlbWlzcGhlcmVMaWdodHNbIGkgXSwgZ2VvbWV0cnkubm9ybWFsICk7XFxuXFx0XFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcdFxcdFxcdHZJbmRpcmVjdEJhY2sgKz0gZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggaGVtaXNwaGVyZUxpZ2h0c1sgaSBdLCBiYWNrR2VvbWV0cnkubm9ybWFsICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuI2VuZGlmXCI7XG5cblx0dmFyIGxpZ2h0c19wYXJzX2JlZ2luID0gXCJ1bmlmb3JtIGJvb2wgcmVjZWl2ZVNoYWRvdztcXG51bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XFxudW5pZm9ybSB2ZWMzIGxpZ2h0UHJvYmVbIDkgXTtcXG52ZWMzIHNoR2V0SXJyYWRpYW5jZUF0KCBpbiB2ZWMzIG5vcm1hbCwgaW4gdmVjMyBzaENvZWZmaWNpZW50c1sgOSBdICkge1xcblxcdGZsb2F0IHggPSBub3JtYWwueCwgeSA9IG5vcm1hbC55LCB6ID0gbm9ybWFsLno7XFxuXFx0dmVjMyByZXN1bHQgPSBzaENvZWZmaWNpZW50c1sgMCBdICogMC44ODYyMjc7XFxuXFx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyAxIF0gKiAyLjAgKiAwLjUxMTY2NCAqIHk7XFxuXFx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyAyIF0gKiAyLjAgKiAwLjUxMTY2NCAqIHo7XFxuXFx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyAzIF0gKiAyLjAgKiAwLjUxMTY2NCAqIHg7XFxuXFx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyA0IF0gKiAyLjAgKiAwLjQyOTA0MyAqIHggKiB5O1xcblxcdHJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgNSBdICogMi4wICogMC40MjkwNDMgKiB5ICogejtcXG5cXHRyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDYgXSAqICggMC43NDMxMjUgKiB6ICogeiAtIDAuMjQ3NzA4ICk7XFxuXFx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyA3IF0gKiAyLjAgKiAwLjQyOTA0MyAqIHggKiB6O1xcblxcdHJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgOCBdICogMC40MjkwNDMgKiAoIHggKiB4IC0geSAqIHkgKTtcXG5cXHRyZXR1cm4gcmVzdWx0O1xcbn1cXG52ZWMzIGdldExpZ2h0UHJvYmVJcnJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIGxpZ2h0UHJvYmVbIDkgXSwgY29uc3QgaW4gdmVjMyBub3JtYWwgKSB7XFxuXFx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IHNoR2V0SXJyYWRpYW5jZUF0KCB3b3JsZE5vcm1hbCwgbGlnaHRQcm9iZSApO1xcblxcdHJldHVybiBpcnJhZGlhbmNlO1xcbn1cXG52ZWMzIGdldEFtYmllbnRMaWdodElycmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgYW1iaWVudExpZ2h0Q29sb3IgKSB7XFxuXFx0dmVjMyBpcnJhZGlhbmNlID0gYW1iaWVudExpZ2h0Q29sb3I7XFxuXFx0cmV0dXJuIGlycmFkaWFuY2U7XFxufVxcbmZsb2F0IGdldERpc3RhbmNlQXR0ZW51YXRpb24oIGNvbnN0IGluIGZsb2F0IGxpZ2h0RGlzdGFuY2UsIGNvbnN0IGluIGZsb2F0IGN1dG9mZkRpc3RhbmNlLCBjb25zdCBpbiBmbG9hdCBkZWNheUV4cG9uZW50ICkge1xcblxcdCNpZiBkZWZpbmVkICggUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUUyApXFxuXFx0XFx0ZmxvYXQgZGlzdGFuY2VGYWxsb2ZmID0gMS4wIC8gbWF4KCBwb3coIGxpZ2h0RGlzdGFuY2UsIGRlY2F5RXhwb25lbnQgKSwgMC4wMSApO1xcblxcdFxcdGlmICggY3V0b2ZmRGlzdGFuY2UgPiAwLjAgKSB7XFxuXFx0XFx0XFx0ZGlzdGFuY2VGYWxsb2ZmICo9IHBvdzIoIHNhdHVyYXRlKCAxLjAgLSBwb3c0KCBsaWdodERpc3RhbmNlIC8gY3V0b2ZmRGlzdGFuY2UgKSApICk7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiBkaXN0YW5jZUZhbGxvZmY7XFxuXFx0I2Vsc2VcXG5cXHRcXHRpZiAoIGN1dG9mZkRpc3RhbmNlID4gMC4wICYmIGRlY2F5RXhwb25lbnQgPiAwLjAgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHBvdyggc2F0dXJhdGUoIC0gbGlnaHREaXN0YW5jZSAvIGN1dG9mZkRpc3RhbmNlICsgMS4wICksIGRlY2F5RXhwb25lbnQgKTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIDEuMDtcXG5cXHQjZW5kaWZcXG59XFxuZmxvYXQgZ2V0U3BvdEF0dGVudWF0aW9uKCBjb25zdCBpbiBmbG9hdCBjb25lQ29zaW5lLCBjb25zdCBpbiBmbG9hdCBwZW51bWJyYUNvc2luZSwgY29uc3QgaW4gZmxvYXQgYW5nbGVDb3NpbmUgKSB7XFxuXFx0cmV0dXJuIHNtb290aHN0ZXAoIGNvbmVDb3NpbmUsIHBlbnVtYnJhQ29zaW5lLCBhbmdsZUNvc2luZSApO1xcbn1cXG4jaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxuXFx0c3RydWN0IERpcmVjdGlvbmFsTGlnaHQge1xcblxcdFxcdHZlYzMgZGlyZWN0aW9uO1xcblxcdFxcdHZlYzMgY29sb3I7XFxuXFx0fTtcXG5cXHR1bmlmb3JtIERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodHNbIE5VTV9ESVJfTElHSFRTIF07XFxuXFx0dm9pZCBnZXREaXJlY3Rpb25hbExpZ2h0SW5mbyggY29uc3QgaW4gRGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBvdXQgSW5jaWRlbnRMaWdodCBsaWdodCApIHtcXG5cXHRcXHRsaWdodC5jb2xvciA9IGRpcmVjdGlvbmFsTGlnaHQuY29sb3I7XFxuXFx0XFx0bGlnaHQuZGlyZWN0aW9uID0gZGlyZWN0aW9uYWxMaWdodC5kaXJlY3Rpb247XFxuXFx0XFx0bGlnaHQudmlzaWJsZSA9IHRydWU7XFxuXFx0fVxcbiNlbmRpZlxcbiNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcblxcdHN0cnVjdCBQb2ludExpZ2h0IHtcXG5cXHRcXHR2ZWMzIHBvc2l0aW9uO1xcblxcdFxcdHZlYzMgY29sb3I7XFxuXFx0XFx0ZmxvYXQgZGlzdGFuY2U7XFxuXFx0XFx0ZmxvYXQgZGVjYXk7XFxuXFx0fTtcXG5cXHR1bmlmb3JtIFBvaW50TGlnaHQgcG9pbnRMaWdodHNbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXG5cXHR2b2lkIGdldFBvaW50TGlnaHRJbmZvKCBjb25zdCBpbiBQb2ludExpZ2h0IHBvaW50TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIG91dCBJbmNpZGVudExpZ2h0IGxpZ2h0ICkge1xcblxcdFxcdHZlYzMgbFZlY3RvciA9IHBvaW50TGlnaHQucG9zaXRpb24gLSBnZW9tZXRyeS5wb3NpdGlvbjtcXG5cXHRcXHRsaWdodC5kaXJlY3Rpb24gPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXHRcXHRmbG9hdCBsaWdodERpc3RhbmNlID0gbGVuZ3RoKCBsVmVjdG9yICk7XFxuXFx0XFx0bGlnaHQuY29sb3IgPSBwb2ludExpZ2h0LmNvbG9yO1xcblxcdFxcdGxpZ2h0LmNvbG9yICo9IGdldERpc3RhbmNlQXR0ZW51YXRpb24oIGxpZ2h0RGlzdGFuY2UsIHBvaW50TGlnaHQuZGlzdGFuY2UsIHBvaW50TGlnaHQuZGVjYXkgKTtcXG5cXHRcXHRsaWdodC52aXNpYmxlID0gKCBsaWdodC5jb2xvciAhPSB2ZWMzKCAwLjAgKSApO1xcblxcdH1cXG4jZW5kaWZcXG4jaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblxcdHN0cnVjdCBTcG90TGlnaHQge1xcblxcdFxcdHZlYzMgcG9zaXRpb247XFxuXFx0XFx0dmVjMyBkaXJlY3Rpb247XFxuXFx0XFx0dmVjMyBjb2xvcjtcXG5cXHRcXHRmbG9hdCBkaXN0YW5jZTtcXG5cXHRcXHRmbG9hdCBkZWNheTtcXG5cXHRcXHRmbG9hdCBjb25lQ29zO1xcblxcdFxcdGZsb2F0IHBlbnVtYnJhQ29zO1xcblxcdH07XFxuXFx0dW5pZm9ybSBTcG90TGlnaHQgc3BvdExpZ2h0c1sgTlVNX1NQT1RfTElHSFRTIF07XFxuXFx0dm9pZCBnZXRTcG90TGlnaHRJbmZvKCBjb25zdCBpbiBTcG90TGlnaHQgc3BvdExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBvdXQgSW5jaWRlbnRMaWdodCBsaWdodCApIHtcXG5cXHRcXHR2ZWMzIGxWZWN0b3IgPSBzcG90TGlnaHQucG9zaXRpb24gLSBnZW9tZXRyeS5wb3NpdGlvbjtcXG5cXHRcXHRsaWdodC5kaXJlY3Rpb24gPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXHRcXHRmbG9hdCBhbmdsZUNvcyA9IGRvdCggbGlnaHQuZGlyZWN0aW9uLCBzcG90TGlnaHQuZGlyZWN0aW9uICk7XFxuXFx0XFx0ZmxvYXQgc3BvdEF0dGVudWF0aW9uID0gZ2V0U3BvdEF0dGVudWF0aW9uKCBzcG90TGlnaHQuY29uZUNvcywgc3BvdExpZ2h0LnBlbnVtYnJhQ29zLCBhbmdsZUNvcyApO1xcblxcdFxcdGlmICggc3BvdEF0dGVudWF0aW9uID4gMC4wICkge1xcblxcdFxcdFxcdGZsb2F0IGxpZ2h0RGlzdGFuY2UgPSBsZW5ndGgoIGxWZWN0b3IgKTtcXG5cXHRcXHRcXHRsaWdodC5jb2xvciA9IHNwb3RMaWdodC5jb2xvciAqIHNwb3RBdHRlbnVhdGlvbjtcXG5cXHRcXHRcXHRsaWdodC5jb2xvciAqPSBnZXREaXN0YW5jZUF0dGVudWF0aW9uKCBsaWdodERpc3RhbmNlLCBzcG90TGlnaHQuZGlzdGFuY2UsIHNwb3RMaWdodC5kZWNheSApO1xcblxcdFxcdFxcdGxpZ2h0LnZpc2libGUgPSAoIGxpZ2h0LmNvbG9yICE9IHZlYzMoIDAuMCApICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRsaWdodC5jb2xvciA9IHZlYzMoIDAuMCApO1xcblxcdFxcdFxcdGxpZ2h0LnZpc2libGUgPSBmYWxzZTtcXG5cXHRcXHR9XFxuXFx0fVxcbiNlbmRpZlxcbiNpZiBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDBcXG5cXHRzdHJ1Y3QgUmVjdEFyZWFMaWdodCB7XFxuXFx0XFx0dmVjMyBjb2xvcjtcXG5cXHRcXHR2ZWMzIHBvc2l0aW9uO1xcblxcdFxcdHZlYzMgaGFsZldpZHRoO1xcblxcdFxcdHZlYzMgaGFsZkhlaWdodDtcXG5cXHR9O1xcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGx0Y18xO1xcdHVuaWZvcm0gc2FtcGxlcjJEIGx0Y18yO1xcblxcdHVuaWZvcm0gUmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0c1sgTlVNX1JFQ1RfQVJFQV9MSUdIVFMgXTtcXG4jZW5kaWZcXG4jaWYgTlVNX0hFTUlfTElHSFRTID4gMFxcblxcdHN0cnVjdCBIZW1pc3BoZXJlTGlnaHQge1xcblxcdFxcdHZlYzMgZGlyZWN0aW9uO1xcblxcdFxcdHZlYzMgc2t5Q29sb3I7XFxuXFx0XFx0dmVjMyBncm91bmRDb2xvcjtcXG5cXHR9O1xcblxcdHVuaWZvcm0gSGVtaXNwaGVyZUxpZ2h0IGhlbWlzcGhlcmVMaWdodHNbIE5VTV9IRU1JX0xJR0hUUyBdO1xcblxcdHZlYzMgZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggY29uc3QgaW4gSGVtaXNwaGVyZUxpZ2h0IGhlbWlMaWdodCwgY29uc3QgaW4gdmVjMyBub3JtYWwgKSB7XFxuXFx0XFx0ZmxvYXQgZG90TkwgPSBkb3QoIG5vcm1hbCwgaGVtaUxpZ2h0LmRpcmVjdGlvbiApO1xcblxcdFxcdGZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0ID0gMC41ICogZG90TkwgKyAwLjU7XFxuXFx0XFx0dmVjMyBpcnJhZGlhbmNlID0gbWl4KCBoZW1pTGlnaHQuZ3JvdW5kQ29sb3IsIGhlbWlMaWdodC5za3lDb2xvciwgaGVtaURpZmZ1c2VXZWlnaHQgKTtcXG5cXHRcXHRyZXR1cm4gaXJyYWRpYW5jZTtcXG5cXHR9XFxuI2VuZGlmXCI7XG5cblx0dmFyIGVudm1hcF9waHlzaWNhbF9wYXJzX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApXFxuXFx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRlJBQ1RJT05cXG5cXHRcXHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cXHQjZW5kaWZcXG5cXHR2ZWMzIGdldElCTElycmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgbm9ybWFsICkge1xcblxcdFxcdCNpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWIClcXG5cXHRcXHRcXHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlVVYoIGVudk1hcCwgd29ybGROb3JtYWwsIDEuMCApO1xcblxcdFxcdFxcdHJldHVybiBQSSAqIGVudk1hcENvbG9yLnJnYiAqIGVudk1hcEludGVuc2l0eTtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHJldHVybiB2ZWMzKCAwLjAgKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuXFx0dmVjMyBnZXRJQkxSYWRpYW5jZSggY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcblxcdFxcdCNpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWIClcXG5cXHRcXHRcXHR2ZWMzIHJlZmxlY3RWZWM7XFxuXFx0XFx0XFx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXG5cXHRcXHRcXHRcXHRyZWZsZWN0VmVjID0gcmVmbGVjdCggLSB2aWV3RGlyLCBub3JtYWwgKTtcXG5cXHRcXHRcXHRcXHRyZWZsZWN0VmVjID0gbm9ybWFsaXplKCBtaXgoIHJlZmxlY3RWZWMsIG5vcm1hbCwgcm91Z2huZXNzICogcm91Z2huZXNzKSApO1xcblxcdFxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0XFx0cmVmbGVjdFZlYyA9IHJlZnJhY3QoIC0gdmlld0Rpciwgbm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXG5cXHRcXHRcXHQjZW5kaWZcXG5cXHRcXHRcXHRyZWZsZWN0VmVjID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggcmVmbGVjdFZlYywgdmlld01hdHJpeCApO1xcblxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZVVWKCBlbnZNYXAsIHJlZmxlY3RWZWMsIHJvdWdobmVzcyApO1xcblxcdFxcdFxcdHJldHVybiBlbnZNYXBDb2xvci5yZ2IgKiBlbnZNYXBJbnRlbnNpdHk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRyZXR1cm4gdmVjMyggMC4wICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcbiNlbmRpZlwiO1xuXG5cdHZhciBsaWdodHNfdG9vbl9mcmFnbWVudCA9IFwiVG9vbk1hdGVyaWFsIG1hdGVyaWFsO1xcbm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2I7XCI7XG5cblx0dmFyIGxpZ2h0c190b29uX3BhcnNfZnJhZ21lbnQgPSBcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbnN0cnVjdCBUb29uTWF0ZXJpYWwge1xcblxcdHZlYzMgZGlmZnVzZUNvbG9yO1xcbn07XFxudm9pZCBSRV9EaXJlY3RfVG9vbiggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gVG9vbk1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHR2ZWMzIGlycmFkaWFuY2UgPSBnZXRHcmFkaWVudElycmFkaWFuY2UoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKiBkaXJlY3RMaWdodC5jb2xvcjtcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcbn1cXG52b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9Ub29uKCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIFRvb25NYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcbn1cXG4jZGVmaW5lIFJFX0RpcmVjdFxcdFxcdFxcdFxcdFJFX0RpcmVjdF9Ub29uXFxuI2RlZmluZSBSRV9JbmRpcmVjdERpZmZ1c2VcXHRcXHRSRV9JbmRpcmVjdERpZmZ1c2VfVG9vblxcbiNkZWZpbmUgTWF0ZXJpYWxfTGlnaHRQcm9iZUxPRCggbWF0ZXJpYWwgKVxcdCgwKVwiO1xuXG5cdHZhciBsaWdodHNfcGhvbmdfZnJhZ21lbnQgPSBcIkJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbDtcXG5tYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBkaWZmdXNlQ29sb3IucmdiO1xcbm1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBzcGVjdWxhcjtcXG5tYXRlcmlhbC5zcGVjdWxhclNoaW5pbmVzcyA9IHNoaW5pbmVzcztcXG5tYXRlcmlhbC5zcGVjdWxhclN0cmVuZ3RoID0gc3BlY3VsYXJTdHJlbmd0aDtcIjtcblxuXHR2YXIgbGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQgPSBcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbnN0cnVjdCBCbGlublBob25nTWF0ZXJpYWwge1xcblxcdHZlYzMgZGlmZnVzZUNvbG9yO1xcblxcdHZlYzMgc3BlY3VsYXJDb2xvcjtcXG5cXHRmbG9hdCBzcGVjdWxhclNoaW5pbmVzcztcXG5cXHRmbG9hdCBzcGVjdWxhclN0cmVuZ3RoO1xcbn07XFxudm9pZCBSRV9EaXJlY3RfQmxpbm5QaG9uZyggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKTtcXG5cXHR2ZWMzIGlycmFkaWFuY2UgPSBkb3ROTCAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gaXJyYWRpYW5jZSAqIEJSREZfQmxpbm5QaG9uZyggZGlyZWN0TGlnaHQuZGlyZWN0aW9uLCBnZW9tZXRyeS52aWV3RGlyLCBnZW9tZXRyeS5ub3JtYWwsIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyU2hpbmluZXNzICkgKiBtYXRlcmlhbC5zcGVjdWxhclN0cmVuZ3RoO1xcbn1cXG52b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9CbGlublBob25nKCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIEJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcbn1cXG4jZGVmaW5lIFJFX0RpcmVjdFxcdFxcdFxcdFxcdFJFX0RpcmVjdF9CbGlublBob25nXFxuI2RlZmluZSBSRV9JbmRpcmVjdERpZmZ1c2VcXHRcXHRSRV9JbmRpcmVjdERpZmZ1c2VfQmxpbm5QaG9uZ1xcbiNkZWZpbmUgTWF0ZXJpYWxfTGlnaHRQcm9iZUxPRCggbWF0ZXJpYWwgKVxcdCgwKVwiO1xuXG5cdHZhciBsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQgPSBcIlBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWw7XFxubWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYiAqICggMS4wIC0gbWV0YWxuZXNzRmFjdG9yICk7XFxudmVjMyBkeHkgPSBtYXgoIGFicyggZEZkeCggZ2VvbWV0cnlOb3JtYWwgKSApLCBhYnMoIGRGZHkoIGdlb21ldHJ5Tm9ybWFsICkgKSApO1xcbmZsb2F0IGdlb21ldHJ5Um91Z2huZXNzID0gbWF4KCBtYXgoIGR4eS54LCBkeHkueSApLCBkeHkueiApO1xcbm1hdGVyaWFsLnJvdWdobmVzcyA9IG1heCggcm91Z2huZXNzRmFjdG9yLCAwLjA1MjUgKTttYXRlcmlhbC5yb3VnaG5lc3MgKz0gZ2VvbWV0cnlSb3VnaG5lc3M7XFxubWF0ZXJpYWwucm91Z2huZXNzID0gbWluKCBtYXRlcmlhbC5yb3VnaG5lc3MsIDEuMCApO1xcbiNpZmRlZiBJT1JcXG5cXHQjaWZkZWYgU1BFQ1VMQVJcXG5cXHRcXHRmbG9hdCBzcGVjdWxhckludGVuc2l0eUZhY3RvciA9IHNwZWN1bGFySW50ZW5zaXR5O1xcblxcdFxcdHZlYzMgc3BlY3VsYXJDb2xvckZhY3RvciA9IHNwZWN1bGFyQ29sb3I7XFxuXFx0XFx0I2lmZGVmIFVTRV9TUEVDVUxBUklOVEVOU0lUWU1BUFxcblxcdFxcdFxcdHNwZWN1bGFySW50ZW5zaXR5RmFjdG9yICo9IHRleHR1cmUyRCggc3BlY3VsYXJJbnRlbnNpdHlNYXAsIHZVdiApLmE7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0I2lmZGVmIFVTRV9TUEVDVUxBUkNPTE9STUFQXFxuXFx0XFx0XFx0c3BlY3VsYXJDb2xvckZhY3RvciAqPSBzcGVjdWxhckNvbG9yTWFwVGV4ZWxUb0xpbmVhciggdGV4dHVyZTJEKCBzcGVjdWxhckNvbG9yTWFwLCB2VXYgKSApLnJnYjtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRtYXRlcmlhbC5zcGVjdWxhckY5MCA9IG1peCggc3BlY3VsYXJJbnRlbnNpdHlGYWN0b3IsIDEuMCwgbWV0YWxuZXNzRmFjdG9yICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRmbG9hdCBzcGVjdWxhckludGVuc2l0eUZhY3RvciA9IDEuMDtcXG5cXHRcXHR2ZWMzIHNwZWN1bGFyQ29sb3JGYWN0b3IgPSB2ZWMzKCAxLjAgKTtcXG5cXHRcXHRtYXRlcmlhbC5zcGVjdWxhckY5MCA9IDEuMDtcXG5cXHQjZW5kaWZcXG5cXHRtYXRlcmlhbC5zcGVjdWxhckNvbG9yID0gbWl4KCBtaW4oIHBvdzIoICggaW9yIC0gMS4wICkgLyAoIGlvciArIDEuMCApICkgKiBzcGVjdWxhckNvbG9yRmFjdG9yLCB2ZWMzKCAxLjAgKSApICogc3BlY3VsYXJJbnRlbnNpdHlGYWN0b3IsIGRpZmZ1c2VDb2xvci5yZ2IsIG1ldGFsbmVzc0ZhY3RvciApO1xcbiNlbHNlXFxuXFx0bWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IG1peCggdmVjMyggMC4wNCApLCBkaWZmdXNlQ29sb3IucmdiLCBtZXRhbG5lc3NGYWN0b3IgKTtcXG5cXHRtYXRlcmlhbC5zcGVjdWxhckY5MCA9IDEuMDtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0NMRUFSQ09BVFxcblxcdG1hdGVyaWFsLmNsZWFyY29hdCA9IGNsZWFyY29hdDtcXG5cXHRtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgPSBjbGVhcmNvYXRSb3VnaG5lc3M7XFxuXFx0bWF0ZXJpYWwuY2xlYXJjb2F0RjAgPSB2ZWMzKCAwLjA0ICk7XFxuXFx0bWF0ZXJpYWwuY2xlYXJjb2F0RjkwID0gMS4wO1xcblxcdCNpZmRlZiBVU0VfQ0xFQVJDT0FUTUFQXFxuXFx0XFx0bWF0ZXJpYWwuY2xlYXJjb2F0ICo9IHRleHR1cmUyRCggY2xlYXJjb2F0TWFwLCB2VXYgKS54O1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUFxcblxcdFxcdG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyAqPSB0ZXh0dXJlMkQoIGNsZWFyY29hdFJvdWdobmVzc01hcCwgdlV2ICkueTtcXG5cXHQjZW5kaWZcXG5cXHRtYXRlcmlhbC5jbGVhcmNvYXQgPSBzYXR1cmF0ZSggbWF0ZXJpYWwuY2xlYXJjb2F0ICk7XFx0bWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzID0gbWF4KCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MsIDAuMDUyNSApO1xcblxcdG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyArPSBnZW9tZXRyeVJvdWdobmVzcztcXG5cXHRtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgPSBtaW4oIG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcywgMS4wICk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9TSEVFTlxcblxcdG1hdGVyaWFsLnNoZWVuQ29sb3IgPSBzaGVlbkNvbG9yO1xcblxcdCNpZmRlZiBVU0VfU0hFRU5DT0xPUk1BUFxcblxcdFxcdG1hdGVyaWFsLnNoZWVuQ29sb3IgKj0gc2hlZW5Db2xvck1hcFRleGVsVG9MaW5lYXIoIHRleHR1cmUyRCggc2hlZW5Db2xvck1hcCwgdlV2ICkgKS5yZ2I7XFxuXFx0I2VuZGlmXFxuXFx0bWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3MgPSBjbGFtcCggc2hlZW5Sb3VnaG5lc3MsIDAuMDcsIDEuMCApO1xcblxcdCNpZmRlZiBVU0VfU0hFRU5ST1VHSE5FU1NNQVBcXG5cXHRcXHRtYXRlcmlhbC5zaGVlblJvdWdobmVzcyAqPSB0ZXh0dXJlMkQoIHNoZWVuUm91Z2huZXNzTWFwLCB2VXYgKS5hO1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG5cdHZhciBsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudCA9IFwic3RydWN0IFBoeXNpY2FsTWF0ZXJpYWwge1xcblxcdHZlYzMgZGlmZnVzZUNvbG9yO1xcblxcdGZsb2F0IHJvdWdobmVzcztcXG5cXHR2ZWMzIHNwZWN1bGFyQ29sb3I7XFxuXFx0ZmxvYXQgc3BlY3VsYXJGOTA7XFxuXFx0I2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHRcXHRmbG9hdCBjbGVhcmNvYXQ7XFxuXFx0XFx0ZmxvYXQgY2xlYXJjb2F0Um91Z2huZXNzO1xcblxcdFxcdHZlYzMgY2xlYXJjb2F0RjA7XFxuXFx0XFx0ZmxvYXQgY2xlYXJjb2F0RjkwO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfU0hFRU5cXG5cXHRcXHR2ZWMzIHNoZWVuQ29sb3I7XFxuXFx0XFx0ZmxvYXQgc2hlZW5Sb3VnaG5lc3M7XFxuXFx0I2VuZGlmXFxufTtcXG52ZWMzIGNsZWFyY29hdFNwZWN1bGFyID0gdmVjMyggMC4wICk7XFxudmVjMiBERkdBcHByb3goIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7XFxuXFx0Y29uc3QgdmVjNCBjMCA9IHZlYzQoIC0gMSwgLSAwLjAyNzUsIC0gMC41NzIsIDAuMDIyICk7XFxuXFx0Y29uc3QgdmVjNCBjMSA9IHZlYzQoIDEsIDAuMDQyNSwgMS4wNCwgLSAwLjA0ICk7XFxuXFx0dmVjNCByID0gcm91Z2huZXNzICogYzAgKyBjMTtcXG5cXHRmbG9hdCBhMDA0ID0gbWluKCByLnggKiByLngsIGV4cDIoIC0gOS4yOCAqIGRvdE5WICkgKSAqIHIueCArIHIueTtcXG5cXHR2ZWMyIGZhYiA9IHZlYzIoIC0gMS4wNCwgMS4wNCApICogYTAwNCArIHIuenc7XFxuXFx0cmV0dXJuIGZhYjtcXG59XFxudmVjMyBFbnZpcm9ubWVudEJSREYoIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgc3BlY3VsYXJGOTAsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHR2ZWMyIGZhYiA9IERGR0FwcHJveCggbm9ybWFsLCB2aWV3RGlyLCByb3VnaG5lc3MgKTtcXG5cXHRyZXR1cm4gc3BlY3VsYXJDb2xvciAqIGZhYi54ICsgc3BlY3VsYXJGOTAgKiBmYWIueTtcXG59XFxudm9pZCBjb21wdXRlTXVsdGlzY2F0dGVyaW5nKCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNwZWN1bGFyRjkwLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGlub3V0IHZlYzMgc2luZ2xlU2NhdHRlciwgaW5vdXQgdmVjMyBtdWx0aVNjYXR0ZXIgKSB7XFxuXFx0dmVjMiBmYWIgPSBERkdBcHByb3goIG5vcm1hbCwgdmlld0Rpciwgcm91Z2huZXNzICk7XFxuXFx0dmVjMyBGc3NFc3MgPSBzcGVjdWxhckNvbG9yICogZmFiLnggKyBzcGVjdWxhckY5MCAqIGZhYi55O1xcblxcdGZsb2F0IEVzcyA9IGZhYi54ICsgZmFiLnk7XFxuXFx0ZmxvYXQgRW1zID0gMS4wIC0gRXNzO1xcblxcdHZlYzMgRmF2ZyA9IHNwZWN1bGFyQ29sb3IgKyAoIDEuMCAtIHNwZWN1bGFyQ29sb3IgKSAqIDAuMDQ3NjE5O1xcdHZlYzMgRm1zID0gRnNzRXNzICogRmF2ZyAvICggMS4wIC0gRW1zICogRmF2ZyApO1xcblxcdHNpbmdsZVNjYXR0ZXIgKz0gRnNzRXNzO1xcblxcdG11bHRpU2NhdHRlciArPSBGbXMgKiBFbXM7XFxufVxcbiNpZiBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDBcXG5cXHR2b2lkIFJFX0RpcmVjdF9SZWN0QXJlYV9QaHlzaWNhbCggY29uc3QgaW4gUmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRcXHR2ZWMzIG5vcm1hbCA9IGdlb21ldHJ5Lm5vcm1hbDtcXG5cXHRcXHR2ZWMzIHZpZXdEaXIgPSBnZW9tZXRyeS52aWV3RGlyO1xcblxcdFxcdHZlYzMgcG9zaXRpb24gPSBnZW9tZXRyeS5wb3NpdGlvbjtcXG5cXHRcXHR2ZWMzIGxpZ2h0UG9zID0gcmVjdEFyZWFMaWdodC5wb3NpdGlvbjtcXG5cXHRcXHR2ZWMzIGhhbGZXaWR0aCA9IHJlY3RBcmVhTGlnaHQuaGFsZldpZHRoO1xcblxcdFxcdHZlYzMgaGFsZkhlaWdodCA9IHJlY3RBcmVhTGlnaHQuaGFsZkhlaWdodDtcXG5cXHRcXHR2ZWMzIGxpZ2h0Q29sb3IgPSByZWN0QXJlYUxpZ2h0LmNvbG9yO1xcblxcdFxcdGZsb2F0IHJvdWdobmVzcyA9IG1hdGVyaWFsLnJvdWdobmVzcztcXG5cXHRcXHR2ZWMzIHJlY3RDb29yZHNbIDQgXTtcXG5cXHRcXHRyZWN0Q29vcmRzWyAwIF0gPSBsaWdodFBvcyArIGhhbGZXaWR0aCAtIGhhbGZIZWlnaHQ7XFx0XFx0cmVjdENvb3Jkc1sgMSBdID0gbGlnaHRQb3MgLSBoYWxmV2lkdGggLSBoYWxmSGVpZ2h0O1xcblxcdFxcdHJlY3RDb29yZHNbIDIgXSA9IGxpZ2h0UG9zIC0gaGFsZldpZHRoICsgaGFsZkhlaWdodDtcXG5cXHRcXHRyZWN0Q29vcmRzWyAzIF0gPSBsaWdodFBvcyArIGhhbGZXaWR0aCArIGhhbGZIZWlnaHQ7XFxuXFx0XFx0dmVjMiB1diA9IExUQ19Vdiggbm9ybWFsLCB2aWV3RGlyLCByb3VnaG5lc3MgKTtcXG5cXHRcXHR2ZWM0IHQxID0gdGV4dHVyZTJEKCBsdGNfMSwgdXYgKTtcXG5cXHRcXHR2ZWM0IHQyID0gdGV4dHVyZTJEKCBsdGNfMiwgdXYgKTtcXG5cXHRcXHRtYXQzIG1JbnYgPSBtYXQzKFxcblxcdFxcdFxcdHZlYzMoIHQxLngsIDAsIHQxLnkgKSxcXG5cXHRcXHRcXHR2ZWMzKFx0XHQwLCAxLFx0XHQwICksXFxuXFx0XFx0XFx0dmVjMyggdDEueiwgMCwgdDEudyApXFxuXFx0XFx0KTtcXG5cXHRcXHR2ZWMzIGZyZXNuZWwgPSAoIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgKiB0Mi54ICsgKCB2ZWMzKCAxLjAgKSAtIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgKSAqIHQyLnkgKTtcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBsaWdodENvbG9yICogZnJlc25lbCAqIExUQ19FdmFsdWF0ZSggbm9ybWFsLCB2aWV3RGlyLCBwb3NpdGlvbiwgbUludiwgcmVjdENvb3JkcyApO1xcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gbGlnaHRDb2xvciAqIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciAqIExUQ19FdmFsdWF0ZSggbm9ybWFsLCB2aWV3RGlyLCBwb3NpdGlvbiwgbWF0MyggMS4wICksIHJlY3RDb29yZHMgKTtcXG5cXHR9XFxuI2VuZGlmXFxudm9pZCBSRV9EaXJlY3RfUGh5c2ljYWwoIGNvbnN0IGluIEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApO1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0I2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHRcXHRmbG9hdCBkb3ROTGNjID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkuY2xlYXJjb2F0Tm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApO1xcblxcdFxcdHZlYzMgY2NJcnJhZGlhbmNlID0gZG90TkxjYyAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdFxcdGNsZWFyY29hdFNwZWN1bGFyICs9IGNjSXJyYWRpYW5jZSAqIEJSREZfR0dYKCBkaXJlY3RMaWdodC5kaXJlY3Rpb24sIGdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5LmNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwuY2xlYXJjb2F0RjAsIG1hdGVyaWFsLmNsZWFyY29hdEY5MCwgbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzICk7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9TSEVFTlxcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICs9IGlycmFkaWFuY2UgKiBCUkRGX1NoZWVuKCBkaXJlY3RMaWdodC5kaXJlY3Rpb24sIGdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5Lm5vcm1hbCwgbWF0ZXJpYWwuc2hlZW5Db2xvciwgbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3MgKTtcXG5cXHQjZW5kaWZcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogQlJERl9HR1goIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiwgZ2VvbWV0cnkudmlld0RpciwgZ2VvbWV0cnkubm9ybWFsLCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckY5MCwgbWF0ZXJpYWwucm91Z2huZXNzICk7XFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG59XFxudm9pZCBSRV9JbmRpcmVjdERpZmZ1c2VfUGh5c2ljYWwoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcbn1cXG52b2lkIFJFX0luZGlyZWN0U3BlY3VsYXJfUGh5c2ljYWwoIGNvbnN0IGluIHZlYzMgcmFkaWFuY2UsIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gdmVjMyBjbGVhcmNvYXRSYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQpIHtcXG5cXHQjaWZkZWYgVVNFX0NMRUFSQ09BVFxcblxcdFxcdGNsZWFyY29hdFNwZWN1bGFyICs9IGNsZWFyY29hdFJhZGlhbmNlICogRW52aXJvbm1lbnRCUkRGKCBnZW9tZXRyeS5jbGVhcmNvYXROb3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIsIG1hdGVyaWFsLmNsZWFyY29hdEYwLCBtYXRlcmlhbC5jbGVhcmNvYXRGOTAsIG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyApO1xcblxcdCNlbmRpZlxcblxcdHZlYzMgc2luZ2xlU2NhdHRlcmluZyA9IHZlYzMoIDAuMCApO1xcblxcdHZlYzMgbXVsdGlTY2F0dGVyaW5nID0gdmVjMyggMC4wICk7XFxuXFx0dmVjMyBjb3NpbmVXZWlnaHRlZElycmFkaWFuY2UgPSBpcnJhZGlhbmNlICogUkVDSVBST0NBTF9QSTtcXG5cXHRjb21wdXRlTXVsdGlzY2F0dGVyaW5nKCBnZW9tZXRyeS5ub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIsIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyRjkwLCBtYXRlcmlhbC5yb3VnaG5lc3MsIHNpbmdsZVNjYXR0ZXJpbmcsIG11bHRpU2NhdHRlcmluZyApO1xcblxcdHZlYzMgZGlmZnVzZSA9IG1hdGVyaWFsLmRpZmZ1c2VDb2xvciAqICggMS4wIC0gKCBzaW5nbGVTY2F0dGVyaW5nICsgbXVsdGlTY2F0dGVyaW5nICkgKTtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICs9IHJhZGlhbmNlICogc2luZ2xlU2NhdHRlcmluZztcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICs9IG11bHRpU2NhdHRlcmluZyAqIGNvc2luZVdlaWdodGVkSXJyYWRpYW5jZTtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gZGlmZnVzZSAqIGNvc2luZVdlaWdodGVkSXJyYWRpYW5jZTtcXG59XFxuI2RlZmluZSBSRV9EaXJlY3RcXHRcXHRcXHRcXHRSRV9EaXJlY3RfUGh5c2ljYWxcXG4jZGVmaW5lIFJFX0RpcmVjdF9SZWN0QXJlYVxcdFxcdFJFX0RpcmVjdF9SZWN0QXJlYV9QaHlzaWNhbFxcbiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlXFx0XFx0UkVfSW5kaXJlY3REaWZmdXNlX1BoeXNpY2FsXFxuI2RlZmluZSBSRV9JbmRpcmVjdFNwZWN1bGFyXFx0XFx0UkVfSW5kaXJlY3RTcGVjdWxhcl9QaHlzaWNhbFxcbmZsb2F0IGNvbXB1dGVTcGVjdWxhck9jY2x1c2lvbiggY29uc3QgaW4gZmxvYXQgZG90TlYsIGNvbnN0IGluIGZsb2F0IGFtYmllbnRPY2NsdXNpb24sIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRyZXR1cm4gc2F0dXJhdGUoIHBvdyggZG90TlYgKyBhbWJpZW50T2NjbHVzaW9uLCBleHAyKCAtIDE2LjAgKiByb3VnaG5lc3MgLSAxLjAgKSApIC0gMS4wICsgYW1iaWVudE9jY2x1c2lvbiApO1xcbn1cIjtcblxuXHR2YXIgbGlnaHRzX2ZyYWdtZW50X2JlZ2luID0gXCJcXG5HZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5O1xcbmdlb21ldHJ5LnBvc2l0aW9uID0gLSB2Vmlld1Bvc2l0aW9uO1xcbmdlb21ldHJ5Lm5vcm1hbCA9IG5vcm1hbDtcXG5nZW9tZXRyeS52aWV3RGlyID0gKCBpc09ydGhvZ3JhcGhpYyApID8gdmVjMyggMCwgMCwgMSApIDogbm9ybWFsaXplKCB2Vmlld1Bvc2l0aW9uICk7XFxuI2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHRnZW9tZXRyeS5jbGVhcmNvYXROb3JtYWwgPSBjbGVhcmNvYXROb3JtYWw7XFxuI2VuZGlmXFxuSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodDtcXG4jaWYgKCBOVU1fUE9JTlRfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXFxuXFx0UG9pbnRMaWdodCBwb2ludExpZ2h0O1xcblxcdCNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0UG9pbnRMaWdodFNoYWRvdyBwb2ludExpZ2h0U2hhZG93O1xcblxcdCNlbmRpZlxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHBvaW50TGlnaHQgPSBwb2ludExpZ2h0c1sgaSBdO1xcblxcdFxcdGdldFBvaW50TGlnaHRJbmZvKCBwb2ludExpZ2h0LCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXG5cXHRcXHQjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmICggVU5ST0xMRURfTE9PUF9JTkRFWCA8IE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIClcXG5cXHRcXHRwb2ludExpZ2h0U2hhZG93ID0gcG9pbnRMaWdodFNoYWRvd3NbIGkgXTtcXG5cXHRcXHRkaXJlY3RMaWdodC5jb2xvciAqPSBhbGwoIGJ2ZWMyKCBkaXJlY3RMaWdodC52aXNpYmxlLCByZWNlaXZlU2hhZG93ICkgKSA/IGdldFBvaW50U2hhZG93KCBwb2ludFNoYWRvd01hcFsgaSBdLCBwb2ludExpZ2h0U2hhZG93LnNoYWRvd01hcFNpemUsIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93QmlhcywgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dSYWRpdXMsIHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0sIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93Q2FtZXJhTmVhciwgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dDYW1lcmFGYXIgKSA6IDEuMDtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuI2VuZGlmXFxuI2lmICggTlVNX1NQT1RfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXFxuXFx0U3BvdExpZ2h0IHNwb3RMaWdodDtcXG5cXHQjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0U3BvdExpZ2h0U2hhZG93IHNwb3RMaWdodFNoYWRvdztcXG5cXHQjZW5kaWZcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHNwb3RMaWdodCA9IHNwb3RMaWdodHNbIGkgXTtcXG5cXHRcXHRnZXRTcG90TGlnaHRJbmZvKCBzcG90TGlnaHQsIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcblxcdFxcdCNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgKCBVTlJPTExFRF9MT09QX0lOREVYIDwgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyApXFxuXFx0XFx0c3BvdExpZ2h0U2hhZG93ID0gc3BvdExpZ2h0U2hhZG93c1sgaSBdO1xcblxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9IGFsbCggYnZlYzIoIGRpcmVjdExpZ2h0LnZpc2libGUsIHJlY2VpdmVTaGFkb3cgKSApID8gZ2V0U2hhZG93KCBzcG90U2hhZG93TWFwWyBpIF0sIHNwb3RMaWdodFNoYWRvdy5zaGFkb3dNYXBTaXplLCBzcG90TGlnaHRTaGFkb3cuc2hhZG93Qmlhcywgc3BvdExpZ2h0U2hhZG93LnNoYWRvd1JhZGl1cywgdlNwb3RTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0UkVfRGlyZWN0KCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcbiNlbmRpZlxcbiNpZiAoIE5VTV9ESVJfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXFxuXFx0RGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0O1xcblxcdCNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgTlVNX0RJUl9MSUdIVF9TSEFET1dTID4gMFxcblxcdERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgZGlyZWN0aW9uYWxMaWdodFNoYWRvdztcXG5cXHQjZW5kaWZcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0ZGlyZWN0aW9uYWxMaWdodCA9IGRpcmVjdGlvbmFsTGlnaHRzWyBpIF07XFxuXFx0XFx0Z2V0RGlyZWN0aW9uYWxMaWdodEluZm8oIGRpcmVjdGlvbmFsTGlnaHQsIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcblxcdFxcdCNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgKCBVTlJPTExFRF9MT09QX0lOREVYIDwgTlVNX0RJUl9MSUdIVF9TSEFET1dTIClcXG5cXHRcXHRkaXJlY3Rpb25hbExpZ2h0U2hhZG93ID0gZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIGkgXTtcXG5cXHRcXHRkaXJlY3RMaWdodC5jb2xvciAqPSBhbGwoIGJ2ZWMyKCBkaXJlY3RMaWdodC52aXNpYmxlLCByZWNlaXZlU2hhZG93ICkgKSA/IGdldFNoYWRvdyggZGlyZWN0aW9uYWxTaGFkb3dNYXBbIGkgXSwgZGlyZWN0aW9uYWxMaWdodFNoYWRvdy5zaGFkb3dNYXBTaXplLCBkaXJlY3Rpb25hbExpZ2h0U2hhZG93LnNoYWRvd0JpYXMsIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3cuc2hhZG93UmFkaXVzLCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0UkVfRGlyZWN0KCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcbiNlbmRpZlxcbiNpZiAoIE5VTV9SRUNUX0FSRUFfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdF9SZWN0QXJlYSApXFxuXFx0UmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0O1xcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUkVDVF9BUkVBX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRyZWN0QXJlYUxpZ2h0ID0gcmVjdEFyZWFMaWdodHNbIGkgXTtcXG5cXHRcXHRSRV9EaXJlY3RfUmVjdEFyZWEoIHJlY3RBcmVhTGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG4jZW5kaWZcXG4jaWYgZGVmaW5lZCggUkVfSW5kaXJlY3REaWZmdXNlIClcXG5cXHR2ZWMzIGlibElycmFkaWFuY2UgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWMzIGlycmFkaWFuY2UgPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApO1xcblxcdGlycmFkaWFuY2UgKz0gZ2V0TGlnaHRQcm9iZUlycmFkaWFuY2UoIGxpZ2h0UHJvYmUsIGdlb21ldHJ5Lm5vcm1hbCApO1xcblxcdCNpZiAoIE5VTV9IRU1JX0xJR0hUUyA+IDAgKVxcblxcdFxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fSEVNSV9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0XFx0aXJyYWRpYW5jZSArPSBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBoZW1pc3BoZXJlTGlnaHRzWyBpIF0sIGdlb21ldHJ5Lm5vcm1hbCApO1xcblxcdFxcdH1cXG5cXHRcXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdCNlbmRpZlxcbiNlbmRpZlxcbiNpZiBkZWZpbmVkKCBSRV9JbmRpcmVjdFNwZWN1bGFyIClcXG5cXHR2ZWMzIHJhZGlhbmNlID0gdmVjMyggMC4wICk7XFxuXFx0dmVjMyBjbGVhcmNvYXRSYWRpYW5jZSA9IHZlYzMoIDAuMCApO1xcbiNlbmRpZlwiO1xuXG5cdHZhciBsaWdodHNfZnJhZ21lbnRfbWFwcyA9IFwiI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0RGlmZnVzZSApXFxuXFx0I2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcdFxcdHZlYzQgbGlnaHRNYXBUZXhlbCA9IHRleHR1cmUyRCggbGlnaHRNYXAsIHZVdjIgKTtcXG5cXHRcXHR2ZWMzIGxpZ2h0TWFwSXJyYWRpYW5jZSA9IGxpZ2h0TWFwVGV4ZWxUb0xpbmVhciggbGlnaHRNYXBUZXhlbCApLnJnYiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1xcblxcdFxcdCNpZm5kZWYgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUU1xcblxcdFxcdFxcdGxpZ2h0TWFwSXJyYWRpYW5jZSAqPSBQSTtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRpcnJhZGlhbmNlICs9IGxpZ2h0TWFwSXJyYWRpYW5jZTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFNUQU5EQVJEICkgJiYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApXFxuXFx0XFx0aWJsSXJyYWRpYW5jZSArPSBnZXRJQkxJcnJhZGlhbmNlKCBnZW9tZXRyeS5ub3JtYWwgKTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG4jaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFJFX0luZGlyZWN0U3BlY3VsYXIgKVxcblxcdHJhZGlhbmNlICs9IGdldElCTFJhZGlhbmNlKCBnZW9tZXRyeS52aWV3RGlyLCBnZW9tZXRyeS5ub3JtYWwsIG1hdGVyaWFsLnJvdWdobmVzcyApO1xcblxcdCNpZmRlZiBVU0VfQ0xFQVJDT0FUXFxuXFx0XFx0Y2xlYXJjb2F0UmFkaWFuY2UgKz0gZ2V0SUJMUmFkaWFuY2UoIGdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5LmNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzICk7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cblx0dmFyIGxpZ2h0c19mcmFnbWVudF9lbmQgPSBcIiNpZiBkZWZpbmVkKCBSRV9JbmRpcmVjdERpZmZ1c2UgKVxcblxcdFJFX0luZGlyZWN0RGlmZnVzZSggaXJyYWRpYW5jZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcbiNlbmRpZlxcbiNpZiBkZWZpbmVkKCBSRV9JbmRpcmVjdFNwZWN1bGFyIClcXG5cXHRSRV9JbmRpcmVjdFNwZWN1bGFyKCByYWRpYW5jZSwgaWJsSXJyYWRpYW5jZSwgY2xlYXJjb2F0UmFkaWFuY2UsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG4jZW5kaWZcIjtcblxuXHR2YXIgbG9nZGVwdGhidWZfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBVU0VfTE9HREVQVEhCVUYgKSAmJiBkZWZpbmVkKCBVU0VfTE9HREVQVEhCVUZfRVhUIClcXG5cXHRnbF9GcmFnRGVwdGhFWFQgPSB2SXNQZXJzcGVjdGl2ZSA9PSAwLjAgPyBnbF9GcmFnQ29vcmQueiA6IGxvZzIoIHZGcmFnRGVwdGggKSAqIGxvZ0RlcHRoQnVmRkMgKiAwLjU7XFxuI2VuZGlmXCI7XG5cblx0dmFyIGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBVU0VfTE9HREVQVEhCVUYgKSAmJiBkZWZpbmVkKCBVU0VfTE9HREVQVEhCVUZfRVhUIClcXG5cXHR1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxuXFx0dmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoO1xcblxcdHZhcnlpbmcgZmxvYXQgdklzUGVyc3BlY3RpdmU7XFxuI2VuZGlmXCI7XG5cblx0dmFyIGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXHRcXHR2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7XFxuXFx0XFx0dmFyeWluZyBmbG9hdCB2SXNQZXJzcGVjdGl2ZTtcXG5cXHQjZWxzZVxcblxcdFxcdHVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxuXHR2YXIgbG9nZGVwdGhidWZfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXHRcXHR2RnJhZ0RlcHRoID0gMS4wICsgZ2xfUG9zaXRpb24udztcXG5cXHRcXHR2SXNQZXJzcGVjdGl2ZSA9IGZsb2F0KCBpc1BlcnNwZWN0aXZlTWF0cml4KCBwcm9qZWN0aW9uTWF0cml4ICkgKTtcXG5cXHQjZWxzZVxcblxcdFxcdGlmICggaXNQZXJzcGVjdGl2ZU1hdHJpeCggcHJvamVjdGlvbk1hdHJpeCApICkge1xcblxcdFxcdFxcdGdsX1Bvc2l0aW9uLnogPSBsb2cyKCBtYXgoIEVQU0lMT04sIGdsX1Bvc2l0aW9uLncgKyAxLjAgKSApICogbG9nRGVwdGhCdWZGQyAtIDEuMDtcXG5cXHRcXHRcXHRnbF9Qb3NpdGlvbi56ICo9IGdsX1Bvc2l0aW9uLnc7XFxuXFx0XFx0fVxcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG5cdHZhciBtYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFx0dmVjNCB0ZXhlbENvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVdiApO1xcblxcdHRleGVsQ29sb3IgPSBtYXBUZXhlbFRvTGluZWFyKCB0ZXhlbENvbG9yICk7XFxuXFx0ZGlmZnVzZUNvbG9yICo9IHRleGVsQ29sb3I7XFxuI2VuZGlmXCI7XG5cblx0dmFyIG1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG4jZW5kaWZcIjtcblxuXHR2YXIgbWFwX3BhcnRpY2xlX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApXFxuXFx0dmVjMiB1diA9ICggdXZUcmFuc2Zvcm0gKiB2ZWMzKCBnbF9Qb2ludENvb3JkLngsIDEuMCAtIGdsX1BvaW50Q29vcmQueSwgMSApICkueHk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9NQVBcXG5cXHR2ZWM0IG1hcFRleGVsID0gdGV4dHVyZTJEKCBtYXAsIHV2ICk7XFxuXFx0ZGlmZnVzZUNvbG9yICo9IG1hcFRleGVsVG9MaW5lYXIoIG1hcFRleGVsICk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcdGRpZmZ1c2VDb2xvci5hICo9IHRleHR1cmUyRCggYWxwaGFNYXAsIHV2ICkuZztcXG4jZW5kaWZcIjtcblxuXHR2YXIgbWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQIClcXG5cXHR1bmlmb3JtIG1hdDMgdXZUcmFuc2Zvcm07XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9NQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGFscGhhTWFwO1xcbiNlbmRpZlwiO1xuXG5cdHZhciBtZXRhbG5lc3NtYXBfZnJhZ21lbnQgPSBcImZsb2F0IG1ldGFsbmVzc0ZhY3RvciA9IG1ldGFsbmVzcztcXG4jaWZkZWYgVVNFX01FVEFMTkVTU01BUFxcblxcdHZlYzQgdGV4ZWxNZXRhbG5lc3MgPSB0ZXh0dXJlMkQoIG1ldGFsbmVzc01hcCwgdlV2ICk7XFxuXFx0bWV0YWxuZXNzRmFjdG9yICo9IHRleGVsTWV0YWxuZXNzLmI7XFxuI2VuZGlmXCI7XG5cblx0dmFyIG1ldGFsbmVzc21hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX01FVEFMTkVTU01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIG1ldGFsbmVzc01hcDtcXG4jZW5kaWZcIjtcblxuXHR2YXIgbW9ycGhub3JtYWxfdmVydGV4ID0gXCIjaWZkZWYgVVNFX01PUlBITk9STUFMU1xcblxcdG9iamVjdE5vcm1hbCAqPSBtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2U7XFxuXFx0I2lmZGVmIE1PUlBIVEFSR0VUU19URVhUVVJFXFxuXFx0XFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTU9SUEhUQVJHRVRTX0NPVU5UOyBpICsrICkge1xcblxcdFxcdFxcdGlmICggbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF0gPiAwLjAgKSBvYmplY3ROb3JtYWwgKz0gZ2V0TW9ycGgoIGdsX1ZlcnRleElELCBpLCAxLCAyICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXTtcXG5cXHRcXHR9XFxuXFx0I2Vsc2VcXG5cXHRcXHRvYmplY3ROb3JtYWwgKz0gbW9ycGhOb3JtYWwwICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxuXFx0XFx0b2JqZWN0Tm9ybWFsICs9IG1vcnBoTm9ybWFsMSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1xcblxcdFxcdG9iamVjdE5vcm1hbCArPSBtb3JwaE5vcm1hbDIgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcXG5cXHRcXHRvYmplY3ROb3JtYWwgKz0gbW9ycGhOb3JtYWwzICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cblx0dmFyIG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlO1xcblxcdCNpZmRlZiBNT1JQSFRBUkdFVFNfVEVYVFVSRVxcblxcdFxcdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBNT1JQSFRBUkdFVFNfQ09VTlQgXTtcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyREFycmF5IG1vcnBoVGFyZ2V0c1RleHR1cmU7XFxuXFx0XFx0dW5pZm9ybSB2ZWMyIG1vcnBoVGFyZ2V0c1RleHR1cmVTaXplO1xcblxcdFxcdHZlYzMgZ2V0TW9ycGgoIGNvbnN0IGluIGludCB2ZXJ0ZXhJbmRleCwgY29uc3QgaW4gaW50IG1vcnBoVGFyZ2V0SW5kZXgsIGNvbnN0IGluIGludCBvZmZzZXQsIGNvbnN0IGluIGludCBzdHJpZGUgKSB7XFxuXFx0XFx0XFx0ZmxvYXQgdGV4ZWxJbmRleCA9IGZsb2F0KCB2ZXJ0ZXhJbmRleCAqIHN0cmlkZSArIG9mZnNldCApO1xcblxcdFxcdFxcdGZsb2F0IHkgPSBmbG9vciggdGV4ZWxJbmRleCAvIG1vcnBoVGFyZ2V0c1RleHR1cmVTaXplLnggKTtcXG5cXHRcXHRcXHRmbG9hdCB4ID0gdGV4ZWxJbmRleCAtIHkgKiBtb3JwaFRhcmdldHNUZXh0dXJlU2l6ZS54O1xcblxcdFxcdFxcdHZlYzMgbW9ycGhVViA9IHZlYzMoICggeCArIDAuNSApIC8gbW9ycGhUYXJnZXRzVGV4dHVyZVNpemUueCwgeSAvIG1vcnBoVGFyZ2V0c1RleHR1cmVTaXplLnksIG1vcnBoVGFyZ2V0SW5kZXggKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGV4dHVyZSggbW9ycGhUYXJnZXRzVGV4dHVyZSwgbW9ycGhVViApLnh5ejtcXG5cXHRcXHR9XFxuXFx0I2Vsc2VcXG5cXHRcXHQjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXHRcXHRcXHR1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgOCBdO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDQgXTtcXG5cXHRcXHQjZW5kaWZcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxuXHR2YXIgbW9ycGh0YXJnZXRfdmVydGV4ID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcdHRyYW5zZm9ybWVkICo9IG1vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZTtcXG5cXHQjaWZkZWYgTU9SUEhUQVJHRVRTX1RFWFRVUkVcXG5cXHRcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNT1JQSFRBUkdFVFNfQ09VTlQ7IGkgKysgKSB7XFxuXFx0XFx0XFx0I2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFx0XFx0XFx0XFx0aWYgKCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXSA+IDAuMCApIHRyYW5zZm9ybWVkICs9IGdldE1vcnBoKCBnbF9WZXJ0ZXhJRCwgaSwgMCwgMSApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF07XFxuXFx0XFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRcXHRpZiAoIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdID4gMC4wICkgdHJhbnNmb3JtZWQgKz0gZ2V0TW9ycGgoIGdsX1ZlcnRleElELCBpLCAwLCAyICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXTtcXG5cXHRcXHRcXHQjZW5kaWZcXG5cXHRcXHR9XFxuXFx0I2Vsc2VcXG5cXHRcXHR0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDAgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDAgXTtcXG5cXHRcXHR0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDEgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcXG5cXHRcXHR0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDIgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcXG5cXHRcXHR0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDMgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDMgXTtcXG5cXHRcXHQjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXHRcXHRcXHR0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDQgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDQgXTtcXG5cXHRcXHRcXHR0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDUgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDUgXTtcXG5cXHRcXHRcXHR0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDYgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDYgXTtcXG5cXHRcXHRcXHR0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDcgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDcgXTtcXG5cXHRcXHQjZW5kaWZcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxuXHR2YXIgbm9ybWFsX2ZyYWdtZW50X2JlZ2luID0gXCJmbG9hdCBmYWNlRGlyZWN0aW9uID0gZ2xfRnJvbnRGYWNpbmcgPyAxLjAgOiAtIDEuMDtcXG4jaWZkZWYgRkxBVF9TSEFERURcXG5cXHR2ZWMzIGZkeCA9IHZlYzMoIGRGZHgoIHZWaWV3UG9zaXRpb24ueCApLCBkRmR4KCB2Vmlld1Bvc2l0aW9uLnkgKSwgZEZkeCggdlZpZXdQb3NpdGlvbi56ICkgKTtcXG5cXHR2ZWMzIGZkeSA9IHZlYzMoIGRGZHkoIHZWaWV3UG9zaXRpb24ueCApLCBkRmR5KCB2Vmlld1Bvc2l0aW9uLnkgKSwgZEZkeSggdlZpZXdQb3NpdGlvbi56ICkgKTtcXG5cXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggY3Jvc3MoIGZkeCwgZmR5ICkgKTtcXG4jZWxzZVxcblxcdHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB2Tm9ybWFsICk7XFxuXFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcdFxcdG5vcm1hbCA9IG5vcm1hbCAqIGZhY2VEaXJlY3Rpb247XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0XFx0dmVjMyB0YW5nZW50ID0gbm9ybWFsaXplKCB2VGFuZ2VudCApO1xcblxcdFxcdHZlYzMgYml0YW5nZW50ID0gbm9ybWFsaXplKCB2Qml0YW5nZW50ICk7XFxuXFx0XFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcdFxcdFxcdHRhbmdlbnQgPSB0YW5nZW50ICogZmFjZURpcmVjdGlvbjtcXG5cXHRcXHRcXHRiaXRhbmdlbnQgPSBiaXRhbmdlbnQgKiBmYWNlRGlyZWN0aW9uO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdCNpZiBkZWZpbmVkKCBUQU5HRU5UU1BBQ0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAgKVxcblxcdFxcdFxcdG1hdDMgdlRCTiA9IG1hdDMoIHRhbmdlbnQsIGJpdGFuZ2VudCwgbm9ybWFsICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxudmVjMyBnZW9tZXRyeU5vcm1hbCA9IG5vcm1hbDtcIjtcblxuXHR2YXIgbm9ybWFsX2ZyYWdtZW50X21hcHMgPSBcIiNpZmRlZiBPQkpFQ1RTUEFDRV9OT1JNQUxNQVBcXG5cXHRub3JtYWwgPSB0ZXh0dXJlMkQoIG5vcm1hbE1hcCwgdlV2ICkueHl6ICogMi4wIC0gMS4wO1xcblxcdCNpZmRlZiBGTElQX1NJREVEXFxuXFx0XFx0bm9ybWFsID0gLSBub3JtYWw7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcdFxcdG5vcm1hbCA9IG5vcm1hbCAqIGZhY2VEaXJlY3Rpb247XFxuXFx0I2VuZGlmXFxuXFx0bm9ybWFsID0gbm9ybWFsaXplKCBub3JtYWxNYXRyaXggKiBub3JtYWwgKTtcXG4jZWxpZiBkZWZpbmVkKCBUQU5HRU5UU1BBQ0VfTk9STUFMTUFQIClcXG5cXHR2ZWMzIG1hcE4gPSB0ZXh0dXJlMkQoIG5vcm1hbE1hcCwgdlV2ICkueHl6ICogMi4wIC0gMS4wO1xcblxcdG1hcE4ueHkgKj0gbm9ybWFsU2NhbGU7XFxuXFx0I2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0XFx0bm9ybWFsID0gbm9ybWFsaXplKCB2VEJOICogbWFwTiApO1xcblxcdCNlbHNlXFxuXFx0XFx0bm9ybWFsID0gcGVydHVyYk5vcm1hbDJBcmIoIC0gdlZpZXdQb3NpdGlvbiwgbm9ybWFsLCBtYXBOLCBmYWNlRGlyZWN0aW9uICk7XFxuXFx0I2VuZGlmXFxuI2VsaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKVxcblxcdG5vcm1hbCA9IHBlcnR1cmJOb3JtYWxBcmIoIC0gdlZpZXdQb3NpdGlvbiwgbm9ybWFsLCBkSGR4eV9md2QoKSwgZmFjZURpcmVjdGlvbiApO1xcbiNlbmRpZlwiO1xuXG5cdHZhciBub3JtYWxfcGFyc19mcmFnbWVudCA9IFwiI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcblxcdCNpZmRlZiBVU0VfVEFOR0VOVFxcblxcdFxcdHZhcnlpbmcgdmVjMyB2VGFuZ2VudDtcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdkJpdGFuZ2VudDtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxuXHR2YXIgbm9ybWFsX3BhcnNfdmVydGV4ID0gXCIjaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuXFx0I2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZUYW5nZW50O1xcblxcdFxcdHZhcnlpbmcgdmVjMyB2Qml0YW5nZW50O1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG5cdHZhciBub3JtYWxfdmVydGV4ID0gXCIjaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcXG5cXHQjaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHRcXHR2VGFuZ2VudCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWRUYW5nZW50ICk7XFxuXFx0XFx0dkJpdGFuZ2VudCA9IG5vcm1hbGl6ZSggY3Jvc3MoIHZOb3JtYWwsIHZUYW5nZW50ICkgKiB0YW5nZW50LncgKTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxuXHR2YXIgbm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfTk9STUFMTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbm9ybWFsTWFwO1xcblxcdHVuaWZvcm0gdmVjMiBub3JtYWxTY2FsZTtcXG4jZW5kaWZcXG4jaWZkZWYgT0JKRUNUU1BBQ0VfTk9STUFMTUFQXFxuXFx0dW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDtcXG4jZW5kaWZcXG4jaWYgISBkZWZpbmVkICggVVNFX1RBTkdFTlQgKSAmJiAoIGRlZmluZWQgKCBUQU5HRU5UU1BBQ0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCAoIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQICkgKVxcblxcdHZlYzMgcGVydHVyYk5vcm1hbDJBcmIoIHZlYzMgZXllX3BvcywgdmVjMyBzdXJmX25vcm0sIHZlYzMgbWFwTiwgZmxvYXQgZmFjZURpcmVjdGlvbiApIHtcXG5cXHRcXHR2ZWMzIHEwID0gdmVjMyggZEZkeCggZXllX3Bvcy54ICksIGRGZHgoIGV5ZV9wb3MueSApLCBkRmR4KCBleWVfcG9zLnogKSApO1xcblxcdFxcdHZlYzMgcTEgPSB2ZWMzKCBkRmR5KCBleWVfcG9zLnggKSwgZEZkeSggZXllX3Bvcy55ICksIGRGZHkoIGV5ZV9wb3MueiApICk7XFxuXFx0XFx0dmVjMiBzdDAgPSBkRmR4KCB2VXYuc3QgKTtcXG5cXHRcXHR2ZWMyIHN0MSA9IGRGZHkoIHZVdi5zdCApO1xcblxcdFxcdHZlYzMgTiA9IHN1cmZfbm9ybTtcXG5cXHRcXHR2ZWMzIHExcGVycCA9IGNyb3NzKCBxMSwgTiApO1xcblxcdFxcdHZlYzMgcTBwZXJwID0gY3Jvc3MoIE4sIHEwICk7XFxuXFx0XFx0dmVjMyBUID0gcTFwZXJwICogc3QwLnggKyBxMHBlcnAgKiBzdDEueDtcXG5cXHRcXHR2ZWMzIEIgPSBxMXBlcnAgKiBzdDAueSArIHEwcGVycCAqIHN0MS55O1xcblxcdFxcdGZsb2F0IGRldCA9IG1heCggZG90KCBULCBUICksIGRvdCggQiwgQiApICk7XFxuXFx0XFx0ZmxvYXQgc2NhbGUgPSAoIGRldCA9PSAwLjAgKSA/IDAuMCA6IGZhY2VEaXJlY3Rpb24gKiBpbnZlcnNlc3FydCggZGV0ICk7XFxuXFx0XFx0cmV0dXJuIG5vcm1hbGl6ZSggVCAqICggbWFwTi54ICogc2NhbGUgKSArIEIgKiAoIG1hcE4ueSAqIHNjYWxlICkgKyBOICogbWFwTi56ICk7XFxuXFx0fVxcbiNlbmRpZlwiO1xuXG5cdHZhciBjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X2JlZ2luID0gXCIjaWZkZWYgVVNFX0NMRUFSQ09BVFxcblxcdHZlYzMgY2xlYXJjb2F0Tm9ybWFsID0gZ2VvbWV0cnlOb3JtYWw7XFxuI2VuZGlmXCI7XG5cblx0dmFyIGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfbWFwcyA9IFwiI2lmZGVmIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQXFxuXFx0dmVjMyBjbGVhcmNvYXRNYXBOID0gdGV4dHVyZTJEKCBjbGVhcmNvYXROb3JtYWxNYXAsIHZVdiApLnh5eiAqIDIuMCAtIDEuMDtcXG5cXHRjbGVhcmNvYXRNYXBOLnh5ICo9IGNsZWFyY29hdE5vcm1hbFNjYWxlO1xcblxcdCNpZmRlZiBVU0VfVEFOR0VOVFxcblxcdFxcdGNsZWFyY29hdE5vcm1hbCA9IG5vcm1hbGl6ZSggdlRCTiAqIGNsZWFyY29hdE1hcE4gKTtcXG5cXHQjZWxzZVxcblxcdFxcdGNsZWFyY29hdE5vcm1hbCA9IHBlcnR1cmJOb3JtYWwyQXJiKCAtIHZWaWV3UG9zaXRpb24sIGNsZWFyY29hdE5vcm1hbCwgY2xlYXJjb2F0TWFwTiwgZmFjZURpcmVjdGlvbiApO1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG5cdHZhciBjbGVhcmNvYXRfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9DTEVBUkNPQVRNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBjbGVhcmNvYXRNYXA7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9DTEVBUkNPQVRfUk9VR0hORVNTTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgY2xlYXJjb2F0Um91Z2huZXNzTWFwO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGNsZWFyY29hdE5vcm1hbE1hcDtcXG5cXHR1bmlmb3JtIHZlYzIgY2xlYXJjb2F0Tm9ybWFsU2NhbGU7XFxuI2VuZGlmXCI7XG5cblx0dmFyIG91dHB1dF9mcmFnbWVudCA9IFwiI2lmZGVmIE9QQVFVRVxcbmRpZmZ1c2VDb2xvci5hID0gMS4wO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OXFxuZGlmZnVzZUNvbG9yLmEgKj0gdHJhbnNtaXNzaW9uQWxwaGEgKyAwLjE7XFxuI2VuZGlmXFxuZ2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIjtcblxuXHR2YXIgcGFja2luZyA9IFwidmVjMyBwYWNrTm9ybWFsVG9SR0IoIGNvbnN0IGluIHZlYzMgbm9ybWFsICkge1xcblxcdHJldHVybiBub3JtYWxpemUoIG5vcm1hbCApICogMC41ICsgMC41O1xcbn1cXG52ZWMzIHVucGFja1JHQlRvTm9ybWFsKCBjb25zdCBpbiB2ZWMzIHJnYiApIHtcXG5cXHRyZXR1cm4gMi4wICogcmdiLnh5eiAtIDEuMDtcXG59XFxuY29uc3QgZmxvYXQgUGFja1Vwc2NhbGUgPSAyNTYuIC8gMjU1Ljtjb25zdCBmbG9hdCBVbnBhY2tEb3duc2NhbGUgPSAyNTUuIC8gMjU2LjtcXG5jb25zdCB2ZWMzIFBhY2tGYWN0b3JzID0gdmVjMyggMjU2LiAqIDI1Ni4gKiAyNTYuLCAyNTYuICogMjU2LiwgMjU2LiApO1xcbmNvbnN0IHZlYzQgVW5wYWNrRmFjdG9ycyA9IFVucGFja0Rvd25zY2FsZSAvIHZlYzQoIFBhY2tGYWN0b3JzLCAxLiApO1xcbmNvbnN0IGZsb2F0IFNoaWZ0UmlnaHQ4ID0gMS4gLyAyNTYuO1xcbnZlYzQgcGFja0RlcHRoVG9SR0JBKCBjb25zdCBpbiBmbG9hdCB2ICkge1xcblxcdHZlYzQgciA9IHZlYzQoIGZyYWN0KCB2ICogUGFja0ZhY3RvcnMgKSwgdiApO1xcblxcdHIueXp3IC09IHIueHl6ICogU2hpZnRSaWdodDg7XFx0cmV0dXJuIHIgKiBQYWNrVXBzY2FsZTtcXG59XFxuZmxvYXQgdW5wYWNrUkdCQVRvRGVwdGgoIGNvbnN0IGluIHZlYzQgdiApIHtcXG5cXHRyZXR1cm4gZG90KCB2LCBVbnBhY2tGYWN0b3JzICk7XFxufVxcbnZlYzQgcGFjazJIYWxmVG9SR0JBKCB2ZWMyIHYgKSB7XFxuXFx0dmVjNCByID0gdmVjNCggdi54LCBmcmFjdCggdi54ICogMjU1LjAgKSwgdi55LCBmcmFjdCggdi55ICogMjU1LjAgKSApO1xcblxcdHJldHVybiB2ZWM0KCByLnggLSByLnkgLyAyNTUuMCwgci55LCByLnogLSByLncgLyAyNTUuMCwgci53ICk7XFxufVxcbnZlYzIgdW5wYWNrUkdCQVRvMkhhbGYoIHZlYzQgdiApIHtcXG5cXHRyZXR1cm4gdmVjMiggdi54ICsgKCB2LnkgLyAyNTUuMCApLCB2LnogKyAoIHYudyAvIDI1NS4wICkgKTtcXG59XFxuZmxvYXQgdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKCBjb25zdCBpbiBmbG9hdCB2aWV3WiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xcblxcdHJldHVybiAoIHZpZXdaICsgbmVhciApIC8gKCBuZWFyIC0gZmFyICk7XFxufVxcbmZsb2F0IG9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WiggY29uc3QgaW4gZmxvYXQgbGluZWFyQ2xpcFosIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcXG5cXHRyZXR1cm4gbGluZWFyQ2xpcFogKiAoIG5lYXIgLSBmYXIgKSAtIG5lYXI7XFxufVxcbmZsb2F0IHZpZXdaVG9QZXJzcGVjdGl2ZURlcHRoKCBjb25zdCBpbiBmbG9hdCB2aWV3WiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xcblxcdHJldHVybiAoICggbmVhciArIHZpZXdaICkgKiBmYXIgKSAvICggKCBmYXIgLSBuZWFyICkgKiB2aWV3WiApO1xcbn1cXG5mbG9hdCBwZXJzcGVjdGl2ZURlcHRoVG9WaWV3WiggY29uc3QgaW4gZmxvYXQgaW52Q2xpcFosIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcXG5cXHRyZXR1cm4gKCBuZWFyICogZmFyICkgLyAoICggZmFyIC0gbmVhciApICogaW52Q2xpcFogLSBmYXIgKTtcXG59XCI7XG5cblx0dmFyIHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQgPSBcIiNpZmRlZiBQUkVNVUxUSVBMSUVEX0FMUEhBXFxuXFx0Z2xfRnJhZ0NvbG9yLnJnYiAqPSBnbF9GcmFnQ29sb3IuYTtcXG4jZW5kaWZcIjtcblxuXHR2YXIgcHJvamVjdF92ZXJ0ZXggPSBcInZlYzQgbXZQb3NpdGlvbiA9IHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG4jaWZkZWYgVVNFX0lOU1RBTkNJTkdcXG5cXHRtdlBvc2l0aW9uID0gaW5zdGFuY2VNYXRyaXggKiBtdlBvc2l0aW9uO1xcbiNlbmRpZlxcbm12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiBtdlBvc2l0aW9uO1xcbmdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XCI7XG5cblx0dmFyIGRpdGhlcmluZ19mcmFnbWVudCA9IFwiI2lmZGVmIERJVEhFUklOR1xcblxcdGdsX0ZyYWdDb2xvci5yZ2IgPSBkaXRoZXJpbmcoIGdsX0ZyYWdDb2xvci5yZ2IgKTtcXG4jZW5kaWZcIjtcblxuXHR2YXIgZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBESVRIRVJJTkdcXG5cXHR2ZWMzIGRpdGhlcmluZyggdmVjMyBjb2xvciApIHtcXG5cXHRcXHRmbG9hdCBncmlkX3Bvc2l0aW9uID0gcmFuZCggZ2xfRnJhZ0Nvb3JkLnh5ICk7XFxuXFx0XFx0dmVjMyBkaXRoZXJfc2hpZnRfUkdCID0gdmVjMyggMC4yNSAvIDI1NS4wLCAtMC4yNSAvIDI1NS4wLCAwLjI1IC8gMjU1LjAgKTtcXG5cXHRcXHRkaXRoZXJfc2hpZnRfUkdCID0gbWl4KCAyLjAgKiBkaXRoZXJfc2hpZnRfUkdCLCAtMi4wICogZGl0aGVyX3NoaWZ0X1JHQiwgZ3JpZF9wb3NpdGlvbiApO1xcblxcdFxcdHJldHVybiBjb2xvciArIGRpdGhlcl9zaGlmdF9SR0I7XFxuXFx0fVxcbiNlbmRpZlwiO1xuXG5cdHZhciByb3VnaG5lc3NtYXBfZnJhZ21lbnQgPSBcImZsb2F0IHJvdWdobmVzc0ZhY3RvciA9IHJvdWdobmVzcztcXG4jaWZkZWYgVVNFX1JPVUdITkVTU01BUFxcblxcdHZlYzQgdGV4ZWxSb3VnaG5lc3MgPSB0ZXh0dXJlMkQoIHJvdWdobmVzc01hcCwgdlV2ICk7XFxuXFx0cm91Z2huZXNzRmFjdG9yICo9IHRleGVsUm91Z2huZXNzLmc7XFxuI2VuZGlmXCI7XG5cblx0dmFyIHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX1JPVUdITkVTU01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIHJvdWdobmVzc01hcDtcXG4jZW5kaWZcIjtcblxuXHR2YXIgc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0I2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBkaXJlY3Rpb25hbFNoYWRvd01hcFsgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0dmFyeWluZyB2ZWM0IHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBOVU1fRElSX0xJR0hUX1NIQURPV1MgXTtcXG5cXHRcXHRzdHJ1Y3QgRGlyZWN0aW9uYWxMaWdodFNoYWRvdyB7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93QmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dOb3JtYWxCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHR2ZWMyIHNoYWRvd01hcFNpemU7XFxuXFx0XFx0fTtcXG5cXHRcXHR1bmlmb3JtIERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fU1BPVF9MSUdIVF9TSEFET1dTID4gMFxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHNwb3RTaGFkb3dNYXBbIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgXTtcXG5cXHRcXHR2YXJ5aW5nIHZlYzQgdlNwb3RTaGFkb3dDb29yZFsgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHN0cnVjdCBTcG90TGlnaHRTaGFkb3cge1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Tm9ybWFsQmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblxcdFxcdH07XFxuXFx0XFx0dW5pZm9ybSBTcG90TGlnaHRTaGFkb3cgc3BvdExpZ2h0U2hhZG93c1sgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyBdO1xcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBwb2ludFNoYWRvd01hcFsgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgXTtcXG5cXHRcXHR2YXJ5aW5nIHZlYzQgdlBvaW50U2hhZG93Q29vcmRbIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0c3RydWN0IFBvaW50TGlnaHRTaGFkb3cge1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Tm9ybWFsQmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0NhbWVyYU5lYXI7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Q2FtZXJhRmFyO1xcblxcdFxcdH07XFxuXFx0XFx0dW5pZm9ybSBQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHRTaGFkb3dzWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdO1xcblxcdCNlbmRpZlxcblxcdGZsb2F0IHRleHR1cmUyRENvbXBhcmUoIHNhbXBsZXIyRCBkZXB0aHMsIHZlYzIgdXYsIGZsb2F0IGNvbXBhcmUgKSB7XFxuXFx0XFx0cmV0dXJuIHN0ZXAoIGNvbXBhcmUsIHVucGFja1JHQkFUb0RlcHRoKCB0ZXh0dXJlMkQoIGRlcHRocywgdXYgKSApICk7XFxuXFx0fVxcblxcdHZlYzIgdGV4dHVyZTJERGlzdHJpYnV0aW9uKCBzYW1wbGVyMkQgc2hhZG93LCB2ZWMyIHV2ICkge1xcblxcdFxcdHJldHVybiB1bnBhY2tSR0JBVG8ySGFsZiggdGV4dHVyZTJEKCBzaGFkb3csIHV2ICkgKTtcXG5cXHR9XFxuXFx0ZmxvYXQgVlNNU2hhZG93IChzYW1wbGVyMkQgc2hhZG93LCB2ZWMyIHV2LCBmbG9hdCBjb21wYXJlICl7XFxuXFx0XFx0ZmxvYXQgb2NjbHVzaW9uID0gMS4wO1xcblxcdFxcdHZlYzIgZGlzdHJpYnV0aW9uID0gdGV4dHVyZTJERGlzdHJpYnV0aW9uKCBzaGFkb3csIHV2ICk7XFxuXFx0XFx0ZmxvYXQgaGFyZF9zaGFkb3cgPSBzdGVwKCBjb21wYXJlICwgZGlzdHJpYnV0aW9uLnggKTtcXG5cXHRcXHRpZiAoaGFyZF9zaGFkb3cgIT0gMS4wICkge1xcblxcdFxcdFxcdGZsb2F0IGRpc3RhbmNlID0gY29tcGFyZSAtIGRpc3RyaWJ1dGlvbi54IDtcXG5cXHRcXHRcXHRmbG9hdCB2YXJpYW5jZSA9IG1heCggMC4wMDAwMCwgZGlzdHJpYnV0aW9uLnkgKiBkaXN0cmlidXRpb24ueSApO1xcblxcdFxcdFxcdGZsb2F0IHNvZnRuZXNzX3Byb2JhYmlsaXR5ID0gdmFyaWFuY2UgLyAodmFyaWFuY2UgKyBkaXN0YW5jZSAqIGRpc3RhbmNlICk7XFx0XFx0XFx0c29mdG5lc3NfcHJvYmFiaWxpdHkgPSBjbGFtcCggKCBzb2Z0bmVzc19wcm9iYWJpbGl0eSAtIDAuMyApIC8gKCAwLjk1IC0gMC4zICksIDAuMCwgMS4wICk7XFx0XFx0XFx0b2NjbHVzaW9uID0gY2xhbXAoIG1heCggaGFyZF9zaGFkb3csIHNvZnRuZXNzX3Byb2JhYmlsaXR5ICksIDAuMCwgMS4wICk7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiBvY2NsdXNpb247XFxuXFx0fVxcblxcdGZsb2F0IGdldFNoYWRvdyggc2FtcGxlcjJEIHNoYWRvd01hcCwgdmVjMiBzaGFkb3dNYXBTaXplLCBmbG9hdCBzaGFkb3dCaWFzLCBmbG9hdCBzaGFkb3dSYWRpdXMsIHZlYzQgc2hhZG93Q29vcmQgKSB7XFxuXFx0XFx0ZmxvYXQgc2hhZG93ID0gMS4wO1xcblxcdFxcdHNoYWRvd0Nvb3JkLnh5eiAvPSBzaGFkb3dDb29yZC53O1xcblxcdFxcdHNoYWRvd0Nvb3JkLnogKz0gc2hhZG93QmlhcztcXG5cXHRcXHRidmVjNCBpbkZydXN0dW1WZWMgPSBidmVjNCAoIHNoYWRvd0Nvb3JkLnggPj0gMC4wLCBzaGFkb3dDb29yZC54IDw9IDEuMCwgc2hhZG93Q29vcmQueSA+PSAwLjAsIHNoYWRvd0Nvb3JkLnkgPD0gMS4wICk7XFxuXFx0XFx0Ym9vbCBpbkZydXN0dW0gPSBhbGwoIGluRnJ1c3R1bVZlYyApO1xcblxcdFxcdGJ2ZWMyIGZydXN0dW1UZXN0VmVjID0gYnZlYzIoIGluRnJ1c3R1bSwgc2hhZG93Q29vcmQueiA8PSAxLjAgKTtcXG5cXHRcXHRib29sIGZydXN0dW1UZXN0ID0gYWxsKCBmcnVzdHVtVGVzdFZlYyApO1xcblxcdFxcdGlmICggZnJ1c3R1bVRlc3QgKSB7XFxuXFx0XFx0I2lmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRiApXFxuXFx0XFx0XFx0dmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvIHNoYWRvd01hcFNpemU7XFxuXFx0XFx0XFx0ZmxvYXQgZHgwID0gLSB0ZXhlbFNpemUueCAqIHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHRmbG9hdCBkeTAgPSAtIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdGZsb2F0IGR4MSA9ICsgdGV4ZWxTaXplLnggKiBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0ZmxvYXQgZHkxID0gKyB0ZXhlbFNpemUueSAqIHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHRmbG9hdCBkeDIgPSBkeDAgLyAyLjA7XFxuXFx0XFx0XFx0ZmxvYXQgZHkyID0gZHkwIC8gMi4wO1xcblxcdFxcdFxcdGZsb2F0IGR4MyA9IGR4MSAvIDIuMDtcXG5cXHRcXHRcXHRmbG9hdCBkeTMgPSBkeTEgLyAyLjA7XFxuXFx0XFx0XFx0c2hhZG93ID0gKFxcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDIsIGR5MiApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MiApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDMsIGR5MiApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDIsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MywgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MiwgZHkzICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkzICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MywgZHkzICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkxICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkxICksIHNoYWRvd0Nvb3JkLnogKVxcblxcdFxcdFxcdCkgKiAoIDEuMCAvIDE3LjAgKTtcXG5cXHRcXHQjZWxpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApXFxuXFx0XFx0XFx0dmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvIHNoYWRvd01hcFNpemU7XFxuXFx0XFx0XFx0ZmxvYXQgZHggPSB0ZXhlbFNpemUueDtcXG5cXHRcXHRcXHRmbG9hdCBkeSA9IHRleGVsU2l6ZS55O1xcblxcdFxcdFxcdHZlYzIgdXYgPSBzaGFkb3dDb29yZC54eTtcXG5cXHRcXHRcXHR2ZWMyIGYgPSBmcmFjdCggdXYgKiBzaGFkb3dNYXBTaXplICsgMC41ICk7XFxuXFx0XFx0XFx0dXYgLT0gZiAqIHRleGVsU2l6ZTtcXG5cXHRcXHRcXHRzaGFkb3cgPSAoXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggZHgsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAwLjAsIGR5ICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHRleGVsU2l6ZSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHRtaXgoIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAtZHgsIDAuMCApLCBzaGFkb3dDb29yZC56ICksIFxcblxcdFxcdFxcdFxcdFxcdCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMi4wICogZHgsIDAuMCApLCBzaGFkb3dDb29yZC56ICksXFxuXFx0XFx0XFx0XFx0XFx0IGYueCApICtcXG5cXHRcXHRcXHRcXHRtaXgoIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAtZHgsIGR5ICksIHNoYWRvd0Nvb3JkLnogKSwgXFxuXFx0XFx0XFx0XFx0XFx0IHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAyLjAgKiBkeCwgZHkgKSwgc2hhZG93Q29vcmQueiApLFxcblxcdFxcdFxcdFxcdFxcdCBmLnggKSArXFxuXFx0XFx0XFx0XFx0bWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMC4wLCAtZHkgKSwgc2hhZG93Q29vcmQueiApLCBcXG5cXHRcXHRcXHRcXHRcXHQgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDAuMCwgMi4wICogZHkgKSwgc2hhZG93Q29vcmQueiApLFxcblxcdFxcdFxcdFxcdFxcdCBmLnkgKSArXFxuXFx0XFx0XFx0XFx0bWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggZHgsIC1keSApLCBzaGFkb3dDb29yZC56ICksIFxcblxcdFxcdFxcdFxcdFxcdCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggZHgsIDIuMCAqIGR5ICksIHNoYWRvd0Nvb3JkLnogKSxcXG5cXHRcXHRcXHRcXHRcXHQgZi55ICkgK1xcblxcdFxcdFxcdFxcdG1peCggbWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggLWR4LCAtZHkgKSwgc2hhZG93Q29vcmQueiApLCBcXG5cXHRcXHRcXHRcXHRcXHRcXHRcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAyLjAgKiBkeCwgLWR5ICksIHNoYWRvd0Nvb3JkLnogKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcdGYueCApLFxcblxcdFxcdFxcdFxcdFxcdCBtaXgoIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAtZHgsIDIuMCAqIGR5ICksIHNoYWRvd0Nvb3JkLnogKSwgXFxuXFx0XFx0XFx0XFx0XFx0XFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMi4wICogZHgsIDIuMCAqIGR5ICksIHNoYWRvd0Nvb3JkLnogKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcdGYueCApLFxcblxcdFxcdFxcdFxcdFxcdCBmLnkgKVxcblxcdFxcdFxcdCkgKiAoIDEuMCAvIDkuMCApO1xcblxcdFxcdCNlbGlmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1ZTTSApXFxuXFx0XFx0XFx0c2hhZG93ID0gVlNNU2hhZG93KCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRzaGFkb3cgPSB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiBzaGFkb3c7XFxuXFx0fVxcblxcdHZlYzIgY3ViZVRvVVYoIHZlYzMgdiwgZmxvYXQgdGV4ZWxTaXplWSApIHtcXG5cXHRcXHR2ZWMzIGFic1YgPSBhYnMoIHYgKTtcXG5cXHRcXHRmbG9hdCBzY2FsZVRvQ3ViZSA9IDEuMCAvIG1heCggYWJzVi54LCBtYXgoIGFic1YueSwgYWJzVi56ICkgKTtcXG5cXHRcXHRhYnNWICo9IHNjYWxlVG9DdWJlO1xcblxcdFxcdHYgKj0gc2NhbGVUb0N1YmUgKiAoIDEuMCAtIDIuMCAqIHRleGVsU2l6ZVkgKTtcXG5cXHRcXHR2ZWMyIHBsYW5hciA9IHYueHk7XFxuXFx0XFx0ZmxvYXQgYWxtb3N0QVRleGVsID0gMS41ICogdGV4ZWxTaXplWTtcXG5cXHRcXHRmbG9hdCBhbG1vc3RPbmUgPSAxLjAgLSBhbG1vc3RBVGV4ZWw7XFxuXFx0XFx0aWYgKCBhYnNWLnogPj0gYWxtb3N0T25lICkge1xcblxcdFxcdFxcdGlmICggdi56ID4gMC4wIClcXG5cXHRcXHRcXHRcXHRwbGFuYXIueCA9IDQuMCAtIHYueDtcXG5cXHRcXHR9IGVsc2UgaWYgKCBhYnNWLnggPj0gYWxtb3N0T25lICkge1xcblxcdFxcdFxcdGZsb2F0IHNpZ25YID0gc2lnbiggdi54ICk7XFxuXFx0XFx0XFx0cGxhbmFyLnggPSB2LnogKiBzaWduWCArIDIuMCAqIHNpZ25YO1xcblxcdFxcdH0gZWxzZSBpZiAoIGFic1YueSA+PSBhbG1vc3RPbmUgKSB7XFxuXFx0XFx0XFx0ZmxvYXQgc2lnblkgPSBzaWduKCB2LnkgKTtcXG5cXHRcXHRcXHRwbGFuYXIueCA9IHYueCArIDIuMCAqIHNpZ25ZICsgMi4wO1xcblxcdFxcdFxcdHBsYW5hci55ID0gdi56ICogc2lnblkgLSAyLjA7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB2ZWMyKCAwLjEyNSwgMC4yNSApICogcGxhbmFyICsgdmVjMiggMC4zNzUsIDAuNzUgKTtcXG5cXHR9XFxuXFx0ZmxvYXQgZ2V0UG9pbnRTaGFkb3coIHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgc2hhZG93TWFwU2l6ZSwgZmxvYXQgc2hhZG93QmlhcywgZmxvYXQgc2hhZG93UmFkaXVzLCB2ZWM0IHNoYWRvd0Nvb3JkLCBmbG9hdCBzaGFkb3dDYW1lcmFOZWFyLCBmbG9hdCBzaGFkb3dDYW1lcmFGYXIgKSB7XFxuXFx0XFx0dmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvICggc2hhZG93TWFwU2l6ZSAqIHZlYzIoIDQuMCwgMi4wICkgKTtcXG5cXHRcXHR2ZWMzIGxpZ2h0VG9Qb3NpdGlvbiA9IHNoYWRvd0Nvb3JkLnh5ejtcXG5cXHRcXHRmbG9hdCBkcCA9ICggbGVuZ3RoKCBsaWdodFRvUG9zaXRpb24gKSAtIHNoYWRvd0NhbWVyYU5lYXIgKSAvICggc2hhZG93Q2FtZXJhRmFyIC0gc2hhZG93Q2FtZXJhTmVhciApO1xcdFxcdGRwICs9IHNoYWRvd0JpYXM7XFxuXFx0XFx0dmVjMyBiZDNEID0gbm9ybWFsaXplKCBsaWdodFRvUG9zaXRpb24gKTtcXG5cXHRcXHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGICkgfHwgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKSB8fCBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9WU00gKVxcblxcdFxcdFxcdHZlYzIgb2Zmc2V0ID0gdmVjMiggLSAxLCAxICkgKiBzaGFkb3dSYWRpdXMgKiB0ZXhlbFNpemUueTtcXG5cXHRcXHRcXHRyZXR1cm4gKFxcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHl5LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl5eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eXgsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXl4LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNELCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh4eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eHksIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHh4LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl4eCwgdGV4ZWxTaXplLnkgKSwgZHAgKVxcblxcdFxcdFxcdCkgKiAoIDEuMCAvIDkuMCApO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0cmV0dXJuIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QsIHRleGVsU2l6ZS55ICksIGRwICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcbiNlbmRpZlwiO1xuXG5cdHZhciBzaGFkb3dtYXBfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0I2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRcXHR1bmlmb3JtIG1hdDQgZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0c3RydWN0IERpcmVjdGlvbmFsTGlnaHRTaGFkb3cge1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Tm9ybWFsQmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblxcdFxcdH07XFxuXFx0XFx0dW5pZm9ybSBEaXJlY3Rpb25hbExpZ2h0U2hhZG93IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzWyBOVU1fRElSX0xJR0hUX1NIQURPV1MgXTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRcXHR1bmlmb3JtIG1hdDQgc3BvdFNoYWRvd01hdHJpeFsgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2U3BvdFNoYWRvd0Nvb3JkWyBOVU1fU1BPVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0c3RydWN0IFNwb3RMaWdodFNoYWRvdyB7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93QmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dOb3JtYWxCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHR2ZWMyIHNoYWRvd01hcFNpemU7XFxuXFx0XFx0fTtcXG5cXHRcXHR1bmlmb3JtIFNwb3RMaWdodFNoYWRvdyBzcG90TGlnaHRTaGFkb3dzWyBOVU1fU1BPVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTID4gMFxcblxcdFxcdHVuaWZvcm0gbWF0NCBwb2ludFNoYWRvd01hdHJpeFsgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgXTtcXG5cXHRcXHR2YXJ5aW5nIHZlYzQgdlBvaW50U2hhZG93Q29vcmRbIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0c3RydWN0IFBvaW50TGlnaHRTaGFkb3cge1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Tm9ybWFsQmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0NhbWVyYU5lYXI7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Q2FtZXJhRmFyO1xcblxcdFxcdH07XFxuXFx0XFx0dW5pZm9ybSBQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHRTaGFkb3dzWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdO1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG5cdHZhciBzaGFkb3dtYXBfdmVydGV4ID0gXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcdCNpZiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwIHx8IE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgPiAwIHx8IE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTID4gMFxcblxcdFxcdHZlYzMgc2hhZG93V29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCB0cmFuc2Zvcm1lZE5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcdFxcdHZlYzQgc2hhZG93V29ybGRQb3NpdGlvbjtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX0RJUl9MSUdIVF9TSEFET1dTID4gMFxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUX1NIQURPV1M7IGkgKysgKSB7XFxuXFx0XFx0c2hhZG93V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24gKyB2ZWM0KCBzaGFkb3dXb3JsZE5vcm1hbCAqIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzWyBpIF0uc2hhZG93Tm9ybWFsQmlhcywgMCApO1xcblxcdFxcdHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gPSBkaXJlY3Rpb25hbFNoYWRvd01hdHJpeFsgaSBdICogc2hhZG93V29ybGRQb3NpdGlvbjtcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRfU0hBRE9XUzsgaSArKyApIHtcXG5cXHRcXHRzaGFkb3dXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbiArIHZlYzQoIHNoYWRvd1dvcmxkTm9ybWFsICogc3BvdExpZ2h0U2hhZG93c1sgaSBdLnNoYWRvd05vcm1hbEJpYXMsIDAgKTtcXG5cXHRcXHR2U3BvdFNoYWRvd0Nvb3JkWyBpIF0gPSBzcG90U2hhZG93TWF0cml4WyBpIF0gKiBzaGFkb3dXb3JsZFBvc2l0aW9uO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1M7IGkgKysgKSB7XFxuXFx0XFx0c2hhZG93V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24gKyB2ZWM0KCBzaGFkb3dXb3JsZE5vcm1hbCAqIHBvaW50TGlnaHRTaGFkb3dzWyBpIF0uc2hhZG93Tm9ybWFsQmlhcywgMCApO1xcblxcdFxcdHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0gPSBwb2ludFNoYWRvd01hdHJpeFsgaSBdICogc2hhZG93V29ybGRQb3NpdGlvbjtcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcblxuXHR2YXIgc2hhZG93bWFza19wYXJzX2ZyYWdtZW50ID0gXCJmbG9hdCBnZXRTaGFkb3dNYXNrKCkge1xcblxcdGZsb2F0IHNoYWRvdyA9IDEuMDtcXG5cXHQjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcdCNpZiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0RGlyZWN0aW9uYWxMaWdodFNoYWRvdyBkaXJlY3Rpb25hbExpZ2h0O1xcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUX1NIQURPV1M7IGkgKysgKSB7XFxuXFx0XFx0ZGlyZWN0aW9uYWxMaWdodCA9IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzWyBpIF07XFxuXFx0XFx0c2hhZG93ICo9IHJlY2VpdmVTaGFkb3cgPyBnZXRTaGFkb3coIGRpcmVjdGlvbmFsU2hhZG93TWFwWyBpIF0sIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93TWFwU2l6ZSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dCaWFzLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd1JhZGl1cywgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fU1BPVF9MSUdIVF9TSEFET1dTID4gMFxcblxcdFNwb3RMaWdodFNoYWRvdyBzcG90TGlnaHQ7XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUX1NIQURPV1M7IGkgKysgKSB7XFxuXFx0XFx0c3BvdExpZ2h0ID0gc3BvdExpZ2h0U2hhZG93c1sgaSBdO1xcblxcdFxcdHNoYWRvdyAqPSByZWNlaXZlU2hhZG93ID8gZ2V0U2hhZG93KCBzcG90U2hhZG93TWFwWyBpIF0sIHNwb3RMaWdodC5zaGFkb3dNYXBTaXplLCBzcG90TGlnaHQuc2hhZG93Qmlhcywgc3BvdExpZ2h0LnNoYWRvd1JhZGl1cywgdlNwb3RTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTID4gMFxcblxcdFBvaW50TGlnaHRTaGFkb3cgcG9pbnRMaWdodDtcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1M7IGkgKysgKSB7XFxuXFx0XFx0cG9pbnRMaWdodCA9IHBvaW50TGlnaHRTaGFkb3dzWyBpIF07XFxuXFx0XFx0c2hhZG93ICo9IHJlY2VpdmVTaGFkb3cgPyBnZXRQb2ludFNoYWRvdyggcG9pbnRTaGFkb3dNYXBbIGkgXSwgcG9pbnRMaWdodC5zaGFkb3dNYXBTaXplLCBwb2ludExpZ2h0LnNoYWRvd0JpYXMsIHBvaW50TGlnaHQuc2hhZG93UmFkaXVzLCB2UG9pbnRTaGFkb3dDb29yZFsgaSBdLCBwb2ludExpZ2h0LnNoYWRvd0NhbWVyYU5lYXIsIHBvaW50TGlnaHQuc2hhZG93Q2FtZXJhRmFyICkgOiAxLjA7XFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuXFx0I2VuZGlmXFxuXFx0I2VuZGlmXFxuXFx0cmV0dXJuIHNoYWRvdztcXG59XCI7XG5cblx0dmFyIHNraW5iYXNlX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcdG1hdDQgYm9uZU1hdFggPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueCApO1xcblxcdG1hdDQgYm9uZU1hdFkgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueSApO1xcblxcdG1hdDQgYm9uZU1hdFogPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueiApO1xcblxcdG1hdDQgYm9uZU1hdFcgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgudyApO1xcbiNlbmRpZlwiO1xuXG5cdHZhciBza2lubmluZ19wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4O1xcblxcdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4SW52ZXJzZTtcXG5cXHQjaWZkZWYgQk9ORV9URVhUVVJFXFxuXFx0XFx0dW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgYm9uZVRleHR1cmU7XFxuXFx0XFx0dW5pZm9ybSBpbnQgYm9uZVRleHR1cmVTaXplO1xcblxcdFxcdG1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHtcXG5cXHRcXHRcXHRmbG9hdCBqID0gaSAqIDQuMDtcXG5cXHRcXHRcXHRmbG9hdCB4ID0gbW9kKCBqLCBmbG9hdCggYm9uZVRleHR1cmVTaXplICkgKTtcXG5cXHRcXHRcXHRmbG9hdCB5ID0gZmxvb3IoIGogLyBmbG9hdCggYm9uZVRleHR1cmVTaXplICkgKTtcXG5cXHRcXHRcXHRmbG9hdCBkeCA9IDEuMCAvIGZsb2F0KCBib25lVGV4dHVyZVNpemUgKTtcXG5cXHRcXHRcXHRmbG9hdCBkeSA9IDEuMCAvIGZsb2F0KCBib25lVGV4dHVyZVNpemUgKTtcXG5cXHRcXHRcXHR5ID0gZHkgKiAoIHkgKyAwLjUgKTtcXG5cXHRcXHRcXHR2ZWM0IHYxID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAwLjUgKSwgeSApICk7XFxuXFx0XFx0XFx0dmVjNCB2MiA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMS41ICksIHkgKSApO1xcblxcdFxcdFxcdHZlYzQgdjMgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDIuNSApLCB5ICkgKTtcXG5cXHRcXHRcXHR2ZWM0IHY0ID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAzLjUgKSwgeSApICk7XFxuXFx0XFx0XFx0bWF0NCBib25lID0gbWF0NCggdjEsIHYyLCB2MywgdjQgKTtcXG5cXHRcXHRcXHRyZXR1cm4gYm9uZTtcXG5cXHRcXHR9XFxuXFx0I2Vsc2VcXG5cXHRcXHR1bmlmb3JtIG1hdDQgYm9uZU1hdHJpY2VzWyBNQVhfQk9ORVMgXTtcXG5cXHRcXHRtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFx0XFx0XFx0bWF0NCBib25lID0gYm9uZU1hdHJpY2VzWyBpbnQoaSkgXTtcXG5cXHRcXHRcXHRyZXR1cm4gYm9uZTtcXG5cXHRcXHR9XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cblx0dmFyIHNraW5uaW5nX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcdHZlYzQgc2tpblZlcnRleCA9IGJpbmRNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxuXFx0dmVjNCBza2lubmVkID0gdmVjNCggMC4wICk7XFxuXFx0c2tpbm5lZCArPSBib25lTWF0WCAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lng7XFxuXFx0c2tpbm5lZCArPSBib25lTWF0WSAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnk7XFxuXFx0c2tpbm5lZCArPSBib25lTWF0WiAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lno7XFxuXFx0c2tpbm5lZCArPSBib25lTWF0VyAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnc7XFxuXFx0dHJhbnNmb3JtZWQgPSAoIGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbm5lZCApLnh5ejtcXG4jZW5kaWZcIjtcblxuXHR2YXIgc2tpbm5vcm1hbF92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXHRtYXQ0IHNraW5NYXRyaXggPSBtYXQ0KCAwLjAgKTtcXG5cXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueCAqIGJvbmVNYXRYO1xcblxcdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC55ICogYm9uZU1hdFk7XFxuXFx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnogKiBib25lTWF0WjtcXG5cXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQudyAqIGJvbmVNYXRXO1xcblxcdHNraW5NYXRyaXggPSBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5NYXRyaXggKiBiaW5kTWF0cml4O1xcblxcdG9iamVjdE5vcm1hbCA9IHZlYzQoIHNraW5NYXRyaXggKiB2ZWM0KCBvYmplY3ROb3JtYWwsIDAuMCApICkueHl6O1xcblxcdCNpZmRlZiBVU0VfVEFOR0VOVFxcblxcdFxcdG9iamVjdFRhbmdlbnQgPSB2ZWM0KCBza2luTWF0cml4ICogdmVjNCggb2JqZWN0VGFuZ2VudCwgMC4wICkgKS54eXo7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG5cblx0dmFyIHNwZWN1bGFybWFwX2ZyYWdtZW50ID0gXCJmbG9hdCBzcGVjdWxhclN0cmVuZ3RoO1xcbiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXG5cXHR2ZWM0IHRleGVsU3BlY3VsYXIgPSB0ZXh0dXJlMkQoIHNwZWN1bGFyTWFwLCB2VXYgKTtcXG5cXHRzcGVjdWxhclN0cmVuZ3RoID0gdGV4ZWxTcGVjdWxhci5yO1xcbiNlbHNlXFxuXFx0c3BlY3VsYXJTdHJlbmd0aCA9IDEuMDtcXG4jZW5kaWZcIjtcblxuXHR2YXIgc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyTWFwO1xcbiNlbmRpZlwiO1xuXG5cdHZhciB0b25lbWFwcGluZ19mcmFnbWVudCA9IFwiI2lmIGRlZmluZWQoIFRPTkVfTUFQUElORyApXFxuXFx0Z2xfRnJhZ0NvbG9yLnJnYiA9IHRvbmVNYXBwaW5nKCBnbF9GcmFnQ29sb3IucmdiICk7XFxuI2VuZGlmXCI7XG5cblx0dmFyIHRvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQgPSBcIiNpZm5kZWYgc2F0dXJhdGVcXG4jZGVmaW5lIHNhdHVyYXRlKCBhICkgY2xhbXAoIGEsIDAuMCwgMS4wIClcXG4jZW5kaWZcXG51bmlmb3JtIGZsb2F0IHRvbmVNYXBwaW5nRXhwb3N1cmU7XFxudmVjMyBMaW5lYXJUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcXG5cXHRyZXR1cm4gdG9uZU1hcHBpbmdFeHBvc3VyZSAqIGNvbG9yO1xcbn1cXG52ZWMzIFJlaW5oYXJkVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7XFxuXFx0Y29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTtcXG5cXHRyZXR1cm4gc2F0dXJhdGUoIGNvbG9yIC8gKCB2ZWMzKCAxLjAgKSArIGNvbG9yICkgKTtcXG59XFxudmVjMyBPcHRpbWl6ZWRDaW5lb25Ub25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcXG5cXHRjb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlO1xcblxcdGNvbG9yID0gbWF4KCB2ZWMzKCAwLjAgKSwgY29sb3IgLSAwLjAwNCApO1xcblxcdHJldHVybiBwb3coICggY29sb3IgKiAoIDYuMiAqIGNvbG9yICsgMC41ICkgKSAvICggY29sb3IgKiAoIDYuMiAqIGNvbG9yICsgMS43ICkgKyAwLjA2ICksIHZlYzMoIDIuMiApICk7XFxufVxcbnZlYzMgUlJUQW5kT0RURml0KCB2ZWMzIHYgKSB7XFxuXFx0dmVjMyBhID0gdiAqICggdiArIDAuMDI0NTc4NiApIC0gMC4wMDAwOTA1Mzc7XFxuXFx0dmVjMyBiID0gdiAqICggMC45ODM3MjkgKiB2ICsgMC40MzI5NTEwICkgKyAwLjIzODA4MTtcXG5cXHRyZXR1cm4gYSAvIGI7XFxufVxcbnZlYzMgQUNFU0ZpbG1pY1RvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcblxcdGNvbnN0IG1hdDMgQUNFU0lucHV0TWF0ID0gbWF0MyhcXG5cXHRcXHR2ZWMzKCAwLjU5NzE5LCAwLjA3NjAwLCAwLjAyODQwICksXFx0XFx0dmVjMyggMC4zNTQ1OCwgMC45MDgzNCwgMC4xMzM4MyApLFxcblxcdFxcdHZlYzMoIDAuMDQ4MjMsIDAuMDE1NjYsIDAuODM3NzcgKVxcblxcdCk7XFxuXFx0Y29uc3QgbWF0MyBBQ0VTT3V0cHV0TWF0ID0gbWF0MyhcXG5cXHRcXHR2ZWMzKFx0MS42MDQ3NSwgLTAuMTAyMDgsIC0wLjAwMzI3ICksXFx0XFx0dmVjMyggLTAuNTMxMDgsXHQxLjEwODEzLCAtMC4wNzI3NiApLFxcblxcdFxcdHZlYzMoIC0wLjA3MzY3LCAtMC4wMDYwNSxcdDEuMDc2MDIgKVxcblxcdCk7XFxuXFx0Y29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZSAvIDAuNjtcXG5cXHRjb2xvciA9IEFDRVNJbnB1dE1hdCAqIGNvbG9yO1xcblxcdGNvbG9yID0gUlJUQW5kT0RURml0KCBjb2xvciApO1xcblxcdGNvbG9yID0gQUNFU091dHB1dE1hdCAqIGNvbG9yO1xcblxcdHJldHVybiBzYXR1cmF0ZSggY29sb3IgKTtcXG59XFxudmVjMyBDdXN0b21Ub25lTWFwcGluZyggdmVjMyBjb2xvciApIHsgcmV0dXJuIGNvbG9yOyB9XCI7XG5cblx0dmFyIHRyYW5zbWlzc2lvbl9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9UUkFOU01JU1NJT05cXG5cXHRmbG9hdCB0cmFuc21pc3Npb25BbHBoYSA9IDEuMDtcXG5cXHRmbG9hdCB0cmFuc21pc3Npb25GYWN0b3IgPSB0cmFuc21pc3Npb247XFxuXFx0ZmxvYXQgdGhpY2tuZXNzRmFjdG9yID0gdGhpY2tuZXNzO1xcblxcdCNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OTUFQXFxuXFx0XFx0dHJhbnNtaXNzaW9uRmFjdG9yICo9IHRleHR1cmUyRCggdHJhbnNtaXNzaW9uTWFwLCB2VXYgKS5yO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfVEhJQ0tORVNTTUFQXFxuXFx0XFx0dGhpY2tuZXNzRmFjdG9yICo9IHRleHR1cmUyRCggdGhpY2tuZXNzTWFwLCB2VXYgKS5nO1xcblxcdCNlbmRpZlxcblxcdHZlYzMgcG9zID0gdldvcmxkUG9zaXRpb247XFxuXFx0dmVjMyB2ID0gbm9ybWFsaXplKCBjYW1lcmFQb3NpdGlvbiAtIHBvcyApO1xcblxcdHZlYzMgbiA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcdHZlYzQgdHJhbnNtaXNzaW9uID0gZ2V0SUJMVm9sdW1lUmVmcmFjdGlvbihcXG5cXHRcXHRuLCB2LCByb3VnaG5lc3NGYWN0b3IsIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJGOTAsXFxuXFx0XFx0cG9zLCBtb2RlbE1hdHJpeCwgdmlld01hdHJpeCwgcHJvamVjdGlvbk1hdHJpeCwgaW9yLCB0aGlja25lc3NGYWN0b3IsXFxuXFx0XFx0YXR0ZW51YXRpb25Db2xvciwgYXR0ZW51YXRpb25EaXN0YW5jZSApO1xcblxcdHRvdGFsRGlmZnVzZSA9IG1peCggdG90YWxEaWZmdXNlLCB0cmFuc21pc3Npb24ucmdiLCB0cmFuc21pc3Npb25GYWN0b3IgKTtcXG5cXHR0cmFuc21pc3Npb25BbHBoYSA9IG1peCggdHJhbnNtaXNzaW9uQWxwaGEsIHRyYW5zbWlzc2lvbi5hLCB0cmFuc21pc3Npb25GYWN0b3IgKTtcXG4jZW5kaWZcIjtcblxuXHR2YXIgdHJhbnNtaXNzaW9uX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OXFxuXFx0dW5pZm9ybSBmbG9hdCB0cmFuc21pc3Npb247XFxuXFx0dW5pZm9ybSBmbG9hdCB0aGlja25lc3M7XFxuXFx0dW5pZm9ybSBmbG9hdCBhdHRlbnVhdGlvbkRpc3RhbmNlO1xcblxcdHVuaWZvcm0gdmVjMyBhdHRlbnVhdGlvbkNvbG9yO1xcblxcdCNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OTUFQXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgdHJhbnNtaXNzaW9uTWFwO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfVEhJQ0tORVNTTUFQXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgdGhpY2tuZXNzTWFwO1xcblxcdCNlbmRpZlxcblxcdHVuaWZvcm0gdmVjMiB0cmFuc21pc3Npb25TYW1wbGVyU2l6ZTtcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCB0cmFuc21pc3Npb25TYW1wbGVyTWFwO1xcblxcdHVuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDtcXG5cXHR1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDtcXG5cXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuXFx0dmVjMyBnZXRWb2x1bWVUcmFuc21pc3Npb25SYXkoIHZlYzMgbiwgdmVjMyB2LCBmbG9hdCB0aGlja25lc3MsIGZsb2F0IGlvciwgbWF0NCBtb2RlbE1hdHJpeCApIHtcXG5cXHRcXHR2ZWMzIHJlZnJhY3Rpb25WZWN0b3IgPSByZWZyYWN0KCAtIHYsIG5vcm1hbGl6ZSggbiApLCAxLjAgLyBpb3IgKTtcXG5cXHRcXHR2ZWMzIG1vZGVsU2NhbGU7XFxuXFx0XFx0bW9kZWxTY2FsZS54ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMCBdLnh5eiApICk7XFxuXFx0XFx0bW9kZWxTY2FsZS55ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMSBdLnh5eiApICk7XFxuXFx0XFx0bW9kZWxTY2FsZS56ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMiBdLnh5eiApICk7XFxuXFx0XFx0cmV0dXJuIG5vcm1hbGl6ZSggcmVmcmFjdGlvblZlY3RvciApICogdGhpY2tuZXNzICogbW9kZWxTY2FsZTtcXG5cXHR9XFxuXFx0ZmxvYXQgYXBwbHlJb3JUb1JvdWdobmVzcyggZmxvYXQgcm91Z2huZXNzLCBmbG9hdCBpb3IgKSB7XFxuXFx0XFx0cmV0dXJuIHJvdWdobmVzcyAqIGNsYW1wKCBpb3IgKiAyLjAgLSAyLjAsIDAuMCwgMS4wICk7XFxuXFx0fVxcblxcdHZlYzQgZ2V0VHJhbnNtaXNzaW9uU2FtcGxlKCB2ZWMyIGZyYWdDb29yZCwgZmxvYXQgcm91Z2huZXNzLCBmbG9hdCBpb3IgKSB7XFxuXFx0XFx0ZmxvYXQgZnJhbWVidWZmZXJMb2QgPSBsb2cyKCB0cmFuc21pc3Npb25TYW1wbGVyU2l6ZS54ICkgKiBhcHBseUlvclRvUm91Z2huZXNzKCByb3VnaG5lc3MsIGlvciApO1xcblxcdFxcdCNpZmRlZiBURVhUVVJFX0xPRF9FWFRcXG5cXHRcXHRcXHRyZXR1cm4gdGV4dHVyZTJETG9kRVhUKCB0cmFuc21pc3Npb25TYW1wbGVyTWFwLCBmcmFnQ29vcmQueHksIGZyYW1lYnVmZmVyTG9kICk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRyZXR1cm4gdGV4dHVyZTJEKCB0cmFuc21pc3Npb25TYW1wbGVyTWFwLCBmcmFnQ29vcmQueHksIGZyYW1lYnVmZmVyTG9kICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcblxcdHZlYzMgYXBwbHlWb2x1bWVBdHRlbnVhdGlvbiggdmVjMyByYWRpYW5jZSwgZmxvYXQgdHJhbnNtaXNzaW9uRGlzdGFuY2UsIHZlYzMgYXR0ZW51YXRpb25Db2xvciwgZmxvYXQgYXR0ZW51YXRpb25EaXN0YW5jZSApIHtcXG5cXHRcXHRpZiAoIGF0dGVudWF0aW9uRGlzdGFuY2UgPT0gMC4wICkge1xcblxcdFxcdFxcdHJldHVybiByYWRpYW5jZTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHZlYzMgYXR0ZW51YXRpb25Db2VmZmljaWVudCA9IC1sb2coIGF0dGVudWF0aW9uQ29sb3IgKSAvIGF0dGVudWF0aW9uRGlzdGFuY2U7XFxuXFx0XFx0XFx0dmVjMyB0cmFuc21pdHRhbmNlID0gZXhwKCAtIGF0dGVudWF0aW9uQ29lZmZpY2llbnQgKiB0cmFuc21pc3Npb25EaXN0YW5jZSApO1xcdFxcdFxcdHJldHVybiB0cmFuc21pdHRhbmNlICogcmFkaWFuY2U7XFxuXFx0XFx0fVxcblxcdH1cXG5cXHR2ZWM0IGdldElCTFZvbHVtZVJlZnJhY3Rpb24oIHZlYzMgbiwgdmVjMyB2LCBmbG9hdCByb3VnaG5lc3MsIHZlYzMgZGlmZnVzZUNvbG9yLCB2ZWMzIHNwZWN1bGFyQ29sb3IsIGZsb2F0IHNwZWN1bGFyRjkwLFxcblxcdFxcdHZlYzMgcG9zaXRpb24sIG1hdDQgbW9kZWxNYXRyaXgsIG1hdDQgdmlld01hdHJpeCwgbWF0NCBwcm9qTWF0cml4LCBmbG9hdCBpb3IsIGZsb2F0IHRoaWNrbmVzcyxcXG5cXHRcXHR2ZWMzIGF0dGVudWF0aW9uQ29sb3IsIGZsb2F0IGF0dGVudWF0aW9uRGlzdGFuY2UgKSB7XFxuXFx0XFx0dmVjMyB0cmFuc21pc3Npb25SYXkgPSBnZXRWb2x1bWVUcmFuc21pc3Npb25SYXkoIG4sIHYsIHRoaWNrbmVzcywgaW9yLCBtb2RlbE1hdHJpeCApO1xcblxcdFxcdHZlYzMgcmVmcmFjdGVkUmF5RXhpdCA9IHBvc2l0aW9uICsgdHJhbnNtaXNzaW9uUmF5O1xcblxcdFxcdHZlYzQgbmRjUG9zID0gcHJvak1hdHJpeCAqIHZpZXdNYXRyaXggKiB2ZWM0KCByZWZyYWN0ZWRSYXlFeGl0LCAxLjAgKTtcXG5cXHRcXHR2ZWMyIHJlZnJhY3Rpb25Db29yZHMgPSBuZGNQb3MueHkgLyBuZGNQb3MudztcXG5cXHRcXHRyZWZyYWN0aW9uQ29vcmRzICs9IDEuMDtcXG5cXHRcXHRyZWZyYWN0aW9uQ29vcmRzIC89IDIuMDtcXG5cXHRcXHR2ZWM0IHRyYW5zbWl0dGVkTGlnaHQgPSBnZXRUcmFuc21pc3Npb25TYW1wbGUoIHJlZnJhY3Rpb25Db29yZHMsIHJvdWdobmVzcywgaW9yICk7XFxuXFx0XFx0dmVjMyBhdHRlbnVhdGVkQ29sb3IgPSBhcHBseVZvbHVtZUF0dGVudWF0aW9uKCB0cmFuc21pdHRlZExpZ2h0LnJnYiwgbGVuZ3RoKCB0cmFuc21pc3Npb25SYXkgKSwgYXR0ZW51YXRpb25Db2xvciwgYXR0ZW51YXRpb25EaXN0YW5jZSApO1xcblxcdFxcdHZlYzMgRiA9IEVudmlyb25tZW50QlJERiggbiwgdiwgc3BlY3VsYXJDb2xvciwgc3BlY3VsYXJGOTAsIHJvdWdobmVzcyApO1xcblxcdFxcdHJldHVybiB2ZWM0KCAoIDEuMCAtIEYgKSAqIGF0dGVudWF0ZWRDb2xvciAqIGRpZmZ1c2VDb2xvciwgdHJhbnNtaXR0ZWRMaWdodC5hICk7XFxuXFx0fVxcbiNlbmRpZlwiO1xuXG5cdHZhciB1dl9wYXJzX2ZyYWdtZW50ID0gXCIjaWYgKCBkZWZpbmVkKCBVU0VfVVYgKSAmJiAhIGRlZmluZWQoIFVWU19WRVJURVhfT05MWSApIClcXG5cXHR2YXJ5aW5nIHZlYzIgdlV2O1xcbiNlbmRpZlwiO1xuXG5cdHZhciB1dl9wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9VVlxcblxcdCNpZmRlZiBVVlNfVkVSVEVYX09OTFlcXG5cXHRcXHR2ZWMyIHZVdjtcXG5cXHQjZWxzZVxcblxcdFxcdHZhcnlpbmcgdmVjMiB2VXY7XFxuXFx0I2VuZGlmXFxuXFx0dW5pZm9ybSBtYXQzIHV2VHJhbnNmb3JtO1xcbiNlbmRpZlwiO1xuXG5cdHZhciB1dl92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfVVZcXG5cXHR2VXYgPSAoIHV2VHJhbnNmb3JtICogdmVjMyggdXYsIDEgKSApLnh5O1xcbiNlbmRpZlwiO1xuXG5cdHZhciB1djJfcGFyc19mcmFnbWVudCA9IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXFx0dmFyeWluZyB2ZWMyIHZVdjI7XFxuI2VuZGlmXCI7XG5cblx0dmFyIHV2Ml9wYXJzX3ZlcnRleCA9IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXFx0YXR0cmlidXRlIHZlYzIgdXYyO1xcblxcdHZhcnlpbmcgdmVjMiB2VXYyO1xcblxcdHVuaWZvcm0gbWF0MyB1djJUcmFuc2Zvcm07XFxuI2VuZGlmXCI7XG5cblx0dmFyIHV2Ml92ZXJ0ZXggPSBcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblxcdHZVdjIgPSAoIHV2MlRyYW5zZm9ybSAqIHZlYzMoIHV2MiwgMSApICkueHk7XFxuI2VuZGlmXCI7XG5cblx0dmFyIHdvcmxkcG9zX3ZlcnRleCA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkKCBESVNUQU5DRSApIHx8IGRlZmluZWQgKCBVU0VfU0hBRE9XTUFQICkgfHwgZGVmaW5lZCAoIFVTRV9UUkFOU01JU1NJT04gKVxcblxcdHZlYzQgd29ybGRQb3NpdGlvbiA9IHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG5cXHQjaWZkZWYgVVNFX0lOU1RBTkNJTkdcXG5cXHRcXHR3b3JsZFBvc2l0aW9uID0gaW5zdGFuY2VNYXRyaXggKiB3b3JsZFBvc2l0aW9uO1xcblxcdCNlbmRpZlxcblxcdHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHdvcmxkUG9zaXRpb247XFxuI2VuZGlmXCI7XG5cblx0Y29uc3QgdmVydGV4JGcgPSBcInZhcnlpbmcgdmVjMiB2VXY7XFxudW5pZm9ybSBtYXQzIHV2VHJhbnNmb3JtO1xcbnZvaWQgbWFpbigpIHtcXG5cXHR2VXYgPSAoIHV2VHJhbnNmb3JtICogdmVjMyggdXYsIDEgKSApLnh5O1xcblxcdGdsX1Bvc2l0aW9uID0gdmVjNCggcG9zaXRpb24ueHksIDEuMCwgMS4wICk7XFxufVwiO1xuXHRjb25zdCBmcmFnbWVudCRnID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCB0MkQ7XFxudmFyeWluZyB2ZWMyIHZVdjtcXG52b2lkIG1haW4oKSB7XFxuXFx0dmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRCggdDJELCB2VXYgKTtcXG5cXHRnbF9GcmFnQ29sb3IgPSBtYXBUZXhlbFRvTGluZWFyKCB0ZXhDb2xvciApO1xcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50Plxcbn1cIjtcblxuXHRjb25zdCB2ZXJ0ZXgkZiA9IFwidmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2V29ybGREaXJlY3Rpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1xcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdGdsX1Bvc2l0aW9uLnogPSBnbF9Qb3NpdGlvbi53O1xcbn1cIjtcblx0Y29uc3QgZnJhZ21lbnQkZiA9IFwiI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD5cXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcXG4jaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWMzIHZSZWZsZWN0ID0gdldvcmxkRGlyZWN0aW9uO1xcblxcdCNpbmNsdWRlIDxlbnZtYXBfZnJhZ21lbnQ+XFxuXFx0Z2xfRnJhZ0NvbG9yID0gZW52Q29sb3I7XFxuXFx0Z2xfRnJhZ0NvbG9yLmEgKj0gb3BhY2l0eTtcXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG59XCI7XG5cblx0Y29uc3QgdmVydGV4JGUgPSBcIiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52YXJ5aW5nIHZlYzIgdkhpZ2hQcmVjaXNpb25aVztcXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxuXFx0XFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHRcXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdFxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjZW5kaWZcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHR2SGlnaFByZWNpc2lvblpXID0gZ2xfUG9zaXRpb24uenc7XFxufVwiO1xuXHRjb25zdCBmcmFnbWVudCRlID0gXCIjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwXFxuXFx0dW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudmFyeWluZyB2ZWMyIHZIaWdoUHJlY2lzaW9uWlc7XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCAxLjAgKTtcXG5cXHQjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwXFxuXFx0XFx0ZGlmZnVzZUNvbG9yLmEgPSBvcGFjaXR5O1xcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdGZsb2F0IGZyYWdDb29yZFogPSAwLjUgKiB2SGlnaFByZWNpc2lvblpXWzBdIC8gdkhpZ2hQcmVjaXNpb25aV1sxXSArIDAuNTtcXG5cXHQjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyggMS4wIC0gZnJhZ0Nvb3JkWiApLCBvcGFjaXR5ICk7XFxuXFx0I2VsaWYgREVQVEhfUEFDS0lORyA9PSAzMjAxXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gcGFja0RlcHRoVG9SR0JBKCBmcmFnQ29vcmRaICk7XFxuXFx0I2VuZGlmXFxufVwiO1xuXG5cdGNvbnN0IHZlcnRleCRkID0gXCIjZGVmaW5lIERJU1RBTkNFXFxudmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXG5cXHRcXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdFxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0XFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XFxufVwiO1xuXHRjb25zdCBmcmFnbWVudCRkID0gXCIjZGVmaW5lIERJU1RBTkNFXFxudW5pZm9ybSB2ZWMzIHJlZmVyZW5jZVBvc2l0aW9uO1xcbnVuaWZvcm0gZmxvYXQgbmVhckRpc3RhbmNlO1xcbnVuaWZvcm0gZmxvYXQgZmFyRGlzdGFuY2U7XFxudmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluICgpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggMS4wICk7XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHRmbG9hdCBkaXN0ID0gbGVuZ3RoKCB2V29ybGRQb3NpdGlvbiAtIHJlZmVyZW5jZVBvc2l0aW9uICk7XFxuXFx0ZGlzdCA9ICggZGlzdCAtIG5lYXJEaXN0YW5jZSApIC8gKCBmYXJEaXN0YW5jZSAtIG5lYXJEaXN0YW5jZSApO1xcblxcdGRpc3QgPSBzYXR1cmF0ZSggZGlzdCApO1xcblxcdGdsX0ZyYWdDb2xvciA9IHBhY2tEZXB0aFRvUkdCQSggZGlzdCApO1xcbn1cIjtcblxuXHRjb25zdCB2ZXJ0ZXgkYyA9IFwidmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2V29ybGREaXJlY3Rpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1xcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4Plxcbn1cIjtcblx0Y29uc3QgZnJhZ21lbnQkYyA9IFwidW5pZm9ybSBzYW1wbGVyMkQgdEVxdWlyZWN0O1xcbnZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG52b2lkIG1haW4oKSB7XFxuXFx0dmVjMyBkaXJlY3Rpb24gPSBub3JtYWxpemUoIHZXb3JsZERpcmVjdGlvbiApO1xcblxcdHZlYzIgc2FtcGxlVVYgPSBlcXVpcmVjdFV2KCBkaXJlY3Rpb24gKTtcXG5cXHR2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKCB0RXF1aXJlY3QsIHNhbXBsZVVWICk7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gbWFwVGV4ZWxUb0xpbmVhciggdGV4Q29sb3IgKTtcXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG59XCI7XG5cblx0Y29uc3QgdmVydGV4JGIgPSBcInVuaWZvcm0gZmxvYXQgc2NhbGU7XFxuYXR0cmlidXRlIGZsb2F0IGxpbmVEaXN0YW5jZTtcXG52YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdHZMaW5lRGlzdGFuY2UgPSBzY2FsZSAqIGxpbmVEaXN0YW5jZTtcXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XCI7XG5cdGNvbnN0IGZyYWdtZW50JGIgPSBcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG51bmlmb3JtIGZsb2F0IGRhc2hTaXplO1xcbnVuaWZvcm0gZmxvYXQgdG90YWxTaXplO1xcbnZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0aWYgKCBtb2QoIHZMaW5lRGlzdGFuY2UsIHRvdGFsU2l6ZSApID4gZGFzaFNpemUgKSB7XFxuXFx0XFx0ZGlzY2FyZDtcXG5cXHR9XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHRvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjtcXG5cXHQjaW5jbHVkZSA8b3V0cHV0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxufVwiO1xuXG5cdGNvbnN0IHZlcnRleCRhID0gXCIjaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8dXYyX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpZiBkZWZpbmVkICggVVNFX0VOVk1BUCApIHx8IGRlZmluZWQgKCBVU0VfU0tJTk5JTkcgKVxcblxcdFxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0XFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHRcXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdFxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHRcXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2VuZGlmXFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XCI7XG5cdGNvbnN0IGZyYWdtZW50JGEgPSBcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuI2VuZGlmXFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8c3BlY3VsYXJtYXBfZnJhZ21lbnQ+XFxuXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXG5cXHQjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFx0XFx0dmVjNCBsaWdodE1hcFRleGVsPSB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICk7XFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGxpZ2h0TWFwVGV4ZWxUb0xpbmVhciggbGlnaHRNYXBUZXhlbCApLnJnYiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1xcblxcdCNlbHNlXFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IHZlYzMoIDEuMCApO1xcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD5cXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKj0gZGlmZnVzZUNvbG9yLnJnYjtcXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2U7XFxuXFx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8b3V0cHV0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cXG59XCI7XG5cblx0Y29uc3QgdmVydGV4JDkgPSBcIiNkZWZpbmUgTEFNQkVSVFxcbnZhcnlpbmcgdmVjMyB2TGlnaHRGcm9udDtcXG52YXJ5aW5nIHZlYzMgdkluZGlyZWN0RnJvbnQ7XFxuI2lmZGVmIERPVUJMRV9TSURFRFxcblxcdHZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1xcblxcdHZhcnlpbmcgdmVjMyB2SW5kaXJlY3RCYWNrO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8YnNkZnM+XFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8dXYyX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2xhbWJlcnRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cIjtcblx0Y29uc3QgZnJhZ21lbnQkOSA9IFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG52YXJ5aW5nIHZlYzMgdkxpZ2h0RnJvbnQ7XFxudmFyeWluZyB2ZWMzIHZJbmRpcmVjdEZyb250O1xcbiNpZmRlZiBET1VCTEVfU0lERURcXG5cXHR2YXJ5aW5nIHZlYzMgdkxpZ2h0QmFjaztcXG5cXHR2YXJ5aW5nIHZlYzMgdkluZGlyZWN0QmFjaztcXG4jZW5kaWZcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxic2Rmcz5cXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnNfYmVnaW4+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c2hhZG93bWFza19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApO1xcblxcdHZlYzMgdG90YWxFbWlzc2l2ZVJhZGlhbmNlID0gZW1pc3NpdmU7XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxzcGVjdWxhcm1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW1pc3NpdmVtYXBfZnJhZ21lbnQ+XFxuXFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSAoIGdsX0Zyb250RmFjaW5nICkgPyB2SW5kaXJlY3RGcm9udCA6IHZJbmRpcmVjdEJhY2s7XFxuXFx0I2Vsc2VcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gdkluZGlyZWN0RnJvbnQ7XFxuXFx0I2VuZGlmXFxuXFx0I2luY2x1ZGUgPGxpZ2h0bWFwX2ZyYWdtZW50PlxcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSAqPSBCUkRGX0xhbWJlcnQoIGRpZmZ1c2VDb2xvci5yZ2IgKTtcXG5cXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSA9ICggZ2xfRnJvbnRGYWNpbmcgKSA/IHZMaWdodEZyb250IDogdkxpZ2h0QmFjaztcXG5cXHQjZWxzZVxcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgPSB2TGlnaHRGcm9udDtcXG5cXHQjZW5kaWZcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICo9IEJSREZfTGFtYmVydCggZGlmZnVzZUNvbG9yLnJnYiApICogZ2V0U2hhZG93TWFzaygpO1xcblxcdCNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD5cXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICsgdG90YWxFbWlzc2l2ZVJhZGlhbmNlO1xcblxcdCNpbmNsdWRlIDxlbnZtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG91dHB1dF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XFxufVwiO1xuXG5cdGNvbnN0IHZlcnRleCQ4ID0gXCIjZGVmaW5lIE1BVENBUFxcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG5cXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXG59XCI7XG5cdGNvbnN0IGZyYWdtZW50JDggPSBcIiNkZWZpbmUgTUFUQ0FQXFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnVuaWZvcm0gc2FtcGxlcjJEIG1hdGNhcDtcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X2JlZ2luPlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz5cXG5cXHR2ZWMzIHZpZXdEaXIgPSBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcXG5cXHR2ZWMzIHggPSBub3JtYWxpemUoIHZlYzMoIHZpZXdEaXIueiwgMC4wLCAtIHZpZXdEaXIueCApICk7XFxuXFx0dmVjMyB5ID0gY3Jvc3MoIHZpZXdEaXIsIHggKTtcXG5cXHR2ZWMyIHV2ID0gdmVjMiggZG90KCB4LCBub3JtYWwgKSwgZG90KCB5LCBub3JtYWwgKSApICogMC40OTUgKyAwLjU7XFxuXFx0I2lmZGVmIFVTRV9NQVRDQVBcXG5cXHRcXHR2ZWM0IG1hdGNhcENvbG9yID0gdGV4dHVyZTJEKCBtYXRjYXAsIHV2ICk7XFxuXFx0XFx0bWF0Y2FwQ29sb3IgPSBtYXRjYXBUZXhlbFRvTGluZWFyKCBtYXRjYXBDb2xvciApO1xcblxcdCNlbHNlXFxuXFx0XFx0dmVjNCBtYXRjYXBDb2xvciA9IHZlYzQoIDEuMCApO1xcblxcdCNlbmRpZlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2IgKiBtYXRjYXBDb2xvci5yZ2I7XFxuXFx0I2luY2x1ZGUgPG91dHB1dF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XFxufVwiO1xuXG5cdGNvbnN0IHZlcnRleCQ3ID0gXCIjZGVmaW5lIE5PUk1BTFxcbiNpZiBkZWZpbmVkKCBGTEFUX1NIQURFRCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVEFOR0VOVFNQQUNFX05PUk1BTE1BUCApXFxuXFx0dmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2VuZGlmXFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG4jaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFRBTkdFTlRTUEFDRV9OT1JNQUxNQVAgKVxcblxcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcbiNlbmRpZlxcbn1cIjtcblx0Y29uc3QgZnJhZ21lbnQkNyA9IFwiI2RlZmluZSBOT1JNQUxcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2lmIGRlZmluZWQoIEZMQVRfU0hBREVEICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBUQU5HRU5UU1BBQ0VfTk9STUFMTUFQIClcXG5cXHR2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jZW5kaWZcXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X2JlZ2luPlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz5cXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBwYWNrTm9ybWFsVG9SR0IoIG5vcm1hbCApLCBvcGFjaXR5ICk7XFxufVwiO1xuXG5cdGNvbnN0IHZlcnRleCQ2ID0gXCIjZGVmaW5lIFBIT05HXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxufVwiO1xuXHRjb25zdCBmcmFnbWVudCQ2ID0gXCIjZGVmaW5lIFBIT05HXFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcbnVuaWZvcm0gdmVjMyBzcGVjdWxhcjtcXG51bmlmb3JtIGZsb2F0IHNoaW5pbmVzcztcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJzZGZzPlxcbiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXG5cXHR2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8c3BlY3VsYXJtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfcGhvbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9lbmQ+XFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxuXFx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8b3V0cHV0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cXG59XCI7XG5cblx0Y29uc3QgdmVydGV4JDUgPSBcIiNkZWZpbmUgU1RBTkRBUkRcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaWZkZWYgVVNFX1RSQU5TTUlTU0lPTlxcblxcdHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG4jZW5kaWZcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxuI2lmZGVmIFVTRV9UUkFOU01JU1NJT05cXG5cXHR2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1xcbiNlbmRpZlxcbn1cIjtcblx0Y29uc3QgZnJhZ21lbnQkNSA9IFwiI2RlZmluZSBTVEFOREFSRFxcbiNpZmRlZiBQSFlTSUNBTFxcblxcdCNkZWZpbmUgSU9SXFxuXFx0I2RlZmluZSBTUEVDVUxBUlxcbiNlbmRpZlxcbnVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcXG51bmlmb3JtIGZsb2F0IHJvdWdobmVzcztcXG51bmlmb3JtIGZsb2F0IG1ldGFsbmVzcztcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2lmZGVmIElPUlxcblxcdHVuaWZvcm0gZmxvYXQgaW9yO1xcbiNlbmRpZlxcbiNpZmRlZiBTUEVDVUxBUlxcblxcdHVuaWZvcm0gZmxvYXQgc3BlY3VsYXJJbnRlbnNpdHk7XFxuXFx0dW5pZm9ybSB2ZWMzIHNwZWN1bGFyQ29sb3I7XFxuXFx0I2lmZGVmIFVTRV9TUEVDVUxBUklOVEVOU0lUWU1BUFxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFySW50ZW5zaXR5TWFwO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfU1BFQ1VMQVJDT0xPUk1BUFxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyQ29sb3JNYXA7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHR1bmlmb3JtIGZsb2F0IGNsZWFyY29hdDtcXG5cXHR1bmlmb3JtIGZsb2F0IGNsZWFyY29hdFJvdWdobmVzcztcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX1NIRUVOXFxuXFx0dW5pZm9ybSB2ZWMzIHNoZWVuQ29sb3I7XFxuXFx0dW5pZm9ybSBmbG9hdCBzaGVlblJvdWdobmVzcztcXG5cXHQjaWZkZWYgVVNFX1NIRUVOQ09MT1JNQVBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBzaGVlbkNvbG9yTWFwO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfU0hFRU5ST1VHSE5FU1NNQVBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBzaGVlblJvdWdobmVzc01hcDtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnNkZnM+XFxuI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGh5c2ljYWxfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPlxcbiNpbmNsdWRlIDxub3JtYWxfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHRyYW5zbWlzc2lvbl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xlYXJjb2F0X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXG5cXHR2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8cm91Z2huZXNzbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxtZXRhbG5lc3NtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfYmVnaW4+XFxuXFx0I2luY2x1ZGUgPGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfbWFwcz5cXG5cXHQjaW5jbHVkZSA8ZW1pc3NpdmVtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2JlZ2luPlxcblxcdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfbWFwcz5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2VuZD5cXG5cXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XFxuXFx0dmVjMyB0b3RhbERpZmZ1c2UgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlO1xcblxcdHZlYzMgdG90YWxTcGVjdWxhciA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhcjtcXG5cXHQjaW5jbHVkZSA8dHJhbnNtaXNzaW9uX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHRvdGFsRGlmZnVzZSArIHRvdGFsU3BlY3VsYXIgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxuXFx0I2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHRcXHRmbG9hdCBkb3ROVmNjID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkuY2xlYXJjb2F0Tm9ybWFsLCBnZW9tZXRyeS52aWV3RGlyICkgKTtcXG5cXHRcXHR2ZWMzIEZjYyA9IEZfU2NobGljayggbWF0ZXJpYWwuY2xlYXJjb2F0RjAsIG1hdGVyaWFsLmNsZWFyY29hdEY5MCwgZG90TlZjYyApO1xcblxcdFxcdG91dGdvaW5nTGlnaHQgPSBvdXRnb2luZ0xpZ2h0ICogKCAxLjAgLSBtYXRlcmlhbC5jbGVhcmNvYXQgKiBGY2MgKSArIGNsZWFyY29hdFNwZWN1bGFyICogbWF0ZXJpYWwuY2xlYXJjb2F0O1xcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxvdXRwdXRfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Plxcbn1cIjtcblxuXHRjb25zdCB2ZXJ0ZXgkNCA9IFwiI2RlZmluZSBUT09OXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxub3JtYWxfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx1djJfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cIjtcblx0Y29uc3QgZnJhZ21lbnQkNCA9IFwiI2RlZmluZSBUT09OXFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Z3JhZGllbnRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJzZGZzPlxcbiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0c190b29uX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApO1xcblxcdHZlYzMgdG90YWxFbWlzc2l2ZVJhZGlhbmNlID0gZW1pc3NpdmU7XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfYmVnaW4+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPlxcblxcdCNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX3Rvb25fZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9lbmQ+XFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxuXFx0I2luY2x1ZGUgPG91dHB1dF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XFxufVwiO1xuXG5cdGNvbnN0IHZlcnRleCQzID0gXCJ1bmlmb3JtIGZsb2F0IHNpemU7XFxudW5pZm9ybSBmbG9hdCBzY2FsZTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdGdsX1BvaW50U2l6ZSA9IHNpemU7XFxuXFx0I2lmZGVmIFVTRV9TSVpFQVRURU5VQVRJT05cXG5cXHRcXHRib29sIGlzUGVyc3BlY3RpdmUgPSBpc1BlcnNwZWN0aXZlTWF0cml4KCBwcm9qZWN0aW9uTWF0cml4ICk7XFxuXFx0XFx0aWYgKCBpc1BlcnNwZWN0aXZlICkgZ2xfUG9pbnRTaXplICo9ICggc2NhbGUgLyAtIG12UG9zaXRpb24ueiApO1xcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XCI7XG5cdGNvbnN0IGZyYWdtZW50JDMgPSBcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9wYXJ0aWNsZV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHRvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjtcXG5cXHQjaW5jbHVkZSA8b3V0cHV0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxufVwiO1xuXG5cdGNvbnN0IHZlcnRleCQyID0gXCIjaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cIjtcblx0Y29uc3QgZnJhZ21lbnQkMiA9IFwidW5pZm9ybSB2ZWMzIGNvbG9yO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnNkZnM+XFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c2hhZG93bWFza19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBjb2xvciwgb3BhY2l0eSAqICggMS4wIC0gZ2V0U2hhZG93TWFzaygpICkgKTtcXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50Plxcbn1cIjtcblxuXHRjb25zdCB2ZXJ0ZXgkMSA9IFwidW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcXG51bmlmb3JtIHZlYzIgY2VudGVyO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0dmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggMC4wLCAwLjAsIDAuMCwgMS4wICk7XFxuXFx0dmVjMiBzY2FsZTtcXG5cXHRzY2FsZS54ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMCBdLngsIG1vZGVsTWF0cml4WyAwIF0ueSwgbW9kZWxNYXRyaXhbIDAgXS56ICkgKTtcXG5cXHRzY2FsZS55ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMSBdLngsIG1vZGVsTWF0cml4WyAxIF0ueSwgbW9kZWxNYXRyaXhbIDEgXS56ICkgKTtcXG5cXHQjaWZuZGVmIFVTRV9TSVpFQVRURU5VQVRJT05cXG5cXHRcXHRib29sIGlzUGVyc3BlY3RpdmUgPSBpc1BlcnNwZWN0aXZlTWF0cml4KCBwcm9qZWN0aW9uTWF0cml4ICk7XFxuXFx0XFx0aWYgKCBpc1BlcnNwZWN0aXZlICkgc2NhbGUgKj0gLSBtdlBvc2l0aW9uLno7XFxuXFx0I2VuZGlmXFxuXFx0dmVjMiBhbGlnbmVkUG9zaXRpb24gPSAoIHBvc2l0aW9uLnh5IC0gKCBjZW50ZXIgLSB2ZWMyKCAwLjUgKSApICkgKiBzY2FsZTtcXG5cXHR2ZWMyIHJvdGF0ZWRQb3NpdGlvbjtcXG5cXHRyb3RhdGVkUG9zaXRpb24ueCA9IGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7XFxuXFx0cm90YXRlZFBvc2l0aW9uLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55O1xcblxcdG12UG9zaXRpb24ueHkgKz0gcm90YXRlZFBvc2l0aW9uO1xcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XCI7XG5cdGNvbnN0IGZyYWdtZW50JDEgPSBcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHRvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjtcXG5cXHQjaW5jbHVkZSA8b3V0cHV0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxufVwiO1xuXG5cdGNvbnN0IFNoYWRlckNodW5rID0ge1xuXHRcdGFscGhhbWFwX2ZyYWdtZW50OiBhbHBoYW1hcF9mcmFnbWVudCxcblx0XHRhbHBoYW1hcF9wYXJzX2ZyYWdtZW50OiBhbHBoYW1hcF9wYXJzX2ZyYWdtZW50LFxuXHRcdGFscGhhdGVzdF9mcmFnbWVudDogYWxwaGF0ZXN0X2ZyYWdtZW50LFxuXHRcdGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50OiBhbHBoYXRlc3RfcGFyc19mcmFnbWVudCxcblx0XHRhb21hcF9mcmFnbWVudDogYW9tYXBfZnJhZ21lbnQsXG5cdFx0YW9tYXBfcGFyc19mcmFnbWVudDogYW9tYXBfcGFyc19mcmFnbWVudCxcblx0XHRiZWdpbl92ZXJ0ZXg6IGJlZ2luX3ZlcnRleCxcblx0XHRiZWdpbm5vcm1hbF92ZXJ0ZXg6IGJlZ2lubm9ybWFsX3ZlcnRleCxcblx0XHRic2RmczogYnNkZnMsXG5cdFx0YnVtcG1hcF9wYXJzX2ZyYWdtZW50OiBidW1wbWFwX3BhcnNfZnJhZ21lbnQsXG5cdFx0Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50OiBjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQsXG5cdFx0Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ6IGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50LFxuXHRcdGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleDogY2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4LFxuXHRcdGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg6IGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXgsXG5cdFx0Y29sb3JfZnJhZ21lbnQ6IGNvbG9yX2ZyYWdtZW50LFxuXHRcdGNvbG9yX3BhcnNfZnJhZ21lbnQ6IGNvbG9yX3BhcnNfZnJhZ21lbnQsXG5cdFx0Y29sb3JfcGFyc192ZXJ0ZXg6IGNvbG9yX3BhcnNfdmVydGV4LFxuXHRcdGNvbG9yX3ZlcnRleDogY29sb3JfdmVydGV4LFxuXHRcdGNvbW1vbjogY29tbW9uLFxuXHRcdGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudDogY3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50LFxuXHRcdGRlZmF1bHRub3JtYWxfdmVydGV4OiBkZWZhdWx0bm9ybWFsX3ZlcnRleCxcblx0XHRkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg6IGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleCxcblx0XHRkaXNwbGFjZW1lbnRtYXBfdmVydGV4OiBkaXNwbGFjZW1lbnRtYXBfdmVydGV4LFxuXHRcdGVtaXNzaXZlbWFwX2ZyYWdtZW50OiBlbWlzc2l2ZW1hcF9mcmFnbWVudCxcblx0XHRlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50OiBlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50LFxuXHRcdGVuY29kaW5nc19mcmFnbWVudDogZW5jb2RpbmdzX2ZyYWdtZW50LFxuXHRcdGVuY29kaW5nc19wYXJzX2ZyYWdtZW50OiBlbmNvZGluZ3NfcGFyc19mcmFnbWVudCxcblx0XHRlbnZtYXBfZnJhZ21lbnQ6IGVudm1hcF9mcmFnbWVudCxcblx0XHRlbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQ6IGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudCxcblx0XHRlbnZtYXBfcGFyc19mcmFnbWVudDogZW52bWFwX3BhcnNfZnJhZ21lbnQsXG5cdFx0ZW52bWFwX3BhcnNfdmVydGV4OiBlbnZtYXBfcGFyc192ZXJ0ZXgsXG5cdFx0ZW52bWFwX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ6IGVudm1hcF9waHlzaWNhbF9wYXJzX2ZyYWdtZW50LFxuXHRcdGVudm1hcF92ZXJ0ZXg6IGVudm1hcF92ZXJ0ZXgsXG5cdFx0Zm9nX3ZlcnRleDogZm9nX3ZlcnRleCxcblx0XHRmb2dfcGFyc192ZXJ0ZXg6IGZvZ19wYXJzX3ZlcnRleCxcblx0XHRmb2dfZnJhZ21lbnQ6IGZvZ19mcmFnbWVudCxcblx0XHRmb2dfcGFyc19mcmFnbWVudDogZm9nX3BhcnNfZnJhZ21lbnQsXG5cdFx0Z3JhZGllbnRtYXBfcGFyc19mcmFnbWVudDogZ3JhZGllbnRtYXBfcGFyc19mcmFnbWVudCxcblx0XHRsaWdodG1hcF9mcmFnbWVudDogbGlnaHRtYXBfZnJhZ21lbnQsXG5cdFx0bGlnaHRtYXBfcGFyc19mcmFnbWVudDogbGlnaHRtYXBfcGFyc19mcmFnbWVudCxcblx0XHRsaWdodHNfbGFtYmVydF92ZXJ0ZXg6IGxpZ2h0c19sYW1iZXJ0X3ZlcnRleCxcblx0XHRsaWdodHNfcGFyc19iZWdpbjogbGlnaHRzX3BhcnNfYmVnaW4sXG5cdFx0bGlnaHRzX3Rvb25fZnJhZ21lbnQ6IGxpZ2h0c190b29uX2ZyYWdtZW50LFxuXHRcdGxpZ2h0c190b29uX3BhcnNfZnJhZ21lbnQ6IGxpZ2h0c190b29uX3BhcnNfZnJhZ21lbnQsXG5cdFx0bGlnaHRzX3Bob25nX2ZyYWdtZW50OiBsaWdodHNfcGhvbmdfZnJhZ21lbnQsXG5cdFx0bGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQ6IGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50LFxuXHRcdGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudDogbGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50LFxuXHRcdGxpZ2h0c19waHlzaWNhbF9wYXJzX2ZyYWdtZW50OiBsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudCxcblx0XHRsaWdodHNfZnJhZ21lbnRfYmVnaW46IGxpZ2h0c19mcmFnbWVudF9iZWdpbixcblx0XHRsaWdodHNfZnJhZ21lbnRfbWFwczogbGlnaHRzX2ZyYWdtZW50X21hcHMsXG5cdFx0bGlnaHRzX2ZyYWdtZW50X2VuZDogbGlnaHRzX2ZyYWdtZW50X2VuZCxcblx0XHRsb2dkZXB0aGJ1Zl9mcmFnbWVudDogbG9nZGVwdGhidWZfZnJhZ21lbnQsXG5cdFx0bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudDogbG9nZGVwdGhidWZfcGFyc19mcmFnbWVudCxcblx0XHRsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleDogbG9nZGVwdGhidWZfcGFyc192ZXJ0ZXgsXG5cdFx0bG9nZGVwdGhidWZfdmVydGV4OiBsb2dkZXB0aGJ1Zl92ZXJ0ZXgsXG5cdFx0bWFwX2ZyYWdtZW50OiBtYXBfZnJhZ21lbnQsXG5cdFx0bWFwX3BhcnNfZnJhZ21lbnQ6IG1hcF9wYXJzX2ZyYWdtZW50LFxuXHRcdG1hcF9wYXJ0aWNsZV9mcmFnbWVudDogbWFwX3BhcnRpY2xlX2ZyYWdtZW50LFxuXHRcdG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50OiBtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudCxcblx0XHRtZXRhbG5lc3NtYXBfZnJhZ21lbnQ6IG1ldGFsbmVzc21hcF9mcmFnbWVudCxcblx0XHRtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudDogbWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQsXG5cdFx0bW9ycGhub3JtYWxfdmVydGV4OiBtb3JwaG5vcm1hbF92ZXJ0ZXgsXG5cdFx0bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg6IG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4LFxuXHRcdG1vcnBodGFyZ2V0X3ZlcnRleDogbW9ycGh0YXJnZXRfdmVydGV4LFxuXHRcdG5vcm1hbF9mcmFnbWVudF9iZWdpbjogbm9ybWFsX2ZyYWdtZW50X2JlZ2luLFxuXHRcdG5vcm1hbF9mcmFnbWVudF9tYXBzOiBub3JtYWxfZnJhZ21lbnRfbWFwcyxcblx0XHRub3JtYWxfcGFyc19mcmFnbWVudDogbm9ybWFsX3BhcnNfZnJhZ21lbnQsXG5cdFx0bm9ybWFsX3BhcnNfdmVydGV4OiBub3JtYWxfcGFyc192ZXJ0ZXgsXG5cdFx0bm9ybWFsX3ZlcnRleDogbm9ybWFsX3ZlcnRleCxcblx0XHRub3JtYWxtYXBfcGFyc19mcmFnbWVudDogbm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQsXG5cdFx0Y2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9iZWdpbjogY2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9iZWdpbixcblx0XHRjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X21hcHM6IGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfbWFwcyxcblx0XHRjbGVhcmNvYXRfcGFyc19mcmFnbWVudDogY2xlYXJjb2F0X3BhcnNfZnJhZ21lbnQsXG5cdFx0b3V0cHV0X2ZyYWdtZW50OiBvdXRwdXRfZnJhZ21lbnQsXG5cdFx0cGFja2luZzogcGFja2luZyxcblx0XHRwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50OiBwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50LFxuXHRcdHByb2plY3RfdmVydGV4OiBwcm9qZWN0X3ZlcnRleCxcblx0XHRkaXRoZXJpbmdfZnJhZ21lbnQ6IGRpdGhlcmluZ19mcmFnbWVudCxcblx0XHRkaXRoZXJpbmdfcGFyc19mcmFnbWVudDogZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQsXG5cdFx0cm91Z2huZXNzbWFwX2ZyYWdtZW50OiByb3VnaG5lc3NtYXBfZnJhZ21lbnQsXG5cdFx0cm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQ6IHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50LFxuXHRcdHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50OiBzaGFkb3dtYXBfcGFyc19mcmFnbWVudCxcblx0XHRzaGFkb3dtYXBfcGFyc192ZXJ0ZXg6IHNoYWRvd21hcF9wYXJzX3ZlcnRleCxcblx0XHRzaGFkb3dtYXBfdmVydGV4OiBzaGFkb3dtYXBfdmVydGV4LFxuXHRcdHNoYWRvd21hc2tfcGFyc19mcmFnbWVudDogc2hhZG93bWFza19wYXJzX2ZyYWdtZW50LFxuXHRcdHNraW5iYXNlX3ZlcnRleDogc2tpbmJhc2VfdmVydGV4LFxuXHRcdHNraW5uaW5nX3BhcnNfdmVydGV4OiBza2lubmluZ19wYXJzX3ZlcnRleCxcblx0XHRza2lubmluZ192ZXJ0ZXg6IHNraW5uaW5nX3ZlcnRleCxcblx0XHRza2lubm9ybWFsX3ZlcnRleDogc2tpbm5vcm1hbF92ZXJ0ZXgsXG5cdFx0c3BlY3VsYXJtYXBfZnJhZ21lbnQ6IHNwZWN1bGFybWFwX2ZyYWdtZW50LFxuXHRcdHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ6IHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQsXG5cdFx0dG9uZW1hcHBpbmdfZnJhZ21lbnQ6IHRvbmVtYXBwaW5nX2ZyYWdtZW50LFxuXHRcdHRvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQ6IHRvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQsXG5cdFx0dHJhbnNtaXNzaW9uX2ZyYWdtZW50OiB0cmFuc21pc3Npb25fZnJhZ21lbnQsXG5cdFx0dHJhbnNtaXNzaW9uX3BhcnNfZnJhZ21lbnQ6IHRyYW5zbWlzc2lvbl9wYXJzX2ZyYWdtZW50LFxuXHRcdHV2X3BhcnNfZnJhZ21lbnQ6IHV2X3BhcnNfZnJhZ21lbnQsXG5cdFx0dXZfcGFyc192ZXJ0ZXg6IHV2X3BhcnNfdmVydGV4LFxuXHRcdHV2X3ZlcnRleDogdXZfdmVydGV4LFxuXHRcdHV2Ml9wYXJzX2ZyYWdtZW50OiB1djJfcGFyc19mcmFnbWVudCxcblx0XHR1djJfcGFyc192ZXJ0ZXg6IHV2Ml9wYXJzX3ZlcnRleCxcblx0XHR1djJfdmVydGV4OiB1djJfdmVydGV4LFxuXHRcdHdvcmxkcG9zX3ZlcnRleDogd29ybGRwb3NfdmVydGV4LFxuXHRcdGJhY2tncm91bmRfdmVydDogdmVydGV4JGcsXG5cdFx0YmFja2dyb3VuZF9mcmFnOiBmcmFnbWVudCRnLFxuXHRcdGN1YmVfdmVydDogdmVydGV4JGYsXG5cdFx0Y3ViZV9mcmFnOiBmcmFnbWVudCRmLFxuXHRcdGRlcHRoX3ZlcnQ6IHZlcnRleCRlLFxuXHRcdGRlcHRoX2ZyYWc6IGZyYWdtZW50JGUsXG5cdFx0ZGlzdGFuY2VSR0JBX3ZlcnQ6IHZlcnRleCRkLFxuXHRcdGRpc3RhbmNlUkdCQV9mcmFnOiBmcmFnbWVudCRkLFxuXHRcdGVxdWlyZWN0X3ZlcnQ6IHZlcnRleCRjLFxuXHRcdGVxdWlyZWN0X2ZyYWc6IGZyYWdtZW50JGMsXG5cdFx0bGluZWRhc2hlZF92ZXJ0OiB2ZXJ0ZXgkYixcblx0XHRsaW5lZGFzaGVkX2ZyYWc6IGZyYWdtZW50JGIsXG5cdFx0bWVzaGJhc2ljX3ZlcnQ6IHZlcnRleCRhLFxuXHRcdG1lc2hiYXNpY19mcmFnOiBmcmFnbWVudCRhLFxuXHRcdG1lc2hsYW1iZXJ0X3ZlcnQ6IHZlcnRleCQ5LFxuXHRcdG1lc2hsYW1iZXJ0X2ZyYWc6IGZyYWdtZW50JDksXG5cdFx0bWVzaG1hdGNhcF92ZXJ0OiB2ZXJ0ZXgkOCxcblx0XHRtZXNobWF0Y2FwX2ZyYWc6IGZyYWdtZW50JDgsXG5cdFx0bWVzaG5vcm1hbF92ZXJ0OiB2ZXJ0ZXgkNyxcblx0XHRtZXNobm9ybWFsX2ZyYWc6IGZyYWdtZW50JDcsXG5cdFx0bWVzaHBob25nX3ZlcnQ6IHZlcnRleCQ2LFxuXHRcdG1lc2hwaG9uZ19mcmFnOiBmcmFnbWVudCQ2LFxuXHRcdG1lc2hwaHlzaWNhbF92ZXJ0OiB2ZXJ0ZXgkNSxcblx0XHRtZXNocGh5c2ljYWxfZnJhZzogZnJhZ21lbnQkNSxcblx0XHRtZXNodG9vbl92ZXJ0OiB2ZXJ0ZXgkNCxcblx0XHRtZXNodG9vbl9mcmFnOiBmcmFnbWVudCQ0LFxuXHRcdHBvaW50c192ZXJ0OiB2ZXJ0ZXgkMyxcblx0XHRwb2ludHNfZnJhZzogZnJhZ21lbnQkMyxcblx0XHRzaGFkb3dfdmVydDogdmVydGV4JDIsXG5cdFx0c2hhZG93X2ZyYWc6IGZyYWdtZW50JDIsXG5cdFx0c3ByaXRlX3ZlcnQ6IHZlcnRleCQxLFxuXHRcdHNwcml0ZV9mcmFnOiBmcmFnbWVudCQxXG5cdH07XG5cblx0LyoqXG5cdCAqIFVuaWZvcm1zIGxpYnJhcnkgZm9yIHNoYXJlZCB3ZWJnbCBzaGFkZXJzXG5cdCAqL1xuXG5cdGNvbnN0IFVuaWZvcm1zTGliID0ge1xuXHRcdGNvbW1vbjoge1xuXHRcdFx0ZGlmZnVzZToge1xuXHRcdFx0XHR2YWx1ZTogbmV3IENvbG9yKDB4ZmZmZmZmKVxuXHRcdFx0fSxcblx0XHRcdG9wYWNpdHk6IHtcblx0XHRcdFx0dmFsdWU6IDEuMFxuXHRcdFx0fSxcblx0XHRcdG1hcDoge1xuXHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0fSxcblx0XHRcdHV2VHJhbnNmb3JtOiB7XG5cdFx0XHRcdHZhbHVlOiBuZXcgTWF0cml4MygpXG5cdFx0XHR9LFxuXHRcdFx0dXYyVHJhbnNmb3JtOiB7XG5cdFx0XHRcdHZhbHVlOiBuZXcgTWF0cml4MygpXG5cdFx0XHR9LFxuXHRcdFx0YWxwaGFNYXA6IHtcblx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdH0sXG5cdFx0XHRhbHBoYVRlc3Q6IHtcblx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNwZWN1bGFybWFwOiB7XG5cdFx0XHRzcGVjdWxhck1hcDoge1xuXHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZW52bWFwOiB7XG5cdFx0XHRlbnZNYXA6IHtcblx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdH0sXG5cdFx0XHRmbGlwRW52TWFwOiB7XG5cdFx0XHRcdHZhbHVlOiAtMVxuXHRcdFx0fSxcblx0XHRcdHJlZmxlY3Rpdml0eToge1xuXHRcdFx0XHR2YWx1ZTogMS4wXG5cdFx0XHR9LFxuXHRcdFx0Ly8gYmFzaWMsIGxhbWJlcnQsIHBob25nXG5cdFx0XHRpb3I6IHtcblx0XHRcdFx0dmFsdWU6IDEuNVxuXHRcdFx0fSxcblx0XHRcdC8vIHN0YW5kYXJkLCBwaHlzaWNhbFxuXHRcdFx0cmVmcmFjdGlvblJhdGlvOiB7XG5cdFx0XHRcdHZhbHVlOiAwLjk4XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhb21hcDoge1xuXHRcdFx0YW9NYXA6IHtcblx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdH0sXG5cdFx0XHRhb01hcEludGVuc2l0eToge1xuXHRcdFx0XHR2YWx1ZTogMVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bGlnaHRtYXA6IHtcblx0XHRcdGxpZ2h0TWFwOiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHR9LFxuXHRcdFx0bGlnaHRNYXBJbnRlbnNpdHk6IHtcblx0XHRcdFx0dmFsdWU6IDFcblx0XHRcdH1cblx0XHR9LFxuXHRcdGVtaXNzaXZlbWFwOiB7XG5cdFx0XHRlbWlzc2l2ZU1hcDoge1xuXHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YnVtcG1hcDoge1xuXHRcdFx0YnVtcE1hcDoge1xuXHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0fSxcblx0XHRcdGJ1bXBTY2FsZToge1xuXHRcdFx0XHR2YWx1ZTogMVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bm9ybWFsbWFwOiB7XG5cdFx0XHRub3JtYWxNYXA6IHtcblx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdH0sXG5cdFx0XHRub3JtYWxTY2FsZToge1xuXHRcdFx0XHR2YWx1ZTogbmV3IFZlY3RvcjIoMSwgMSlcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRpc3BsYWNlbWVudG1hcDoge1xuXHRcdFx0ZGlzcGxhY2VtZW50TWFwOiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHR9LFxuXHRcdFx0ZGlzcGxhY2VtZW50U2NhbGU6IHtcblx0XHRcdFx0dmFsdWU6IDFcblx0XHRcdH0sXG5cdFx0XHRkaXNwbGFjZW1lbnRCaWFzOiB7XG5cdFx0XHRcdHZhbHVlOiAwXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyb3VnaG5lc3NtYXA6IHtcblx0XHRcdHJvdWdobmVzc01hcDoge1xuXHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bWV0YWxuZXNzbWFwOiB7XG5cdFx0XHRtZXRhbG5lc3NNYXA6IHtcblx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdH1cblx0XHR9LFxuXHRcdGdyYWRpZW50bWFwOiB7XG5cdFx0XHRncmFkaWVudE1hcDoge1xuXHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Zm9nOiB7XG5cdFx0XHRmb2dEZW5zaXR5OiB7XG5cdFx0XHRcdHZhbHVlOiAwLjAwMDI1XG5cdFx0XHR9LFxuXHRcdFx0Zm9nTmVhcjoge1xuXHRcdFx0XHR2YWx1ZTogMVxuXHRcdFx0fSxcblx0XHRcdGZvZ0Zhcjoge1xuXHRcdFx0XHR2YWx1ZTogMjAwMFxuXHRcdFx0fSxcblx0XHRcdGZvZ0NvbG9yOiB7XG5cdFx0XHRcdHZhbHVlOiBuZXcgQ29sb3IoMHhmZmZmZmYpXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRsaWdodHM6IHtcblx0XHRcdGFtYmllbnRMaWdodENvbG9yOiB7XG5cdFx0XHRcdHZhbHVlOiBbXVxuXHRcdFx0fSxcblx0XHRcdGxpZ2h0UHJvYmU6IHtcblx0XHRcdFx0dmFsdWU6IFtdXG5cdFx0XHR9LFxuXHRcdFx0ZGlyZWN0aW9uYWxMaWdodHM6IHtcblx0XHRcdFx0dmFsdWU6IFtdLFxuXHRcdFx0XHRwcm9wZXJ0aWVzOiB7XG5cdFx0XHRcdFx0ZGlyZWN0aW9uOiB7fSxcblx0XHRcdFx0XHRjb2xvcjoge31cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzOiB7XG5cdFx0XHRcdHZhbHVlOiBbXSxcblx0XHRcdFx0cHJvcGVydGllczoge1xuXHRcdFx0XHRcdHNoYWRvd0JpYXM6IHt9LFxuXHRcdFx0XHRcdHNoYWRvd05vcm1hbEJpYXM6IHt9LFxuXHRcdFx0XHRcdHNoYWRvd1JhZGl1czoge30sXG5cdFx0XHRcdFx0c2hhZG93TWFwU2l6ZToge31cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRpcmVjdGlvbmFsU2hhZG93TWFwOiB7XG5cdFx0XHRcdHZhbHVlOiBbXVxuXHRcdFx0fSxcblx0XHRcdGRpcmVjdGlvbmFsU2hhZG93TWF0cml4OiB7XG5cdFx0XHRcdHZhbHVlOiBbXVxuXHRcdFx0fSxcblx0XHRcdHNwb3RMaWdodHM6IHtcblx0XHRcdFx0dmFsdWU6IFtdLFxuXHRcdFx0XHRwcm9wZXJ0aWVzOiB7XG5cdFx0XHRcdFx0Y29sb3I6IHt9LFxuXHRcdFx0XHRcdHBvc2l0aW9uOiB7fSxcblx0XHRcdFx0XHRkaXJlY3Rpb246IHt9LFxuXHRcdFx0XHRcdGRpc3RhbmNlOiB7fSxcblx0XHRcdFx0XHRjb25lQ29zOiB7fSxcblx0XHRcdFx0XHRwZW51bWJyYUNvczoge30sXG5cdFx0XHRcdFx0ZGVjYXk6IHt9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRzcG90TGlnaHRTaGFkb3dzOiB7XG5cdFx0XHRcdHZhbHVlOiBbXSxcblx0XHRcdFx0cHJvcGVydGllczoge1xuXHRcdFx0XHRcdHNoYWRvd0JpYXM6IHt9LFxuXHRcdFx0XHRcdHNoYWRvd05vcm1hbEJpYXM6IHt9LFxuXHRcdFx0XHRcdHNoYWRvd1JhZGl1czoge30sXG5cdFx0XHRcdFx0c2hhZG93TWFwU2l6ZToge31cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHNwb3RTaGFkb3dNYXA6IHtcblx0XHRcdFx0dmFsdWU6IFtdXG5cdFx0XHR9LFxuXHRcdFx0c3BvdFNoYWRvd01hdHJpeDoge1xuXHRcdFx0XHR2YWx1ZTogW11cblx0XHRcdH0sXG5cdFx0XHRwb2ludExpZ2h0czoge1xuXHRcdFx0XHR2YWx1ZTogW10sXG5cdFx0XHRcdHByb3BlcnRpZXM6IHtcblx0XHRcdFx0XHRjb2xvcjoge30sXG5cdFx0XHRcdFx0cG9zaXRpb246IHt9LFxuXHRcdFx0XHRcdGRlY2F5OiB7fSxcblx0XHRcdFx0XHRkaXN0YW5jZToge31cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHBvaW50TGlnaHRTaGFkb3dzOiB7XG5cdFx0XHRcdHZhbHVlOiBbXSxcblx0XHRcdFx0cHJvcGVydGllczoge1xuXHRcdFx0XHRcdHNoYWRvd0JpYXM6IHt9LFxuXHRcdFx0XHRcdHNoYWRvd05vcm1hbEJpYXM6IHt9LFxuXHRcdFx0XHRcdHNoYWRvd1JhZGl1czoge30sXG5cdFx0XHRcdFx0c2hhZG93TWFwU2l6ZToge30sXG5cdFx0XHRcdFx0c2hhZG93Q2FtZXJhTmVhcjoge30sXG5cdFx0XHRcdFx0c2hhZG93Q2FtZXJhRmFyOiB7fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cG9pbnRTaGFkb3dNYXA6IHtcblx0XHRcdFx0dmFsdWU6IFtdXG5cdFx0XHR9LFxuXHRcdFx0cG9pbnRTaGFkb3dNYXRyaXg6IHtcblx0XHRcdFx0dmFsdWU6IFtdXG5cdFx0XHR9LFxuXHRcdFx0aGVtaXNwaGVyZUxpZ2h0czoge1xuXHRcdFx0XHR2YWx1ZTogW10sXG5cdFx0XHRcdHByb3BlcnRpZXM6IHtcblx0XHRcdFx0XHRkaXJlY3Rpb246IHt9LFxuXHRcdFx0XHRcdHNreUNvbG9yOiB7fSxcblx0XHRcdFx0XHRncm91bmRDb2xvcjoge31cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdC8vIFRPRE8gKGFiZWxuYXRpb24pOiBSZWN0QXJlYUxpZ2h0IEJSREYgZGF0YSBuZWVkcyB0byBiZSBtb3ZlZCBmcm9tIGV4YW1wbGUgdG8gbWFpbiBzcmNcblx0XHRcdHJlY3RBcmVhTGlnaHRzOiB7XG5cdFx0XHRcdHZhbHVlOiBbXSxcblx0XHRcdFx0cHJvcGVydGllczoge1xuXHRcdFx0XHRcdGNvbG9yOiB7fSxcblx0XHRcdFx0XHRwb3NpdGlvbjoge30sXG5cdFx0XHRcdFx0d2lkdGg6IHt9LFxuXHRcdFx0XHRcdGhlaWdodDoge31cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGx0Y18xOiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHR9LFxuXHRcdFx0bHRjXzI6IHtcblx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdH1cblx0XHR9LFxuXHRcdHBvaW50czoge1xuXHRcdFx0ZGlmZnVzZToge1xuXHRcdFx0XHR2YWx1ZTogbmV3IENvbG9yKDB4ZmZmZmZmKVxuXHRcdFx0fSxcblx0XHRcdG9wYWNpdHk6IHtcblx0XHRcdFx0dmFsdWU6IDEuMFxuXHRcdFx0fSxcblx0XHRcdHNpemU6IHtcblx0XHRcdFx0dmFsdWU6IDEuMFxuXHRcdFx0fSxcblx0XHRcdHNjYWxlOiB7XG5cdFx0XHRcdHZhbHVlOiAxLjBcblx0XHRcdH0sXG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdH0sXG5cdFx0XHRhbHBoYU1hcDoge1xuXHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0fSxcblx0XHRcdGFscGhhVGVzdDoge1xuXHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0fSxcblx0XHRcdHV2VHJhbnNmb3JtOiB7XG5cdFx0XHRcdHZhbHVlOiBuZXcgTWF0cml4MygpXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzcHJpdGU6IHtcblx0XHRcdGRpZmZ1c2U6IHtcblx0XHRcdFx0dmFsdWU6IG5ldyBDb2xvcigweGZmZmZmZilcblx0XHRcdH0sXG5cdFx0XHRvcGFjaXR5OiB7XG5cdFx0XHRcdHZhbHVlOiAxLjBcblx0XHRcdH0sXG5cdFx0XHRjZW50ZXI6IHtcblx0XHRcdFx0dmFsdWU6IG5ldyBWZWN0b3IyKDAuNSwgMC41KVxuXHRcdFx0fSxcblx0XHRcdHJvdGF0aW9uOiB7XG5cdFx0XHRcdHZhbHVlOiAwLjBcblx0XHRcdH0sXG5cdFx0XHRtYXA6IHtcblx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdH0sXG5cdFx0XHRhbHBoYU1hcDoge1xuXHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0fSxcblx0XHRcdGFscGhhVGVzdDoge1xuXHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0fSxcblx0XHRcdHV2VHJhbnNmb3JtOiB7XG5cdFx0XHRcdHZhbHVlOiBuZXcgTWF0cml4MygpXG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdGNvbnN0IFNoYWRlckxpYiA9IHtcblx0XHRiYXNpYzoge1xuXHRcdFx0dW5pZm9ybXM6IG1lcmdlVW5pZm9ybXMoW1VuaWZvcm1zTGliLmNvbW1vbiwgVW5pZm9ybXNMaWIuc3BlY3VsYXJtYXAsIFVuaWZvcm1zTGliLmVudm1hcCwgVW5pZm9ybXNMaWIuYW9tYXAsIFVuaWZvcm1zTGliLmxpZ2h0bWFwLCBVbmlmb3Jtc0xpYi5mb2ddKSxcblx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaGJhc2ljX3ZlcnQsXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaGJhc2ljX2ZyYWdcblx0XHR9LFxuXHRcdGxhbWJlcnQ6IHtcblx0XHRcdHVuaWZvcm1zOiBtZXJnZVVuaWZvcm1zKFtVbmlmb3Jtc0xpYi5jb21tb24sIFVuaWZvcm1zTGliLnNwZWN1bGFybWFwLCBVbmlmb3Jtc0xpYi5lbnZtYXAsIFVuaWZvcm1zTGliLmFvbWFwLCBVbmlmb3Jtc0xpYi5saWdodG1hcCwgVW5pZm9ybXNMaWIuZW1pc3NpdmVtYXAsIFVuaWZvcm1zTGliLmZvZywgVW5pZm9ybXNMaWIubGlnaHRzLCB7XG5cdFx0XHRcdGVtaXNzaXZlOiB7XG5cdFx0XHRcdFx0dmFsdWU6IG5ldyBDb2xvcigweDAwMDAwMClcblx0XHRcdFx0fVxuXHRcdFx0fV0pLFxuXHRcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNobGFtYmVydF92ZXJ0LFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hsYW1iZXJ0X2ZyYWdcblx0XHR9LFxuXHRcdHBob25nOiB7XG5cdFx0XHR1bmlmb3JtczogbWVyZ2VVbmlmb3JtcyhbVW5pZm9ybXNMaWIuY29tbW9uLCBVbmlmb3Jtc0xpYi5zcGVjdWxhcm1hcCwgVW5pZm9ybXNMaWIuZW52bWFwLCBVbmlmb3Jtc0xpYi5hb21hcCwgVW5pZm9ybXNMaWIubGlnaHRtYXAsIFVuaWZvcm1zTGliLmVtaXNzaXZlbWFwLCBVbmlmb3Jtc0xpYi5idW1wbWFwLCBVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsIFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCwgVW5pZm9ybXNMaWIuZm9nLCBVbmlmb3Jtc0xpYi5saWdodHMsIHtcblx0XHRcdFx0ZW1pc3NpdmU6IHtcblx0XHRcdFx0XHR2YWx1ZTogbmV3IENvbG9yKDB4MDAwMDAwKVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzcGVjdWxhcjoge1xuXHRcdFx0XHRcdHZhbHVlOiBuZXcgQ29sb3IoMHgxMTExMTEpXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNoaW5pbmVzczoge1xuXHRcdFx0XHRcdHZhbHVlOiAzMFxuXHRcdFx0XHR9XG5cdFx0XHR9XSksXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaG9uZ192ZXJ0LFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaG9uZ19mcmFnXG5cdFx0fSxcblx0XHRzdGFuZGFyZDoge1xuXHRcdFx0dW5pZm9ybXM6IG1lcmdlVW5pZm9ybXMoW1VuaWZvcm1zTGliLmNvbW1vbiwgVW5pZm9ybXNMaWIuZW52bWFwLCBVbmlmb3Jtc0xpYi5hb21hcCwgVW5pZm9ybXNMaWIubGlnaHRtYXAsIFVuaWZvcm1zTGliLmVtaXNzaXZlbWFwLCBVbmlmb3Jtc0xpYi5idW1wbWFwLCBVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsIFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCwgVW5pZm9ybXNMaWIucm91Z2huZXNzbWFwLCBVbmlmb3Jtc0xpYi5tZXRhbG5lc3NtYXAsIFVuaWZvcm1zTGliLmZvZywgVW5pZm9ybXNMaWIubGlnaHRzLCB7XG5cdFx0XHRcdGVtaXNzaXZlOiB7XG5cdFx0XHRcdFx0dmFsdWU6IG5ldyBDb2xvcigweDAwMDAwMClcblx0XHRcdFx0fSxcblx0XHRcdFx0cm91Z2huZXNzOiB7XG5cdFx0XHRcdFx0dmFsdWU6IDEuMFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRtZXRhbG5lc3M6IHtcblx0XHRcdFx0XHR2YWx1ZTogMC4wXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVudk1hcEludGVuc2l0eToge1xuXHRcdFx0XHRcdHZhbHVlOiAxXG5cdFx0XHRcdH0gLy8gdGVtcG9yYXJ5XG5cblx0XHRcdH1dKSxcblx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBoeXNpY2FsX3ZlcnQsXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBoeXNpY2FsX2ZyYWdcblx0XHR9LFxuXHRcdHRvb246IHtcblx0XHRcdHVuaWZvcm1zOiBtZXJnZVVuaWZvcm1zKFtVbmlmb3Jtc0xpYi5jb21tb24sIFVuaWZvcm1zTGliLmFvbWFwLCBVbmlmb3Jtc0xpYi5saWdodG1hcCwgVW5pZm9ybXNMaWIuZW1pc3NpdmVtYXAsIFVuaWZvcm1zTGliLmJ1bXBtYXAsIFVuaWZvcm1zTGliLm5vcm1hbG1hcCwgVW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwLCBVbmlmb3Jtc0xpYi5ncmFkaWVudG1hcCwgVW5pZm9ybXNMaWIuZm9nLCBVbmlmb3Jtc0xpYi5saWdodHMsIHtcblx0XHRcdFx0ZW1pc3NpdmU6IHtcblx0XHRcdFx0XHR2YWx1ZTogbmV3IENvbG9yKDB4MDAwMDAwKVxuXHRcdFx0XHR9XG5cdFx0XHR9XSksXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2h0b29uX3ZlcnQsXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHRvb25fZnJhZ1xuXHRcdH0sXG5cdFx0bWF0Y2FwOiB7XG5cdFx0XHR1bmlmb3JtczogbWVyZ2VVbmlmb3JtcyhbVW5pZm9ybXNMaWIuY29tbW9uLCBVbmlmb3Jtc0xpYi5idW1wbWFwLCBVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsIFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCwgVW5pZm9ybXNMaWIuZm9nLCB7XG5cdFx0XHRcdG1hdGNhcDoge1xuXHRcdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHRcdH1cblx0XHRcdH1dKSxcblx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaG1hdGNhcF92ZXJ0LFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2htYXRjYXBfZnJhZ1xuXHRcdH0sXG5cdFx0cG9pbnRzOiB7XG5cdFx0XHR1bmlmb3JtczogbWVyZ2VVbmlmb3JtcyhbVW5pZm9ybXNMaWIucG9pbnRzLCBVbmlmb3Jtc0xpYi5mb2ddKSxcblx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsucG9pbnRzX3ZlcnQsXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsucG9pbnRzX2ZyYWdcblx0XHR9LFxuXHRcdGRhc2hlZDoge1xuXHRcdFx0dW5pZm9ybXM6IG1lcmdlVW5pZm9ybXMoW1VuaWZvcm1zTGliLmNvbW1vbiwgVW5pZm9ybXNMaWIuZm9nLCB7XG5cdFx0XHRcdHNjYWxlOiB7XG5cdFx0XHRcdFx0dmFsdWU6IDFcblx0XHRcdFx0fSxcblx0XHRcdFx0ZGFzaFNpemU6IHtcblx0XHRcdFx0XHR2YWx1ZTogMVxuXHRcdFx0XHR9LFxuXHRcdFx0XHR0b3RhbFNpemU6IHtcblx0XHRcdFx0XHR2YWx1ZTogMlxuXHRcdFx0XHR9XG5cdFx0XHR9XSksXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmxpbmVkYXNoZWRfdmVydCxcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5saW5lZGFzaGVkX2ZyYWdcblx0XHR9LFxuXHRcdGRlcHRoOiB7XG5cdFx0XHR1bmlmb3JtczogbWVyZ2VVbmlmb3JtcyhbVW5pZm9ybXNMaWIuY29tbW9uLCBVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXBdKSxcblx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuZGVwdGhfdmVydCxcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5kZXB0aF9mcmFnXG5cdFx0fSxcblx0XHRub3JtYWw6IHtcblx0XHRcdHVuaWZvcm1zOiBtZXJnZVVuaWZvcm1zKFtVbmlmb3Jtc0xpYi5jb21tb24sIFVuaWZvcm1zTGliLmJ1bXBtYXAsIFVuaWZvcm1zTGliLm5vcm1hbG1hcCwgVW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwLCB7XG5cdFx0XHRcdG9wYWNpdHk6IHtcblx0XHRcdFx0XHR2YWx1ZTogMS4wXG5cdFx0XHRcdH1cblx0XHRcdH1dKSxcblx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaG5vcm1hbF92ZXJ0LFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hub3JtYWxfZnJhZ1xuXHRcdH0sXG5cdFx0c3ByaXRlOiB7XG5cdFx0XHR1bmlmb3JtczogbWVyZ2VVbmlmb3JtcyhbVW5pZm9ybXNMaWIuc3ByaXRlLCBVbmlmb3Jtc0xpYi5mb2ddKSxcblx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuc3ByaXRlX3ZlcnQsXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuc3ByaXRlX2ZyYWdcblx0XHR9LFxuXHRcdGJhY2tncm91bmQ6IHtcblx0XHRcdHVuaWZvcm1zOiB7XG5cdFx0XHRcdHV2VHJhbnNmb3JtOiB7XG5cdFx0XHRcdFx0dmFsdWU6IG5ldyBNYXRyaXgzKClcblx0XHRcdFx0fSxcblx0XHRcdFx0dDJEOiB7XG5cdFx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuYmFja2dyb3VuZF92ZXJ0LFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmJhY2tncm91bmRfZnJhZ1xuXHRcdH0sXG5cblx0XHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0Ly9cdEN1YmUgbWFwIHNoYWRlclxuXHRcdCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdFx0Y3ViZToge1xuXHRcdFx0dW5pZm9ybXM6IG1lcmdlVW5pZm9ybXMoW1VuaWZvcm1zTGliLmVudm1hcCwge1xuXHRcdFx0XHRvcGFjaXR5OiB7XG5cdFx0XHRcdFx0dmFsdWU6IDEuMFxuXHRcdFx0XHR9XG5cdFx0XHR9XSksXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmN1YmVfdmVydCxcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5jdWJlX2ZyYWdcblx0XHR9LFxuXHRcdGVxdWlyZWN0OiB7XG5cdFx0XHR1bmlmb3Jtczoge1xuXHRcdFx0XHR0RXF1aXJlY3Q6IHtcblx0XHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5lcXVpcmVjdF92ZXJ0LFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmVxdWlyZWN0X2ZyYWdcblx0XHR9LFxuXHRcdGRpc3RhbmNlUkdCQToge1xuXHRcdFx0dW5pZm9ybXM6IG1lcmdlVW5pZm9ybXMoW1VuaWZvcm1zTGliLmNvbW1vbiwgVW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwLCB7XG5cdFx0XHRcdHJlZmVyZW5jZVBvc2l0aW9uOiB7XG5cdFx0XHRcdFx0dmFsdWU6IG5ldyBWZWN0b3IzKClcblx0XHRcdFx0fSxcblx0XHRcdFx0bmVhckRpc3RhbmNlOiB7XG5cdFx0XHRcdFx0dmFsdWU6IDFcblx0XHRcdFx0fSxcblx0XHRcdFx0ZmFyRGlzdGFuY2U6IHtcblx0XHRcdFx0XHR2YWx1ZTogMTAwMFxuXHRcdFx0XHR9XG5cdFx0XHR9XSksXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmRpc3RhbmNlUkdCQV92ZXJ0LFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmRpc3RhbmNlUkdCQV9mcmFnXG5cdFx0fSxcblx0XHRzaGFkb3c6IHtcblx0XHRcdHVuaWZvcm1zOiBtZXJnZVVuaWZvcm1zKFtVbmlmb3Jtc0xpYi5saWdodHMsIFVuaWZvcm1zTGliLmZvZywge1xuXHRcdFx0XHRjb2xvcjoge1xuXHRcdFx0XHRcdHZhbHVlOiBuZXcgQ29sb3IoMHgwMDAwMClcblx0XHRcdFx0fSxcblx0XHRcdFx0b3BhY2l0eToge1xuXHRcdFx0XHRcdHZhbHVlOiAxLjBcblx0XHRcdFx0fVxuXHRcdFx0fV0pLFxuXHRcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5zaGFkb3dfdmVydCxcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5zaGFkb3dfZnJhZ1xuXHRcdH1cblx0fTtcblx0U2hhZGVyTGliLnBoeXNpY2FsID0ge1xuXHRcdHVuaWZvcm1zOiBtZXJnZVVuaWZvcm1zKFtTaGFkZXJMaWIuc3RhbmRhcmQudW5pZm9ybXMsIHtcblx0XHRcdGNsZWFyY29hdDoge1xuXHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0fSxcblx0XHRcdGNsZWFyY29hdE1hcDoge1xuXHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0fSxcblx0XHRcdGNsZWFyY29hdFJvdWdobmVzczoge1xuXHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0fSxcblx0XHRcdGNsZWFyY29hdFJvdWdobmVzc01hcDoge1xuXHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0fSxcblx0XHRcdGNsZWFyY29hdE5vcm1hbFNjYWxlOiB7XG5cdFx0XHRcdHZhbHVlOiBuZXcgVmVjdG9yMigxLCAxKVxuXHRcdFx0fSxcblx0XHRcdGNsZWFyY29hdE5vcm1hbE1hcDoge1xuXHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0fSxcblx0XHRcdHNoZWVuOiB7XG5cdFx0XHRcdHZhbHVlOiAwXG5cdFx0XHR9LFxuXHRcdFx0c2hlZW5Db2xvcjoge1xuXHRcdFx0XHR2YWx1ZTogbmV3IENvbG9yKDB4MDAwMDAwKVxuXHRcdFx0fSxcblx0XHRcdHNoZWVuQ29sb3JNYXA6IHtcblx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdH0sXG5cdFx0XHRzaGVlblJvdWdobmVzczoge1xuXHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0fSxcblx0XHRcdHNoZWVuUm91Z2huZXNzTWFwOiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHR9LFxuXHRcdFx0dHJhbnNtaXNzaW9uOiB7XG5cdFx0XHRcdHZhbHVlOiAwXG5cdFx0XHR9LFxuXHRcdFx0dHJhbnNtaXNzaW9uTWFwOiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHR9LFxuXHRcdFx0dHJhbnNtaXNzaW9uU2FtcGxlclNpemU6IHtcblx0XHRcdFx0dmFsdWU6IG5ldyBWZWN0b3IyKClcblx0XHRcdH0sXG5cdFx0XHR0cmFuc21pc3Npb25TYW1wbGVyTWFwOiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHR9LFxuXHRcdFx0dGhpY2tuZXNzOiB7XG5cdFx0XHRcdHZhbHVlOiAwXG5cdFx0XHR9LFxuXHRcdFx0dGhpY2tuZXNzTWFwOiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHR9LFxuXHRcdFx0YXR0ZW51YXRpb25EaXN0YW5jZToge1xuXHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0fSxcblx0XHRcdGF0dGVudWF0aW9uQ29sb3I6IHtcblx0XHRcdFx0dmFsdWU6IG5ldyBDb2xvcigweDAwMDAwMClcblx0XHRcdH0sXG5cdFx0XHRzcGVjdWxhckludGVuc2l0eToge1xuXHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0fSxcblx0XHRcdHNwZWN1bGFySW50ZW5zaXR5TWFwOiB7XG5cdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHR9LFxuXHRcdFx0c3BlY3VsYXJDb2xvcjoge1xuXHRcdFx0XHR2YWx1ZTogbmV3IENvbG9yKDEsIDEsIDEpXG5cdFx0XHR9LFxuXHRcdFx0c3BlY3VsYXJDb2xvck1hcDoge1xuXHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0fVxuXHRcdH1dKSxcblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaHlzaWNhbF92ZXJ0LFxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGh5c2ljYWxfZnJhZ1xuXHR9O1xuXG5cdGZ1bmN0aW9uIFdlYkdMQmFja2dyb3VuZChyZW5kZXJlciwgY3ViZW1hcHMsIHN0YXRlLCBvYmplY3RzLCBwcmVtdWx0aXBsaWVkQWxwaGEpIHtcblx0XHRjb25zdCBjbGVhckNvbG9yID0gbmV3IENvbG9yKDB4MDAwMDAwKTtcblx0XHRsZXQgY2xlYXJBbHBoYSA9IDA7XG5cdFx0bGV0IHBsYW5lTWVzaDtcblx0XHRsZXQgYm94TWVzaDtcblx0XHRsZXQgY3VycmVudEJhY2tncm91bmQgPSBudWxsO1xuXHRcdGxldCBjdXJyZW50QmFja2dyb3VuZFZlcnNpb24gPSAwO1xuXHRcdGxldCBjdXJyZW50VG9uZW1hcHBpbmcgPSBudWxsO1xuXG5cdFx0ZnVuY3Rpb24gcmVuZGVyKHJlbmRlckxpc3QsIHNjZW5lKSB7XG5cdFx0XHRsZXQgZm9yY2VDbGVhciA9IGZhbHNlO1xuXHRcdFx0bGV0IGJhY2tncm91bmQgPSBzY2VuZS5pc1NjZW5lID09PSB0cnVlID8gc2NlbmUuYmFja2dyb3VuZCA6IG51bGw7XG5cblx0XHRcdGlmIChiYWNrZ3JvdW5kICYmIGJhY2tncm91bmQuaXNUZXh0dXJlKSB7XG5cdFx0XHRcdGJhY2tncm91bmQgPSBjdWJlbWFwcy5nZXQoYmFja2dyb3VuZCk7XG5cdFx0XHR9IC8vIElnbm9yZSBiYWNrZ3JvdW5kIGluIEFSXG5cdFx0XHQvLyBUT0RPOiBSZWNvbnNpZGVyIHRoaXMuXG5cblxuXHRcdFx0Y29uc3QgeHIgPSByZW5kZXJlci54cjtcblx0XHRcdGNvbnN0IHNlc3Npb24gPSB4ci5nZXRTZXNzaW9uICYmIHhyLmdldFNlc3Npb24oKTtcblxuXHRcdFx0aWYgKHNlc3Npb24gJiYgc2Vzc2lvbi5lbnZpcm9ubWVudEJsZW5kTW9kZSA9PT0gJ2FkZGl0aXZlJykge1xuXHRcdFx0XHRiYWNrZ3JvdW5kID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGJhY2tncm91bmQgPT09IG51bGwpIHtcblx0XHRcdFx0c2V0Q2xlYXIoY2xlYXJDb2xvciwgY2xlYXJBbHBoYSk7XG5cdFx0XHR9IGVsc2UgaWYgKGJhY2tncm91bmQgJiYgYmFja2dyb3VuZC5pc0NvbG9yKSB7XG5cdFx0XHRcdHNldENsZWFyKGJhY2tncm91bmQsIDEpO1xuXHRcdFx0XHRmb3JjZUNsZWFyID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHJlbmRlcmVyLmF1dG9DbGVhciB8fCBmb3JjZUNsZWFyKSB7XG5cdFx0XHRcdHJlbmRlcmVyLmNsZWFyKHJlbmRlcmVyLmF1dG9DbGVhckNvbG9yLCByZW5kZXJlci5hdXRvQ2xlYXJEZXB0aCwgcmVuZGVyZXIuYXV0b0NsZWFyU3RlbmNpbCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChiYWNrZ3JvdW5kICYmIChiYWNrZ3JvdW5kLmlzQ3ViZVRleHR1cmUgfHwgYmFja2dyb3VuZC5tYXBwaW5nID09PSBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZykpIHtcblx0XHRcdFx0aWYgKGJveE1lc2ggPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGJveE1lc2ggPSBuZXcgTWVzaChuZXcgQm94R2VvbWV0cnkoMSwgMSwgMSksIG5ldyBTaGFkZXJNYXRlcmlhbCh7XG5cdFx0XHRcdFx0XHRuYW1lOiAnQmFja2dyb3VuZEN1YmVNYXRlcmlhbCcsXG5cdFx0XHRcdFx0XHR1bmlmb3JtczogY2xvbmVVbmlmb3JtcyhTaGFkZXJMaWIuY3ViZS51bmlmb3JtcyksXG5cdFx0XHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckxpYi5jdWJlLnZlcnRleFNoYWRlcixcblx0XHRcdFx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJMaWIuY3ViZS5mcmFnbWVudFNoYWRlcixcblx0XHRcdFx0XHRcdHNpZGU6IEJhY2tTaWRlLFxuXHRcdFx0XHRcdFx0ZGVwdGhUZXN0OiBmYWxzZSxcblx0XHRcdFx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlLFxuXHRcdFx0XHRcdFx0Zm9nOiBmYWxzZVxuXHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0XHRib3hNZXNoLmdlb21ldHJ5LmRlbGV0ZUF0dHJpYnV0ZSgnbm9ybWFsJyk7XG5cdFx0XHRcdFx0Ym94TWVzaC5nZW9tZXRyeS5kZWxldGVBdHRyaWJ1dGUoJ3V2Jyk7XG5cblx0XHRcdFx0XHRib3hNZXNoLm9uQmVmb3JlUmVuZGVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHlQb3NpdGlvbihjYW1lcmEubWF0cml4V29ybGQpO1xuXHRcdFx0XHRcdH07IC8vIGVuYWJsZSBjb2RlIGluamVjdGlvbiBmb3Igbm9uLWJ1aWx0LWluIG1hdGVyaWFsXG5cblxuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShib3hNZXNoLm1hdGVyaWFsLCAnZW52TWFwJywge1xuXHRcdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLnVuaWZvcm1zLmVudk1hcC52YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRvYmplY3RzLnVwZGF0ZShib3hNZXNoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJveE1lc2gubWF0ZXJpYWwudW5pZm9ybXMuZW52TWFwLnZhbHVlID0gYmFja2dyb3VuZDtcblx0XHRcdFx0Ym94TWVzaC5tYXRlcmlhbC51bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlID0gYmFja2dyb3VuZC5pc0N1YmVUZXh0dXJlICYmIGJhY2tncm91bmQuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID09PSBmYWxzZSA/IC0xIDogMTtcblxuXHRcdFx0XHRpZiAoY3VycmVudEJhY2tncm91bmQgIT09IGJhY2tncm91bmQgfHwgY3VycmVudEJhY2tncm91bmRWZXJzaW9uICE9PSBiYWNrZ3JvdW5kLnZlcnNpb24gfHwgY3VycmVudFRvbmVtYXBwaW5nICE9PSByZW5kZXJlci50b25lTWFwcGluZykge1xuXHRcdFx0XHRcdGJveE1lc2gubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdGN1cnJlbnRCYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcblx0XHRcdFx0XHRjdXJyZW50QmFja2dyb3VuZFZlcnNpb24gPSBiYWNrZ3JvdW5kLnZlcnNpb247XG5cdFx0XHRcdFx0Y3VycmVudFRvbmVtYXBwaW5nID0gcmVuZGVyZXIudG9uZU1hcHBpbmc7XG5cdFx0XHRcdH0gLy8gcHVzaCB0byB0aGUgcHJlLXNvcnRlZCBvcGFxdWUgcmVuZGVyIGxpc3RcblxuXG5cdFx0XHRcdHJlbmRlckxpc3QudW5zaGlmdChib3hNZXNoLCBib3hNZXNoLmdlb21ldHJ5LCBib3hNZXNoLm1hdGVyaWFsLCAwLCAwLCBudWxsKTtcblx0XHRcdH0gZWxzZSBpZiAoYmFja2dyb3VuZCAmJiBiYWNrZ3JvdW5kLmlzVGV4dHVyZSkge1xuXHRcdFx0XHRpZiAocGxhbmVNZXNoID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRwbGFuZU1lc2ggPSBuZXcgTWVzaChuZXcgUGxhbmVHZW9tZXRyeSgyLCAyKSwgbmV3IFNoYWRlck1hdGVyaWFsKHtcblx0XHRcdFx0XHRcdG5hbWU6ICdCYWNrZ3JvdW5kTWF0ZXJpYWwnLFxuXHRcdFx0XHRcdFx0dW5pZm9ybXM6IGNsb25lVW5pZm9ybXMoU2hhZGVyTGliLmJhY2tncm91bmQudW5pZm9ybXMpLFxuXHRcdFx0XHRcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJMaWIuYmFja2dyb3VuZC52ZXJ0ZXhTaGFkZXIsXG5cdFx0XHRcdFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyTGliLmJhY2tncm91bmQuZnJhZ21lbnRTaGFkZXIsXG5cdFx0XHRcdFx0XHRzaWRlOiBGcm9udFNpZGUsXG5cdFx0XHRcdFx0XHRkZXB0aFRlc3Q6IGZhbHNlLFxuXHRcdFx0XHRcdFx0ZGVwdGhXcml0ZTogZmFsc2UsXG5cdFx0XHRcdFx0XHRmb2c6IGZhbHNlXG5cdFx0XHRcdFx0fSkpO1xuXHRcdFx0XHRcdHBsYW5lTWVzaC5nZW9tZXRyeS5kZWxldGVBdHRyaWJ1dGUoJ25vcm1hbCcpOyAvLyBlbmFibGUgY29kZSBpbmplY3Rpb24gZm9yIG5vbi1idWlsdC1pbiBtYXRlcmlhbFxuXG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHBsYW5lTWVzaC5tYXRlcmlhbCwgJ21hcCcsIHtcblx0XHRcdFx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy51bmlmb3Jtcy50MkQudmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0b2JqZWN0cy51cGRhdGUocGxhbmVNZXNoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHBsYW5lTWVzaC5tYXRlcmlhbC51bmlmb3Jtcy50MkQudmFsdWUgPSBiYWNrZ3JvdW5kO1xuXG5cdFx0XHRcdGlmIChiYWNrZ3JvdW5kLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUpIHtcblx0XHRcdFx0XHRiYWNrZ3JvdW5kLnVwZGF0ZU1hdHJpeCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cGxhbmVNZXNoLm1hdGVyaWFsLnVuaWZvcm1zLnV2VHJhbnNmb3JtLnZhbHVlLmNvcHkoYmFja2dyb3VuZC5tYXRyaXgpO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50QmFja2dyb3VuZCAhPT0gYmFja2dyb3VuZCB8fCBjdXJyZW50QmFja2dyb3VuZFZlcnNpb24gIT09IGJhY2tncm91bmQudmVyc2lvbiB8fCBjdXJyZW50VG9uZW1hcHBpbmcgIT09IHJlbmRlcmVyLnRvbmVNYXBwaW5nKSB7XG5cdFx0XHRcdFx0cGxhbmVNZXNoLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRjdXJyZW50QmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG5cdFx0XHRcdFx0Y3VycmVudEJhY2tncm91bmRWZXJzaW9uID0gYmFja2dyb3VuZC52ZXJzaW9uO1xuXHRcdFx0XHRcdGN1cnJlbnRUb25lbWFwcGluZyA9IHJlbmRlcmVyLnRvbmVNYXBwaW5nO1xuXHRcdFx0XHR9IC8vIHB1c2ggdG8gdGhlIHByZS1zb3J0ZWQgb3BhcXVlIHJlbmRlciBsaXN0XG5cblxuXHRcdFx0XHRyZW5kZXJMaXN0LnVuc2hpZnQocGxhbmVNZXNoLCBwbGFuZU1lc2guZ2VvbWV0cnksIHBsYW5lTWVzaC5tYXRlcmlhbCwgMCwgMCwgbnVsbCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0Q2xlYXIoY29sb3IsIGFscGhhKSB7XG5cdFx0XHRzdGF0ZS5idWZmZXJzLmNvbG9yLnNldENsZWFyKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIGFscGhhLCBwcmVtdWx0aXBsaWVkQWxwaGEpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRnZXRDbGVhckNvbG9yOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBjbGVhckNvbG9yO1xuXHRcdFx0fSxcblx0XHRcdHNldENsZWFyQ29sb3I6IGZ1bmN0aW9uIChjb2xvciwgYWxwaGEgPSAxKSB7XG5cdFx0XHRcdGNsZWFyQ29sb3Iuc2V0KGNvbG9yKTtcblx0XHRcdFx0Y2xlYXJBbHBoYSA9IGFscGhhO1xuXHRcdFx0XHRzZXRDbGVhcihjbGVhckNvbG9yLCBjbGVhckFscGhhKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRDbGVhckFscGhhOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBjbGVhckFscGhhO1xuXHRcdFx0fSxcblx0XHRcdHNldENsZWFyQWxwaGE6IGZ1bmN0aW9uIChhbHBoYSkge1xuXHRcdFx0XHRjbGVhckFscGhhID0gYWxwaGE7XG5cdFx0XHRcdHNldENsZWFyKGNsZWFyQ29sb3IsIGNsZWFyQWxwaGEpO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogcmVuZGVyXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIFdlYkdMQmluZGluZ1N0YXRlcyhnbCwgZXh0ZW5zaW9ucywgYXR0cmlidXRlcywgY2FwYWJpbGl0aWVzKSB7XG5cdFx0Y29uc3QgbWF4VmVydGV4QXR0cmlidXRlcyA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVkVSVEVYX0FUVFJJQlMpO1xuXHRcdGNvbnN0IGV4dGVuc2lvbiA9IGNhcGFiaWxpdGllcy5pc1dlYkdMMiA/IG51bGwgOiBleHRlbnNpb25zLmdldCgnT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnKTtcblx0XHRjb25zdCB2YW9BdmFpbGFibGUgPSBjYXBhYmlsaXRpZXMuaXNXZWJHTDIgfHwgZXh0ZW5zaW9uICE9PSBudWxsO1xuXHRcdGNvbnN0IGJpbmRpbmdTdGF0ZXMgPSB7fTtcblx0XHRjb25zdCBkZWZhdWx0U3RhdGUgPSBjcmVhdGVCaW5kaW5nU3RhdGUobnVsbCk7XG5cdFx0bGV0IGN1cnJlbnRTdGF0ZSA9IGRlZmF1bHRTdGF0ZTtcblxuXHRcdGZ1bmN0aW9uIHNldHVwKG9iamVjdCwgbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5LCBpbmRleCkge1xuXHRcdFx0bGV0IHVwZGF0ZUJ1ZmZlcnMgPSBmYWxzZTtcblxuXHRcdFx0aWYgKHZhb0F2YWlsYWJsZSkge1xuXHRcdFx0XHRjb25zdCBzdGF0ZSA9IGdldEJpbmRpbmdTdGF0ZShnZW9tZXRyeSwgcHJvZ3JhbSwgbWF0ZXJpYWwpO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50U3RhdGUgIT09IHN0YXRlKSB7XG5cdFx0XHRcdFx0Y3VycmVudFN0YXRlID0gc3RhdGU7XG5cdFx0XHRcdFx0YmluZFZlcnRleEFycmF5T2JqZWN0KGN1cnJlbnRTdGF0ZS5vYmplY3QpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dXBkYXRlQnVmZmVycyA9IG5lZWRzVXBkYXRlKGdlb21ldHJ5LCBpbmRleCk7XG5cdFx0XHRcdGlmICh1cGRhdGVCdWZmZXJzKSBzYXZlQ2FjaGUoZ2VvbWV0cnksIGluZGV4KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IHdpcmVmcmFtZSA9IG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFN0YXRlLmdlb21ldHJ5ICE9PSBnZW9tZXRyeS5pZCB8fCBjdXJyZW50U3RhdGUucHJvZ3JhbSAhPT0gcHJvZ3JhbS5pZCB8fCBjdXJyZW50U3RhdGUud2lyZWZyYW1lICE9PSB3aXJlZnJhbWUpIHtcblx0XHRcdFx0XHRjdXJyZW50U3RhdGUuZ2VvbWV0cnkgPSBnZW9tZXRyeS5pZDtcblx0XHRcdFx0XHRjdXJyZW50U3RhdGUucHJvZ3JhbSA9IHByb2dyYW0uaWQ7XG5cdFx0XHRcdFx0Y3VycmVudFN0YXRlLndpcmVmcmFtZSA9IHdpcmVmcmFtZTtcblx0XHRcdFx0XHR1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAob2JqZWN0LmlzSW5zdGFuY2VkTWVzaCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHR1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGluZGV4ICE9PSBudWxsKSB7XG5cdFx0XHRcdGF0dHJpYnV0ZXMudXBkYXRlKGluZGV4LCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUik7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh1cGRhdGVCdWZmZXJzKSB7XG5cdFx0XHRcdHNldHVwVmVydGV4QXR0cmlidXRlcyhvYmplY3QsIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSk7XG5cblx0XHRcdFx0aWYgKGluZGV4ICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0Z2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgYXR0cmlidXRlcy5nZXQoaW5kZXgpLmJ1ZmZlcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVWZXJ0ZXhBcnJheU9iamVjdCgpIHtcblx0XHRcdGlmIChjYXBhYmlsaXRpZXMuaXNXZWJHTDIpIHJldHVybiBnbC5jcmVhdGVWZXJ0ZXhBcnJheSgpO1xuXHRcdFx0cmV0dXJuIGV4dGVuc2lvbi5jcmVhdGVWZXJ0ZXhBcnJheU9FUygpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJpbmRWZXJ0ZXhBcnJheU9iamVjdCh2YW8pIHtcblx0XHRcdGlmIChjYXBhYmlsaXRpZXMuaXNXZWJHTDIpIHJldHVybiBnbC5iaW5kVmVydGV4QXJyYXkodmFvKTtcblx0XHRcdHJldHVybiBleHRlbnNpb24uYmluZFZlcnRleEFycmF5T0VTKHZhbyk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGVsZXRlVmVydGV4QXJyYXlPYmplY3QodmFvKSB7XG5cdFx0XHRpZiAoY2FwYWJpbGl0aWVzLmlzV2ViR0wyKSByZXR1cm4gZ2wuZGVsZXRlVmVydGV4QXJyYXkodmFvKTtcblx0XHRcdHJldHVybiBleHRlbnNpb24uZGVsZXRlVmVydGV4QXJyYXlPRVModmFvKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRCaW5kaW5nU3RhdGUoZ2VvbWV0cnksIHByb2dyYW0sIG1hdGVyaWFsKSB7XG5cdFx0XHRjb25zdCB3aXJlZnJhbWUgPSBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWU7XG5cdFx0XHRsZXQgcHJvZ3JhbU1hcCA9IGJpbmRpbmdTdGF0ZXNbZ2VvbWV0cnkuaWRdO1xuXG5cdFx0XHRpZiAocHJvZ3JhbU1hcCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHByb2dyYW1NYXAgPSB7fTtcblx0XHRcdFx0YmluZGluZ1N0YXRlc1tnZW9tZXRyeS5pZF0gPSBwcm9ncmFtTWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgc3RhdGVNYXAgPSBwcm9ncmFtTWFwW3Byb2dyYW0uaWRdO1xuXG5cdFx0XHRpZiAoc3RhdGVNYXAgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRzdGF0ZU1hcCA9IHt9O1xuXHRcdFx0XHRwcm9ncmFtTWFwW3Byb2dyYW0uaWRdID0gc3RhdGVNYXA7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBzdGF0ZSA9IHN0YXRlTWFwW3dpcmVmcmFtZV07XG5cblx0XHRcdGlmIChzdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHN0YXRlID0gY3JlYXRlQmluZGluZ1N0YXRlKGNyZWF0ZVZlcnRleEFycmF5T2JqZWN0KCkpO1xuXHRcdFx0XHRzdGF0ZU1hcFt3aXJlZnJhbWVdID0gc3RhdGU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVCaW5kaW5nU3RhdGUodmFvKSB7XG5cdFx0XHRjb25zdCBuZXdBdHRyaWJ1dGVzID0gW107XG5cdFx0XHRjb25zdCBlbmFibGVkQXR0cmlidXRlcyA9IFtdO1xuXHRcdFx0Y29uc3QgYXR0cmlidXRlRGl2aXNvcnMgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBtYXhWZXJ0ZXhBdHRyaWJ1dGVzOyBpKyspIHtcblx0XHRcdFx0bmV3QXR0cmlidXRlc1tpXSA9IDA7XG5cdFx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzW2ldID0gMDtcblx0XHRcdFx0YXR0cmlidXRlRGl2aXNvcnNbaV0gPSAwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHQvLyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBvbiBub24tVkFPIHN1cHBvcnQgYnJvd3NlclxuXHRcdFx0XHRnZW9tZXRyeTogbnVsbCxcblx0XHRcdFx0cHJvZ3JhbTogbnVsbCxcblx0XHRcdFx0d2lyZWZyYW1lOiBmYWxzZSxcblx0XHRcdFx0bmV3QXR0cmlidXRlczogbmV3QXR0cmlidXRlcyxcblx0XHRcdFx0ZW5hYmxlZEF0dHJpYnV0ZXM6IGVuYWJsZWRBdHRyaWJ1dGVzLFxuXHRcdFx0XHRhdHRyaWJ1dGVEaXZpc29yczogYXR0cmlidXRlRGl2aXNvcnMsXG5cdFx0XHRcdG9iamVjdDogdmFvLFxuXHRcdFx0XHRhdHRyaWJ1dGVzOiB7fSxcblx0XHRcdFx0aW5kZXg6IG51bGxcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbmVlZHNVcGRhdGUoZ2VvbWV0cnksIGluZGV4KSB7XG5cdFx0XHRjb25zdCBjYWNoZWRBdHRyaWJ1dGVzID0gY3VycmVudFN0YXRlLmF0dHJpYnV0ZXM7XG5cdFx0XHRjb25zdCBnZW9tZXRyeUF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXHRcdFx0bGV0IGF0dHJpYnV0ZXNOdW0gPSAwO1xuXG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBnZW9tZXRyeUF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0Y29uc3QgY2FjaGVkQXR0cmlidXRlID0gY2FjaGVkQXR0cmlidXRlc1trZXldO1xuXHRcdFx0XHRjb25zdCBnZW9tZXRyeUF0dHJpYnV0ZSA9IGdlb21ldHJ5QXR0cmlidXRlc1trZXldO1xuXHRcdFx0XHRpZiAoY2FjaGVkQXR0cmlidXRlID09PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xuXHRcdFx0XHRpZiAoY2FjaGVkQXR0cmlidXRlLmF0dHJpYnV0ZSAhPT0gZ2VvbWV0cnlBdHRyaWJ1dGUpIHJldHVybiB0cnVlO1xuXHRcdFx0XHRpZiAoY2FjaGVkQXR0cmlidXRlLmRhdGEgIT09IGdlb21ldHJ5QXR0cmlidXRlLmRhdGEpIHJldHVybiB0cnVlO1xuXHRcdFx0XHRhdHRyaWJ1dGVzTnVtKys7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjdXJyZW50U3RhdGUuYXR0cmlidXRlc051bSAhPT0gYXR0cmlidXRlc051bSkgcmV0dXJuIHRydWU7XG5cdFx0XHRpZiAoY3VycmVudFN0YXRlLmluZGV4ICE9PSBpbmRleCkgcmV0dXJuIHRydWU7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2F2ZUNhY2hlKGdlb21ldHJ5LCBpbmRleCkge1xuXHRcdFx0Y29uc3QgY2FjaGUgPSB7fTtcblx0XHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXHRcdFx0bGV0IGF0dHJpYnV0ZXNOdW0gPSAwO1xuXG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNba2V5XTtcblx0XHRcdFx0Y29uc3QgZGF0YSA9IHt9O1xuXHRcdFx0XHRkYXRhLmF0dHJpYnV0ZSA9IGF0dHJpYnV0ZTtcblxuXHRcdFx0XHRpZiAoYXR0cmlidXRlLmRhdGEpIHtcblx0XHRcdFx0XHRkYXRhLmRhdGEgPSBhdHRyaWJ1dGUuZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhY2hlW2tleV0gPSBkYXRhO1xuXHRcdFx0XHRhdHRyaWJ1dGVzTnVtKys7XG5cdFx0XHR9XG5cblx0XHRcdGN1cnJlbnRTdGF0ZS5hdHRyaWJ1dGVzID0gY2FjaGU7XG5cdFx0XHRjdXJyZW50U3RhdGUuYXR0cmlidXRlc051bSA9IGF0dHJpYnV0ZXNOdW07XG5cdFx0XHRjdXJyZW50U3RhdGUuaW5kZXggPSBpbmRleDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpbml0QXR0cmlidXRlcygpIHtcblx0XHRcdGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBjdXJyZW50U3RhdGUubmV3QXR0cmlidXRlcztcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gbmV3QXR0cmlidXRlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdG5ld0F0dHJpYnV0ZXNbaV0gPSAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGVuYWJsZUF0dHJpYnV0ZShhdHRyaWJ1dGUpIHtcblx0XHRcdGVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoYXR0cmlidXRlLCAwKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBlbmFibGVBdHRyaWJ1dGVBbmREaXZpc29yKGF0dHJpYnV0ZSwgbWVzaFBlckF0dHJpYnV0ZSkge1xuXHRcdFx0Y29uc3QgbmV3QXR0cmlidXRlcyA9IGN1cnJlbnRTdGF0ZS5uZXdBdHRyaWJ1dGVzO1xuXHRcdFx0Y29uc3QgZW5hYmxlZEF0dHJpYnV0ZXMgPSBjdXJyZW50U3RhdGUuZW5hYmxlZEF0dHJpYnV0ZXM7XG5cdFx0XHRjb25zdCBhdHRyaWJ1dGVEaXZpc29ycyA9IGN1cnJlbnRTdGF0ZS5hdHRyaWJ1dGVEaXZpc29ycztcblx0XHRcdG5ld0F0dHJpYnV0ZXNbYXR0cmlidXRlXSA9IDE7XG5cblx0XHRcdGlmIChlbmFibGVkQXR0cmlidXRlc1thdHRyaWJ1dGVdID09PSAwKSB7XG5cdFx0XHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJpYnV0ZSk7XG5cdFx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPSAxO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYXR0cmlidXRlRGl2aXNvcnNbYXR0cmlidXRlXSAhPT0gbWVzaFBlckF0dHJpYnV0ZSkge1xuXHRcdFx0XHRjb25zdCBleHRlbnNpb24gPSBjYXBhYmlsaXRpZXMuaXNXZWJHTDIgPyBnbCA6IGV4dGVuc2lvbnMuZ2V0KCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyk7XG5cdFx0XHRcdGV4dGVuc2lvbltjYXBhYmlsaXRpZXMuaXNXZWJHTDIgPyAndmVydGV4QXR0cmliRGl2aXNvcicgOiAndmVydGV4QXR0cmliRGl2aXNvckFOR0xFJ10oYXR0cmlidXRlLCBtZXNoUGVyQXR0cmlidXRlKTtcblx0XHRcdFx0YXR0cmlidXRlRGl2aXNvcnNbYXR0cmlidXRlXSA9IG1lc2hQZXJBdHRyaWJ1dGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKSB7XG5cdFx0XHRjb25zdCBuZXdBdHRyaWJ1dGVzID0gY3VycmVudFN0YXRlLm5ld0F0dHJpYnV0ZXM7XG5cdFx0XHRjb25zdCBlbmFibGVkQXR0cmlidXRlcyA9IGN1cnJlbnRTdGF0ZS5lbmFibGVkQXR0cmlidXRlcztcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gZW5hYmxlZEF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRpZiAoZW5hYmxlZEF0dHJpYnV0ZXNbaV0gIT09IG5ld0F0dHJpYnV0ZXNbaV0pIHtcblx0XHRcdFx0XHRnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaSk7XG5cdFx0XHRcdFx0ZW5hYmxlZEF0dHJpYnV0ZXNbaV0gPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdmVydGV4QXR0cmliUG9pbnRlcihpbmRleCwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBvZmZzZXQpIHtcblx0XHRcdGlmIChjYXBhYmlsaXRpZXMuaXNXZWJHTDIgPT09IHRydWUgJiYgKHR5cGUgPT09IGdsLklOVCB8fCB0eXBlID09PSBnbC5VTlNJR05FRF9JTlQpKSB7XG5cdFx0XHRcdGdsLnZlcnRleEF0dHJpYklQb2ludGVyKGluZGV4LCBzaXplLCB0eXBlLCBzdHJpZGUsIG9mZnNldCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGluZGV4LCBzaXplLCB0eXBlLCBub3JtYWxpemVkLCBzdHJpZGUsIG9mZnNldCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKG9iamVjdCwgbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5KSB7XG5cdFx0XHRpZiAoY2FwYWJpbGl0aWVzLmlzV2ViR0wyID09PSBmYWxzZSAmJiAob2JqZWN0LmlzSW5zdGFuY2VkTWVzaCB8fCBnZW9tZXRyeS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5KSkge1xuXHRcdFx0XHRpZiAoZXh0ZW5zaW9ucy5nZXQoJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnKSA9PT0gbnVsbCkgcmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpbml0QXR0cmlidXRlcygpO1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnlBdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblx0XHRcdGNvbnN0IHByb2dyYW1BdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XG5cdFx0XHRjb25zdCBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgPSBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzO1xuXG5cdFx0XHRmb3IgKGNvbnN0IG5hbWUgaW4gcHJvZ3JhbUF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0Y29uc3QgcHJvZ3JhbUF0dHJpYnV0ZSA9IHByb2dyYW1BdHRyaWJ1dGVzW25hbWVdO1xuXG5cdFx0XHRcdGlmIChwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uID49IDApIHtcblx0XHRcdFx0XHRsZXQgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBnZW9tZXRyeUF0dHJpYnV0ZXNbbmFtZV07XG5cblx0XHRcdFx0XHRpZiAoZ2VvbWV0cnlBdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0aWYgKG5hbWUgPT09ICdpbnN0YW5jZU1hdHJpeCcgJiYgb2JqZWN0Lmluc3RhbmNlTWF0cml4KSBnZW9tZXRyeUF0dHJpYnV0ZSA9IG9iamVjdC5pbnN0YW5jZU1hdHJpeDtcblx0XHRcdFx0XHRcdGlmIChuYW1lID09PSAnaW5zdGFuY2VDb2xvcicgJiYgb2JqZWN0Lmluc3RhbmNlQ29sb3IpIGdlb21ldHJ5QXR0cmlidXRlID0gb2JqZWN0Lmluc3RhbmNlQ29sb3I7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGdlb21ldHJ5QXR0cmlidXRlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGNvbnN0IG5vcm1hbGl6ZWQgPSBnZW9tZXRyeUF0dHJpYnV0ZS5ub3JtYWxpemVkO1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2l6ZSA9IGdlb21ldHJ5QXR0cmlidXRlLml0ZW1TaXplO1xuXHRcdFx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlcy5nZXQoZ2VvbWV0cnlBdHRyaWJ1dGUpOyAvLyBUT0RPIEF0dHJpYnV0ZSBtYXkgbm90IGJlIGF2YWlsYWJsZSBvbiBjb250ZXh0IHJlc3RvcmVcblxuXHRcdFx0XHRcdFx0aWYgKGF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcblx0XHRcdFx0XHRcdGNvbnN0IGJ1ZmZlciA9IGF0dHJpYnV0ZS5idWZmZXI7XG5cdFx0XHRcdFx0XHRjb25zdCB0eXBlID0gYXR0cmlidXRlLnR5cGU7XG5cdFx0XHRcdFx0XHRjb25zdCBieXRlc1BlckVsZW1lbnQgPSBhdHRyaWJ1dGUuYnl0ZXNQZXJFbGVtZW50O1xuXG5cdFx0XHRcdFx0XHRpZiAoZ2VvbWV0cnlBdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBkYXRhID0gZ2VvbWV0cnlBdHRyaWJ1dGUuZGF0YTtcblx0XHRcdFx0XHRcdFx0Y29uc3Qgc3RyaWRlID0gZGF0YS5zdHJpZGU7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG9mZnNldCA9IGdlb21ldHJ5QXR0cmlidXRlLm9mZnNldDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoZGF0YSAmJiBkYXRhLmlzSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIpIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb25TaXplOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IocHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvbiArIGksIGRhdGEubWVzaFBlckF0dHJpYnV0ZSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKG9iamVjdC5pc0luc3RhbmNlZE1lc2ggIT09IHRydWUgJiYgZ2VvbWV0cnkuX21heEluc3RhbmNlQ291bnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkuX21heEluc3RhbmNlQ291bnQgPSBkYXRhLm1lc2hQZXJBdHRyaWJ1dGUgKiBkYXRhLmNvdW50O1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb25TaXplOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZShwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uICsgaSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG5cblx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uU2l6ZTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmVydGV4QXR0cmliUG9pbnRlcihwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uICsgaSwgc2l6ZSAvIHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb25TaXplLCB0eXBlLCBub3JtYWxpemVkLCBzdHJpZGUgKiBieXRlc1BlckVsZW1lbnQsIChvZmZzZXQgKyBzaXplIC8gcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvblNpemUgKiBpKSAqIGJ5dGVzUGVyRWxlbWVudCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmIChnZW9tZXRyeUF0dHJpYnV0ZS5pc0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSkge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvblNpemU7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvcihwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uICsgaSwgZ2VvbWV0cnlBdHRyaWJ1dGUubWVzaFBlckF0dHJpYnV0ZSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKG9iamVjdC5pc0luc3RhbmNlZE1lc2ggIT09IHRydWUgJiYgZ2VvbWV0cnkuX21heEluc3RhbmNlQ291bnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkuX21heEluc3RhbmNlQ291bnQgPSBnZW9tZXRyeUF0dHJpYnV0ZS5tZXNoUGVyQXR0cmlidXRlICogZ2VvbWV0cnlBdHRyaWJ1dGUuY291bnQ7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvblNpemU7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24gKyBpKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb25TaXplOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHR2ZXJ0ZXhBdHRyaWJQb2ludGVyKHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24gKyBpLCBzaXplIC8gcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvblNpemUsIHR5cGUsIG5vcm1hbGl6ZWQsIHNpemUgKiBieXRlc1BlckVsZW1lbnQsIHNpemUgLyBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uU2l6ZSAqIGkgKiBieXRlc1BlckVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXNbbmFtZV07XG5cblx0XHRcdFx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdHN3aXRjaCAodmFsdWUubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdFx0XHRcdFx0Z2wudmVydGV4QXR0cmliMmZ2KHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24sIHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAzOlxuXHRcdFx0XHRcdFx0XHRcdFx0Z2wudmVydGV4QXR0cmliM2Z2KHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24sIHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSA0OlxuXHRcdFx0XHRcdFx0XHRcdFx0Z2wudmVydGV4QXR0cmliNGZ2KHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24sIHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHRcdGdsLnZlcnRleEF0dHJpYjFmdihwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkaXNwb3NlKCkge1xuXHRcdFx0cmVzZXQoKTtcblxuXHRcdFx0Zm9yIChjb25zdCBnZW9tZXRyeUlkIGluIGJpbmRpbmdTdGF0ZXMpIHtcblx0XHRcdFx0Y29uc3QgcHJvZ3JhbU1hcCA9IGJpbmRpbmdTdGF0ZXNbZ2VvbWV0cnlJZF07XG5cblx0XHRcdFx0Zm9yIChjb25zdCBwcm9ncmFtSWQgaW4gcHJvZ3JhbU1hcCkge1xuXHRcdFx0XHRcdGNvbnN0IHN0YXRlTWFwID0gcHJvZ3JhbU1hcFtwcm9ncmFtSWRdO1xuXG5cdFx0XHRcdFx0Zm9yIChjb25zdCB3aXJlZnJhbWUgaW4gc3RhdGVNYXApIHtcblx0XHRcdFx0XHRcdGRlbGV0ZVZlcnRleEFycmF5T2JqZWN0KHN0YXRlTWFwW3dpcmVmcmFtZV0ub2JqZWN0KTtcblx0XHRcdFx0XHRcdGRlbGV0ZSBzdGF0ZU1hcFt3aXJlZnJhbWVdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGRlbGV0ZSBwcm9ncmFtTWFwW3Byb2dyYW1JZF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgYmluZGluZ1N0YXRlc1tnZW9tZXRyeUlkXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWxlYXNlU3RhdGVzT2ZHZW9tZXRyeShnZW9tZXRyeSkge1xuXHRcdFx0aWYgKGJpbmRpbmdTdGF0ZXNbZ2VvbWV0cnkuaWRdID09PSB1bmRlZmluZWQpIHJldHVybjtcblx0XHRcdGNvbnN0IHByb2dyYW1NYXAgPSBiaW5kaW5nU3RhdGVzW2dlb21ldHJ5LmlkXTtcblxuXHRcdFx0Zm9yIChjb25zdCBwcm9ncmFtSWQgaW4gcHJvZ3JhbU1hcCkge1xuXHRcdFx0XHRjb25zdCBzdGF0ZU1hcCA9IHByb2dyYW1NYXBbcHJvZ3JhbUlkXTtcblxuXHRcdFx0XHRmb3IgKGNvbnN0IHdpcmVmcmFtZSBpbiBzdGF0ZU1hcCkge1xuXHRcdFx0XHRcdGRlbGV0ZVZlcnRleEFycmF5T2JqZWN0KHN0YXRlTWFwW3dpcmVmcmFtZV0ub2JqZWN0KTtcblx0XHRcdFx0XHRkZWxldGUgc3RhdGVNYXBbd2lyZWZyYW1lXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBwcm9ncmFtTWFwW3Byb2dyYW1JZF07XG5cdFx0XHR9XG5cblx0XHRcdGRlbGV0ZSBiaW5kaW5nU3RhdGVzW2dlb21ldHJ5LmlkXTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWxlYXNlU3RhdGVzT2ZQcm9ncmFtKHByb2dyYW0pIHtcblx0XHRcdGZvciAoY29uc3QgZ2VvbWV0cnlJZCBpbiBiaW5kaW5nU3RhdGVzKSB7XG5cdFx0XHRcdGNvbnN0IHByb2dyYW1NYXAgPSBiaW5kaW5nU3RhdGVzW2dlb21ldHJ5SWRdO1xuXHRcdFx0XHRpZiAocHJvZ3JhbU1hcFtwcm9ncmFtLmlkXSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcblx0XHRcdFx0Y29uc3Qgc3RhdGVNYXAgPSBwcm9ncmFtTWFwW3Byb2dyYW0uaWRdO1xuXG5cdFx0XHRcdGZvciAoY29uc3Qgd2lyZWZyYW1lIGluIHN0YXRlTWFwKSB7XG5cdFx0XHRcdFx0ZGVsZXRlVmVydGV4QXJyYXlPYmplY3Qoc3RhdGVNYXBbd2lyZWZyYW1lXS5vYmplY3QpO1xuXHRcdFx0XHRcdGRlbGV0ZSBzdGF0ZU1hcFt3aXJlZnJhbWVdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIHByb2dyYW1NYXBbcHJvZ3JhbS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVzZXQoKSB7XG5cdFx0XHRyZXNldERlZmF1bHRTdGF0ZSgpO1xuXHRcdFx0aWYgKGN1cnJlbnRTdGF0ZSA9PT0gZGVmYXVsdFN0YXRlKSByZXR1cm47XG5cdFx0XHRjdXJyZW50U3RhdGUgPSBkZWZhdWx0U3RhdGU7XG5cdFx0XHRiaW5kVmVydGV4QXJyYXlPYmplY3QoY3VycmVudFN0YXRlLm9iamVjdCk7XG5cdFx0fSAvLyBmb3IgYmFja3dhcmQtY29tcGF0aWxpYml0eVxuXG5cblx0XHRmdW5jdGlvbiByZXNldERlZmF1bHRTdGF0ZSgpIHtcblx0XHRcdGRlZmF1bHRTdGF0ZS5nZW9tZXRyeSA9IG51bGw7XG5cdFx0XHRkZWZhdWx0U3RhdGUucHJvZ3JhbSA9IG51bGw7XG5cdFx0XHRkZWZhdWx0U3RhdGUud2lyZWZyYW1lID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHNldHVwOiBzZXR1cCxcblx0XHRcdHJlc2V0OiByZXNldCxcblx0XHRcdHJlc2V0RGVmYXVsdFN0YXRlOiByZXNldERlZmF1bHRTdGF0ZSxcblx0XHRcdGRpc3Bvc2U6IGRpc3Bvc2UsXG5cdFx0XHRyZWxlYXNlU3RhdGVzT2ZHZW9tZXRyeTogcmVsZWFzZVN0YXRlc09mR2VvbWV0cnksXG5cdFx0XHRyZWxlYXNlU3RhdGVzT2ZQcm9ncmFtOiByZWxlYXNlU3RhdGVzT2ZQcm9ncmFtLFxuXHRcdFx0aW5pdEF0dHJpYnV0ZXM6IGluaXRBdHRyaWJ1dGVzLFxuXHRcdFx0ZW5hYmxlQXR0cmlidXRlOiBlbmFibGVBdHRyaWJ1dGUsXG5cdFx0XHRkaXNhYmxlVW51c2VkQXR0cmlidXRlczogZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXNcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gV2ViR0xCdWZmZXJSZW5kZXJlcihnbCwgZXh0ZW5zaW9ucywgaW5mbywgY2FwYWJpbGl0aWVzKSB7XG5cdFx0Y29uc3QgaXNXZWJHTDIgPSBjYXBhYmlsaXRpZXMuaXNXZWJHTDI7XG5cdFx0bGV0IG1vZGU7XG5cblx0XHRmdW5jdGlvbiBzZXRNb2RlKHZhbHVlKSB7XG5cdFx0XHRtb2RlID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVuZGVyKHN0YXJ0LCBjb3VudCkge1xuXHRcdFx0Z2wuZHJhd0FycmF5cyhtb2RlLCBzdGFydCwgY291bnQpO1xuXHRcdFx0aW5mby51cGRhdGUoY291bnQsIG1vZGUsIDEpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbmRlckluc3RhbmNlcyhzdGFydCwgY291bnQsIHByaW1jb3VudCkge1xuXHRcdFx0aWYgKHByaW1jb3VudCA9PT0gMCkgcmV0dXJuO1xuXHRcdFx0bGV0IGV4dGVuc2lvbiwgbWV0aG9kTmFtZTtcblxuXHRcdFx0aWYgKGlzV2ViR0wyKSB7XG5cdFx0XHRcdGV4dGVuc2lvbiA9IGdsO1xuXHRcdFx0XHRtZXRob2ROYW1lID0gJ2RyYXdBcnJheXNJbnN0YW5jZWQnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnKTtcblx0XHRcdFx0bWV0aG9kTmFtZSA9ICdkcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUnO1xuXG5cdFx0XHRcdGlmIChleHRlbnNpb24gPT09IG51bGwpIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTEJ1ZmZlclJlbmRlcmVyOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZXh0ZW5zaW9uW21ldGhvZE5hbWVdKG1vZGUsIHN0YXJ0LCBjb3VudCwgcHJpbWNvdW50KTtcblx0XHRcdGluZm8udXBkYXRlKGNvdW50LCBtb2RlLCBwcmltY291bnQpO1xuXHRcdH0gLy9cblxuXG5cdFx0dGhpcy5zZXRNb2RlID0gc2V0TW9kZTtcblx0XHR0aGlzLnJlbmRlciA9IHJlbmRlcjtcblx0XHR0aGlzLnJlbmRlckluc3RhbmNlcyA9IHJlbmRlckluc3RhbmNlcztcblx0fVxuXG5cdGZ1bmN0aW9uIFdlYkdMQ2FwYWJpbGl0aWVzKGdsLCBleHRlbnNpb25zLCBwYXJhbWV0ZXJzKSB7XG5cdFx0bGV0IG1heEFuaXNvdHJvcHk7XG5cblx0XHRmdW5jdGlvbiBnZXRNYXhBbmlzb3Ryb3B5KCkge1xuXHRcdFx0aWYgKG1heEFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCkgcmV0dXJuIG1heEFuaXNvdHJvcHk7XG5cblx0XHRcdGlmIChleHRlbnNpb25zLmhhcygnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJykgPT09IHRydWUpIHtcblx0XHRcdFx0Y29uc3QgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycpO1xuXHRcdFx0XHRtYXhBbmlzb3Ryb3B5ID0gZ2wuZ2V0UGFyYW1ldGVyKGV4dGVuc2lvbi5NQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF4QW5pc290cm9weSA9IDA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXhBbmlzb3Ryb3B5O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldE1heFByZWNpc2lvbihwcmVjaXNpb24pIHtcblx0XHRcdGlmIChwcmVjaXNpb24gPT09ICdoaWdocCcpIHtcblx0XHRcdFx0aWYgKGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5WRVJURVhfU0hBREVSLCBnbC5ISUdIX0ZMT0FUKS5wcmVjaXNpb24gPiAwICYmIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkhJR0hfRkxPQVQpLnByZWNpc2lvbiA+IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gJ2hpZ2hwJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHByZWNpc2lvbiA9ICdtZWRpdW1wJztcblx0XHRcdH1cblxuXHRcdFx0aWYgKHByZWNpc2lvbiA9PT0gJ21lZGl1bXAnKSB7XG5cdFx0XHRcdGlmIChnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuVkVSVEVYX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUKS5wcmVjaXNpb24gPiAwICYmIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCkucHJlY2lzaW9uID4gMCkge1xuXHRcdFx0XHRcdHJldHVybiAnbWVkaXVtcCc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICdsb3dwJztcblx0XHR9XG5cdFx0LyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cblxuXG5cdFx0Y29uc3QgaXNXZWJHTDIgPSB0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0IHx8IHR5cGVvZiBXZWJHTDJDb21wdXRlUmVuZGVyaW5nQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2wgaW5zdGFuY2VvZiBXZWJHTDJDb21wdXRlUmVuZGVyaW5nQ29udGV4dDtcblx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZGVmICovXG5cblx0XHRsZXQgcHJlY2lzaW9uID0gcGFyYW1ldGVycy5wcmVjaXNpb24gIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHJlY2lzaW9uIDogJ2hpZ2hwJztcblx0XHRjb25zdCBtYXhQcmVjaXNpb24gPSBnZXRNYXhQcmVjaXNpb24ocHJlY2lzaW9uKTtcblxuXHRcdGlmIChtYXhQcmVjaXNpb24gIT09IHByZWNpc2lvbikge1xuXHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOicsIHByZWNpc2lvbiwgJ25vdCBzdXBwb3J0ZWQsIHVzaW5nJywgbWF4UHJlY2lzaW9uLCAnaW5zdGVhZC4nKTtcblx0XHRcdHByZWNpc2lvbiA9IG1heFByZWNpc2lvbjtcblx0XHR9XG5cblx0XHRjb25zdCBkcmF3QnVmZmVycyA9IGlzV2ViR0wyIHx8IGV4dGVuc2lvbnMuaGFzKCdXRUJHTF9kcmF3X2J1ZmZlcnMnKTtcblx0XHRjb25zdCBsb2dhcml0aG1pY0RlcHRoQnVmZmVyID0gcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID09PSB0cnVlO1xuXHRcdGNvbnN0IG1heFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKTtcblx0XHRjb25zdCBtYXhWZXJ0ZXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMpO1xuXHRcdGNvbnN0IG1heFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpO1xuXHRcdGNvbnN0IG1heEN1YmVtYXBTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUpO1xuXHRcdGNvbnN0IG1heEF0dHJpYnV0ZXMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1ZFUlRFWF9BVFRSSUJTKTtcblx0XHRjb25zdCBtYXhWZXJ0ZXhVbmlmb3JtcyA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUyk7XG5cdFx0Y29uc3QgbWF4VmFyeWluZ3MgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1ZBUllJTkdfVkVDVE9SUyk7XG5cdFx0Y29uc3QgbWF4RnJhZ21lbnRVbmlmb3JtcyA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTKTtcblx0XHRjb25zdCB2ZXJ0ZXhUZXh0dXJlcyA9IG1heFZlcnRleFRleHR1cmVzID4gMDtcblx0XHRjb25zdCBmbG9hdEZyYWdtZW50VGV4dHVyZXMgPSBpc1dlYkdMMiB8fCBleHRlbnNpb25zLmhhcygnT0VTX3RleHR1cmVfZmxvYXQnKTtcblx0XHRjb25zdCBmbG9hdFZlcnRleFRleHR1cmVzID0gdmVydGV4VGV4dHVyZXMgJiYgZmxvYXRGcmFnbWVudFRleHR1cmVzO1xuXHRcdGNvbnN0IG1heFNhbXBsZXMgPSBpc1dlYkdMMiA/IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfU0FNUExFUykgOiAwO1xuXHRcdHJldHVybiB7XG5cdFx0XHRpc1dlYkdMMjogaXNXZWJHTDIsXG5cdFx0XHRkcmF3QnVmZmVyczogZHJhd0J1ZmZlcnMsXG5cdFx0XHRnZXRNYXhBbmlzb3Ryb3B5OiBnZXRNYXhBbmlzb3Ryb3B5LFxuXHRcdFx0Z2V0TWF4UHJlY2lzaW9uOiBnZXRNYXhQcmVjaXNpb24sXG5cdFx0XHRwcmVjaXNpb246IHByZWNpc2lvbixcblx0XHRcdGxvZ2FyaXRobWljRGVwdGhCdWZmZXI6IGxvZ2FyaXRobWljRGVwdGhCdWZmZXIsXG5cdFx0XHRtYXhUZXh0dXJlczogbWF4VGV4dHVyZXMsXG5cdFx0XHRtYXhWZXJ0ZXhUZXh0dXJlczogbWF4VmVydGV4VGV4dHVyZXMsXG5cdFx0XHRtYXhUZXh0dXJlU2l6ZTogbWF4VGV4dHVyZVNpemUsXG5cdFx0XHRtYXhDdWJlbWFwU2l6ZTogbWF4Q3ViZW1hcFNpemUsXG5cdFx0XHRtYXhBdHRyaWJ1dGVzOiBtYXhBdHRyaWJ1dGVzLFxuXHRcdFx0bWF4VmVydGV4VW5pZm9ybXM6IG1heFZlcnRleFVuaWZvcm1zLFxuXHRcdFx0bWF4VmFyeWluZ3M6IG1heFZhcnlpbmdzLFxuXHRcdFx0bWF4RnJhZ21lbnRVbmlmb3JtczogbWF4RnJhZ21lbnRVbmlmb3Jtcyxcblx0XHRcdHZlcnRleFRleHR1cmVzOiB2ZXJ0ZXhUZXh0dXJlcyxcblx0XHRcdGZsb2F0RnJhZ21lbnRUZXh0dXJlczogZmxvYXRGcmFnbWVudFRleHR1cmVzLFxuXHRcdFx0ZmxvYXRWZXJ0ZXhUZXh0dXJlczogZmxvYXRWZXJ0ZXhUZXh0dXJlcyxcblx0XHRcdG1heFNhbXBsZXM6IG1heFNhbXBsZXNcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gV2ViR0xDbGlwcGluZyhwcm9wZXJ0aWVzKSB7XG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdGxldCBnbG9iYWxTdGF0ZSA9IG51bGwsXG5cdFx0XHRcdG51bUdsb2JhbFBsYW5lcyA9IDAsXG5cdFx0XHRcdGxvY2FsQ2xpcHBpbmdFbmFibGVkID0gZmFsc2UsXG5cdFx0XHRcdHJlbmRlcmluZ1NoYWRvd3MgPSBmYWxzZTtcblx0XHRjb25zdCBwbGFuZSA9IG5ldyBQbGFuZSgpLFxuXHRcdFx0XHRcdHZpZXdOb3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpLFxuXHRcdFx0XHRcdHVuaWZvcm0gPSB7XG5cdFx0XHR2YWx1ZTogbnVsbCxcblx0XHRcdG5lZWRzVXBkYXRlOiBmYWxzZVxuXHRcdH07XG5cdFx0dGhpcy51bmlmb3JtID0gdW5pZm9ybTtcblx0XHR0aGlzLm51bVBsYW5lcyA9IDA7XG5cdFx0dGhpcy5udW1JbnRlcnNlY3Rpb24gPSAwO1xuXG5cdFx0dGhpcy5pbml0ID0gZnVuY3Rpb24gKHBsYW5lcywgZW5hYmxlTG9jYWxDbGlwcGluZywgY2FtZXJhKSB7XG5cdFx0XHRjb25zdCBlbmFibGVkID0gcGxhbmVzLmxlbmd0aCAhPT0gMCB8fCBlbmFibGVMb2NhbENsaXBwaW5nIHx8IC8vIGVuYWJsZSBzdGF0ZSBvZiBwcmV2aW91cyBmcmFtZSAtIHRoZSBjbGlwcGluZyBjb2RlIGhhcyB0b1xuXHRcdFx0Ly8gcnVuIGFub3RoZXIgZnJhbWUgaW4gb3JkZXIgdG8gcmVzZXQgdGhlIHN0YXRlOlxuXHRcdFx0bnVtR2xvYmFsUGxhbmVzICE9PSAwIHx8IGxvY2FsQ2xpcHBpbmdFbmFibGVkO1xuXHRcdFx0bG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBlbmFibGVMb2NhbENsaXBwaW5nO1xuXHRcdFx0Z2xvYmFsU3RhdGUgPSBwcm9qZWN0UGxhbmVzKHBsYW5lcywgY2FtZXJhLCAwKTtcblx0XHRcdG51bUdsb2JhbFBsYW5lcyA9IHBsYW5lcy5sZW5ndGg7XG5cdFx0XHRyZXR1cm4gZW5hYmxlZDtcblx0XHR9O1xuXG5cdFx0dGhpcy5iZWdpblNoYWRvd3MgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW5kZXJpbmdTaGFkb3dzID0gdHJ1ZTtcblx0XHRcdHByb2plY3RQbGFuZXMobnVsbCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuZW5kU2hhZG93cyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbmRlcmluZ1NoYWRvd3MgPSBmYWxzZTtcblx0XHRcdHJlc2V0R2xvYmFsU3RhdGUoKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChtYXRlcmlhbCwgY2FtZXJhLCB1c2VDYWNoZSkge1xuXHRcdFx0Y29uc3QgcGxhbmVzID0gbWF0ZXJpYWwuY2xpcHBpbmdQbGFuZXMsXG5cdFx0XHRcdFx0XHRjbGlwSW50ZXJzZWN0aW9uID0gbWF0ZXJpYWwuY2xpcEludGVyc2VjdGlvbixcblx0XHRcdFx0XHRcdGNsaXBTaGFkb3dzID0gbWF0ZXJpYWwuY2xpcFNoYWRvd3M7XG5cdFx0XHRjb25zdCBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldChtYXRlcmlhbCk7XG5cblx0XHRcdGlmICghbG9jYWxDbGlwcGluZ0VuYWJsZWQgfHwgcGxhbmVzID09PSBudWxsIHx8IHBsYW5lcy5sZW5ndGggPT09IDAgfHwgcmVuZGVyaW5nU2hhZG93cyAmJiAhY2xpcFNoYWRvd3MpIHtcblx0XHRcdFx0Ly8gdGhlcmUncyBubyBsb2NhbCBjbGlwcGluZ1xuXHRcdFx0XHRpZiAocmVuZGVyaW5nU2hhZG93cykge1xuXHRcdFx0XHRcdC8vIHRoZXJlJ3Mgbm8gZ2xvYmFsIGNsaXBwaW5nXG5cdFx0XHRcdFx0cHJvamVjdFBsYW5lcyhudWxsKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXNldEdsb2JhbFN0YXRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IG5HbG9iYWwgPSByZW5kZXJpbmdTaGFkb3dzID8gMCA6IG51bUdsb2JhbFBsYW5lcyxcblx0XHRcdFx0XHRcdFx0bEdsb2JhbCA9IG5HbG9iYWwgKiA0O1xuXHRcdFx0XHRsZXQgZHN0QXJyYXkgPSBtYXRlcmlhbFByb3BlcnRpZXMuY2xpcHBpbmdTdGF0ZSB8fCBudWxsO1xuXHRcdFx0XHR1bmlmb3JtLnZhbHVlID0gZHN0QXJyYXk7IC8vIGVuc3VyZSB1bmlxdWUgc3RhdGVcblxuXHRcdFx0XHRkc3RBcnJheSA9IHByb2plY3RQbGFuZXMocGxhbmVzLCBjYW1lcmEsIGxHbG9iYWwsIHVzZUNhY2hlKTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSAhPT0gbEdsb2JhbDsgKytpKSB7XG5cdFx0XHRcdFx0ZHN0QXJyYXlbaV0gPSBnbG9iYWxTdGF0ZVtpXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5jbGlwcGluZ1N0YXRlID0gZHN0QXJyYXk7XG5cdFx0XHRcdHRoaXMubnVtSW50ZXJzZWN0aW9uID0gY2xpcEludGVyc2VjdGlvbiA/IHRoaXMubnVtUGxhbmVzIDogMDtcblx0XHRcdFx0dGhpcy5udW1QbGFuZXMgKz0gbkdsb2JhbDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVzZXRHbG9iYWxTdGF0ZSgpIHtcblx0XHRcdGlmICh1bmlmb3JtLnZhbHVlICE9PSBnbG9iYWxTdGF0ZSkge1xuXHRcdFx0XHR1bmlmb3JtLnZhbHVlID0gZ2xvYmFsU3RhdGU7XG5cdFx0XHRcdHVuaWZvcm0ubmVlZHNVcGRhdGUgPSBudW1HbG9iYWxQbGFuZXMgPiAwO1xuXHRcdFx0fVxuXG5cdFx0XHRzY29wZS5udW1QbGFuZXMgPSBudW1HbG9iYWxQbGFuZXM7XG5cdFx0XHRzY29wZS5udW1JbnRlcnNlY3Rpb24gPSAwO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHByb2plY3RQbGFuZXMocGxhbmVzLCBjYW1lcmEsIGRzdE9mZnNldCwgc2tpcFRyYW5zZm9ybSkge1xuXHRcdFx0Y29uc3QgblBsYW5lcyA9IHBsYW5lcyAhPT0gbnVsbCA/IHBsYW5lcy5sZW5ndGggOiAwO1xuXHRcdFx0bGV0IGRzdEFycmF5ID0gbnVsbDtcblxuXHRcdFx0aWYgKG5QbGFuZXMgIT09IDApIHtcblx0XHRcdFx0ZHN0QXJyYXkgPSB1bmlmb3JtLnZhbHVlO1xuXG5cdFx0XHRcdGlmIChza2lwVHJhbnNmb3JtICE9PSB0cnVlIHx8IGRzdEFycmF5ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0Y29uc3QgZmxhdFNpemUgPSBkc3RPZmZzZXQgKyBuUGxhbmVzICogNCxcblx0XHRcdFx0XHRcdFx0XHR2aWV3TWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZTtcblx0XHRcdFx0XHR2aWV3Tm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCh2aWV3TWF0cml4KTtcblxuXHRcdFx0XHRcdGlmIChkc3RBcnJheSA9PT0gbnVsbCB8fCBkc3RBcnJheS5sZW5ndGggPCBmbGF0U2l6ZSkge1xuXHRcdFx0XHRcdFx0ZHN0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGZsYXRTaXplKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaTQgPSBkc3RPZmZzZXQ7IGkgIT09IG5QbGFuZXM7ICsraSwgaTQgKz0gNCkge1xuXHRcdFx0XHRcdFx0cGxhbmUuY29weShwbGFuZXNbaV0pLmFwcGx5TWF0cml4NCh2aWV3TWF0cml4LCB2aWV3Tm9ybWFsTWF0cml4KTtcblx0XHRcdFx0XHRcdHBsYW5lLm5vcm1hbC50b0FycmF5KGRzdEFycmF5LCBpNCk7XG5cdFx0XHRcdFx0XHRkc3RBcnJheVtpNCArIDNdID0gcGxhbmUuY29uc3RhbnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dW5pZm9ybS52YWx1ZSA9IGRzdEFycmF5O1xuXHRcdFx0XHR1bmlmb3JtLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0c2NvcGUubnVtUGxhbmVzID0gblBsYW5lcztcblx0XHRcdHNjb3BlLm51bUludGVyc2VjdGlvbiA9IDA7XG5cdFx0XHRyZXR1cm4gZHN0QXJyYXk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gV2ViR0xDdWJlTWFwcyhyZW5kZXJlcikge1xuXHRcdGxldCBjdWJlbWFwcyA9IG5ldyBXZWFrTWFwKCk7XG5cblx0XHRmdW5jdGlvbiBtYXBUZXh0dXJlTWFwcGluZyh0ZXh0dXJlLCBtYXBwaW5nKSB7XG5cdFx0XHRpZiAobWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcpIHtcblx0XHRcdFx0dGV4dHVyZS5tYXBwaW5nID0gQ3ViZVJlZmxlY3Rpb25NYXBwaW5nO1xuXHRcdFx0fSBlbHNlIGlmIChtYXBwaW5nID09PSBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZykge1xuXHRcdFx0XHR0ZXh0dXJlLm1hcHBpbmcgPSBDdWJlUmVmcmFjdGlvbk1hcHBpbmc7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0ZXh0dXJlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldCh0ZXh0dXJlKSB7XG5cdFx0XHRpZiAodGV4dHVyZSAmJiB0ZXh0dXJlLmlzVGV4dHVyZSAmJiB0ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0Y29uc3QgbWFwcGluZyA9IHRleHR1cmUubWFwcGluZztcblxuXHRcdFx0XHRpZiAobWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgfHwgbWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcpIHtcblx0XHRcdFx0XHRpZiAoY3ViZW1hcHMuaGFzKHRleHR1cmUpKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBjdWJlbWFwID0gY3ViZW1hcHMuZ2V0KHRleHR1cmUpLnRleHR1cmU7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbWFwVGV4dHVyZU1hcHBpbmcoY3ViZW1hcCwgdGV4dHVyZS5tYXBwaW5nKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc3QgaW1hZ2UgPSB0ZXh0dXJlLmltYWdlO1xuXG5cdFx0XHRcdFx0XHRpZiAoaW1hZ2UgJiYgaW1hZ2UuaGVpZ2h0ID4gMCkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBjdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHJlbmRlclRhcmdldCA9IG5ldyBXZWJHTEN1YmVSZW5kZXJUYXJnZXQoaW1hZ2UuaGVpZ2h0IC8gMik7XG5cdFx0XHRcdFx0XHRcdHJlbmRlclRhcmdldC5mcm9tRXF1aXJlY3Rhbmd1bGFyVGV4dHVyZShyZW5kZXJlciwgdGV4dHVyZSk7XG5cdFx0XHRcdFx0XHRcdGN1YmVtYXBzLnNldCh0ZXh0dXJlLCByZW5kZXJUYXJnZXQpO1xuXHRcdFx0XHRcdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoY3VycmVudFJlbmRlclRhcmdldCk7XG5cdFx0XHRcdFx0XHRcdHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbWFwVGV4dHVyZU1hcHBpbmcocmVuZGVyVGFyZ2V0LnRleHR1cmUsIHRleHR1cmUubWFwcGluZyk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBpbWFnZSBub3QgeWV0IHJlYWR5LiB0cnkgdGhlIGNvbnZlcnNpb24gbmV4dCBmcmFtZVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRleHR1cmU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25UZXh0dXJlRGlzcG9zZShldmVudCkge1xuXHRcdFx0Y29uc3QgdGV4dHVyZSA9IGV2ZW50LnRhcmdldDtcblx0XHRcdHRleHR1cmUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UpO1xuXHRcdFx0Y29uc3QgY3ViZW1hcCA9IGN1YmVtYXBzLmdldCh0ZXh0dXJlKTtcblxuXHRcdFx0aWYgKGN1YmVtYXAgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjdWJlbWFwcy5kZWxldGUodGV4dHVyZSk7XG5cdFx0XHRcdGN1YmVtYXAuZGlzcG9zZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cdFx0XHRjdWJlbWFwcyA9IG5ldyBXZWFrTWFwKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGdldDogZ2V0LFxuXHRcdFx0ZGlzcG9zZTogZGlzcG9zZVxuXHRcdH07XG5cdH1cblxuXHRjbGFzcyBPcnRob2dyYXBoaWNDYW1lcmEgZXh0ZW5kcyBDYW1lcmEge1xuXHRcdGNvbnN0cnVjdG9yKGxlZnQgPSAtMSwgcmlnaHQgPSAxLCB0b3AgPSAxLCBib3R0b20gPSAtMSwgbmVhciA9IDAuMSwgZmFyID0gMjAwMCkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdPcnRob2dyYXBoaWNDYW1lcmEnO1xuXHRcdFx0dGhpcy56b29tID0gMTtcblx0XHRcdHRoaXMudmlldyA9IG51bGw7XG5cdFx0XHR0aGlzLmxlZnQgPSBsZWZ0O1xuXHRcdFx0dGhpcy5yaWdodCA9IHJpZ2h0O1xuXHRcdFx0dGhpcy50b3AgPSB0b3A7XG5cdFx0XHR0aGlzLmJvdHRvbSA9IGJvdHRvbTtcblx0XHRcdHRoaXMubmVhciA9IG5lYXI7XG5cdFx0XHR0aGlzLmZhciA9IGZhcjtcblx0XHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlLCByZWN1cnNpdmUpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlLCByZWN1cnNpdmUpO1xuXHRcdFx0dGhpcy5sZWZ0ID0gc291cmNlLmxlZnQ7XG5cdFx0XHR0aGlzLnJpZ2h0ID0gc291cmNlLnJpZ2h0O1xuXHRcdFx0dGhpcy50b3AgPSBzb3VyY2UudG9wO1xuXHRcdFx0dGhpcy5ib3R0b20gPSBzb3VyY2UuYm90dG9tO1xuXHRcdFx0dGhpcy5uZWFyID0gc291cmNlLm5lYXI7XG5cdFx0XHR0aGlzLmZhciA9IHNvdXJjZS5mYXI7XG5cdFx0XHR0aGlzLnpvb20gPSBzb3VyY2Uuem9vbTtcblx0XHRcdHRoaXMudmlldyA9IHNvdXJjZS52aWV3ID09PSBudWxsID8gbnVsbCA6IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZS52aWV3KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldFZpZXdPZmZzZXQoZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0XHRpZiAodGhpcy52aWV3ID09PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMudmlldyA9IHtcblx0XHRcdFx0XHRlbmFibGVkOiB0cnVlLFxuXHRcdFx0XHRcdGZ1bGxXaWR0aDogMSxcblx0XHRcdFx0XHRmdWxsSGVpZ2h0OiAxLFxuXHRcdFx0XHRcdG9mZnNldFg6IDAsXG5cdFx0XHRcdFx0b2Zmc2V0WTogMCxcblx0XHRcdFx0XHR3aWR0aDogMSxcblx0XHRcdFx0XHRoZWlnaHQ6IDFcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy52aWV3LmVuYWJsZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy52aWV3LmZ1bGxXaWR0aCA9IGZ1bGxXaWR0aDtcblx0XHRcdHRoaXMudmlldy5mdWxsSGVpZ2h0ID0gZnVsbEhlaWdodDtcblx0XHRcdHRoaXMudmlldy5vZmZzZXRYID0geDtcblx0XHRcdHRoaXMudmlldy5vZmZzZXRZID0geTtcblx0XHRcdHRoaXMudmlldy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0dGhpcy52aWV3LmhlaWdodCA9IGhlaWdodDtcblx0XHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXHRcdH1cblxuXHRcdGNsZWFyVmlld09mZnNldCgpIHtcblx0XHRcdGlmICh0aGlzLnZpZXcgIT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy52aWV3LmVuYWJsZWQgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0fVxuXG5cdFx0dXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpIHtcblx0XHRcdGNvbnN0IGR4ID0gKHRoaXMucmlnaHQgLSB0aGlzLmxlZnQpIC8gKDIgKiB0aGlzLnpvb20pO1xuXHRcdFx0Y29uc3QgZHkgPSAodGhpcy50b3AgLSB0aGlzLmJvdHRvbSkgLyAoMiAqIHRoaXMuem9vbSk7XG5cdFx0XHRjb25zdCBjeCA9ICh0aGlzLnJpZ2h0ICsgdGhpcy5sZWZ0KSAvIDI7XG5cdFx0XHRjb25zdCBjeSA9ICh0aGlzLnRvcCArIHRoaXMuYm90dG9tKSAvIDI7XG5cdFx0XHRsZXQgbGVmdCA9IGN4IC0gZHg7XG5cdFx0XHRsZXQgcmlnaHQgPSBjeCArIGR4O1xuXHRcdFx0bGV0IHRvcCA9IGN5ICsgZHk7XG5cdFx0XHRsZXQgYm90dG9tID0gY3kgLSBkeTtcblxuXHRcdFx0aWYgKHRoaXMudmlldyAhPT0gbnVsbCAmJiB0aGlzLnZpZXcuZW5hYmxlZCkge1xuXHRcdFx0XHRjb25zdCBzY2FsZVcgPSAodGhpcy5yaWdodCAtIHRoaXMubGVmdCkgLyB0aGlzLnZpZXcuZnVsbFdpZHRoIC8gdGhpcy56b29tO1xuXHRcdFx0XHRjb25zdCBzY2FsZUggPSAodGhpcy50b3AgLSB0aGlzLmJvdHRvbSkgLyB0aGlzLnZpZXcuZnVsbEhlaWdodCAvIHRoaXMuem9vbTtcblx0XHRcdFx0bGVmdCArPSBzY2FsZVcgKiB0aGlzLnZpZXcub2Zmc2V0WDtcblx0XHRcdFx0cmlnaHQgPSBsZWZ0ICsgc2NhbGVXICogdGhpcy52aWV3LndpZHRoO1xuXHRcdFx0XHR0b3AgLT0gc2NhbGVIICogdGhpcy52aWV3Lm9mZnNldFk7XG5cdFx0XHRcdGJvdHRvbSA9IHRvcCAtIHNjYWxlSCAqIHRoaXMudmlldy5oZWlnaHQ7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlT3J0aG9ncmFwaGljKGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG5cdFx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlLmNvcHkodGhpcy5wcm9qZWN0aW9uTWF0cml4KS5pbnZlcnQoKTtcblx0XHR9XG5cblx0XHR0b0pTT04obWV0YSkge1xuXHRcdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTihtZXRhKTtcblx0XHRcdGRhdGEub2JqZWN0Lnpvb20gPSB0aGlzLnpvb207XG5cdFx0XHRkYXRhLm9iamVjdC5sZWZ0ID0gdGhpcy5sZWZ0O1xuXHRcdFx0ZGF0YS5vYmplY3QucmlnaHQgPSB0aGlzLnJpZ2h0O1xuXHRcdFx0ZGF0YS5vYmplY3QudG9wID0gdGhpcy50b3A7XG5cdFx0XHRkYXRhLm9iamVjdC5ib3R0b20gPSB0aGlzLmJvdHRvbTtcblx0XHRcdGRhdGEub2JqZWN0Lm5lYXIgPSB0aGlzLm5lYXI7XG5cdFx0XHRkYXRhLm9iamVjdC5mYXIgPSB0aGlzLmZhcjtcblx0XHRcdGlmICh0aGlzLnZpZXcgIT09IG51bGwpIGRhdGEub2JqZWN0LnZpZXcgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnZpZXcpO1xuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdH1cblxuXHRPcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLmlzT3J0aG9ncmFwaGljQ2FtZXJhID0gdHJ1ZTtcblxuXHRjbGFzcyBSYXdTaGFkZXJNYXRlcmlhbCBleHRlbmRzIFNoYWRlck1hdGVyaWFsIHtcblx0XHRjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG5cdFx0XHRzdXBlcihwYXJhbWV0ZXJzKTtcblx0XHRcdHRoaXMudHlwZSA9ICdSYXdTaGFkZXJNYXRlcmlhbCc7XG5cdFx0fVxuXG5cdH1cblxuXHRSYXdTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuaXNSYXdTaGFkZXJNYXRlcmlhbCA9IHRydWU7XG5cblx0Y29uc3QgTE9EX01JTiA9IDQ7XG5cdGNvbnN0IExPRF9NQVggPSA4O1xuXHRjb25zdCBTSVpFX01BWCA9IE1hdGgucG93KDIsIExPRF9NQVgpOyAvLyBUaGUgc3RhbmRhcmQgZGV2aWF0aW9ucyAocmFkaWFucykgYXNzb2NpYXRlZCB3aXRoIHRoZSBleHRyYSBtaXBzLiBUaGVzZSBhcmVcblx0Ly8gY2hvc2VuIHRvIGFwcHJveGltYXRlIGEgVHJvd2JyaWRnZS1SZWl0eiBkaXN0cmlidXRpb24gZnVuY3Rpb24gdGltZXMgdGhlXG5cdC8vIGdlb21ldHJpYyBzaGFkb3dpbmcgZnVuY3Rpb24uIFRoZXNlIHNpZ21hIHZhbHVlcyBzcXVhcmVkIG11c3QgbWF0Y2ggdGhlXG5cdC8vIHZhcmlhbmNlICNkZWZpbmVzIGluIGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudC5nbHNsLmpzLlxuXG5cdGNvbnN0IEVYVFJBX0xPRF9TSUdNQSA9IFswLjEyNSwgMC4yMTUsIDAuMzUsIDAuNDQ2LCAwLjUyNiwgMC41ODJdO1xuXHRjb25zdCBUT1RBTF9MT0RTID0gTE9EX01BWCAtIExPRF9NSU4gKyAxICsgRVhUUkFfTE9EX1NJR01BLmxlbmd0aDsgLy8gVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBibHVyIGZvciBsb29wLiBTbWFsbGVyIHNpZ21hcyB3aWxsIHVzZSBmZXdlclxuXHQvLyBzYW1wbGVzIGFuZCBleGl0IGVhcmx5LCBidXQgbm90IHJlY29tcGlsZSB0aGUgc2hhZGVyLlxuXG5cdGNvbnN0IE1BWF9TQU1QTEVTID0gMjA7XG5cdGNvbnN0IEVOQ09ESU5HUyA9IHtcblx0XHRbTGluZWFyRW5jb2RpbmddOiAwLFxuXHRcdFtzUkdCRW5jb2RpbmddOiAxLFxuXHRcdFtSR0JFRW5jb2RpbmddOiAyLFxuXHRcdFtSR0JNN0VuY29kaW5nXTogMyxcblx0XHRbUkdCTTE2RW5jb2RpbmddOiA0LFxuXHRcdFtSR0JERW5jb2RpbmddOiA1LFxuXHRcdFtHYW1tYUVuY29kaW5nXTogNlxuXHR9O1xuXG5cdGNvbnN0IF9mbGF0Q2FtZXJhID0gLypAX19QVVJFX18qL25ldyBPcnRob2dyYXBoaWNDYW1lcmEoKTtcblxuXHRjb25zdCB7XG5cdFx0X2xvZFBsYW5lcyxcblx0XHRfc2l6ZUxvZHMsXG5cdFx0X3NpZ21hc1xuXHR9ID0gLypAX19QVVJFX18qL19jcmVhdGVQbGFuZXMoKTtcblxuXHRjb25zdCBfY2xlYXJDb2xvciA9IC8qQF9fUFVSRV9fKi9uZXcgQ29sb3IoKTtcblxuXHRsZXQgX29sZFRhcmdldCA9IG51bGw7IC8vIEdvbGRlbiBSYXRpb1xuXG5cdGNvbnN0IFBISSA9ICgxICsgTWF0aC5zcXJ0KDUpKSAvIDI7XG5cdGNvbnN0IElOVl9QSEkgPSAxIC8gUEhJOyAvLyBWZXJ0aWNlcyBvZiBhIGRvZGVjYWhlZHJvbiAoZXhjZXB0IHRoZSBvcHBvc2l0ZXMsIHdoaWNoIHJlcHJlc2VudCB0aGVcblx0Ly8gc2FtZSBheGlzKSwgdXNlZCBhcyBheGlzIGRpcmVjdGlvbnMgZXZlbmx5IHNwcmVhZCBvbiBhIHNwaGVyZS5cblxuXHRjb25zdCBfYXhpc0RpcmVjdGlvbnMgPSBbLypAX19QVVJFX18qL25ldyBWZWN0b3IzKDEsIDEsIDEpLCAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoLTEsIDEsIDEpLCAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoMSwgMSwgLTEpLCAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoLTEsIDEsIC0xKSwgLypAX19QVVJFX18qL25ldyBWZWN0b3IzKDAsIFBISSwgSU5WX1BISSksIC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygwLCBQSEksIC1JTlZfUEhJKSwgLypAX19QVVJFX18qL25ldyBWZWN0b3IzKElOVl9QSEksIDAsIFBISSksIC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygtSU5WX1BISSwgMCwgUEhJKSwgLypAX19QVVJFX18qL25ldyBWZWN0b3IzKFBISSwgSU5WX1BISSwgMCksIC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygtUEhJLCBJTlZfUEhJLCAwKV07XG5cdC8qKlxuXHQgKiBUaGlzIGNsYXNzIGdlbmVyYXRlcyBhIFByZWZpbHRlcmVkLCBNaXBtYXBwZWQgUmFkaWFuY2UgRW52aXJvbm1lbnQgTWFwXG5cdCAqIChQTVJFTSkgZnJvbSBhIGN1YmVNYXAgZW52aXJvbm1lbnQgdGV4dHVyZS4gVGhpcyBhbGxvd3MgZGlmZmVyZW50IGxldmVscyBvZlxuXHQgKiBibHVyIHRvIGJlIHF1aWNrbHkgYWNjZXNzZWQgYmFzZWQgb24gbWF0ZXJpYWwgcm91Z2huZXNzLiBJdCBpcyBwYWNrZWQgaW50byBhXG5cdCAqIHNwZWNpYWwgQ3ViZVVWIGZvcm1hdCB0aGF0IGFsbG93cyB1cyB0byBwZXJmb3JtIGN1c3RvbSBpbnRlcnBvbGF0aW9uIHNvIHRoYXRcblx0ICogd2UgY2FuIHN1cHBvcnQgbm9ubGluZWFyIGZvcm1hdHMgc3VjaCBhcyBSR0JFLiBVbmxpa2UgYSB0cmFkaXRpb25hbCBtaXBtYXBcblx0ICogY2hhaW4sIGl0IG9ubHkgZ29lcyBkb3duIHRvIHRoZSBMT0RfTUlOIGxldmVsIChhYm92ZSksIGFuZCB0aGVuIGNyZWF0ZXMgZXh0cmFcblx0ICogZXZlbiBtb3JlIGZpbHRlcmVkICdtaXBzJyBhdCB0aGUgc2FtZSBMT0RfTUlOIHJlc29sdXRpb24sIGFzc29jaWF0ZWQgd2l0aFxuXHQgKiBoaWdoZXIgcm91Z2huZXNzIGxldmVscy4gSW4gdGhpcyB3YXkgd2UgbWFpbnRhaW4gcmVzb2x1dGlvbiB0byBzbW9vdGhseVxuXHQgKiBpbnRlcnBvbGF0ZSBkaWZmdXNlIGxpZ2h0aW5nIHdoaWxlIGxpbWl0aW5nIHNhbXBsaW5nIGNvbXB1dGF0aW9uLlxuXHQgKlxuXHQgKiBQYXBlcjogRmFzdCwgQWNjdXJhdGUgSW1hZ2UtQmFzZWQgTGlnaHRpbmdcblx0ICogaHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xNXk4cl9VcEtsVTlTdlY0SUxiMEMzcUNQZWNTOHB2THovdmlld1xuXHQqL1xuXG5cdGNsYXNzIFBNUkVNR2VuZXJhdG9yIHtcblx0XHRjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcblx0XHRcdHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0ID0gbnVsbDtcblx0XHRcdHRoaXMuX2JsdXJNYXRlcmlhbCA9IF9nZXRCbHVyU2hhZGVyKE1BWF9TQU1QTEVTKTtcblx0XHRcdHRoaXMuX2VxdWlyZWN0U2hhZGVyID0gbnVsbDtcblx0XHRcdHRoaXMuX2N1YmVtYXBTaGFkZXIgPSBudWxsO1xuXG5cdFx0XHR0aGlzLl9jb21waWxlTWF0ZXJpYWwodGhpcy5fYmx1ck1hdGVyaWFsKTtcblx0XHR9XG5cdFx0LyoqXG5cdFx0ICogR2VuZXJhdGVzIGEgUE1SRU0gZnJvbSBhIHN1cHBsaWVkIFNjZW5lLCB3aGljaCBjYW4gYmUgZmFzdGVyIHRoYW4gdXNpbmcgYW5cblx0XHQgKiBpbWFnZSBpZiBuZXR3b3JraW5nIGJhbmR3aWR0aCBpcyBsb3cuIE9wdGlvbmFsIHNpZ21hIHNwZWNpZmllcyBhIGJsdXIgcmFkaXVzXG5cdFx0ICogaW4gcmFkaWFucyB0byBiZSBhcHBsaWVkIHRvIHRoZSBzY2VuZSBiZWZvcmUgUE1SRU0gZ2VuZXJhdGlvbi4gT3B0aW9uYWwgbmVhclxuXHRcdCAqIGFuZCBmYXIgcGxhbmVzIGVuc3VyZSB0aGUgc2NlbmUgaXMgcmVuZGVyZWQgaW4gaXRzIGVudGlyZXR5ICh0aGUgY3ViZUNhbWVyYVxuXHRcdCAqIGlzIHBsYWNlZCBhdCB0aGUgb3JpZ2luKS5cblx0XHQgKi9cblxuXG5cdFx0ZnJvbVNjZW5lKHNjZW5lLCBzaWdtYSA9IDAsIG5lYXIgPSAwLjEsIGZhciA9IDEwMCkge1xuXHRcdFx0X29sZFRhcmdldCA9IHRoaXMuX3JlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xuXG5cdFx0XHRjb25zdCBjdWJlVVZSZW5kZXJUYXJnZXQgPSB0aGlzLl9hbGxvY2F0ZVRhcmdldHMoKTtcblxuXHRcdFx0dGhpcy5fc2NlbmVUb0N1YmVVVihzY2VuZSwgbmVhciwgZmFyLCBjdWJlVVZSZW5kZXJUYXJnZXQpO1xuXG5cdFx0XHRpZiAoc2lnbWEgPiAwKSB7XG5cdFx0XHRcdHRoaXMuX2JsdXIoY3ViZVVWUmVuZGVyVGFyZ2V0LCAwLCAwLCBzaWdtYSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2FwcGx5UE1SRU0oY3ViZVVWUmVuZGVyVGFyZ2V0KTtcblxuXHRcdFx0dGhpcy5fY2xlYW51cChjdWJlVVZSZW5kZXJUYXJnZXQpO1xuXG5cdFx0XHRyZXR1cm4gY3ViZVVWUmVuZGVyVGFyZ2V0O1xuXHRcdH1cblx0XHQvKipcblx0XHQgKiBHZW5lcmF0ZXMgYSBQTVJFTSBmcm9tIGFuIGVxdWlyZWN0YW5ndWxhciB0ZXh0dXJlLCB3aGljaCBjYW4gYmUgZWl0aGVyIExEUlxuXHRcdCAqIChSR0JGb3JtYXQpIG9yIEhEUiAoUkdCRUZvcm1hdCkuIFRoZSBpZGVhbCBpbnB1dCBpbWFnZSBzaXplIGlzIDFrICgxMDI0IHggNTEyKSxcblx0XHQgKiBhcyB0aGlzIG1hdGNoZXMgYmVzdCB3aXRoIHRoZSAyNTYgeCAyNTYgY3ViZW1hcCBvdXRwdXQuXG5cdFx0ICovXG5cblxuXHRcdGZyb21FcXVpcmVjdGFuZ3VsYXIoZXF1aXJlY3Rhbmd1bGFyKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZnJvbVRleHR1cmUoZXF1aXJlY3Rhbmd1bGFyKTtcblx0XHR9XG5cdFx0LyoqXG5cdFx0ICogR2VuZXJhdGVzIGEgUE1SRU0gZnJvbSBhbiBjdWJlbWFwIHRleHR1cmUsIHdoaWNoIGNhbiBiZSBlaXRoZXIgTERSXG5cdFx0ICogKFJHQkZvcm1hdCkgb3IgSERSIChSR0JFRm9ybWF0KS4gVGhlIGlkZWFsIGlucHV0IGN1YmUgc2l6ZSBpcyAyNTYgeCAyNTYsXG5cdFx0ICogYXMgdGhpcyBtYXRjaGVzIGJlc3Qgd2l0aCB0aGUgMjU2IHggMjU2IGN1YmVtYXAgb3V0cHV0LlxuXHRcdCAqL1xuXG5cblx0XHRmcm9tQ3ViZW1hcChjdWJlbWFwKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZnJvbVRleHR1cmUoY3ViZW1hcCk7XG5cdFx0fVxuXHRcdC8qKlxuXHRcdCAqIFByZS1jb21waWxlcyB0aGUgY3ViZW1hcCBzaGFkZXIuIFlvdSBjYW4gZ2V0IGZhc3RlciBzdGFydC11cCBieSBpbnZva2luZyB0aGlzIG1ldGhvZCBkdXJpbmdcblx0XHQgKiB5b3VyIHRleHR1cmUncyBuZXR3b3JrIGZldGNoIGZvciBpbmNyZWFzZWQgY29uY3VycmVuY3kuXG5cdFx0ICovXG5cblxuXHRcdGNvbXBpbGVDdWJlbWFwU2hhZGVyKCkge1xuXHRcdFx0aWYgKHRoaXMuX2N1YmVtYXBTaGFkZXIgPT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5fY3ViZW1hcFNoYWRlciA9IF9nZXRDdWJlbWFwU2hhZGVyKCk7XG5cblx0XHRcdFx0dGhpcy5fY29tcGlsZU1hdGVyaWFsKHRoaXMuX2N1YmVtYXBTaGFkZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvKipcblx0XHQgKiBQcmUtY29tcGlsZXMgdGhlIGVxdWlyZWN0YW5ndWxhciBzaGFkZXIuIFlvdSBjYW4gZ2V0IGZhc3RlciBzdGFydC11cCBieSBpbnZva2luZyB0aGlzIG1ldGhvZCBkdXJpbmdcblx0XHQgKiB5b3VyIHRleHR1cmUncyBuZXR3b3JrIGZldGNoIGZvciBpbmNyZWFzZWQgY29uY3VycmVuY3kuXG5cdFx0ICovXG5cblxuXHRcdGNvbXBpbGVFcXVpcmVjdGFuZ3VsYXJTaGFkZXIoKSB7XG5cdFx0XHRpZiAodGhpcy5fZXF1aXJlY3RTaGFkZXIgPT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5fZXF1aXJlY3RTaGFkZXIgPSBfZ2V0RXF1aXJlY3RTaGFkZXIoKTtcblxuXHRcdFx0XHR0aGlzLl9jb21waWxlTWF0ZXJpYWwodGhpcy5fZXF1aXJlY3RTaGFkZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvKipcblx0XHQgKiBEaXNwb3NlcyBvZiB0aGUgUE1SRU1HZW5lcmF0b3IncyBpbnRlcm5hbCBtZW1vcnkuIE5vdGUgdGhhdCBQTVJFTUdlbmVyYXRvciBpcyBhIHN0YXRpYyBjbGFzcyxcblx0XHQgKiBzbyB5b3Ugc2hvdWxkIG5vdCBuZWVkIG1vcmUgdGhhbiBvbmUgUE1SRU1HZW5lcmF0b3Igb2JqZWN0LiBJZiB5b3UgZG8sIGNhbGxpbmcgZGlzcG9zZSgpIG9uXG5cdFx0ICogb25lIG9mIHRoZW0gd2lsbCBjYXVzZSBhbnkgb3RoZXJzIHRvIGFsc28gYmVjb21lIHVudXNhYmxlLlxuXHRcdCAqL1xuXG5cblx0XHRkaXNwb3NlKCkge1xuXHRcdFx0dGhpcy5fYmx1ck1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHRcdFx0aWYgKHRoaXMuX2N1YmVtYXBTaGFkZXIgIT09IG51bGwpIHRoaXMuX2N1YmVtYXBTaGFkZXIuZGlzcG9zZSgpO1xuXHRcdFx0aWYgKHRoaXMuX2VxdWlyZWN0U2hhZGVyICE9PSBudWxsKSB0aGlzLl9lcXVpcmVjdFNoYWRlci5kaXNwb3NlKCk7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgX2xvZFBsYW5lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRfbG9kUGxhbmVzW2ldLmRpc3Bvc2UoKTtcblx0XHRcdH1cblx0XHR9IC8vIHByaXZhdGUgaW50ZXJmYWNlXG5cblxuXHRcdF9jbGVhbnVwKG91dHB1dFRhcmdldCkge1xuXHRcdFx0dGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQuZGlzcG9zZSgpO1xuXG5cdFx0XHR0aGlzLl9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoX29sZFRhcmdldCk7XG5cblx0XHRcdG91dHB1dFRhcmdldC5zY2lzc29yVGVzdCA9IGZhbHNlO1xuXG5cdFx0XHRfc2V0Vmlld3BvcnQob3V0cHV0VGFyZ2V0LCAwLCAwLCBvdXRwdXRUYXJnZXQud2lkdGgsIG91dHB1dFRhcmdldC5oZWlnaHQpO1xuXHRcdH1cblxuXHRcdF9mcm9tVGV4dHVyZSh0ZXh0dXJlKSB7XG5cdFx0XHRfb2xkVGFyZ2V0ID0gdGhpcy5fcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cblx0XHRcdGNvbnN0IGN1YmVVVlJlbmRlclRhcmdldCA9IHRoaXMuX2FsbG9jYXRlVGFyZ2V0cyh0ZXh0dXJlKTtcblxuXHRcdFx0dGhpcy5fdGV4dHVyZVRvQ3ViZVVWKHRleHR1cmUsIGN1YmVVVlJlbmRlclRhcmdldCk7XG5cblx0XHRcdHRoaXMuX2FwcGx5UE1SRU0oY3ViZVVWUmVuZGVyVGFyZ2V0KTtcblxuXHRcdFx0dGhpcy5fY2xlYW51cChjdWJlVVZSZW5kZXJUYXJnZXQpO1xuXG5cdFx0XHRyZXR1cm4gY3ViZVVWUmVuZGVyVGFyZ2V0O1xuXHRcdH1cblxuXHRcdF9hbGxvY2F0ZVRhcmdldHModGV4dHVyZSkge1xuXHRcdFx0Ly8gd2FybmluZzogbnVsbCB0ZXh0dXJlIGlzIHZhbGlkXG5cdFx0XHRjb25zdCBwYXJhbXMgPSB7XG5cdFx0XHRcdG1hZ0ZpbHRlcjogTmVhcmVzdEZpbHRlcixcblx0XHRcdFx0bWluRmlsdGVyOiBOZWFyZXN0RmlsdGVyLFxuXHRcdFx0XHRnZW5lcmF0ZU1pcG1hcHM6IGZhbHNlLFxuXHRcdFx0XHR0eXBlOiBVbnNpZ25lZEJ5dGVUeXBlLFxuXHRcdFx0XHRmb3JtYXQ6IFJHQkVGb3JtYXQsXG5cdFx0XHRcdGVuY29kaW5nOiBfaXNMRFIodGV4dHVyZSkgPyB0ZXh0dXJlLmVuY29kaW5nIDogUkdCRUVuY29kaW5nLFxuXHRcdFx0XHRkZXB0aEJ1ZmZlcjogZmFsc2Vcblx0XHRcdH07XG5cblx0XHRcdGNvbnN0IGN1YmVVVlJlbmRlclRhcmdldCA9IF9jcmVhdGVSZW5kZXJUYXJnZXQocGFyYW1zKTtcblxuXHRcdFx0Y3ViZVVWUmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyID0gdGV4dHVyZSA/IGZhbHNlIDogdHJ1ZTtcblx0XHRcdHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0ID0gX2NyZWF0ZVJlbmRlclRhcmdldChwYXJhbXMpO1xuXHRcdFx0cmV0dXJuIGN1YmVVVlJlbmRlclRhcmdldDtcblx0XHR9XG5cblx0XHRfY29tcGlsZU1hdGVyaWFsKG1hdGVyaWFsKSB7XG5cdFx0XHRjb25zdCB0bXBNZXNoID0gbmV3IE1lc2goX2xvZFBsYW5lc1swXSwgbWF0ZXJpYWwpO1xuXG5cdFx0XHR0aGlzLl9yZW5kZXJlci5jb21waWxlKHRtcE1lc2gsIF9mbGF0Q2FtZXJhKTtcblx0XHR9XG5cblx0XHRfc2NlbmVUb0N1YmVVVihzY2VuZSwgbmVhciwgZmFyLCBjdWJlVVZSZW5kZXJUYXJnZXQpIHtcblx0XHRcdGNvbnN0IGZvdiA9IDkwO1xuXHRcdFx0Y29uc3QgYXNwZWN0ID0gMTtcblx0XHRcdGNvbnN0IGN1YmVDYW1lcmEgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoZm92LCBhc3BlY3QsIG5lYXIsIGZhcik7XG5cdFx0XHRjb25zdCB1cFNpZ24gPSBbMSwgLTEsIDEsIDEsIDEsIDFdO1xuXHRcdFx0Y29uc3QgZm9yd2FyZFNpZ24gPSBbMSwgMSwgMSwgLTEsIC0xLCAtMV07XG5cdFx0XHRjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuXHRcdFx0Y29uc3Qgb3JpZ2luYWxBdXRvQ2xlYXIgPSByZW5kZXJlci5hdXRvQ2xlYXI7XG5cdFx0XHRjb25zdCBvdXRwdXRFbmNvZGluZyA9IHJlbmRlcmVyLm91dHB1dEVuY29kaW5nO1xuXHRcdFx0Y29uc3QgdG9uZU1hcHBpbmcgPSByZW5kZXJlci50b25lTWFwcGluZztcblx0XHRcdHJlbmRlcmVyLmdldENsZWFyQ29sb3IoX2NsZWFyQ29sb3IpO1xuXHRcdFx0cmVuZGVyZXIudG9uZU1hcHBpbmcgPSBOb1RvbmVNYXBwaW5nO1xuXHRcdFx0cmVuZGVyZXIub3V0cHV0RW5jb2RpbmcgPSBMaW5lYXJFbmNvZGluZztcblx0XHRcdHJlbmRlcmVyLmF1dG9DbGVhciA9IGZhbHNlO1xuXHRcdFx0Y29uc3QgYmFja2dyb3VuZE1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKHtcblx0XHRcdFx0bmFtZTogJ1BNUkVNLkJhY2tncm91bmQnLFxuXHRcdFx0XHRzaWRlOiBCYWNrU2lkZSxcblx0XHRcdFx0ZGVwdGhXcml0ZTogZmFsc2UsXG5cdFx0XHRcdGRlcHRoVGVzdDogZmFsc2Vcblx0XHRcdH0pO1xuXHRcdFx0Y29uc3QgYmFja2dyb3VuZEJveCA9IG5ldyBNZXNoKG5ldyBCb3hHZW9tZXRyeSgpLCBiYWNrZ3JvdW5kTWF0ZXJpYWwpO1xuXHRcdFx0bGV0IHVzZVNvbGlkQ29sb3IgPSBmYWxzZTtcblx0XHRcdGNvbnN0IGJhY2tncm91bmQgPSBzY2VuZS5iYWNrZ3JvdW5kO1xuXG5cdFx0XHRpZiAoYmFja2dyb3VuZCkge1xuXHRcdFx0XHRpZiAoYmFja2dyb3VuZC5pc0NvbG9yKSB7XG5cdFx0XHRcdFx0YmFja2dyb3VuZE1hdGVyaWFsLmNvbG9yLmNvcHkoYmFja2dyb3VuZCk7XG5cdFx0XHRcdFx0c2NlbmUuYmFja2dyb3VuZCA9IG51bGw7XG5cdFx0XHRcdFx0dXNlU29saWRDb2xvciA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJhY2tncm91bmRNYXRlcmlhbC5jb2xvci5jb3B5KF9jbGVhckNvbG9yKTtcblx0XHRcdFx0dXNlU29saWRDb2xvciA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGNvbCA9IGkgJSAzO1xuXG5cdFx0XHRcdGlmIChjb2wgPT0gMCkge1xuXHRcdFx0XHRcdGN1YmVDYW1lcmEudXAuc2V0KDAsIHVwU2lnbltpXSwgMCk7XG5cdFx0XHRcdFx0Y3ViZUNhbWVyYS5sb29rQXQoZm9yd2FyZFNpZ25baV0sIDAsIDApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNvbCA9PSAxKSB7XG5cdFx0XHRcdFx0Y3ViZUNhbWVyYS51cC5zZXQoMCwgMCwgdXBTaWduW2ldKTtcblx0XHRcdFx0XHRjdWJlQ2FtZXJhLmxvb2tBdCgwLCBmb3J3YXJkU2lnbltpXSwgMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y3ViZUNhbWVyYS51cC5zZXQoMCwgdXBTaWduW2ldLCAwKTtcblx0XHRcdFx0XHRjdWJlQ2FtZXJhLmxvb2tBdCgwLCAwLCBmb3J3YXJkU2lnbltpXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfc2V0Vmlld3BvcnQoY3ViZVVWUmVuZGVyVGFyZ2V0LCBjb2wgKiBTSVpFX01BWCwgaSA+IDIgPyBTSVpFX01BWCA6IDAsIFNJWkVfTUFYLCBTSVpFX01BWCk7XG5cblx0XHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KGN1YmVVVlJlbmRlclRhcmdldCk7XG5cblx0XHRcdFx0aWYgKHVzZVNvbGlkQ29sb3IpIHtcblx0XHRcdFx0XHRyZW5kZXJlci5yZW5kZXIoYmFja2dyb3VuZEJveCwgY3ViZUNhbWVyYSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZW5kZXJlci5yZW5kZXIoc2NlbmUsIGN1YmVDYW1lcmEpO1xuXHRcdFx0fVxuXG5cdFx0XHRiYWNrZ3JvdW5kQm94Lmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHRcdGJhY2tncm91bmRCb3gubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHRcdFx0cmVuZGVyZXIudG9uZU1hcHBpbmcgPSB0b25lTWFwcGluZztcblx0XHRcdHJlbmRlcmVyLm91dHB1dEVuY29kaW5nID0gb3V0cHV0RW5jb2Rpbmc7XG5cdFx0XHRyZW5kZXJlci5hdXRvQ2xlYXIgPSBvcmlnaW5hbEF1dG9DbGVhcjtcblx0XHRcdHNjZW5lLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuXHRcdH1cblxuXHRcdF9zZXRFbmNvZGluZyh1bmlmb3JtLCB0ZXh0dXJlKSB7XG5cdFx0XHQvKiBpZiAoIHRoaXMuX3JlbmRlcmVyLmNhcGFiaWxpdGllcy5pc1dlYkdMMiA9PT0gdHJ1ZSAmJiB0ZXh0dXJlLmZvcm1hdCA9PT0gUkdCQUZvcm1hdCAmJiB0ZXh0dXJlLnR5cGUgPT09IFVuc2lnbmVkQnl0ZVR5cGUgJiYgdGV4dHVyZS5lbmNvZGluZyA9PT0gc1JHQkVuY29kaW5nICkge1xuXHRcdFx0XHRcdHVuaWZvcm0udmFsdWUgPSBFTkNPRElOR1NbIExpbmVhckVuY29kaW5nIF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dW5pZm9ybS52YWx1ZSA9IEVOQ09ESU5HU1sgdGV4dHVyZS5lbmNvZGluZyBdO1xuXHRcdFx0XHR9ICovXG5cdFx0XHR1bmlmb3JtLnZhbHVlID0gRU5DT0RJTkdTW3RleHR1cmUuZW5jb2RpbmddO1xuXHRcdH1cblxuXHRcdF90ZXh0dXJlVG9DdWJlVVYodGV4dHVyZSwgY3ViZVVWUmVuZGVyVGFyZ2V0KSB7XG5cdFx0XHRjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuXHRcdFx0Y29uc3QgaXNDdWJlVGV4dHVyZSA9IHRleHR1cmUubWFwcGluZyA9PT0gQ3ViZVJlZmxlY3Rpb25NYXBwaW5nIHx8IHRleHR1cmUubWFwcGluZyA9PT0gQ3ViZVJlZnJhY3Rpb25NYXBwaW5nO1xuXG5cdFx0XHRpZiAoaXNDdWJlVGV4dHVyZSkge1xuXHRcdFx0XHRpZiAodGhpcy5fY3ViZW1hcFNoYWRlciA9PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5fY3ViZW1hcFNoYWRlciA9IF9nZXRDdWJlbWFwU2hhZGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aGlzLl9lcXVpcmVjdFNoYWRlciA9PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5fZXF1aXJlY3RTaGFkZXIgPSBfZ2V0RXF1aXJlY3RTaGFkZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtYXRlcmlhbCA9IGlzQ3ViZVRleHR1cmUgPyB0aGlzLl9jdWJlbWFwU2hhZGVyIDogdGhpcy5fZXF1aXJlY3RTaGFkZXI7XG5cdFx0XHRjb25zdCBtZXNoID0gbmV3IE1lc2goX2xvZFBsYW5lc1swXSwgbWF0ZXJpYWwpO1xuXHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBtYXRlcmlhbC51bmlmb3Jtcztcblx0XHRcdHVuaWZvcm1zWydlbnZNYXAnXS52YWx1ZSA9IHRleHR1cmU7XG5cblx0XHRcdGlmICghaXNDdWJlVGV4dHVyZSkge1xuXHRcdFx0XHR1bmlmb3Jtc1sndGV4ZWxTaXplJ10udmFsdWUuc2V0KDEuMCAvIHRleHR1cmUuaW1hZ2Uud2lkdGgsIDEuMCAvIHRleHR1cmUuaW1hZ2UuaGVpZ2h0KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc2V0RW5jb2RpbmcodW5pZm9ybXNbJ2lucHV0RW5jb2RpbmcnXSwgdGV4dHVyZSk7XG5cblx0XHRcdHRoaXMuX3NldEVuY29kaW5nKHVuaWZvcm1zWydvdXRwdXRFbmNvZGluZyddLCBjdWJlVVZSZW5kZXJUYXJnZXQudGV4dHVyZSk7XG5cblx0XHRcdF9zZXRWaWV3cG9ydChjdWJlVVZSZW5kZXJUYXJnZXQsIDAsIDAsIDMgKiBTSVpFX01BWCwgMiAqIFNJWkVfTUFYKTtcblxuXHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KGN1YmVVVlJlbmRlclRhcmdldCk7XG5cdFx0XHRyZW5kZXJlci5yZW5kZXIobWVzaCwgX2ZsYXRDYW1lcmEpO1xuXHRcdH1cblxuXHRcdF9hcHBseVBNUkVNKGN1YmVVVlJlbmRlclRhcmdldCkge1xuXHRcdFx0Y29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcblx0XHRcdGNvbnN0IGF1dG9DbGVhciA9IHJlbmRlcmVyLmF1dG9DbGVhcjtcblx0XHRcdHJlbmRlcmVyLmF1dG9DbGVhciA9IGZhbHNlO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IFRPVEFMX0xPRFM7IGkrKykge1xuXHRcdFx0XHRjb25zdCBzaWdtYSA9IE1hdGguc3FydChfc2lnbWFzW2ldICogX3NpZ21hc1tpXSAtIF9zaWdtYXNbaSAtIDFdICogX3NpZ21hc1tpIC0gMV0pO1xuXHRcdFx0XHRjb25zdCBwb2xlQXhpcyA9IF9heGlzRGlyZWN0aW9uc1soaSAtIDEpICUgX2F4aXNEaXJlY3Rpb25zLmxlbmd0aF07XG5cblx0XHRcdFx0dGhpcy5fYmx1cihjdWJlVVZSZW5kZXJUYXJnZXQsIGkgLSAxLCBpLCBzaWdtYSwgcG9sZUF4aXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZW5kZXJlci5hdXRvQ2xlYXIgPSBhdXRvQ2xlYXI7XG5cdFx0fVxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgaXMgYSB0d28tcGFzcyBHYXVzc2lhbiBibHVyIGZvciBhIGN1YmVtYXAuIE5vcm1hbGx5IHRoaXMgaXMgZG9uZVxuXHRcdCAqIHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseSwgYnV0IHRoaXMgYnJlYWtzIGRvd24gb24gYSBjdWJlLiBIZXJlIHdlIGFwcGx5XG5cdFx0ICogdGhlIGJsdXIgbGF0aXR1ZGluYWxseSAoYXJvdW5kIHRoZSBwb2xlcyksIGFuZCB0aGVuIGxvbmdpdHVkaW5hbGx5ICh0b3dhcmRzXG5cdFx0ICogdGhlIHBvbGVzKSB0byBhcHByb3hpbWF0ZSB0aGUgb3J0aG9nb25hbGx5LXNlcGFyYWJsZSBibHVyLiBJdCBpcyBsZWFzdFxuXHRcdCAqIGFjY3VyYXRlIGF0IHRoZSBwb2xlcywgYnV0IHN0aWxsIGRvZXMgYSBkZWNlbnQgam9iLlxuXHRcdCAqL1xuXG5cblx0XHRfYmx1cihjdWJlVVZSZW5kZXJUYXJnZXQsIGxvZEluLCBsb2RPdXQsIHNpZ21hLCBwb2xlQXhpcykge1xuXHRcdFx0Y29uc3QgcGluZ1BvbmdSZW5kZXJUYXJnZXQgPSB0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldDtcblxuXHRcdFx0dGhpcy5faGFsZkJsdXIoY3ViZVVWUmVuZGVyVGFyZ2V0LCBwaW5nUG9uZ1JlbmRlclRhcmdldCwgbG9kSW4sIGxvZE91dCwgc2lnbWEsICdsYXRpdHVkaW5hbCcsIHBvbGVBeGlzKTtcblxuXHRcdFx0dGhpcy5faGFsZkJsdXIocGluZ1BvbmdSZW5kZXJUYXJnZXQsIGN1YmVVVlJlbmRlclRhcmdldCwgbG9kT3V0LCBsb2RPdXQsIHNpZ21hLCAnbG9uZ2l0dWRpbmFsJywgcG9sZUF4aXMpO1xuXHRcdH1cblxuXHRcdF9oYWxmQmx1cih0YXJnZXRJbiwgdGFyZ2V0T3V0LCBsb2RJbiwgbG9kT3V0LCBzaWdtYVJhZGlhbnMsIGRpcmVjdGlvbiwgcG9sZUF4aXMpIHtcblx0XHRcdGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG5cdFx0XHRjb25zdCBibHVyTWF0ZXJpYWwgPSB0aGlzLl9ibHVyTWF0ZXJpYWw7XG5cblx0XHRcdGlmIChkaXJlY3Rpb24gIT09ICdsYXRpdHVkaW5hbCcgJiYgZGlyZWN0aW9uICE9PSAnbG9uZ2l0dWRpbmFsJykge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdibHVyIGRpcmVjdGlvbiBtdXN0IGJlIGVpdGhlciBsYXRpdHVkaW5hbCBvciBsb25naXR1ZGluYWwhJyk7XG5cdFx0XHR9IC8vIE51bWJlciBvZiBzdGFuZGFyZCBkZXZpYXRpb25zIGF0IHdoaWNoIHRvIGN1dCBvZmYgdGhlIGRpc2NyZXRlIGFwcHJveGltYXRpb24uXG5cblxuXHRcdFx0Y29uc3QgU1RBTkRBUkRfREVWSUFUSU9OUyA9IDM7XG5cdFx0XHRjb25zdCBibHVyTWVzaCA9IG5ldyBNZXNoKF9sb2RQbGFuZXNbbG9kT3V0XSwgYmx1ck1hdGVyaWFsKTtcblx0XHRcdGNvbnN0IGJsdXJVbmlmb3JtcyA9IGJsdXJNYXRlcmlhbC51bmlmb3Jtcztcblx0XHRcdGNvbnN0IHBpeGVscyA9IF9zaXplTG9kc1tsb2RJbl0gLSAxO1xuXHRcdFx0Y29uc3QgcmFkaWFuc1BlclBpeGVsID0gaXNGaW5pdGUoc2lnbWFSYWRpYW5zKSA/IE1hdGguUEkgLyAoMiAqIHBpeGVscykgOiAyICogTWF0aC5QSSAvICgyICogTUFYX1NBTVBMRVMgLSAxKTtcblx0XHRcdGNvbnN0IHNpZ21hUGl4ZWxzID0gc2lnbWFSYWRpYW5zIC8gcmFkaWFuc1BlclBpeGVsO1xuXHRcdFx0Y29uc3Qgc2FtcGxlcyA9IGlzRmluaXRlKHNpZ21hUmFkaWFucykgPyAxICsgTWF0aC5mbG9vcihTVEFOREFSRF9ERVZJQVRJT05TICogc2lnbWFQaXhlbHMpIDogTUFYX1NBTVBMRVM7XG5cblx0XHRcdGlmIChzYW1wbGVzID4gTUFYX1NBTVBMRVMpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKGBzaWdtYVJhZGlhbnMsICR7c2lnbWFSYWRpYW5zfSwgaXMgdG9vIGxhcmdlIGFuZCB3aWxsIGNsaXAsIGFzIGl0IHJlcXVlc3RlZCAke3NhbXBsZXN9IHNhbXBsZXMgd2hlbiB0aGUgbWF4aW11bSBpcyBzZXQgdG8gJHtNQVhfU0FNUExFU31gKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgd2VpZ2h0cyA9IFtdO1xuXHRcdFx0bGV0IHN1bSA9IDA7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgTUFYX1NBTVBMRVM7ICsraSkge1xuXHRcdFx0XHRjb25zdCB4ID0gaSAvIHNpZ21hUGl4ZWxzO1xuXHRcdFx0XHRjb25zdCB3ZWlnaHQgPSBNYXRoLmV4cCgteCAqIHggLyAyKTtcblx0XHRcdFx0d2VpZ2h0cy5wdXNoKHdlaWdodCk7XG5cblx0XHRcdFx0aWYgKGkgPT0gMCkge1xuXHRcdFx0XHRcdHN1bSArPSB3ZWlnaHQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaSA8IHNhbXBsZXMpIHtcblx0XHRcdFx0XHRzdW0gKz0gMiAqIHdlaWdodDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHdlaWdodHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0d2VpZ2h0c1tpXSA9IHdlaWdodHNbaV0gLyBzdW07XG5cdFx0XHR9XG5cblx0XHRcdGJsdXJVbmlmb3Jtc1snZW52TWFwJ10udmFsdWUgPSB0YXJnZXRJbi50ZXh0dXJlO1xuXHRcdFx0Ymx1clVuaWZvcm1zWydzYW1wbGVzJ10udmFsdWUgPSBzYW1wbGVzO1xuXHRcdFx0Ymx1clVuaWZvcm1zWyd3ZWlnaHRzJ10udmFsdWUgPSB3ZWlnaHRzO1xuXHRcdFx0Ymx1clVuaWZvcm1zWydsYXRpdHVkaW5hbCddLnZhbHVlID0gZGlyZWN0aW9uID09PSAnbGF0aXR1ZGluYWwnO1xuXG5cdFx0XHRpZiAocG9sZUF4aXMpIHtcblx0XHRcdFx0Ymx1clVuaWZvcm1zWydwb2xlQXhpcyddLnZhbHVlID0gcG9sZUF4aXM7XG5cdFx0XHR9XG5cblx0XHRcdGJsdXJVbmlmb3Jtc1snZFRoZXRhJ10udmFsdWUgPSByYWRpYW5zUGVyUGl4ZWw7XG5cdFx0XHRibHVyVW5pZm9ybXNbJ21pcEludCddLnZhbHVlID0gTE9EX01BWCAtIGxvZEluO1xuXG5cdFx0XHR0aGlzLl9zZXRFbmNvZGluZyhibHVyVW5pZm9ybXNbJ2lucHV0RW5jb2RpbmcnXSwgdGFyZ2V0SW4udGV4dHVyZSk7XG5cblx0XHRcdHRoaXMuX3NldEVuY29kaW5nKGJsdXJVbmlmb3Jtc1snb3V0cHV0RW5jb2RpbmcnXSwgdGFyZ2V0SW4udGV4dHVyZSk7XG5cblx0XHRcdGNvbnN0IG91dHB1dFNpemUgPSBfc2l6ZUxvZHNbbG9kT3V0XTtcblx0XHRcdGNvbnN0IHggPSAzICogTWF0aC5tYXgoMCwgU0laRV9NQVggLSAyICogb3V0cHV0U2l6ZSk7XG5cdFx0XHRjb25zdCB5ID0gKGxvZE91dCA9PT0gMCA/IDAgOiAyICogU0laRV9NQVgpICsgMiAqIG91dHB1dFNpemUgKiAobG9kT3V0ID4gTE9EX01BWCAtIExPRF9NSU4gPyBsb2RPdXQgLSBMT0RfTUFYICsgTE9EX01JTiA6IDApO1xuXG5cdFx0XHRfc2V0Vmlld3BvcnQodGFyZ2V0T3V0LCB4LCB5LCAzICogb3V0cHV0U2l6ZSwgMiAqIG91dHB1dFNpemUpO1xuXG5cdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGFyZ2V0T3V0KTtcblx0XHRcdHJlbmRlcmVyLnJlbmRlcihibHVyTWVzaCwgX2ZsYXRDYW1lcmEpO1xuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gX2lzTERSKHRleHR1cmUpIHtcblx0XHRpZiAodGV4dHVyZSA9PT0gdW5kZWZpbmVkIHx8IHRleHR1cmUudHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZSkgcmV0dXJuIGZhbHNlO1xuXHRcdHJldHVybiB0ZXh0dXJlLmVuY29kaW5nID09PSBMaW5lYXJFbmNvZGluZyB8fCB0ZXh0dXJlLmVuY29kaW5nID09PSBzUkdCRW5jb2RpbmcgfHwgdGV4dHVyZS5lbmNvZGluZyA9PT0gR2FtbWFFbmNvZGluZztcblx0fVxuXG5cdGZ1bmN0aW9uIF9jcmVhdGVQbGFuZXMoKSB7XG5cdFx0Y29uc3QgX2xvZFBsYW5lcyA9IFtdO1xuXHRcdGNvbnN0IF9zaXplTG9kcyA9IFtdO1xuXHRcdGNvbnN0IF9zaWdtYXMgPSBbXTtcblx0XHRsZXQgbG9kID0gTE9EX01BWDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgVE9UQUxfTE9EUzsgaSsrKSB7XG5cdFx0XHRjb25zdCBzaXplTG9kID0gTWF0aC5wb3coMiwgbG9kKTtcblxuXHRcdFx0X3NpemVMb2RzLnB1c2goc2l6ZUxvZCk7XG5cblx0XHRcdGxldCBzaWdtYSA9IDEuMCAvIHNpemVMb2Q7XG5cblx0XHRcdGlmIChpID4gTE9EX01BWCAtIExPRF9NSU4pIHtcblx0XHRcdFx0c2lnbWEgPSBFWFRSQV9MT0RfU0lHTUFbaSAtIExPRF9NQVggKyBMT0RfTUlOIC0gMV07XG5cdFx0XHR9IGVsc2UgaWYgKGkgPT0gMCkge1xuXHRcdFx0XHRzaWdtYSA9IDA7XG5cdFx0XHR9XG5cblx0XHRcdF9zaWdtYXMucHVzaChzaWdtYSk7XG5cblx0XHRcdGNvbnN0IHRleGVsU2l6ZSA9IDEuMCAvIChzaXplTG9kIC0gMSk7XG5cdFx0XHRjb25zdCBtaW4gPSAtdGV4ZWxTaXplIC8gMjtcblx0XHRcdGNvbnN0IG1heCA9IDEgKyB0ZXhlbFNpemUgLyAyO1xuXHRcdFx0Y29uc3QgdXYxID0gW21pbiwgbWluLCBtYXgsIG1pbiwgbWF4LCBtYXgsIG1pbiwgbWluLCBtYXgsIG1heCwgbWluLCBtYXhdO1xuXHRcdFx0Y29uc3QgY3ViZUZhY2VzID0gNjtcblx0XHRcdGNvbnN0IHZlcnRpY2VzID0gNjtcblx0XHRcdGNvbnN0IHBvc2l0aW9uU2l6ZSA9IDM7XG5cdFx0XHRjb25zdCB1dlNpemUgPSAyO1xuXHRcdFx0Y29uc3QgZmFjZUluZGV4U2l6ZSA9IDE7XG5cdFx0XHRjb25zdCBwb3NpdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25TaXplICogdmVydGljZXMgKiBjdWJlRmFjZXMpO1xuXHRcdFx0Y29uc3QgdXYgPSBuZXcgRmxvYXQzMkFycmF5KHV2U2l6ZSAqIHZlcnRpY2VzICogY3ViZUZhY2VzKTtcblx0XHRcdGNvbnN0IGZhY2VJbmRleCA9IG5ldyBGbG9hdDMyQXJyYXkoZmFjZUluZGV4U2l6ZSAqIHZlcnRpY2VzICogY3ViZUZhY2VzKTtcblxuXHRcdFx0Zm9yIChsZXQgZmFjZSA9IDA7IGZhY2UgPCBjdWJlRmFjZXM7IGZhY2UrKykge1xuXHRcdFx0XHRjb25zdCB4ID0gZmFjZSAlIDMgKiAyIC8gMyAtIDE7XG5cdFx0XHRcdGNvbnN0IHkgPSBmYWNlID4gMiA/IDAgOiAtMTtcblx0XHRcdFx0Y29uc3QgY29vcmRpbmF0ZXMgPSBbeCwgeSwgMCwgeCArIDIgLyAzLCB5LCAwLCB4ICsgMiAvIDMsIHkgKyAxLCAwLCB4LCB5LCAwLCB4ICsgMiAvIDMsIHkgKyAxLCAwLCB4LCB5ICsgMSwgMF07XG5cdFx0XHRcdHBvc2l0aW9uLnNldChjb29yZGluYXRlcywgcG9zaXRpb25TaXplICogdmVydGljZXMgKiBmYWNlKTtcblx0XHRcdFx0dXYuc2V0KHV2MSwgdXZTaXplICogdmVydGljZXMgKiBmYWNlKTtcblx0XHRcdFx0Y29uc3QgZmlsbCA9IFtmYWNlLCBmYWNlLCBmYWNlLCBmYWNlLCBmYWNlLCBmYWNlXTtcblx0XHRcdFx0ZmFjZUluZGV4LnNldChmaWxsLCBmYWNlSW5kZXhTaXplICogdmVydGljZXMgKiBmYWNlKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcGxhbmVzID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHRwbGFuZXMuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUocG9zaXRpb24sIHBvc2l0aW9uU2l6ZSkpO1xuXHRcdFx0cGxhbmVzLnNldEF0dHJpYnV0ZSgndXYnLCBuZXcgQnVmZmVyQXR0cmlidXRlKHV2LCB1dlNpemUpKTtcblx0XHRcdHBsYW5lcy5zZXRBdHRyaWJ1dGUoJ2ZhY2VJbmRleCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoZmFjZUluZGV4LCBmYWNlSW5kZXhTaXplKSk7XG5cblx0XHRcdF9sb2RQbGFuZXMucHVzaChwbGFuZXMpO1xuXG5cdFx0XHRpZiAobG9kID4gTE9EX01JTikge1xuXHRcdFx0XHRsb2QtLTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0X2xvZFBsYW5lcyxcblx0XHRcdF9zaXplTG9kcyxcblx0XHRcdF9zaWdtYXNcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gX2NyZWF0ZVJlbmRlclRhcmdldChwYXJhbXMpIHtcblx0XHRjb25zdCBjdWJlVVZSZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQoMyAqIFNJWkVfTUFYLCAzICogU0laRV9NQVgsIHBhcmFtcyk7XG5cdFx0Y3ViZVVWUmVuZGVyVGFyZ2V0LnRleHR1cmUubWFwcGluZyA9IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nO1xuXHRcdGN1YmVVVlJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSAnUE1SRU0uY3ViZVV2Jztcblx0XHRjdWJlVVZSZW5kZXJUYXJnZXQuc2Npc3NvclRlc3QgPSB0cnVlO1xuXHRcdHJldHVybiBjdWJlVVZSZW5kZXJUYXJnZXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBfc2V0Vmlld3BvcnQodGFyZ2V0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dGFyZ2V0LnZpZXdwb3J0LnNldCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblx0XHR0YXJnZXQuc2Npc3Nvci5zZXQoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cdH1cblxuXHRmdW5jdGlvbiBfZ2V0Qmx1clNoYWRlcihtYXhTYW1wbGVzKSB7XG5cdFx0Y29uc3Qgd2VpZ2h0cyA9IG5ldyBGbG9hdDMyQXJyYXkobWF4U2FtcGxlcyk7XG5cdFx0Y29uc3QgcG9sZUF4aXMgPSBuZXcgVmVjdG9yMygwLCAxLCAwKTtcblx0XHRjb25zdCBzaGFkZXJNYXRlcmlhbCA9IG5ldyBSYXdTaGFkZXJNYXRlcmlhbCh7XG5cdFx0XHRuYW1lOiAnU3BoZXJpY2FsR2F1c3NpYW5CbHVyJyxcblx0XHRcdGRlZmluZXM6IHtcblx0XHRcdFx0J24nOiBtYXhTYW1wbGVzXG5cdFx0XHR9LFxuXHRcdFx0dW5pZm9ybXM6IHtcblx0XHRcdFx0J2Vudk1hcCc6IHtcblx0XHRcdFx0XHR2YWx1ZTogbnVsbFxuXHRcdFx0XHR9LFxuXHRcdFx0XHQnc2FtcGxlcyc6IHtcblx0XHRcdFx0XHR2YWx1ZTogMVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQnd2VpZ2h0cyc6IHtcblx0XHRcdFx0XHR2YWx1ZTogd2VpZ2h0c1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQnbGF0aXR1ZGluYWwnOiB7XG5cdFx0XHRcdFx0dmFsdWU6IGZhbHNlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCdkVGhldGEnOiB7XG5cdFx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdFx0fSxcblx0XHRcdFx0J21pcEludCc6IHtcblx0XHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0XHR9LFxuXHRcdFx0XHQncG9sZUF4aXMnOiB7XG5cdFx0XHRcdFx0dmFsdWU6IHBvbGVBeGlzXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCdpbnB1dEVuY29kaW5nJzoge1xuXHRcdFx0XHRcdHZhbHVlOiBFTkNPRElOR1NbTGluZWFyRW5jb2RpbmddXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCdvdXRwdXRFbmNvZGluZyc6IHtcblx0XHRcdFx0XHR2YWx1ZTogRU5DT0RJTkdTW0xpbmVhckVuY29kaW5nXVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dmVydGV4U2hhZGVyOiBfZ2V0Q29tbW9uVmVydGV4U2hhZGVyKCksXG5cdFx0XHRmcmFnbWVudFNoYWRlcjpcblx0XHRcdC8qIGdsc2wgKi9cblx0XHRcdGBcblxuXHRcdFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cdFx0XHRwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XG5cblx0XHRcdHZhcnlpbmcgdmVjMyB2T3V0cHV0RGlyZWN0aW9uO1xuXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XG5cdFx0XHR1bmlmb3JtIGludCBzYW1wbGVzO1xuXHRcdFx0dW5pZm9ybSBmbG9hdCB3ZWlnaHRzWyBuIF07XG5cdFx0XHR1bmlmb3JtIGJvb2wgbGF0aXR1ZGluYWw7XG5cdFx0XHR1bmlmb3JtIGZsb2F0IGRUaGV0YTtcblx0XHRcdHVuaWZvcm0gZmxvYXQgbWlwSW50O1xuXHRcdFx0dW5pZm9ybSB2ZWMzIHBvbGVBeGlzO1xuXG5cdFx0XHQke19nZXRFbmNvZGluZ3MoKX1cblxuXHRcdFx0I2RlZmluZSBFTlZNQVBfVFlQRV9DVUJFX1VWXG5cdFx0XHQjaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PlxuXG5cdFx0XHR2ZWMzIGdldFNhbXBsZSggZmxvYXQgdGhldGEsIHZlYzMgYXhpcyApIHtcblxuXHRcdFx0XHRmbG9hdCBjb3NUaGV0YSA9IGNvcyggdGhldGEgKTtcblx0XHRcdFx0Ly8gUm9kcmlndWVzJyBheGlzLWFuZ2xlIHJvdGF0aW9uXG5cdFx0XHRcdHZlYzMgc2FtcGxlRGlyZWN0aW9uID0gdk91dHB1dERpcmVjdGlvbiAqIGNvc1RoZXRhXG5cdFx0XHRcdFx0KyBjcm9zcyggYXhpcywgdk91dHB1dERpcmVjdGlvbiApICogc2luKCB0aGV0YSApXG5cdFx0XHRcdFx0KyBheGlzICogZG90KCBheGlzLCB2T3V0cHV0RGlyZWN0aW9uICkgKiAoIDEuMCAtIGNvc1RoZXRhICk7XG5cblx0XHRcdFx0cmV0dXJuIGJpbGluZWFyQ3ViZVVWKCBlbnZNYXAsIHNhbXBsZURpcmVjdGlvbiwgbWlwSW50ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dm9pZCBtYWluKCkge1xuXG5cdFx0XHRcdHZlYzMgYXhpcyA9IGxhdGl0dWRpbmFsID8gcG9sZUF4aXMgOiBjcm9zcyggcG9sZUF4aXMsIHZPdXRwdXREaXJlY3Rpb24gKTtcblxuXHRcdFx0XHRpZiAoIGFsbCggZXF1YWwoIGF4aXMsIHZlYzMoIDAuMCApICkgKSApIHtcblxuXHRcdFx0XHRcdGF4aXMgPSB2ZWMzKCB2T3V0cHV0RGlyZWN0aW9uLnosIDAuMCwgLSB2T3V0cHV0RGlyZWN0aW9uLnggKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YXhpcyA9IG5vcm1hbGl6ZSggYXhpcyApO1xuXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApO1xuXHRcdFx0XHRnbF9GcmFnQ29sb3IucmdiICs9IHdlaWdodHNbIDAgXSAqIGdldFNhbXBsZSggMC4wLCBheGlzICk7XG5cblx0XHRcdFx0Zm9yICggaW50IGkgPSAxOyBpIDwgbjsgaSsrICkge1xuXG5cdFx0XHRcdFx0aWYgKCBpID49IHNhbXBsZXMgKSB7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZmxvYXQgdGhldGEgPSBkVGhldGEgKiBmbG9hdCggaSApO1xuXHRcdFx0XHRcdGdsX0ZyYWdDb2xvci5yZ2IgKz0gd2VpZ2h0c1sgaSBdICogZ2V0U2FtcGxlKCAtMS4wICogdGhldGEsIGF4aXMgKTtcblx0XHRcdFx0XHRnbF9GcmFnQ29sb3IucmdiICs9IHdlaWdodHNbIGkgXSAqIGdldFNhbXBsZSggdGhldGEsIGF4aXMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gbGluZWFyVG9PdXRwdXRUZXhlbCggZ2xfRnJhZ0NvbG9yICk7XG5cblx0XHRcdH1cblx0XHRgLFxuXHRcdFx0YmxlbmRpbmc6IE5vQmxlbmRpbmcsXG5cdFx0XHRkZXB0aFRlc3Q6IGZhbHNlLFxuXHRcdFx0ZGVwdGhXcml0ZTogZmFsc2Vcblx0XHR9KTtcblx0XHRyZXR1cm4gc2hhZGVyTWF0ZXJpYWw7XG5cdH1cblxuXHRmdW5jdGlvbiBfZ2V0RXF1aXJlY3RTaGFkZXIoKSB7XG5cdFx0Y29uc3QgdGV4ZWxTaXplID0gbmV3IFZlY3RvcjIoMSwgMSk7XG5cdFx0Y29uc3Qgc2hhZGVyTWF0ZXJpYWwgPSBuZXcgUmF3U2hhZGVyTWF0ZXJpYWwoe1xuXHRcdFx0bmFtZTogJ0VxdWlyZWN0YW5ndWxhclRvQ3ViZVVWJyxcblx0XHRcdHVuaWZvcm1zOiB7XG5cdFx0XHRcdCdlbnZNYXAnOiB7XG5cdFx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdFx0fSxcblx0XHRcdFx0J3RleGVsU2l6ZSc6IHtcblx0XHRcdFx0XHR2YWx1ZTogdGV4ZWxTaXplXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCdpbnB1dEVuY29kaW5nJzoge1xuXHRcdFx0XHRcdHZhbHVlOiBFTkNPRElOR1NbTGluZWFyRW5jb2RpbmddXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCdvdXRwdXRFbmNvZGluZyc6IHtcblx0XHRcdFx0XHR2YWx1ZTogRU5DT0RJTkdTW0xpbmVhckVuY29kaW5nXVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dmVydGV4U2hhZGVyOiBfZ2V0Q29tbW9uVmVydGV4U2hhZGVyKCksXG5cdFx0XHRmcmFnbWVudFNoYWRlcjpcblx0XHRcdC8qIGdsc2wgKi9cblx0XHRcdGBcblxuXHRcdFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cdFx0XHRwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XG5cblx0XHRcdHZhcnlpbmcgdmVjMyB2T3V0cHV0RGlyZWN0aW9uO1xuXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XG5cdFx0XHR1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO1xuXG5cdFx0XHQke19nZXRFbmNvZGluZ3MoKX1cblxuXHRcdFx0I2luY2x1ZGUgPGNvbW1vbj5cblxuXHRcdFx0dm9pZCBtYWluKCkge1xuXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApO1xuXG5cdFx0XHRcdHZlYzMgb3V0cHV0RGlyZWN0aW9uID0gbm9ybWFsaXplKCB2T3V0cHV0RGlyZWN0aW9uICk7XG5cdFx0XHRcdHZlYzIgdXYgPSBlcXVpcmVjdFV2KCBvdXRwdXREaXJlY3Rpb24gKTtcblxuXHRcdFx0XHR2ZWMyIGYgPSBmcmFjdCggdXYgLyB0ZXhlbFNpemUgLSAwLjUgKTtcblx0XHRcdFx0dXYgLT0gZiAqIHRleGVsU2l6ZTtcblx0XHRcdFx0dmVjMyB0bCA9IGVudk1hcFRleGVsVG9MaW5lYXIoIHRleHR1cmUyRCAoIGVudk1hcCwgdXYgKSApLnJnYjtcblx0XHRcdFx0dXYueCArPSB0ZXhlbFNpemUueDtcblx0XHRcdFx0dmVjMyB0ciA9IGVudk1hcFRleGVsVG9MaW5lYXIoIHRleHR1cmUyRCAoIGVudk1hcCwgdXYgKSApLnJnYjtcblx0XHRcdFx0dXYueSArPSB0ZXhlbFNpemUueTtcblx0XHRcdFx0dmVjMyBiciA9IGVudk1hcFRleGVsVG9MaW5lYXIoIHRleHR1cmUyRCAoIGVudk1hcCwgdXYgKSApLnJnYjtcblx0XHRcdFx0dXYueCAtPSB0ZXhlbFNpemUueDtcblx0XHRcdFx0dmVjMyBibCA9IGVudk1hcFRleGVsVG9MaW5lYXIoIHRleHR1cmUyRCAoIGVudk1hcCwgdXYgKSApLnJnYjtcblxuXHRcdFx0XHR2ZWMzIHRtID0gbWl4KCB0bCwgdHIsIGYueCApO1xuXHRcdFx0XHR2ZWMzIGJtID0gbWl4KCBibCwgYnIsIGYueCApO1xuXHRcdFx0XHRnbF9GcmFnQ29sb3IucmdiID0gbWl4KCB0bSwgYm0sIGYueSApO1xuXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IGxpbmVhclRvT3V0cHV0VGV4ZWwoIGdsX0ZyYWdDb2xvciApO1xuXG5cdFx0XHR9XG5cdFx0YCxcblx0XHRcdGJsZW5kaW5nOiBOb0JsZW5kaW5nLFxuXHRcdFx0ZGVwdGhUZXN0OiBmYWxzZSxcblx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlXG5cdFx0fSk7XG5cdFx0cmV0dXJuIHNoYWRlck1hdGVyaWFsO1xuXHR9XG5cblx0ZnVuY3Rpb24gX2dldEN1YmVtYXBTaGFkZXIoKSB7XG5cdFx0Y29uc3Qgc2hhZGVyTWF0ZXJpYWwgPSBuZXcgUmF3U2hhZGVyTWF0ZXJpYWwoe1xuXHRcdFx0bmFtZTogJ0N1YmVtYXBUb0N1YmVVVicsXG5cdFx0XHR1bmlmb3Jtczoge1xuXHRcdFx0XHQnZW52TWFwJzoge1xuXHRcdFx0XHRcdHZhbHVlOiBudWxsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCdpbnB1dEVuY29kaW5nJzoge1xuXHRcdFx0XHRcdHZhbHVlOiBFTkNPRElOR1NbTGluZWFyRW5jb2RpbmddXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCdvdXRwdXRFbmNvZGluZyc6IHtcblx0XHRcdFx0XHR2YWx1ZTogRU5DT0RJTkdTW0xpbmVhckVuY29kaW5nXVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dmVydGV4U2hhZGVyOiBfZ2V0Q29tbW9uVmVydGV4U2hhZGVyKCksXG5cdFx0XHRmcmFnbWVudFNoYWRlcjpcblx0XHRcdC8qIGdsc2wgKi9cblx0XHRcdGBcblxuXHRcdFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cdFx0XHRwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XG5cblx0XHRcdHZhcnlpbmcgdmVjMyB2T3V0cHV0RGlyZWN0aW9uO1xuXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcblxuXHRcdFx0JHtfZ2V0RW5jb2RpbmdzKCl9XG5cblx0XHRcdHZvaWQgbWFpbigpIHtcblxuXHRcdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTtcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yLnJnYiA9IGVudk1hcFRleGVsVG9MaW5lYXIoIHRleHR1cmVDdWJlKCBlbnZNYXAsIHZlYzMoIC0gdk91dHB1dERpcmVjdGlvbi54LCB2T3V0cHV0RGlyZWN0aW9uLnl6ICkgKSApLnJnYjtcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gbGluZWFyVG9PdXRwdXRUZXhlbCggZ2xfRnJhZ0NvbG9yICk7XG5cblx0XHRcdH1cblx0XHRgLFxuXHRcdFx0YmxlbmRpbmc6IE5vQmxlbmRpbmcsXG5cdFx0XHRkZXB0aFRlc3Q6IGZhbHNlLFxuXHRcdFx0ZGVwdGhXcml0ZTogZmFsc2Vcblx0XHR9KTtcblx0XHRyZXR1cm4gc2hhZGVyTWF0ZXJpYWw7XG5cdH1cblxuXHRmdW5jdGlvbiBfZ2V0Q29tbW9uVmVydGV4U2hhZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQvKiBnbHNsICovXG5cdFx0XHRgXG5cblx0XHRwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblx0XHRwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XG5cblx0XHRhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcblx0XHRhdHRyaWJ1dGUgdmVjMiB1djtcblx0XHRhdHRyaWJ1dGUgZmxvYXQgZmFjZUluZGV4O1xuXG5cdFx0dmFyeWluZyB2ZWMzIHZPdXRwdXREaXJlY3Rpb247XG5cblx0XHQvLyBSSCBjb29yZGluYXRlIHN5c3RlbTsgUE1SRU0gZmFjZS1pbmRleGluZyBjb252ZW50aW9uXG5cdFx0dmVjMyBnZXREaXJlY3Rpb24oIHZlYzIgdXYsIGZsb2F0IGZhY2UgKSB7XG5cblx0XHRcdHV2ID0gMi4wICogdXYgLSAxLjA7XG5cblx0XHRcdHZlYzMgZGlyZWN0aW9uID0gdmVjMyggdXYsIDEuMCApO1xuXG5cdFx0XHRpZiAoIGZhY2UgPT0gMC4wICkge1xuXG5cdFx0XHRcdGRpcmVjdGlvbiA9IGRpcmVjdGlvbi56eXg7IC8vICggMSwgdiwgdSApIHBvcyB4XG5cblx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgPT0gMS4wICkge1xuXG5cdFx0XHRcdGRpcmVjdGlvbiA9IGRpcmVjdGlvbi54enk7XG5cdFx0XHRcdGRpcmVjdGlvbi54eiAqPSAtMS4wOyAvLyAoIC11LCAxLCAtdiApIHBvcyB5XG5cblx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgPT0gMi4wICkge1xuXG5cdFx0XHRcdGRpcmVjdGlvbi54ICo9IC0xLjA7IC8vICggLXUsIHYsIDEgKSBwb3MgelxuXG5cdFx0XHR9IGVsc2UgaWYgKCBmYWNlID09IDMuMCApIHtcblxuXHRcdFx0XHRkaXJlY3Rpb24gPSBkaXJlY3Rpb24uenl4O1xuXHRcdFx0XHRkaXJlY3Rpb24ueHogKj0gLTEuMDsgLy8gKCAtMSwgdiwgLXUgKSBuZWcgeFxuXG5cdFx0XHR9IGVsc2UgaWYgKCBmYWNlID09IDQuMCApIHtcblxuXHRcdFx0XHRkaXJlY3Rpb24gPSBkaXJlY3Rpb24ueHp5O1xuXHRcdFx0XHRkaXJlY3Rpb24ueHkgKj0gLTEuMDsgLy8gKCAtdSwgLTEsIHYgKSBuZWcgeVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBmYWNlID09IDUuMCApIHtcblxuXHRcdFx0XHRkaXJlY3Rpb24ueiAqPSAtMS4wOyAvLyAoIHUsIHYsIC0xICkgbmVnIHpcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGlyZWN0aW9uO1xuXG5cdFx0fVxuXG5cdFx0dm9pZCBtYWluKCkge1xuXG5cdFx0XHR2T3V0cHV0RGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKCB1diwgZmFjZUluZGV4ICk7XG5cdFx0XHRnbF9Qb3NpdGlvbiA9IHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcblxuXHRcdH1cblx0YFxuXHRcdCk7XG5cdH1cblxuXHRmdW5jdGlvbiBfZ2V0RW5jb2RpbmdzKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQvKiBnbHNsICovXG5cdFx0XHRgXG5cblx0XHR1bmlmb3JtIGludCBpbnB1dEVuY29kaW5nO1xuXHRcdHVuaWZvcm0gaW50IG91dHB1dEVuY29kaW5nO1xuXG5cdFx0I2luY2x1ZGUgPGVuY29kaW5nc19wYXJzX2ZyYWdtZW50PlxuXG5cdFx0dmVjNCBpbnB1dFRleGVsVG9MaW5lYXIoIHZlYzQgdmFsdWUgKSB7XG5cblx0XHRcdGlmICggaW5wdXRFbmNvZGluZyA9PSAwICkge1xuXG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdFx0fSBlbHNlIGlmICggaW5wdXRFbmNvZGluZyA9PSAxICkge1xuXG5cdFx0XHRcdHJldHVybiBzUkdCVG9MaW5lYXIoIHZhbHVlICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGlucHV0RW5jb2RpbmcgPT0gMiApIHtcblxuXHRcdFx0XHRyZXR1cm4gUkdCRVRvTGluZWFyKCB2YWx1ZSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBpbnB1dEVuY29kaW5nID09IDMgKSB7XG5cblx0XHRcdFx0cmV0dXJuIFJHQk1Ub0xpbmVhciggdmFsdWUsIDcuMCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBpbnB1dEVuY29kaW5nID09IDQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIFJHQk1Ub0xpbmVhciggdmFsdWUsIDE2LjAgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggaW5wdXRFbmNvZGluZyA9PSA1ICkge1xuXG5cdFx0XHRcdHJldHVybiBSR0JEVG9MaW5lYXIoIHZhbHVlLCAyNTYuMCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBHYW1tYVRvTGluZWFyKCB2YWx1ZSwgMi4yICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHZlYzQgbGluZWFyVG9PdXRwdXRUZXhlbCggdmVjNCB2YWx1ZSApIHtcblxuXHRcdFx0aWYgKCBvdXRwdXRFbmNvZGluZyA9PSAwICkge1xuXG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdFx0fSBlbHNlIGlmICggb3V0cHV0RW5jb2RpbmcgPT0gMSApIHtcblxuXHRcdFx0XHRyZXR1cm4gTGluZWFyVG9zUkdCKCB2YWx1ZSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvdXRwdXRFbmNvZGluZyA9PSAyICkge1xuXG5cdFx0XHRcdHJldHVybiBMaW5lYXJUb1JHQkUoIHZhbHVlICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG91dHB1dEVuY29kaW5nID09IDMgKSB7XG5cblx0XHRcdFx0cmV0dXJuIExpbmVhclRvUkdCTSggdmFsdWUsIDcuMCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvdXRwdXRFbmNvZGluZyA9PSA0ICkge1xuXG5cdFx0XHRcdHJldHVybiBMaW5lYXJUb1JHQk0oIHZhbHVlLCAxNi4wICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG91dHB1dEVuY29kaW5nID09IDUgKSB7XG5cblx0XHRcdFx0cmV0dXJuIExpbmVhclRvUkdCRCggdmFsdWUsIDI1Ni4wICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIExpbmVhclRvR2FtbWEoIHZhbHVlLCAyLjIgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dmVjNCBlbnZNYXBUZXhlbFRvTGluZWFyKCB2ZWM0IGNvbG9yICkge1xuXG5cdFx0XHRyZXR1cm4gaW5wdXRUZXhlbFRvTGluZWFyKCBjb2xvciApO1xuXG5cdFx0fVxuXHRgXG5cdFx0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIFdlYkdMQ3ViZVVWTWFwcyhyZW5kZXJlcikge1xuXHRcdGxldCBjdWJlVVZtYXBzID0gbmV3IFdlYWtNYXAoKTtcblx0XHRsZXQgcG1yZW1HZW5lcmF0b3IgPSBudWxsO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0KHRleHR1cmUpIHtcblx0XHRcdGlmICh0ZXh0dXJlICYmIHRleHR1cmUuaXNUZXh0dXJlICYmIHRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID09PSBmYWxzZSkge1xuXHRcdFx0XHRjb25zdCBtYXBwaW5nID0gdGV4dHVyZS5tYXBwaW5nO1xuXHRcdFx0XHRjb25zdCBpc0VxdWlyZWN0TWFwID0gbWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgfHwgbWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc7XG5cdFx0XHRcdGNvbnN0IGlzQ3ViZU1hcCA9IG1hcHBpbmcgPT09IEN1YmVSZWZsZWN0aW9uTWFwcGluZyB8fCBtYXBwaW5nID09PSBDdWJlUmVmcmFjdGlvbk1hcHBpbmc7XG5cblx0XHRcdFx0aWYgKGlzRXF1aXJlY3RNYXAgfHwgaXNDdWJlTWFwKSB7XG5cdFx0XHRcdFx0Ly8gZXF1aXJlY3QvY3ViZSBtYXAgdG8gY3ViZVVWIGNvbnZlcnNpb25cblx0XHRcdFx0XHRpZiAoY3ViZVVWbWFwcy5oYXModGV4dHVyZSkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBjdWJlVVZtYXBzLmdldCh0ZXh0dXJlKS50ZXh0dXJlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zdCBpbWFnZSA9IHRleHR1cmUuaW1hZ2U7XG5cblx0XHRcdFx0XHRcdGlmIChpc0VxdWlyZWN0TWFwICYmIGltYWdlICYmIGltYWdlLmhlaWdodCA+IDAgfHwgaXNDdWJlTWFwICYmIGltYWdlICYmIGlzQ3ViZVRleHR1cmVDb21wbGV0ZShpbWFnZSkpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgY3VycmVudFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xuXHRcdFx0XHRcdFx0XHRpZiAocG1yZW1HZW5lcmF0b3IgPT09IG51bGwpIHBtcmVtR2VuZXJhdG9yID0gbmV3IFBNUkVNR2VuZXJhdG9yKHJlbmRlcmVyKTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgcmVuZGVyVGFyZ2V0ID0gaXNFcXVpcmVjdE1hcCA/IHBtcmVtR2VuZXJhdG9yLmZyb21FcXVpcmVjdGFuZ3VsYXIodGV4dHVyZSkgOiBwbXJlbUdlbmVyYXRvci5mcm9tQ3ViZW1hcCh0ZXh0dXJlKTtcblx0XHRcdFx0XHRcdFx0Y3ViZVVWbWFwcy5zZXQodGV4dHVyZSwgcmVuZGVyVGFyZ2V0KTtcblx0XHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KGN1cnJlbnRSZW5kZXJUYXJnZXQpO1xuXHRcdFx0XHRcdFx0XHR0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlbmRlclRhcmdldC50ZXh0dXJlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gaW1hZ2Ugbm90IHlldCByZWFkeS4gdHJ5IHRoZSBjb252ZXJzaW9uIG5leHQgZnJhbWVcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0ZXh0dXJlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzQ3ViZVRleHR1cmVDb21wbGV0ZShpbWFnZSkge1xuXHRcdFx0bGV0IGNvdW50ID0gMDtcblx0XHRcdGNvbnN0IGxlbmd0aCA9IDY7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGltYWdlW2ldICE9PSB1bmRlZmluZWQpIGNvdW50Kys7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjb3VudCA9PT0gbGVuZ3RoO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uVGV4dHVyZURpc3Bvc2UoZXZlbnQpIHtcblx0XHRcdGNvbnN0IHRleHR1cmUgPSBldmVudC50YXJnZXQ7XG5cdFx0XHR0ZXh0dXJlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlKTtcblx0XHRcdGNvbnN0IGN1YmVtYXBVViA9IGN1YmVVVm1hcHMuZ2V0KHRleHR1cmUpO1xuXG5cdFx0XHRpZiAoY3ViZW1hcFVWICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y3ViZVVWbWFwcy5kZWxldGUodGV4dHVyZSk7XG5cdFx0XHRcdGN1YmVtYXBVVi5kaXNwb3NlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGlzcG9zZSgpIHtcblx0XHRcdGN1YmVVVm1hcHMgPSBuZXcgV2Vha01hcCgpO1xuXG5cdFx0XHRpZiAocG1yZW1HZW5lcmF0b3IgIT09IG51bGwpIHtcblx0XHRcdFx0cG1yZW1HZW5lcmF0b3IuZGlzcG9zZSgpO1xuXHRcdFx0XHRwbXJlbUdlbmVyYXRvciA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGdldDogZ2V0LFxuXHRcdFx0ZGlzcG9zZTogZGlzcG9zZVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTEV4dGVuc2lvbnMoZ2wpIHtcblx0XHRjb25zdCBleHRlbnNpb25zID0ge307XG5cblx0XHRmdW5jdGlvbiBnZXRFeHRlbnNpb24obmFtZSkge1xuXHRcdFx0aWYgKGV4dGVuc2lvbnNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gZXh0ZW5zaW9uc1tuYW1lXTtcblx0XHRcdH1cblxuXHRcdFx0bGV0IGV4dGVuc2lvbjtcblxuXHRcdFx0c3dpdGNoIChuYW1lKSB7XG5cdFx0XHRcdGNhc2UgJ1dFQkdMX2RlcHRoX3RleHR1cmUnOlxuXHRcdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbignV0VCR0xfZGVwdGhfdGV4dHVyZScpIHx8IGdsLmdldEV4dGVuc2lvbignTU9aX1dFQkdMX2RlcHRoX3RleHR1cmUnKSB8fCBnbC5nZXRFeHRlbnNpb24oJ1dFQktJVF9XRUJHTF9kZXB0aF90ZXh0dXJlJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJzpcblx0XHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycpIHx8IGdsLmdldEV4dGVuc2lvbignTU9aX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycpIHx8IGdsLmdldEV4dGVuc2lvbignV0VCS0lUX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJzpcblx0XHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJykgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCdNT1pfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnKSB8fCBnbC5nZXRFeHRlbnNpb24oJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Yyc6XG5cdFx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnKSB8fCBnbC5nZXRFeHRlbnNpb24oJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbihuYW1lKTtcblx0XHRcdH1cblxuXHRcdFx0ZXh0ZW5zaW9uc1tuYW1lXSA9IGV4dGVuc2lvbjtcblx0XHRcdHJldHVybiBleHRlbnNpb247XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGhhczogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdFx0cmV0dXJuIGdldEV4dGVuc2lvbihuYW1lKSAhPT0gbnVsbDtcblx0XHRcdH0sXG5cdFx0XHRpbml0OiBmdW5jdGlvbiAoY2FwYWJpbGl0aWVzKSB7XG5cdFx0XHRcdGlmIChjYXBhYmlsaXRpZXMuaXNXZWJHTDIpIHtcblx0XHRcdFx0XHRnZXRFeHRlbnNpb24oJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRnZXRFeHRlbnNpb24oJ1dFQkdMX2RlcHRoX3RleHR1cmUnKTtcblx0XHRcdFx0XHRnZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0Jyk7XG5cdFx0XHRcdFx0Z2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0Jyk7XG5cdFx0XHRcdFx0Z2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicpO1xuXHRcdFx0XHRcdGdldEV4dGVuc2lvbignT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyk7XG5cdFx0XHRcdFx0Z2V0RXh0ZW5zaW9uKCdPRVNfZWxlbWVudF9pbmRleF91aW50Jyk7XG5cdFx0XHRcdFx0Z2V0RXh0ZW5zaW9uKCdPRVNfdmVydGV4X2FycmF5X29iamVjdCcpO1xuXHRcdFx0XHRcdGdldEV4dGVuc2lvbignQU5HTEVfaW5zdGFuY2VkX2FycmF5cycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInKTtcblx0XHRcdFx0Z2V0RXh0ZW5zaW9uKCdFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQnKTtcblx0XHRcdFx0Z2V0RXh0ZW5zaW9uKCdXRUJHTF9tdWx0aXNhbXBsZWRfcmVuZGVyX3RvX3RleHR1cmUnKTtcblx0XHRcdH0sXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRcdGNvbnN0IGV4dGVuc2lvbiA9IGdldEV4dGVuc2lvbihuYW1lKTtcblxuXHRcdFx0XHRpZiAoZXh0ZW5zaW9uID09PSBudWxsKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAnICsgbmFtZSArICcgZXh0ZW5zaW9uIG5vdCBzdXBwb3J0ZWQuJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZXh0ZW5zaW9uO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTEdlb21ldHJpZXMoZ2wsIGF0dHJpYnV0ZXMsIGluZm8sIGJpbmRpbmdTdGF0ZXMpIHtcblx0XHRjb25zdCBnZW9tZXRyaWVzID0ge307XG5cdFx0Y29uc3Qgd2lyZWZyYW1lQXR0cmlidXRlcyA9IG5ldyBXZWFrTWFwKCk7XG5cblx0XHRmdW5jdGlvbiBvbkdlb21ldHJ5RGlzcG9zZShldmVudCkge1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBldmVudC50YXJnZXQ7XG5cblx0XHRcdGlmIChnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0XHRhdHRyaWJ1dGVzLnJlbW92ZShnZW9tZXRyeS5pbmRleCk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoY29uc3QgbmFtZSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdGF0dHJpYnV0ZXMucmVtb3ZlKGdlb21ldHJ5LmF0dHJpYnV0ZXNbbmFtZV0pO1xuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS5yZW1vdmVFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UpO1xuXHRcdFx0ZGVsZXRlIGdlb21ldHJpZXNbZ2VvbWV0cnkuaWRdO1xuXHRcdFx0Y29uc3QgYXR0cmlidXRlID0gd2lyZWZyYW1lQXR0cmlidXRlcy5nZXQoZ2VvbWV0cnkpO1xuXG5cdFx0XHRpZiAoYXR0cmlidXRlKSB7XG5cdFx0XHRcdGF0dHJpYnV0ZXMucmVtb3ZlKGF0dHJpYnV0ZSk7XG5cdFx0XHRcdHdpcmVmcmFtZUF0dHJpYnV0ZXMuZGVsZXRlKGdlb21ldHJ5KTtcblx0XHRcdH1cblxuXHRcdFx0YmluZGluZ1N0YXRlcy5yZWxlYXNlU3RhdGVzT2ZHZW9tZXRyeShnZW9tZXRyeSk7XG5cblx0XHRcdGlmIChnZW9tZXRyeS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ID09PSB0cnVlKSB7XG5cdFx0XHRcdGRlbGV0ZSBnZW9tZXRyeS5fbWF4SW5zdGFuY2VDb3VudDtcblx0XHRcdH0gLy9cblxuXG5cdFx0XHRpbmZvLm1lbW9yeS5nZW9tZXRyaWVzLS07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0KG9iamVjdCwgZ2VvbWV0cnkpIHtcblx0XHRcdGlmIChnZW9tZXRyaWVzW2dlb21ldHJ5LmlkXSA9PT0gdHJ1ZSkgcmV0dXJuIGdlb21ldHJ5O1xuXHRcdFx0Z2VvbWV0cnkuYWRkRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uR2VvbWV0cnlEaXNwb3NlKTtcblx0XHRcdGdlb21ldHJpZXNbZ2VvbWV0cnkuaWRdID0gdHJ1ZTtcblx0XHRcdGluZm8ubWVtb3J5Lmdlb21ldHJpZXMrKztcblx0XHRcdHJldHVybiBnZW9tZXRyeTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cGRhdGUoZ2VvbWV0cnkpIHtcblx0XHRcdGNvbnN0IGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7IC8vIFVwZGF0aW5nIGluZGV4IGJ1ZmZlciBpbiBWQU8gbm93LiBTZWUgV2ViR0xCaW5kaW5nU3RhdGVzLlxuXG5cdFx0XHRmb3IgKGNvbnN0IG5hbWUgaW4gZ2VvbWV0cnlBdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdGF0dHJpYnV0ZXMudXBkYXRlKGdlb21ldHJ5QXR0cmlidXRlc1tuYW1lXSwgZ2wuQVJSQVlfQlVGRkVSKTtcblx0XHRcdH0gLy8gbW9ycGggdGFyZ2V0c1xuXG5cblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcblxuXHRcdFx0Zm9yIChjb25zdCBuYW1lIGluIG1vcnBoQXR0cmlidXRlcykge1xuXHRcdFx0XHRjb25zdCBhcnJheSA9IG1vcnBoQXR0cmlidXRlc1tuYW1lXTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGF0dHJpYnV0ZXMudXBkYXRlKGFycmF5W2ldLCBnbC5BUlJBWV9CVUZGRVIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlV2lyZWZyYW1lQXR0cmlidXRlKGdlb21ldHJ5KSB7XG5cdFx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0XHRjb25zdCBnZW9tZXRyeUluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRjb25zdCBnZW9tZXRyeVBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdGxldCB2ZXJzaW9uID0gMDtcblxuXHRcdFx0aWYgKGdlb21ldHJ5SW5kZXggIT09IG51bGwpIHtcblx0XHRcdFx0Y29uc3QgYXJyYXkgPSBnZW9tZXRyeUluZGV4LmFycmF5O1xuXHRcdFx0XHR2ZXJzaW9uID0gZ2VvbWV0cnlJbmRleC52ZXJzaW9uO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArPSAzKSB7XG5cdFx0XHRcdFx0Y29uc3QgYSA9IGFycmF5W2kgKyAwXTtcblx0XHRcdFx0XHRjb25zdCBiID0gYXJyYXlbaSArIDFdO1xuXHRcdFx0XHRcdGNvbnN0IGMgPSBhcnJheVtpICsgMl07XG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKGEsIGIsIGIsIGMsIGMsIGEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBhcnJheSA9IGdlb21ldHJ5UG9zaXRpb24uYXJyYXk7XG5cdFx0XHRcdHZlcnNpb24gPSBnZW9tZXRyeVBvc2l0aW9uLnZlcnNpb247XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGggLyAzIC0gMTsgaSA8IGw7IGkgKz0gMykge1xuXHRcdFx0XHRcdGNvbnN0IGEgPSBpICsgMDtcblx0XHRcdFx0XHRjb25zdCBiID0gaSArIDE7XG5cdFx0XHRcdFx0Y29uc3QgYyA9IGkgKyAyO1xuXHRcdFx0XHRcdGluZGljZXMucHVzaChhLCBiLCBiLCBjLCBjLCBhKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBuZXcgKGFycmF5TWF4KGluZGljZXMpID4gNjU1MzUgPyBVaW50MzJCdWZmZXJBdHRyaWJ1dGUgOiBVaW50MTZCdWZmZXJBdHRyaWJ1dGUpKGluZGljZXMsIDEpO1xuXHRcdFx0YXR0cmlidXRlLnZlcnNpb24gPSB2ZXJzaW9uOyAvLyBVcGRhdGluZyBpbmRleCBidWZmZXIgaW4gVkFPIG5vdy4gU2VlIFdlYkdMQmluZGluZ1N0YXRlc1xuXHRcdFx0Ly9cblxuXHRcdFx0Y29uc3QgcHJldmlvdXNBdHRyaWJ1dGUgPSB3aXJlZnJhbWVBdHRyaWJ1dGVzLmdldChnZW9tZXRyeSk7XG5cdFx0XHRpZiAocHJldmlvdXNBdHRyaWJ1dGUpIGF0dHJpYnV0ZXMucmVtb3ZlKHByZXZpb3VzQXR0cmlidXRlKTsgLy9cblxuXHRcdFx0d2lyZWZyYW1lQXR0cmlidXRlcy5zZXQoZ2VvbWV0cnksIGF0dHJpYnV0ZSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0V2lyZWZyYW1lQXR0cmlidXRlKGdlb21ldHJ5KSB7XG5cdFx0XHRjb25zdCBjdXJyZW50QXR0cmlidXRlID0gd2lyZWZyYW1lQXR0cmlidXRlcy5nZXQoZ2VvbWV0cnkpO1xuXG5cdFx0XHRpZiAoY3VycmVudEF0dHJpYnV0ZSkge1xuXHRcdFx0XHRjb25zdCBnZW9tZXRyeUluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cblx0XHRcdFx0aWYgKGdlb21ldHJ5SW5kZXggIT09IG51bGwpIHtcblx0XHRcdFx0XHQvLyBpZiB0aGUgYXR0cmlidXRlIGlzIG9ic29sZXRlLCBjcmVhdGUgYSBuZXcgb25lXG5cdFx0XHRcdFx0aWYgKGN1cnJlbnRBdHRyaWJ1dGUudmVyc2lvbiA8IGdlb21ldHJ5SW5kZXgudmVyc2lvbikge1xuXHRcdFx0XHRcdFx0dXBkYXRlV2lyZWZyYW1lQXR0cmlidXRlKGdlb21ldHJ5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHVwZGF0ZVdpcmVmcmFtZUF0dHJpYnV0ZShnZW9tZXRyeSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB3aXJlZnJhbWVBdHRyaWJ1dGVzLmdldChnZW9tZXRyeSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGdldDogZ2V0LFxuXHRcdFx0dXBkYXRlOiB1cGRhdGUsXG5cdFx0XHRnZXRXaXJlZnJhbWVBdHRyaWJ1dGU6IGdldFdpcmVmcmFtZUF0dHJpYnV0ZVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlcihnbCwgZXh0ZW5zaW9ucywgaW5mbywgY2FwYWJpbGl0aWVzKSB7XG5cdFx0Y29uc3QgaXNXZWJHTDIgPSBjYXBhYmlsaXRpZXMuaXNXZWJHTDI7XG5cdFx0bGV0IG1vZGU7XG5cblx0XHRmdW5jdGlvbiBzZXRNb2RlKHZhbHVlKSB7XG5cdFx0XHRtb2RlID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0bGV0IHR5cGUsIGJ5dGVzUGVyRWxlbWVudDtcblxuXHRcdGZ1bmN0aW9uIHNldEluZGV4KHZhbHVlKSB7XG5cdFx0XHR0eXBlID0gdmFsdWUudHlwZTtcblx0XHRcdGJ5dGVzUGVyRWxlbWVudCA9IHZhbHVlLmJ5dGVzUGVyRWxlbWVudDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW5kZXIoc3RhcnQsIGNvdW50KSB7XG5cdFx0XHRnbC5kcmF3RWxlbWVudHMobW9kZSwgY291bnQsIHR5cGUsIHN0YXJ0ICogYnl0ZXNQZXJFbGVtZW50KTtcblx0XHRcdGluZm8udXBkYXRlKGNvdW50LCBtb2RlLCAxKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW5kZXJJbnN0YW5jZXMoc3RhcnQsIGNvdW50LCBwcmltY291bnQpIHtcblx0XHRcdGlmIChwcmltY291bnQgPT09IDApIHJldHVybjtcblx0XHRcdGxldCBleHRlbnNpb24sIG1ldGhvZE5hbWU7XG5cblx0XHRcdGlmIChpc1dlYkdMMikge1xuXHRcdFx0XHRleHRlbnNpb24gPSBnbDtcblx0XHRcdFx0bWV0aG9kTmFtZSA9ICdkcmF3RWxlbWVudHNJbnN0YW5jZWQnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnKTtcblx0XHRcdFx0bWV0aG9kTmFtZSA9ICdkcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRSc7XG5cblx0XHRcdFx0aWYgKGV4dGVuc2lvbiA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZXh0ZW5zaW9uW21ldGhvZE5hbWVdKG1vZGUsIGNvdW50LCB0eXBlLCBzdGFydCAqIGJ5dGVzUGVyRWxlbWVudCwgcHJpbWNvdW50KTtcblx0XHRcdGluZm8udXBkYXRlKGNvdW50LCBtb2RlLCBwcmltY291bnQpO1xuXHRcdH0gLy9cblxuXG5cdFx0dGhpcy5zZXRNb2RlID0gc2V0TW9kZTtcblx0XHR0aGlzLnNldEluZGV4ID0gc2V0SW5kZXg7XG5cdFx0dGhpcy5yZW5kZXIgPSByZW5kZXI7XG5cdFx0dGhpcy5yZW5kZXJJbnN0YW5jZXMgPSByZW5kZXJJbnN0YW5jZXM7XG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTEluZm8oZ2wpIHtcblx0XHRjb25zdCBtZW1vcnkgPSB7XG5cdFx0XHRnZW9tZXRyaWVzOiAwLFxuXHRcdFx0dGV4dHVyZXM6IDBcblx0XHR9O1xuXHRcdGNvbnN0IHJlbmRlciA9IHtcblx0XHRcdGZyYW1lOiAwLFxuXHRcdFx0Y2FsbHM6IDAsXG5cdFx0XHR0cmlhbmdsZXM6IDAsXG5cdFx0XHRwb2ludHM6IDAsXG5cdFx0XHRsaW5lczogMFxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1cGRhdGUoY291bnQsIG1vZGUsIGluc3RhbmNlQ291bnQpIHtcblx0XHRcdHJlbmRlci5jYWxscysrO1xuXG5cdFx0XHRzd2l0Y2ggKG1vZGUpIHtcblx0XHRcdFx0Y2FzZSBnbC5UUklBTkdMRVM6XG5cdFx0XHRcdFx0cmVuZGVyLnRyaWFuZ2xlcyArPSBpbnN0YW5jZUNvdW50ICogKGNvdW50IC8gMyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBnbC5MSU5FUzpcblx0XHRcdFx0XHRyZW5kZXIubGluZXMgKz0gaW5zdGFuY2VDb3VudCAqIChjb3VudCAvIDIpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgZ2wuTElORV9TVFJJUDpcblx0XHRcdFx0XHRyZW5kZXIubGluZXMgKz0gaW5zdGFuY2VDb3VudCAqIChjb3VudCAtIDEpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgZ2wuTElORV9MT09QOlxuXHRcdFx0XHRcdHJlbmRlci5saW5lcyArPSBpbnN0YW5jZUNvdW50ICogY291bnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBnbC5QT0lOVFM6XG5cdFx0XHRcdFx0cmVuZGVyLnBvaW50cyArPSBpbnN0YW5jZUNvdW50ICogY291bnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTEluZm86IFVua25vd24gZHJhdyBtb2RlOicsIG1vZGUpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlc2V0KCkge1xuXHRcdFx0cmVuZGVyLmZyYW1lKys7XG5cdFx0XHRyZW5kZXIuY2FsbHMgPSAwO1xuXHRcdFx0cmVuZGVyLnRyaWFuZ2xlcyA9IDA7XG5cdFx0XHRyZW5kZXIucG9pbnRzID0gMDtcblx0XHRcdHJlbmRlci5saW5lcyA9IDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdG1lbW9yeTogbWVtb3J5LFxuXHRcdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0XHRwcm9ncmFtczogbnVsbCxcblx0XHRcdGF1dG9SZXNldDogdHJ1ZSxcblx0XHRcdHJlc2V0OiByZXNldCxcblx0XHRcdHVwZGF0ZTogdXBkYXRlXG5cdFx0fTtcblx0fVxuXG5cdGNsYXNzIERhdGFUZXh0dXJlMkRBcnJheSBleHRlbmRzIFRleHR1cmUge1xuXHRcdGNvbnN0cnVjdG9yKGRhdGEgPSBudWxsLCB3aWR0aCA9IDEsIGhlaWdodCA9IDEsIGRlcHRoID0gMSkge1xuXHRcdFx0c3VwZXIobnVsbCk7XG5cdFx0XHR0aGlzLmltYWdlID0ge1xuXHRcdFx0XHRkYXRhLFxuXHRcdFx0XHR3aWR0aCxcblx0XHRcdFx0aGVpZ2h0LFxuXHRcdFx0XHRkZXB0aFxuXHRcdFx0fTtcblx0XHRcdHRoaXMubWFnRmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcblx0XHRcdHRoaXMubWluRmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcblx0XHRcdHRoaXMud3JhcFIgPSBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuXHRcdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblx0XHRcdHRoaXMuZmxpcFkgPSBmYWxzZTtcblx0XHRcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gMTtcblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdH1cblxuXHR9XG5cblx0RGF0YVRleHR1cmUyREFycmF5LnByb3RvdHlwZS5pc0RhdGFUZXh0dXJlMkRBcnJheSA9IHRydWU7XG5cblx0ZnVuY3Rpb24gbnVtZXJpY2FsU29ydChhLCBiKSB7XG5cdFx0cmV0dXJuIGFbMF0gLSBiWzBdO1xuXHR9XG5cblx0ZnVuY3Rpb24gYWJzTnVtZXJpY2FsU29ydChhLCBiKSB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKGJbMV0pIC0gTWF0aC5hYnMoYVsxXSk7XG5cdH1cblxuXHRmdW5jdGlvbiBkZW5vcm1hbGl6ZShtb3JwaCwgYXR0cmlidXRlKSB7XG5cdFx0bGV0IGRlbm9taW5hdG9yID0gMTtcblx0XHRjb25zdCBhcnJheSA9IGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlID8gYXR0cmlidXRlLmRhdGEuYXJyYXkgOiBhdHRyaWJ1dGUuYXJyYXk7XG5cdFx0aWYgKGFycmF5IGluc3RhbmNlb2YgSW50OEFycmF5KSBkZW5vbWluYXRvciA9IDEyNztlbHNlIGlmIChhcnJheSBpbnN0YW5jZW9mIEludDE2QXJyYXkpIGRlbm9taW5hdG9yID0gMzI3Njc7ZWxzZSBpZiAoYXJyYXkgaW5zdGFuY2VvZiBJbnQzMkFycmF5KSBkZW5vbWluYXRvciA9IDIxNDc0ODM2NDc7ZWxzZSBjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTE1vcnBodGFyZ2V0czogVW5zdXBwb3J0ZWQgbW9ycGggYXR0cmlidXRlIGRhdGEgdHlwZTogJywgYXJyYXkpO1xuXHRcdG1vcnBoLmRpdmlkZVNjYWxhcihkZW5vbWluYXRvcik7XG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTE1vcnBodGFyZ2V0cyhnbCwgY2FwYWJpbGl0aWVzLCB0ZXh0dXJlcykge1xuXHRcdGNvbnN0IGluZmx1ZW5jZXNMaXN0ID0ge307XG5cdFx0Y29uc3QgbW9ycGhJbmZsdWVuY2VzID0gbmV3IEZsb2F0MzJBcnJheSg4KTtcblx0XHRjb25zdCBtb3JwaFRleHR1cmVzID0gbmV3IFdlYWtNYXAoKTtcblx0XHRjb25zdCBtb3JwaCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3Qgd29ya0luZmx1ZW5jZXMgPSBbXTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdFx0XHR3b3JrSW5mbHVlbmNlc1tpXSA9IFtpLCAwXTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cGRhdGUob2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHByb2dyYW0pIHtcblx0XHRcdGNvbnN0IG9iamVjdEluZmx1ZW5jZXMgPSBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXG5cdFx0XHRpZiAoY2FwYWJpbGl0aWVzLmlzV2ViR0wyID09PSB0cnVlKSB7XG5cdFx0XHRcdC8vIGluc3RlYWQgb2YgdXNpbmcgYXR0cmlidXRlcywgdGhlIFdlYkdMIDIgY29kZSBwYXRoIGVuY29kZXMgbW9ycGggdGFyZ2V0c1xuXHRcdFx0XHQvLyBpbnRvIGFuIGFycmF5IG9mIGRhdGEgdGV4dHVyZXMuIEVhY2ggbGF5ZXIgcmVwcmVzZW50cyBhIHNpbmdsZSBtb3JwaCB0YXJnZXQuXG5cdFx0XHRcdGNvbnN0IG51bWJlck9mTW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uLmxlbmd0aDtcblx0XHRcdFx0bGV0IGVudHJ5ID0gbW9ycGhUZXh0dXJlcy5nZXQoZ2VvbWV0cnkpO1xuXG5cdFx0XHRcdGlmIChlbnRyeSA9PT0gdW5kZWZpbmVkIHx8IGVudHJ5LmNvdW50ICE9PSBudW1iZXJPZk1vcnBoVGFyZ2V0cykge1xuXHRcdFx0XHRcdGlmIChlbnRyeSAhPT0gdW5kZWZpbmVkKSBlbnRyeS50ZXh0dXJlLmRpc3Bvc2UoKTtcblx0XHRcdFx0XHRjb25zdCBoYXNNb3JwaE5vcm1hbHMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsICE9PSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0Y29uc3QgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0XHRcdGNvbnN0IG1vcnBoTm9ybWFscyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgfHwgW107XG5cdFx0XHRcdFx0Y29uc3QgbnVtYmVyT2ZWZXJ0aWNlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQ7XG5cdFx0XHRcdFx0Y29uc3QgbnVtYmVyT2ZWZXJ0ZXhEYXRhID0gaGFzTW9ycGhOb3JtYWxzID09PSB0cnVlID8gMiA6IDE7IC8vICh2LG4pIHZzLiAodilcblxuXHRcdFx0XHRcdGxldCB3aWR0aCA9IG51bWJlck9mVmVydGljZXMgKiBudW1iZXJPZlZlcnRleERhdGE7XG5cdFx0XHRcdFx0bGV0IGhlaWdodCA9IDE7XG5cblx0XHRcdFx0XHRpZiAod2lkdGggPiBjYXBhYmlsaXRpZXMubWF4VGV4dHVyZVNpemUpIHtcblx0XHRcdFx0XHRcdGhlaWdodCA9IE1hdGguY2VpbCh3aWR0aCAvIGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZSk7XG5cdFx0XHRcdFx0XHR3aWR0aCA9IGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb25zdCBidWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoICogaGVpZ2h0ICogNCAqIG51bWJlck9mTW9ycGhUYXJnZXRzKTtcblx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlMkRBcnJheShidWZmZXIsIHdpZHRoLCBoZWlnaHQsIG51bWJlck9mTW9ycGhUYXJnZXRzKTtcblx0XHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IFJHQkFGb3JtYXQ7IC8vIHVzaW5nIFJHQkEgc2luY2UgUkdCIG1pZ2h0IGJlIGVtdWxhdGVkIChhbmQgaXMgdGh1cyBzbG93ZXIpXG5cblx0XHRcdFx0XHR0ZXh0dXJlLnR5cGUgPSBGbG9hdFR5cGU7IC8vIGZpbGwgYnVmZmVyXG5cblx0XHRcdFx0XHRjb25zdCB2ZXJ0ZXhEYXRhU3RyaWRlID0gbnVtYmVyT2ZWZXJ0ZXhEYXRhICogNDtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZNb3JwaFRhcmdldHM7IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgbW9ycGhUYXJnZXQgPSBtb3JwaFRhcmdldHNbaV07XG5cdFx0XHRcdFx0XHRjb25zdCBtb3JwaE5vcm1hbCA9IG1vcnBoTm9ybWFsc1tpXTtcblx0XHRcdFx0XHRcdGNvbnN0IG9mZnNldCA9IHdpZHRoICogaGVpZ2h0ICogNCAqIGk7XG5cblx0XHRcdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgbW9ycGhUYXJnZXQuY291bnQ7IGorKykge1xuXHRcdFx0XHRcdFx0XHRtb3JwaC5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoVGFyZ2V0LCBqKTtcblx0XHRcdFx0XHRcdFx0aWYgKG1vcnBoVGFyZ2V0Lm5vcm1hbGl6ZWQgPT09IHRydWUpIGRlbm9ybWFsaXplKG1vcnBoLCBtb3JwaFRhcmdldCk7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHN0cmlkZSA9IGogKiB2ZXJ0ZXhEYXRhU3RyaWRlO1xuXHRcdFx0XHRcdFx0XHRidWZmZXJbb2Zmc2V0ICsgc3RyaWRlICsgMF0gPSBtb3JwaC54O1xuXHRcdFx0XHRcdFx0XHRidWZmZXJbb2Zmc2V0ICsgc3RyaWRlICsgMV0gPSBtb3JwaC55O1xuXHRcdFx0XHRcdFx0XHRidWZmZXJbb2Zmc2V0ICsgc3RyaWRlICsgMl0gPSBtb3JwaC56O1xuXHRcdFx0XHRcdFx0XHRidWZmZXJbb2Zmc2V0ICsgc3RyaWRlICsgM10gPSAwO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChoYXNNb3JwaE5vcm1hbHMgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0XHRtb3JwaC5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoTm9ybWFsLCBqKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAobW9ycGhOb3JtYWwubm9ybWFsaXplZCA9PT0gdHJ1ZSkgZGVub3JtYWxpemUobW9ycGgsIG1vcnBoTm9ybWFsKTtcblx0XHRcdFx0XHRcdFx0XHRidWZmZXJbb2Zmc2V0ICsgc3RyaWRlICsgNF0gPSBtb3JwaC54O1xuXHRcdFx0XHRcdFx0XHRcdGJ1ZmZlcltvZmZzZXQgKyBzdHJpZGUgKyA1XSA9IG1vcnBoLnk7XG5cdFx0XHRcdFx0XHRcdFx0YnVmZmVyW29mZnNldCArIHN0cmlkZSArIDZdID0gbW9ycGguejtcblx0XHRcdFx0XHRcdFx0XHRidWZmZXJbb2Zmc2V0ICsgc3RyaWRlICsgN10gPSAwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZW50cnkgPSB7XG5cdFx0XHRcdFx0XHRjb3VudDogbnVtYmVyT2ZNb3JwaFRhcmdldHMsXG5cdFx0XHRcdFx0XHR0ZXh0dXJlOiB0ZXh0dXJlLFxuXHRcdFx0XHRcdFx0c2l6ZTogbmV3IFZlY3RvcjIod2lkdGgsIGhlaWdodClcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdG1vcnBoVGV4dHVyZXMuc2V0KGdlb21ldHJ5LCBlbnRyeSk7XG5cdFx0XHRcdH0gLy9cblxuXG5cdFx0XHRcdGxldCBtb3JwaEluZmx1ZW5jZXNTdW0gPSAwO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgb2JqZWN0SW5mbHVlbmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdG1vcnBoSW5mbHVlbmNlc1N1bSArPSBvYmplY3RJbmZsdWVuY2VzW2ldO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgbW9ycGhCYXNlSW5mbHVlbmNlID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzUmVsYXRpdmUgPyAxIDogMSAtIG1vcnBoSW5mbHVlbmNlc1N1bTtcblx0XHRcdFx0cHJvZ3JhbS5nZXRVbmlmb3JtcygpLnNldFZhbHVlKGdsLCAnbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlJywgbW9ycGhCYXNlSW5mbHVlbmNlKTtcblx0XHRcdFx0cHJvZ3JhbS5nZXRVbmlmb3JtcygpLnNldFZhbHVlKGdsLCAnbW9ycGhUYXJnZXRJbmZsdWVuY2VzJywgb2JqZWN0SW5mbHVlbmNlcyk7XG5cdFx0XHRcdHByb2dyYW0uZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZShnbCwgJ21vcnBoVGFyZ2V0c1RleHR1cmUnLCBlbnRyeS50ZXh0dXJlLCB0ZXh0dXJlcyk7XG5cdFx0XHRcdHByb2dyYW0uZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZShnbCwgJ21vcnBoVGFyZ2V0c1RleHR1cmVTaXplJywgZW50cnkuc2l6ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBXaGVuIG9iamVjdCBkb2Vzbid0IGhhdmUgbW9ycGggdGFyZ2V0IGluZmx1ZW5jZXMgZGVmaW5lZCwgd2UgdHJlYXQgaXQgYXMgYSAwLWxlbmd0aCBhcnJheVxuXHRcdFx0XHQvLyBUaGlzIGlzIGltcG9ydGFudCB0byBtYWtlIHN1cmUgd2Ugc2V0IHVwIG1vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZSAvIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1xuXHRcdFx0XHRjb25zdCBsZW5ndGggPSBvYmplY3RJbmZsdWVuY2VzID09PSB1bmRlZmluZWQgPyAwIDogb2JqZWN0SW5mbHVlbmNlcy5sZW5ndGg7XG5cdFx0XHRcdGxldCBpbmZsdWVuY2VzID0gaW5mbHVlbmNlc0xpc3RbZ2VvbWV0cnkuaWRdO1xuXG5cdFx0XHRcdGlmIChpbmZsdWVuY2VzID09PSB1bmRlZmluZWQgfHwgaW5mbHVlbmNlcy5sZW5ndGggIT09IGxlbmd0aCkge1xuXHRcdFx0XHRcdC8vIGluaXRpYWxpc2UgbGlzdFxuXHRcdFx0XHRcdGluZmx1ZW5jZXMgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGluZmx1ZW5jZXNbaV0gPSBbaSwgMF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aW5mbHVlbmNlc0xpc3RbZ2VvbWV0cnkuaWRdID0gaW5mbHVlbmNlcztcblx0XHRcdFx0fSAvLyBDb2xsZWN0IGluZmx1ZW5jZXNcblxuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBpbmZsdWVuY2UgPSBpbmZsdWVuY2VzW2ldO1xuXHRcdFx0XHRcdGluZmx1ZW5jZVswXSA9IGk7XG5cdFx0XHRcdFx0aW5mbHVlbmNlWzFdID0gb2JqZWN0SW5mbHVlbmNlc1tpXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGluZmx1ZW5jZXMuc29ydChhYnNOdW1lcmljYWxTb3J0KTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykge1xuXHRcdFx0XHRcdGlmIChpIDwgbGVuZ3RoICYmIGluZmx1ZW5jZXNbaV1bMV0pIHtcblx0XHRcdFx0XHRcdHdvcmtJbmZsdWVuY2VzW2ldWzBdID0gaW5mbHVlbmNlc1tpXVswXTtcblx0XHRcdFx0XHRcdHdvcmtJbmZsdWVuY2VzW2ldWzFdID0gaW5mbHVlbmNlc1tpXVsxXTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0d29ya0luZmx1ZW5jZXNbaV1bMF0gPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcblx0XHRcdFx0XHRcdHdvcmtJbmZsdWVuY2VzW2ldWzFdID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3b3JrSW5mbHVlbmNlcy5zb3J0KG51bWVyaWNhbFNvcnQpO1xuXHRcdFx0XHRjb25zdCBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRcdGNvbnN0IG1vcnBoTm9ybWFscyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWw7XG5cdFx0XHRcdGxldCBtb3JwaEluZmx1ZW5jZXNTdW0gPSAwO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgaW5mbHVlbmNlID0gd29ya0luZmx1ZW5jZXNbaV07XG5cdFx0XHRcdFx0Y29uc3QgaW5kZXggPSBpbmZsdWVuY2VbMF07XG5cdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSBpbmZsdWVuY2VbMV07XG5cblx0XHRcdFx0XHRpZiAoaW5kZXggIT09IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSICYmIHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRpZiAobW9ycGhUYXJnZXRzICYmIGdlb21ldHJ5LmdldEF0dHJpYnV0ZSgnbW9ycGhUYXJnZXQnICsgaSkgIT09IG1vcnBoVGFyZ2V0c1tpbmRleF0pIHtcblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdtb3JwaFRhcmdldCcgKyBpLCBtb3JwaFRhcmdldHNbaW5kZXhdKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKG1vcnBoTm9ybWFscyAmJiBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ21vcnBoTm9ybWFsJyArIGkpICE9PSBtb3JwaE5vcm1hbHNbaW5kZXhdKSB7XG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnbW9ycGhOb3JtYWwnICsgaSwgbW9ycGhOb3JtYWxzW2luZGV4XSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG1vcnBoSW5mbHVlbmNlc1tpXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0bW9ycGhJbmZsdWVuY2VzU3VtICs9IHZhbHVlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAobW9ycGhUYXJnZXRzICYmIGdlb21ldHJ5Lmhhc0F0dHJpYnV0ZSgnbW9ycGhUYXJnZXQnICsgaSkgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkuZGVsZXRlQXR0cmlidXRlKCdtb3JwaFRhcmdldCcgKyBpKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKG1vcnBoTm9ybWFscyAmJiBnZW9tZXRyeS5oYXNBdHRyaWJ1dGUoJ21vcnBoTm9ybWFsJyArIGkpID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5LmRlbGV0ZUF0dHJpYnV0ZSgnbW9ycGhOb3JtYWwnICsgaSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG1vcnBoSW5mbHVlbmNlc1tpXSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IC8vIEdMU0wgc2hhZGVyIHVzZXMgZm9ybXVsYSBiYXNlaW5mbHVlbmNlICogYmFzZSArIHN1bSh0YXJnZXQgKiBpbmZsdWVuY2UpXG5cdFx0XHRcdC8vIFRoaXMgYWxsb3dzIHVzIHRvIHN3aXRjaCBiZXR3ZWVuIGFic29sdXRlIG1vcnBocyBhbmQgcmVsYXRpdmUgbW9ycGhzIHdpdGhvdXQgY2hhbmdpbmcgc2hhZGVyIGNvZGVcblx0XHRcdFx0Ly8gV2hlbiBiYXNlaW5mbHVlbmNlID0gMSAtIHN1bShpbmZsdWVuY2UpLCB0aGUgYWJvdmUgaXMgZXF1aXZhbGVudCB0byBzdW0oKHRhcmdldCAtIGJhc2UpICogaW5mbHVlbmNlKVxuXG5cblx0XHRcdFx0Y29uc3QgbW9ycGhCYXNlSW5mbHVlbmNlID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzUmVsYXRpdmUgPyAxIDogMSAtIG1vcnBoSW5mbHVlbmNlc1N1bTtcblx0XHRcdFx0cHJvZ3JhbS5nZXRVbmlmb3JtcygpLnNldFZhbHVlKGdsLCAnbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlJywgbW9ycGhCYXNlSW5mbHVlbmNlKTtcblx0XHRcdFx0cHJvZ3JhbS5nZXRVbmlmb3JtcygpLnNldFZhbHVlKGdsLCAnbW9ycGhUYXJnZXRJbmZsdWVuY2VzJywgbW9ycGhJbmZsdWVuY2VzKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dXBkYXRlOiB1cGRhdGVcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gV2ViR0xPYmplY3RzKGdsLCBnZW9tZXRyaWVzLCBhdHRyaWJ1dGVzLCBpbmZvKSB7XG5cdFx0bGV0IHVwZGF0ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cblx0XHRmdW5jdGlvbiB1cGRhdGUob2JqZWN0KSB7XG5cdFx0XHRjb25zdCBmcmFtZSA9IGluZm8ucmVuZGVyLmZyYW1lO1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cdFx0XHRjb25zdCBidWZmZXJnZW9tZXRyeSA9IGdlb21ldHJpZXMuZ2V0KG9iamVjdCwgZ2VvbWV0cnkpOyAvLyBVcGRhdGUgb25jZSBwZXIgZnJhbWVcblxuXHRcdFx0aWYgKHVwZGF0ZU1hcC5nZXQoYnVmZmVyZ2VvbWV0cnkpICE9PSBmcmFtZSkge1xuXHRcdFx0XHRnZW9tZXRyaWVzLnVwZGF0ZShidWZmZXJnZW9tZXRyeSk7XG5cdFx0XHRcdHVwZGF0ZU1hcC5zZXQoYnVmZmVyZ2VvbWV0cnksIGZyYW1lKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9iamVjdC5pc0luc3RhbmNlZE1lc2gpIHtcblx0XHRcdFx0aWYgKG9iamVjdC5oYXNFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25JbnN0YW5jZWRNZXNoRGlzcG9zZSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0b2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvbkluc3RhbmNlZE1lc2hEaXNwb3NlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGF0dHJpYnV0ZXMudXBkYXRlKG9iamVjdC5pbnN0YW5jZU1hdHJpeCwgZ2wuQVJSQVlfQlVGRkVSKTtcblxuXHRcdFx0XHRpZiAob2JqZWN0Lmluc3RhbmNlQ29sb3IgIT09IG51bGwpIHtcblx0XHRcdFx0XHRhdHRyaWJ1dGVzLnVwZGF0ZShvYmplY3QuaW5zdGFuY2VDb2xvciwgZ2wuQVJSQVlfQlVGRkVSKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYnVmZmVyZ2VvbWV0cnk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGlzcG9zZSgpIHtcblx0XHRcdHVwZGF0ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25JbnN0YW5jZWRNZXNoRGlzcG9zZShldmVudCkge1xuXHRcdFx0Y29uc3QgaW5zdGFuY2VkTWVzaCA9IGV2ZW50LnRhcmdldDtcblx0XHRcdGluc3RhbmNlZE1lc2gucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uSW5zdGFuY2VkTWVzaERpc3Bvc2UpO1xuXHRcdFx0YXR0cmlidXRlcy5yZW1vdmUoaW5zdGFuY2VkTWVzaC5pbnN0YW5jZU1hdHJpeCk7XG5cdFx0XHRpZiAoaW5zdGFuY2VkTWVzaC5pbnN0YW5jZUNvbG9yICE9PSBudWxsKSBhdHRyaWJ1dGVzLnJlbW92ZShpbnN0YW5jZWRNZXNoLmluc3RhbmNlQ29sb3IpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR1cGRhdGU6IHVwZGF0ZSxcblx0XHRcdGRpc3Bvc2U6IGRpc3Bvc2Vcblx0XHR9O1xuXHR9XG5cblx0Y2xhc3MgRGF0YVRleHR1cmUzRCBleHRlbmRzIFRleHR1cmUge1xuXHRcdGNvbnN0cnVjdG9yKGRhdGEgPSBudWxsLCB3aWR0aCA9IDEsIGhlaWdodCA9IDEsIGRlcHRoID0gMSkge1xuXHRcdFx0Ly8gV2UncmUgZ29pbmcgdG8gYWRkIC5zZXRYWFgoKSBtZXRob2RzIGZvciBzZXR0aW5nIHByb3BlcnRpZXMgbGF0ZXIuXG5cdFx0XHQvLyBVc2VycyBjYW4gc3RpbGwgc2V0IGluIERhdGFUZXh0dXJlM0QgZGlyZWN0bHkuXG5cdFx0XHQvL1xuXHRcdFx0Ly9cdGNvbnN0IHRleHR1cmUgPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUzRCggZGF0YSwgd2lkdGgsIGhlaWdodCwgZGVwdGggKTtcblx0XHRcdC8vIFx0dGV4dHVyZS5hbmlzb3Ryb3B5ID0gMTY7XG5cdFx0XHQvL1xuXHRcdFx0Ly8gU2VlICMxNDgzOVxuXHRcdFx0c3VwZXIobnVsbCk7XG5cdFx0XHR0aGlzLmltYWdlID0ge1xuXHRcdFx0XHRkYXRhLFxuXHRcdFx0XHR3aWR0aCxcblx0XHRcdFx0aGVpZ2h0LFxuXHRcdFx0XHRkZXB0aFxuXHRcdFx0fTtcblx0XHRcdHRoaXMubWFnRmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcblx0XHRcdHRoaXMubWluRmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcblx0XHRcdHRoaXMud3JhcFIgPSBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuXHRcdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblx0XHRcdHRoaXMuZmxpcFkgPSBmYWxzZTtcblx0XHRcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gMTtcblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdH1cblxuXHR9XG5cblx0RGF0YVRleHR1cmUzRC5wcm90b3R5cGUuaXNEYXRhVGV4dHVyZTNEID0gdHJ1ZTtcblxuXHQvKipcblx0ICogVW5pZm9ybXMgb2YgYSBwcm9ncmFtLlxuXHQgKiBUaG9zZSBmb3JtIGEgdHJlZSBzdHJ1Y3R1cmUgd2l0aCBhIHNwZWNpYWwgdG9wLWxldmVsIGNvbnRhaW5lciBmb3IgdGhlIHJvb3QsXG5cdCAqIHdoaWNoIHlvdSBnZXQgYnkgY2FsbGluZyAnbmV3IFdlYkdMVW5pZm9ybXMoIGdsLCBwcm9ncmFtICknLlxuXHQgKlxuXHQgKlxuXHQgKiBQcm9wZXJ0aWVzIG9mIGlubmVyIG5vZGVzIGluY2x1ZGluZyB0aGUgdG9wLWxldmVsIGNvbnRhaW5lcjpcblx0ICpcblx0ICogLnNlcSAtIGFycmF5IG9mIG5lc3RlZCB1bmlmb3Jtc1xuXHQgKiAubWFwIC0gbmVzdGVkIHVuaWZvcm1zIGJ5IG5hbWVcblx0ICpcblx0ICpcblx0ICogTWV0aG9kcyBvZiBhbGwgbm9kZXMgZXhjZXB0IHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyOlxuXHQgKlxuXHQgKiAuc2V0VmFsdWUoIGdsLCB2YWx1ZSwgW3RleHR1cmVzXSApXG5cdCAqXG5cdCAqIFx0XHR1cGxvYWRzIGEgdW5pZm9ybSB2YWx1ZShzKVxuXHQgKlx0XHR0aGUgJ3RleHR1cmVzJyBwYXJhbWV0ZXIgaXMgbmVlZGVkIGZvciBzYW1wbGVyIHVuaWZvcm1zXG5cdCAqXG5cdCAqXG5cdCAqIFN0YXRpYyBtZXRob2RzIG9mIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyICh0ZXh0dXJlcyBmYWN0b3JpemF0aW9ucyk6XG5cdCAqXG5cdCAqIC51cGxvYWQoIGdsLCBzZXEsIHZhbHVlcywgdGV4dHVyZXMgKVxuXHQgKlxuXHQgKiBcdFx0c2V0cyB1bmlmb3JtcyBpbiAnc2VxJyB0byAndmFsdWVzW2lkXS52YWx1ZSdcblx0ICpcblx0ICogLnNlcVdpdGhWYWx1ZSggc2VxLCB2YWx1ZXMgKSA6IGZpbHRlcmVkU2VxXG5cdCAqXG5cdCAqIFx0XHRmaWx0ZXJzICdzZXEnIGVudHJpZXMgd2l0aCBjb3JyZXNwb25kaW5nIGVudHJ5IGluIHZhbHVlc1xuXHQgKlxuXHQgKlxuXHQgKiBNZXRob2RzIG9mIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyICh0ZXh0dXJlcyBmYWN0b3JpemF0aW9ucyk6XG5cdCAqXG5cdCAqIC5zZXRWYWx1ZSggZ2wsIG5hbWUsIHZhbHVlLCB0ZXh0dXJlcyApXG5cdCAqXG5cdCAqIFx0XHRzZXRzIHVuaWZvcm0gd2l0aFx0bmFtZSAnbmFtZScgdG8gJ3ZhbHVlJ1xuXHQgKlxuXHQgKiAuc2V0T3B0aW9uYWwoIGdsLCBvYmosIHByb3AgKVxuXHQgKlxuXHQgKiBcdFx0bGlrZSAuc2V0IGZvciBhbiBvcHRpb25hbCBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0XG5cdCAqXG5cdCAqL1xuXHRjb25zdCBlbXB0eVRleHR1cmUgPSBuZXcgVGV4dHVyZSgpO1xuXHRjb25zdCBlbXB0eVRleHR1cmUyZEFycmF5ID0gbmV3IERhdGFUZXh0dXJlMkRBcnJheSgpO1xuXHRjb25zdCBlbXB0eVRleHR1cmUzZCA9IG5ldyBEYXRhVGV4dHVyZTNEKCk7XG5cdGNvbnN0IGVtcHR5Q3ViZVRleHR1cmUgPSBuZXcgQ3ViZVRleHR1cmUoKTsgLy8gLS0tIFV0aWxpdGllcyAtLS1cblx0Ly8gQXJyYXkgQ2FjaGVzIChwcm92aWRlIHR5cGVkIGFycmF5cyBmb3IgdGVtcG9yYXJ5IGJ5IHNpemUpXG5cblx0Y29uc3QgYXJyYXlDYWNoZUYzMiA9IFtdO1xuXHRjb25zdCBhcnJheUNhY2hlSTMyID0gW107IC8vIEZsb2F0MzJBcnJheSBjYWNoZXMgdXNlZCBmb3IgdXBsb2FkaW5nIE1hdHJpeCB1bmlmb3Jtc1xuXG5cdGNvbnN0IG1hdDRhcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuXHRjb25zdCBtYXQzYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDkpO1xuXHRjb25zdCBtYXQyYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDQpOyAvLyBGbGF0dGVuaW5nIGZvciBhcnJheXMgb2YgdmVjdG9ycyBhbmQgbWF0cmljZXNcblxuXHRmdW5jdGlvbiBmbGF0dGVuKGFycmF5LCBuQmxvY2tzLCBibG9ja1NpemUpIHtcblx0XHRjb25zdCBmaXJzdEVsZW0gPSBhcnJheVswXTtcblx0XHRpZiAoZmlyc3RFbGVtIDw9IDAgfHwgZmlyc3RFbGVtID4gMCkgcmV0dXJuIGFycmF5OyAvLyB1bm9wdGltaXplZDogISBpc05hTiggZmlyc3RFbGVtIClcblx0XHQvLyBzZWUgaHR0cDovL2phY2tzb25kdW5zdGFuLmNvbS9hcnRpY2xlcy85ODNcblxuXHRcdGNvbnN0IG4gPSBuQmxvY2tzICogYmxvY2tTaXplO1xuXHRcdGxldCByID0gYXJyYXlDYWNoZUYzMltuXTtcblxuXHRcdGlmIChyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHIgPSBuZXcgRmxvYXQzMkFycmF5KG4pO1xuXHRcdFx0YXJyYXlDYWNoZUYzMltuXSA9IHI7XG5cdFx0fVxuXG5cdFx0aWYgKG5CbG9ja3MgIT09IDApIHtcblx0XHRcdGZpcnN0RWxlbS50b0FycmF5KHIsIDApO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMSwgb2Zmc2V0ID0gMDsgaSAhPT0gbkJsb2NrczsgKytpKSB7XG5cdFx0XHRcdG9mZnNldCArPSBibG9ja1NpemU7XG5cdFx0XHRcdGFycmF5W2ldLnRvQXJyYXkociwgb2Zmc2V0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcjtcblx0fVxuXG5cdGZ1bmN0aW9uIGFycmF5c0VxdWFsKGEsIGIpIHtcblx0XHRpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29weUFycmF5KGEsIGIpIHtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRhW2ldID0gYltpXTtcblx0XHR9XG5cdH0gLy8gVGV4dHVyZSB1bml0IGFsbG9jYXRpb25cblxuXG5cdGZ1bmN0aW9uIGFsbG9jVGV4VW5pdHModGV4dHVyZXMsIG4pIHtcblx0XHRsZXQgciA9IGFycmF5Q2FjaGVJMzJbbl07XG5cblx0XHRpZiAociA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyID0gbmV3IEludDMyQXJyYXkobik7XG5cdFx0XHRhcnJheUNhY2hlSTMyW25dID0gcjtcblx0XHR9XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRyW2ldID0gdGV4dHVyZXMuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO1xuXHRcdH1cblxuXHRcdHJldHVybiByO1xuXHR9IC8vIC0tLSBTZXR0ZXJzIC0tLVxuXHQvLyBOb3RlOiBEZWZpbmluZyB0aGVzZSBtZXRob2RzIGV4dGVybmFsbHksIGJlY2F1c2UgdGhleSBjb21lIGluIGEgYnVuY2hcblx0Ly8gYW5kIHRoaXMgd2F5IHRoZWlyIG5hbWVzIG1pbmlmeS5cblx0Ly8gU2luZ2xlIHNjYWxhclxuXG5cblx0ZnVuY3Rpb24gc2V0VmFsdWVWMWYoZ2wsIHYpIHtcblx0XHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cdFx0aWYgKGNhY2hlWzBdID09PSB2KSByZXR1cm47XG5cdFx0Z2wudW5pZm9ybTFmKHRoaXMuYWRkciwgdik7XG5cdFx0Y2FjaGVbMF0gPSB2O1xuXHR9IC8vIFNpbmdsZSBmbG9hdCB2ZWN0b3IgKGZyb20gZmxhdCBhcnJheSBvciBUSFJFRS5WZWN0b3JOKVxuXG5cblx0ZnVuY3Rpb24gc2V0VmFsdWVWMmYoZ2wsIHYpIHtcblx0XHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cblx0XHRpZiAodi54ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmIChjYWNoZVswXSAhPT0gdi54IHx8IGNhY2hlWzFdICE9PSB2LnkpIHtcblx0XHRcdFx0Z2wudW5pZm9ybTJmKHRoaXMuYWRkciwgdi54LCB2LnkpO1xuXHRcdFx0XHRjYWNoZVswXSA9IHYueDtcblx0XHRcdFx0Y2FjaGVbMV0gPSB2Lnk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChhcnJheXNFcXVhbChjYWNoZSwgdikpIHJldHVybjtcblx0XHRcdGdsLnVuaWZvcm0yZnYodGhpcy5hZGRyLCB2KTtcblx0XHRcdGNvcHlBcnJheShjYWNoZSwgdik7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0VmFsdWVWM2YoZ2wsIHYpIHtcblx0XHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cblx0XHRpZiAodi54ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmIChjYWNoZVswXSAhPT0gdi54IHx8IGNhY2hlWzFdICE9PSB2LnkgfHwgY2FjaGVbMl0gIT09IHYueikge1xuXHRcdFx0XHRnbC51bmlmb3JtM2YodGhpcy5hZGRyLCB2LngsIHYueSwgdi56KTtcblx0XHRcdFx0Y2FjaGVbMF0gPSB2Lng7XG5cdFx0XHRcdGNhY2hlWzFdID0gdi55O1xuXHRcdFx0XHRjYWNoZVsyXSA9IHYuejtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHYuciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZiAoY2FjaGVbMF0gIT09IHYuciB8fCBjYWNoZVsxXSAhPT0gdi5nIHx8IGNhY2hlWzJdICE9PSB2LmIpIHtcblx0XHRcdFx0Z2wudW5pZm9ybTNmKHRoaXMuYWRkciwgdi5yLCB2LmcsIHYuYik7XG5cdFx0XHRcdGNhY2hlWzBdID0gdi5yO1xuXHRcdFx0XHRjYWNoZVsxXSA9IHYuZztcblx0XHRcdFx0Y2FjaGVbMl0gPSB2LmI7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChhcnJheXNFcXVhbChjYWNoZSwgdikpIHJldHVybjtcblx0XHRcdGdsLnVuaWZvcm0zZnYodGhpcy5hZGRyLCB2KTtcblx0XHRcdGNvcHlBcnJheShjYWNoZSwgdik7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0VmFsdWVWNGYoZ2wsIHYpIHtcblx0XHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cblx0XHRpZiAodi54ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmIChjYWNoZVswXSAhPT0gdi54IHx8IGNhY2hlWzFdICE9PSB2LnkgfHwgY2FjaGVbMl0gIT09IHYueiB8fCBjYWNoZVszXSAhPT0gdi53KSB7XG5cdFx0XHRcdGdsLnVuaWZvcm00Zih0aGlzLmFkZHIsIHYueCwgdi55LCB2LnosIHYudyk7XG5cdFx0XHRcdGNhY2hlWzBdID0gdi54O1xuXHRcdFx0XHRjYWNoZVsxXSA9IHYueTtcblx0XHRcdFx0Y2FjaGVbMl0gPSB2Lno7XG5cdFx0XHRcdGNhY2hlWzNdID0gdi53O1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoYXJyYXlzRXF1YWwoY2FjaGUsIHYpKSByZXR1cm47XG5cdFx0XHRnbC51bmlmb3JtNGZ2KHRoaXMuYWRkciwgdik7XG5cdFx0XHRjb3B5QXJyYXkoY2FjaGUsIHYpO1xuXHRcdH1cblx0fSAvLyBTaW5nbGUgbWF0cml4IChmcm9tIGZsYXQgYXJyYXkgb3IgVEhSRUUuTWF0cml4TilcblxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlTTIoZ2wsIHYpIHtcblx0XHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cdFx0Y29uc3QgZWxlbWVudHMgPSB2LmVsZW1lbnRzO1xuXG5cdFx0aWYgKGVsZW1lbnRzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmIChhcnJheXNFcXVhbChjYWNoZSwgdikpIHJldHVybjtcblx0XHRcdGdsLnVuaWZvcm1NYXRyaXgyZnYodGhpcy5hZGRyLCBmYWxzZSwgdik7XG5cdFx0XHRjb3B5QXJyYXkoY2FjaGUsIHYpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoYXJyYXlzRXF1YWwoY2FjaGUsIGVsZW1lbnRzKSkgcmV0dXJuO1xuXHRcdFx0bWF0MmFycmF5LnNldChlbGVtZW50cyk7XG5cdFx0XHRnbC51bmlmb3JtTWF0cml4MmZ2KHRoaXMuYWRkciwgZmFsc2UsIG1hdDJhcnJheSk7XG5cdFx0XHRjb3B5QXJyYXkoY2FjaGUsIGVsZW1lbnRzKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZU0zKGdsLCB2KSB7XG5cdFx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRcdGNvbnN0IGVsZW1lbnRzID0gdi5lbGVtZW50cztcblxuXHRcdGlmIChlbGVtZW50cyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZiAoYXJyYXlzRXF1YWwoY2FjaGUsIHYpKSByZXR1cm47XG5cdFx0XHRnbC51bmlmb3JtTWF0cml4M2Z2KHRoaXMuYWRkciwgZmFsc2UsIHYpO1xuXHRcdFx0Y29weUFycmF5KGNhY2hlLCB2KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGFycmF5c0VxdWFsKGNhY2hlLCBlbGVtZW50cykpIHJldHVybjtcblx0XHRcdG1hdDNhcnJheS5zZXQoZWxlbWVudHMpO1xuXHRcdFx0Z2wudW5pZm9ybU1hdHJpeDNmdih0aGlzLmFkZHIsIGZhbHNlLCBtYXQzYXJyYXkpO1xuXHRcdFx0Y29weUFycmF5KGNhY2hlLCBlbGVtZW50cyk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0VmFsdWVNNChnbCwgdikge1xuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0XHRjb25zdCBlbGVtZW50cyA9IHYuZWxlbWVudHM7XG5cblx0XHRpZiAoZWxlbWVudHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYgKGFycmF5c0VxdWFsKGNhY2hlLCB2KSkgcmV0dXJuO1xuXHRcdFx0Z2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLmFkZHIsIGZhbHNlLCB2KTtcblx0XHRcdGNvcHlBcnJheShjYWNoZSwgdik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChhcnJheXNFcXVhbChjYWNoZSwgZWxlbWVudHMpKSByZXR1cm47XG5cdFx0XHRtYXQ0YXJyYXkuc2V0KGVsZW1lbnRzKTtcblx0XHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5hZGRyLCBmYWxzZSwgbWF0NGFycmF5KTtcblx0XHRcdGNvcHlBcnJheShjYWNoZSwgZWxlbWVudHMpO1xuXHRcdH1cblx0fSAvLyBTaW5nbGUgaW50ZWdlciAvIGJvb2xlYW5cblxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVjFpKGdsLCB2KSB7XG5cdFx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRcdGlmIChjYWNoZVswXSA9PT0gdikgcmV0dXJuO1xuXHRcdGdsLnVuaWZvcm0xaSh0aGlzLmFkZHIsIHYpO1xuXHRcdGNhY2hlWzBdID0gdjtcblx0fSAvLyBTaW5nbGUgaW50ZWdlciAvIGJvb2xlYW4gdmVjdG9yIChmcm9tIGZsYXQgYXJyYXkpXG5cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZVYyaShnbCwgdikge1xuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0XHRpZiAoYXJyYXlzRXF1YWwoY2FjaGUsIHYpKSByZXR1cm47XG5cdFx0Z2wudW5pZm9ybTJpdih0aGlzLmFkZHIsIHYpO1xuXHRcdGNvcHlBcnJheShjYWNoZSwgdik7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZVYzaShnbCwgdikge1xuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0XHRpZiAoYXJyYXlzRXF1YWwoY2FjaGUsIHYpKSByZXR1cm47XG5cdFx0Z2wudW5pZm9ybTNpdih0aGlzLmFkZHIsIHYpO1xuXHRcdGNvcHlBcnJheShjYWNoZSwgdik7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZVY0aShnbCwgdikge1xuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0XHRpZiAoYXJyYXlzRXF1YWwoY2FjaGUsIHYpKSByZXR1cm47XG5cdFx0Z2wudW5pZm9ybTRpdih0aGlzLmFkZHIsIHYpO1xuXHRcdGNvcHlBcnJheShjYWNoZSwgdik7XG5cdH0gLy8gU2luZ2xlIHVuc2lnbmVkIGludGVnZXJcblxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVjF1aShnbCwgdikge1xuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0XHRpZiAoY2FjaGVbMF0gPT09IHYpIHJldHVybjtcblx0XHRnbC51bmlmb3JtMXVpKHRoaXMuYWRkciwgdik7XG5cdFx0Y2FjaGVbMF0gPSB2O1xuXHR9IC8vIFNpbmdsZSB1bnNpZ25lZCBpbnRlZ2VyIHZlY3RvciAoZnJvbSBmbGF0IGFycmF5KVxuXG5cblx0ZnVuY3Rpb24gc2V0VmFsdWVWMnVpKGdsLCB2KSB7XG5cdFx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXHRcdGlmIChhcnJheXNFcXVhbChjYWNoZSwgdikpIHJldHVybjtcblx0XHRnbC51bmlmb3JtMnVpdih0aGlzLmFkZHIsIHYpO1xuXHRcdGNvcHlBcnJheShjYWNoZSwgdik7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZVYzdWkoZ2wsIHYpIHtcblx0XHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cdFx0aWYgKGFycmF5c0VxdWFsKGNhY2hlLCB2KSkgcmV0dXJuO1xuXHRcdGdsLnVuaWZvcm0zdWl2KHRoaXMuYWRkciwgdik7XG5cdFx0Y29weUFycmF5KGNhY2hlLCB2KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVjR1aShnbCwgdikge1xuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0XHRpZiAoYXJyYXlzRXF1YWwoY2FjaGUsIHYpKSByZXR1cm47XG5cdFx0Z2wudW5pZm9ybTR1aXYodGhpcy5hZGRyLCB2KTtcblx0XHRjb3B5QXJyYXkoY2FjaGUsIHYpO1xuXHR9IC8vIFNpbmdsZSB0ZXh0dXJlICgyRCAvIEN1YmUpXG5cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZVQxKGdsLCB2LCB0ZXh0dXJlcykge1xuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblx0XHRjb25zdCB1bml0ID0gdGV4dHVyZXMuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO1xuXG5cdFx0aWYgKGNhY2hlWzBdICE9PSB1bml0KSB7XG5cdFx0XHRnbC51bmlmb3JtMWkodGhpcy5hZGRyLCB1bml0KTtcblx0XHRcdGNhY2hlWzBdID0gdW5pdDtcblx0XHR9XG5cblx0XHR0ZXh0dXJlcy5zYWZlU2V0VGV4dHVyZTJEKHYgfHwgZW1wdHlUZXh0dXJlLCB1bml0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVDNEMShnbCwgdiwgdGV4dHVyZXMpIHtcblx0XHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cdFx0Y29uc3QgdW5pdCA9IHRleHR1cmVzLmFsbG9jYXRlVGV4dHVyZVVuaXQoKTtcblxuXHRcdGlmIChjYWNoZVswXSAhPT0gdW5pdCkge1xuXHRcdFx0Z2wudW5pZm9ybTFpKHRoaXMuYWRkciwgdW5pdCk7XG5cdFx0XHRjYWNoZVswXSA9IHVuaXQ7XG5cdFx0fVxuXG5cdFx0dGV4dHVyZXMuc2V0VGV4dHVyZTNEKHYgfHwgZW1wdHlUZXh0dXJlM2QsIHVuaXQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0VmFsdWVUNihnbCwgdiwgdGV4dHVyZXMpIHtcblx0XHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cdFx0Y29uc3QgdW5pdCA9IHRleHR1cmVzLmFsbG9jYXRlVGV4dHVyZVVuaXQoKTtcblxuXHRcdGlmIChjYWNoZVswXSAhPT0gdW5pdCkge1xuXHRcdFx0Z2wudW5pZm9ybTFpKHRoaXMuYWRkciwgdW5pdCk7XG5cdFx0XHRjYWNoZVswXSA9IHVuaXQ7XG5cdFx0fVxuXG5cdFx0dGV4dHVyZXMuc2FmZVNldFRleHR1cmVDdWJlKHYgfHwgZW1wdHlDdWJlVGV4dHVyZSwgdW5pdCk7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZVQyREFycmF5MShnbCwgdiwgdGV4dHVyZXMpIHtcblx0XHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cdFx0Y29uc3QgdW5pdCA9IHRleHR1cmVzLmFsbG9jYXRlVGV4dHVyZVVuaXQoKTtcblxuXHRcdGlmIChjYWNoZVswXSAhPT0gdW5pdCkge1xuXHRcdFx0Z2wudW5pZm9ybTFpKHRoaXMuYWRkciwgdW5pdCk7XG5cdFx0XHRjYWNoZVswXSA9IHVuaXQ7XG5cdFx0fVxuXG5cdFx0dGV4dHVyZXMuc2V0VGV4dHVyZTJEQXJyYXkodiB8fCBlbXB0eVRleHR1cmUyZEFycmF5LCB1bml0KTtcblx0fSAvLyBIZWxwZXIgdG8gcGljayB0aGUgcmlnaHQgc2V0dGVyIGZvciB0aGUgc2luZ3VsYXIgY2FzZVxuXG5cblx0ZnVuY3Rpb24gZ2V0U2luZ3VsYXJTZXR0ZXIodHlwZSkge1xuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSAweDE0MDY6XG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZVYxZjtcblx0XHRcdC8vIEZMT0FUXG5cblx0XHRcdGNhc2UgMHg4YjUwOlxuXHRcdFx0XHRyZXR1cm4gc2V0VmFsdWVWMmY7XG5cdFx0XHQvLyBfVkVDMlxuXG5cdFx0XHRjYXNlIDB4OGI1MTpcblx0XHRcdFx0cmV0dXJuIHNldFZhbHVlVjNmO1xuXHRcdFx0Ly8gX1ZFQzNcblxuXHRcdFx0Y2FzZSAweDhiNTI6XG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZVY0Zjtcblx0XHRcdC8vIF9WRUM0XG5cblx0XHRcdGNhc2UgMHg4YjVhOlxuXHRcdFx0XHRyZXR1cm4gc2V0VmFsdWVNMjtcblx0XHRcdC8vIF9NQVQyXG5cblx0XHRcdGNhc2UgMHg4YjViOlxuXHRcdFx0XHRyZXR1cm4gc2V0VmFsdWVNMztcblx0XHRcdC8vIF9NQVQzXG5cblx0XHRcdGNhc2UgMHg4YjVjOlxuXHRcdFx0XHRyZXR1cm4gc2V0VmFsdWVNNDtcblx0XHRcdC8vIF9NQVQ0XG5cblx0XHRcdGNhc2UgMHgxNDA0OlxuXHRcdFx0Y2FzZSAweDhiNTY6XG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZVYxaTtcblx0XHRcdC8vIElOVCwgQk9PTFxuXG5cdFx0XHRjYXNlIDB4OGI1Mzpcblx0XHRcdGNhc2UgMHg4YjU3OlxuXHRcdFx0XHRyZXR1cm4gc2V0VmFsdWVWMmk7XG5cdFx0XHQvLyBfVkVDMlxuXG5cdFx0XHRjYXNlIDB4OGI1NDpcblx0XHRcdGNhc2UgMHg4YjU4OlxuXHRcdFx0XHRyZXR1cm4gc2V0VmFsdWVWM2k7XG5cdFx0XHQvLyBfVkVDM1xuXG5cdFx0XHRjYXNlIDB4OGI1NTpcblx0XHRcdGNhc2UgMHg4YjU5OlxuXHRcdFx0XHRyZXR1cm4gc2V0VmFsdWVWNGk7XG5cdFx0XHQvLyBfVkVDNFxuXG5cdFx0XHRjYXNlIDB4MTQwNTpcblx0XHRcdFx0cmV0dXJuIHNldFZhbHVlVjF1aTtcblx0XHRcdC8vIFVJTlRcblxuXHRcdFx0Y2FzZSAweDhkYzY6XG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZVYydWk7XG5cdFx0XHQvLyBfVkVDMlxuXG5cdFx0XHRjYXNlIDB4OGRjNzpcblx0XHRcdFx0cmV0dXJuIHNldFZhbHVlVjN1aTtcblx0XHRcdC8vIF9WRUMzXG5cblx0XHRcdGNhc2UgMHg4ZGM4OlxuXHRcdFx0XHRyZXR1cm4gc2V0VmFsdWVWNHVpO1xuXHRcdFx0Ly8gX1ZFQzRcblxuXHRcdFx0Y2FzZSAweDhiNWU6IC8vIFNBTVBMRVJfMkRcblxuXHRcdFx0Y2FzZSAweDhkNjY6IC8vIFNBTVBMRVJfRVhURVJOQUxfT0VTXG5cblx0XHRcdGNhc2UgMHg4ZGNhOiAvLyBJTlRfU0FNUExFUl8yRFxuXG5cdFx0XHRjYXNlIDB4OGRkMjogLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfMkRcblxuXHRcdFx0Y2FzZSAweDhiNjI6XG5cdFx0XHRcdC8vIFNBTVBMRVJfMkRfU0hBRE9XXG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZVQxO1xuXG5cdFx0XHRjYXNlIDB4OGI1ZjogLy8gU0FNUExFUl8zRFxuXG5cdFx0XHRjYXNlIDB4OGRjYjogLy8gSU5UX1NBTVBMRVJfM0RcblxuXHRcdFx0Y2FzZSAweDhkZDM6XG5cdFx0XHRcdC8vIFVOU0lHTkVEX0lOVF9TQU1QTEVSXzNEXG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZVQzRDE7XG5cblx0XHRcdGNhc2UgMHg4YjYwOiAvLyBTQU1QTEVSX0NVQkVcblxuXHRcdFx0Y2FzZSAweDhkY2M6IC8vIElOVF9TQU1QTEVSX0NVQkVcblxuXHRcdFx0Y2FzZSAweDhkZDQ6IC8vIFVOU0lHTkVEX0lOVF9TQU1QTEVSX0NVQkVcblxuXHRcdFx0Y2FzZSAweDhkYzU6XG5cdFx0XHRcdC8vIFNBTVBMRVJfQ1VCRV9TSEFET1dcblx0XHRcdFx0cmV0dXJuIHNldFZhbHVlVDY7XG5cblx0XHRcdGNhc2UgMHg4ZGMxOiAvLyBTQU1QTEVSXzJEX0FSUkFZXG5cblx0XHRcdGNhc2UgMHg4ZGNmOiAvLyBJTlRfU0FNUExFUl8yRF9BUlJBWVxuXG5cdFx0XHRjYXNlIDB4OGRkNzogLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfMkRfQVJSQVlcblxuXHRcdFx0Y2FzZSAweDhkYzQ6XG5cdFx0XHRcdC8vIFNBTVBMRVJfMkRfQVJSQVlfU0hBRE9XXG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZVQyREFycmF5MTtcblx0XHR9XG5cdH0gLy8gQXJyYXkgb2Ygc2NhbGFyc1xuXG5cblx0ZnVuY3Rpb24gc2V0VmFsdWVWMWZBcnJheShnbCwgdikge1xuXHRcdGdsLnVuaWZvcm0xZnYodGhpcy5hZGRyLCB2KTtcblx0fSAvLyBBcnJheSBvZiB2ZWN0b3JzIChmcm9tIGZsYXQgYXJyYXkgb3IgYXJyYXkgb2YgVEhSRUUuVmVjdG9yTilcblxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVjJmQXJyYXkoZ2wsIHYpIHtcblx0XHRjb25zdCBkYXRhID0gZmxhdHRlbih2LCB0aGlzLnNpemUsIDIpO1xuXHRcdGdsLnVuaWZvcm0yZnYodGhpcy5hZGRyLCBkYXRhKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVjNmQXJyYXkoZ2wsIHYpIHtcblx0XHRjb25zdCBkYXRhID0gZmxhdHRlbih2LCB0aGlzLnNpemUsIDMpO1xuXHRcdGdsLnVuaWZvcm0zZnYodGhpcy5hZGRyLCBkYXRhKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVjRmQXJyYXkoZ2wsIHYpIHtcblx0XHRjb25zdCBkYXRhID0gZmxhdHRlbih2LCB0aGlzLnNpemUsIDQpO1xuXHRcdGdsLnVuaWZvcm00ZnYodGhpcy5hZGRyLCBkYXRhKTtcblx0fSAvLyBBcnJheSBvZiBtYXRyaWNlcyAoZnJvbSBmbGF0IGFycmF5IG9yIGFycmF5IG9mIFRIUkVFLk1hdHJpeE4pXG5cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZU0yQXJyYXkoZ2wsIHYpIHtcblx0XHRjb25zdCBkYXRhID0gZmxhdHRlbih2LCB0aGlzLnNpemUsIDQpO1xuXHRcdGdsLnVuaWZvcm1NYXRyaXgyZnYodGhpcy5hZGRyLCBmYWxzZSwgZGF0YSk7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZU0zQXJyYXkoZ2wsIHYpIHtcblx0XHRjb25zdCBkYXRhID0gZmxhdHRlbih2LCB0aGlzLnNpemUsIDkpO1xuXHRcdGdsLnVuaWZvcm1NYXRyaXgzZnYodGhpcy5hZGRyLCBmYWxzZSwgZGF0YSk7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZU00QXJyYXkoZ2wsIHYpIHtcblx0XHRjb25zdCBkYXRhID0gZmxhdHRlbih2LCB0aGlzLnNpemUsIDE2KTtcblx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuYWRkciwgZmFsc2UsIGRhdGEpO1xuXHR9IC8vIEFycmF5IG9mIGludGVnZXIgLyBib29sZWFuXG5cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZVYxaUFycmF5KGdsLCB2KSB7XG5cdFx0Z2wudW5pZm9ybTFpdih0aGlzLmFkZHIsIHYpO1xuXHR9IC8vIEFycmF5IG9mIGludGVnZXIgLyBib29sZWFuIHZlY3RvcnMgKGZyb20gZmxhdCBhcnJheSlcblxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVjJpQXJyYXkoZ2wsIHYpIHtcblx0XHRnbC51bmlmb3JtMml2KHRoaXMuYWRkciwgdik7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZVYzaUFycmF5KGdsLCB2KSB7XG5cdFx0Z2wudW5pZm9ybTNpdih0aGlzLmFkZHIsIHYpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0VmFsdWVWNGlBcnJheShnbCwgdikge1xuXHRcdGdsLnVuaWZvcm00aXYodGhpcy5hZGRyLCB2KTtcblx0fSAvLyBBcnJheSBvZiB1bnNpZ25lZCBpbnRlZ2VyXG5cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZVYxdWlBcnJheShnbCwgdikge1xuXHRcdGdsLnVuaWZvcm0xdWl2KHRoaXMuYWRkciwgdik7XG5cdH0gLy8gQXJyYXkgb2YgdW5zaWduZWQgaW50ZWdlciB2ZWN0b3JzIChmcm9tIGZsYXQgYXJyYXkpXG5cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZVYydWlBcnJheShnbCwgdikge1xuXHRcdGdsLnVuaWZvcm0ydWl2KHRoaXMuYWRkciwgdik7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZVYzdWlBcnJheShnbCwgdikge1xuXHRcdGdsLnVuaWZvcm0zdWl2KHRoaXMuYWRkciwgdik7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZVY0dWlBcnJheShnbCwgdikge1xuXHRcdGdsLnVuaWZvcm00dWl2KHRoaXMuYWRkciwgdik7XG5cdH0gLy8gQXJyYXkgb2YgdGV4dHVyZXMgKDJEIC8gM0QgLyBDdWJlIC8gMkRBcnJheSlcblxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVDFBcnJheShnbCwgdiwgdGV4dHVyZXMpIHtcblx0XHRjb25zdCBuID0gdi5sZW5ndGg7XG5cdFx0Y29uc3QgdW5pdHMgPSBhbGxvY1RleFVuaXRzKHRleHR1cmVzLCBuKTtcblx0XHRnbC51bmlmb3JtMWl2KHRoaXMuYWRkciwgdW5pdHMpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgIT09IG47ICsraSkge1xuXHRcdFx0dGV4dHVyZXMuc2FmZVNldFRleHR1cmUyRCh2W2ldIHx8IGVtcHR5VGV4dHVyZSwgdW5pdHNbaV0pO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVDNEQXJyYXkoZ2wsIHYsIHRleHR1cmVzKSB7XG5cdFx0Y29uc3QgbiA9IHYubGVuZ3RoO1xuXHRcdGNvbnN0IHVuaXRzID0gYWxsb2NUZXhVbml0cyh0ZXh0dXJlcywgbik7XG5cdFx0Z2wudW5pZm9ybTFpdih0aGlzLmFkZHIsIHVuaXRzKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdHRleHR1cmVzLnNldFRleHR1cmUzRCh2W2ldIHx8IGVtcHR5VGV4dHVyZTNkLCB1bml0c1tpXSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0VmFsdWVUNkFycmF5KGdsLCB2LCB0ZXh0dXJlcykge1xuXHRcdGNvbnN0IG4gPSB2Lmxlbmd0aDtcblx0XHRjb25zdCB1bml0cyA9IGFsbG9jVGV4VW5pdHModGV4dHVyZXMsIG4pO1xuXHRcdGdsLnVuaWZvcm0xaXYodGhpcy5hZGRyLCB1bml0cyk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHR0ZXh0dXJlcy5zYWZlU2V0VGV4dHVyZUN1YmUodltpXSB8fCBlbXB0eUN1YmVUZXh0dXJlLCB1bml0c1tpXSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0VmFsdWVUMkRBcnJheUFycmF5KGdsLCB2LCB0ZXh0dXJlcykge1xuXHRcdGNvbnN0IG4gPSB2Lmxlbmd0aDtcblx0XHRjb25zdCB1bml0cyA9IGFsbG9jVGV4VW5pdHModGV4dHVyZXMsIG4pO1xuXHRcdGdsLnVuaWZvcm0xaXYodGhpcy5hZGRyLCB1bml0cyk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlMkRBcnJheSh2W2ldIHx8IGVtcHR5VGV4dHVyZTJkQXJyYXksIHVuaXRzW2ldKTtcblx0XHR9XG5cdH0gLy8gSGVscGVyIHRvIHBpY2sgdGhlIHJpZ2h0IHNldHRlciBmb3IgYSBwdXJlIChib3R0b20tbGV2ZWwpIGFycmF5XG5cblxuXHRmdW5jdGlvbiBnZXRQdXJlQXJyYXlTZXR0ZXIodHlwZSkge1xuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSAweDE0MDY6XG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZVYxZkFycmF5O1xuXHRcdFx0Ly8gRkxPQVRcblxuXHRcdFx0Y2FzZSAweDhiNTA6XG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZVYyZkFycmF5O1xuXHRcdFx0Ly8gX1ZFQzJcblxuXHRcdFx0Y2FzZSAweDhiNTE6XG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZVYzZkFycmF5O1xuXHRcdFx0Ly8gX1ZFQzNcblxuXHRcdFx0Y2FzZSAweDhiNTI6XG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZVY0ZkFycmF5O1xuXHRcdFx0Ly8gX1ZFQzRcblxuXHRcdFx0Y2FzZSAweDhiNWE6XG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZU0yQXJyYXk7XG5cdFx0XHQvLyBfTUFUMlxuXG5cdFx0XHRjYXNlIDB4OGI1Yjpcblx0XHRcdFx0cmV0dXJuIHNldFZhbHVlTTNBcnJheTtcblx0XHRcdC8vIF9NQVQzXG5cblx0XHRcdGNhc2UgMHg4YjVjOlxuXHRcdFx0XHRyZXR1cm4gc2V0VmFsdWVNNEFycmF5O1xuXHRcdFx0Ly8gX01BVDRcblxuXHRcdFx0Y2FzZSAweDE0MDQ6XG5cdFx0XHRjYXNlIDB4OGI1Njpcblx0XHRcdFx0cmV0dXJuIHNldFZhbHVlVjFpQXJyYXk7XG5cdFx0XHQvLyBJTlQsIEJPT0xcblxuXHRcdFx0Y2FzZSAweDhiNTM6XG5cdFx0XHRjYXNlIDB4OGI1Nzpcblx0XHRcdFx0cmV0dXJuIHNldFZhbHVlVjJpQXJyYXk7XG5cdFx0XHQvLyBfVkVDMlxuXG5cdFx0XHRjYXNlIDB4OGI1NDpcblx0XHRcdGNhc2UgMHg4YjU4OlxuXHRcdFx0XHRyZXR1cm4gc2V0VmFsdWVWM2lBcnJheTtcblx0XHRcdC8vIF9WRUMzXG5cblx0XHRcdGNhc2UgMHg4YjU1OlxuXHRcdFx0Y2FzZSAweDhiNTk6XG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZVY0aUFycmF5O1xuXHRcdFx0Ly8gX1ZFQzRcblxuXHRcdFx0Y2FzZSAweDE0MDU6XG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZVYxdWlBcnJheTtcblx0XHRcdC8vIFVJTlRcblxuXHRcdFx0Y2FzZSAweDhkYzY6XG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZVYydWlBcnJheTtcblx0XHRcdC8vIF9WRUMyXG5cblx0XHRcdGNhc2UgMHg4ZGM3OlxuXHRcdFx0XHRyZXR1cm4gc2V0VmFsdWVWM3VpQXJyYXk7XG5cdFx0XHQvLyBfVkVDM1xuXG5cdFx0XHRjYXNlIDB4OGRjODpcblx0XHRcdFx0cmV0dXJuIHNldFZhbHVlVjR1aUFycmF5O1xuXHRcdFx0Ly8gX1ZFQzRcblxuXHRcdFx0Y2FzZSAweDhiNWU6IC8vIFNBTVBMRVJfMkRcblxuXHRcdFx0Y2FzZSAweDhkNjY6IC8vIFNBTVBMRVJfRVhURVJOQUxfT0VTXG5cblx0XHRcdGNhc2UgMHg4ZGNhOiAvLyBJTlRfU0FNUExFUl8yRFxuXG5cdFx0XHRjYXNlIDB4OGRkMjogLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfMkRcblxuXHRcdFx0Y2FzZSAweDhiNjI6XG5cdFx0XHRcdC8vIFNBTVBMRVJfMkRfU0hBRE9XXG5cdFx0XHRcdHJldHVybiBzZXRWYWx1ZVQxQXJyYXk7XG5cblx0XHRcdGNhc2UgMHg4YjVmOiAvLyBTQU1QTEVSXzNEXG5cblx0XHRcdGNhc2UgMHg4ZGNiOiAvLyBJTlRfU0FNUExFUl8zRFxuXG5cdFx0XHRjYXNlIDB4OGRkMzpcblx0XHRcdFx0Ly8gVU5TSUdORURfSU5UX1NBTVBMRVJfM0Rcblx0XHRcdFx0cmV0dXJuIHNldFZhbHVlVDNEQXJyYXk7XG5cblx0XHRcdGNhc2UgMHg4YjYwOiAvLyBTQU1QTEVSX0NVQkVcblxuXHRcdFx0Y2FzZSAweDhkY2M6IC8vIElOVF9TQU1QTEVSX0NVQkVcblxuXHRcdFx0Y2FzZSAweDhkZDQ6IC8vIFVOU0lHTkVEX0lOVF9TQU1QTEVSX0NVQkVcblxuXHRcdFx0Y2FzZSAweDhkYzU6XG5cdFx0XHRcdC8vIFNBTVBMRVJfQ1VCRV9TSEFET1dcblx0XHRcdFx0cmV0dXJuIHNldFZhbHVlVDZBcnJheTtcblxuXHRcdFx0Y2FzZSAweDhkYzE6IC8vIFNBTVBMRVJfMkRfQVJSQVlcblxuXHRcdFx0Y2FzZSAweDhkY2Y6IC8vIElOVF9TQU1QTEVSXzJEX0FSUkFZXG5cblx0XHRcdGNhc2UgMHg4ZGQ3OiAvLyBVTlNJR05FRF9JTlRfU0FNUExFUl8yRF9BUlJBWVxuXG5cdFx0XHRjYXNlIDB4OGRjNDpcblx0XHRcdFx0Ly8gU0FNUExFUl8yRF9BUlJBWV9TSEFET1dcblx0XHRcdFx0cmV0dXJuIHNldFZhbHVlVDJEQXJyYXlBcnJheTtcblx0XHR9XG5cdH0gLy8gLS0tIFVuaWZvcm0gQ2xhc3NlcyAtLS1cblxuXG5cdGZ1bmN0aW9uIFNpbmdsZVVuaWZvcm0oaWQsIGFjdGl2ZUluZm8sIGFkZHIpIHtcblx0XHR0aGlzLmlkID0gaWQ7XG5cdFx0dGhpcy5hZGRyID0gYWRkcjtcblx0XHR0aGlzLmNhY2hlID0gW107XG5cdFx0dGhpcy5zZXRWYWx1ZSA9IGdldFNpbmd1bGFyU2V0dGVyKGFjdGl2ZUluZm8udHlwZSk7IC8vIHRoaXMucGF0aCA9IGFjdGl2ZUluZm8ubmFtZTsgLy8gREVCVUdcblx0fVxuXG5cdGZ1bmN0aW9uIFB1cmVBcnJheVVuaWZvcm0oaWQsIGFjdGl2ZUluZm8sIGFkZHIpIHtcblx0XHR0aGlzLmlkID0gaWQ7XG5cdFx0dGhpcy5hZGRyID0gYWRkcjtcblx0XHR0aGlzLmNhY2hlID0gW107XG5cdFx0dGhpcy5zaXplID0gYWN0aXZlSW5mby5zaXplO1xuXHRcdHRoaXMuc2V0VmFsdWUgPSBnZXRQdXJlQXJyYXlTZXR0ZXIoYWN0aXZlSW5mby50eXBlKTsgLy8gdGhpcy5wYXRoID0gYWN0aXZlSW5mby5uYW1lOyAvLyBERUJVR1xuXHR9XG5cblx0UHVyZUFycmF5VW5pZm9ybS5wcm90b3R5cGUudXBkYXRlQ2FjaGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcblxuXHRcdGlmIChkYXRhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ICYmIGNhY2hlLmxlbmd0aCAhPT0gZGF0YS5sZW5ndGgpIHtcblx0XHRcdHRoaXMuY2FjaGUgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGEubGVuZ3RoKTtcblx0XHR9XG5cblx0XHRjb3B5QXJyYXkoY2FjaGUsIGRhdGEpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIFN0cnVjdHVyZWRVbmlmb3JtKGlkKSB7XG5cdFx0dGhpcy5pZCA9IGlkO1xuXHRcdHRoaXMuc2VxID0gW107XG5cdFx0dGhpcy5tYXAgPSB7fTtcblx0fVxuXG5cdFN0cnVjdHVyZWRVbmlmb3JtLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uIChnbCwgdmFsdWUsIHRleHR1cmVzKSB7XG5cdFx0Y29uc3Qgc2VxID0gdGhpcy5zZXE7XG5cblx0XHRmb3IgKGxldCBpID0gMCwgbiA9IHNlcS5sZW5ndGg7IGkgIT09IG47ICsraSkge1xuXHRcdFx0Y29uc3QgdSA9IHNlcVtpXTtcblx0XHRcdHUuc2V0VmFsdWUoZ2wsIHZhbHVlW3UuaWRdLCB0ZXh0dXJlcyk7XG5cdFx0fVxuXHR9OyAvLyAtLS0gVG9wLWxldmVsIC0tLVxuXHQvLyBQYXJzZXIgLSBidWlsZHMgdXAgdGhlIHByb3BlcnR5IHRyZWUgZnJvbSB0aGUgcGF0aCBzdHJpbmdzXG5cblxuXHRjb25zdCBSZVBhdGhQYXJ0ID0gLyhcXHcrKShcXF0pPyhcXFt8XFwuKT8vZzsgLy8gZXh0cmFjdHNcblx0Ly8gXHQtIHRoZSBpZGVudGlmaWVyIChtZW1iZXIgbmFtZSBvciBhcnJheSBpbmRleClcblx0Ly9cdC0gZm9sbG93ZWQgYnkgYW4gb3B0aW9uYWwgcmlnaHQgYnJhY2tldCAoZm91bmQgd2hlbiBhcnJheSBpbmRleClcblx0Ly9cdC0gZm9sbG93ZWQgYnkgYW4gb3B0aW9uYWwgbGVmdCBicmFja2V0IG9yIGRvdCAodHlwZSBvZiBzdWJzY3JpcHQpXG5cdC8vXG5cdC8vIE5vdGU6IFRoZXNlIHBvcnRpb25zIGNhbiBiZSByZWFkIGluIGEgbm9uLW92ZXJsYXBwaW5nIGZhc2hpb24gYW5kXG5cdC8vIGFsbG93IHN0cmFpZ2h0Zm9yd2FyZCBwYXJzaW5nIG9mIHRoZSBoaWVyYXJjaHkgdGhhdCBXZWJHTCBlbmNvZGVzXG5cdC8vIGluIHRoZSB1bmlmb3JtIG5hbWVzLlxuXG5cdGZ1bmN0aW9uIGFkZFVuaWZvcm0oY29udGFpbmVyLCB1bmlmb3JtT2JqZWN0KSB7XG5cdFx0Y29udGFpbmVyLnNlcS5wdXNoKHVuaWZvcm1PYmplY3QpO1xuXHRcdGNvbnRhaW5lci5tYXBbdW5pZm9ybU9iamVjdC5pZF0gPSB1bmlmb3JtT2JqZWN0O1xuXHR9XG5cblx0ZnVuY3Rpb24gcGFyc2VVbmlmb3JtKGFjdGl2ZUluZm8sIGFkZHIsIGNvbnRhaW5lcikge1xuXHRcdGNvbnN0IHBhdGggPSBhY3RpdmVJbmZvLm5hbWUsXG5cdFx0XHRcdFx0cGF0aExlbmd0aCA9IHBhdGgubGVuZ3RoOyAvLyByZXNldCBSZWdFeHAgb2JqZWN0LCBiZWNhdXNlIG9mIHRoZSBlYXJseSBleGl0IG9mIGEgcHJldmlvdXMgcnVuXG5cblx0XHRSZVBhdGhQYXJ0Lmxhc3RJbmRleCA9IDA7XG5cblx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0Y29uc3QgbWF0Y2ggPSBSZVBhdGhQYXJ0LmV4ZWMocGF0aCksXG5cdFx0XHRcdFx0XHRtYXRjaEVuZCA9IFJlUGF0aFBhcnQubGFzdEluZGV4O1xuXHRcdFx0bGV0IGlkID0gbWF0Y2hbMV07XG5cdFx0XHRjb25zdCBpZElzSW5kZXggPSBtYXRjaFsyXSA9PT0gJ10nLFxuXHRcdFx0XHRcdFx0c3Vic2NyaXB0ID0gbWF0Y2hbM107XG5cdFx0XHRpZiAoaWRJc0luZGV4KSBpZCA9IGlkIHwgMDsgLy8gY29udmVydCB0byBpbnRlZ2VyXG5cblx0XHRcdGlmIChzdWJzY3JpcHQgPT09IHVuZGVmaW5lZCB8fCBzdWJzY3JpcHQgPT09ICdbJyAmJiBtYXRjaEVuZCArIDIgPT09IHBhdGhMZW5ndGgpIHtcblx0XHRcdFx0Ly8gYmFyZSBuYW1lIG9yIFwicHVyZVwiIGJvdHRvbS1sZXZlbCBhcnJheSBcIlswXVwiIHN1ZmZpeFxuXHRcdFx0XHRhZGRVbmlmb3JtKGNvbnRhaW5lciwgc3Vic2NyaXB0ID09PSB1bmRlZmluZWQgPyBuZXcgU2luZ2xlVW5pZm9ybShpZCwgYWN0aXZlSW5mbywgYWRkcikgOiBuZXcgUHVyZUFycmF5VW5pZm9ybShpZCwgYWN0aXZlSW5mbywgYWRkcikpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHN0ZXAgaW50byBpbm5lciBub2RlIC8gY3JlYXRlIGl0IGluIGNhc2UgaXQgZG9lc24ndCBleGlzdFxuXHRcdFx0XHRjb25zdCBtYXAgPSBjb250YWluZXIubWFwO1xuXHRcdFx0XHRsZXQgbmV4dCA9IG1hcFtpZF07XG5cblx0XHRcdFx0aWYgKG5leHQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdG5leHQgPSBuZXcgU3RydWN0dXJlZFVuaWZvcm0oaWQpO1xuXHRcdFx0XHRcdGFkZFVuaWZvcm0oY29udGFpbmVyLCBuZXh0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnRhaW5lciA9IG5leHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IC8vIFJvb3QgQ29udGFpbmVyXG5cblxuXHRmdW5jdGlvbiBXZWJHTFVuaWZvcm1zKGdsLCBwcm9ncmFtKSB7XG5cdFx0dGhpcy5zZXEgPSBbXTtcblx0XHR0aGlzLm1hcCA9IHt9O1xuXHRcdGNvbnN0IG4gPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkFDVElWRV9VTklGT1JNUyk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuXHRcdFx0Y29uc3QgaW5mbyA9IGdsLmdldEFjdGl2ZVVuaWZvcm0ocHJvZ3JhbSwgaSksXG5cdFx0XHRcdFx0XHRhZGRyID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIGluZm8ubmFtZSk7XG5cdFx0XHRwYXJzZVVuaWZvcm0oaW5mbywgYWRkciwgdGhpcyk7XG5cdFx0fVxuXHR9XG5cblx0V2ViR0xVbmlmb3Jtcy5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAoZ2wsIG5hbWUsIHZhbHVlLCB0ZXh0dXJlcykge1xuXHRcdGNvbnN0IHUgPSB0aGlzLm1hcFtuYW1lXTtcblx0XHRpZiAodSAhPT0gdW5kZWZpbmVkKSB1LnNldFZhbHVlKGdsLCB2YWx1ZSwgdGV4dHVyZXMpO1xuXHR9O1xuXG5cdFdlYkdMVW5pZm9ybXMucHJvdG90eXBlLnNldE9wdGlvbmFsID0gZnVuY3Rpb24gKGdsLCBvYmplY3QsIG5hbWUpIHtcblx0XHRjb25zdCB2ID0gb2JqZWN0W25hbWVdO1xuXHRcdGlmICh2ICE9PSB1bmRlZmluZWQpIHRoaXMuc2V0VmFsdWUoZ2wsIG5hbWUsIHYpO1xuXHR9OyAvLyBTdGF0aWMgaW50ZXJmYWNlXG5cblxuXHRXZWJHTFVuaWZvcm1zLnVwbG9hZCA9IGZ1bmN0aW9uIChnbCwgc2VxLCB2YWx1ZXMsIHRleHR1cmVzKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBzZXEubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdGNvbnN0IHUgPSBzZXFbaV0sXG5cdFx0XHRcdFx0XHR2ID0gdmFsdWVzW3UuaWRdO1xuXG5cdFx0XHRpZiAodi5uZWVkc1VwZGF0ZSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0Ly8gbm90ZTogYWx3YXlzIHVwZGF0aW5nIHdoZW4gLm5lZWRzVXBkYXRlIGlzIHVuZGVmaW5lZFxuXHRcdFx0XHR1LnNldFZhbHVlKGdsLCB2LnZhbHVlLCB0ZXh0dXJlcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdFdlYkdMVW5pZm9ybXMuc2VxV2l0aFZhbHVlID0gZnVuY3Rpb24gKHNlcSwgdmFsdWVzKSB7XG5cdFx0Y29uc3QgciA9IFtdO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBzZXEubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdGNvbnN0IHUgPSBzZXFbaV07XG5cdFx0XHRpZiAodS5pZCBpbiB2YWx1ZXMpIHIucHVzaCh1KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcjtcblx0fTtcblxuXHRmdW5jdGlvbiBXZWJHTFNoYWRlcihnbCwgdHlwZSwgc3RyaW5nKSB7XG5cdFx0Y29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuXHRcdGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHN0cmluZyk7XG5cdFx0Z2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuXHRcdHJldHVybiBzaGFkZXI7XG5cdH1cblxuXHRsZXQgcHJvZ3JhbUlkQ291bnQgPSAwO1xuXG5cdGZ1bmN0aW9uIGFkZExpbmVOdW1iZXJzKHN0cmluZykge1xuXHRcdGNvbnN0IGxpbmVzID0gc3RyaW5nLnNwbGl0KCdcXG4nKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxpbmVzW2ldID0gaSArIDEgKyAnOiAnICsgbGluZXNbaV07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0RW5jb2RpbmdDb21wb25lbnRzKGVuY29kaW5nKSB7XG5cdFx0c3dpdGNoIChlbmNvZGluZykge1xuXHRcdFx0Y2FzZSBMaW5lYXJFbmNvZGluZzpcblx0XHRcdFx0cmV0dXJuIFsnTGluZWFyJywgJyggdmFsdWUgKSddO1xuXG5cdFx0XHRjYXNlIHNSR0JFbmNvZGluZzpcblx0XHRcdFx0cmV0dXJuIFsnc1JHQicsICcoIHZhbHVlICknXTtcblxuXHRcdFx0Y2FzZSBSR0JFRW5jb2Rpbmc6XG5cdFx0XHRcdHJldHVybiBbJ1JHQkUnLCAnKCB2YWx1ZSApJ107XG5cblx0XHRcdGNhc2UgUkdCTTdFbmNvZGluZzpcblx0XHRcdFx0cmV0dXJuIFsnUkdCTScsICcoIHZhbHVlLCA3LjAgKSddO1xuXG5cdFx0XHRjYXNlIFJHQk0xNkVuY29kaW5nOlxuXHRcdFx0XHRyZXR1cm4gWydSR0JNJywgJyggdmFsdWUsIDE2LjAgKSddO1xuXG5cdFx0XHRjYXNlIFJHQkRFbmNvZGluZzpcblx0XHRcdFx0cmV0dXJuIFsnUkdCRCcsICcoIHZhbHVlLCAyNTYuMCApJ107XG5cblx0XHRcdGNhc2UgR2FtbWFFbmNvZGluZzpcblx0XHRcdFx0cmV0dXJuIFsnR2FtbWEnLCAnKCB2YWx1ZSwgZmxvYXQoIEdBTU1BX0ZBQ1RPUiApICknXTtcblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFByb2dyYW06IFVuc3VwcG9ydGVkIGVuY29kaW5nOicsIGVuY29kaW5nKTtcblx0XHRcdFx0cmV0dXJuIFsnTGluZWFyJywgJyggdmFsdWUgKSddO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdldFNoYWRlckVycm9ycyhnbCwgc2hhZGVyLCB0eXBlKSB7XG5cdFx0Y29uc3Qgc3RhdHVzID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpO1xuXHRcdGNvbnN0IGVycm9ycyA9IGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKS50cmltKCk7XG5cdFx0aWYgKHN0YXR1cyAmJiBlcnJvcnMgPT09ICcnKSByZXR1cm4gJyc7IC8vIC0tZW5hYmxlLXByaXZpbGVnZWQtd2ViZ2wtZXh0ZW5zaW9uXG5cdFx0Ly8gY29uc29sZS5sb2coICcqKicgKyB0eXBlICsgJyoqJywgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfZGVidWdfc2hhZGVycycgKS5nZXRUcmFuc2xhdGVkU2hhZGVyU291cmNlKCBzaGFkZXIgKSApO1xuXG5cdFx0cmV0dXJuIHR5cGUudG9VcHBlckNhc2UoKSArICdcXG5cXG4nICsgZXJyb3JzICsgJ1xcblxcbicgKyBhZGRMaW5lTnVtYmVycyhnbC5nZXRTaGFkZXJTb3VyY2Uoc2hhZGVyKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRUZXhlbERlY29kaW5nRnVuY3Rpb24oZnVuY3Rpb25OYW1lLCBlbmNvZGluZykge1xuXHRcdGNvbnN0IGNvbXBvbmVudHMgPSBnZXRFbmNvZGluZ0NvbXBvbmVudHMoZW5jb2RpbmcpO1xuXHRcdHJldHVybiAndmVjNCAnICsgZnVuY3Rpb25OYW1lICsgJyggdmVjNCB2YWx1ZSApIHsgcmV0dXJuICcgKyBjb21wb25lbnRzWzBdICsgJ1RvTGluZWFyJyArIGNvbXBvbmVudHNbMV0gKyAnOyB9Jztcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFRleGVsRW5jb2RpbmdGdW5jdGlvbihmdW5jdGlvbk5hbWUsIGVuY29kaW5nKSB7XG5cdFx0Y29uc3QgY29tcG9uZW50cyA9IGdldEVuY29kaW5nQ29tcG9uZW50cyhlbmNvZGluZyk7XG5cdFx0cmV0dXJuICd2ZWM0ICcgKyBmdW5jdGlvbk5hbWUgKyAnKCB2ZWM0IHZhbHVlICkgeyByZXR1cm4gTGluZWFyVG8nICsgY29tcG9uZW50c1swXSArIGNvbXBvbmVudHNbMV0gKyAnOyB9Jztcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFRvbmVNYXBwaW5nRnVuY3Rpb24oZnVuY3Rpb25OYW1lLCB0b25lTWFwcGluZykge1xuXHRcdGxldCB0b25lTWFwcGluZ05hbWU7XG5cblx0XHRzd2l0Y2ggKHRvbmVNYXBwaW5nKSB7XG5cdFx0XHRjYXNlIExpbmVhclRvbmVNYXBwaW5nOlxuXHRcdFx0XHR0b25lTWFwcGluZ05hbWUgPSAnTGluZWFyJztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgUmVpbmhhcmRUb25lTWFwcGluZzpcblx0XHRcdFx0dG9uZU1hcHBpbmdOYW1lID0gJ1JlaW5oYXJkJztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgQ2luZW9uVG9uZU1hcHBpbmc6XG5cdFx0XHRcdHRvbmVNYXBwaW5nTmFtZSA9ICdPcHRpbWl6ZWRDaW5lb24nO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBBQ0VTRmlsbWljVG9uZU1hcHBpbmc6XG5cdFx0XHRcdHRvbmVNYXBwaW5nTmFtZSA9ICdBQ0VTRmlsbWljJztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgQ3VzdG9tVG9uZU1hcHBpbmc6XG5cdFx0XHRcdHRvbmVNYXBwaW5nTmFtZSA9ICdDdXN0b20nO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFByb2dyYW06IFVuc3VwcG9ydGVkIHRvbmVNYXBwaW5nOicsIHRvbmVNYXBwaW5nKTtcblx0XHRcdFx0dG9uZU1hcHBpbmdOYW1lID0gJ0xpbmVhcic7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICd2ZWMzICcgKyBmdW5jdGlvbk5hbWUgKyAnKCB2ZWMzIGNvbG9yICkgeyByZXR1cm4gJyArIHRvbmVNYXBwaW5nTmFtZSArICdUb25lTWFwcGluZyggY29sb3IgKTsgfSc7XG5cdH1cblxuXHRmdW5jdGlvbiBnZW5lcmF0ZUV4dGVuc2lvbnMocGFyYW1ldGVycykge1xuXHRcdGNvbnN0IGNodW5rcyA9IFtwYXJhbWV0ZXJzLmV4dGVuc2lvbkRlcml2YXRpdmVzIHx8IHBhcmFtZXRlcnMuZW52TWFwQ3ViZVVWIHx8IHBhcmFtZXRlcnMuYnVtcE1hcCB8fCBwYXJhbWV0ZXJzLnRhbmdlbnRTcGFjZU5vcm1hbE1hcCB8fCBwYXJhbWV0ZXJzLmNsZWFyY29hdE5vcm1hbE1hcCB8fCBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nIHx8IHBhcmFtZXRlcnMuc2hhZGVySUQgPT09ICdwaHlzaWNhbCcgPyAnI2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGUnIDogJycsIChwYXJhbWV0ZXJzLmV4dGVuc2lvbkZyYWdEZXB0aCB8fCBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIpICYmIHBhcmFtZXRlcnMucmVuZGVyZXJFeHRlbnNpb25GcmFnRGVwdGggPyAnI2V4dGVuc2lvbiBHTF9FWFRfZnJhZ19kZXB0aCA6IGVuYWJsZScgOiAnJywgcGFyYW1ldGVycy5leHRlbnNpb25EcmF3QnVmZmVycyAmJiBwYXJhbWV0ZXJzLnJlbmRlcmVyRXh0ZW5zaW9uRHJhd0J1ZmZlcnMgPyAnI2V4dGVuc2lvbiBHTF9FWFRfZHJhd19idWZmZXJzIDogcmVxdWlyZScgOiAnJywgKHBhcmFtZXRlcnMuZXh0ZW5zaW9uU2hhZGVyVGV4dHVyZUxPRCB8fCBwYXJhbWV0ZXJzLmVudk1hcCB8fCBwYXJhbWV0ZXJzLnRyYW5zbWlzc2lvbikgJiYgcGFyYW1ldGVycy5yZW5kZXJlckV4dGVuc2lvblNoYWRlclRleHR1cmVMb2QgPyAnI2V4dGVuc2lvbiBHTF9FWFRfc2hhZGVyX3RleHR1cmVfbG9kIDogZW5hYmxlJyA6ICcnXTtcblx0XHRyZXR1cm4gY2h1bmtzLmZpbHRlcihmaWx0ZXJFbXB0eUxpbmUpLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuZXJhdGVEZWZpbmVzKGRlZmluZXMpIHtcblx0XHRjb25zdCBjaHVua3MgPSBbXTtcblxuXHRcdGZvciAoY29uc3QgbmFtZSBpbiBkZWZpbmVzKSB7XG5cdFx0XHRjb25zdCB2YWx1ZSA9IGRlZmluZXNbbmFtZV07XG5cdFx0XHRpZiAodmFsdWUgPT09IGZhbHNlKSBjb250aW51ZTtcblx0XHRcdGNodW5rcy5wdXNoKCcjZGVmaW5lICcgKyBuYW1lICsgJyAnICsgdmFsdWUpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjaHVua3Muam9pbignXFxuJyk7XG5cdH1cblxuXHRmdW5jdGlvbiBmZXRjaEF0dHJpYnV0ZUxvY2F0aW9ucyhnbCwgcHJvZ3JhbSkge1xuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcblx0XHRjb25zdCBuID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5BQ1RJVkVfQVRUUklCVVRFUyk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuXHRcdFx0Y29uc3QgaW5mbyA9IGdsLmdldEFjdGl2ZUF0dHJpYihwcm9ncmFtLCBpKTtcblx0XHRcdGNvbnN0IG5hbWUgPSBpbmZvLm5hbWU7XG5cdFx0XHRsZXQgbG9jYXRpb25TaXplID0gMTtcblx0XHRcdGlmIChpbmZvLnR5cGUgPT09IGdsLkZMT0FUX01BVDIpIGxvY2F0aW9uU2l6ZSA9IDI7XG5cdFx0XHRpZiAoaW5mby50eXBlID09PSBnbC5GTE9BVF9NQVQzKSBsb2NhdGlvblNpemUgPSAzO1xuXHRcdFx0aWYgKGluZm8udHlwZSA9PT0gZ2wuRkxPQVRfTUFUNCkgbG9jYXRpb25TaXplID0gNDsgLy8gY29uc29sZS5sb2coICdUSFJFRS5XZWJHTFByb2dyYW06IEFDVElWRSBWRVJURVggQVRUUklCVVRFOicsIG5hbWUsIGkgKTtcblxuXHRcdFx0YXR0cmlidXRlc1tuYW1lXSA9IHtcblx0XHRcdFx0dHlwZTogaW5mby50eXBlLFxuXHRcdFx0XHRsb2NhdGlvbjogZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgbmFtZSksXG5cdFx0XHRcdGxvY2F0aW9uU2l6ZTogbG9jYXRpb25TaXplXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiBhdHRyaWJ1dGVzO1xuXHR9XG5cblx0ZnVuY3Rpb24gZmlsdGVyRW1wdHlMaW5lKHN0cmluZykge1xuXHRcdHJldHVybiBzdHJpbmcgIT09ICcnO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVwbGFjZUxpZ2h0TnVtcyhzdHJpbmcsIHBhcmFtZXRlcnMpIHtcblx0XHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoL05VTV9ESVJfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtRGlyTGlnaHRzKS5yZXBsYWNlKC9OVU1fU1BPVF9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1TcG90TGlnaHRzKS5yZXBsYWNlKC9OVU1fUkVDVF9BUkVBX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bVJlY3RBcmVhTGlnaHRzKS5yZXBsYWNlKC9OVU1fUE9JTlRfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtUG9pbnRMaWdodHMpLnJlcGxhY2UoL05VTV9IRU1JX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bUhlbWlMaWdodHMpLnJlcGxhY2UoL05VTV9ESVJfTElHSFRfU0hBRE9XUy9nLCBwYXJhbWV0ZXJzLm51bURpckxpZ2h0U2hhZG93cykucmVwbGFjZSgvTlVNX1NQT1RfTElHSFRfU0hBRE9XUy9nLCBwYXJhbWV0ZXJzLm51bVNwb3RMaWdodFNoYWRvd3MpLnJlcGxhY2UoL05VTV9QT0lOVF9MSUdIVF9TSEFET1dTL2csIHBhcmFtZXRlcnMubnVtUG9pbnRMaWdodFNoYWRvd3MpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVwbGFjZUNsaXBwaW5nUGxhbmVOdW1zKHN0cmluZywgcGFyYW1ldGVycykge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSgvTlVNX0NMSVBQSU5HX1BMQU5FUy9nLCBwYXJhbWV0ZXJzLm51bUNsaXBwaW5nUGxhbmVzKS5yZXBsYWNlKC9VTklPTl9DTElQUElOR19QTEFORVMvZywgcGFyYW1ldGVycy5udW1DbGlwcGluZ1BsYW5lcyAtIHBhcmFtZXRlcnMubnVtQ2xpcEludGVyc2VjdGlvbik7XG5cdH0gLy8gUmVzb2x2ZSBJbmNsdWRlc1xuXG5cblx0Y29uc3QgaW5jbHVkZVBhdHRlcm4gPSAvXlsgXFx0XSojaW5jbHVkZSArPChbXFx3XFxkLi9dKyk+L2dtO1xuXG5cdGZ1bmN0aW9uIHJlc29sdmVJbmNsdWRlcyhzdHJpbmcpIHtcblx0XHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoaW5jbHVkZVBhdHRlcm4sIGluY2x1ZGVSZXBsYWNlcik7XG5cdH1cblxuXHRmdW5jdGlvbiBpbmNsdWRlUmVwbGFjZXIobWF0Y2gsIGluY2x1ZGUpIHtcblx0XHRjb25zdCBzdHJpbmcgPSBTaGFkZXJDaHVua1tpbmNsdWRlXTtcblxuXHRcdGlmIChzdHJpbmcgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IHJlc29sdmUgI2luY2x1ZGUgPCcgKyBpbmNsdWRlICsgJz4nKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzb2x2ZUluY2x1ZGVzKHN0cmluZyk7XG5cdH0gLy8gVW5yb2xsIExvb3BzXG5cblxuXHRjb25zdCBkZXByZWNhdGVkVW5yb2xsTG9vcFBhdHRlcm4gPSAvI3ByYWdtYSB1bnJvbGxfbG9vcFtcXHNdKz9mb3IgXFwoIGludCBpIFxcPSAoXFxkKylcXDsgaSA8IChcXGQrKVxcOyBpIFxcK1xcKyBcXCkgXFx7KFtcXHNcXFNdKz8pKD89XFx9KVxcfS9nO1xuXHRjb25zdCB1bnJvbGxMb29wUGF0dGVybiA9IC8jcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxzK2ZvclxccypcXChcXHMqaW50XFxzK2lcXHMqPVxccyooXFxkKylcXHMqO1xccyppXFxzKjxcXHMqKFxcZCspXFxzKjtcXHMqaVxccypcXCtcXCtcXHMqXFwpXFxzKnsoW1xcc1xcU10rPyl9XFxzKyNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kL2c7XG5cblx0ZnVuY3Rpb24gdW5yb2xsTG9vcHMoc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKHVucm9sbExvb3BQYXR0ZXJuLCBsb29wUmVwbGFjZXIpLnJlcGxhY2UoZGVwcmVjYXRlZFVucm9sbExvb3BQYXR0ZXJuLCBkZXByZWNhdGVkTG9vcFJlcGxhY2VyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlcHJlY2F0ZWRMb29wUmVwbGFjZXIobWF0Y2gsIHN0YXJ0LCBlbmQsIHNuaXBwZXQpIHtcblx0XHRjb25zb2xlLndhcm4oJ1dlYkdMUHJvZ3JhbTogI3ByYWdtYSB1bnJvbGxfbG9vcCBzaGFkZXIgc3ludGF4IGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgI3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydCBzeW50YXggaW5zdGVhZC4nKTtcblx0XHRyZXR1cm4gbG9vcFJlcGxhY2VyKG1hdGNoLCBzdGFydCwgZW5kLCBzbmlwcGV0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGxvb3BSZXBsYWNlcihtYXRjaCwgc3RhcnQsIGVuZCwgc25pcHBldCkge1xuXHRcdGxldCBzdHJpbmcgPSAnJztcblxuXHRcdGZvciAobGV0IGkgPSBwYXJzZUludChzdGFydCk7IGkgPCBwYXJzZUludChlbmQpOyBpKyspIHtcblx0XHRcdHN0cmluZyArPSBzbmlwcGV0LnJlcGxhY2UoL1xcW1xccyppXFxzKlxcXS9nLCAnWyAnICsgaSArICcgXScpLnJlcGxhY2UoL1VOUk9MTEVEX0xPT1BfSU5ERVgvZywgaSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0cmluZztcblx0fSAvL1xuXG5cblx0ZnVuY3Rpb24gZ2VuZXJhdGVQcmVjaXNpb24ocGFyYW1ldGVycykge1xuXHRcdGxldCBwcmVjaXNpb25zdHJpbmcgPSAncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgZmxvYXQ7XFxucHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgaW50Oyc7XG5cblx0XHRpZiAocGFyYW1ldGVycy5wcmVjaXNpb24gPT09ICdoaWdocCcpIHtcblx0XHRcdHByZWNpc2lvbnN0cmluZyArPSAnXFxuI2RlZmluZSBISUdIX1BSRUNJU0lPTic7XG5cdFx0fSBlbHNlIGlmIChwYXJhbWV0ZXJzLnByZWNpc2lvbiA9PT0gJ21lZGl1bXAnKSB7XG5cdFx0XHRwcmVjaXNpb25zdHJpbmcgKz0gJ1xcbiNkZWZpbmUgTUVESVVNX1BSRUNJU0lPTic7XG5cdFx0fSBlbHNlIGlmIChwYXJhbWV0ZXJzLnByZWNpc2lvbiA9PT0gJ2xvd3AnKSB7XG5cdFx0XHRwcmVjaXNpb25zdHJpbmcgKz0gJ1xcbiNkZWZpbmUgTE9XX1BSRUNJU0lPTic7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHByZWNpc2lvbnN0cmluZztcblx0fVxuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlU2hhZG93TWFwVHlwZURlZmluZShwYXJhbWV0ZXJzKSB7XG5cdFx0bGV0IHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfQkFTSUMnO1xuXG5cdFx0aWYgKHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gUENGU2hhZG93TWFwKSB7XG5cdFx0XHRzaGFkb3dNYXBUeXBlRGVmaW5lID0gJ1NIQURPV01BUF9UWVBFX1BDRic7XG5cdFx0fSBlbHNlIGlmIChwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFBDRlNvZnRTaGFkb3dNYXApIHtcblx0XHRcdHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQnO1xuXHRcdH0gZWxzZSBpZiAocGFyYW1ldGVycy5zaGFkb3dNYXBUeXBlID09PSBWU01TaGFkb3dNYXApIHtcblx0XHRcdHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfVlNNJztcblx0XHR9XG5cblx0XHRyZXR1cm4gc2hhZG93TWFwVHlwZURlZmluZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlRW52TWFwVHlwZURlZmluZShwYXJhbWV0ZXJzKSB7XG5cdFx0bGV0IGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfQ1VCRSc7XG5cblx0XHRpZiAocGFyYW1ldGVycy5lbnZNYXApIHtcblx0XHRcdHN3aXRjaCAocGFyYW1ldGVycy5lbnZNYXBNb2RlKSB7XG5cdFx0XHRcdGNhc2UgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nOlxuXHRcdFx0XHRjYXNlIEN1YmVSZWZyYWN0aW9uTWFwcGluZzpcblx0XHRcdFx0XHRlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkUnO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmc6XG5cdFx0XHRcdGNhc2UgQ3ViZVVWUmVmcmFjdGlvbk1hcHBpbmc6XG5cdFx0XHRcdFx0ZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9DVUJFX1VWJztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZW52TWFwVHlwZURlZmluZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlRW52TWFwTW9kZURlZmluZShwYXJhbWV0ZXJzKSB7XG5cdFx0bGV0IGVudk1hcE1vZGVEZWZpbmUgPSAnRU5WTUFQX01PREVfUkVGTEVDVElPTic7XG5cblx0XHRpZiAocGFyYW1ldGVycy5lbnZNYXApIHtcblx0XHRcdHN3aXRjaCAocGFyYW1ldGVycy5lbnZNYXBNb2RlKSB7XG5cdFx0XHRcdGNhc2UgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nOlxuXHRcdFx0XHRjYXNlIEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nOlxuXHRcdFx0XHRcdGVudk1hcE1vZGVEZWZpbmUgPSAnRU5WTUFQX01PREVfUkVGUkFDVElPTic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVudk1hcE1vZGVEZWZpbmU7XG5cdH1cblxuXHRmdW5jdGlvbiBnZW5lcmF0ZUVudk1hcEJsZW5kaW5nRGVmaW5lKHBhcmFtZXRlcnMpIHtcblx0XHRsZXQgZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX05PTkUnO1xuXG5cdFx0aWYgKHBhcmFtZXRlcnMuZW52TWFwKSB7XG5cdFx0XHRzd2l0Y2ggKHBhcmFtZXRlcnMuY29tYmluZSkge1xuXHRcdFx0XHRjYXNlIE11bHRpcGx5T3BlcmF0aW9uOlxuXHRcdFx0XHRcdGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19NVUxUSVBMWSc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBNaXhPcGVyYXRpb246XG5cdFx0XHRcdFx0ZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01JWCc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBBZGRPcGVyYXRpb246XG5cdFx0XHRcdFx0ZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX0FERCc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVudk1hcEJsZW5kaW5nRGVmaW5lO1xuXHR9XG5cblx0ZnVuY3Rpb24gV2ViR0xQcm9ncmFtKHJlbmRlcmVyLCBjYWNoZUtleSwgcGFyYW1ldGVycywgYmluZGluZ1N0YXRlcykge1xuXHRcdC8vIFRPRE8gU2VuZCB0aGlzIGV2ZW50IHRvIFRocmVlLmpzIERldlRvb2xzXG5cdFx0Ly8gY29uc29sZS5sb2coICdXZWJHTFByb2dyYW0nLCBjYWNoZUtleSApO1xuXHRcdGNvbnN0IGdsID0gcmVuZGVyZXIuZ2V0Q29udGV4dCgpO1xuXHRcdGNvbnN0IGRlZmluZXMgPSBwYXJhbWV0ZXJzLmRlZmluZXM7XG5cdFx0bGV0IHZlcnRleFNoYWRlciA9IHBhcmFtZXRlcnMudmVydGV4U2hhZGVyO1xuXHRcdGxldCBmcmFnbWVudFNoYWRlciA9IHBhcmFtZXRlcnMuZnJhZ21lbnRTaGFkZXI7XG5cdFx0Y29uc3Qgc2hhZG93TWFwVHlwZURlZmluZSA9IGdlbmVyYXRlU2hhZG93TWFwVHlwZURlZmluZShwYXJhbWV0ZXJzKTtcblx0XHRjb25zdCBlbnZNYXBUeXBlRGVmaW5lID0gZ2VuZXJhdGVFbnZNYXBUeXBlRGVmaW5lKHBhcmFtZXRlcnMpO1xuXHRcdGNvbnN0IGVudk1hcE1vZGVEZWZpbmUgPSBnZW5lcmF0ZUVudk1hcE1vZGVEZWZpbmUocGFyYW1ldGVycyk7XG5cdFx0Y29uc3QgZW52TWFwQmxlbmRpbmdEZWZpbmUgPSBnZW5lcmF0ZUVudk1hcEJsZW5kaW5nRGVmaW5lKHBhcmFtZXRlcnMpO1xuXHRcdGNvbnN0IGdhbW1hRmFjdG9yRGVmaW5lID0gcmVuZGVyZXIuZ2FtbWFGYWN0b3IgPiAwID8gcmVuZGVyZXIuZ2FtbWFGYWN0b3IgOiAxLjA7XG5cdFx0Y29uc3QgY3VzdG9tRXh0ZW5zaW9ucyA9IHBhcmFtZXRlcnMuaXNXZWJHTDIgPyAnJyA6IGdlbmVyYXRlRXh0ZW5zaW9ucyhwYXJhbWV0ZXJzKTtcblx0XHRjb25zdCBjdXN0b21EZWZpbmVzID0gZ2VuZXJhdGVEZWZpbmVzKGRlZmluZXMpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cdFx0bGV0IHByZWZpeFZlcnRleCwgcHJlZml4RnJhZ21lbnQ7XG5cdFx0bGV0IHZlcnNpb25TdHJpbmcgPSBwYXJhbWV0ZXJzLmdsc2xWZXJzaW9uID8gJyN2ZXJzaW9uICcgKyBwYXJhbWV0ZXJzLmdsc2xWZXJzaW9uICsgJ1xcbicgOiAnJztcblxuXHRcdGlmIChwYXJhbWV0ZXJzLmlzUmF3U2hhZGVyTWF0ZXJpYWwpIHtcblx0XHRcdHByZWZpeFZlcnRleCA9IFtjdXN0b21EZWZpbmVzXS5maWx0ZXIoZmlsdGVyRW1wdHlMaW5lKS5qb2luKCdcXG4nKTtcblxuXHRcdFx0aWYgKHByZWZpeFZlcnRleC5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHByZWZpeFZlcnRleCArPSAnXFxuJztcblx0XHRcdH1cblxuXHRcdFx0cHJlZml4RnJhZ21lbnQgPSBbY3VzdG9tRXh0ZW5zaW9ucywgY3VzdG9tRGVmaW5lc10uZmlsdGVyKGZpbHRlckVtcHR5TGluZSkuam9pbignXFxuJyk7XG5cblx0XHRcdGlmIChwcmVmaXhGcmFnbWVudC5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHByZWZpeEZyYWdtZW50ICs9ICdcXG4nO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcmVmaXhWZXJ0ZXggPSBbZ2VuZXJhdGVQcmVjaXNpb24ocGFyYW1ldGVycyksICcjZGVmaW5lIFNIQURFUl9OQU1FICcgKyBwYXJhbWV0ZXJzLnNoYWRlck5hbWUsIGN1c3RvbURlZmluZXMsIHBhcmFtZXRlcnMuaW5zdGFuY2luZyA/ICcjZGVmaW5lIFVTRV9JTlNUQU5DSU5HJyA6ICcnLCBwYXJhbWV0ZXJzLmluc3RhbmNpbmdDb2xvciA/ICcjZGVmaW5lIFVTRV9JTlNUQU5DSU5HX0NPTE9SJyA6ICcnLCBwYXJhbWV0ZXJzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgPyAnI2RlZmluZSBWRVJURVhfVEVYVFVSRVMnIDogJycsICcjZGVmaW5lIEdBTU1BX0ZBQ1RPUiAnICsgZ2FtbWFGYWN0b3JEZWZpbmUsICcjZGVmaW5lIE1BWF9CT05FUyAnICsgcGFyYW1ldGVycy5tYXhCb25lcywgcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2cgPyAnI2RlZmluZSBVU0VfRk9HJyA6ICcnLCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZ0V4cDIgPyAnI2RlZmluZSBGT0dfRVhQMicgOiAnJywgcGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lIFVTRV9FTlZNQVAnIDogJycsIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcE1vZGVEZWZpbmUgOiAnJywgcGFyYW1ldGVycy5saWdodE1hcCA/ICcjZGVmaW5lIFVTRV9MSUdIVE1BUCcgOiAnJywgcGFyYW1ldGVycy5hb01hcCA/ICcjZGVmaW5lIFVTRV9BT01BUCcgOiAnJywgcGFyYW1ldGVycy5lbWlzc2l2ZU1hcCA/ICcjZGVmaW5lIFVTRV9FTUlTU0lWRU1BUCcgOiAnJywgcGFyYW1ldGVycy5idW1wTWFwID8gJyNkZWZpbmUgVVNFX0JVTVBNQVAnIDogJycsIHBhcmFtZXRlcnMubm9ybWFsTWFwID8gJyNkZWZpbmUgVVNFX05PUk1BTE1BUCcgOiAnJywgcGFyYW1ldGVycy5ub3JtYWxNYXAgJiYgcGFyYW1ldGVycy5vYmplY3RTcGFjZU5vcm1hbE1hcCA/ICcjZGVmaW5lIE9CSkVDVFNQQUNFX05PUk1BTE1BUCcgOiAnJywgcGFyYW1ldGVycy5ub3JtYWxNYXAgJiYgcGFyYW1ldGVycy50YW5nZW50U3BhY2VOb3JtYWxNYXAgPyAnI2RlZmluZSBUQU5HRU5UU1BBQ0VfTk9STUFMTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLmNsZWFyY29hdE1hcCA/ICcjZGVmaW5lIFVTRV9DTEVBUkNPQVRNQVAnIDogJycsIHBhcmFtZXRlcnMuY2xlYXJjb2F0Um91Z2huZXNzTWFwID8gJyNkZWZpbmUgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVAnIDogJycsIHBhcmFtZXRlcnMuY2xlYXJjb2F0Tm9ybWFsTWFwID8gJyNkZWZpbmUgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAnIDogJycsIHBhcmFtZXRlcnMuZGlzcGxhY2VtZW50TWFwICYmIHBhcmFtZXRlcnMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA/ICcjZGVmaW5lIFVTRV9ESVNQTEFDRU1FTlRNQVAnIDogJycsIHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVAnIDogJycsIHBhcmFtZXRlcnMuc3BlY3VsYXJJbnRlbnNpdHlNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJJTlRFTlNJVFlNQVAnIDogJycsIHBhcmFtZXRlcnMuc3BlY3VsYXJDb2xvck1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUkNPTE9STUFQJyA6ICcnLCBwYXJhbWV0ZXJzLnJvdWdobmVzc01hcCA/ICcjZGVmaW5lIFVTRV9ST1VHSE5FU1NNQVAnIDogJycsIHBhcmFtZXRlcnMubWV0YWxuZXNzTWFwID8gJyNkZWZpbmUgVVNFX01FVEFMTkVTU01BUCcgOiAnJywgcGFyYW1ldGVycy5hbHBoYU1hcCA/ICcjZGVmaW5lIFVTRV9BTFBIQU1BUCcgOiAnJywgcGFyYW1ldGVycy50cmFuc21pc3Npb24gPyAnI2RlZmluZSBVU0VfVFJBTlNNSVNTSU9OJyA6ICcnLCBwYXJhbWV0ZXJzLnRyYW5zbWlzc2lvbk1hcCA/ICcjZGVmaW5lIFVTRV9UUkFOU01JU1NJT05NQVAnIDogJycsIHBhcmFtZXRlcnMudGhpY2tuZXNzTWFwID8gJyNkZWZpbmUgVVNFX1RISUNLTkVTU01BUCcgOiAnJywgcGFyYW1ldGVycy5zaGVlbkNvbG9yTWFwID8gJyNkZWZpbmUgVVNFX1NIRUVOQ09MT1JNQVAnIDogJycsIHBhcmFtZXRlcnMuc2hlZW5Sb3VnaG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfU0hFRU5ST1VHSE5FU1NNQVAnIDogJycsIHBhcmFtZXRlcnMudmVydGV4VGFuZ2VudHMgPyAnI2RlZmluZSBVU0VfVEFOR0VOVCcgOiAnJywgcGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgPyAnI2RlZmluZSBVU0VfQ09MT1InIDogJycsIHBhcmFtZXRlcnMudmVydGV4QWxwaGFzID8gJyNkZWZpbmUgVVNFX0NPTE9SX0FMUEhBJyA6ICcnLCBwYXJhbWV0ZXJzLnZlcnRleFV2cyA/ICcjZGVmaW5lIFVTRV9VVicgOiAnJywgcGFyYW1ldGVycy51dnNWZXJ0ZXhPbmx5ID8gJyNkZWZpbmUgVVZTX1ZFUlRFWF9PTkxZJyA6ICcnLCBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID8gJyNkZWZpbmUgRkxBVF9TSEFERUQnIDogJycsIHBhcmFtZXRlcnMuc2tpbm5pbmcgPyAnI2RlZmluZSBVU0VfU0tJTk5JTkcnIDogJycsIHBhcmFtZXRlcnMudXNlVmVydGV4VGV4dHVyZSA/ICcjZGVmaW5lIEJPTkVfVEVYVFVSRScgOiAnJywgcGFyYW1ldGVycy5tb3JwaFRhcmdldHMgPyAnI2RlZmluZSBVU0VfTU9SUEhUQVJHRVRTJyA6ICcnLCBwYXJhbWV0ZXJzLm1vcnBoTm9ybWFscyAmJiBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID09PSBmYWxzZSA/ICcjZGVmaW5lIFVTRV9NT1JQSE5PUk1BTFMnIDogJycsIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzICYmIHBhcmFtZXRlcnMuaXNXZWJHTDIgPyAnI2RlZmluZSBNT1JQSFRBUkdFVFNfVEVYVFVSRScgOiAnJywgcGFyYW1ldGVycy5tb3JwaFRhcmdldHMgJiYgcGFyYW1ldGVycy5pc1dlYkdMMiA/ICcjZGVmaW5lIE1PUlBIVEFSR0VUU19DT1VOVCAnICsgcGFyYW1ldGVycy5tb3JwaFRhcmdldHNDb3VudCA6ICcnLCBwYXJhbWV0ZXJzLmRvdWJsZVNpZGVkID8gJyNkZWZpbmUgRE9VQkxFX1NJREVEJyA6ICcnLCBwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/ICcjZGVmaW5lIEZMSVBfU0lERUQnIDogJycsIHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lIFVTRV9TSEFET1dNQVAnIDogJycsIHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lICcgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogJycsIHBhcmFtZXRlcnMuc2l6ZUF0dGVudWF0aW9uID8gJyNkZWZpbmUgVVNFX1NJWkVBVFRFTlVBVElPTicgOiAnJywgcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGJyA6ICcnLCBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgJiYgcGFyYW1ldGVycy5yZW5kZXJlckV4dGVuc2lvbkZyYWdEZXB0aCA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRl9FWFQnIDogJycsICd1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7JywgJ3VuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7JywgJ3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OycsICd1bmlmb3JtIG1hdDQgdmlld01hdHJpeDsnLCAndW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDsnLCAndW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uOycsICd1bmlmb3JtIGJvb2wgaXNPcnRob2dyYXBoaWM7JywgJyNpZmRlZiBVU0VfSU5TVEFOQ0lORycsICdcdGF0dHJpYnV0ZSBtYXQ0IGluc3RhbmNlTWF0cml4OycsICcjZW5kaWYnLCAnI2lmZGVmIFVTRV9JTlNUQU5DSU5HX0NPTE9SJywgJ1x0YXR0cmlidXRlIHZlYzMgaW5zdGFuY2VDb2xvcjsnLCAnI2VuZGlmJywgJ2F0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uOycsICdhdHRyaWJ1dGUgdmVjMyBub3JtYWw7JywgJ2F0dHJpYnV0ZSB2ZWMyIHV2OycsICcjaWZkZWYgVVNFX1RBTkdFTlQnLCAnXHRhdHRyaWJ1dGUgdmVjNCB0YW5nZW50OycsICcjZW5kaWYnLCAnI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApJywgJ1x0YXR0cmlidXRlIHZlYzQgY29sb3I7JywgJyNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApJywgJ1x0YXR0cmlidXRlIHZlYzMgY29sb3I7JywgJyNlbmRpZicsICcjaWYgKCBkZWZpbmVkKCBVU0VfTU9SUEhUQVJHRVRTICkgJiYgISBkZWZpbmVkKCBNT1JQSFRBUkdFVFNfVEVYVFVSRSApICknLCAnXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDA7JywgJ1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQxOycsICdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MjsnLCAnXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDM7JywgJ1x0I2lmZGVmIFVTRV9NT1JQSE5PUk1BTFMnLCAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMDsnLCAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMTsnLCAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMjsnLCAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMzsnLCAnXHQjZWxzZScsICdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ0OycsICdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ1OycsICdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ2OycsICdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ3OycsICdcdCNlbmRpZicsICcjZW5kaWYnLCAnI2lmZGVmIFVTRV9TS0lOTklORycsICdcdGF0dHJpYnV0ZSB2ZWM0IHNraW5JbmRleDsnLCAnXHRhdHRyaWJ1dGUgdmVjNCBza2luV2VpZ2h0OycsICcjZW5kaWYnLCAnXFxuJ10uZmlsdGVyKGZpbHRlckVtcHR5TGluZSkuam9pbignXFxuJyk7XG5cdFx0XHRwcmVmaXhGcmFnbWVudCA9IFtjdXN0b21FeHRlbnNpb25zLCBnZW5lcmF0ZVByZWNpc2lvbihwYXJhbWV0ZXJzKSwgJyNkZWZpbmUgU0hBREVSX05BTUUgJyArIHBhcmFtZXRlcnMuc2hhZGVyTmFtZSwgY3VzdG9tRGVmaW5lcywgJyNkZWZpbmUgR0FNTUFfRkFDVE9SICcgKyBnYW1tYUZhY3RvckRlZmluZSwgcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2cgPyAnI2RlZmluZSBVU0VfRk9HJyA6ICcnLCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZ0V4cDIgPyAnI2RlZmluZSBGT0dfRVhQMicgOiAnJywgcGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLm1hdGNhcCA/ICcjZGVmaW5lIFVTRV9NQVRDQVAnIDogJycsIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgVVNFX0VOVk1BUCcgOiAnJywgcGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwVHlwZURlZmluZSA6ICcnLCBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBNb2RlRGVmaW5lIDogJycsIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcEJsZW5kaW5nRGVmaW5lIDogJycsIHBhcmFtZXRlcnMubGlnaHRNYXAgPyAnI2RlZmluZSBVU0VfTElHSFRNQVAnIDogJycsIHBhcmFtZXRlcnMuYW9NYXAgPyAnI2RlZmluZSBVU0VfQU9NQVAnIDogJycsIHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPyAnI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAnIDogJycsIHBhcmFtZXRlcnMuYnVtcE1hcCA/ICcjZGVmaW5lIFVTRV9CVU1QTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVAnIDogJycsIHBhcmFtZXRlcnMubm9ybWFsTWFwICYmIHBhcmFtZXRlcnMub2JqZWN0U3BhY2VOb3JtYWxNYXAgPyAnI2RlZmluZSBPQkpFQ1RTUEFDRV9OT1JNQUxNQVAnIDogJycsIHBhcmFtZXRlcnMubm9ybWFsTWFwICYmIHBhcmFtZXRlcnMudGFuZ2VudFNwYWNlTm9ybWFsTWFwID8gJyNkZWZpbmUgVEFOR0VOVFNQQUNFX05PUk1BTE1BUCcgOiAnJywgcGFyYW1ldGVycy5jbGVhcmNvYXQgPyAnI2RlZmluZSBVU0VfQ0xFQVJDT0FUJyA6ICcnLCBwYXJhbWV0ZXJzLmNsZWFyY29hdE1hcCA/ICcjZGVmaW5lIFVTRV9DTEVBUkNPQVRNQVAnIDogJycsIHBhcmFtZXRlcnMuY2xlYXJjb2F0Um91Z2huZXNzTWFwID8gJyNkZWZpbmUgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVAnIDogJycsIHBhcmFtZXRlcnMuY2xlYXJjb2F0Tm9ybWFsTWFwID8gJyNkZWZpbmUgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAnIDogJycsIHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVAnIDogJycsIHBhcmFtZXRlcnMuc3BlY3VsYXJJbnRlbnNpdHlNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJJTlRFTlNJVFlNQVAnIDogJycsIHBhcmFtZXRlcnMuc3BlY3VsYXJDb2xvck1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUkNPTE9STUFQJyA6ICcnLCBwYXJhbWV0ZXJzLnJvdWdobmVzc01hcCA/ICcjZGVmaW5lIFVTRV9ST1VHSE5FU1NNQVAnIDogJycsIHBhcmFtZXRlcnMubWV0YWxuZXNzTWFwID8gJyNkZWZpbmUgVVNFX01FVEFMTkVTU01BUCcgOiAnJywgcGFyYW1ldGVycy5hbHBoYU1hcCA/ICcjZGVmaW5lIFVTRV9BTFBIQU1BUCcgOiAnJywgcGFyYW1ldGVycy5hbHBoYVRlc3QgPyAnI2RlZmluZSBVU0VfQUxQSEFURVNUJyA6ICcnLCBwYXJhbWV0ZXJzLnNoZWVuID8gJyNkZWZpbmUgVVNFX1NIRUVOJyA6ICcnLCBwYXJhbWV0ZXJzLnNoZWVuQ29sb3JNYXAgPyAnI2RlZmluZSBVU0VfU0hFRU5DT0xPUk1BUCcgOiAnJywgcGFyYW1ldGVycy5zaGVlblJvdWdobmVzc01hcCA/ICcjZGVmaW5lIFVTRV9TSEVFTlJPVUdITkVTU01BUCcgOiAnJywgcGFyYW1ldGVycy50cmFuc21pc3Npb24gPyAnI2RlZmluZSBVU0VfVFJBTlNNSVNTSU9OJyA6ICcnLCBwYXJhbWV0ZXJzLnRyYW5zbWlzc2lvbk1hcCA/ICcjZGVmaW5lIFVTRV9UUkFOU01JU1NJT05NQVAnIDogJycsIHBhcmFtZXRlcnMudGhpY2tuZXNzTWFwID8gJyNkZWZpbmUgVVNFX1RISUNLTkVTU01BUCcgOiAnJywgcGFyYW1ldGVycy52ZXJ0ZXhUYW5nZW50cyA/ICcjZGVmaW5lIFVTRV9UQU5HRU5UJyA6ICcnLCBwYXJhbWV0ZXJzLnZlcnRleENvbG9ycyB8fCBwYXJhbWV0ZXJzLmluc3RhbmNpbmdDb2xvciA/ICcjZGVmaW5lIFVTRV9DT0xPUicgOiAnJywgcGFyYW1ldGVycy52ZXJ0ZXhBbHBoYXMgPyAnI2RlZmluZSBVU0VfQ09MT1JfQUxQSEEnIDogJycsIHBhcmFtZXRlcnMudmVydGV4VXZzID8gJyNkZWZpbmUgVVNFX1VWJyA6ICcnLCBwYXJhbWV0ZXJzLnV2c1ZlcnRleE9ubHkgPyAnI2RlZmluZSBVVlNfVkVSVEVYX09OTFknIDogJycsIHBhcmFtZXRlcnMuZ3JhZGllbnRNYXAgPyAnI2RlZmluZSBVU0VfR1JBRElFTlRNQVAnIDogJycsIHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPyAnI2RlZmluZSBGTEFUX1NIQURFRCcgOiAnJywgcGFyYW1ldGVycy5kb3VibGVTaWRlZCA/ICcjZGVmaW5lIERPVUJMRV9TSURFRCcgOiAnJywgcGFyYW1ldGVycy5mbGlwU2lkZWQgPyAnI2RlZmluZSBGTElQX1NJREVEJyA6ICcnLCBwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSBVU0VfU0hBRE9XTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSAnICsgc2hhZG93TWFwVHlwZURlZmluZSA6ICcnLCBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSA/ICcjZGVmaW5lIFBSRU1VTFRJUExJRURfQUxQSEEnIDogJycsIHBhcmFtZXRlcnMucGh5c2ljYWxseUNvcnJlY3RMaWdodHMgPyAnI2RlZmluZSBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTJyA6ICcnLCBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUYnIDogJycsIHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiBwYXJhbWV0ZXJzLnJlbmRlcmVyRXh0ZW5zaW9uRnJhZ0RlcHRoID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCcgOiAnJywgKHBhcmFtZXRlcnMuZXh0ZW5zaW9uU2hhZGVyVGV4dHVyZUxPRCB8fCBwYXJhbWV0ZXJzLmVudk1hcCkgJiYgcGFyYW1ldGVycy5yZW5kZXJlckV4dGVuc2lvblNoYWRlclRleHR1cmVMb2QgPyAnI2RlZmluZSBURVhUVVJFX0xPRF9FWFQnIDogJycsICd1bmlmb3JtIG1hdDQgdmlld01hdHJpeDsnLCAndW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uOycsICd1bmlmb3JtIGJvb2wgaXNPcnRob2dyYXBoaWM7JywgcGFyYW1ldGVycy50b25lTWFwcGluZyAhPT0gTm9Ub25lTWFwcGluZyA/ICcjZGVmaW5lIFRPTkVfTUFQUElORycgOiAnJywgcGFyYW1ldGVycy50b25lTWFwcGluZyAhPT0gTm9Ub25lTWFwcGluZyA/IFNoYWRlckNodW5rWyd0b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50J10gOiAnJywgLy8gdGhpcyBjb2RlIGlzIHJlcXVpcmVkIGhlcmUgYmVjYXVzZSBpdCBpcyB1c2VkIGJ5IHRoZSB0b25lTWFwcGluZygpIGZ1bmN0aW9uIGRlZmluZWQgYmVsb3dcblx0XHRcdHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgIT09IE5vVG9uZU1hcHBpbmcgPyBnZXRUb25lTWFwcGluZ0Z1bmN0aW9uKCd0b25lTWFwcGluZycsIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcpIDogJycsIHBhcmFtZXRlcnMuZGl0aGVyaW5nID8gJyNkZWZpbmUgRElUSEVSSU5HJyA6ICcnLCBwYXJhbWV0ZXJzLmZvcm1hdCA9PT0gUkdCRm9ybWF0ID8gJyNkZWZpbmUgT1BBUVVFJyA6ICcnLCBTaGFkZXJDaHVua1snZW5jb2RpbmdzX3BhcnNfZnJhZ21lbnQnXSwgLy8gdGhpcyBjb2RlIGlzIHJlcXVpcmVkIGhlcmUgYmVjYXVzZSBpdCBpcyB1c2VkIGJ5IHRoZSB2YXJpb3VzIGVuY29kaW5nL2RlY29kaW5nIGZ1bmN0aW9uIGRlZmluZWQgYmVsb3dcblx0XHRcdHBhcmFtZXRlcnMubWFwID8gZ2V0VGV4ZWxEZWNvZGluZ0Z1bmN0aW9uKCdtYXBUZXhlbFRvTGluZWFyJywgcGFyYW1ldGVycy5tYXBFbmNvZGluZykgOiAnJywgcGFyYW1ldGVycy5tYXRjYXAgPyBnZXRUZXhlbERlY29kaW5nRnVuY3Rpb24oJ21hdGNhcFRleGVsVG9MaW5lYXInLCBwYXJhbWV0ZXJzLm1hdGNhcEVuY29kaW5nKSA6ICcnLCBwYXJhbWV0ZXJzLmVudk1hcCA/IGdldFRleGVsRGVjb2RpbmdGdW5jdGlvbignZW52TWFwVGV4ZWxUb0xpbmVhcicsIHBhcmFtZXRlcnMuZW52TWFwRW5jb2RpbmcpIDogJycsIHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPyBnZXRUZXhlbERlY29kaW5nRnVuY3Rpb24oJ2VtaXNzaXZlTWFwVGV4ZWxUb0xpbmVhcicsIHBhcmFtZXRlcnMuZW1pc3NpdmVNYXBFbmNvZGluZykgOiAnJywgcGFyYW1ldGVycy5zcGVjdWxhckNvbG9yTWFwID8gZ2V0VGV4ZWxEZWNvZGluZ0Z1bmN0aW9uKCdzcGVjdWxhckNvbG9yTWFwVGV4ZWxUb0xpbmVhcicsIHBhcmFtZXRlcnMuc3BlY3VsYXJDb2xvck1hcEVuY29kaW5nKSA6ICcnLCBwYXJhbWV0ZXJzLnNoZWVuQ29sb3JNYXAgPyBnZXRUZXhlbERlY29kaW5nRnVuY3Rpb24oJ3NoZWVuQ29sb3JNYXBUZXhlbFRvTGluZWFyJywgcGFyYW1ldGVycy5zaGVlbkNvbG9yTWFwRW5jb2RpbmcpIDogJycsIHBhcmFtZXRlcnMubGlnaHRNYXAgPyBnZXRUZXhlbERlY29kaW5nRnVuY3Rpb24oJ2xpZ2h0TWFwVGV4ZWxUb0xpbmVhcicsIHBhcmFtZXRlcnMubGlnaHRNYXBFbmNvZGluZykgOiAnJywgZ2V0VGV4ZWxFbmNvZGluZ0Z1bmN0aW9uKCdsaW5lYXJUb091dHB1dFRleGVsJywgcGFyYW1ldGVycy5vdXRwdXRFbmNvZGluZyksIHBhcmFtZXRlcnMuZGVwdGhQYWNraW5nID8gJyNkZWZpbmUgREVQVEhfUEFDS0lORyAnICsgcGFyYW1ldGVycy5kZXB0aFBhY2tpbmcgOiAnJywgJ1xcbiddLmZpbHRlcihmaWx0ZXJFbXB0eUxpbmUpLmpvaW4oJ1xcbicpO1xuXHRcdH1cblxuXHRcdHZlcnRleFNoYWRlciA9IHJlc29sdmVJbmNsdWRlcyh2ZXJ0ZXhTaGFkZXIpO1xuXHRcdHZlcnRleFNoYWRlciA9IHJlcGxhY2VMaWdodE51bXModmVydGV4U2hhZGVyLCBwYXJhbWV0ZXJzKTtcblx0XHR2ZXJ0ZXhTaGFkZXIgPSByZXBsYWNlQ2xpcHBpbmdQbGFuZU51bXModmVydGV4U2hhZGVyLCBwYXJhbWV0ZXJzKTtcblx0XHRmcmFnbWVudFNoYWRlciA9IHJlc29sdmVJbmNsdWRlcyhmcmFnbWVudFNoYWRlcik7XG5cdFx0ZnJhZ21lbnRTaGFkZXIgPSByZXBsYWNlTGlnaHROdW1zKGZyYWdtZW50U2hhZGVyLCBwYXJhbWV0ZXJzKTtcblx0XHRmcmFnbWVudFNoYWRlciA9IHJlcGxhY2VDbGlwcGluZ1BsYW5lTnVtcyhmcmFnbWVudFNoYWRlciwgcGFyYW1ldGVycyk7XG5cdFx0dmVydGV4U2hhZGVyID0gdW5yb2xsTG9vcHModmVydGV4U2hhZGVyKTtcblx0XHRmcmFnbWVudFNoYWRlciA9IHVucm9sbExvb3BzKGZyYWdtZW50U2hhZGVyKTtcblxuXHRcdGlmIChwYXJhbWV0ZXJzLmlzV2ViR0wyICYmIHBhcmFtZXRlcnMuaXNSYXdTaGFkZXJNYXRlcmlhbCAhPT0gdHJ1ZSkge1xuXHRcdFx0Ly8gR0xTTCAzLjAgY29udmVyc2lvbiBmb3IgYnVpbHQtaW4gbWF0ZXJpYWxzIGFuZCBTaGFkZXJNYXRlcmlhbFxuXHRcdFx0dmVyc2lvblN0cmluZyA9ICcjdmVyc2lvbiAzMDAgZXNcXG4nO1xuXHRcdFx0cHJlZml4VmVydGV4ID0gWydwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkRBcnJheTsnLCAnI2RlZmluZSBhdHRyaWJ1dGUgaW4nLCAnI2RlZmluZSB2YXJ5aW5nIG91dCcsICcjZGVmaW5lIHRleHR1cmUyRCB0ZXh0dXJlJ10uam9pbignXFxuJykgKyAnXFxuJyArIHByZWZpeFZlcnRleDtcblx0XHRcdHByZWZpeEZyYWdtZW50ID0gWycjZGVmaW5lIHZhcnlpbmcgaW4nLCBwYXJhbWV0ZXJzLmdsc2xWZXJzaW9uID09PSBHTFNMMyA/ICcnIDogJ291dCBoaWdocCB2ZWM0IHBjX2ZyYWdDb2xvcjsnLCBwYXJhbWV0ZXJzLmdsc2xWZXJzaW9uID09PSBHTFNMMyA/ICcnIDogJyNkZWZpbmUgZ2xfRnJhZ0NvbG9yIHBjX2ZyYWdDb2xvcicsICcjZGVmaW5lIGdsX0ZyYWdEZXB0aEVYVCBnbF9GcmFnRGVwdGgnLCAnI2RlZmluZSB0ZXh0dXJlMkQgdGV4dHVyZScsICcjZGVmaW5lIHRleHR1cmVDdWJlIHRleHR1cmUnLCAnI2RlZmluZSB0ZXh0dXJlMkRQcm9qIHRleHR1cmVQcm9qJywgJyNkZWZpbmUgdGV4dHVyZTJETG9kRVhUIHRleHR1cmVMb2QnLCAnI2RlZmluZSB0ZXh0dXJlMkRQcm9qTG9kRVhUIHRleHR1cmVQcm9qTG9kJywgJyNkZWZpbmUgdGV4dHVyZUN1YmVMb2RFWFQgdGV4dHVyZUxvZCcsICcjZGVmaW5lIHRleHR1cmUyREdyYWRFWFQgdGV4dHVyZUdyYWQnLCAnI2RlZmluZSB0ZXh0dXJlMkRQcm9qR3JhZEVYVCB0ZXh0dXJlUHJvakdyYWQnLCAnI2RlZmluZSB0ZXh0dXJlQ3ViZUdyYWRFWFQgdGV4dHVyZUdyYWQnXS5qb2luKCdcXG4nKSArICdcXG4nICsgcHJlZml4RnJhZ21lbnQ7XG5cdFx0fVxuXG5cdFx0Y29uc3QgdmVydGV4R2xzbCA9IHZlcnNpb25TdHJpbmcgKyBwcmVmaXhWZXJ0ZXggKyB2ZXJ0ZXhTaGFkZXI7XG5cdFx0Y29uc3QgZnJhZ21lbnRHbHNsID0gdmVyc2lvblN0cmluZyArIHByZWZpeEZyYWdtZW50ICsgZnJhZ21lbnRTaGFkZXI7IC8vIGNvbnNvbGUubG9nKCAnKlZFUlRFWConLCB2ZXJ0ZXhHbHNsICk7XG5cdFx0Ly8gY29uc29sZS5sb2coICcqRlJBR01FTlQqJywgZnJhZ21lbnRHbHNsICk7XG5cblx0XHRjb25zdCBnbFZlcnRleFNoYWRlciA9IFdlYkdMU2hhZGVyKGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhHbHNsKTtcblx0XHRjb25zdCBnbEZyYWdtZW50U2hhZGVyID0gV2ViR0xTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRHbHNsKTtcblx0XHRnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZ2xWZXJ0ZXhTaGFkZXIpO1xuXHRcdGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBnbEZyYWdtZW50U2hhZGVyKTsgLy8gRm9yY2UgYSBwYXJ0aWN1bGFyIGF0dHJpYnV0ZSB0byBpbmRleCAwLlxuXG5cdFx0aWYgKHBhcmFtZXRlcnMuaW5kZXgwQXR0cmlidXRlTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRnbC5iaW5kQXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgMCwgcGFyYW1ldGVycy5pbmRleDBBdHRyaWJ1dGVOYW1lKTtcblx0XHR9IGVsc2UgaWYgKHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID09PSB0cnVlKSB7XG5cdFx0XHQvLyBwcm9ncmFtcyB3aXRoIG1vcnBoVGFyZ2V0cyBkaXNwbGFjZSBwb3NpdGlvbiBvdXQgb2YgYXR0cmlidXRlIDBcblx0XHRcdGdsLmJpbmRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAwLCAncG9zaXRpb24nKTtcblx0XHR9XG5cblx0XHRnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTsgLy8gY2hlY2sgZm9yIGxpbmsgZXJyb3JzXG5cblx0XHRpZiAocmVuZGVyZXIuZGVidWcuY2hlY2tTaGFkZXJFcnJvcnMpIHtcblx0XHRcdGNvbnN0IHByb2dyYW1Mb2cgPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKS50cmltKCk7XG5cdFx0XHRjb25zdCB2ZXJ0ZXhMb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKGdsVmVydGV4U2hhZGVyKS50cmltKCk7XG5cdFx0XHRjb25zdCBmcmFnbWVudExvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coZ2xGcmFnbWVudFNoYWRlcikudHJpbSgpO1xuXHRcdFx0bGV0IHJ1bm5hYmxlID0gdHJ1ZTtcblx0XHRcdGxldCBoYXZlRGlhZ25vc3RpY3MgPSB0cnVlO1xuXG5cdFx0XHRpZiAoZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHJ1bm5hYmxlID0gZmFsc2U7XG5cdFx0XHRcdGNvbnN0IHZlcnRleEVycm9ycyA9IGdldFNoYWRlckVycm9ycyhnbCwgZ2xWZXJ0ZXhTaGFkZXIsICd2ZXJ0ZXgnKTtcblx0XHRcdFx0Y29uc3QgZnJhZ21lbnRFcnJvcnMgPSBnZXRTaGFkZXJFcnJvcnMoZ2wsIGdsRnJhZ21lbnRTaGFkZXIsICdmcmFnbWVudCcpO1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTFByb2dyYW06IFNoYWRlciBFcnJvciAnICsgZ2wuZ2V0RXJyb3IoKSArICcgLSAnICsgJ1ZBTElEQVRFX1NUQVRVUyAnICsgZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5WQUxJREFURV9TVEFUVVMpICsgJ1xcblxcbicgKyAnUHJvZ3JhbSBJbmZvIExvZzogJyArIHByb2dyYW1Mb2cgKyAnXFxuJyArIHZlcnRleEVycm9ycyArICdcXG4nICsgZnJhZ21lbnRFcnJvcnMpO1xuXHRcdFx0fSBlbHNlIGlmIChwcm9ncmFtTG9nICE9PSAnJykge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUHJvZ3JhbTogUHJvZ3JhbSBJbmZvIExvZzonLCBwcm9ncmFtTG9nKTtcblx0XHRcdH0gZWxzZSBpZiAodmVydGV4TG9nID09PSAnJyB8fCBmcmFnbWVudExvZyA9PT0gJycpIHtcblx0XHRcdFx0aGF2ZURpYWdub3N0aWNzID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChoYXZlRGlhZ25vc3RpY3MpIHtcblx0XHRcdFx0dGhpcy5kaWFnbm9zdGljcyA9IHtcblx0XHRcdFx0XHRydW5uYWJsZTogcnVubmFibGUsXG5cdFx0XHRcdFx0cHJvZ3JhbUxvZzogcHJvZ3JhbUxvZyxcblx0XHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IHtcblx0XHRcdFx0XHRcdGxvZzogdmVydGV4TG9nLFxuXHRcdFx0XHRcdFx0cHJlZml4OiBwcmVmaXhWZXJ0ZXhcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGZyYWdtZW50U2hhZGVyOiB7XG5cdFx0XHRcdFx0XHRsb2c6IGZyYWdtZW50TG9nLFxuXHRcdFx0XHRcdFx0cHJlZml4OiBwcmVmaXhGcmFnbWVudFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9IC8vIENsZWFuIHVwXG5cdFx0Ly8gQ3Jhc2hlcyBpbiBpT1M5IGFuZCBpT1MxMC4gIzE4NDAyXG5cdFx0Ly8gZ2wuZGV0YWNoU2hhZGVyKCBwcm9ncmFtLCBnbFZlcnRleFNoYWRlciApO1xuXHRcdC8vIGdsLmRldGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xGcmFnbWVudFNoYWRlciApO1xuXG5cblx0XHRnbC5kZWxldGVTaGFkZXIoZ2xWZXJ0ZXhTaGFkZXIpO1xuXHRcdGdsLmRlbGV0ZVNoYWRlcihnbEZyYWdtZW50U2hhZGVyKTsgLy8gc2V0IHVwIGNhY2hpbmcgZm9yIHVuaWZvcm0gbG9jYXRpb25zXG5cblx0XHRsZXQgY2FjaGVkVW5pZm9ybXM7XG5cblx0XHR0aGlzLmdldFVuaWZvcm1zID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKGNhY2hlZFVuaWZvcm1zID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y2FjaGVkVW5pZm9ybXMgPSBuZXcgV2ViR0xVbmlmb3JtcyhnbCwgcHJvZ3JhbSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjYWNoZWRVbmlmb3Jtcztcblx0XHR9OyAvLyBzZXQgdXAgY2FjaGluZyBmb3IgYXR0cmlidXRlIGxvY2F0aW9uc1xuXG5cblx0XHRsZXQgY2FjaGVkQXR0cmlidXRlcztcblxuXHRcdHRoaXMuZ2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChjYWNoZWRBdHRyaWJ1dGVzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y2FjaGVkQXR0cmlidXRlcyA9IGZldGNoQXR0cmlidXRlTG9jYXRpb25zKGdsLCBwcm9ncmFtKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNhY2hlZEF0dHJpYnV0ZXM7XG5cdFx0fTsgLy8gZnJlZSByZXNvdXJjZVxuXG5cblx0XHR0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRiaW5kaW5nU3RhdGVzLnJlbGVhc2VTdGF0ZXNPZlByb2dyYW0odGhpcyk7XG5cdFx0XHRnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuXHRcdFx0dGhpcy5wcm9ncmFtID0gdW5kZWZpbmVkO1xuXHRcdH07IC8vXG5cblxuXHRcdHRoaXMubmFtZSA9IHBhcmFtZXRlcnMuc2hhZGVyTmFtZTtcblx0XHR0aGlzLmlkID0gcHJvZ3JhbUlkQ291bnQrKztcblx0XHR0aGlzLmNhY2hlS2V5ID0gY2FjaGVLZXk7XG5cdFx0dGhpcy51c2VkVGltZXMgPSAxO1xuXHRcdHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG5cdFx0dGhpcy52ZXJ0ZXhTaGFkZXIgPSBnbFZlcnRleFNoYWRlcjtcblx0XHR0aGlzLmZyYWdtZW50U2hhZGVyID0gZ2xGcmFnbWVudFNoYWRlcjtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGZ1bmN0aW9uIFdlYkdMUHJvZ3JhbXMocmVuZGVyZXIsIGN1YmVtYXBzLCBjdWJldXZtYXBzLCBleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMsIGJpbmRpbmdTdGF0ZXMsIGNsaXBwaW5nKSB7XG5cdFx0Y29uc3QgcHJvZ3JhbXMgPSBbXTtcblx0XHRjb25zdCBpc1dlYkdMMiA9IGNhcGFiaWxpdGllcy5pc1dlYkdMMjtcblx0XHRjb25zdCBsb2dhcml0aG1pY0RlcHRoQnVmZmVyID0gY2FwYWJpbGl0aWVzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXI7XG5cdFx0Y29uc3QgZmxvYXRWZXJ0ZXhUZXh0dXJlcyA9IGNhcGFiaWxpdGllcy5mbG9hdFZlcnRleFRleHR1cmVzO1xuXHRcdGNvbnN0IG1heFZlcnRleFVuaWZvcm1zID0gY2FwYWJpbGl0aWVzLm1heFZlcnRleFVuaWZvcm1zO1xuXHRcdGNvbnN0IHZlcnRleFRleHR1cmVzID0gY2FwYWJpbGl0aWVzLnZlcnRleFRleHR1cmVzO1xuXHRcdGxldCBwcmVjaXNpb24gPSBjYXBhYmlsaXRpZXMucHJlY2lzaW9uO1xuXHRcdGNvbnN0IHNoYWRlcklEcyA9IHtcblx0XHRcdE1lc2hEZXB0aE1hdGVyaWFsOiAnZGVwdGgnLFxuXHRcdFx0TWVzaERpc3RhbmNlTWF0ZXJpYWw6ICdkaXN0YW5jZVJHQkEnLFxuXHRcdFx0TWVzaE5vcm1hbE1hdGVyaWFsOiAnbm9ybWFsJyxcblx0XHRcdE1lc2hCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxuXHRcdFx0TWVzaExhbWJlcnRNYXRlcmlhbDogJ2xhbWJlcnQnLFxuXHRcdFx0TWVzaFBob25nTWF0ZXJpYWw6ICdwaG9uZycsXG5cdFx0XHRNZXNoVG9vbk1hdGVyaWFsOiAndG9vbicsXG5cdFx0XHRNZXNoU3RhbmRhcmRNYXRlcmlhbDogJ3BoeXNpY2FsJyxcblx0XHRcdE1lc2hQaHlzaWNhbE1hdGVyaWFsOiAncGh5c2ljYWwnLFxuXHRcdFx0TWVzaE1hdGNhcE1hdGVyaWFsOiAnbWF0Y2FwJyxcblx0XHRcdExpbmVCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxuXHRcdFx0TGluZURhc2hlZE1hdGVyaWFsOiAnZGFzaGVkJyxcblx0XHRcdFBvaW50c01hdGVyaWFsOiAncG9pbnRzJyxcblx0XHRcdFNoYWRvd01hdGVyaWFsOiAnc2hhZG93Jyxcblx0XHRcdFNwcml0ZU1hdGVyaWFsOiAnc3ByaXRlJ1xuXHRcdH07XG5cdFx0Y29uc3QgcGFyYW1ldGVyTmFtZXMgPSBbJ3ByZWNpc2lvbicsICdpc1dlYkdMMicsICdzdXBwb3J0c1ZlcnRleFRleHR1cmVzJywgJ291dHB1dEVuY29kaW5nJywgJ2luc3RhbmNpbmcnLCAnaW5zdGFuY2luZ0NvbG9yJywgJ21hcCcsICdtYXBFbmNvZGluZycsICdtYXRjYXAnLCAnbWF0Y2FwRW5jb2RpbmcnLCAnZW52TWFwJywgJ2Vudk1hcE1vZGUnLCAnZW52TWFwRW5jb2RpbmcnLCAnZW52TWFwQ3ViZVVWJywgJ2xpZ2h0TWFwJywgJ2xpZ2h0TWFwRW5jb2RpbmcnLCAnYW9NYXAnLCAnZW1pc3NpdmVNYXAnLCAnZW1pc3NpdmVNYXBFbmNvZGluZycsICdidW1wTWFwJywgJ25vcm1hbE1hcCcsICdvYmplY3RTcGFjZU5vcm1hbE1hcCcsICd0YW5nZW50U3BhY2VOb3JtYWxNYXAnLCAnY2xlYXJjb2F0JywgJ2NsZWFyY29hdE1hcCcsICdjbGVhcmNvYXRSb3VnaG5lc3NNYXAnLCAnY2xlYXJjb2F0Tm9ybWFsTWFwJywgJ2Rpc3BsYWNlbWVudE1hcCcsICdzcGVjdWxhck1hcCcsLCAncm91Z2huZXNzTWFwJywgJ21ldGFsbmVzc01hcCcsICdncmFkaWVudE1hcCcsICdhbHBoYU1hcCcsICdhbHBoYVRlc3QnLCAnY29tYmluZScsICd2ZXJ0ZXhDb2xvcnMnLCAndmVydGV4QWxwaGFzJywgJ3ZlcnRleFRhbmdlbnRzJywgJ3ZlcnRleFV2cycsICd1dnNWZXJ0ZXhPbmx5JywgJ2ZvZycsICd1c2VGb2cnLCAnZm9nRXhwMicsICdmbGF0U2hhZGluZycsICdzaXplQXR0ZW51YXRpb24nLCAnbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcicsICdza2lubmluZycsICdtYXhCb25lcycsICd1c2VWZXJ0ZXhUZXh0dXJlJywgJ21vcnBoVGFyZ2V0cycsICdtb3JwaE5vcm1hbHMnLCAnbW9ycGhUYXJnZXRzQ291bnQnLCAncHJlbXVsdGlwbGllZEFscGhhJywgJ251bURpckxpZ2h0cycsICdudW1Qb2ludExpZ2h0cycsICdudW1TcG90TGlnaHRzJywgJ251bUhlbWlMaWdodHMnLCAnbnVtUmVjdEFyZWFMaWdodHMnLCAnbnVtRGlyTGlnaHRTaGFkb3dzJywgJ251bVBvaW50TGlnaHRTaGFkb3dzJywgJ251bVNwb3RMaWdodFNoYWRvd3MnLCAnc2hhZG93TWFwRW5hYmxlZCcsICdzaGFkb3dNYXBUeXBlJywgJ3RvbmVNYXBwaW5nJywgJ3BoeXNpY2FsbHlDb3JyZWN0TGlnaHRzJywgJ2RvdWJsZVNpZGVkJywgJ2ZsaXBTaWRlZCcsICdudW1DbGlwcGluZ1BsYW5lcycsICdudW1DbGlwSW50ZXJzZWN0aW9uJywgJ2RlcHRoUGFja2luZycsICdkaXRoZXJpbmcnLCAnZm9ybWF0JywgJ3NwZWN1bGFySW50ZW5zaXR5TWFwJywgJ3NwZWN1bGFyQ29sb3JNYXAnLCAnc3BlY3VsYXJDb2xvck1hcEVuY29kaW5nJywgJ3RyYW5zbWlzc2lvbicsICd0cmFuc21pc3Npb25NYXAnLCAndGhpY2tuZXNzTWFwJywgJ3NoZWVuJywgJ3NoZWVuQ29sb3JNYXAnLCAnc2hlZW5Db2xvck1hcEVuY29kaW5nJywgJ3NoZWVuUm91Z2huZXNzTWFwJ107XG5cblx0XHRmdW5jdGlvbiBnZXRNYXhCb25lcyhvYmplY3QpIHtcblx0XHRcdGNvbnN0IHNrZWxldG9uID0gb2JqZWN0LnNrZWxldG9uO1xuXHRcdFx0Y29uc3QgYm9uZXMgPSBza2VsZXRvbi5ib25lcztcblxuXHRcdFx0aWYgKGZsb2F0VmVydGV4VGV4dHVyZXMpIHtcblx0XHRcdFx0cmV0dXJuIDEwMjQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBkZWZhdWx0IGZvciB3aGVuIG9iamVjdCBpcyBub3Qgc3BlY2lmaWVkXG5cdFx0XHRcdC8vICggZm9yIGV4YW1wbGUgd2hlbiBwcmVidWlsZGluZyBzaGFkZXIgdG8gYmUgdXNlZCB3aXRoIG11bHRpcGxlIG9iamVjdHMgKVxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvL1x0LSBsZWF2ZSBzb21lIGV4dHJhIHNwYWNlIGZvciBvdGhlciB1bmlmb3Jtc1xuXHRcdFx0XHQvL1x0LSBsaW1pdCBoZXJlIGlzIEFOR0xFJ3MgMjU0IG1heCB1bmlmb3JtIHZlY3RvcnNcblx0XHRcdFx0Ly9cdFx0KHVwIHRvIDU0IHNob3VsZCBiZSBzYWZlKVxuXHRcdFx0XHRjb25zdCBuVmVydGV4VW5pZm9ybXMgPSBtYXhWZXJ0ZXhVbmlmb3Jtcztcblx0XHRcdFx0Y29uc3QgblZlcnRleE1hdHJpY2VzID0gTWF0aC5mbG9vcigoblZlcnRleFVuaWZvcm1zIC0gMjApIC8gNCk7XG5cdFx0XHRcdGNvbnN0IG1heEJvbmVzID0gTWF0aC5taW4oblZlcnRleE1hdHJpY2VzLCBib25lcy5sZW5ndGgpO1xuXG5cdFx0XHRcdGlmIChtYXhCb25lcyA8IGJvbmVzLmxlbmd0aCkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogU2tlbGV0b24gaGFzICcgKyBib25lcy5sZW5ndGggKyAnIGJvbmVzLiBUaGlzIEdQVSBzdXBwb3J0cyAnICsgbWF4Qm9uZXMgKyAnLicpO1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1heEJvbmVzO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFRleHR1cmVFbmNvZGluZ0Zyb21NYXAobWFwKSB7XG5cdFx0XHRsZXQgZW5jb2Rpbmc7XG5cblx0XHRcdGlmIChtYXAgJiYgbWFwLmlzVGV4dHVyZSkge1xuXHRcdFx0XHRlbmNvZGluZyA9IG1hcC5lbmNvZGluZztcblx0XHRcdH0gZWxzZSBpZiAobWFwICYmIG1hcC5pc1dlYkdMUmVuZGVyVGFyZ2V0KSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xQcm9ncmFtcy5nZXRUZXh0dXJlRW5jb2RpbmdGcm9tTWFwOiBkb25cXCd0IHVzZSByZW5kZXIgdGFyZ2V0cyBhcyB0ZXh0dXJlcy4gVXNlIHRoZWlyIC50ZXh0dXJlIHByb3BlcnR5IGluc3RlYWQuJyk7XG5cdFx0XHRcdGVuY29kaW5nID0gbWFwLnRleHR1cmUuZW5jb2Rpbmc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbmNvZGluZyA9IExpbmVhckVuY29kaW5nO1xuXHRcdFx0fVxuXHRcdFx0LyogaWYgKCBpc1dlYkdMMiAmJiBtYXAgJiYgbWFwLmlzVGV4dHVyZSAmJiBtYXAuZm9ybWF0ID09PSBSR0JBRm9ybWF0ICYmIG1hcC50eXBlID09PSBVbnNpZ25lZEJ5dGVUeXBlICYmIG1hcC5lbmNvZGluZyA9PT0gc1JHQkVuY29kaW5nICkge1xuXHRcdFx0XHRcdGVuY29kaW5nID0gTGluZWFyRW5jb2Rpbmc7IC8vIGRpc2FibGUgaW5saW5lIGRlY29kZSBmb3Igc1JHQiB0ZXh0dXJlcyBpbiBXZWJHTCAyXG5cdFx0XHRcdH0gKi9cblxuXG5cdFx0XHRyZXR1cm4gZW5jb2Rpbmc7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0UGFyYW1ldGVycyhtYXRlcmlhbCwgbGlnaHRzLCBzaGFkb3dzLCBzY2VuZSwgb2JqZWN0KSB7XG5cdFx0XHRjb25zdCBmb2cgPSBzY2VuZS5mb2c7XG5cdFx0XHRjb25zdCBlbnZpcm9ubWVudCA9IG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPyBzY2VuZS5lbnZpcm9ubWVudCA6IG51bGw7XG5cdFx0XHRjb25zdCBlbnZNYXAgPSAobWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCA/IGN1YmV1dm1hcHMgOiBjdWJlbWFwcykuZ2V0KG1hdGVyaWFsLmVudk1hcCB8fCBlbnZpcm9ubWVudCk7XG5cdFx0XHRjb25zdCBzaGFkZXJJRCA9IHNoYWRlcklEc1ttYXRlcmlhbC50eXBlXTsgLy8gaGV1cmlzdGljcyB0byBjcmVhdGUgc2hhZGVyIHBhcmFtZXRlcnMgYWNjb3JkaW5nIHRvIGxpZ2h0cyBpbiB0aGUgc2NlbmVcblx0XHRcdC8vIChub3QgdG8gYmxvdyBvdmVyIG1heExpZ2h0cyBidWRnZXQpXG5cblx0XHRcdGNvbnN0IG1heEJvbmVzID0gb2JqZWN0LmlzU2tpbm5lZE1lc2ggPyBnZXRNYXhCb25lcyhvYmplY3QpIDogMDtcblxuXHRcdFx0aWYgKG1hdGVyaWFsLnByZWNpc2lvbiAhPT0gbnVsbCkge1xuXHRcdFx0XHRwcmVjaXNpb24gPSBjYXBhYmlsaXRpZXMuZ2V0TWF4UHJlY2lzaW9uKG1hdGVyaWFsLnByZWNpc2lvbik7XG5cblx0XHRcdFx0aWYgKHByZWNpc2lvbiAhPT0gbWF0ZXJpYWwucHJlY2lzaW9uKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFByb2dyYW0uZ2V0UGFyYW1ldGVyczonLCBtYXRlcmlhbC5wcmVjaXNpb24sICdub3Qgc3VwcG9ydGVkLCB1c2luZycsIHByZWNpc2lvbiwgJ2luc3RlYWQuJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bGV0IHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXI7XG5cblx0XHRcdGlmIChzaGFkZXJJRCkge1xuXHRcdFx0XHRjb25zdCBzaGFkZXIgPSBTaGFkZXJMaWJbc2hhZGVySURdO1xuXHRcdFx0XHR2ZXJ0ZXhTaGFkZXIgPSBzaGFkZXIudmVydGV4U2hhZGVyO1xuXHRcdFx0XHRmcmFnbWVudFNoYWRlciA9IHNoYWRlci5mcmFnbWVudFNoYWRlcjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZlcnRleFNoYWRlciA9IG1hdGVyaWFsLnZlcnRleFNoYWRlcjtcblx0XHRcdFx0ZnJhZ21lbnRTaGFkZXIgPSBtYXRlcmlhbC5mcmFnbWVudFNoYWRlcjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgY3VycmVudFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xuXHRcdFx0Y29uc3QgdXNlQWxwaGFUZXN0ID0gbWF0ZXJpYWwuYWxwaGFUZXN0ID4gMDtcblx0XHRcdGNvbnN0IHVzZUNsZWFyY29hdCA9IG1hdGVyaWFsLmNsZWFyY29hdCA+IDA7XG5cdFx0XHRjb25zdCBwYXJhbWV0ZXJzID0ge1xuXHRcdFx0XHRpc1dlYkdMMjogaXNXZWJHTDIsXG5cdFx0XHRcdHNoYWRlcklEOiBzaGFkZXJJRCxcblx0XHRcdFx0c2hhZGVyTmFtZTogbWF0ZXJpYWwudHlwZSxcblx0XHRcdFx0dmVydGV4U2hhZGVyOiB2ZXJ0ZXhTaGFkZXIsXG5cdFx0XHRcdGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudFNoYWRlcixcblx0XHRcdFx0ZGVmaW5lczogbWF0ZXJpYWwuZGVmaW5lcyxcblx0XHRcdFx0aXNSYXdTaGFkZXJNYXRlcmlhbDogbWF0ZXJpYWwuaXNSYXdTaGFkZXJNYXRlcmlhbCA9PT0gdHJ1ZSxcblx0XHRcdFx0Z2xzbFZlcnNpb246IG1hdGVyaWFsLmdsc2xWZXJzaW9uLFxuXHRcdFx0XHRwcmVjaXNpb246IHByZWNpc2lvbixcblx0XHRcdFx0aW5zdGFuY2luZzogb2JqZWN0LmlzSW5zdGFuY2VkTWVzaCA9PT0gdHJ1ZSxcblx0XHRcdFx0aW5zdGFuY2luZ0NvbG9yOiBvYmplY3QuaXNJbnN0YW5jZWRNZXNoID09PSB0cnVlICYmIG9iamVjdC5pbnN0YW5jZUNvbG9yICE9PSBudWxsLFxuXHRcdFx0XHRzdXBwb3J0c1ZlcnRleFRleHR1cmVzOiB2ZXJ0ZXhUZXh0dXJlcyxcblx0XHRcdFx0b3V0cHV0RW5jb2Rpbmc6IGN1cnJlbnRSZW5kZXJUYXJnZXQgIT09IG51bGwgPyBnZXRUZXh0dXJlRW5jb2RpbmdGcm9tTWFwKGN1cnJlbnRSZW5kZXJUYXJnZXQudGV4dHVyZSkgOiByZW5kZXJlci5vdXRwdXRFbmNvZGluZyxcblx0XHRcdFx0bWFwOiAhIW1hdGVyaWFsLm1hcCxcblx0XHRcdFx0bWFwRW5jb2Rpbmc6IGdldFRleHR1cmVFbmNvZGluZ0Zyb21NYXAobWF0ZXJpYWwubWFwKSxcblx0XHRcdFx0bWF0Y2FwOiAhIW1hdGVyaWFsLm1hdGNhcCxcblx0XHRcdFx0bWF0Y2FwRW5jb2Rpbmc6IGdldFRleHR1cmVFbmNvZGluZ0Zyb21NYXAobWF0ZXJpYWwubWF0Y2FwKSxcblx0XHRcdFx0ZW52TWFwOiAhIWVudk1hcCxcblx0XHRcdFx0ZW52TWFwTW9kZTogZW52TWFwICYmIGVudk1hcC5tYXBwaW5nLFxuXHRcdFx0XHRlbnZNYXBFbmNvZGluZzogZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcChlbnZNYXApLFxuXHRcdFx0XHRlbnZNYXBDdWJlVVY6ICEhZW52TWFwICYmIChlbnZNYXAubWFwcGluZyA9PT0gQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcgfHwgZW52TWFwLm1hcHBpbmcgPT09IEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nKSxcblx0XHRcdFx0bGlnaHRNYXA6ICEhbWF0ZXJpYWwubGlnaHRNYXAsXG5cdFx0XHRcdGxpZ2h0TWFwRW5jb2Rpbmc6IGdldFRleHR1cmVFbmNvZGluZ0Zyb21NYXAobWF0ZXJpYWwubGlnaHRNYXApLFxuXHRcdFx0XHRhb01hcDogISFtYXRlcmlhbC5hb01hcCxcblx0XHRcdFx0ZW1pc3NpdmVNYXA6ICEhbWF0ZXJpYWwuZW1pc3NpdmVNYXAsXG5cdFx0XHRcdGVtaXNzaXZlTWFwRW5jb2Rpbmc6IGdldFRleHR1cmVFbmNvZGluZ0Zyb21NYXAobWF0ZXJpYWwuZW1pc3NpdmVNYXApLFxuXHRcdFx0XHRidW1wTWFwOiAhIW1hdGVyaWFsLmJ1bXBNYXAsXG5cdFx0XHRcdG5vcm1hbE1hcDogISFtYXRlcmlhbC5ub3JtYWxNYXAsXG5cdFx0XHRcdG9iamVjdFNwYWNlTm9ybWFsTWFwOiBtYXRlcmlhbC5ub3JtYWxNYXBUeXBlID09PSBPYmplY3RTcGFjZU5vcm1hbE1hcCxcblx0XHRcdFx0dGFuZ2VudFNwYWNlTm9ybWFsTWFwOiBtYXRlcmlhbC5ub3JtYWxNYXBUeXBlID09PSBUYW5nZW50U3BhY2VOb3JtYWxNYXAsXG5cdFx0XHRcdGNsZWFyY29hdDogdXNlQ2xlYXJjb2F0LFxuXHRcdFx0XHRjbGVhcmNvYXRNYXA6IHVzZUNsZWFyY29hdCAmJiAhIW1hdGVyaWFsLmNsZWFyY29hdE1hcCxcblx0XHRcdFx0Y2xlYXJjb2F0Um91Z2huZXNzTWFwOiB1c2VDbGVhcmNvYXQgJiYgISFtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3NNYXAsXG5cdFx0XHRcdGNsZWFyY29hdE5vcm1hbE1hcDogdXNlQ2xlYXJjb2F0ICYmICEhbWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsTWFwLFxuXHRcdFx0XHRkaXNwbGFjZW1lbnRNYXA6ICEhbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwLFxuXHRcdFx0XHRyb3VnaG5lc3NNYXA6ICEhbWF0ZXJpYWwucm91Z2huZXNzTWFwLFxuXHRcdFx0XHRtZXRhbG5lc3NNYXA6ICEhbWF0ZXJpYWwubWV0YWxuZXNzTWFwLFxuXHRcdFx0XHRzcGVjdWxhck1hcDogISFtYXRlcmlhbC5zcGVjdWxhck1hcCxcblx0XHRcdFx0c3BlY3VsYXJJbnRlbnNpdHlNYXA6ICEhbWF0ZXJpYWwuc3BlY3VsYXJJbnRlbnNpdHlNYXAsXG5cdFx0XHRcdHNwZWN1bGFyQ29sb3JNYXA6ICEhbWF0ZXJpYWwuc3BlY3VsYXJDb2xvck1hcCxcblx0XHRcdFx0c3BlY3VsYXJDb2xvck1hcEVuY29kaW5nOiBnZXRUZXh0dXJlRW5jb2RpbmdGcm9tTWFwKG1hdGVyaWFsLnNwZWN1bGFyQ29sb3JNYXApLFxuXHRcdFx0XHRhbHBoYU1hcDogISFtYXRlcmlhbC5hbHBoYU1hcCxcblx0XHRcdFx0YWxwaGFUZXN0OiB1c2VBbHBoYVRlc3QsXG5cdFx0XHRcdGdyYWRpZW50TWFwOiAhIW1hdGVyaWFsLmdyYWRpZW50TWFwLFxuXHRcdFx0XHRzaGVlbjogbWF0ZXJpYWwuc2hlZW4gPiAwLFxuXHRcdFx0XHRzaGVlbkNvbG9yTWFwOiAhIW1hdGVyaWFsLnNoZWVuQ29sb3JNYXAsXG5cdFx0XHRcdHNoZWVuQ29sb3JNYXBFbmNvZGluZzogZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcChtYXRlcmlhbC5zaGVlbkNvbG9yTWFwKSxcblx0XHRcdFx0c2hlZW5Sb3VnaG5lc3NNYXA6ICEhbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3NNYXAsXG5cdFx0XHRcdHRyYW5zbWlzc2lvbjogbWF0ZXJpYWwudHJhbnNtaXNzaW9uID4gMCxcblx0XHRcdFx0dHJhbnNtaXNzaW9uTWFwOiAhIW1hdGVyaWFsLnRyYW5zbWlzc2lvbk1hcCxcblx0XHRcdFx0dGhpY2tuZXNzTWFwOiAhIW1hdGVyaWFsLnRoaWNrbmVzc01hcCxcblx0XHRcdFx0Y29tYmluZTogbWF0ZXJpYWwuY29tYmluZSxcblx0XHRcdFx0dmVydGV4VGFuZ2VudHM6ICEhbWF0ZXJpYWwubm9ybWFsTWFwICYmICEhb2JqZWN0Lmdlb21ldHJ5ICYmICEhb2JqZWN0Lmdlb21ldHJ5LmF0dHJpYnV0ZXMudGFuZ2VudCxcblx0XHRcdFx0dmVydGV4Q29sb3JzOiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMsXG5cdFx0XHRcdHZlcnRleEFscGhhczogbWF0ZXJpYWwudmVydGV4Q29sb3JzID09PSB0cnVlICYmICEhb2JqZWN0Lmdlb21ldHJ5ICYmICEhb2JqZWN0Lmdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IgJiYgb2JqZWN0Lmdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IuaXRlbVNpemUgPT09IDQsXG5cdFx0XHRcdHZlcnRleFV2czogISFtYXRlcmlhbC5tYXAgfHwgISFtYXRlcmlhbC5idW1wTWFwIHx8ICEhbWF0ZXJpYWwubm9ybWFsTWFwIHx8ICEhbWF0ZXJpYWwuc3BlY3VsYXJNYXAgfHwgISFtYXRlcmlhbC5hbHBoYU1hcCB8fCAhIW1hdGVyaWFsLmVtaXNzaXZlTWFwIHx8ICEhbWF0ZXJpYWwucm91Z2huZXNzTWFwIHx8ICEhbWF0ZXJpYWwubWV0YWxuZXNzTWFwIHx8ICEhbWF0ZXJpYWwuY2xlYXJjb2F0TWFwIHx8ICEhbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzTWFwIHx8ICEhbWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsTWFwIHx8ICEhbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwIHx8ICEhbWF0ZXJpYWwudHJhbnNtaXNzaW9uTWFwIHx8ICEhbWF0ZXJpYWwudGhpY2tuZXNzTWFwIHx8ICEhbWF0ZXJpYWwuc3BlY3VsYXJJbnRlbnNpdHlNYXAgfHwgISFtYXRlcmlhbC5zcGVjdWxhckNvbG9yTWFwIHx8ICEhbWF0ZXJpYWwuc2hlZW5Db2xvck1hcCB8fCBtYXRlcmlhbC5zaGVlblJvdWdobmVzc01hcCxcblx0XHRcdFx0dXZzVmVydGV4T25seTogISghIW1hdGVyaWFsLm1hcCB8fCAhIW1hdGVyaWFsLmJ1bXBNYXAgfHwgISFtYXRlcmlhbC5ub3JtYWxNYXAgfHwgISFtYXRlcmlhbC5zcGVjdWxhck1hcCB8fCAhIW1hdGVyaWFsLmFscGhhTWFwIHx8ICEhbWF0ZXJpYWwuZW1pc3NpdmVNYXAgfHwgISFtYXRlcmlhbC5yb3VnaG5lc3NNYXAgfHwgISFtYXRlcmlhbC5tZXRhbG5lc3NNYXAgfHwgISFtYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxNYXAgfHwgbWF0ZXJpYWwudHJhbnNtaXNzaW9uID4gMCB8fCAhIW1hdGVyaWFsLnRyYW5zbWlzc2lvbk1hcCB8fCAhIW1hdGVyaWFsLnRoaWNrbmVzc01hcCB8fCAhIW1hdGVyaWFsLnNwZWN1bGFySW50ZW5zaXR5TWFwIHx8ICEhbWF0ZXJpYWwuc3BlY3VsYXJDb2xvck1hcCB8fCBtYXRlcmlhbC5zaGVlbiA+IDAgfHwgISFtYXRlcmlhbC5zaGVlbkNvbG9yTWFwIHx8ICEhbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3NNYXApICYmICEhbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwLFxuXHRcdFx0XHRmb2c6ICEhZm9nLFxuXHRcdFx0XHR1c2VGb2c6IG1hdGVyaWFsLmZvZyxcblx0XHRcdFx0Zm9nRXhwMjogZm9nICYmIGZvZy5pc0ZvZ0V4cDIsXG5cdFx0XHRcdGZsYXRTaGFkaW5nOiAhIW1hdGVyaWFsLmZsYXRTaGFkaW5nLFxuXHRcdFx0XHRzaXplQXR0ZW51YXRpb246IG1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbixcblx0XHRcdFx0bG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcjogbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcixcblx0XHRcdFx0c2tpbm5pbmc6IG9iamVjdC5pc1NraW5uZWRNZXNoID09PSB0cnVlICYmIG1heEJvbmVzID4gMCxcblx0XHRcdFx0bWF4Qm9uZXM6IG1heEJvbmVzLFxuXHRcdFx0XHR1c2VWZXJ0ZXhUZXh0dXJlOiBmbG9hdFZlcnRleFRleHR1cmVzLFxuXHRcdFx0XHRtb3JwaFRhcmdldHM6ICEhb2JqZWN0Lmdlb21ldHJ5ICYmICEhb2JqZWN0Lmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbixcblx0XHRcdFx0bW9ycGhOb3JtYWxzOiAhIW9iamVjdC5nZW9tZXRyeSAmJiAhIW9iamVjdC5nZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsLFxuXHRcdFx0XHRtb3JwaFRhcmdldHNDb3VudDogISFvYmplY3QuZ2VvbWV0cnkgJiYgISFvYmplY3QuZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uID8gb2JqZWN0Lmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbi5sZW5ndGggOiAwLFxuXHRcdFx0XHRudW1EaXJMaWdodHM6IGxpZ2h0cy5kaXJlY3Rpb25hbC5sZW5ndGgsXG5cdFx0XHRcdG51bVBvaW50TGlnaHRzOiBsaWdodHMucG9pbnQubGVuZ3RoLFxuXHRcdFx0XHRudW1TcG90TGlnaHRzOiBsaWdodHMuc3BvdC5sZW5ndGgsXG5cdFx0XHRcdG51bVJlY3RBcmVhTGlnaHRzOiBsaWdodHMucmVjdEFyZWEubGVuZ3RoLFxuXHRcdFx0XHRudW1IZW1pTGlnaHRzOiBsaWdodHMuaGVtaS5sZW5ndGgsXG5cdFx0XHRcdG51bURpckxpZ2h0U2hhZG93czogbGlnaHRzLmRpcmVjdGlvbmFsU2hhZG93TWFwLmxlbmd0aCxcblx0XHRcdFx0bnVtUG9pbnRMaWdodFNoYWRvd3M6IGxpZ2h0cy5wb2ludFNoYWRvd01hcC5sZW5ndGgsXG5cdFx0XHRcdG51bVNwb3RMaWdodFNoYWRvd3M6IGxpZ2h0cy5zcG90U2hhZG93TWFwLmxlbmd0aCxcblx0XHRcdFx0bnVtQ2xpcHBpbmdQbGFuZXM6IGNsaXBwaW5nLm51bVBsYW5lcyxcblx0XHRcdFx0bnVtQ2xpcEludGVyc2VjdGlvbjogY2xpcHBpbmcubnVtSW50ZXJzZWN0aW9uLFxuXHRcdFx0XHRmb3JtYXQ6IG1hdGVyaWFsLmZvcm1hdCxcblx0XHRcdFx0ZGl0aGVyaW5nOiBtYXRlcmlhbC5kaXRoZXJpbmcsXG5cdFx0XHRcdHNoYWRvd01hcEVuYWJsZWQ6IHJlbmRlcmVyLnNoYWRvd01hcC5lbmFibGVkICYmIHNoYWRvd3MubGVuZ3RoID4gMCxcblx0XHRcdFx0c2hhZG93TWFwVHlwZTogcmVuZGVyZXIuc2hhZG93TWFwLnR5cGUsXG5cdFx0XHRcdHRvbmVNYXBwaW5nOiBtYXRlcmlhbC50b25lTWFwcGVkID8gcmVuZGVyZXIudG9uZU1hcHBpbmcgOiBOb1RvbmVNYXBwaW5nLFxuXHRcdFx0XHRwaHlzaWNhbGx5Q29ycmVjdExpZ2h0czogcmVuZGVyZXIucGh5c2ljYWxseUNvcnJlY3RMaWdodHMsXG5cdFx0XHRcdHByZW11bHRpcGxpZWRBbHBoYTogbWF0ZXJpYWwucHJlbXVsdGlwbGllZEFscGhhLFxuXHRcdFx0XHRkb3VibGVTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gRG91YmxlU2lkZSxcblx0XHRcdFx0ZmxpcFNpZGVkOiBtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSxcblx0XHRcdFx0ZGVwdGhQYWNraW5nOiBtYXRlcmlhbC5kZXB0aFBhY2tpbmcgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsLmRlcHRoUGFja2luZyA6IGZhbHNlLFxuXHRcdFx0XHRpbmRleDBBdHRyaWJ1dGVOYW1lOiBtYXRlcmlhbC5pbmRleDBBdHRyaWJ1dGVOYW1lLFxuXHRcdFx0XHRleHRlbnNpb25EZXJpdmF0aXZlczogbWF0ZXJpYWwuZXh0ZW5zaW9ucyAmJiBtYXRlcmlhbC5leHRlbnNpb25zLmRlcml2YXRpdmVzLFxuXHRcdFx0XHRleHRlbnNpb25GcmFnRGVwdGg6IG1hdGVyaWFsLmV4dGVuc2lvbnMgJiYgbWF0ZXJpYWwuZXh0ZW5zaW9ucy5mcmFnRGVwdGgsXG5cdFx0XHRcdGV4dGVuc2lvbkRyYXdCdWZmZXJzOiBtYXRlcmlhbC5leHRlbnNpb25zICYmIG1hdGVyaWFsLmV4dGVuc2lvbnMuZHJhd0J1ZmZlcnMsXG5cdFx0XHRcdGV4dGVuc2lvblNoYWRlclRleHR1cmVMT0Q6IG1hdGVyaWFsLmV4dGVuc2lvbnMgJiYgbWF0ZXJpYWwuZXh0ZW5zaW9ucy5zaGFkZXJUZXh0dXJlTE9ELFxuXHRcdFx0XHRyZW5kZXJlckV4dGVuc2lvbkZyYWdEZXB0aDogaXNXZWJHTDIgfHwgZXh0ZW5zaW9ucy5oYXMoJ0VYVF9mcmFnX2RlcHRoJyksXG5cdFx0XHRcdHJlbmRlcmVyRXh0ZW5zaW9uRHJhd0J1ZmZlcnM6IGlzV2ViR0wyIHx8IGV4dGVuc2lvbnMuaGFzKCdXRUJHTF9kcmF3X2J1ZmZlcnMnKSxcblx0XHRcdFx0cmVuZGVyZXJFeHRlbnNpb25TaGFkZXJUZXh0dXJlTG9kOiBpc1dlYkdMMiB8fCBleHRlbnNpb25zLmhhcygnRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCcpLFxuXHRcdFx0XHRjdXN0b21Qcm9ncmFtQ2FjaGVLZXk6IG1hdGVyaWFsLmN1c3RvbVByb2dyYW1DYWNoZUtleSgpXG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHBhcmFtZXRlcnM7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0UHJvZ3JhbUNhY2hlS2V5KHBhcmFtZXRlcnMpIHtcblx0XHRcdGNvbnN0IGFycmF5ID0gW107XG5cblx0XHRcdGlmIChwYXJhbWV0ZXJzLnNoYWRlcklEKSB7XG5cdFx0XHRcdGFycmF5LnB1c2gocGFyYW1ldGVycy5zaGFkZXJJRCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhcnJheS5wdXNoKGhhc2hTdHJpbmcocGFyYW1ldGVycy5mcmFnbWVudFNoYWRlcikpO1xuXHRcdFx0XHRhcnJheS5wdXNoKGhhc2hTdHJpbmcocGFyYW1ldGVycy52ZXJ0ZXhTaGFkZXIpKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHBhcmFtZXRlcnMuZGVmaW5lcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGZvciAoY29uc3QgbmFtZSBpbiBwYXJhbWV0ZXJzLmRlZmluZXMpIHtcblx0XHRcdFx0XHRhcnJheS5wdXNoKG5hbWUpO1xuXHRcdFx0XHRcdGFycmF5LnB1c2gocGFyYW1ldGVycy5kZWZpbmVzW25hbWVdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAocGFyYW1ldGVycy5pc1Jhd1NoYWRlck1hdGVyaWFsID09PSBmYWxzZSkge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtZXRlck5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0YXJyYXkucHVzaChwYXJhbWV0ZXJzW3BhcmFtZXRlck5hbWVzW2ldXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhcnJheS5wdXNoKHJlbmRlcmVyLm91dHB1dEVuY29kaW5nKTtcblx0XHRcdFx0YXJyYXkucHVzaChyZW5kZXJlci5nYW1tYUZhY3Rvcik7XG5cdFx0XHR9XG5cblx0XHRcdGFycmF5LnB1c2gocGFyYW1ldGVycy5jdXN0b21Qcm9ncmFtQ2FjaGVLZXkpO1xuXHRcdFx0cmV0dXJuIGFycmF5LmpvaW4oKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRVbmlmb3JtcyhtYXRlcmlhbCkge1xuXHRcdFx0Y29uc3Qgc2hhZGVySUQgPSBzaGFkZXJJRHNbbWF0ZXJpYWwudHlwZV07XG5cdFx0XHRsZXQgdW5pZm9ybXM7XG5cblx0XHRcdGlmIChzaGFkZXJJRCkge1xuXHRcdFx0XHRjb25zdCBzaGFkZXIgPSBTaGFkZXJMaWJbc2hhZGVySURdO1xuXHRcdFx0XHR1bmlmb3JtcyA9IFVuaWZvcm1zVXRpbHMuY2xvbmUoc2hhZGVyLnVuaWZvcm1zKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHVuaWZvcm1zID0gbWF0ZXJpYWwudW5pZm9ybXM7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bmlmb3Jtcztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhY3F1aXJlUHJvZ3JhbShwYXJhbWV0ZXJzLCBjYWNoZUtleSkge1xuXHRcdFx0bGV0IHByb2dyYW07IC8vIENoZWNrIGlmIGNvZGUgaGFzIGJlZW4gYWxyZWFkeSBjb21waWxlZFxuXG5cdFx0XHRmb3IgKGxldCBwID0gMCwgcGwgPSBwcm9ncmFtcy5sZW5ndGg7IHAgPCBwbDsgcCsrKSB7XG5cdFx0XHRcdGNvbnN0IHByZWV4aXN0aW5nUHJvZ3JhbSA9IHByb2dyYW1zW3BdO1xuXG5cdFx0XHRcdGlmIChwcmVleGlzdGluZ1Byb2dyYW0uY2FjaGVLZXkgPT09IGNhY2hlS2V5KSB7XG5cdFx0XHRcdFx0cHJvZ3JhbSA9IHByZWV4aXN0aW5nUHJvZ3JhbTtcblx0XHRcdFx0XHQrK3Byb2dyYW0udXNlZFRpbWVzO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChwcm9ncmFtID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cHJvZ3JhbSA9IG5ldyBXZWJHTFByb2dyYW0ocmVuZGVyZXIsIGNhY2hlS2V5LCBwYXJhbWV0ZXJzLCBiaW5kaW5nU3RhdGVzKTtcblx0XHRcdFx0cHJvZ3JhbXMucHVzaChwcm9ncmFtKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHByb2dyYW07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVsZWFzZVByb2dyYW0ocHJvZ3JhbSkge1xuXHRcdFx0aWYgKC0tcHJvZ3JhbS51c2VkVGltZXMgPT09IDApIHtcblx0XHRcdFx0Ly8gUmVtb3ZlIGZyb20gdW5vcmRlcmVkIHNldFxuXHRcdFx0XHRjb25zdCBpID0gcHJvZ3JhbXMuaW5kZXhPZihwcm9ncmFtKTtcblx0XHRcdFx0cHJvZ3JhbXNbaV0gPSBwcm9ncmFtc1twcm9ncmFtcy5sZW5ndGggLSAxXTtcblx0XHRcdFx0cHJvZ3JhbXMucG9wKCk7IC8vIEZyZWUgV2ViR0wgcmVzb3VyY2VzXG5cblx0XHRcdFx0cHJvZ3JhbS5kZXN0cm95KCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGdldFBhcmFtZXRlcnM6IGdldFBhcmFtZXRlcnMsXG5cdFx0XHRnZXRQcm9ncmFtQ2FjaGVLZXk6IGdldFByb2dyYW1DYWNoZUtleSxcblx0XHRcdGdldFVuaWZvcm1zOiBnZXRVbmlmb3Jtcyxcblx0XHRcdGFjcXVpcmVQcm9ncmFtOiBhY3F1aXJlUHJvZ3JhbSxcblx0XHRcdHJlbGVhc2VQcm9ncmFtOiByZWxlYXNlUHJvZ3JhbSxcblx0XHRcdC8vIEV4cG9zZWQgZm9yIHJlc291cmNlIG1vbml0b3JpbmcgJiBlcnJvciBmZWVkYmFjayB2aWEgcmVuZGVyZXIuaW5mbzpcblx0XHRcdHByb2dyYW1zOiBwcm9ncmFtc1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTFByb3BlcnRpZXMoKSB7XG5cdFx0bGV0IHByb3BlcnRpZXMgPSBuZXcgV2Vha01hcCgpO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0KG9iamVjdCkge1xuXHRcdFx0bGV0IG1hcCA9IHByb3BlcnRpZXMuZ2V0KG9iamVjdCk7XG5cblx0XHRcdGlmIChtYXAgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRtYXAgPSB7fTtcblx0XHRcdFx0cHJvcGVydGllcy5zZXQob2JqZWN0LCBtYXApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWFwO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbW92ZShvYmplY3QpIHtcblx0XHRcdHByb3BlcnRpZXMuZGVsZXRlKG9iamVjdCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuXHRcdFx0cHJvcGVydGllcy5nZXQob2JqZWN0KVtrZXldID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGlzcG9zZSgpIHtcblx0XHRcdHByb3BlcnRpZXMgPSBuZXcgV2Vha01hcCgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRnZXQ6IGdldCxcblx0XHRcdHJlbW92ZTogcmVtb3ZlLFxuXHRcdFx0dXBkYXRlOiB1cGRhdGUsXG5cdFx0XHRkaXNwb3NlOiBkaXNwb3NlXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIHBhaW50ZXJTb3J0U3RhYmxlKGEsIGIpIHtcblx0XHRpZiAoYS5ncm91cE9yZGVyICE9PSBiLmdyb3VwT3JkZXIpIHtcblx0XHRcdHJldHVybiBhLmdyb3VwT3JkZXIgLSBiLmdyb3VwT3JkZXI7XG5cdFx0fSBlbHNlIGlmIChhLnJlbmRlck9yZGVyICE9PSBiLnJlbmRlck9yZGVyKSB7XG5cdFx0XHRyZXR1cm4gYS5yZW5kZXJPcmRlciAtIGIucmVuZGVyT3JkZXI7XG5cdFx0fSBlbHNlIGlmIChhLnByb2dyYW0gIT09IGIucHJvZ3JhbSkge1xuXHRcdFx0cmV0dXJuIGEucHJvZ3JhbS5pZCAtIGIucHJvZ3JhbS5pZDtcblx0XHR9IGVsc2UgaWYgKGEubWF0ZXJpYWwuaWQgIT09IGIubWF0ZXJpYWwuaWQpIHtcblx0XHRcdHJldHVybiBhLm1hdGVyaWFsLmlkIC0gYi5tYXRlcmlhbC5pZDtcblx0XHR9IGVsc2UgaWYgKGEueiAhPT0gYi56KSB7XG5cdFx0XHRyZXR1cm4gYS56IC0gYi56O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gYS5pZCAtIGIuaWQ7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlKGEsIGIpIHtcblx0XHRpZiAoYS5ncm91cE9yZGVyICE9PSBiLmdyb3VwT3JkZXIpIHtcblx0XHRcdHJldHVybiBhLmdyb3VwT3JkZXIgLSBiLmdyb3VwT3JkZXI7XG5cdFx0fSBlbHNlIGlmIChhLnJlbmRlck9yZGVyICE9PSBiLnJlbmRlck9yZGVyKSB7XG5cdFx0XHRyZXR1cm4gYS5yZW5kZXJPcmRlciAtIGIucmVuZGVyT3JkZXI7XG5cdFx0fSBlbHNlIGlmIChhLnogIT09IGIueikge1xuXHRcdFx0cmV0dXJuIGIueiAtIGEuejtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGEuaWQgLSBiLmlkO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIFdlYkdMUmVuZGVyTGlzdChwcm9wZXJ0aWVzKSB7XG5cdFx0Y29uc3QgcmVuZGVySXRlbXMgPSBbXTtcblx0XHRsZXQgcmVuZGVySXRlbXNJbmRleCA9IDA7XG5cdFx0Y29uc3Qgb3BhcXVlID0gW107XG5cdFx0Y29uc3QgdHJhbnNtaXNzaXZlID0gW107XG5cdFx0Y29uc3QgdHJhbnNwYXJlbnQgPSBbXTtcblx0XHRjb25zdCBkZWZhdWx0UHJvZ3JhbSA9IHtcblx0XHRcdGlkOiAtMVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBpbml0KCkge1xuXHRcdFx0cmVuZGVySXRlbXNJbmRleCA9IDA7XG5cdFx0XHRvcGFxdWUubGVuZ3RoID0gMDtcblx0XHRcdHRyYW5zbWlzc2l2ZS5sZW5ndGggPSAwO1xuXHRcdFx0dHJhbnNwYXJlbnQubGVuZ3RoID0gMDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXROZXh0UmVuZGVySXRlbShvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXBPcmRlciwgeiwgZ3JvdXApIHtcblx0XHRcdGxldCByZW5kZXJJdGVtID0gcmVuZGVySXRlbXNbcmVuZGVySXRlbXNJbmRleF07XG5cdFx0XHRjb25zdCBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldChtYXRlcmlhbCk7XG5cblx0XHRcdGlmIChyZW5kZXJJdGVtID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmVuZGVySXRlbSA9IHtcblx0XHRcdFx0XHRpZDogb2JqZWN0LmlkLFxuXHRcdFx0XHRcdG9iamVjdDogb2JqZWN0LFxuXHRcdFx0XHRcdGdlb21ldHJ5OiBnZW9tZXRyeSxcblx0XHRcdFx0XHRtYXRlcmlhbDogbWF0ZXJpYWwsXG5cdFx0XHRcdFx0cHJvZ3JhbTogbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0gfHwgZGVmYXVsdFByb2dyYW0sXG5cdFx0XHRcdFx0Z3JvdXBPcmRlcjogZ3JvdXBPcmRlcixcblx0XHRcdFx0XHRyZW5kZXJPcmRlcjogb2JqZWN0LnJlbmRlck9yZGVyLFxuXHRcdFx0XHRcdHo6IHosXG5cdFx0XHRcdFx0Z3JvdXA6IGdyb3VwXG5cdFx0XHRcdH07XG5cdFx0XHRcdHJlbmRlckl0ZW1zW3JlbmRlckl0ZW1zSW5kZXhdID0gcmVuZGVySXRlbTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlbmRlckl0ZW0uaWQgPSBvYmplY3QuaWQ7XG5cdFx0XHRcdHJlbmRlckl0ZW0ub2JqZWN0ID0gb2JqZWN0O1xuXHRcdFx0XHRyZW5kZXJJdGVtLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG5cdFx0XHRcdHJlbmRlckl0ZW0ubWF0ZXJpYWwgPSBtYXRlcmlhbDtcblx0XHRcdFx0cmVuZGVySXRlbS5wcm9ncmFtID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0gfHwgZGVmYXVsdFByb2dyYW07XG5cdFx0XHRcdHJlbmRlckl0ZW0uZ3JvdXBPcmRlciA9IGdyb3VwT3JkZXI7XG5cdFx0XHRcdHJlbmRlckl0ZW0ucmVuZGVyT3JkZXIgPSBvYmplY3QucmVuZGVyT3JkZXI7XG5cdFx0XHRcdHJlbmRlckl0ZW0ueiA9IHo7XG5cdFx0XHRcdHJlbmRlckl0ZW0uZ3JvdXAgPSBncm91cDtcblx0XHRcdH1cblxuXHRcdFx0cmVuZGVySXRlbXNJbmRleCsrO1xuXHRcdFx0cmV0dXJuIHJlbmRlckl0ZW07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcHVzaChvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXBPcmRlciwgeiwgZ3JvdXApIHtcblx0XHRcdGNvbnN0IHJlbmRlckl0ZW0gPSBnZXROZXh0UmVuZGVySXRlbShvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXBPcmRlciwgeiwgZ3JvdXApO1xuXG5cdFx0XHRpZiAobWF0ZXJpYWwudHJhbnNtaXNzaW9uID4gMC4wKSB7XG5cdFx0XHRcdHRyYW5zbWlzc2l2ZS5wdXNoKHJlbmRlckl0ZW0pO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHR0cmFuc3BhcmVudC5wdXNoKHJlbmRlckl0ZW0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3BhcXVlLnB1c2gocmVuZGVySXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdW5zaGlmdChvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXBPcmRlciwgeiwgZ3JvdXApIHtcblx0XHRcdGNvbnN0IHJlbmRlckl0ZW0gPSBnZXROZXh0UmVuZGVySXRlbShvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXBPcmRlciwgeiwgZ3JvdXApO1xuXG5cdFx0XHRpZiAobWF0ZXJpYWwudHJhbnNtaXNzaW9uID4gMC4wKSB7XG5cdFx0XHRcdHRyYW5zbWlzc2l2ZS51bnNoaWZ0KHJlbmRlckl0ZW0pO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHR0cmFuc3BhcmVudC51bnNoaWZ0KHJlbmRlckl0ZW0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3BhcXVlLnVuc2hpZnQocmVuZGVySXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc29ydChjdXN0b21PcGFxdWVTb3J0LCBjdXN0b21UcmFuc3BhcmVudFNvcnQpIHtcblx0XHRcdGlmIChvcGFxdWUubGVuZ3RoID4gMSkgb3BhcXVlLnNvcnQoY3VzdG9tT3BhcXVlU29ydCB8fCBwYWludGVyU29ydFN0YWJsZSk7XG5cdFx0XHRpZiAodHJhbnNtaXNzaXZlLmxlbmd0aCA+IDEpIHRyYW5zbWlzc2l2ZS5zb3J0KGN1c3RvbVRyYW5zcGFyZW50U29ydCB8fCByZXZlcnNlUGFpbnRlclNvcnRTdGFibGUpO1xuXHRcdFx0aWYgKHRyYW5zcGFyZW50Lmxlbmd0aCA+IDEpIHRyYW5zcGFyZW50LnNvcnQoY3VzdG9tVHJhbnNwYXJlbnRTb3J0IHx8IHJldmVyc2VQYWludGVyU29ydFN0YWJsZSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZmluaXNoKCkge1xuXHRcdFx0Ly8gQ2xlYXIgcmVmZXJlbmNlcyBmcm9tIGluYWN0aXZlIHJlbmRlckl0ZW1zIGluIHRoZSBsaXN0XG5cdFx0XHRmb3IgKGxldCBpID0gcmVuZGVySXRlbXNJbmRleCwgaWwgPSByZW5kZXJJdGVtcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHJlbmRlckl0ZW0gPSByZW5kZXJJdGVtc1tpXTtcblx0XHRcdFx0aWYgKHJlbmRlckl0ZW0uaWQgPT09IG51bGwpIGJyZWFrO1xuXHRcdFx0XHRyZW5kZXJJdGVtLmlkID0gbnVsbDtcblx0XHRcdFx0cmVuZGVySXRlbS5vYmplY3QgPSBudWxsO1xuXHRcdFx0XHRyZW5kZXJJdGVtLmdlb21ldHJ5ID0gbnVsbDtcblx0XHRcdFx0cmVuZGVySXRlbS5tYXRlcmlhbCA9IG51bGw7XG5cdFx0XHRcdHJlbmRlckl0ZW0ucHJvZ3JhbSA9IG51bGw7XG5cdFx0XHRcdHJlbmRlckl0ZW0uZ3JvdXAgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRvcGFxdWU6IG9wYXF1ZSxcblx0XHRcdHRyYW5zbWlzc2l2ZTogdHJhbnNtaXNzaXZlLFxuXHRcdFx0dHJhbnNwYXJlbnQ6IHRyYW5zcGFyZW50LFxuXHRcdFx0aW5pdDogaW5pdCxcblx0XHRcdHB1c2g6IHB1c2gsXG5cdFx0XHR1bnNoaWZ0OiB1bnNoaWZ0LFxuXHRcdFx0ZmluaXNoOiBmaW5pc2gsXG5cdFx0XHRzb3J0OiBzb3J0XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIFdlYkdMUmVuZGVyTGlzdHMocHJvcGVydGllcykge1xuXHRcdGxldCBsaXN0cyA9IG5ldyBXZWFrTWFwKCk7XG5cblx0XHRmdW5jdGlvbiBnZXQoc2NlbmUsIHJlbmRlckNhbGxEZXB0aCkge1xuXHRcdFx0bGV0IGxpc3Q7XG5cblx0XHRcdGlmIChsaXN0cy5oYXMoc2NlbmUpID09PSBmYWxzZSkge1xuXHRcdFx0XHRsaXN0ID0gbmV3IFdlYkdMUmVuZGVyTGlzdChwcm9wZXJ0aWVzKTtcblx0XHRcdFx0bGlzdHMuc2V0KHNjZW5lLCBbbGlzdF0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHJlbmRlckNhbGxEZXB0aCA+PSBsaXN0cy5nZXQoc2NlbmUpLmxlbmd0aCkge1xuXHRcdFx0XHRcdGxpc3QgPSBuZXcgV2ViR0xSZW5kZXJMaXN0KHByb3BlcnRpZXMpO1xuXHRcdFx0XHRcdGxpc3RzLmdldChzY2VuZSkucHVzaChsaXN0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gbGlzdHMuZ2V0KHNjZW5lKVtyZW5kZXJDYWxsRGVwdGhdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBsaXN0O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cdFx0XHRsaXN0cyA9IG5ldyBXZWFrTWFwKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGdldDogZ2V0LFxuXHRcdFx0ZGlzcG9zZTogZGlzcG9zZVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBVbmlmb3Jtc0NhY2hlKCkge1xuXHRcdGNvbnN0IGxpZ2h0cyA9IHt9O1xuXHRcdHJldHVybiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uIChsaWdodCkge1xuXHRcdFx0XHRpZiAobGlnaHRzW2xpZ2h0LmlkXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGxpZ2h0c1tsaWdodC5pZF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsZXQgdW5pZm9ybXM7XG5cblx0XHRcdFx0c3dpdGNoIChsaWdodC50eXBlKSB7XG5cdFx0XHRcdFx0Y2FzZSAnRGlyZWN0aW9uYWxMaWdodCc6XG5cdFx0XHRcdFx0XHR1bmlmb3JtcyA9IHtcblx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uOiBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRcdFx0XHRjb2xvcjogbmV3IENvbG9yKClcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1Nwb3RMaWdodCc6XG5cdFx0XHRcdFx0XHR1bmlmb3JtcyA9IHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb246IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHRcdGRpcmVjdGlvbjogbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0XHRcdFx0Y29sb3I6IG5ldyBDb2xvcigpLFxuXHRcdFx0XHRcdFx0XHRkaXN0YW5jZTogMCxcblx0XHRcdFx0XHRcdFx0Y29uZUNvczogMCxcblx0XHRcdFx0XHRcdFx0cGVudW1icmFDb3M6IDAsXG5cdFx0XHRcdFx0XHRcdGRlY2F5OiAwXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdQb2ludExpZ2h0Jzpcblx0XHRcdFx0XHRcdHVuaWZvcm1zID0ge1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbjogbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0XHRcdFx0Y29sb3I6IG5ldyBDb2xvcigpLFxuXHRcdFx0XHRcdFx0XHRkaXN0YW5jZTogMCxcblx0XHRcdFx0XHRcdFx0ZGVjYXk6IDBcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0hlbWlzcGhlcmVMaWdodCc6XG5cdFx0XHRcdFx0XHR1bmlmb3JtcyA9IHtcblx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uOiBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRcdFx0XHRza3lDb2xvcjogbmV3IENvbG9yKCksXG5cdFx0XHRcdFx0XHRcdGdyb3VuZENvbG9yOiBuZXcgQ29sb3IoKVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnUmVjdEFyZWFMaWdodCc6XG5cdFx0XHRcdFx0XHR1bmlmb3JtcyA9IHtcblx0XHRcdFx0XHRcdFx0Y29sb3I6IG5ldyBDb2xvcigpLFxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbjogbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0XHRcdFx0aGFsZldpZHRoOiBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRcdFx0XHRoYWxmSGVpZ2h0OiBuZXcgVmVjdG9yMygpXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsaWdodHNbbGlnaHQuaWRdID0gdW5pZm9ybXM7XG5cdFx0XHRcdHJldHVybiB1bmlmb3Jtcztcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gU2hhZG93VW5pZm9ybXNDYWNoZSgpIHtcblx0XHRjb25zdCBsaWdodHMgPSB7fTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAobGlnaHQpIHtcblx0XHRcdFx0aWYgKGxpZ2h0c1tsaWdodC5pZF0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJldHVybiBsaWdodHNbbGlnaHQuaWRdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGV0IHVuaWZvcm1zO1xuXG5cdFx0XHRcdHN3aXRjaCAobGlnaHQudHlwZSkge1xuXHRcdFx0XHRcdGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxuXHRcdFx0XHRcdFx0dW5pZm9ybXMgPSB7XG5cdFx0XHRcdFx0XHRcdHNoYWRvd0JpYXM6IDAsXG5cdFx0XHRcdFx0XHRcdHNoYWRvd05vcm1hbEJpYXM6IDAsXG5cdFx0XHRcdFx0XHRcdHNoYWRvd1JhZGl1czogMSxcblx0XHRcdFx0XHRcdFx0c2hhZG93TWFwU2l6ZTogbmV3IFZlY3RvcjIoKVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnU3BvdExpZ2h0Jzpcblx0XHRcdFx0XHRcdHVuaWZvcm1zID0ge1xuXHRcdFx0XHRcdFx0XHRzaGFkb3dCaWFzOiAwLFxuXHRcdFx0XHRcdFx0XHRzaGFkb3dOb3JtYWxCaWFzOiAwLFxuXHRcdFx0XHRcdFx0XHRzaGFkb3dSYWRpdXM6IDEsXG5cdFx0XHRcdFx0XHRcdHNoYWRvd01hcFNpemU6IG5ldyBWZWN0b3IyKClcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1BvaW50TGlnaHQnOlxuXHRcdFx0XHRcdFx0dW5pZm9ybXMgPSB7XG5cdFx0XHRcdFx0XHRcdHNoYWRvd0JpYXM6IDAsXG5cdFx0XHRcdFx0XHRcdHNoYWRvd05vcm1hbEJpYXM6IDAsXG5cdFx0XHRcdFx0XHRcdHNoYWRvd1JhZGl1czogMSxcblx0XHRcdFx0XHRcdFx0c2hhZG93TWFwU2l6ZTogbmV3IFZlY3RvcjIoKSxcblx0XHRcdFx0XHRcdFx0c2hhZG93Q2FtZXJhTmVhcjogMSxcblx0XHRcdFx0XHRcdFx0c2hhZG93Q2FtZXJhRmFyOiAxMDAwXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Ly8gVE9ETyAoYWJlbG5hdGlvbik6IHNldCBSZWN0QXJlYUxpZ2h0IHNoYWRvdyB1bmlmb3Jtc1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGlnaHRzW2xpZ2h0LmlkXSA9IHVuaWZvcm1zO1xuXHRcdFx0XHRyZXR1cm4gdW5pZm9ybXM7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdGxldCBuZXh0VmVyc2lvbiA9IDA7XG5cblx0ZnVuY3Rpb24gc2hhZG93Q2FzdGluZ0xpZ2h0c0ZpcnN0KGxpZ2h0QSwgbGlnaHRCKSB7XG5cdFx0cmV0dXJuIChsaWdodEIuY2FzdFNoYWRvdyA/IDEgOiAwKSAtIChsaWdodEEuY2FzdFNoYWRvdyA/IDEgOiAwKTtcblx0fVxuXG5cdGZ1bmN0aW9uIFdlYkdMTGlnaHRzKGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcykge1xuXHRcdGNvbnN0IGNhY2hlID0gbmV3IFVuaWZvcm1zQ2FjaGUoKTtcblx0XHRjb25zdCBzaGFkb3dDYWNoZSA9IFNoYWRvd1VuaWZvcm1zQ2FjaGUoKTtcblx0XHRjb25zdCBzdGF0ZSA9IHtcblx0XHRcdHZlcnNpb246IDAsXG5cdFx0XHRoYXNoOiB7XG5cdFx0XHRcdGRpcmVjdGlvbmFsTGVuZ3RoOiAtMSxcblx0XHRcdFx0cG9pbnRMZW5ndGg6IC0xLFxuXHRcdFx0XHRzcG90TGVuZ3RoOiAtMSxcblx0XHRcdFx0cmVjdEFyZWFMZW5ndGg6IC0xLFxuXHRcdFx0XHRoZW1pTGVuZ3RoOiAtMSxcblx0XHRcdFx0bnVtRGlyZWN0aW9uYWxTaGFkb3dzOiAtMSxcblx0XHRcdFx0bnVtUG9pbnRTaGFkb3dzOiAtMSxcblx0XHRcdFx0bnVtU3BvdFNoYWRvd3M6IC0xXG5cdFx0XHR9LFxuXHRcdFx0YW1iaWVudDogWzAsIDAsIDBdLFxuXHRcdFx0cHJvYmU6IFtdLFxuXHRcdFx0ZGlyZWN0aW9uYWw6IFtdLFxuXHRcdFx0ZGlyZWN0aW9uYWxTaGFkb3c6IFtdLFxuXHRcdFx0ZGlyZWN0aW9uYWxTaGFkb3dNYXA6IFtdLFxuXHRcdFx0ZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXg6IFtdLFxuXHRcdFx0c3BvdDogW10sXG5cdFx0XHRzcG90U2hhZG93OiBbXSxcblx0XHRcdHNwb3RTaGFkb3dNYXA6IFtdLFxuXHRcdFx0c3BvdFNoYWRvd01hdHJpeDogW10sXG5cdFx0XHRyZWN0QXJlYTogW10sXG5cdFx0XHRyZWN0QXJlYUxUQzE6IG51bGwsXG5cdFx0XHRyZWN0QXJlYUxUQzI6IG51bGwsXG5cdFx0XHRwb2ludDogW10sXG5cdFx0XHRwb2ludFNoYWRvdzogW10sXG5cdFx0XHRwb2ludFNoYWRvd01hcDogW10sXG5cdFx0XHRwb2ludFNoYWRvd01hdHJpeDogW10sXG5cdFx0XHRoZW1pOiBbXVxuXHRcdH07XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykgc3RhdGUucHJvYmUucHVzaChuZXcgVmVjdG9yMygpKTtcblxuXHRcdGNvbnN0IHZlY3RvcjMgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IG1hdHJpeDQgPSBuZXcgTWF0cml4NCgpO1xuXHRcdGNvbnN0IG1hdHJpeDQyID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdGZ1bmN0aW9uIHNldHVwKGxpZ2h0cywgcGh5c2ljYWxseUNvcnJlY3RMaWdodHMpIHtcblx0XHRcdGxldCByID0gMCxcblx0XHRcdFx0XHRnID0gMCxcblx0XHRcdFx0XHRiID0gMDtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHN0YXRlLnByb2JlW2ldLnNldCgwLCAwLCAwKTtcblxuXHRcdFx0bGV0IGRpcmVjdGlvbmFsTGVuZ3RoID0gMDtcblx0XHRcdGxldCBwb2ludExlbmd0aCA9IDA7XG5cdFx0XHRsZXQgc3BvdExlbmd0aCA9IDA7XG5cdFx0XHRsZXQgcmVjdEFyZWFMZW5ndGggPSAwO1xuXHRcdFx0bGV0IGhlbWlMZW5ndGggPSAwO1xuXHRcdFx0bGV0IG51bURpcmVjdGlvbmFsU2hhZG93cyA9IDA7XG5cdFx0XHRsZXQgbnVtUG9pbnRTaGFkb3dzID0gMDtcblx0XHRcdGxldCBudW1TcG90U2hhZG93cyA9IDA7XG5cdFx0XHRsaWdodHMuc29ydChzaGFkb3dDYXN0aW5nTGlnaHRzRmlyc3QpOyAvLyBhcnRpc3QtZnJpZW5kbHkgbGlnaHQgaW50ZW5zaXR5IHNjYWxpbmcgZmFjdG9yXG5cblx0XHRcdGNvbnN0IHNjYWxlRmFjdG9yID0gcGh5c2ljYWxseUNvcnJlY3RMaWdodHMgIT09IHRydWUgPyBNYXRoLlBJIDogMTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBsaWdodHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGxpZ2h0ID0gbGlnaHRzW2ldO1xuXHRcdFx0XHRjb25zdCBjb2xvciA9IGxpZ2h0LmNvbG9yO1xuXHRcdFx0XHRjb25zdCBpbnRlbnNpdHkgPSBsaWdodC5pbnRlbnNpdHk7XG5cdFx0XHRcdGNvbnN0IGRpc3RhbmNlID0gbGlnaHQuZGlzdGFuY2U7XG5cdFx0XHRcdGNvbnN0IHNoYWRvd01hcCA9IGxpZ2h0LnNoYWRvdyAmJiBsaWdodC5zaGFkb3cubWFwID8gbGlnaHQuc2hhZG93Lm1hcC50ZXh0dXJlIDogbnVsbDtcblxuXHRcdFx0XHRpZiAobGlnaHQuaXNBbWJpZW50TGlnaHQpIHtcblx0XHRcdFx0XHRyICs9IGNvbG9yLnIgKiBpbnRlbnNpdHkgKiBzY2FsZUZhY3Rvcjtcblx0XHRcdFx0XHRnICs9IGNvbG9yLmcgKiBpbnRlbnNpdHkgKiBzY2FsZUZhY3Rvcjtcblx0XHRcdFx0XHRiICs9IGNvbG9yLmIgKiBpbnRlbnNpdHkgKiBzY2FsZUZhY3Rvcjtcblx0XHRcdFx0fSBlbHNlIGlmIChsaWdodC5pc0xpZ2h0UHJvYmUpIHtcblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IDk7IGorKykge1xuXHRcdFx0XHRcdFx0c3RhdGUucHJvYmVbal0uYWRkU2NhbGVkVmVjdG9yKGxpZ2h0LnNoLmNvZWZmaWNpZW50c1tqXSwgaW50ZW5zaXR5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAobGlnaHQuaXNEaXJlY3Rpb25hbExpZ2h0KSB7XG5cdFx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBjYWNoZS5nZXQobGlnaHQpO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmNvbG9yLmNvcHkobGlnaHQuY29sb3IpLm11bHRpcGx5U2NhbGFyKGxpZ2h0LmludGVuc2l0eSAqIHNjYWxlRmFjdG9yKTtcblxuXHRcdFx0XHRcdGlmIChsaWdodC5jYXN0U2hhZG93KSB7XG5cdFx0XHRcdFx0XHRjb25zdCBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XG5cdFx0XHRcdFx0XHRjb25zdCBzaGFkb3dVbmlmb3JtcyA9IHNoYWRvd0NhY2hlLmdldChsaWdodCk7XG5cdFx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dCaWFzID0gc2hhZG93LmJpYXM7XG5cdFx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dOb3JtYWxCaWFzID0gc2hhZG93Lm5vcm1hbEJpYXM7XG5cdFx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dSYWRpdXMgPSBzaGFkb3cucmFkaXVzO1xuXHRcdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93TWFwU2l6ZSA9IHNoYWRvdy5tYXBTaXplO1xuXHRcdFx0XHRcdFx0c3RhdGUuZGlyZWN0aW9uYWxTaGFkb3dbZGlyZWN0aW9uYWxMZW5ndGhdID0gc2hhZG93VW5pZm9ybXM7XG5cdFx0XHRcdFx0XHRzdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hcFtkaXJlY3Rpb25hbExlbmd0aF0gPSBzaGFkb3dNYXA7XG5cdFx0XHRcdFx0XHRzdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hdHJpeFtkaXJlY3Rpb25hbExlbmd0aF0gPSBsaWdodC5zaGFkb3cubWF0cml4O1xuXHRcdFx0XHRcdFx0bnVtRGlyZWN0aW9uYWxTaGFkb3dzKys7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c3RhdGUuZGlyZWN0aW9uYWxbZGlyZWN0aW9uYWxMZW5ndGhdID0gdW5pZm9ybXM7XG5cdFx0XHRcdFx0ZGlyZWN0aW9uYWxMZW5ndGgrKztcblx0XHRcdFx0fSBlbHNlIGlmIChsaWdodC5pc1Nwb3RMaWdodCkge1xuXHRcdFx0XHRcdGNvbnN0IHVuaWZvcm1zID0gY2FjaGUuZ2V0KGxpZ2h0KTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24obGlnaHQubWF0cml4V29ybGQpO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmNvbG9yLmNvcHkoY29sb3IpLm11bHRpcGx5U2NhbGFyKGludGVuc2l0eSAqIHNjYWxlRmFjdG9yKTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmNvbmVDb3MgPSBNYXRoLmNvcyhsaWdodC5hbmdsZSk7XG5cdFx0XHRcdFx0dW5pZm9ybXMucGVudW1icmFDb3MgPSBNYXRoLmNvcyhsaWdodC5hbmdsZSAqICgxIC0gbGlnaHQucGVudW1icmEpKTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5kZWNheSA9IGxpZ2h0LmRlY2F5O1xuXG5cdFx0XHRcdFx0aWYgKGxpZ2h0LmNhc3RTaGFkb3cpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHNoYWRvdyA9IGxpZ2h0LnNoYWRvdztcblx0XHRcdFx0XHRcdGNvbnN0IHNoYWRvd1VuaWZvcm1zID0gc2hhZG93Q2FjaGUuZ2V0KGxpZ2h0KTtcblx0XHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd0JpYXMgPSBzaGFkb3cuYmlhcztcblx0XHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd05vcm1hbEJpYXMgPSBzaGFkb3cubm9ybWFsQmlhcztcblx0XHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd1JhZGl1cyA9IHNoYWRvdy5yYWRpdXM7XG5cdFx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dNYXBTaXplID0gc2hhZG93Lm1hcFNpemU7XG5cdFx0XHRcdFx0XHRzdGF0ZS5zcG90U2hhZG93W3Nwb3RMZW5ndGhdID0gc2hhZG93VW5pZm9ybXM7XG5cdFx0XHRcdFx0XHRzdGF0ZS5zcG90U2hhZG93TWFwW3Nwb3RMZW5ndGhdID0gc2hhZG93TWFwO1xuXHRcdFx0XHRcdFx0c3RhdGUuc3BvdFNoYWRvd01hdHJpeFtzcG90TGVuZ3RoXSA9IGxpZ2h0LnNoYWRvdy5tYXRyaXg7XG5cdFx0XHRcdFx0XHRudW1TcG90U2hhZG93cysrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHN0YXRlLnNwb3Rbc3BvdExlbmd0aF0gPSB1bmlmb3Jtcztcblx0XHRcdFx0XHRzcG90TGVuZ3RoKys7XG5cdFx0XHRcdH0gZWxzZSBpZiAobGlnaHQuaXNSZWN0QXJlYUxpZ2h0KSB7XG5cdFx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBjYWNoZS5nZXQobGlnaHQpOyAvLyAoYSkgaW50ZW5zaXR5IGlzIHRoZSB0b3RhbCB2aXNpYmxlIGxpZ2h0IGVtaXR0ZWRcblx0XHRcdFx0XHQvL3VuaWZvcm1zLmNvbG9yLmNvcHkoIGNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSAvICggbGlnaHQud2lkdGggKiBsaWdodC5oZWlnaHQgKiBNYXRoLlBJICkgKTtcblx0XHRcdFx0XHQvLyAoYikgaW50ZW5zaXR5IGlzIHRoZSBicmlnaHRuZXNzIG9mIHRoZSBsaWdodFxuXG5cdFx0XHRcdFx0dW5pZm9ybXMuY29sb3IuY29weShjb2xvcikubXVsdGlwbHlTY2FsYXIoaW50ZW5zaXR5KTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5oYWxmV2lkdGguc2V0KGxpZ2h0LndpZHRoICogMC41LCAwLjAsIDAuMCk7XG5cdFx0XHRcdFx0dW5pZm9ybXMuaGFsZkhlaWdodC5zZXQoMC4wLCBsaWdodC5oZWlnaHQgKiAwLjUsIDAuMCk7XG5cdFx0XHRcdFx0c3RhdGUucmVjdEFyZWFbcmVjdEFyZWFMZW5ndGhdID0gdW5pZm9ybXM7XG5cdFx0XHRcdFx0cmVjdEFyZWFMZW5ndGgrKztcblx0XHRcdFx0fSBlbHNlIGlmIChsaWdodC5pc1BvaW50TGlnaHQpIHtcblx0XHRcdFx0XHRjb25zdCB1bmlmb3JtcyA9IGNhY2hlLmdldChsaWdodCk7XG5cdFx0XHRcdFx0dW5pZm9ybXMuY29sb3IuY29weShsaWdodC5jb2xvcikubXVsdGlwbHlTY2FsYXIobGlnaHQuaW50ZW5zaXR5ICogc2NhbGVGYWN0b3IpO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmRpc3RhbmNlID0gbGlnaHQuZGlzdGFuY2U7XG5cdFx0XHRcdFx0dW5pZm9ybXMuZGVjYXkgPSBsaWdodC5kZWNheTtcblxuXHRcdFx0XHRcdGlmIChsaWdodC5jYXN0U2hhZG93KSB7XG5cdFx0XHRcdFx0XHRjb25zdCBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XG5cdFx0XHRcdFx0XHRjb25zdCBzaGFkb3dVbmlmb3JtcyA9IHNoYWRvd0NhY2hlLmdldChsaWdodCk7XG5cdFx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dCaWFzID0gc2hhZG93LmJpYXM7XG5cdFx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dOb3JtYWxCaWFzID0gc2hhZG93Lm5vcm1hbEJpYXM7XG5cdFx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dSYWRpdXMgPSBzaGFkb3cucmFkaXVzO1xuXHRcdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93TWFwU2l6ZSA9IHNoYWRvdy5tYXBTaXplO1xuXHRcdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93Q2FtZXJhTmVhciA9IHNoYWRvdy5jYW1lcmEubmVhcjtcblx0XHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd0NhbWVyYUZhciA9IHNoYWRvdy5jYW1lcmEuZmFyO1xuXHRcdFx0XHRcdFx0c3RhdGUucG9pbnRTaGFkb3dbcG9pbnRMZW5ndGhdID0gc2hhZG93VW5pZm9ybXM7XG5cdFx0XHRcdFx0XHRzdGF0ZS5wb2ludFNoYWRvd01hcFtwb2ludExlbmd0aF0gPSBzaGFkb3dNYXA7XG5cdFx0XHRcdFx0XHRzdGF0ZS5wb2ludFNoYWRvd01hdHJpeFtwb2ludExlbmd0aF0gPSBsaWdodC5zaGFkb3cubWF0cml4O1xuXHRcdFx0XHRcdFx0bnVtUG9pbnRTaGFkb3dzKys7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c3RhdGUucG9pbnRbcG9pbnRMZW5ndGhdID0gdW5pZm9ybXM7XG5cdFx0XHRcdFx0cG9pbnRMZW5ndGgrKztcblx0XHRcdFx0fSBlbHNlIGlmIChsaWdodC5pc0hlbWlzcGhlcmVMaWdodCkge1xuXHRcdFx0XHRcdGNvbnN0IHVuaWZvcm1zID0gY2FjaGUuZ2V0KGxpZ2h0KTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5za3lDb2xvci5jb3B5KGxpZ2h0LmNvbG9yKS5tdWx0aXBseVNjYWxhcihpbnRlbnNpdHkgKiBzY2FsZUZhY3Rvcik7XG5cdFx0XHRcdFx0dW5pZm9ybXMuZ3JvdW5kQ29sb3IuY29weShsaWdodC5ncm91bmRDb2xvcikubXVsdGlwbHlTY2FsYXIoaW50ZW5zaXR5ICogc2NhbGVGYWN0b3IpO1xuXHRcdFx0XHRcdHN0YXRlLmhlbWlbaGVtaUxlbmd0aF0gPSB1bmlmb3Jtcztcblx0XHRcdFx0XHRoZW1pTGVuZ3RoKys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHJlY3RBcmVhTGVuZ3RoID4gMCkge1xuXHRcdFx0XHRpZiAoY2FwYWJpbGl0aWVzLmlzV2ViR0wyKSB7XG5cdFx0XHRcdFx0Ly8gV2ViR0wgMlxuXHRcdFx0XHRcdHN0YXRlLnJlY3RBcmVhTFRDMSA9IFVuaWZvcm1zTGliLkxUQ19GTE9BVF8xO1xuXHRcdFx0XHRcdHN0YXRlLnJlY3RBcmVhTFRDMiA9IFVuaWZvcm1zTGliLkxUQ19GTE9BVF8yO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIFdlYkdMIDFcblx0XHRcdFx0XHRpZiAoZXh0ZW5zaW9ucy5oYXMoJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRzdGF0ZS5yZWN0QXJlYUxUQzEgPSBVbmlmb3Jtc0xpYi5MVENfRkxPQVRfMTtcblx0XHRcdFx0XHRcdHN0YXRlLnJlY3RBcmVhTFRDMiA9IFVuaWZvcm1zTGliLkxUQ19GTE9BVF8yO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZXh0ZW5zaW9ucy5oYXMoJ09FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyJykgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdHN0YXRlLnJlY3RBcmVhTFRDMSA9IFVuaWZvcm1zTGliLkxUQ19IQUxGXzE7XG5cdFx0XHRcdFx0XHRzdGF0ZS5yZWN0QXJlYUxUQzIgPSBVbmlmb3Jtc0xpYi5MVENfSEFMRl8yO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBVbmFibGUgdG8gdXNlIFJlY3RBcmVhTGlnaHQuIE1pc3NpbmcgV2ViR0wgZXh0ZW5zaW9ucy4nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0c3RhdGUuYW1iaWVudFswXSA9IHI7XG5cdFx0XHRzdGF0ZS5hbWJpZW50WzFdID0gZztcblx0XHRcdHN0YXRlLmFtYmllbnRbMl0gPSBiO1xuXHRcdFx0Y29uc3QgaGFzaCA9IHN0YXRlLmhhc2g7XG5cblx0XHRcdGlmIChoYXNoLmRpcmVjdGlvbmFsTGVuZ3RoICE9PSBkaXJlY3Rpb25hbExlbmd0aCB8fCBoYXNoLnBvaW50TGVuZ3RoICE9PSBwb2ludExlbmd0aCB8fCBoYXNoLnNwb3RMZW5ndGggIT09IHNwb3RMZW5ndGggfHwgaGFzaC5yZWN0QXJlYUxlbmd0aCAhPT0gcmVjdEFyZWFMZW5ndGggfHwgaGFzaC5oZW1pTGVuZ3RoICE9PSBoZW1pTGVuZ3RoIHx8IGhhc2gubnVtRGlyZWN0aW9uYWxTaGFkb3dzICE9PSBudW1EaXJlY3Rpb25hbFNoYWRvd3MgfHwgaGFzaC5udW1Qb2ludFNoYWRvd3MgIT09IG51bVBvaW50U2hhZG93cyB8fCBoYXNoLm51bVNwb3RTaGFkb3dzICE9PSBudW1TcG90U2hhZG93cykge1xuXHRcdFx0XHRzdGF0ZS5kaXJlY3Rpb25hbC5sZW5ndGggPSBkaXJlY3Rpb25hbExlbmd0aDtcblx0XHRcdFx0c3RhdGUuc3BvdC5sZW5ndGggPSBzcG90TGVuZ3RoO1xuXHRcdFx0XHRzdGF0ZS5yZWN0QXJlYS5sZW5ndGggPSByZWN0QXJlYUxlbmd0aDtcblx0XHRcdFx0c3RhdGUucG9pbnQubGVuZ3RoID0gcG9pbnRMZW5ndGg7XG5cdFx0XHRcdHN0YXRlLmhlbWkubGVuZ3RoID0gaGVtaUxlbmd0aDtcblx0XHRcdFx0c3RhdGUuZGlyZWN0aW9uYWxTaGFkb3cubGVuZ3RoID0gbnVtRGlyZWN0aW9uYWxTaGFkb3dzO1xuXHRcdFx0XHRzdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hcC5sZW5ndGggPSBudW1EaXJlY3Rpb25hbFNoYWRvd3M7XG5cdFx0XHRcdHN0YXRlLnBvaW50U2hhZG93Lmxlbmd0aCA9IG51bVBvaW50U2hhZG93cztcblx0XHRcdFx0c3RhdGUucG9pbnRTaGFkb3dNYXAubGVuZ3RoID0gbnVtUG9pbnRTaGFkb3dzO1xuXHRcdFx0XHRzdGF0ZS5zcG90U2hhZG93Lmxlbmd0aCA9IG51bVNwb3RTaGFkb3dzO1xuXHRcdFx0XHRzdGF0ZS5zcG90U2hhZG93TWFwLmxlbmd0aCA9IG51bVNwb3RTaGFkb3dzO1xuXHRcdFx0XHRzdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hdHJpeC5sZW5ndGggPSBudW1EaXJlY3Rpb25hbFNoYWRvd3M7XG5cdFx0XHRcdHN0YXRlLnBvaW50U2hhZG93TWF0cml4Lmxlbmd0aCA9IG51bVBvaW50U2hhZG93cztcblx0XHRcdFx0c3RhdGUuc3BvdFNoYWRvd01hdHJpeC5sZW5ndGggPSBudW1TcG90U2hhZG93cztcblx0XHRcdFx0aGFzaC5kaXJlY3Rpb25hbExlbmd0aCA9IGRpcmVjdGlvbmFsTGVuZ3RoO1xuXHRcdFx0XHRoYXNoLnBvaW50TGVuZ3RoID0gcG9pbnRMZW5ndGg7XG5cdFx0XHRcdGhhc2guc3BvdExlbmd0aCA9IHNwb3RMZW5ndGg7XG5cdFx0XHRcdGhhc2gucmVjdEFyZWFMZW5ndGggPSByZWN0QXJlYUxlbmd0aDtcblx0XHRcdFx0aGFzaC5oZW1pTGVuZ3RoID0gaGVtaUxlbmd0aDtcblx0XHRcdFx0aGFzaC5udW1EaXJlY3Rpb25hbFNoYWRvd3MgPSBudW1EaXJlY3Rpb25hbFNoYWRvd3M7XG5cdFx0XHRcdGhhc2gubnVtUG9pbnRTaGFkb3dzID0gbnVtUG9pbnRTaGFkb3dzO1xuXHRcdFx0XHRoYXNoLm51bVNwb3RTaGFkb3dzID0gbnVtU3BvdFNoYWRvd3M7XG5cdFx0XHRcdHN0YXRlLnZlcnNpb24gPSBuZXh0VmVyc2lvbisrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldHVwVmlldyhsaWdodHMsIGNhbWVyYSkge1xuXHRcdFx0bGV0IGRpcmVjdGlvbmFsTGVuZ3RoID0gMDtcblx0XHRcdGxldCBwb2ludExlbmd0aCA9IDA7XG5cdFx0XHRsZXQgc3BvdExlbmd0aCA9IDA7XG5cdFx0XHRsZXQgcmVjdEFyZWFMZW5ndGggPSAwO1xuXHRcdFx0bGV0IGhlbWlMZW5ndGggPSAwO1xuXHRcdFx0Y29uc3Qgdmlld01hdHJpeCA9IGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2U7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gbGlnaHRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBsaWdodCA9IGxpZ2h0c1tpXTtcblxuXHRcdFx0XHRpZiAobGlnaHQuaXNEaXJlY3Rpb25hbExpZ2h0KSB7XG5cdFx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBzdGF0ZS5kaXJlY3Rpb25hbFtkaXJlY3Rpb25hbExlbmd0aF07XG5cdFx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihsaWdodC5tYXRyaXhXb3JsZCk7XG5cdFx0XHRcdFx0dmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24obGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkKTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24uc3ViKHZlY3RvcjMpO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24odmlld01hdHJpeCk7XG5cdFx0XHRcdFx0ZGlyZWN0aW9uYWxMZW5ndGgrKztcblx0XHRcdFx0fSBlbHNlIGlmIChsaWdodC5pc1Nwb3RMaWdodCkge1xuXHRcdFx0XHRcdGNvbnN0IHVuaWZvcm1zID0gc3RhdGUuc3BvdFtzcG90TGVuZ3RoXTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24obGlnaHQubWF0cml4V29ybGQpO1xuXHRcdFx0XHRcdHVuaWZvcm1zLnBvc2l0aW9uLmFwcGx5TWF0cml4NCh2aWV3TWF0cml4KTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGxpZ2h0Lm1hdHJpeFdvcmxkKTtcblx0XHRcdFx0XHR2ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbihsaWdodC50YXJnZXQubWF0cml4V29ybGQpO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zdWIodmVjdG9yMyk7XG5cdFx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbih2aWV3TWF0cml4KTtcblx0XHRcdFx0XHRzcG90TGVuZ3RoKys7XG5cdFx0XHRcdH0gZWxzZSBpZiAobGlnaHQuaXNSZWN0QXJlYUxpZ2h0KSB7XG5cdFx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBzdGF0ZS5yZWN0QXJlYVtyZWN0QXJlYUxlbmd0aF07XG5cdFx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGxpZ2h0Lm1hdHJpeFdvcmxkKTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5hcHBseU1hdHJpeDQodmlld01hdHJpeCk7IC8vIGV4dHJhY3QgbG9jYWwgcm90YXRpb24gb2YgbGlnaHQgdG8gZGVyaXZlIHdpZHRoL2hlaWdodCBoYWxmIHZlY3RvcnNcblxuXHRcdFx0XHRcdG1hdHJpeDQyLmlkZW50aXR5KCk7XG5cdFx0XHRcdFx0bWF0cml4NC5jb3B5KGxpZ2h0Lm1hdHJpeFdvcmxkKTtcblx0XHRcdFx0XHRtYXRyaXg0LnByZW11bHRpcGx5KHZpZXdNYXRyaXgpO1xuXHRcdFx0XHRcdG1hdHJpeDQyLmV4dHJhY3RSb3RhdGlvbihtYXRyaXg0KTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5oYWxmV2lkdGguc2V0KGxpZ2h0LndpZHRoICogMC41LCAwLjAsIDAuMCk7XG5cdFx0XHRcdFx0dW5pZm9ybXMuaGFsZkhlaWdodC5zZXQoMC4wLCBsaWdodC5oZWlnaHQgKiAwLjUsIDAuMCk7XG5cdFx0XHRcdFx0dW5pZm9ybXMuaGFsZldpZHRoLmFwcGx5TWF0cml4NChtYXRyaXg0Mik7XG5cdFx0XHRcdFx0dW5pZm9ybXMuaGFsZkhlaWdodC5hcHBseU1hdHJpeDQobWF0cml4NDIpO1xuXHRcdFx0XHRcdHJlY3RBcmVhTGVuZ3RoKys7XG5cdFx0XHRcdH0gZWxzZSBpZiAobGlnaHQuaXNQb2ludExpZ2h0KSB7XG5cdFx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBzdGF0ZS5wb2ludFtwb2ludExlbmd0aF07XG5cdFx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGxpZ2h0Lm1hdHJpeFdvcmxkKTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5hcHBseU1hdHJpeDQodmlld01hdHJpeCk7XG5cdFx0XHRcdFx0cG9pbnRMZW5ndGgrKztcblx0XHRcdFx0fSBlbHNlIGlmIChsaWdodC5pc0hlbWlzcGhlcmVMaWdodCkge1xuXHRcdFx0XHRcdGNvbnN0IHVuaWZvcm1zID0gc3RhdGUuaGVtaVtoZW1pTGVuZ3RoXTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGxpZ2h0Lm1hdHJpeFdvcmxkKTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKHZpZXdNYXRyaXgpO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5ub3JtYWxpemUoKTtcblx0XHRcdFx0XHRoZW1pTGVuZ3RoKys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0c2V0dXA6IHNldHVwLFxuXHRcdFx0c2V0dXBWaWV3OiBzZXR1cFZpZXcsXG5cdFx0XHRzdGF0ZTogc3RhdGVcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gV2ViR0xSZW5kZXJTdGF0ZShleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMpIHtcblx0XHRjb25zdCBsaWdodHMgPSBuZXcgV2ViR0xMaWdodHMoZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzKTtcblx0XHRjb25zdCBsaWdodHNBcnJheSA9IFtdO1xuXHRcdGNvbnN0IHNoYWRvd3NBcnJheSA9IFtdO1xuXG5cdFx0ZnVuY3Rpb24gaW5pdCgpIHtcblx0XHRcdGxpZ2h0c0FycmF5Lmxlbmd0aCA9IDA7XG5cdFx0XHRzaGFkb3dzQXJyYXkubGVuZ3RoID0gMDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwdXNoTGlnaHQobGlnaHQpIHtcblx0XHRcdGxpZ2h0c0FycmF5LnB1c2gobGlnaHQpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHB1c2hTaGFkb3coc2hhZG93TGlnaHQpIHtcblx0XHRcdHNoYWRvd3NBcnJheS5wdXNoKHNoYWRvd0xpZ2h0KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXR1cExpZ2h0cyhwaHlzaWNhbGx5Q29ycmVjdExpZ2h0cykge1xuXHRcdFx0bGlnaHRzLnNldHVwKGxpZ2h0c0FycmF5LCBwaHlzaWNhbGx5Q29ycmVjdExpZ2h0cyk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0dXBMaWdodHNWaWV3KGNhbWVyYSkge1xuXHRcdFx0bGlnaHRzLnNldHVwVmlldyhsaWdodHNBcnJheSwgY2FtZXJhKTtcblx0XHR9XG5cblx0XHRjb25zdCBzdGF0ZSA9IHtcblx0XHRcdGxpZ2h0c0FycmF5OiBsaWdodHNBcnJheSxcblx0XHRcdHNoYWRvd3NBcnJheTogc2hhZG93c0FycmF5LFxuXHRcdFx0bGlnaHRzOiBsaWdodHNcblx0XHR9O1xuXHRcdHJldHVybiB7XG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0c3RhdGU6IHN0YXRlLFxuXHRcdFx0c2V0dXBMaWdodHM6IHNldHVwTGlnaHRzLFxuXHRcdFx0c2V0dXBMaWdodHNWaWV3OiBzZXR1cExpZ2h0c1ZpZXcsXG5cdFx0XHRwdXNoTGlnaHQ6IHB1c2hMaWdodCxcblx0XHRcdHB1c2hTaGFkb3c6IHB1c2hTaGFkb3dcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gV2ViR0xSZW5kZXJTdGF0ZXMoZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzKSB7XG5cdFx0bGV0IHJlbmRlclN0YXRlcyA9IG5ldyBXZWFrTWFwKCk7XG5cblx0XHRmdW5jdGlvbiBnZXQoc2NlbmUsIHJlbmRlckNhbGxEZXB0aCA9IDApIHtcblx0XHRcdGxldCByZW5kZXJTdGF0ZTtcblxuXHRcdFx0aWYgKHJlbmRlclN0YXRlcy5oYXMoc2NlbmUpID09PSBmYWxzZSkge1xuXHRcdFx0XHRyZW5kZXJTdGF0ZSA9IG5ldyBXZWJHTFJlbmRlclN0YXRlKGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcyk7XG5cdFx0XHRcdHJlbmRlclN0YXRlcy5zZXQoc2NlbmUsIFtyZW5kZXJTdGF0ZV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHJlbmRlckNhbGxEZXB0aCA+PSByZW5kZXJTdGF0ZXMuZ2V0KHNjZW5lKS5sZW5ndGgpIHtcblx0XHRcdFx0XHRyZW5kZXJTdGF0ZSA9IG5ldyBXZWJHTFJlbmRlclN0YXRlKGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcyk7XG5cdFx0XHRcdFx0cmVuZGVyU3RhdGVzLmdldChzY2VuZSkucHVzaChyZW5kZXJTdGF0ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVuZGVyU3RhdGUgPSByZW5kZXJTdGF0ZXMuZ2V0KHNjZW5lKVtyZW5kZXJDYWxsRGVwdGhdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZW5kZXJTdGF0ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkaXNwb3NlKCkge1xuXHRcdFx0cmVuZGVyU3RhdGVzID0gbmV3IFdlYWtNYXAoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0Z2V0OiBnZXQsXG5cdFx0XHRkaXNwb3NlOiBkaXNwb3NlXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBwYXJhbWV0ZXJzID0ge1xuXHQgKlxuXHQgKlx0b3BhY2l0eTogPGZsb2F0Pixcblx0ICpcblx0ICpcdG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICpcdGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKlx0ZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlx0ZGlzcGxhY2VtZW50U2NhbGU6IDxmbG9hdD4sXG5cdCAqXHRkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKlx0d2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG5cdCAqXHR3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD5cblx0ICogfVxuXHQgKi9cblxuXHRjbGFzcyBNZXNoRGVwdGhNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblx0XHRjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ01lc2hEZXB0aE1hdGVyaWFsJztcblx0XHRcdHRoaXMuZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmc7XG5cdFx0XHR0aGlzLm1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcblx0XHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cdFx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cdFx0XHR0aGlzLmZvZyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMocGFyYW1ldGVycyk7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdHRoaXMuZGVwdGhQYWNraW5nID0gc291cmNlLmRlcHRoUGFja2luZztcblx0XHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblx0XHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XG5cdFx0XHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdFx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdE1lc2hEZXB0aE1hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hEZXB0aE1hdGVyaWFsID0gdHJ1ZTtcblxuXHQvKipcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICpcblx0ICpcdHJlZmVyZW5jZVBvc2l0aW9uOiA8ZmxvYXQ+LFxuXHQgKlx0bmVhckRpc3RhbmNlOiA8ZmxvYXQ+LFxuXHQgKlx0ZmFyRGlzdGFuY2U6IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHRtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqXHRhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICpcdGRpc3BsYWNlbWVudE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcdGRpc3BsYWNlbWVudFNjYWxlOiA8ZmxvYXQ+LFxuXHQgKlx0ZGlzcGxhY2VtZW50QmlhczogPGZsb2F0PlxuXHQgKlxuXHQgKiB9XG5cdCAqL1xuXG5cdGNsYXNzIE1lc2hEaXN0YW5jZU1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXHRcdGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnTWVzaERpc3RhbmNlTWF0ZXJpYWwnO1xuXHRcdFx0dGhpcy5yZWZlcmVuY2VQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR0aGlzLm5lYXJEaXN0YW5jZSA9IDE7XG5cdFx0XHR0aGlzLmZhckRpc3RhbmNlID0gMTAwMDtcblx0XHRcdHRoaXMubWFwID0gbnVsbDtcblx0XHRcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXHRcdFx0dGhpcy5mb2cgPSBmYWxzZTtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLnJlZmVyZW5jZVBvc2l0aW9uLmNvcHkoc291cmNlLnJlZmVyZW5jZVBvc2l0aW9uKTtcblx0XHRcdHRoaXMubmVhckRpc3RhbmNlID0gc291cmNlLm5lYXJEaXN0YW5jZTtcblx0XHRcdHRoaXMuZmFyRGlzdGFuY2UgPSBzb3VyY2UuZmFyRGlzdGFuY2U7XG5cdFx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cdFx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRNZXNoRGlzdGFuY2VNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoRGlzdGFuY2VNYXRlcmlhbCA9IHRydWU7XG5cblx0Y29uc3QgdmVydGV4ID0gXCJ2b2lkIG1haW4oKSB7XFxuXFx0Z2xfUG9zaXRpb24gPSB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxufVwiO1xuXHRjb25zdCBmcmFnbWVudCA9IFwidW5pZm9ybSBzYW1wbGVyMkQgc2hhZG93X3Bhc3M7XFxudW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XFxudW5pZm9ybSBmbG9hdCByYWRpdXM7XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxudm9pZCBtYWluKCkge1xcblxcdGNvbnN0IGZsb2F0IHNhbXBsZXMgPSBmbG9hdCggVlNNX1NBTVBMRVMgKTtcXG5cXHRmbG9hdCBtZWFuID0gMC4wO1xcblxcdGZsb2F0IHNxdWFyZWRfbWVhbiA9IDAuMDtcXG5cXHRmbG9hdCB1dlN0cmlkZSA9IHNhbXBsZXMgPD0gMS4wID8gMC4wIDogMi4wIC8gKCBzYW1wbGVzIC0gMS4wICk7XFxuXFx0ZmxvYXQgdXZTdGFydCA9IHNhbXBsZXMgPD0gMS4wID8gMC4wIDogLSAxLjA7XFxuXFx0Zm9yICggZmxvYXQgaSA9IDAuMDsgaSA8IHNhbXBsZXM7IGkgKysgKSB7XFxuXFx0XFx0ZmxvYXQgdXZPZmZzZXQgPSB1dlN0YXJ0ICsgaSAqIHV2U3RyaWRlO1xcblxcdFxcdCNpZmRlZiBIT1JJWk9OVEFMX1BBU1NcXG5cXHRcXHRcXHR2ZWMyIGRpc3RyaWJ1dGlvbiA9IHVucGFja1JHQkFUbzJIYWxmKCB0ZXh0dXJlMkQoIHNoYWRvd19wYXNzLCAoIGdsX0ZyYWdDb29yZC54eSArIHZlYzIoIHV2T2Zmc2V0LCAwLjAgKSAqIHJhZGl1cyApIC8gcmVzb2x1dGlvbiApICk7XFxuXFx0XFx0XFx0bWVhbiArPSBkaXN0cmlidXRpb24ueDtcXG5cXHRcXHRcXHRzcXVhcmVkX21lYW4gKz0gZGlzdHJpYnV0aW9uLnkgKiBkaXN0cmlidXRpb24ueSArIGRpc3RyaWJ1dGlvbi54ICogZGlzdHJpYnV0aW9uLng7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRmbG9hdCBkZXB0aCA9IHVucGFja1JHQkFUb0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd19wYXNzLCAoIGdsX0ZyYWdDb29yZC54eSArIHZlYzIoIDAuMCwgdXZPZmZzZXQgKSAqIHJhZGl1cyApIC8gcmVzb2x1dGlvbiApICk7XFxuXFx0XFx0XFx0bWVhbiArPSBkZXB0aDtcXG5cXHRcXHRcXHRzcXVhcmVkX21lYW4gKz0gZGVwdGggKiBkZXB0aDtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuXFx0bWVhbiA9IG1lYW4gLyBzYW1wbGVzO1xcblxcdHNxdWFyZWRfbWVhbiA9IHNxdWFyZWRfbWVhbiAvIHNhbXBsZXM7XFxuXFx0ZmxvYXQgc3RkX2RldiA9IHNxcnQoIHNxdWFyZWRfbWVhbiAtIG1lYW4gKiBtZWFuICk7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gcGFjazJIYWxmVG9SR0JBKCB2ZWMyKCBtZWFuLCBzdGRfZGV2ICkgKTtcXG59XCI7XG5cblx0ZnVuY3Rpb24gV2ViR0xTaGFkb3dNYXAoX3JlbmRlcmVyLCBfb2JqZWN0cywgX2NhcGFiaWxpdGllcykge1xuXHRcdGxldCBfZnJ1c3R1bSA9IG5ldyBGcnVzdHVtKCk7XG5cblx0XHRjb25zdCBfc2hhZG93TWFwU2l6ZSA9IG5ldyBWZWN0b3IyKCksXG5cdFx0XHRcdFx0X3ZpZXdwb3J0U2l6ZSA9IG5ldyBWZWN0b3IyKCksXG5cdFx0XHRcdFx0X3ZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoKSxcblx0XHRcdFx0XHRfZGVwdGhNYXRlcmlhbCA9IG5ldyBNZXNoRGVwdGhNYXRlcmlhbCh7XG5cdFx0XHRkZXB0aFBhY2tpbmc6IFJHQkFEZXB0aFBhY2tpbmdcblx0XHR9KSxcblx0XHRcdFx0XHRfZGlzdGFuY2VNYXRlcmlhbCA9IG5ldyBNZXNoRGlzdGFuY2VNYXRlcmlhbCgpLFxuXHRcdFx0XHRcdF9tYXRlcmlhbENhY2hlID0ge30sXG5cdFx0XHRcdFx0X21heFRleHR1cmVTaXplID0gX2NhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZTtcblxuXHRcdGNvbnN0IHNoYWRvd1NpZGUgPSB7XG5cdFx0XHQwOiBCYWNrU2lkZSxcblx0XHRcdDE6IEZyb250U2lkZSxcblx0XHRcdDI6IERvdWJsZVNpZGVcblx0XHR9O1xuXHRcdGNvbnN0IHNoYWRvd01hdGVyaWFsVmVydGljYWwgPSBuZXcgU2hhZGVyTWF0ZXJpYWwoe1xuXHRcdFx0ZGVmaW5lczoge1xuXHRcdFx0XHRWU01fU0FNUExFUzogOFxuXHRcdFx0fSxcblx0XHRcdHVuaWZvcm1zOiB7XG5cdFx0XHRcdHNoYWRvd19wYXNzOiB7XG5cdFx0XHRcdFx0dmFsdWU6IG51bGxcblx0XHRcdFx0fSxcblx0XHRcdFx0cmVzb2x1dGlvbjoge1xuXHRcdFx0XHRcdHZhbHVlOiBuZXcgVmVjdG9yMigpXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJhZGl1czoge1xuXHRcdFx0XHRcdHZhbHVlOiA0LjBcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHZlcnRleFNoYWRlcjogdmVydGV4LFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IGZyYWdtZW50XG5cdFx0fSk7XG5cdFx0Y29uc3Qgc2hhZG93TWF0ZXJpYWxIb3Jpem9udGFsID0gc2hhZG93TWF0ZXJpYWxWZXJ0aWNhbC5jbG9uZSgpO1xuXHRcdHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbC5kZWZpbmVzLkhPUklaT05UQUxfUEFTUyA9IDE7XG5cdFx0Y29uc3QgZnVsbFNjcmVlblRyaSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdGZ1bGxTY3JlZW5Ucmkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheShbLTEsIC0xLCAwLjUsIDMsIC0xLCAwLjUsIC0xLCAzLCAwLjVdKSwgMykpO1xuXHRcdGNvbnN0IGZ1bGxTY3JlZW5NZXNoID0gbmV3IE1lc2goZnVsbFNjcmVlblRyaSwgc2hhZG93TWF0ZXJpYWxWZXJ0aWNhbCk7XG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXHRcdHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMudHlwZSA9IFBDRlNoYWRvd01hcDtcblxuXHRcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKGxpZ2h0cywgc2NlbmUsIGNhbWVyYSkge1xuXHRcdFx0aWYgKHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XG5cdFx0XHRpZiAoc2NvcGUuYXV0b1VwZGF0ZSA9PT0gZmFsc2UgJiYgc2NvcGUubmVlZHNVcGRhdGUgPT09IGZhbHNlKSByZXR1cm47XG5cdFx0XHRpZiAobGlnaHRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG5cdFx0XHRjb25zdCBjdXJyZW50UmVuZGVyVGFyZ2V0ID0gX3JlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xuXG5cdFx0XHRjb25zdCBhY3RpdmVDdWJlRmFjZSA9IF9yZW5kZXJlci5nZXRBY3RpdmVDdWJlRmFjZSgpO1xuXG5cdFx0XHRjb25zdCBhY3RpdmVNaXBtYXBMZXZlbCA9IF9yZW5kZXJlci5nZXRBY3RpdmVNaXBtYXBMZXZlbCgpO1xuXG5cdFx0XHRjb25zdCBfc3RhdGUgPSBfcmVuZGVyZXIuc3RhdGU7IC8vIFNldCBHTCBzdGF0ZSBmb3IgZGVwdGggbWFwLlxuXG5cdFx0XHRfc3RhdGUuc2V0QmxlbmRpbmcoTm9CbGVuZGluZyk7XG5cblx0XHRcdF9zdGF0ZS5idWZmZXJzLmNvbG9yLnNldENsZWFyKDEsIDEsIDEsIDEpO1xuXG5cdFx0XHRfc3RhdGUuYnVmZmVycy5kZXB0aC5zZXRUZXN0KHRydWUpO1xuXG5cdFx0XHRfc3RhdGUuc2V0U2Npc3NvclRlc3QoZmFsc2UpOyAvLyByZW5kZXIgZGVwdGggbWFwXG5cblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gbGlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgbGlnaHQgPSBsaWdodHNbaV07XG5cdFx0XHRcdGNvbnN0IHNoYWRvdyA9IGxpZ2h0LnNoYWRvdztcblxuXHRcdFx0XHRpZiAoc2hhZG93ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMU2hhZG93TWFwOicsIGxpZ2h0LCAnaGFzIG5vIHNoYWRvdy4nKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChzaGFkb3cuYXV0b1VwZGF0ZSA9PT0gZmFsc2UgJiYgc2hhZG93Lm5lZWRzVXBkYXRlID09PSBmYWxzZSkgY29udGludWU7XG5cblx0XHRcdFx0X3NoYWRvd01hcFNpemUuY29weShzaGFkb3cubWFwU2l6ZSk7XG5cblx0XHRcdFx0Y29uc3Qgc2hhZG93RnJhbWVFeHRlbnRzID0gc2hhZG93LmdldEZyYW1lRXh0ZW50cygpO1xuXG5cdFx0XHRcdF9zaGFkb3dNYXBTaXplLm11bHRpcGx5KHNoYWRvd0ZyYW1lRXh0ZW50cyk7XG5cblx0XHRcdFx0X3ZpZXdwb3J0U2l6ZS5jb3B5KHNoYWRvdy5tYXBTaXplKTtcblxuXHRcdFx0XHRpZiAoX3NoYWRvd01hcFNpemUueCA+IF9tYXhUZXh0dXJlU2l6ZSB8fCBfc2hhZG93TWFwU2l6ZS55ID4gX21heFRleHR1cmVTaXplKSB7XG5cdFx0XHRcdFx0aWYgKF9zaGFkb3dNYXBTaXplLnggPiBfbWF4VGV4dHVyZVNpemUpIHtcblx0XHRcdFx0XHRcdF92aWV3cG9ydFNpemUueCA9IE1hdGguZmxvb3IoX21heFRleHR1cmVTaXplIC8gc2hhZG93RnJhbWVFeHRlbnRzLngpO1xuXHRcdFx0XHRcdFx0X3NoYWRvd01hcFNpemUueCA9IF92aWV3cG9ydFNpemUueCAqIHNoYWRvd0ZyYW1lRXh0ZW50cy54O1xuXHRcdFx0XHRcdFx0c2hhZG93Lm1hcFNpemUueCA9IF92aWV3cG9ydFNpemUueDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoX3NoYWRvd01hcFNpemUueSA+IF9tYXhUZXh0dXJlU2l6ZSkge1xuXHRcdFx0XHRcdFx0X3ZpZXdwb3J0U2l6ZS55ID0gTWF0aC5mbG9vcihfbWF4VGV4dHVyZVNpemUgLyBzaGFkb3dGcmFtZUV4dGVudHMueSk7XG5cdFx0XHRcdFx0XHRfc2hhZG93TWFwU2l6ZS55ID0gX3ZpZXdwb3J0U2l6ZS55ICogc2hhZG93RnJhbWVFeHRlbnRzLnk7XG5cdFx0XHRcdFx0XHRzaGFkb3cubWFwU2l6ZS55ID0gX3ZpZXdwb3J0U2l6ZS55O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChzaGFkb3cubWFwID09PSBudWxsICYmICFzaGFkb3cuaXNQb2ludExpZ2h0U2hhZG93ICYmIHRoaXMudHlwZSA9PT0gVlNNU2hhZG93TWFwKSB7XG5cdFx0XHRcdFx0Y29uc3QgcGFycyA9IHtcblx0XHRcdFx0XHRcdG1pbkZpbHRlcjogTGluZWFyRmlsdGVyLFxuXHRcdFx0XHRcdFx0bWFnRmlsdGVyOiBMaW5lYXJGaWx0ZXIsXG5cdFx0XHRcdFx0XHRmb3JtYXQ6IFJHQkFGb3JtYXRcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHNoYWRvdy5tYXAgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQoX3NoYWRvd01hcFNpemUueCwgX3NoYWRvd01hcFNpemUueSwgcGFycyk7XG5cdFx0XHRcdFx0c2hhZG93Lm1hcC50ZXh0dXJlLm5hbWUgPSBsaWdodC5uYW1lICsgJy5zaGFkb3dNYXAnO1xuXHRcdFx0XHRcdHNoYWRvdy5tYXBQYXNzID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KF9zaGFkb3dNYXBTaXplLngsIF9zaGFkb3dNYXBTaXplLnksIHBhcnMpO1xuXHRcdFx0XHRcdHNoYWRvdy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHNoYWRvdy5tYXAgPT09IG51bGwpIHtcblx0XHRcdFx0XHRjb25zdCBwYXJzID0ge1xuXHRcdFx0XHRcdFx0bWluRmlsdGVyOiBOZWFyZXN0RmlsdGVyLFxuXHRcdFx0XHRcdFx0bWFnRmlsdGVyOiBOZWFyZXN0RmlsdGVyLFxuXHRcdFx0XHRcdFx0Zm9ybWF0OiBSR0JBRm9ybWF0XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRzaGFkb3cubWFwID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KF9zaGFkb3dNYXBTaXplLngsIF9zaGFkb3dNYXBTaXplLnksIHBhcnMpO1xuXHRcdFx0XHRcdHNoYWRvdy5tYXAudGV4dHVyZS5uYW1lID0gbGlnaHQubmFtZSArICcuc2hhZG93TWFwJztcblx0XHRcdFx0XHRzaGFkb3cuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoc2hhZG93Lm1hcCk7XG5cblx0XHRcdFx0X3JlbmRlcmVyLmNsZWFyKCk7XG5cblx0XHRcdFx0Y29uc3Qgdmlld3BvcnRDb3VudCA9IHNoYWRvdy5nZXRWaWV3cG9ydENvdW50KCk7XG5cblx0XHRcdFx0Zm9yIChsZXQgdnAgPSAwOyB2cCA8IHZpZXdwb3J0Q291bnQ7IHZwKyspIHtcblx0XHRcdFx0XHRjb25zdCB2aWV3cG9ydCA9IHNoYWRvdy5nZXRWaWV3cG9ydCh2cCk7XG5cblx0XHRcdFx0XHRfdmlld3BvcnQuc2V0KF92aWV3cG9ydFNpemUueCAqIHZpZXdwb3J0LngsIF92aWV3cG9ydFNpemUueSAqIHZpZXdwb3J0LnksIF92aWV3cG9ydFNpemUueCAqIHZpZXdwb3J0LnosIF92aWV3cG9ydFNpemUueSAqIHZpZXdwb3J0LncpO1xuXG5cdFx0XHRcdFx0X3N0YXRlLnZpZXdwb3J0KF92aWV3cG9ydCk7XG5cblx0XHRcdFx0XHRzaGFkb3cudXBkYXRlTWF0cmljZXMobGlnaHQsIHZwKTtcblx0XHRcdFx0XHRfZnJ1c3R1bSA9IHNoYWRvdy5nZXRGcnVzdHVtKCk7XG5cdFx0XHRcdFx0cmVuZGVyT2JqZWN0KHNjZW5lLCBjYW1lcmEsIHNoYWRvdy5jYW1lcmEsIGxpZ2h0LCB0aGlzLnR5cGUpO1xuXHRcdFx0XHR9IC8vIGRvIGJsdXIgcGFzcyBmb3IgVlNNXG5cblxuXHRcdFx0XHRpZiAoIXNoYWRvdy5pc1BvaW50TGlnaHRTaGFkb3cgJiYgdGhpcy50eXBlID09PSBWU01TaGFkb3dNYXApIHtcblx0XHRcdFx0XHRWU01QYXNzKHNoYWRvdywgY2FtZXJhKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNoYWRvdy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRzY29wZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHRfcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KGN1cnJlbnRSZW5kZXJUYXJnZXQsIGFjdGl2ZUN1YmVGYWNlLCBhY3RpdmVNaXBtYXBMZXZlbCk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIFZTTVBhc3Moc2hhZG93LCBjYW1lcmEpIHtcblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gX29iamVjdHMudXBkYXRlKGZ1bGxTY3JlZW5NZXNoKTtcblxuXHRcdFx0aWYgKHNoYWRvd01hdGVyaWFsVmVydGljYWwuZGVmaW5lcy5WU01fU0FNUExFUyAhPT0gc2hhZG93LmJsdXJTYW1wbGVzKSB7XG5cdFx0XHRcdHNoYWRvd01hdGVyaWFsVmVydGljYWwuZGVmaW5lcy5WU01fU0FNUExFUyA9IHNoYWRvdy5ibHVyU2FtcGxlcztcblx0XHRcdFx0c2hhZG93TWF0ZXJpYWxIb3Jpem9udGFsLmRlZmluZXMuVlNNX1NBTVBMRVMgPSBzaGFkb3cuYmx1clNhbXBsZXM7XG5cdFx0XHRcdHNoYWRvd01hdGVyaWFsVmVydGljYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRzaGFkb3dNYXRlcmlhbEhvcml6b250YWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0fSAvLyB2ZXJ0aWNhbCBwYXNzXG5cblxuXHRcdFx0c2hhZG93TWF0ZXJpYWxWZXJ0aWNhbC51bmlmb3Jtcy5zaGFkb3dfcGFzcy52YWx1ZSA9IHNoYWRvdy5tYXAudGV4dHVyZTtcblx0XHRcdHNoYWRvd01hdGVyaWFsVmVydGljYWwudW5pZm9ybXMucmVzb2x1dGlvbi52YWx1ZSA9IHNoYWRvdy5tYXBTaXplO1xuXHRcdFx0c2hhZG93TWF0ZXJpYWxWZXJ0aWNhbC51bmlmb3Jtcy5yYWRpdXMudmFsdWUgPSBzaGFkb3cucmFkaXVzO1xuXG5cdFx0XHRfcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHNoYWRvdy5tYXBQYXNzKTtcblxuXHRcdFx0X3JlbmRlcmVyLmNsZWFyKCk7XG5cblx0XHRcdF9yZW5kZXJlci5yZW5kZXJCdWZmZXJEaXJlY3QoY2FtZXJhLCBudWxsLCBnZW9tZXRyeSwgc2hhZG93TWF0ZXJpYWxWZXJ0aWNhbCwgZnVsbFNjcmVlbk1lc2gsIG51bGwpOyAvLyBob3Jpem9udGFsIHBhc3NcblxuXG5cdFx0XHRzaGFkb3dNYXRlcmlhbEhvcml6b250YWwudW5pZm9ybXMuc2hhZG93X3Bhc3MudmFsdWUgPSBzaGFkb3cubWFwUGFzcy50ZXh0dXJlO1xuXHRcdFx0c2hhZG93TWF0ZXJpYWxIb3Jpem9udGFsLnVuaWZvcm1zLnJlc29sdXRpb24udmFsdWUgPSBzaGFkb3cubWFwU2l6ZTtcblx0XHRcdHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbC51bmlmb3Jtcy5yYWRpdXMudmFsdWUgPSBzaGFkb3cucmFkaXVzO1xuXG5cdFx0XHRfcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHNoYWRvdy5tYXApO1xuXG5cdFx0XHRfcmVuZGVyZXIuY2xlYXIoKTtcblxuXHRcdFx0X3JlbmRlcmVyLnJlbmRlckJ1ZmZlckRpcmVjdChjYW1lcmEsIG51bGwsIGdlb21ldHJ5LCBzaGFkb3dNYXRlcmlhbEhvcml6b250YWwsIGZ1bGxTY3JlZW5NZXNoLCBudWxsKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXREZXB0aE1hdGVyaWFsKG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBsaWdodCwgc2hhZG93Q2FtZXJhTmVhciwgc2hhZG93Q2FtZXJhRmFyLCB0eXBlKSB7XG5cdFx0XHRsZXQgcmVzdWx0ID0gbnVsbDtcblx0XHRcdGNvbnN0IGN1c3RvbU1hdGVyaWFsID0gbGlnaHQuaXNQb2ludExpZ2h0ID09PSB0cnVlID8gb2JqZWN0LmN1c3RvbURpc3RhbmNlTWF0ZXJpYWwgOiBvYmplY3QuY3VzdG9tRGVwdGhNYXRlcmlhbDtcblxuXHRcdFx0aWYgKGN1c3RvbU1hdGVyaWFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmVzdWx0ID0gY3VzdG9tTWF0ZXJpYWw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHQgPSBsaWdodC5pc1BvaW50TGlnaHQgPT09IHRydWUgPyBfZGlzdGFuY2VNYXRlcmlhbCA6IF9kZXB0aE1hdGVyaWFsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoX3JlbmRlcmVyLmxvY2FsQ2xpcHBpbmdFbmFibGVkICYmIG1hdGVyaWFsLmNsaXBTaGFkb3dzID09PSB0cnVlICYmIG1hdGVyaWFsLmNsaXBwaW5nUGxhbmVzLmxlbmd0aCAhPT0gMCB8fCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgJiYgbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGUgIT09IDAgfHwgbWF0ZXJpYWwuYWxwaGFNYXAgJiYgbWF0ZXJpYWwuYWxwaGFUZXN0ID4gMCkge1xuXHRcdFx0XHQvLyBpbiB0aGlzIGNhc2Ugd2UgbmVlZCBhIHVuaXF1ZSBtYXRlcmlhbCBpbnN0YW5jZSByZWZsZWN0aW5nIHRoZVxuXHRcdFx0XHQvLyBhcHByb3ByaWF0ZSBzdGF0ZVxuXHRcdFx0XHRjb25zdCBrZXlBID0gcmVzdWx0LnV1aWQsXG5cdFx0XHRcdFx0XHRcdGtleUIgPSBtYXRlcmlhbC51dWlkO1xuXHRcdFx0XHRsZXQgbWF0ZXJpYWxzRm9yVmFyaWFudCA9IF9tYXRlcmlhbENhY2hlW2tleUFdO1xuXG5cdFx0XHRcdGlmIChtYXRlcmlhbHNGb3JWYXJpYW50ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRtYXRlcmlhbHNGb3JWYXJpYW50ID0ge307XG5cdFx0XHRcdFx0X21hdGVyaWFsQ2FjaGVba2V5QV0gPSBtYXRlcmlhbHNGb3JWYXJpYW50O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGV0IGNhY2hlZE1hdGVyaWFsID0gbWF0ZXJpYWxzRm9yVmFyaWFudFtrZXlCXTtcblxuXHRcdFx0XHRpZiAoY2FjaGVkTWF0ZXJpYWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNhY2hlZE1hdGVyaWFsID0gcmVzdWx0LmNsb25lKCk7XG5cdFx0XHRcdFx0bWF0ZXJpYWxzRm9yVmFyaWFudFtrZXlCXSA9IGNhY2hlZE1hdGVyaWFsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ID0gY2FjaGVkTWF0ZXJpYWw7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3VsdC52aXNpYmxlID0gbWF0ZXJpYWwudmlzaWJsZTtcblx0XHRcdHJlc3VsdC53aXJlZnJhbWUgPSBtYXRlcmlhbC53aXJlZnJhbWU7XG5cblx0XHRcdGlmICh0eXBlID09PSBWU01TaGFkb3dNYXApIHtcblx0XHRcdFx0cmVzdWx0LnNpZGUgPSBtYXRlcmlhbC5zaGFkb3dTaWRlICE9PSBudWxsID8gbWF0ZXJpYWwuc2hhZG93U2lkZSA6IG1hdGVyaWFsLnNpZGU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHQuc2lkZSA9IG1hdGVyaWFsLnNoYWRvd1NpZGUgIT09IG51bGwgPyBtYXRlcmlhbC5zaGFkb3dTaWRlIDogc2hhZG93U2lkZVttYXRlcmlhbC5zaWRlXTtcblx0XHRcdH1cblxuXHRcdFx0cmVzdWx0LmFscGhhTWFwID0gbWF0ZXJpYWwuYWxwaGFNYXA7XG5cdFx0XHRyZXN1bHQuYWxwaGFUZXN0ID0gbWF0ZXJpYWwuYWxwaGFUZXN0O1xuXHRcdFx0cmVzdWx0LmNsaXBTaGFkb3dzID0gbWF0ZXJpYWwuY2xpcFNoYWRvd3M7XG5cdFx0XHRyZXN1bHQuY2xpcHBpbmdQbGFuZXMgPSBtYXRlcmlhbC5jbGlwcGluZ1BsYW5lcztcblx0XHRcdHJlc3VsdC5jbGlwSW50ZXJzZWN0aW9uID0gbWF0ZXJpYWwuY2xpcEludGVyc2VjdGlvbjtcblx0XHRcdHJlc3VsdC5kaXNwbGFjZW1lbnRNYXAgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0XHRyZXN1bHQuZGlzcGxhY2VtZW50U2NhbGUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRcdHJlc3VsdC5kaXNwbGFjZW1lbnRCaWFzID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50Qmlhcztcblx0XHRcdHJlc3VsdC53aXJlZnJhbWVMaW5ld2lkdGggPSBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdFx0XHRyZXN1bHQubGluZXdpZHRoID0gbWF0ZXJpYWwubGluZXdpZHRoO1xuXG5cdFx0XHRpZiAobGlnaHQuaXNQb2ludExpZ2h0ID09PSB0cnVlICYmIHJlc3VsdC5pc01lc2hEaXN0YW5jZU1hdGVyaWFsID09PSB0cnVlKSB7XG5cdFx0XHRcdHJlc3VsdC5yZWZlcmVuY2VQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24obGlnaHQubWF0cml4V29ybGQpO1xuXHRcdFx0XHRyZXN1bHQubmVhckRpc3RhbmNlID0gc2hhZG93Q2FtZXJhTmVhcjtcblx0XHRcdFx0cmVzdWx0LmZhckRpc3RhbmNlID0gc2hhZG93Q2FtZXJhRmFyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbmRlck9iamVjdChvYmplY3QsIGNhbWVyYSwgc2hhZG93Q2FtZXJhLCBsaWdodCwgdHlwZSkge1xuXHRcdFx0aWYgKG9iamVjdC52aXNpYmxlID09PSBmYWxzZSkgcmV0dXJuO1xuXHRcdFx0Y29uc3QgdmlzaWJsZSA9IG9iamVjdC5sYXllcnMudGVzdChjYW1lcmEubGF5ZXJzKTtcblxuXHRcdFx0aWYgKHZpc2libGUgJiYgKG9iamVjdC5pc01lc2ggfHwgb2JqZWN0LmlzTGluZSB8fCBvYmplY3QuaXNQb2ludHMpKSB7XG5cdFx0XHRcdGlmICgob2JqZWN0LmNhc3RTaGFkb3cgfHwgb2JqZWN0LnJlY2VpdmVTaGFkb3cgJiYgdHlwZSA9PT0gVlNNU2hhZG93TWFwKSAmJiAoIW9iamVjdC5mcnVzdHVtQ3VsbGVkIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3Qob2JqZWN0KSkpIHtcblx0XHRcdFx0XHRvYmplY3QubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkKTtcblxuXHRcdFx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gX29iamVjdHMudXBkYXRlKG9iamVjdCk7XG5cblx0XHRcdFx0XHRjb25zdCBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuXHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KG1hdGVyaWFsKSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBrID0gMCwga2wgPSBncm91cHMubGVuZ3RoOyBrIDwga2w7IGsrKykge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1trXTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsW2dyb3VwLm1hdGVyaWFsSW5kZXhdO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChncm91cE1hdGVyaWFsICYmIGdyb3VwTWF0ZXJpYWwudmlzaWJsZSkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGRlcHRoTWF0ZXJpYWwgPSBnZXREZXB0aE1hdGVyaWFsKG9iamVjdCwgZ2VvbWV0cnksIGdyb3VwTWF0ZXJpYWwsIGxpZ2h0LCBzaGFkb3dDYW1lcmEubmVhciwgc2hhZG93Q2FtZXJhLmZhciwgdHlwZSk7XG5cblx0XHRcdFx0XHRcdFx0XHRfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KHNoYWRvd0NhbWVyYSwgbnVsbCwgZ2VvbWV0cnksIGRlcHRoTWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbC52aXNpYmxlKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBkZXB0aE1hdGVyaWFsID0gZ2V0RGVwdGhNYXRlcmlhbChvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgbGlnaHQsIHNoYWRvd0NhbWVyYS5uZWFyLCBzaGFkb3dDYW1lcmEuZmFyLCB0eXBlKTtcblxuXHRcdFx0XHRcdFx0X3JlbmRlcmVyLnJlbmRlckJ1ZmZlckRpcmVjdChzaGFkb3dDYW1lcmEsIG51bGwsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBvYmplY3QsIG51bGwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0cmVuZGVyT2JqZWN0KGNoaWxkcmVuW2ldLCBjYW1lcmEsIHNoYWRvd0NhbWVyYSwgbGlnaHQsIHR5cGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIFdlYkdMU3RhdGUoZ2wsIGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcykge1xuXHRcdGNvbnN0IGlzV2ViR0wyID0gY2FwYWJpbGl0aWVzLmlzV2ViR0wyO1xuXG5cdFx0ZnVuY3Rpb24gQ29sb3JCdWZmZXIoKSB7XG5cdFx0XHRsZXQgbG9ja2VkID0gZmFsc2U7XG5cdFx0XHRjb25zdCBjb2xvciA9IG5ldyBWZWN0b3I0KCk7XG5cdFx0XHRsZXQgY3VycmVudENvbG9yTWFzayA9IG51bGw7XG5cdFx0XHRjb25zdCBjdXJyZW50Q29sb3JDbGVhciA9IG5ldyBWZWN0b3I0KDAsIDAsIDAsIDApO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0c2V0TWFzazogZnVuY3Rpb24gKGNvbG9yTWFzaykge1xuXHRcdFx0XHRcdGlmIChjdXJyZW50Q29sb3JNYXNrICE9PSBjb2xvck1hc2sgJiYgIWxvY2tlZCkge1xuXHRcdFx0XHRcdFx0Z2wuY29sb3JNYXNrKGNvbG9yTWFzaywgY29sb3JNYXNrLCBjb2xvck1hc2ssIGNvbG9yTWFzayk7XG5cdFx0XHRcdFx0XHRjdXJyZW50Q29sb3JNYXNrID0gY29sb3JNYXNrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0TG9ja2VkOiBmdW5jdGlvbiAobG9jaykge1xuXHRcdFx0XHRcdGxvY2tlZCA9IGxvY2s7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldENsZWFyOiBmdW5jdGlvbiAociwgZywgYiwgYSwgcHJlbXVsdGlwbGllZEFscGhhKSB7XG5cdFx0XHRcdFx0aWYgKHByZW11bHRpcGxpZWRBbHBoYSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0ciAqPSBhO1xuXHRcdFx0XHRcdFx0ZyAqPSBhO1xuXHRcdFx0XHRcdFx0YiAqPSBhO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbG9yLnNldChyLCBnLCBiLCBhKTtcblxuXHRcdFx0XHRcdGlmIChjdXJyZW50Q29sb3JDbGVhci5lcXVhbHMoY29sb3IpID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0Z2wuY2xlYXJDb2xvcihyLCBnLCBiLCBhKTtcblx0XHRcdFx0XHRcdGN1cnJlbnRDb2xvckNsZWFyLmNvcHkoY29sb3IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0cmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRsb2NrZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRjdXJyZW50Q29sb3JNYXNrID0gbnVsbDtcblx0XHRcdFx0XHRjdXJyZW50Q29sb3JDbGVhci5zZXQoLTEsIDAsIDAsIDApOyAvLyBzZXQgdG8gaW52YWxpZCBzdGF0ZVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIERlcHRoQnVmZmVyKCkge1xuXHRcdFx0bGV0IGxvY2tlZCA9IGZhbHNlO1xuXHRcdFx0bGV0IGN1cnJlbnREZXB0aE1hc2sgPSBudWxsO1xuXHRcdFx0bGV0IGN1cnJlbnREZXB0aEZ1bmMgPSBudWxsO1xuXHRcdFx0bGV0IGN1cnJlbnREZXB0aENsZWFyID0gbnVsbDtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHNldFRlc3Q6IGZ1bmN0aW9uIChkZXB0aFRlc3QpIHtcblx0XHRcdFx0XHRpZiAoZGVwdGhUZXN0KSB7XG5cdFx0XHRcdFx0XHRlbmFibGUoZ2wuREVQVEhfVEVTVCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXRNYXNrOiBmdW5jdGlvbiAoZGVwdGhNYXNrKSB7XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnREZXB0aE1hc2sgIT09IGRlcHRoTWFzayAmJiAhbG9ja2VkKSB7XG5cdFx0XHRcdFx0XHRnbC5kZXB0aE1hc2soZGVwdGhNYXNrKTtcblx0XHRcdFx0XHRcdGN1cnJlbnREZXB0aE1hc2sgPSBkZXB0aE1hc2s7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXRGdW5jOiBmdW5jdGlvbiAoZGVwdGhGdW5jKSB7XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnREZXB0aEZ1bmMgIT09IGRlcHRoRnVuYykge1xuXHRcdFx0XHRcdFx0aWYgKGRlcHRoRnVuYykge1xuXHRcdFx0XHRcdFx0XHRzd2l0Y2ggKGRlcHRoRnVuYykge1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgTmV2ZXJEZXB0aDpcblx0XHRcdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyhnbC5ORVZFUik7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgQWx3YXlzRGVwdGg6XG5cdFx0XHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoZ2wuQUxXQVlTKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBMZXNzRGVwdGg6XG5cdFx0XHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoZ2wuTEVTUyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgTGVzc0VxdWFsRGVwdGg6XG5cdFx0XHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoZ2wuTEVRVUFMKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBFcXVhbERlcHRoOlxuXHRcdFx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKGdsLkVRVUFMKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBHcmVhdGVyRXF1YWxEZXB0aDpcblx0XHRcdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyhnbC5HRVFVQUwpO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRjYXNlIEdyZWF0ZXJEZXB0aDpcblx0XHRcdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyhnbC5HUkVBVEVSKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBOb3RFcXVhbERlcHRoOlxuXHRcdFx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKGdsLk5PVEVRVUFMKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyhnbC5MRVFVQUwpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoZ2wuTEVRVUFMKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y3VycmVudERlcHRoRnVuYyA9IGRlcHRoRnVuYztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldExvY2tlZDogZnVuY3Rpb24gKGxvY2spIHtcblx0XHRcdFx0XHRsb2NrZWQgPSBsb2NrO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXRDbGVhcjogZnVuY3Rpb24gKGRlcHRoKSB7XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnREZXB0aENsZWFyICE9PSBkZXB0aCkge1xuXHRcdFx0XHRcdFx0Z2wuY2xlYXJEZXB0aChkZXB0aCk7XG5cdFx0XHRcdFx0XHRjdXJyZW50RGVwdGhDbGVhciA9IGRlcHRoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0cmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRsb2NrZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRjdXJyZW50RGVwdGhNYXNrID0gbnVsbDtcblx0XHRcdFx0XHRjdXJyZW50RGVwdGhGdW5jID0gbnVsbDtcblx0XHRcdFx0XHRjdXJyZW50RGVwdGhDbGVhciA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gU3RlbmNpbEJ1ZmZlcigpIHtcblx0XHRcdGxldCBsb2NrZWQgPSBmYWxzZTtcblx0XHRcdGxldCBjdXJyZW50U3RlbmNpbE1hc2sgPSBudWxsO1xuXHRcdFx0bGV0IGN1cnJlbnRTdGVuY2lsRnVuYyA9IG51bGw7XG5cdFx0XHRsZXQgY3VycmVudFN0ZW5jaWxSZWYgPSBudWxsO1xuXHRcdFx0bGV0IGN1cnJlbnRTdGVuY2lsRnVuY01hc2sgPSBudWxsO1xuXHRcdFx0bGV0IGN1cnJlbnRTdGVuY2lsRmFpbCA9IG51bGw7XG5cdFx0XHRsZXQgY3VycmVudFN0ZW5jaWxaRmFpbCA9IG51bGw7XG5cdFx0XHRsZXQgY3VycmVudFN0ZW5jaWxaUGFzcyA9IG51bGw7XG5cdFx0XHRsZXQgY3VycmVudFN0ZW5jaWxDbGVhciA9IG51bGw7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzZXRUZXN0OiBmdW5jdGlvbiAoc3RlbmNpbFRlc3QpIHtcblx0XHRcdFx0XHRpZiAoIWxvY2tlZCkge1xuXHRcdFx0XHRcdFx0aWYgKHN0ZW5jaWxUZXN0KSB7XG5cdFx0XHRcdFx0XHRcdGVuYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0TWFzazogZnVuY3Rpb24gKHN0ZW5jaWxNYXNrKSB7XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnRTdGVuY2lsTWFzayAhPT0gc3RlbmNpbE1hc2sgJiYgIWxvY2tlZCkge1xuXHRcdFx0XHRcdFx0Z2wuc3RlbmNpbE1hc2soc3RlbmNpbE1hc2spO1xuXHRcdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxNYXNrID0gc3RlbmNpbE1hc2s7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXRGdW5jOiBmdW5jdGlvbiAoc3RlbmNpbEZ1bmMsIHN0ZW5jaWxSZWYsIHN0ZW5jaWxNYXNrKSB7XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnRTdGVuY2lsRnVuYyAhPT0gc3RlbmNpbEZ1bmMgfHwgY3VycmVudFN0ZW5jaWxSZWYgIT09IHN0ZW5jaWxSZWYgfHwgY3VycmVudFN0ZW5jaWxGdW5jTWFzayAhPT0gc3RlbmNpbE1hc2spIHtcblx0XHRcdFx0XHRcdGdsLnN0ZW5jaWxGdW5jKHN0ZW5jaWxGdW5jLCBzdGVuY2lsUmVmLCBzdGVuY2lsTWFzayk7XG5cdFx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbEZ1bmMgPSBzdGVuY2lsRnVuYztcblx0XHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsUmVmID0gc3RlbmNpbFJlZjtcblx0XHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsRnVuY01hc2sgPSBzdGVuY2lsTWFzaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldE9wOiBmdW5jdGlvbiAoc3RlbmNpbEZhaWwsIHN0ZW5jaWxaRmFpbCwgc3RlbmNpbFpQYXNzKSB7XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnRTdGVuY2lsRmFpbCAhPT0gc3RlbmNpbEZhaWwgfHwgY3VycmVudFN0ZW5jaWxaRmFpbCAhPT0gc3RlbmNpbFpGYWlsIHx8IGN1cnJlbnRTdGVuY2lsWlBhc3MgIT09IHN0ZW5jaWxaUGFzcykge1xuXHRcdFx0XHRcdFx0Z2wuc3RlbmNpbE9wKHN0ZW5jaWxGYWlsLCBzdGVuY2lsWkZhaWwsIHN0ZW5jaWxaUGFzcyk7XG5cdFx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbEZhaWwgPSBzdGVuY2lsRmFpbDtcblx0XHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsWkZhaWwgPSBzdGVuY2lsWkZhaWw7XG5cdFx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbFpQYXNzID0gc3RlbmNpbFpQYXNzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0TG9ja2VkOiBmdW5jdGlvbiAobG9jaykge1xuXHRcdFx0XHRcdGxvY2tlZCA9IGxvY2s7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldENsZWFyOiBmdW5jdGlvbiAoc3RlbmNpbCkge1xuXHRcdFx0XHRcdGlmIChjdXJyZW50U3RlbmNpbENsZWFyICE9PSBzdGVuY2lsKSB7XG5cdFx0XHRcdFx0XHRnbC5jbGVhclN0ZW5jaWwoc3RlbmNpbCk7XG5cdFx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbENsZWFyID0gc3RlbmNpbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bG9ja2VkID0gZmFsc2U7XG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxNYXNrID0gbnVsbDtcblx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbEZ1bmMgPSBudWxsO1xuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsUmVmID0gbnVsbDtcblx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbEZ1bmNNYXNrID0gbnVsbDtcblx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbEZhaWwgPSBudWxsO1xuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsWkZhaWwgPSBudWxsO1xuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsWlBhc3MgPSBudWxsO1xuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsQ2xlYXIgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0gLy9cblxuXG5cdFx0Y29uc3QgY29sb3JCdWZmZXIgPSBuZXcgQ29sb3JCdWZmZXIoKTtcblx0XHRjb25zdCBkZXB0aEJ1ZmZlciA9IG5ldyBEZXB0aEJ1ZmZlcigpO1xuXHRcdGNvbnN0IHN0ZW5jaWxCdWZmZXIgPSBuZXcgU3RlbmNpbEJ1ZmZlcigpO1xuXHRcdGxldCBlbmFibGVkQ2FwYWJpbGl0aWVzID0ge307XG5cdFx0bGV0IGN1cnJlbnRCb3VuZEZyYW1lYnVmZmVycyA9IHt9O1xuXHRcdGxldCBjdXJyZW50UHJvZ3JhbSA9IG51bGw7XG5cdFx0bGV0IGN1cnJlbnRCbGVuZGluZ0VuYWJsZWQgPSBmYWxzZTtcblx0XHRsZXQgY3VycmVudEJsZW5kaW5nID0gbnVsbDtcblx0XHRsZXQgY3VycmVudEJsZW5kRXF1YXRpb24gPSBudWxsO1xuXHRcdGxldCBjdXJyZW50QmxlbmRTcmMgPSBudWxsO1xuXHRcdGxldCBjdXJyZW50QmxlbmREc3QgPSBudWxsO1xuXHRcdGxldCBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcblx0XHRsZXQgY3VycmVudEJsZW5kU3JjQWxwaGEgPSBudWxsO1xuXHRcdGxldCBjdXJyZW50QmxlbmREc3RBbHBoYSA9IG51bGw7XG5cdFx0bGV0IGN1cnJlbnRQcmVtdWx0aXBsZWRBbHBoYSA9IGZhbHNlO1xuXHRcdGxldCBjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcblx0XHRsZXQgY3VycmVudEN1bGxGYWNlID0gbnVsbDtcblx0XHRsZXQgY3VycmVudExpbmVXaWR0aCA9IG51bGw7XG5cdFx0bGV0IGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gbnVsbDtcblx0XHRsZXQgY3VycmVudFBvbHlnb25PZmZzZXRVbml0cyA9IG51bGw7XG5cdFx0Y29uc3QgbWF4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMpO1xuXHRcdGxldCBsaW5lV2lkdGhBdmFpbGFibGUgPSBmYWxzZTtcblx0XHRsZXQgdmVyc2lvbiA9IDA7XG5cdFx0Y29uc3QgZ2xWZXJzaW9uID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLlZFUlNJT04pO1xuXG5cdFx0aWYgKGdsVmVyc2lvbi5pbmRleE9mKCdXZWJHTCcpICE9PSAtMSkge1xuXHRcdFx0dmVyc2lvbiA9IHBhcnNlRmxvYXQoL15XZWJHTCAoXFxkKS8uZXhlYyhnbFZlcnNpb24pWzFdKTtcblx0XHRcdGxpbmVXaWR0aEF2YWlsYWJsZSA9IHZlcnNpb24gPj0gMS4wO1xuXHRcdH0gZWxzZSBpZiAoZ2xWZXJzaW9uLmluZGV4T2YoJ09wZW5HTCBFUycpICE9PSAtMSkge1xuXHRcdFx0dmVyc2lvbiA9IHBhcnNlRmxvYXQoL15PcGVuR0wgRVMgKFxcZCkvLmV4ZWMoZ2xWZXJzaW9uKVsxXSk7XG5cdFx0XHRsaW5lV2lkdGhBdmFpbGFibGUgPSB2ZXJzaW9uID49IDIuMDtcblx0XHR9XG5cblx0XHRsZXQgY3VycmVudFRleHR1cmVTbG90ID0gbnVsbDtcblx0XHRsZXQgY3VycmVudEJvdW5kVGV4dHVyZXMgPSB7fTtcblx0XHRjb25zdCBzY2lzc29yUGFyYW0gPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuU0NJU1NPUl9CT1gpO1xuXHRcdGNvbnN0IHZpZXdwb3J0UGFyYW0gPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuVklFV1BPUlQpO1xuXHRcdGNvbnN0IGN1cnJlbnRTY2lzc29yID0gbmV3IFZlY3RvcjQoKS5mcm9tQXJyYXkoc2Npc3NvclBhcmFtKTtcblx0XHRjb25zdCBjdXJyZW50Vmlld3BvcnQgPSBuZXcgVmVjdG9yNCgpLmZyb21BcnJheSh2aWV3cG9ydFBhcmFtKTtcblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZVRleHR1cmUodHlwZSwgdGFyZ2V0LCBjb3VudCkge1xuXHRcdFx0Y29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KDQpOyAvLyA0IGlzIHJlcXVpcmVkIHRvIG1hdGNoIGRlZmF1bHQgdW5wYWNrIGFsaWdubWVudCBvZiA0LlxuXG5cdFx0XHRjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXHRcdFx0Z2wuYmluZFRleHR1cmUodHlwZSwgdGV4dHVyZSk7XG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKHR5cGUsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKHR5cGUsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHRcdFx0XHRnbC50ZXhJbWFnZTJEKHRhcmdldCArIGksIDAsIGdsLlJHQkEsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGRhdGEpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGV4dHVyZTtcblx0XHR9XG5cblx0XHRjb25zdCBlbXB0eVRleHR1cmVzID0ge307XG5cdFx0ZW1wdHlUZXh0dXJlc1tnbC5URVhUVVJFXzJEXSA9IGNyZWF0ZVRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV8yRCwgMSk7XG5cdFx0ZW1wdHlUZXh0dXJlc1tnbC5URVhUVVJFX0NVQkVfTUFQXSA9IGNyZWF0ZVRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YLCA2KTsgLy8gaW5pdFxuXG5cdFx0Y29sb3JCdWZmZXIuc2V0Q2xlYXIoMCwgMCwgMCwgMSk7XG5cdFx0ZGVwdGhCdWZmZXIuc2V0Q2xlYXIoMSk7XG5cdFx0c3RlbmNpbEJ1ZmZlci5zZXRDbGVhcigwKTtcblx0XHRlbmFibGUoZ2wuREVQVEhfVEVTVCk7XG5cdFx0ZGVwdGhCdWZmZXIuc2V0RnVuYyhMZXNzRXF1YWxEZXB0aCk7XG5cdFx0c2V0RmxpcFNpZGVkKGZhbHNlKTtcblx0XHRzZXRDdWxsRmFjZShDdWxsRmFjZUJhY2spO1xuXHRcdGVuYWJsZShnbC5DVUxMX0ZBQ0UpO1xuXHRcdHNldEJsZW5kaW5nKE5vQmxlbmRpbmcpOyAvL1xuXG5cdFx0ZnVuY3Rpb24gZW5hYmxlKGlkKSB7XG5cdFx0XHRpZiAoZW5hYmxlZENhcGFiaWxpdGllc1tpZF0gIT09IHRydWUpIHtcblx0XHRcdFx0Z2wuZW5hYmxlKGlkKTtcblx0XHRcdFx0ZW5hYmxlZENhcGFiaWxpdGllc1tpZF0gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRpc2FibGUoaWQpIHtcblx0XHRcdGlmIChlbmFibGVkQ2FwYWJpbGl0aWVzW2lkXSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0Z2wuZGlzYWJsZShpZCk7XG5cdFx0XHRcdGVuYWJsZWRDYXBhYmlsaXRpZXNbaWRdID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYmluZEZyYW1lYnVmZmVyKHRhcmdldCwgZnJhbWVidWZmZXIpIHtcblx0XHRcdGlmIChjdXJyZW50Qm91bmRGcmFtZWJ1ZmZlcnNbdGFyZ2V0XSAhPT0gZnJhbWVidWZmZXIpIHtcblx0XHRcdFx0Z2wuYmluZEZyYW1lYnVmZmVyKHRhcmdldCwgZnJhbWVidWZmZXIpO1xuXHRcdFx0XHRjdXJyZW50Qm91bmRGcmFtZWJ1ZmZlcnNbdGFyZ2V0XSA9IGZyYW1lYnVmZmVyO1xuXG5cdFx0XHRcdGlmIChpc1dlYkdMMikge1xuXHRcdFx0XHRcdC8vIGdsLkRSQVdfRlJBTUVCVUZGRVIgaXMgZXF1aXZhbGVudCB0byBnbC5GUkFNRUJVRkZFUlxuXHRcdFx0XHRcdGlmICh0YXJnZXQgPT09IGdsLkRSQVdfRlJBTUVCVUZGRVIpIHtcblx0XHRcdFx0XHRcdGN1cnJlbnRCb3VuZEZyYW1lYnVmZmVyc1tnbC5GUkFNRUJVRkZFUl0gPSBmcmFtZWJ1ZmZlcjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAodGFyZ2V0ID09PSBnbC5GUkFNRUJVRkZFUikge1xuXHRcdFx0XHRcdFx0Y3VycmVudEJvdW5kRnJhbWVidWZmZXJzW2dsLkRSQVdfRlJBTUVCVUZGRVJdID0gZnJhbWVidWZmZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1c2VQcm9ncmFtKHByb2dyYW0pIHtcblx0XHRcdGlmIChjdXJyZW50UHJvZ3JhbSAhPT0gcHJvZ3JhbSkge1xuXHRcdFx0XHRnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuXHRcdFx0XHRjdXJyZW50UHJvZ3JhbSA9IHByb2dyYW07XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Y29uc3QgZXF1YXRpb25Ub0dMID0ge1xuXHRcdFx0W0FkZEVxdWF0aW9uXTogZ2wuRlVOQ19BREQsXG5cdFx0XHRbU3VidHJhY3RFcXVhdGlvbl06IGdsLkZVTkNfU1VCVFJBQ1QsXG5cdFx0XHRbUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb25dOiBnbC5GVU5DX1JFVkVSU0VfU1VCVFJBQ1Rcblx0XHR9O1xuXG5cdFx0aWYgKGlzV2ViR0wyKSB7XG5cdFx0XHRlcXVhdGlvblRvR0xbTWluRXF1YXRpb25dID0gZ2wuTUlOO1xuXHRcdFx0ZXF1YXRpb25Ub0dMW01heEVxdWF0aW9uXSA9IGdsLk1BWDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ0VYVF9ibGVuZF9taW5tYXgnKTtcblxuXHRcdFx0aWYgKGV4dGVuc2lvbiAhPT0gbnVsbCkge1xuXHRcdFx0XHRlcXVhdGlvblRvR0xbTWluRXF1YXRpb25dID0gZXh0ZW5zaW9uLk1JTl9FWFQ7XG5cdFx0XHRcdGVxdWF0aW9uVG9HTFtNYXhFcXVhdGlvbl0gPSBleHRlbnNpb24uTUFYX0VYVDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCBmYWN0b3JUb0dMID0ge1xuXHRcdFx0W1plcm9GYWN0b3JdOiBnbC5aRVJPLFxuXHRcdFx0W09uZUZhY3Rvcl06IGdsLk9ORSxcblx0XHRcdFtTcmNDb2xvckZhY3Rvcl06IGdsLlNSQ19DT0xPUixcblx0XHRcdFtTcmNBbHBoYUZhY3Rvcl06IGdsLlNSQ19BTFBIQSxcblx0XHRcdFtTcmNBbHBoYVNhdHVyYXRlRmFjdG9yXTogZ2wuU1JDX0FMUEhBX1NBVFVSQVRFLFxuXHRcdFx0W0RzdENvbG9yRmFjdG9yXTogZ2wuRFNUX0NPTE9SLFxuXHRcdFx0W0RzdEFscGhhRmFjdG9yXTogZ2wuRFNUX0FMUEhBLFxuXHRcdFx0W09uZU1pbnVzU3JjQ29sb3JGYWN0b3JdOiBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SLFxuXHRcdFx0W09uZU1pbnVzU3JjQWxwaGFGYWN0b3JdOiBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLFxuXHRcdFx0W09uZU1pbnVzRHN0Q29sb3JGYWN0b3JdOiBnbC5PTkVfTUlOVVNfRFNUX0NPTE9SLFxuXHRcdFx0W09uZU1pbnVzRHN0QWxwaGFGYWN0b3JdOiBnbC5PTkVfTUlOVVNfRFNUX0FMUEhBXG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHNldEJsZW5kaW5nKGJsZW5kaW5nLCBibGVuZEVxdWF0aW9uLCBibGVuZFNyYywgYmxlbmREc3QsIGJsZW5kRXF1YXRpb25BbHBoYSwgYmxlbmRTcmNBbHBoYSwgYmxlbmREc3RBbHBoYSwgcHJlbXVsdGlwbGllZEFscGhhKSB7XG5cdFx0XHRpZiAoYmxlbmRpbmcgPT09IE5vQmxlbmRpbmcpIHtcblx0XHRcdFx0aWYgKGN1cnJlbnRCbGVuZGluZ0VuYWJsZWQgPT09IHRydWUpIHtcblx0XHRcdFx0XHRkaXNhYmxlKGdsLkJMRU5EKTtcblx0XHRcdFx0XHRjdXJyZW50QmxlbmRpbmdFbmFibGVkID0gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjdXJyZW50QmxlbmRpbmdFbmFibGVkID09PSBmYWxzZSkge1xuXHRcdFx0XHRlbmFibGUoZ2wuQkxFTkQpO1xuXHRcdFx0XHRjdXJyZW50QmxlbmRpbmdFbmFibGVkID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGJsZW5kaW5nICE9PSBDdXN0b21CbGVuZGluZykge1xuXHRcdFx0XHRpZiAoYmxlbmRpbmcgIT09IGN1cnJlbnRCbGVuZGluZyB8fCBwcmVtdWx0aXBsaWVkQWxwaGEgIT09IGN1cnJlbnRQcmVtdWx0aXBsZWRBbHBoYSkge1xuXHRcdFx0XHRcdGlmIChjdXJyZW50QmxlbmRFcXVhdGlvbiAhPT0gQWRkRXF1YXRpb24gfHwgY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSAhPT0gQWRkRXF1YXRpb24pIHtcblx0XHRcdFx0XHRcdGdsLmJsZW5kRXF1YXRpb24oZ2wuRlVOQ19BREQpO1xuXHRcdFx0XHRcdFx0Y3VycmVudEJsZW5kRXF1YXRpb24gPSBBZGRFcXVhdGlvbjtcblx0XHRcdFx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBBZGRFcXVhdGlvbjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAocHJlbXVsdGlwbGllZEFscGhhKSB7XG5cdFx0XHRcdFx0XHRzd2l0Y2ggKGJsZW5kaW5nKSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgTm9ybWFsQmxlbmRpbmc6XG5cdFx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgQWRkaXRpdmVCbGVuZGluZzpcblx0XHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkUpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgU3VidHJhY3RpdmVCbGVuZGluZzpcblx0XHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZShnbC5aRVJPLCBnbC5aRVJPLCBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlIE11bHRpcGx5QmxlbmRpbmc6XG5cdFx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuWkVSTywgZ2wuU1JDX0NPTE9SLCBnbC5aRVJPLCBnbC5TUkNfQUxQSEEpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xTdGF0ZTogSW52YWxpZCBibGVuZGluZzogJywgYmxlbmRpbmcpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzd2l0Y2ggKGJsZW5kaW5nKSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgTm9ybWFsQmxlbmRpbmc6XG5cdFx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgQWRkaXRpdmVCbGVuZGluZzpcblx0XHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkUpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgU3VidHJhY3RpdmVCbGVuZGluZzpcblx0XHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmMoZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19DT0xPUik7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSBNdWx0aXBseUJsZW5kaW5nOlxuXHRcdFx0XHRcdFx0XHRcdGdsLmJsZW5kRnVuYyhnbC5aRVJPLCBnbC5TUkNfQ09MT1IpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xTdGF0ZTogSW52YWxpZCBibGVuZGluZzogJywgYmxlbmRpbmcpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGN1cnJlbnRCbGVuZFNyYyA9IG51bGw7XG5cdFx0XHRcdFx0Y3VycmVudEJsZW5kRHN0ID0gbnVsbDtcblx0XHRcdFx0XHRjdXJyZW50QmxlbmRTcmNBbHBoYSA9IG51bGw7XG5cdFx0XHRcdFx0Y3VycmVudEJsZW5kRHN0QWxwaGEgPSBudWxsO1xuXHRcdFx0XHRcdGN1cnJlbnRCbGVuZGluZyA9IGJsZW5kaW5nO1xuXHRcdFx0XHRcdGN1cnJlbnRQcmVtdWx0aXBsZWRBbHBoYSA9IHByZW11bHRpcGxpZWRBbHBoYTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gLy8gY3VzdG9tIGJsZW5kaW5nXG5cblxuXHRcdFx0YmxlbmRFcXVhdGlvbkFscGhhID0gYmxlbmRFcXVhdGlvbkFscGhhIHx8IGJsZW5kRXF1YXRpb247XG5cdFx0XHRibGVuZFNyY0FscGhhID0gYmxlbmRTcmNBbHBoYSB8fCBibGVuZFNyYztcblx0XHRcdGJsZW5kRHN0QWxwaGEgPSBibGVuZERzdEFscGhhIHx8IGJsZW5kRHN0O1xuXG5cdFx0XHRpZiAoYmxlbmRFcXVhdGlvbiAhPT0gY3VycmVudEJsZW5kRXF1YXRpb24gfHwgYmxlbmRFcXVhdGlvbkFscGhhICE9PSBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhKSB7XG5cdFx0XHRcdGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShlcXVhdGlvblRvR0xbYmxlbmRFcXVhdGlvbl0sIGVxdWF0aW9uVG9HTFtibGVuZEVxdWF0aW9uQWxwaGFdKTtcblx0XHRcdFx0Y3VycmVudEJsZW5kRXF1YXRpb24gPSBibGVuZEVxdWF0aW9uO1xuXHRcdFx0XHRjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gYmxlbmRFcXVhdGlvbkFscGhhO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYmxlbmRTcmMgIT09IGN1cnJlbnRCbGVuZFNyYyB8fCBibGVuZERzdCAhPT0gY3VycmVudEJsZW5kRHN0IHx8IGJsZW5kU3JjQWxwaGEgIT09IGN1cnJlbnRCbGVuZFNyY0FscGhhIHx8IGJsZW5kRHN0QWxwaGEgIT09IGN1cnJlbnRCbGVuZERzdEFscGhhKSB7XG5cdFx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKGZhY3RvclRvR0xbYmxlbmRTcmNdLCBmYWN0b3JUb0dMW2JsZW5kRHN0XSwgZmFjdG9yVG9HTFtibGVuZFNyY0FscGhhXSwgZmFjdG9yVG9HTFtibGVuZERzdEFscGhhXSk7XG5cdFx0XHRcdGN1cnJlbnRCbGVuZFNyYyA9IGJsZW5kU3JjO1xuXHRcdFx0XHRjdXJyZW50QmxlbmREc3QgPSBibGVuZERzdDtcblx0XHRcdFx0Y3VycmVudEJsZW5kU3JjQWxwaGEgPSBibGVuZFNyY0FscGhhO1xuXHRcdFx0XHRjdXJyZW50QmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGE7XG5cdFx0XHR9XG5cblx0XHRcdGN1cnJlbnRCbGVuZGluZyA9IGJsZW5kaW5nO1xuXHRcdFx0Y3VycmVudFByZW11bHRpcGxlZEFscGhhID0gbnVsbDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXRNYXRlcmlhbChtYXRlcmlhbCwgZnJvbnRGYWNlQ1cpIHtcblx0XHRcdG1hdGVyaWFsLnNpZGUgPT09IERvdWJsZVNpZGUgPyBkaXNhYmxlKGdsLkNVTExfRkFDRSkgOiBlbmFibGUoZ2wuQ1VMTF9GQUNFKTtcblx0XHRcdGxldCBmbGlwU2lkZWQgPSBtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZTtcblx0XHRcdGlmIChmcm9udEZhY2VDVykgZmxpcFNpZGVkID0gIWZsaXBTaWRlZDtcblx0XHRcdHNldEZsaXBTaWRlZChmbGlwU2lkZWQpO1xuXHRcdFx0bWF0ZXJpYWwuYmxlbmRpbmcgPT09IE5vcm1hbEJsZW5kaW5nICYmIG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSBmYWxzZSA/IHNldEJsZW5kaW5nKE5vQmxlbmRpbmcpIDogc2V0QmxlbmRpbmcobWF0ZXJpYWwuYmxlbmRpbmcsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24sIG1hdGVyaWFsLmJsZW5kU3JjLCBtYXRlcmlhbC5ibGVuZERzdCwgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbkFscGhhLCBtYXRlcmlhbC5ibGVuZFNyY0FscGhhLCBtYXRlcmlhbC5ibGVuZERzdEFscGhhLCBtYXRlcmlhbC5wcmVtdWx0aXBsaWVkQWxwaGEpO1xuXHRcdFx0ZGVwdGhCdWZmZXIuc2V0RnVuYyhtYXRlcmlhbC5kZXB0aEZ1bmMpO1xuXHRcdFx0ZGVwdGhCdWZmZXIuc2V0VGVzdChtYXRlcmlhbC5kZXB0aFRlc3QpO1xuXHRcdFx0ZGVwdGhCdWZmZXIuc2V0TWFzayhtYXRlcmlhbC5kZXB0aFdyaXRlKTtcblx0XHRcdGNvbG9yQnVmZmVyLnNldE1hc2sobWF0ZXJpYWwuY29sb3JXcml0ZSk7XG5cdFx0XHRjb25zdCBzdGVuY2lsV3JpdGUgPSBtYXRlcmlhbC5zdGVuY2lsV3JpdGU7XG5cdFx0XHRzdGVuY2lsQnVmZmVyLnNldFRlc3Qoc3RlbmNpbFdyaXRlKTtcblxuXHRcdFx0aWYgKHN0ZW5jaWxXcml0ZSkge1xuXHRcdFx0XHRzdGVuY2lsQnVmZmVyLnNldE1hc2sobWF0ZXJpYWwuc3RlbmNpbFdyaXRlTWFzayk7XG5cdFx0XHRcdHN0ZW5jaWxCdWZmZXIuc2V0RnVuYyhtYXRlcmlhbC5zdGVuY2lsRnVuYywgbWF0ZXJpYWwuc3RlbmNpbFJlZiwgbWF0ZXJpYWwuc3RlbmNpbEZ1bmNNYXNrKTtcblx0XHRcdFx0c3RlbmNpbEJ1ZmZlci5zZXRPcChtYXRlcmlhbC5zdGVuY2lsRmFpbCwgbWF0ZXJpYWwuc3RlbmNpbFpGYWlsLCBtYXRlcmlhbC5zdGVuY2lsWlBhc3MpO1xuXHRcdFx0fVxuXG5cdFx0XHRzZXRQb2x5Z29uT2Zmc2V0KG1hdGVyaWFsLnBvbHlnb25PZmZzZXQsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRVbml0cyk7XG5cdFx0XHRtYXRlcmlhbC5hbHBoYVRvQ292ZXJhZ2UgPT09IHRydWUgPyBlbmFibGUoZ2wuU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFKSA6IGRpc2FibGUoZ2wuU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFKTtcblx0XHR9IC8vXG5cblxuXHRcdGZ1bmN0aW9uIHNldEZsaXBTaWRlZChmbGlwU2lkZWQpIHtcblx0XHRcdGlmIChjdXJyZW50RmxpcFNpZGVkICE9PSBmbGlwU2lkZWQpIHtcblx0XHRcdFx0aWYgKGZsaXBTaWRlZCkge1xuXHRcdFx0XHRcdGdsLmZyb250RmFjZShnbC5DVyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Z2wuZnJvbnRGYWNlKGdsLkNDVyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdXJyZW50RmxpcFNpZGVkID0gZmxpcFNpZGVkO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldEN1bGxGYWNlKGN1bGxGYWNlKSB7XG5cdFx0XHRpZiAoY3VsbEZhY2UgIT09IEN1bGxGYWNlTm9uZSkge1xuXHRcdFx0XHRlbmFibGUoZ2wuQ1VMTF9GQUNFKTtcblxuXHRcdFx0XHRpZiAoY3VsbEZhY2UgIT09IGN1cnJlbnRDdWxsRmFjZSkge1xuXHRcdFx0XHRcdGlmIChjdWxsRmFjZSA9PT0gQ3VsbEZhY2VCYWNrKSB7XG5cdFx0XHRcdFx0XHRnbC5jdWxsRmFjZShnbC5CQUNLKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGN1bGxGYWNlID09PSBDdWxsRmFjZUZyb250KSB7XG5cdFx0XHRcdFx0XHRnbC5jdWxsRmFjZShnbC5GUk9OVCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGdsLmN1bGxGYWNlKGdsLkZST05UX0FORF9CQUNLKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRpc2FibGUoZ2wuQ1VMTF9GQUNFKTtcblx0XHRcdH1cblxuXHRcdFx0Y3VycmVudEN1bGxGYWNlID0gY3VsbEZhY2U7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0TGluZVdpZHRoKHdpZHRoKSB7XG5cdFx0XHRpZiAod2lkdGggIT09IGN1cnJlbnRMaW5lV2lkdGgpIHtcblx0XHRcdFx0aWYgKGxpbmVXaWR0aEF2YWlsYWJsZSkgZ2wubGluZVdpZHRoKHdpZHRoKTtcblx0XHRcdFx0Y3VycmVudExpbmVXaWR0aCA9IHdpZHRoO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldFBvbHlnb25PZmZzZXQocG9seWdvbk9mZnNldCwgZmFjdG9yLCB1bml0cykge1xuXHRcdFx0aWYgKHBvbHlnb25PZmZzZXQpIHtcblx0XHRcdFx0ZW5hYmxlKGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwpO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciAhPT0gZmFjdG9yIHx8IGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgIT09IHVuaXRzKSB7XG5cdFx0XHRcdFx0Z2wucG9seWdvbk9mZnNldChmYWN0b3IsIHVuaXRzKTtcblx0XHRcdFx0XHRjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciA9IGZhY3Rvcjtcblx0XHRcdFx0XHRjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzID0gdW5pdHM7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRpc2FibGUoZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0U2Npc3NvclRlc3Qoc2Npc3NvclRlc3QpIHtcblx0XHRcdGlmIChzY2lzc29yVGVzdCkge1xuXHRcdFx0XHRlbmFibGUoZ2wuU0NJU1NPUl9URVNUKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRpc2FibGUoZ2wuU0NJU1NPUl9URVNUKTtcblx0XHRcdH1cblx0XHR9IC8vIHRleHR1cmVcblxuXG5cdFx0ZnVuY3Rpb24gYWN0aXZlVGV4dHVyZSh3ZWJnbFNsb3QpIHtcblx0XHRcdGlmICh3ZWJnbFNsb3QgPT09IHVuZGVmaW5lZCkgd2ViZ2xTbG90ID0gZ2wuVEVYVFVSRTAgKyBtYXhUZXh0dXJlcyAtIDE7XG5cblx0XHRcdGlmIChjdXJyZW50VGV4dHVyZVNsb3QgIT09IHdlYmdsU2xvdCkge1xuXHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKHdlYmdsU2xvdCk7XG5cdFx0XHRcdGN1cnJlbnRUZXh0dXJlU2xvdCA9IHdlYmdsU2xvdDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBiaW5kVGV4dHVyZSh3ZWJnbFR5cGUsIHdlYmdsVGV4dHVyZSkge1xuXHRcdFx0aWYgKGN1cnJlbnRUZXh0dXJlU2xvdCA9PT0gbnVsbCkge1xuXHRcdFx0XHRhY3RpdmVUZXh0dXJlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBib3VuZFRleHR1cmUgPSBjdXJyZW50Qm91bmRUZXh0dXJlc1tjdXJyZW50VGV4dHVyZVNsb3RdO1xuXG5cdFx0XHRpZiAoYm91bmRUZXh0dXJlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Ym91bmRUZXh0dXJlID0ge1xuXHRcdFx0XHRcdHR5cGU6IHVuZGVmaW5lZCxcblx0XHRcdFx0XHR0ZXh0dXJlOiB1bmRlZmluZWRcblx0XHRcdFx0fTtcblx0XHRcdFx0Y3VycmVudEJvdW5kVGV4dHVyZXNbY3VycmVudFRleHR1cmVTbG90XSA9IGJvdW5kVGV4dHVyZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGJvdW5kVGV4dHVyZS50eXBlICE9PSB3ZWJnbFR5cGUgfHwgYm91bmRUZXh0dXJlLnRleHR1cmUgIT09IHdlYmdsVGV4dHVyZSkge1xuXHRcdFx0XHRnbC5iaW5kVGV4dHVyZSh3ZWJnbFR5cGUsIHdlYmdsVGV4dHVyZSB8fCBlbXB0eVRleHR1cmVzW3dlYmdsVHlwZV0pO1xuXHRcdFx0XHRib3VuZFRleHR1cmUudHlwZSA9IHdlYmdsVHlwZTtcblx0XHRcdFx0Ym91bmRUZXh0dXJlLnRleHR1cmUgPSB3ZWJnbFRleHR1cmU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdW5iaW5kVGV4dHVyZSgpIHtcblx0XHRcdGNvbnN0IGJvdW5kVGV4dHVyZSA9IGN1cnJlbnRCb3VuZFRleHR1cmVzW2N1cnJlbnRUZXh0dXJlU2xvdF07XG5cblx0XHRcdGlmIChib3VuZFRleHR1cmUgIT09IHVuZGVmaW5lZCAmJiBib3VuZFRleHR1cmUudHlwZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGJvdW5kVGV4dHVyZS50eXBlLCBudWxsKTtcblx0XHRcdFx0Ym91bmRUZXh0dXJlLnR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdGJvdW5kVGV4dHVyZS50ZXh0dXJlID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNvbXByZXNzZWRUZXhJbWFnZTJEKCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Z2wuY29tcHJlc3NlZFRleEltYWdlMkQuYXBwbHkoZ2wsIGFyZ3VtZW50cyk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTFN0YXRlOicsIGVycm9yKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0ZXhTdWJJbWFnZTJEKCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Z2wudGV4U3ViSW1hZ2UyRC5hcHBseShnbCwgYXJndW1lbnRzKTtcblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMU3RhdGU6JywgZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRleFN0b3JhZ2UyRCgpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGdsLnRleFN0b3JhZ2UyRC5hcHBseShnbCwgYXJndW1lbnRzKTtcblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMU3RhdGU6JywgZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRleEltYWdlMkQoKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRnbC50ZXhJbWFnZTJELmFwcGx5KGdsLCBhcmd1bWVudHMpO1xuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xTdGF0ZTonLCBlcnJvcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdGV4SW1hZ2UzRCgpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGdsLnRleEltYWdlM0QuYXBwbHkoZ2wsIGFyZ3VtZW50cyk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTFN0YXRlOicsIGVycm9yKTtcblx0XHRcdH1cblx0XHR9IC8vXG5cblxuXHRcdGZ1bmN0aW9uIHNjaXNzb3Ioc2Npc3Nvcikge1xuXHRcdFx0aWYgKGN1cnJlbnRTY2lzc29yLmVxdWFscyhzY2lzc29yKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0Z2wuc2Npc3NvcihzY2lzc29yLngsIHNjaXNzb3IueSwgc2Npc3Nvci56LCBzY2lzc29yLncpO1xuXHRcdFx0XHRjdXJyZW50U2Npc3Nvci5jb3B5KHNjaXNzb3IpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHZpZXdwb3J0KHZpZXdwb3J0KSB7XG5cdFx0XHRpZiAoY3VycmVudFZpZXdwb3J0LmVxdWFscyh2aWV3cG9ydCkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdGdsLnZpZXdwb3J0KHZpZXdwb3J0LngsIHZpZXdwb3J0LnksIHZpZXdwb3J0LnosIHZpZXdwb3J0LncpO1xuXHRcdFx0XHRjdXJyZW50Vmlld3BvcnQuY29weSh2aWV3cG9ydCk7XG5cdFx0XHR9XG5cdFx0fSAvL1xuXG5cblx0XHRmdW5jdGlvbiByZXNldCgpIHtcblx0XHRcdC8vIHJlc2V0IHN0YXRlXG5cdFx0XHRnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblx0XHRcdGdsLmRpc2FibGUoZ2wuQ1VMTF9GQUNFKTtcblx0XHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cdFx0XHRnbC5kaXNhYmxlKGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwpO1xuXHRcdFx0Z2wuZGlzYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xuXHRcdFx0Z2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuXHRcdFx0Z2wuZGlzYWJsZShnbC5TQU1QTEVfQUxQSEFfVE9fQ09WRVJBR0UpO1xuXHRcdFx0Z2wuYmxlbmRFcXVhdGlvbihnbC5GVU5DX0FERCk7XG5cdFx0XHRnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5aRVJPKTtcblx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKGdsLk9ORSwgZ2wuWkVSTywgZ2wuT05FLCBnbC5aRVJPKTtcblx0XHRcdGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcblx0XHRcdGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XG5cdFx0XHRnbC5kZXB0aE1hc2sodHJ1ZSk7XG5cdFx0XHRnbC5kZXB0aEZ1bmMoZ2wuTEVTUyk7XG5cdFx0XHRnbC5jbGVhckRlcHRoKDEpO1xuXHRcdFx0Z2wuc3RlbmNpbE1hc2soMHhmZmZmZmZmZik7XG5cdFx0XHRnbC5zdGVuY2lsRnVuYyhnbC5BTFdBWVMsIDAsIDB4ZmZmZmZmZmYpO1xuXHRcdFx0Z2wuc3RlbmNpbE9wKGdsLktFRVAsIGdsLktFRVAsIGdsLktFRVApO1xuXHRcdFx0Z2wuY2xlYXJTdGVuY2lsKDApO1xuXHRcdFx0Z2wuY3VsbEZhY2UoZ2wuQkFDSyk7XG5cdFx0XHRnbC5mcm9udEZhY2UoZ2wuQ0NXKTtcblx0XHRcdGdsLnBvbHlnb25PZmZzZXQoMCwgMCk7XG5cdFx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcblx0XHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cblx0XHRcdGlmIChpc1dlYkdMMiA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRFJBV19GUkFNRUJVRkZFUiwgbnVsbCk7XG5cdFx0XHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5SRUFEX0ZSQU1FQlVGRkVSLCBudWxsKTtcblx0XHRcdH1cblxuXHRcdFx0Z2wudXNlUHJvZ3JhbShudWxsKTtcblx0XHRcdGdsLmxpbmVXaWR0aCgxKTtcblx0XHRcdGdsLnNjaXNzb3IoMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTtcblx0XHRcdGdsLnZpZXdwb3J0KDAsIDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCk7IC8vIHJlc2V0IGludGVybmFsc1xuXG5cdFx0XHRlbmFibGVkQ2FwYWJpbGl0aWVzID0ge307XG5cdFx0XHRjdXJyZW50VGV4dHVyZVNsb3QgPSBudWxsO1xuXHRcdFx0Y3VycmVudEJvdW5kVGV4dHVyZXMgPSB7fTtcblx0XHRcdGN1cnJlbnRCb3VuZEZyYW1lYnVmZmVycyA9IHt9O1xuXHRcdFx0Y3VycmVudFByb2dyYW0gPSBudWxsO1xuXHRcdFx0Y3VycmVudEJsZW5kaW5nRW5hYmxlZCA9IGZhbHNlO1xuXHRcdFx0Y3VycmVudEJsZW5kaW5nID0gbnVsbDtcblx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gbnVsbDtcblx0XHRcdGN1cnJlbnRCbGVuZFNyYyA9IG51bGw7XG5cdFx0XHRjdXJyZW50QmxlbmREc3QgPSBudWxsO1xuXHRcdFx0Y3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XG5cdFx0XHRjdXJyZW50QmxlbmRTcmNBbHBoYSA9IG51bGw7XG5cdFx0XHRjdXJyZW50QmxlbmREc3RBbHBoYSA9IG51bGw7XG5cdFx0XHRjdXJyZW50UHJlbXVsdGlwbGVkQWxwaGEgPSBmYWxzZTtcblx0XHRcdGN1cnJlbnRGbGlwU2lkZWQgPSBudWxsO1xuXHRcdFx0Y3VycmVudEN1bGxGYWNlID0gbnVsbDtcblx0XHRcdGN1cnJlbnRMaW5lV2lkdGggPSBudWxsO1xuXHRcdFx0Y3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgPSBudWxsO1xuXHRcdFx0Y3VycmVudFBvbHlnb25PZmZzZXRVbml0cyA9IG51bGw7XG5cdFx0XHRjdXJyZW50U2Npc3Nvci5zZXQoMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTtcblx0XHRcdGN1cnJlbnRWaWV3cG9ydC5zZXQoMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTtcblx0XHRcdGNvbG9yQnVmZmVyLnJlc2V0KCk7XG5cdFx0XHRkZXB0aEJ1ZmZlci5yZXNldCgpO1xuXHRcdFx0c3RlbmNpbEJ1ZmZlci5yZXNldCgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRidWZmZXJzOiB7XG5cdFx0XHRcdGNvbG9yOiBjb2xvckJ1ZmZlcixcblx0XHRcdFx0ZGVwdGg6IGRlcHRoQnVmZmVyLFxuXHRcdFx0XHRzdGVuY2lsOiBzdGVuY2lsQnVmZmVyXG5cdFx0XHR9LFxuXHRcdFx0ZW5hYmxlOiBlbmFibGUsXG5cdFx0XHRkaXNhYmxlOiBkaXNhYmxlLFxuXHRcdFx0YmluZEZyYW1lYnVmZmVyOiBiaW5kRnJhbWVidWZmZXIsXG5cdFx0XHR1c2VQcm9ncmFtOiB1c2VQcm9ncmFtLFxuXHRcdFx0c2V0QmxlbmRpbmc6IHNldEJsZW5kaW5nLFxuXHRcdFx0c2V0TWF0ZXJpYWw6IHNldE1hdGVyaWFsLFxuXHRcdFx0c2V0RmxpcFNpZGVkOiBzZXRGbGlwU2lkZWQsXG5cdFx0XHRzZXRDdWxsRmFjZTogc2V0Q3VsbEZhY2UsXG5cdFx0XHRzZXRMaW5lV2lkdGg6IHNldExpbmVXaWR0aCxcblx0XHRcdHNldFBvbHlnb25PZmZzZXQ6IHNldFBvbHlnb25PZmZzZXQsXG5cdFx0XHRzZXRTY2lzc29yVGVzdDogc2V0U2Npc3NvclRlc3QsXG5cdFx0XHRhY3RpdmVUZXh0dXJlOiBhY3RpdmVUZXh0dXJlLFxuXHRcdFx0YmluZFRleHR1cmU6IGJpbmRUZXh0dXJlLFxuXHRcdFx0dW5iaW5kVGV4dHVyZTogdW5iaW5kVGV4dHVyZSxcblx0XHRcdGNvbXByZXNzZWRUZXhJbWFnZTJEOiBjb21wcmVzc2VkVGV4SW1hZ2UyRCxcblx0XHRcdHRleEltYWdlMkQ6IHRleEltYWdlMkQsXG5cdFx0XHR0ZXhJbWFnZTNEOiB0ZXhJbWFnZTNELFxuXHRcdFx0dGV4U3RvcmFnZTJEOiB0ZXhTdG9yYWdlMkQsXG5cdFx0XHR0ZXhTdWJJbWFnZTJEOiB0ZXhTdWJJbWFnZTJELFxuXHRcdFx0c2Npc3Nvcjogc2Npc3Nvcixcblx0XHRcdHZpZXdwb3J0OiB2aWV3cG9ydCxcblx0XHRcdHJlc2V0OiByZXNldFxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTFRleHR1cmVzKF9nbCwgZXh0ZW5zaW9ucywgc3RhdGUsIHByb3BlcnRpZXMsIGNhcGFiaWxpdGllcywgdXRpbHMsIGluZm8pIHtcblx0XHRjb25zdCBpc1dlYkdMMiA9IGNhcGFiaWxpdGllcy5pc1dlYkdMMjtcblx0XHRjb25zdCBtYXhUZXh0dXJlcyA9IGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlcztcblx0XHRjb25zdCBtYXhDdWJlbWFwU2l6ZSA9IGNhcGFiaWxpdGllcy5tYXhDdWJlbWFwU2l6ZTtcblx0XHRjb25zdCBtYXhUZXh0dXJlU2l6ZSA9IGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZTtcblx0XHRjb25zdCBtYXhTYW1wbGVzID0gY2FwYWJpbGl0aWVzLm1heFNhbXBsZXM7XG5cdFx0Y29uc3QgaGFzTXVsdGlzYW1wbGVkUmVuZGVyVG9UZXh0dXJlID0gZXh0ZW5zaW9ucy5oYXMoJ1dFQkdMX211bHRpc2FtcGxlZF9yZW5kZXJfdG9fdGV4dHVyZScpO1xuXHRcdGNvbnN0IE11bHRpc2FtcGxlZFJlbmRlclRvVGV4dHVyZUV4dGVuc2lvbiA9IGhhc011bHRpc2FtcGxlZFJlbmRlclRvVGV4dHVyZSA/IGV4dGVuc2lvbnMuZ2V0KCdXRUJHTF9tdWx0aXNhbXBsZWRfcmVuZGVyX3RvX3RleHR1cmUnKSA6IHVuZGVmaW5lZDtcblxuXHRcdGNvbnN0IF92aWRlb1RleHR1cmVzID0gbmV3IFdlYWtNYXAoKTtcblxuXHRcdGxldCBfY2FudmFzOyAvLyBjb3Jkb3ZhIGlPUyAoYXMgb2YgNS4wKSBzdGlsbCB1c2VzIFVJV2ViVmlldywgd2hpY2ggcHJvdmlkZXMgT2Zmc2NyZWVuQ2FudmFzLFxuXHRcdC8vIGFsc28gT2Zmc2NyZWVuQ2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiKSwgYnV0IG5vdCBPZmZzY3JlZW5DYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpIVxuXHRcdC8vIFNvbWUgaW1wbGVtZW50YXRpb25zIG1heSBvbmx5IGltcGxlbWVudCBPZmZzY3JlZW5DYW52YXMgcGFydGlhbGx5IChlLmcuIGxhY2tpbmcgMmQpLlxuXG5cblx0XHRsZXQgdXNlT2Zmc2NyZWVuQ2FudmFzID0gZmFsc2U7XG5cblx0XHR0cnkge1xuXHRcdFx0dXNlT2Zmc2NyZWVuQ2FudmFzID0gdHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKS5nZXRDb250ZXh0KCcyZCcpICE9PSBudWxsO1xuXHRcdH0gY2F0Y2ggKGVycikgey8vIElnbm9yZSBhbnkgZXJyb3JzXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcblx0XHRcdC8vIFVzZSBPZmZzY3JlZW5DYW52YXMgd2hlbiBhdmFpbGFibGUuIFNwZWNpYWxseSBuZWVkZWQgaW4gd2ViIHdvcmtlcnNcblx0XHRcdHJldHVybiB1c2VPZmZzY3JlZW5DYW52YXMgPyBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpIDogY3JlYXRlRWxlbWVudE5TKCdjYW52YXMnKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZXNpemVJbWFnZShpbWFnZSwgbmVlZHNQb3dlck9mVHdvLCBuZWVkc05ld0NhbnZhcywgbWF4U2l6ZSkge1xuXHRcdFx0bGV0IHNjYWxlID0gMTsgLy8gaGFuZGxlIGNhc2UgaWYgdGV4dHVyZSBleGNlZWRzIG1heCBzaXplXG5cblx0XHRcdGlmIChpbWFnZS53aWR0aCA+IG1heFNpemUgfHwgaW1hZ2UuaGVpZ2h0ID4gbWF4U2l6ZSkge1xuXHRcdFx0XHRzY2FsZSA9IG1heFNpemUgLyBNYXRoLm1heChpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcblx0XHRcdH0gLy8gb25seSBwZXJmb3JtIHJlc2l6ZSBpZiBuZWNlc3NhcnlcblxuXG5cdFx0XHRpZiAoc2NhbGUgPCAxIHx8IG5lZWRzUG93ZXJPZlR3byA9PT0gdHJ1ZSkge1xuXHRcdFx0XHQvLyBvbmx5IHBlcmZvcm0gcmVzaXplIGZvciBjZXJ0YWluIGltYWdlIHR5cGVzXG5cdFx0XHRcdGlmICh0eXBlb2YgSFRNTEltYWdlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50IHx8IHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCB8fCB0eXBlb2YgSW1hZ2VCaXRtYXAgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXApIHtcblx0XHRcdFx0XHRjb25zdCBmbG9vciA9IG5lZWRzUG93ZXJPZlR3byA/IGZsb29yUG93ZXJPZlR3byA6IE1hdGguZmxvb3I7XG5cdFx0XHRcdFx0Y29uc3Qgd2lkdGggPSBmbG9vcihzY2FsZSAqIGltYWdlLndpZHRoKTtcblx0XHRcdFx0XHRjb25zdCBoZWlnaHQgPSBmbG9vcihzY2FsZSAqIGltYWdlLmhlaWdodCk7XG5cdFx0XHRcdFx0aWYgKF9jYW52YXMgPT09IHVuZGVmaW5lZCkgX2NhbnZhcyA9IGNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KTsgLy8gY3ViZSB0ZXh0dXJlcyBjYW4ndCByZXVzZSB0aGUgc2FtZSBjYW52YXNcblxuXHRcdFx0XHRcdGNvbnN0IGNhbnZhcyA9IG5lZWRzTmV3Q2FudmFzID8gY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIDogX2NhbnZhcztcblx0XHRcdFx0XHRjYW52YXMud2lkdGggPSB3aWR0aDtcblx0XHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdFx0XHRcdGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRcdFx0XHRjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGhhcyBiZWVuIHJlc2l6ZWQgZnJvbSAoJyArIGltYWdlLndpZHRoICsgJ3gnICsgaW1hZ2UuaGVpZ2h0ICsgJykgdG8gKCcgKyB3aWR0aCArICd4JyArIGhlaWdodCArICcpLicpO1xuXHRcdFx0XHRcdHJldHVybiBjYW52YXM7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCdkYXRhJyBpbiBpbWFnZSkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBJbWFnZSBpbiBEYXRhVGV4dHVyZSBpcyB0b28gYmlnICgnICsgaW1hZ2Uud2lkdGggKyAneCcgKyBpbWFnZS5oZWlnaHQgKyAnKS4nKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gaW1hZ2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGltYWdlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzUG93ZXJPZlR3byQxKGltYWdlKSB7XG5cdFx0XHRyZXR1cm4gaXNQb3dlck9mVHdvKGltYWdlLndpZHRoKSAmJiBpc1Bvd2VyT2ZUd28oaW1hZ2UuaGVpZ2h0KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0ZXh0dXJlTmVlZHNQb3dlck9mVHdvKHRleHR1cmUpIHtcblx0XHRcdGlmIChpc1dlYkdMMikgcmV0dXJuIGZhbHNlO1xuXHRcdFx0cmV0dXJuIHRleHR1cmUud3JhcFMgIT09IENsYW1wVG9FZGdlV3JhcHBpbmcgfHwgdGV4dHVyZS53cmFwVCAhPT0gQ2xhbXBUb0VkZ2VXcmFwcGluZyB8fCB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTmVhcmVzdEZpbHRlciAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTGluZWFyRmlsdGVyO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyh0ZXh0dXJlLCBzdXBwb3J0c01pcHMpIHtcblx0XHRcdHJldHVybiB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBzdXBwb3J0c01pcHMgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IE5lYXJlc3RGaWx0ZXIgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IExpbmVhckZpbHRlcjtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZW5lcmF0ZU1pcG1hcCh0YXJnZXQpIHtcblx0XHRcdF9nbC5nZW5lcmF0ZU1pcG1hcCh0YXJnZXQpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEludGVybmFsRm9ybWF0KGludGVybmFsRm9ybWF0TmFtZSwgZ2xGb3JtYXQsIGdsVHlwZVxuXHRcdC8qLCBlbmNvZGluZyovXG5cdFx0KSB7XG5cdFx0XHRpZiAoaXNXZWJHTDIgPT09IGZhbHNlKSByZXR1cm4gZ2xGb3JtYXQ7XG5cblx0XHRcdGlmIChpbnRlcm5hbEZvcm1hdE5hbWUgIT09IG51bGwpIHtcblx0XHRcdFx0aWYgKF9nbFtpbnRlcm5hbEZvcm1hdE5hbWVdICE9PSB1bmRlZmluZWQpIHJldHVybiBfZ2xbaW50ZXJuYWxGb3JtYXROYW1lXTtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIHVzZSBub24tZXhpc3RpbmcgV2ViR0wgaW50ZXJuYWwgZm9ybWF0IFxcJycgKyBpbnRlcm5hbEZvcm1hdE5hbWUgKyAnXFwnJyk7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBpbnRlcm5hbEZvcm1hdCA9IGdsRm9ybWF0O1xuXG5cdFx0XHRpZiAoZ2xGb3JtYXQgPT09IF9nbC5SRUQpIHtcblx0XHRcdFx0aWYgKGdsVHlwZSA9PT0gX2dsLkZMT0FUKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SMzJGO1xuXHRcdFx0XHRpZiAoZ2xUeXBlID09PSBfZ2wuSEFMRl9GTE9BVCkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUjE2Rjtcblx0XHRcdFx0aWYgKGdsVHlwZSA9PT0gX2dsLlVOU0lHTkVEX0JZVEUpIGludGVybmFsRm9ybWF0ID0gX2dsLlI4O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZ2xGb3JtYXQgPT09IF9nbC5SR0IpIHtcblx0XHRcdFx0aWYgKGdsVHlwZSA9PT0gX2dsLkZMT0FUKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SR0IzMkY7XG5cdFx0XHRcdGlmIChnbFR5cGUgPT09IF9nbC5IQUxGX0ZMT0FUKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SR0IxNkY7XG5cdFx0XHRcdGlmIChnbFR5cGUgPT09IF9nbC5VTlNJR05FRF9CWVRFKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SR0I4O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZ2xGb3JtYXQgPT09IF9nbC5SR0JBKSB7XG5cdFx0XHRcdGlmIChnbFR5cGUgPT09IF9nbC5GTE9BVCkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUkdCQTMyRjtcblx0XHRcdFx0aWYgKGdsVHlwZSA9PT0gX2dsLkhBTEZfRkxPQVQpIGludGVybmFsRm9ybWF0ID0gX2dsLlJHQkExNkY7IC8vaWYgKCBnbFR5cGUgPT09IF9nbC5VTlNJR05FRF9CWVRFICkgaW50ZXJuYWxGb3JtYXQgPSAoIGVuY29kaW5nID09PSBzUkdCRW5jb2RpbmcgKSA/IF9nbC5TUkdCOF9BTFBIQTggOiBfZ2wuUkdCQTg7XG5cblx0XHRcdFx0aWYgKGdsVHlwZSA9PT0gX2dsLlVOU0lHTkVEX0JZVEUpIGludGVybmFsRm9ybWF0ID0gX2dsLlJHQkE4O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaW50ZXJuYWxGb3JtYXQgPT09IF9nbC5SMTZGIHx8IGludGVybmFsRm9ybWF0ID09PSBfZ2wuUjMyRiB8fCBpbnRlcm5hbEZvcm1hdCA9PT0gX2dsLlJHQkExNkYgfHwgaW50ZXJuYWxGb3JtYXQgPT09IF9nbC5SR0JBMzJGKSB7XG5cdFx0XHRcdGV4dGVuc2lvbnMuZ2V0KCdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0Jyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbnRlcm5hbEZvcm1hdDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRNaXBMZXZlbHModGV4dHVyZSwgaW1hZ2UsIHN1cHBvcnRzTWlwcykge1xuXHRcdFx0aWYgKHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyh0ZXh0dXJlLCBzdXBwb3J0c01pcHMpID09PSB0cnVlKSB7XG5cdFx0XHRcdC8vIGdlbmVyYXRlZCBtaXBtYXBzIHZpYSBnbC5nZW5lcmF0ZU1pcG1hcCgpXG5cdFx0XHRcdHJldHVybiBNYXRoLmxvZzIoTWF0aC5tYXgoaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCkpICsgMTtcblx0XHRcdH0gZWxzZSBpZiAodGV4dHVyZS5taXBtYXBzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Ly8gdXNlci1kZWZpbmVkIG1pcG1hcHNcblx0XHRcdFx0cmV0dXJuIHRleHR1cmUubWlwbWFwcy5sZW5ndGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyB0ZXh0dXJlIHdpdGhvdXQgbWlwbWFwcyAob25seSBiYXNlIGxldmVsKVxuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblx0XHR9IC8vIEZhbGxiYWNrIGZpbHRlcnMgZm9yIG5vbi1wb3dlci1vZi0yIHRleHR1cmVzXG5cblxuXHRcdGZ1bmN0aW9uIGZpbHRlckZhbGxiYWNrKGYpIHtcblx0XHRcdGlmIChmID09PSBOZWFyZXN0RmlsdGVyIHx8IGYgPT09IE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyIHx8IGYgPT09IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIpIHtcblx0XHRcdFx0cmV0dXJuIF9nbC5ORUFSRVNUO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gX2dsLkxJTkVBUjtcblx0XHR9IC8vXG5cblxuXHRcdGZ1bmN0aW9uIG9uVGV4dHVyZURpc3Bvc2UoZXZlbnQpIHtcblx0XHRcdGNvbnN0IHRleHR1cmUgPSBldmVudC50YXJnZXQ7XG5cdFx0XHR0ZXh0dXJlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlKTtcblx0XHRcdGRlYWxsb2NhdGVUZXh0dXJlKHRleHR1cmUpO1xuXG5cdFx0XHRpZiAodGV4dHVyZS5pc1ZpZGVvVGV4dHVyZSkge1xuXHRcdFx0XHRfdmlkZW9UZXh0dXJlcy5kZWxldGUodGV4dHVyZSk7XG5cdFx0XHR9XG5cblx0XHRcdGluZm8ubWVtb3J5LnRleHR1cmVzLS07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25SZW5kZXJUYXJnZXREaXNwb3NlKGV2ZW50KSB7XG5cdFx0XHRjb25zdCByZW5kZXJUYXJnZXQgPSBldmVudC50YXJnZXQ7XG5cdFx0XHRyZW5kZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSk7XG5cdFx0XHRkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG5cdFx0fSAvL1xuXG5cblx0XHRmdW5jdGlvbiBkZWFsbG9jYXRlVGV4dHVyZSh0ZXh0dXJlKSB7XG5cdFx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHRleHR1cmUpO1xuXHRcdFx0aWYgKHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuXHRcdFx0X2dsLmRlbGV0ZVRleHR1cmUodGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUpO1xuXG5cdFx0XHRwcm9wZXJ0aWVzLnJlbW92ZSh0ZXh0dXJlKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCkge1xuXHRcdFx0Y29uc3QgdGV4dHVyZSA9IHJlbmRlclRhcmdldC50ZXh0dXJlO1xuXHRcdFx0Y29uc3QgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldCk7XG5cdFx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHRleHR1cmUpO1xuXHRcdFx0aWYgKCFyZW5kZXJUYXJnZXQpIHJldHVybjtcblxuXHRcdFx0aWYgKHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0X2dsLmRlbGV0ZVRleHR1cmUodGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUpO1xuXG5cdFx0XHRcdGluZm8ubWVtb3J5LnRleHR1cmVzLS07XG5cdFx0XHR9XG5cblx0XHRcdGlmIChyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlKSB7XG5cdFx0XHRcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuZGlzcG9zZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocmVuZGVyVGFyZ2V0LmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0KSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG5cdFx0XHRcdFx0X2dsLmRlbGV0ZUZyYW1lYnVmZmVyKHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyW2ldKTtcblxuXHRcdFx0XHRcdGlmIChyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlcikgX2dsLmRlbGV0ZVJlbmRlcmJ1ZmZlcihyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlcltpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF9nbC5kZWxldGVGcmFtZWJ1ZmZlcihyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlcik7XG5cblx0XHRcdFx0aWYgKHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyKSBfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyKTtcblx0XHRcdFx0aWYgKHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyKSBfZ2wuZGVsZXRlRnJhbWVidWZmZXIocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIpO1xuXHRcdFx0XHRpZiAocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXIpIF9nbC5kZWxldGVSZW5kZXJidWZmZXIocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXIpO1xuXHRcdFx0XHRpZiAocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhSZW5kZXJidWZmZXIpIF9nbC5kZWxldGVSZW5kZXJidWZmZXIocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhSZW5kZXJidWZmZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocmVuZGVyVGFyZ2V0LmlzV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gdGV4dHVyZS5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgYXR0YWNobWVudFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCh0ZXh0dXJlW2ldKTtcblxuXHRcdFx0XHRcdGlmIChhdHRhY2htZW50UHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSkge1xuXHRcdFx0XHRcdFx0X2dsLmRlbGV0ZVRleHR1cmUoYXR0YWNobWVudFByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUpO1xuXG5cdFx0XHRcdFx0XHRpbmZvLm1lbW9yeS50ZXh0dXJlcy0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHByb3BlcnRpZXMucmVtb3ZlKHRleHR1cmVbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHByb3BlcnRpZXMucmVtb3ZlKHRleHR1cmUpO1xuXHRcdFx0cHJvcGVydGllcy5yZW1vdmUocmVuZGVyVGFyZ2V0KTtcblx0XHR9IC8vXG5cblxuXHRcdGxldCB0ZXh0dXJlVW5pdHMgPSAwO1xuXG5cdFx0ZnVuY3Rpb24gcmVzZXRUZXh0dXJlVW5pdHMoKSB7XG5cdFx0XHR0ZXh0dXJlVW5pdHMgPSAwO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFsbG9jYXRlVGV4dHVyZVVuaXQoKSB7XG5cdFx0XHRjb25zdCB0ZXh0dXJlVW5pdCA9IHRleHR1cmVVbml0cztcblxuXHRcdFx0aWYgKHRleHR1cmVVbml0ID49IG1heFRleHR1cmVzKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xUZXh0dXJlczogVHJ5aW5nIHRvIHVzZSAnICsgdGV4dHVyZVVuaXQgKyAnIHRleHR1cmUgdW5pdHMgd2hpbGUgdGhpcyBHUFUgc3VwcG9ydHMgb25seSAnICsgbWF4VGV4dHVyZXMpO1xuXHRcdFx0fVxuXG5cdFx0XHR0ZXh0dXJlVW5pdHMgKz0gMTtcblx0XHRcdHJldHVybiB0ZXh0dXJlVW5pdDtcblx0XHR9IC8vXG5cblxuXHRcdGZ1bmN0aW9uIHNldFRleHR1cmUyRCh0ZXh0dXJlLCBzbG90KSB7XG5cdFx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHRleHR1cmUpO1xuXHRcdFx0aWYgKHRleHR1cmUuaXNWaWRlb1RleHR1cmUpIHVwZGF0ZVZpZGVvVGV4dHVyZSh0ZXh0dXJlKTtcblxuXHRcdFx0aWYgKHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24pIHtcblx0XHRcdFx0Y29uc3QgaW1hZ2UgPSB0ZXh0dXJlLmltYWdlO1xuXG5cdFx0XHRcdGlmIChpbWFnZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBpbWFnZSBpcyB1bmRlZmluZWQnKTtcblx0XHRcdFx0fSBlbHNlIGlmIChpbWFnZS5jb21wbGV0ZSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgbWFya2VkIGZvciB1cGRhdGUgYnV0IGltYWdlIGlzIGluY29tcGxldGUnKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR1cGxvYWRUZXh0dXJlKHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZShfZ2wuVEVYVFVSRTAgKyBzbG90KTtcblx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0VGV4dHVyZTJEQXJyYXkodGV4dHVyZSwgc2xvdCkge1xuXHRcdFx0Y29uc3QgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCh0ZXh0dXJlKTtcblxuXHRcdFx0aWYgKHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24pIHtcblx0XHRcdFx0dXBsb2FkVGV4dHVyZSh0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSwgc2xvdCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZShfZ2wuVEVYVFVSRTAgKyBzbG90KTtcblx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKF9nbC5URVhUVVJFXzJEX0FSUkFZLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0VGV4dHVyZTNEKHRleHR1cmUsIHNsb3QpIHtcblx0XHRcdGNvbnN0IHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQodGV4dHVyZSk7XG5cblx0XHRcdGlmICh0ZXh0dXJlLnZlcnNpb24gPiAwICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiAhPT0gdGV4dHVyZS52ZXJzaW9uKSB7XG5cdFx0XHRcdHVwbG9hZFRleHR1cmUodGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoX2dsLlRFWFRVUkUwICsgc2xvdCk7XG5cdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZShfZ2wuVEVYVFVSRV8zRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldFRleHR1cmVDdWJlKHRleHR1cmUsIHNsb3QpIHtcblx0XHRcdGNvbnN0IHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQodGV4dHVyZSk7XG5cblx0XHRcdGlmICh0ZXh0dXJlLnZlcnNpb24gPiAwICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiAhPT0gdGV4dHVyZS52ZXJzaW9uKSB7XG5cdFx0XHRcdHVwbG9hZEN1YmVUZXh0dXJlKHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKF9nbC5URVhUVVJFMCArIHNsb3QpO1xuXHRcdFx0c3RhdGUuYmluZFRleHR1cmUoX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlKTtcblx0XHR9XG5cblx0XHRjb25zdCB3cmFwcGluZ1RvR0wgPSB7XG5cdFx0XHRbUmVwZWF0V3JhcHBpbmddOiBfZ2wuUkVQRUFULFxuXHRcdFx0W0NsYW1wVG9FZGdlV3JhcHBpbmddOiBfZ2wuQ0xBTVBfVE9fRURHRSxcblx0XHRcdFtNaXJyb3JlZFJlcGVhdFdyYXBwaW5nXTogX2dsLk1JUlJPUkVEX1JFUEVBVFxuXHRcdH07XG5cdFx0Y29uc3QgZmlsdGVyVG9HTCA9IHtcblx0XHRcdFtOZWFyZXN0RmlsdGVyXTogX2dsLk5FQVJFU1QsXG5cdFx0XHRbTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXJdOiBfZ2wuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCxcblx0XHRcdFtOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyXTogX2dsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUixcblx0XHRcdFtMaW5lYXJGaWx0ZXJdOiBfZ2wuTElORUFSLFxuXHRcdFx0W0xpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXJdOiBfZ2wuTElORUFSX01JUE1BUF9ORUFSRVNULFxuXHRcdFx0W0xpbmVhck1pcG1hcExpbmVhckZpbHRlcl06IF9nbC5MSU5FQVJfTUlQTUFQX0xJTkVBUlxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBzZXRUZXh0dXJlUGFyYW1ldGVycyh0ZXh0dXJlVHlwZSwgdGV4dHVyZSwgc3VwcG9ydHNNaXBzKSB7XG5cdFx0XHRpZiAoc3VwcG9ydHNNaXBzKSB7XG5cdFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1MsIHdyYXBwaW5nVG9HTFt0ZXh0dXJlLndyYXBTXSk7XG5cblx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmkodGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfVCwgd3JhcHBpbmdUb0dMW3RleHR1cmUud3JhcFRdKTtcblxuXHRcdFx0XHRpZiAodGV4dHVyZVR5cGUgPT09IF9nbC5URVhUVVJFXzNEIHx8IHRleHR1cmVUeXBlID09PSBfZ2wuVEVYVFVSRV8yRF9BUlJBWSkge1xuXHRcdFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1IsIHdyYXBwaW5nVG9HTFt0ZXh0dXJlLndyYXBSXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZmlsdGVyVG9HTFt0ZXh0dXJlLm1hZ0ZpbHRlcl0pO1xuXG5cdFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBmaWx0ZXJUb0dMW3RleHR1cmUubWluRmlsdGVyXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9TLCBfZ2wuQ0xBTVBfVE9fRURHRSk7XG5cblx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmkodGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfVCwgX2dsLkNMQU1QX1RPX0VER0UpO1xuXG5cdFx0XHRcdGlmICh0ZXh0dXJlVHlwZSA9PT0gX2dsLlRFWFRVUkVfM0QgfHwgdGV4dHVyZVR5cGUgPT09IF9nbC5URVhUVVJFXzJEX0FSUkFZKSB7XG5cdFx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmkodGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUiwgX2dsLkNMQU1QX1RPX0VER0UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRleHR1cmUud3JhcFMgIT09IENsYW1wVG9FZGdlV3JhcHBpbmcgfHwgdGV4dHVyZS53cmFwVCAhPT0gQ2xhbXBUb0VkZ2VXcmFwcGluZykge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBpcyBub3QgcG93ZXIgb2YgdHdvLiBUZXh0dXJlLndyYXBTIGFuZCBUZXh0dXJlLndyYXBUIHNob3VsZCBiZSBzZXQgdG8gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZy4nKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBmaWx0ZXJGYWxsYmFjayh0ZXh0dXJlLm1hZ0ZpbHRlcikpO1xuXG5cdFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBmaWx0ZXJGYWxsYmFjayh0ZXh0dXJlLm1pbkZpbHRlcikpO1xuXG5cdFx0XHRcdGlmICh0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTmVhcmVzdEZpbHRlciAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTGluZWFyRmlsdGVyKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGlzIG5vdCBwb3dlciBvZiB0d28uIFRleHR1cmUubWluRmlsdGVyIHNob3VsZCBiZSBzZXQgdG8gVEhSRUUuTmVhcmVzdEZpbHRlciBvciBUSFJFRS5MaW5lYXJGaWx0ZXIuJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGV4dGVuc2lvbnMuaGFzKCdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnKSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRjb25zdCBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCgnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyk7XG5cdFx0XHRcdGlmICh0ZXh0dXJlLnR5cGUgPT09IEZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmhhcygnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJykgPT09IGZhbHNlKSByZXR1cm47IC8vIHZlcmlmeSBleHRlbnNpb24gZm9yIFdlYkdMIDEgYW5kIFdlYkdMIDJcblxuXHRcdFx0XHRpZiAoaXNXZWJHTDIgPT09IGZhbHNlICYmIHRleHR1cmUudHlwZSA9PT0gSGFsZkZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmhhcygnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInKSA9PT0gZmFsc2UpIHJldHVybjsgLy8gdmVyaWZ5IGV4dGVuc2lvbiBmb3IgV2ViR0wgMSBvbmx5XG5cblx0XHRcdFx0aWYgKHRleHR1cmUuYW5pc290cm9weSA+IDEgfHwgcHJvcGVydGllcy5nZXQodGV4dHVyZSkuX19jdXJyZW50QW5pc290cm9weSkge1xuXHRcdFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJmKHRleHR1cmVUeXBlLCBleHRlbnNpb24uVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIE1hdGgubWluKHRleHR1cmUuYW5pc290cm9weSwgY2FwYWJpbGl0aWVzLmdldE1heEFuaXNvdHJvcHkoKSkpO1xuXG5cdFx0XHRcdFx0cHJvcGVydGllcy5nZXQodGV4dHVyZSkuX19jdXJyZW50QW5pc290cm9weSA9IHRleHR1cmUuYW5pc290cm9weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGluaXRUZXh0dXJlKHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlKSB7XG5cdFx0XHRpZiAodGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9IHRydWU7XG5cdFx0XHRcdHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UpO1xuXHRcdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cdFx0XHRcdGluZm8ubWVtb3J5LnRleHR1cmVzKys7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXBsb2FkVGV4dHVyZSh0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSwgc2xvdCkge1xuXHRcdFx0bGV0IHRleHR1cmVUeXBlID0gX2dsLlRFWFRVUkVfMkQ7XG5cdFx0XHRpZiAodGV4dHVyZS5pc0RhdGFUZXh0dXJlMkRBcnJheSkgdGV4dHVyZVR5cGUgPSBfZ2wuVEVYVFVSRV8yRF9BUlJBWTtcblx0XHRcdGlmICh0ZXh0dXJlLmlzRGF0YVRleHR1cmUzRCkgdGV4dHVyZVR5cGUgPSBfZ2wuVEVYVFVSRV8zRDtcblx0XHRcdGluaXRUZXh0dXJlKHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlKTtcblx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoX2dsLlRFWFRVUkUwICsgc2xvdCk7XG5cdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSh0ZXh0dXJlVHlwZSwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUpO1xuXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRleHR1cmUuZmxpcFkpO1xuXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoX2dsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGV4dHVyZS5wcmVtdWx0aXBseUFscGhhKTtcblxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKF9nbC5VTlBBQ0tfQUxJR05NRU5ULCB0ZXh0dXJlLnVucGFja0FsaWdubWVudCk7XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCwgX2dsLk5PTkUpO1xuXG5cdFx0XHRjb25zdCBuZWVkc1Bvd2VyT2ZUd28gPSB0ZXh0dXJlTmVlZHNQb3dlck9mVHdvKHRleHR1cmUpICYmIGlzUG93ZXJPZlR3byQxKHRleHR1cmUuaW1hZ2UpID09PSBmYWxzZTtcblx0XHRcdGNvbnN0IGltYWdlID0gcmVzaXplSW1hZ2UodGV4dHVyZS5pbWFnZSwgbmVlZHNQb3dlck9mVHdvLCBmYWxzZSwgbWF4VGV4dHVyZVNpemUpO1xuXHRcdFx0Y29uc3Qgc3VwcG9ydHNNaXBzID0gaXNQb3dlck9mVHdvJDEoaW1hZ2UpIHx8IGlzV2ViR0wyLFxuXHRcdFx0XHRcdFx0Z2xGb3JtYXQgPSB1dGlscy5jb252ZXJ0KHRleHR1cmUuZm9ybWF0KTtcblx0XHRcdGxldCBnbFR5cGUgPSB1dGlscy5jb252ZXJ0KHRleHR1cmUudHlwZSksXG5cdFx0XHRcdFx0Z2xJbnRlcm5hbEZvcm1hdCA9IGdldEludGVybmFsRm9ybWF0KHRleHR1cmUuaW50ZXJuYWxGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIHRleHR1cmUuZW5jb2RpbmcpO1xuXHRcdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnModGV4dHVyZVR5cGUsIHRleHR1cmUsIHN1cHBvcnRzTWlwcyk7XG5cdFx0XHRsZXQgbWlwbWFwO1xuXHRcdFx0Y29uc3QgbWlwbWFwcyA9IHRleHR1cmUubWlwbWFwcztcblxuXHRcdFx0aWYgKHRleHR1cmUuaXNEZXB0aFRleHR1cmUpIHtcblx0XHRcdFx0Ly8gcG9wdWxhdGUgZGVwdGggdGV4dHVyZSB3aXRoIGR1bW15IGRhdGFcblx0XHRcdFx0Z2xJbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSF9DT01QT05FTlQ7XG5cblx0XHRcdFx0aWYgKGlzV2ViR0wyKSB7XG5cdFx0XHRcdFx0aWYgKHRleHR1cmUudHlwZSA9PT0gRmxvYXRUeXBlKSB7XG5cdFx0XHRcdFx0XHRnbEludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDMyRjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRleHR1cmUudHlwZSA9PT0gVW5zaWduZWRJbnRUeXBlKSB7XG5cdFx0XHRcdFx0XHRnbEludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDI0O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGV4dHVyZS50eXBlID09PSBVbnNpZ25lZEludDI0OFR5cGUpIHtcblx0XHRcdFx0XHRcdGdsSW50ZXJuYWxGb3JtYXQgPSBfZ2wuREVQVEgyNF9TVEVOQ0lMODtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Z2xJbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSF9DT01QT05FTlQxNjsgLy8gV2ViR0wyIHJlcXVpcmVzIHNpemVkIGludGVybmFsZm9ybWF0IGZvciBnbFRleEltYWdlMkRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHRleHR1cmUudHlwZSA9PT0gRmxvYXRUeXBlKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdXZWJHTFJlbmRlcmVyOiBGbG9hdGluZyBwb2ludCBkZXB0aCB0ZXh0dXJlIHJlcXVpcmVzIFdlYkdMMi4nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gLy8gdmFsaWRhdGlvbiBjaGVja3MgZm9yIFdlYkdMIDFcblxuXG5cdFx0XHRcdGlmICh0ZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhGb3JtYXQgJiYgZ2xJbnRlcm5hbEZvcm1hdCA9PT0gX2dsLkRFUFRIX0NPTVBPTkVOVCkge1xuXHRcdFx0XHRcdC8vIFRoZSBlcnJvciBJTlZBTElEX09QRVJBVElPTiBpcyBnZW5lcmF0ZWQgYnkgdGV4SW1hZ2UyRCBpZiBmb3JtYXQgYW5kIGludGVybmFsZm9ybWF0IGFyZVxuXHRcdFx0XHRcdC8vIERFUFRIX0NPTVBPTkVOVCBhbmQgdHlwZSBpcyBub3QgVU5TSUdORURfU0hPUlQgb3IgVU5TSUdORURfSU5UXG5cdFx0XHRcdFx0Ly8gKGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L3dlYmdsL2V4dGVuc2lvbnMvV0VCR0xfZGVwdGhfdGV4dHVyZS8pXG5cdFx0XHRcdFx0aWYgKHRleHR1cmUudHlwZSAhPT0gVW5zaWduZWRTaG9ydFR5cGUgJiYgdGV4dHVyZS50eXBlICE9PSBVbnNpZ25lZEludFR5cGUpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogVXNlIFVuc2lnbmVkU2hvcnRUeXBlIG9yIFVuc2lnbmVkSW50VHlwZSBmb3IgRGVwdGhGb3JtYXQgRGVwdGhUZXh0dXJlLicpO1xuXHRcdFx0XHRcdFx0dGV4dHVyZS50eXBlID0gVW5zaWduZWRTaG9ydFR5cGU7XG5cdFx0XHRcdFx0XHRnbFR5cGUgPSB1dGlscy5jb252ZXJ0KHRleHR1cmUudHlwZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRleHR1cmUuZm9ybWF0ID09PSBEZXB0aFN0ZW5jaWxGb3JtYXQgJiYgZ2xJbnRlcm5hbEZvcm1hdCA9PT0gX2dsLkRFUFRIX0NPTVBPTkVOVCkge1xuXHRcdFx0XHRcdC8vIERlcHRoIHN0ZW5jaWwgdGV4dHVyZXMgbmVlZCB0aGUgREVQVEhfU1RFTkNJTCBpbnRlcm5hbCBmb3JtYXRcblx0XHRcdFx0XHQvLyAoaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvZXh0ZW5zaW9ucy9XRUJHTF9kZXB0aF90ZXh0dXJlLylcblx0XHRcdFx0XHRnbEludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX1NURU5DSUw7IC8vIFRoZSBlcnJvciBJTlZBTElEX09QRVJBVElPTiBpcyBnZW5lcmF0ZWQgYnkgdGV4SW1hZ2UyRCBpZiBmb3JtYXQgYW5kIGludGVybmFsZm9ybWF0IGFyZVxuXHRcdFx0XHRcdC8vIERFUFRIX1NURU5DSUwgYW5kIHR5cGUgaXMgbm90IFVOU0lHTkVEX0lOVF8yNF84X1dFQkdMLlxuXHRcdFx0XHRcdC8vIChodHRwczovL3d3dy5raHJvbm9zLm9yZy9yZWdpc3RyeS93ZWJnbC9leHRlbnNpb25zL1dFQkdMX2RlcHRoX3RleHR1cmUvKVxuXG5cdFx0XHRcdFx0aWYgKHRleHR1cmUudHlwZSAhPT0gVW5zaWduZWRJbnQyNDhUeXBlKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFVzZSBVbnNpZ25lZEludDI0OFR5cGUgZm9yIERlcHRoU3RlbmNpbEZvcm1hdCBEZXB0aFRleHR1cmUuJyk7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlLnR5cGUgPSBVbnNpZ25lZEludDI0OFR5cGU7XG5cdFx0XHRcdFx0XHRnbFR5cGUgPSB1dGlscy5jb252ZXJ0KHRleHR1cmUudHlwZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IC8vXG5cblxuXHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKF9nbC5URVhUVVJFXzJELCAwLCBnbEludGVybmFsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsKTtcblx0XHRcdH0gZWxzZSBpZiAodGV4dHVyZS5pc0RhdGFUZXh0dXJlKSB7XG5cdFx0XHRcdC8vIHVzZSBtYW51YWxseSBjcmVhdGVkIG1pcG1hcHMgaWYgYXZhaWxhYmxlXG5cdFx0XHRcdC8vIGlmIHRoZXJlIGFyZSBubyBtYW51YWwgbWlwbWFwc1xuXHRcdFx0XHQvLyBzZXQgMCBsZXZlbCBtaXBtYXAgYW5kIHRoZW4gdXNlIEdMIHRvIGdlbmVyYXRlIG90aGVyIG1pcG1hcCBsZXZlbHNcblx0XHRcdFx0aWYgKG1pcG1hcHMubGVuZ3RoID4gMCAmJiBzdXBwb3J0c01pcHMpIHtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbaV07XG5cdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKF9nbC5URVhUVVJFXzJELCBpLCBnbEludGVybmFsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoX2dsLlRFWFRVUkVfMkQsIDAsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHRleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSkge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzW2ldO1xuXG5cdFx0XHRcdFx0aWYgKHRleHR1cmUuZm9ybWF0ICE9PSBSR0JBRm9ybWF0ICYmIHRleHR1cmUuZm9ybWF0ICE9PSBSR0JGb3JtYXQpIHtcblx0XHRcdFx0XHRcdGlmIChnbEZvcm1hdCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRzdGF0ZS5jb21wcmVzc2VkVGV4SW1hZ2UyRChfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBtaXBtYXAuZGF0YSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gbG9hZCB1bnN1cHBvcnRlZCBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0IGluIC51cGxvYWRUZXh0dXJlKCknKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRChfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHRleHR1cmUuaXNEYXRhVGV4dHVyZTJEQXJyYXkpIHtcblx0XHRcdFx0c3RhdGUudGV4SW1hZ2UzRChfZ2wuVEVYVFVSRV8yRF9BUlJBWSwgMCwgZ2xJbnRlcm5hbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgaW1hZ2UuZGVwdGgsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEpO1xuXHRcdFx0fSBlbHNlIGlmICh0ZXh0dXJlLmlzRGF0YVRleHR1cmUzRCkge1xuXHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTNEKF9nbC5URVhUVVJFXzNELCAwLCBnbEludGVybmFsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCBpbWFnZS5kZXB0aCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UuZGF0YSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyByZWd1bGFyIFRleHR1cmUgKGltYWdlLCB2aWRlbywgY2FudmFzKVxuXHRcdFx0XHQvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxuXHRcdFx0XHQvLyBpZiB0aGVyZSBhcmUgbm8gbWFudWFsIG1pcG1hcHNcblx0XHRcdFx0Ly8gc2V0IDAgbGV2ZWwgbWlwbWFwIGFuZCB0aGVuIHVzZSBHTCB0byBnZW5lcmF0ZSBvdGhlciBtaXBtYXAgbGV2ZWxzXG5cdFx0XHRcdGNvbnN0IGxldmVscyA9IGdldE1pcExldmVscyh0ZXh0dXJlLCBpbWFnZSwgc3VwcG9ydHNNaXBzKTtcblx0XHRcdFx0Y29uc3QgdXNlVGV4U3RvcmFnZSA9IGlzV2ViR0wyICYmIHRleHR1cmUuaXNWaWRlb1RleHR1cmUgIT09IHRydWU7XG5cdFx0XHRcdGNvbnN0IGFsbG9jYXRlTWVtb3J5ID0gdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uID09PSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0aWYgKG1pcG1hcHMubGVuZ3RoID4gMCAmJiBzdXBwb3J0c01pcHMpIHtcblx0XHRcdFx0XHRpZiAodXNlVGV4U3RvcmFnZSAmJiBhbGxvY2F0ZU1lbW9yeSkge1xuXHRcdFx0XHRcdFx0c3RhdGUudGV4U3RvcmFnZTJEKF9nbC5URVhUVVJFXzJELCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcHNbMF0ud2lkdGgsIG1pcG1hcHNbMF0uaGVpZ2h0KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbaV07XG5cblx0XHRcdFx0XHRcdGlmICh1c2VUZXhTdG9yYWdlKSB7XG5cdFx0XHRcdFx0XHRcdHN0YXRlLnRleFN1YkltYWdlMkQoX2dsLlRFWFRVUkVfMkQsIGksIDAsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKF9nbC5URVhUVVJFXzJELCBpLCBnbEludGVybmFsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHVzZVRleFN0b3JhZ2UpIHtcblx0XHRcdFx0XHRcdGlmIChhbGxvY2F0ZU1lbW9yeSkge1xuXHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdG9yYWdlMkQoX2dsLlRFWFRVUkVfMkQsIGxldmVscywgZ2xJbnRlcm5hbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXRlLnRleFN1YkltYWdlMkQoX2dsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRChfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xJbnRlcm5hbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGV4dHVyZU5lZWRzR2VuZXJhdGVNaXBtYXBzKHRleHR1cmUsIHN1cHBvcnRzTWlwcykpIHtcblx0XHRcdFx0Z2VuZXJhdGVNaXBtYXAodGV4dHVyZVR5cGUpO1xuXHRcdFx0fVxuXG5cdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gPSB0ZXh0dXJlLnZlcnNpb247XG5cdFx0XHRpZiAodGV4dHVyZS5vblVwZGF0ZSkgdGV4dHVyZS5vblVwZGF0ZSh0ZXh0dXJlKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cGxvYWRDdWJlVGV4dHVyZSh0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSwgc2xvdCkge1xuXHRcdFx0aWYgKHRleHR1cmUuaW1hZ2UubGVuZ3RoICE9PSA2KSByZXR1cm47XG5cdFx0XHRpbml0VGV4dHVyZSh0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSk7XG5cdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKF9nbC5URVhUVVJFMCArIHNsb3QpO1xuXHRcdFx0c3RhdGUuYmluZFRleHR1cmUoX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlKTtcblxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZKTtcblxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKF9nbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSk7XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX0FMSUdOTUVOVCwgdGV4dHVyZS51bnBhY2tBbGlnbm1lbnQpO1xuXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoX2dsLlVOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wsIF9nbC5OT05FKTtcblxuXHRcdFx0Y29uc3QgaXNDb21wcmVzc2VkID0gdGV4dHVyZSAmJiAodGV4dHVyZS5pc0NvbXByZXNzZWRUZXh0dXJlIHx8IHRleHR1cmUuaW1hZ2VbMF0uaXNDb21wcmVzc2VkVGV4dHVyZSk7XG5cdFx0XHRjb25zdCBpc0RhdGFUZXh0dXJlID0gdGV4dHVyZS5pbWFnZVswXSAmJiB0ZXh0dXJlLmltYWdlWzBdLmlzRGF0YVRleHR1cmU7XG5cdFx0XHRjb25zdCBjdWJlSW1hZ2UgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcblx0XHRcdFx0aWYgKCFpc0NvbXByZXNzZWQgJiYgIWlzRGF0YVRleHR1cmUpIHtcblx0XHRcdFx0XHRjdWJlSW1hZ2VbaV0gPSByZXNpemVJbWFnZSh0ZXh0dXJlLmltYWdlW2ldLCBmYWxzZSwgdHJ1ZSwgbWF4Q3ViZW1hcFNpemUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN1YmVJbWFnZVtpXSA9IGlzRGF0YVRleHR1cmUgPyB0ZXh0dXJlLmltYWdlW2ldLmltYWdlIDogdGV4dHVyZS5pbWFnZVtpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBpbWFnZSA9IGN1YmVJbWFnZVswXSxcblx0XHRcdFx0XHRcdHN1cHBvcnRzTWlwcyA9IGlzUG93ZXJPZlR3byQxKGltYWdlKSB8fCBpc1dlYkdMMixcblx0XHRcdFx0XHRcdGdsRm9ybWF0ID0gdXRpbHMuY29udmVydCh0ZXh0dXJlLmZvcm1hdCksXG5cdFx0XHRcdFx0XHRnbFR5cGUgPSB1dGlscy5jb252ZXJ0KHRleHR1cmUudHlwZSksXG5cdFx0XHRcdFx0XHRnbEludGVybmFsRm9ybWF0ID0gZ2V0SW50ZXJuYWxGb3JtYXQodGV4dHVyZS5pbnRlcm5hbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgdGV4dHVyZS5lbmNvZGluZyk7XG5cdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyhfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZSwgc3VwcG9ydHNNaXBzKTtcblx0XHRcdGxldCBtaXBtYXBzO1xuXG5cdFx0XHRpZiAoaXNDb21wcmVzc2VkKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG5cdFx0XHRcdFx0bWlwbWFwcyA9IGN1YmVJbWFnZVtpXS5taXBtYXBzO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBtaXBtYXBzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBtaXBtYXAgPSBtaXBtYXBzW2pdO1xuXG5cdFx0XHRcdFx0XHRpZiAodGV4dHVyZS5mb3JtYXQgIT09IFJHQkFGb3JtYXQgJiYgdGV4dHVyZS5mb3JtYXQgIT09IFJHQkZvcm1hdCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoZ2xGb3JtYXQgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZS5jb21wcmVzc2VkVGV4SW1hZ2UyRChfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiwgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBtaXBtYXAuZGF0YSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAuc2V0VGV4dHVyZUN1YmUoKScpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqLCBnbEludGVybmFsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1pcG1hcHMgPSB0ZXh0dXJlLm1pcG1hcHM7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcblx0XHRcdFx0XHRpZiAoaXNEYXRhVGV4dHVyZSkge1xuXHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRChfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgZ2xJbnRlcm5hbEZvcm1hdCwgY3ViZUltYWdlW2ldLndpZHRoLCBjdWJlSW1hZ2VbaV0uaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbaV0uZGF0YSk7XG5cblx0XHRcdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgbWlwbWFwcy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBtaXBtYXAgPSBtaXBtYXBzW2pdO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBtaXBtYXBJbWFnZSA9IG1pcG1hcC5pbWFnZVtpXS5pbWFnZTtcblx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRChfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiArIDEsIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcEltYWdlLndpZHRoLCBtaXBtYXBJbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcEltYWdlLmRhdGEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEludGVybmFsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbaV0pO1xuXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IG1pcG1hcHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbWlwbWFwID0gbWlwbWFwc1tqXTtcblx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRChfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiArIDEsIGdsSW50ZXJuYWxGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5pbWFnZVtpXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHModGV4dHVyZSwgc3VwcG9ydHNNaXBzKSkge1xuXHRcdFx0XHQvLyBXZSBhc3N1bWUgaW1hZ2VzIGZvciBjdWJlIG1hcCBoYXZlIHRoZSBzYW1lIHNpemUuXG5cdFx0XHRcdGdlbmVyYXRlTWlwbWFwKF9nbC5URVhUVVJFX0NVQkVfTUFQKTtcblx0XHRcdH1cblxuXHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uID0gdGV4dHVyZS52ZXJzaW9uO1xuXHRcdFx0aWYgKHRleHR1cmUub25VcGRhdGUpIHRleHR1cmUub25VcGRhdGUodGV4dHVyZSk7XG5cdFx0fSAvLyBSZW5kZXIgdGFyZ2V0c1xuXHRcdC8vIFNldHVwIHN0b3JhZ2UgZm9yIHRhcmdldCB0ZXh0dXJlIGFuZCBiaW5kIGl0IHRvIGNvcnJlY3QgZnJhbWVidWZmZXJcblxuXG5cdFx0ZnVuY3Rpb24gc2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUoZnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgdGV4dHVyZSwgYXR0YWNobWVudCwgdGV4dHVyZVRhcmdldCkge1xuXHRcdFx0Y29uc3QgZ2xGb3JtYXQgPSB1dGlscy5jb252ZXJ0KHRleHR1cmUuZm9ybWF0KTtcblx0XHRcdGNvbnN0IGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQodGV4dHVyZS50eXBlKTtcblx0XHRcdGNvbnN0IGdsSW50ZXJuYWxGb3JtYXQgPSBnZXRJbnRlcm5hbEZvcm1hdCh0ZXh0dXJlLmludGVybmFsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCB0ZXh0dXJlLmVuY29kaW5nKTtcblx0XHRcdGNvbnN0IHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldChyZW5kZXJUYXJnZXQpO1xuXG5cdFx0XHRpZiAoIXJlbmRlclRhcmdldFByb3BlcnRpZXMuX19oYXNFeHRlcm5hbFRleHR1cmVzKSB7XG5cdFx0XHRcdGlmICh0ZXh0dXJlVGFyZ2V0ID09PSBfZ2wuVEVYVFVSRV8zRCB8fCB0ZXh0dXJlVGFyZ2V0ID09PSBfZ2wuVEVYVFVSRV8yRF9BUlJBWSkge1xuXHRcdFx0XHRcdHN0YXRlLnRleEltYWdlM0QodGV4dHVyZVRhcmdldCwgMCwgZ2xJbnRlcm5hbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0LCByZW5kZXJUYXJnZXQuZGVwdGgsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG51bGwpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQodGV4dHVyZVRhcmdldCwgMCwgZ2xJbnRlcm5hbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7XG5cblx0XHRcdGlmIChyZW5kZXJUYXJnZXQudXNlUmVuZGVyVG9UZXh0dXJlKSB7XG5cdFx0XHRcdE11bHRpc2FtcGxlZFJlbmRlclRvVGV4dHVyZUV4dGVuc2lvbi5mcmFtZWJ1ZmZlclRleHR1cmUyRE11bHRpc2FtcGxlRVhUKF9nbC5GUkFNRUJVRkZFUiwgYXR0YWNobWVudCwgdGV4dHVyZVRhcmdldCwgcHJvcGVydGllcy5nZXQodGV4dHVyZSkuX193ZWJnbFRleHR1cmUsIDAsIGdldFJlbmRlclRhcmdldFNhbXBsZXMocmVuZGVyVGFyZ2V0KSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoX2dsLkZSQU1FQlVGRkVSLCBhdHRhY2htZW50LCB0ZXh0dXJlVGFyZ2V0LCBwcm9wZXJ0aWVzLmdldCh0ZXh0dXJlKS5fX3dlYmdsVGV4dHVyZSwgMCk7XG5cdFx0XHR9XG5cblx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcihfZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXHRcdH0gLy8gU2V0dXAgc3RvcmFnZSBmb3IgaW50ZXJuYWwgZGVwdGgvc3RlbmNpbCBidWZmZXJzIGFuZCBiaW5kIHRvIGNvcnJlY3QgZnJhbWVidWZmZXJcblxuXG5cdFx0ZnVuY3Rpb24gc2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKHJlbmRlcmJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCBpc011bHRpc2FtcGxlKSB7XG5cdFx0XHRfZ2wuYmluZFJlbmRlcmJ1ZmZlcihfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIpO1xuXG5cdFx0XHRpZiAocmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmICFyZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlcikge1xuXHRcdFx0XHRsZXQgZ2xJbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSF9DT01QT05FTlQxNjtcblxuXHRcdFx0XHRpZiAoaXNNdWx0aXNhbXBsZSB8fCByZW5kZXJUYXJnZXQudXNlUmVuZGVyVG9UZXh0dXJlKSB7XG5cdFx0XHRcdFx0Y29uc3QgZGVwdGhUZXh0dXJlID0gcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZTtcblxuXHRcdFx0XHRcdGlmIChkZXB0aFRleHR1cmUgJiYgZGVwdGhUZXh0dXJlLmlzRGVwdGhUZXh0dXJlKSB7XG5cdFx0XHRcdFx0XHRpZiAoZGVwdGhUZXh0dXJlLnR5cGUgPT09IEZsb2F0VHlwZSkge1xuXHRcdFx0XHRcdFx0XHRnbEludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDMyRjtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoZGVwdGhUZXh0dXJlLnR5cGUgPT09IFVuc2lnbmVkSW50VHlwZSkge1xuXHRcdFx0XHRcdFx0XHRnbEludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDI0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IHNhbXBsZXMgPSBnZXRSZW5kZXJUYXJnZXRTYW1wbGVzKHJlbmRlclRhcmdldCk7XG5cblx0XHRcdFx0XHRpZiAocmVuZGVyVGFyZ2V0LnVzZVJlbmRlclRvVGV4dHVyZSkge1xuXHRcdFx0XHRcdFx0TXVsdGlzYW1wbGVkUmVuZGVyVG9UZXh0dXJlRXh0ZW5zaW9uLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZUVYVChfZ2wuUkVOREVSQlVGRkVSLCBzYW1wbGVzLCBnbEludGVybmFsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKF9nbC5SRU5ERVJCVUZGRVIsIHNhbXBsZXMsIGdsSW50ZXJuYWxGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKF9nbC5SRU5ERVJCVUZGRVIsIGdsSW50ZXJuYWxGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyKTtcblx0XHRcdH0gZWxzZSBpZiAocmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyKSB7XG5cdFx0XHRcdGNvbnN0IHNhbXBsZXMgPSBnZXRSZW5kZXJUYXJnZXRTYW1wbGVzKHJlbmRlclRhcmdldCk7XG5cblx0XHRcdFx0aWYgKGlzTXVsdGlzYW1wbGUgJiYgcmVuZGVyVGFyZ2V0LnVzZVJlbmRlcmJ1ZmZlcikge1xuXHRcdFx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoX2dsLlJFTkRFUkJVRkZFUiwgc2FtcGxlcywgX2dsLkRFUFRIMjRfU1RFTkNJTDgsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocmVuZGVyVGFyZ2V0LnVzZVJlbmRlclRvVGV4dHVyZSkge1xuXHRcdFx0XHRcdE11bHRpc2FtcGxlZFJlbmRlclRvVGV4dHVyZUV4dGVuc2lvbi5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGVFWFQoX2dsLlJFTkRFUkJVRkZFUiwgc2FtcGxlcywgX2dsLkRFUFRIMjRfU1RFTkNJTDgsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoX2dsLlJFTkRFUkJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUwsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gVXNlIHRoZSBmaXJzdCB0ZXh0dXJlIGZvciBNUlQgc28gZmFyXG5cdFx0XHRcdGNvbnN0IHRleHR1cmUgPSByZW5kZXJUYXJnZXQuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyA9PT0gdHJ1ZSA/IHJlbmRlclRhcmdldC50ZXh0dXJlWzBdIDogcmVuZGVyVGFyZ2V0LnRleHR1cmU7XG5cdFx0XHRcdGNvbnN0IGdsRm9ybWF0ID0gdXRpbHMuY29udmVydCh0ZXh0dXJlLmZvcm1hdCk7XG5cdFx0XHRcdGNvbnN0IGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQodGV4dHVyZS50eXBlKTtcblx0XHRcdFx0Y29uc3QgZ2xJbnRlcm5hbEZvcm1hdCA9IGdldEludGVybmFsRm9ybWF0KHRleHR1cmUuaW50ZXJuYWxGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIHRleHR1cmUuZW5jb2RpbmcpO1xuXHRcdFx0XHRjb25zdCBzYW1wbGVzID0gZ2V0UmVuZGVyVGFyZ2V0U2FtcGxlcyhyZW5kZXJUYXJnZXQpO1xuXG5cdFx0XHRcdGlmIChpc011bHRpc2FtcGxlICYmIHJlbmRlclRhcmdldC51c2VSZW5kZXJidWZmZXIpIHtcblx0XHRcdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKF9nbC5SRU5ERVJCVUZGRVIsIHNhbXBsZXMsIGdsSW50ZXJuYWxGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocmVuZGVyVGFyZ2V0LnVzZVJlbmRlclRvVGV4dHVyZSkge1xuXHRcdFx0XHRcdE11bHRpc2FtcGxlZFJlbmRlclRvVGV4dHVyZUV4dGVuc2lvbi5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGVFWFQoX2dsLlJFTkRFUkJVRkZFUiwgc2FtcGxlcywgZ2xJbnRlcm5hbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShfZ2wuUkVOREVSQlVGRkVSLCBnbEludGVybmFsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdF9nbC5iaW5kUmVuZGVyYnVmZmVyKF9nbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xuXHRcdH0gLy8gU2V0dXAgcmVzb3VyY2VzIGZvciBhIERlcHRoIFRleHR1cmUgZm9yIGEgRkJPIChuZWVkcyBhbiBleHRlbnNpb24pXG5cblxuXHRcdGZ1bmN0aW9uIHNldHVwRGVwdGhUZXh0dXJlKGZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQpIHtcblx0XHRcdGNvbnN0IGlzQ3ViZSA9IHJlbmRlclRhcmdldCAmJiByZW5kZXJUYXJnZXQuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQ7XG5cdFx0XHRpZiAoaXNDdWJlKSB0aHJvdyBuZXcgRXJyb3IoJ0RlcHRoIFRleHR1cmUgd2l0aCBjdWJlIHJlbmRlciB0YXJnZXRzIGlzIG5vdCBzdXBwb3J0ZWQnKTtcblx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcihfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTtcblxuXHRcdFx0aWYgKCEocmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSAmJiByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmlzRGVwdGhUZXh0dXJlKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3JlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBUSFJFRS5EZXB0aFRleHR1cmUnKTtcblx0XHRcdH0gLy8gdXBsb2FkIGFuIGVtcHR5IGRlcHRoIHRleHR1cmUgd2l0aCBmcmFtZWJ1ZmZlciBzaXplXG5cblxuXHRcdFx0aWYgKCFwcm9wZXJ0aWVzLmdldChyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlKS5fX3dlYmdsVGV4dHVyZSB8fCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmltYWdlLndpZHRoICE9PSByZW5kZXJUYXJnZXQud2lkdGggfHwgcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pbWFnZS5oZWlnaHQgIT09IHJlbmRlclRhcmdldC5oZWlnaHQpIHtcblx0XHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pbWFnZS53aWR0aCA9IHJlbmRlclRhcmdldC53aWR0aDtcblx0XHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pbWFnZS5oZWlnaHQgPSByZW5kZXJUYXJnZXQuaGVpZ2h0O1xuXHRcdFx0XHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0c2V0VGV4dHVyZTJEKHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUsIDApO1xuXG5cdFx0XHRjb25zdCB3ZWJnbERlcHRoVGV4dHVyZSA9IHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUpLl9fd2ViZ2xUZXh0dXJlO1xuXG5cdFx0XHRjb25zdCBzYW1wbGVzID0gZ2V0UmVuZGVyVGFyZ2V0U2FtcGxlcyhyZW5kZXJUYXJnZXQpO1xuXG5cdFx0XHRpZiAocmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5mb3JtYXQgPT09IERlcHRoRm9ybWF0KSB7XG5cdFx0XHRcdGlmIChyZW5kZXJUYXJnZXQudXNlUmVuZGVyVG9UZXh0dXJlKSB7XG5cdFx0XHRcdFx0TXVsdGlzYW1wbGVkUmVuZGVyVG9UZXh0dXJlRXh0ZW5zaW9uLmZyYW1lYnVmZmVyVGV4dHVyZTJETXVsdGlzYW1wbGVFWFQoX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlRFWFRVUkVfMkQsIHdlYmdsRGVwdGhUZXh0dXJlLCAwLCBzYW1wbGVzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlRFWFRVUkVfMkQsIHdlYmdsRGVwdGhUZXh0dXJlLCAwKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0KSB7XG5cdFx0XHRcdGlmIChyZW5kZXJUYXJnZXQudXNlUmVuZGVyVG9UZXh0dXJlKSB7XG5cdFx0XHRcdFx0TXVsdGlzYW1wbGVkUmVuZGVyVG9UZXh0dXJlRXh0ZW5zaW9uLmZyYW1lYnVmZmVyVGV4dHVyZTJETXVsdGlzYW1wbGVFWFQoX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBfZ2wuVEVYVFVSRV8yRCwgd2ViZ2xEZXB0aFRleHR1cmUsIDAsIHNhbXBsZXMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5URVhUVVJFXzJELCB3ZWJnbERlcHRoVGV4dHVyZSwgMCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5rbm93biBkZXB0aFRleHR1cmUgZm9ybWF0Jyk7XG5cdFx0XHR9XG5cdFx0fSAvLyBTZXR1cCBHTCByZXNvdXJjZXMgZm9yIGEgbm9uLXRleHR1cmUgZGVwdGggYnVmZmVyXG5cblxuXHRcdGZ1bmN0aW9uIHNldHVwRGVwdGhSZW5kZXJidWZmZXIocmVuZGVyVGFyZ2V0KSB7XG5cdFx0XHRjb25zdCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0KTtcblx0XHRcdGNvbnN0IGlzQ3ViZSA9IHJlbmRlclRhcmdldC5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCA9PT0gdHJ1ZTtcblxuXHRcdFx0aWYgKHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgJiYgIXJlbmRlclRhcmdldFByb3BlcnRpZXMuX19hdXRvQWxsb2NhdGVEZXB0aEJ1ZmZlcikge1xuXHRcdFx0XHRpZiAoaXNDdWJlKSB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldC5kZXB0aFRleHR1cmUgbm90IHN1cHBvcnRlZCBpbiBDdWJlIHJlbmRlciB0YXJnZXRzJyk7XG5cdFx0XHRcdHNldHVwRGVwdGhUZXh0dXJlKHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGlzQ3ViZSkge1xuXHRcdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyID0gW107XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuXHRcdFx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKF9nbC5GUkFNRUJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbaV0pO1xuXHRcdFx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXJbaV0gPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cdFx0XHRcdFx0XHRzZXR1cFJlbmRlckJ1ZmZlclN0b3JhZ2UocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXJbaV0sIHJlbmRlclRhcmdldCwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoX2dsLkZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlcik7XG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cdFx0XHRcdFx0c2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyLCByZW5kZXJUYXJnZXQsIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoX2dsLkZSQU1FQlVGRkVSLCBudWxsKTtcblx0XHR9IC8vIHJlYmluZCBmcmFtZWJ1ZmZlciB3aXRoIGV4dGVybmFsIHRleHR1cmVzXG5cblxuXHRcdGZ1bmN0aW9uIHJlYmluZFRleHR1cmVzKHJlbmRlclRhcmdldCwgY29sb3JUZXh0dXJlLCBkZXB0aFRleHR1cmUpIHtcblx0XHRcdGNvbnN0IHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldChyZW5kZXJUYXJnZXQpO1xuXG5cdFx0XHRpZiAoY29sb3JUZXh0dXJlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0c2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgcmVuZGVyVGFyZ2V0LnRleHR1cmUsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlRFWFRVUkVfMkQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZGVwdGhUZXh0dXJlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0c2V0dXBEZXB0aFJlbmRlcmJ1ZmZlcihyZW5kZXJUYXJnZXQpO1xuXHRcdFx0fVxuXHRcdH0gLy8gU2V0IHVwIEdMIHJlc291cmNlcyBmb3IgdGhlIHJlbmRlciB0YXJnZXRcblxuXG5cdFx0ZnVuY3Rpb24gc2V0dXBSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KSB7XG5cdFx0XHRjb25zdCB0ZXh0dXJlID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XG5cdFx0XHRjb25zdCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0KTtcblx0XHRcdGNvbnN0IHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQodGV4dHVyZSk7XG5cdFx0XHRyZW5kZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSk7XG5cblx0XHRcdGlmIChyZW5kZXJUYXJnZXQuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyAhPT0gdHJ1ZSkge1xuXHRcdFx0XHRpZiAodGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcblx0XHRcdFx0aW5mby5tZW1vcnkudGV4dHVyZXMrKztcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgaXNDdWJlID0gcmVuZGVyVGFyZ2V0LmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0ID09PSB0cnVlO1xuXHRcdFx0Y29uc3QgaXNNdWx0aXBsZVJlbmRlclRhcmdldHMgPSByZW5kZXJUYXJnZXQuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyA9PT0gdHJ1ZTtcblx0XHRcdGNvbnN0IGlzUmVuZGVyVGFyZ2V0M0QgPSB0ZXh0dXJlLmlzRGF0YVRleHR1cmUzRCB8fCB0ZXh0dXJlLmlzRGF0YVRleHR1cmUyREFycmF5O1xuXHRcdFx0Y29uc3Qgc3VwcG9ydHNNaXBzID0gaXNQb3dlck9mVHdvJDEocmVuZGVyVGFyZ2V0KSB8fCBpc1dlYkdMMjsgLy8gSGFuZGxlcyBXZWJHTDIgUkdCRm9ybWF0IGZhbGxiYWNrIC0gIzE4ODU4XG5cblx0XHRcdGlmIChpc1dlYkdMMiAmJiB0ZXh0dXJlLmZvcm1hdCA9PT0gUkdCRm9ybWF0ICYmICh0ZXh0dXJlLnR5cGUgPT09IEZsb2F0VHlwZSB8fCB0ZXh0dXJlLnR5cGUgPT09IEhhbGZGbG9hdFR5cGUpKSB7XG5cdFx0XHRcdHRleHR1cmUuZm9ybWF0ID0gUkdCQUZvcm1hdDtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBSZW5kZXJpbmcgdG8gdGV4dHVyZXMgd2l0aCBSR0IgZm9ybWF0IGlzIG5vdCBzdXBwb3J0ZWQuIFVzaW5nIFJHQkEgZm9ybWF0IGluc3RlYWQuJyk7XG5cdFx0XHR9IC8vIFNldHVwIGZyYW1lYnVmZmVyXG5cblxuXHRcdFx0aWYgKGlzQ3ViZSkge1xuXHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9IFtdO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbaV0gPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblxuXHRcdFx0XHRpZiAoaXNNdWx0aXBsZVJlbmRlclRhcmdldHMpIHtcblx0XHRcdFx0XHRpZiAoY2FwYWJpbGl0aWVzLmRyYXdCdWZmZXJzKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlcyA9IHJlbmRlclRhcmdldC50ZXh0dXJlO1xuXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSB0ZXh0dXJlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGF0dGFjaG1lbnRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQodGV4dHVyZXNbaV0pO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChhdHRhY2htZW50UHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0YXR0YWNobWVudFByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXHRcdFx0XHRcdFx0XHRcdGluZm8ubWVtb3J5LnRleHR1cmVzKys7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyBjYW4gb25seSBiZSB1c2VkIHdpdGggV2ViR0wyIG9yIFdFQkdMX2RyYXdfYnVmZmVycyBleHRlbnNpb24uJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHJlbmRlclRhcmdldC51c2VSZW5kZXJidWZmZXIpIHtcblx0XHRcdFx0XHRpZiAoaXNXZWJHTDIpIHtcblx0XHRcdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cdFx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlciA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblxuXHRcdFx0XHRcdFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXIpO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBnbEZvcm1hdCA9IHV0aWxzLmNvbnZlcnQodGV4dHVyZS5mb3JtYXQpO1xuXHRcdFx0XHRcdFx0Y29uc3QgZ2xUeXBlID0gdXRpbHMuY29udmVydCh0ZXh0dXJlLnR5cGUpO1xuXHRcdFx0XHRcdFx0Y29uc3QgZ2xJbnRlcm5hbEZvcm1hdCA9IGdldEludGVybmFsRm9ybWF0KHRleHR1cmUuaW50ZXJuYWxGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIHRleHR1cmUuZW5jb2RpbmcpO1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2FtcGxlcyA9IGdldFJlbmRlclRhcmdldFNhbXBsZXMocmVuZGVyVGFyZ2V0KTtcblxuXHRcdFx0XHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZShfZ2wuUkVOREVSQlVGRkVSLCBzYW1wbGVzLCBnbEludGVybmFsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQpO1xuXG5cdFx0XHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoX2dsLkZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlcik7XG5cblx0XHRcdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihfZ2wuRlJBTUVCVUZGRVIsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXIpO1xuXG5cdFx0XHRcdFx0XHRfZ2wuYmluZFJlbmRlcmJ1ZmZlcihfZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcblxuXHRcdFx0XHRcdFx0aWYgKHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlcikge1xuXHRcdFx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aFJlbmRlcmJ1ZmZlciA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblx0XHRcdFx0XHRcdFx0c2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoUmVuZGVyYnVmZmVyLCByZW5kZXJUYXJnZXQsIHRydWUpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoX2dsLkZSQU1FQlVGRkVSLCBudWxsKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBXZWJHTE11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0IGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBXZWJHTDIuJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IC8vIFNldHVwIGNvbG9yIGJ1ZmZlclxuXG5cblx0XHRcdGlmIChpc0N1YmUpIHtcblx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlKTtcblx0XHRcdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUsIHN1cHBvcnRzTWlwcyk7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcblx0XHRcdFx0XHRzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZShyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlcltpXSwgcmVuZGVyVGFyZ2V0LCB0ZXh0dXJlLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHModGV4dHVyZSwgc3VwcG9ydHNNaXBzKSkge1xuXHRcdFx0XHRcdGdlbmVyYXRlTWlwbWFwKF9nbC5URVhUVVJFX0NVQkVfTUFQKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN0YXRlLnVuYmluZFRleHR1cmUoKTtcblx0XHRcdH0gZWxzZSBpZiAoaXNNdWx0aXBsZVJlbmRlclRhcmdldHMpIHtcblx0XHRcdFx0Y29uc3QgdGV4dHVyZXMgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSB0ZXh0dXJlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgYXR0YWNobWVudCA9IHRleHR1cmVzW2ldO1xuXHRcdFx0XHRcdGNvbnN0IGF0dGFjaG1lbnRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoYXR0YWNobWVudCk7XG5cdFx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoX2dsLlRFWFRVUkVfMkQsIGF0dGFjaG1lbnRQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlKTtcblx0XHRcdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyhfZ2wuVEVYVFVSRV8yRCwgYXR0YWNobWVudCwgc3VwcG9ydHNNaXBzKTtcblx0XHRcdFx0XHRzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZShyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCBhdHRhY2htZW50LCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpLCBfZ2wuVEVYVFVSRV8yRCk7XG5cblx0XHRcdFx0XHRpZiAodGV4dHVyZU5lZWRzR2VuZXJhdGVNaXBtYXBzKGF0dGFjaG1lbnQsIHN1cHBvcnRzTWlwcykpIHtcblx0XHRcdFx0XHRcdGdlbmVyYXRlTWlwbWFwKF9nbC5URVhUVVJFXzJEKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzdGF0ZS51bmJpbmRUZXh0dXJlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsZXQgZ2xUZXh0dXJlVHlwZSA9IF9nbC5URVhUVVJFXzJEO1xuXG5cdFx0XHRcdGlmIChpc1JlbmRlclRhcmdldDNEKSB7XG5cdFx0XHRcdFx0Ly8gUmVuZGVyIHRhcmdldHMgY29udGFpbmluZyBsYXllcnMsIGkuZTogVGV4dHVyZSAzRCBhbmQgMmQgYXJyYXlzXG5cdFx0XHRcdFx0aWYgKGlzV2ViR0wyKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBpc1RleHR1cmUzRCA9IHRleHR1cmUuaXNEYXRhVGV4dHVyZTNEO1xuXHRcdFx0XHRcdFx0Z2xUZXh0dXJlVHlwZSA9IGlzVGV4dHVyZTNEID8gX2dsLlRFWFRVUkVfM0QgOiBfZ2wuVEVYVFVSRV8yRF9BUlJBWTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5EYXRhVGV4dHVyZTNEIGFuZCBUSFJFRS5EYXRhVGV4dHVyZTJEQXJyYXkgb25seSBzdXBwb3J0ZWQgd2l0aCBXZWJHTDIuJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoZ2xUZXh0dXJlVHlwZSwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUpO1xuXHRcdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyhnbFRleHR1cmVUeXBlLCB0ZXh0dXJlLCBzdXBwb3J0c01pcHMpO1xuXHRcdFx0XHRzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZShyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCB0ZXh0dXJlLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsVGV4dHVyZVR5cGUpO1xuXG5cdFx0XHRcdGlmICh0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHModGV4dHVyZSwgc3VwcG9ydHNNaXBzKSkge1xuXHRcdFx0XHRcdGdlbmVyYXRlTWlwbWFwKGdsVGV4dHVyZVR5cGUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3RhdGUudW5iaW5kVGV4dHVyZSgpO1xuXHRcdFx0fSAvLyBTZXR1cCBkZXB0aCBhbmQgc3RlbmNpbCBidWZmZXJzXG5cblxuXHRcdFx0aWYgKHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlcikge1xuXHRcdFx0XHRzZXR1cERlcHRoUmVuZGVyYnVmZmVyKHJlbmRlclRhcmdldCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwKHJlbmRlclRhcmdldCkge1xuXHRcdFx0Y29uc3Qgc3VwcG9ydHNNaXBzID0gaXNQb3dlck9mVHdvJDEocmVuZGVyVGFyZ2V0KSB8fCBpc1dlYkdMMjtcblx0XHRcdGNvbnN0IHRleHR1cmVzID0gcmVuZGVyVGFyZ2V0LmlzV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMgPT09IHRydWUgPyByZW5kZXJUYXJnZXQudGV4dHVyZSA6IFtyZW5kZXJUYXJnZXQudGV4dHVyZV07XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IHRleHR1cmVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgdGV4dHVyZSA9IHRleHR1cmVzW2ldO1xuXG5cdFx0XHRcdGlmICh0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHModGV4dHVyZSwgc3VwcG9ydHNNaXBzKSkge1xuXHRcdFx0XHRcdGNvbnN0IHRhcmdldCA9IHJlbmRlclRhcmdldC5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCA/IF9nbC5URVhUVVJFX0NVQkVfTUFQIDogX2dsLlRFWFRVUkVfMkQ7XG5cblx0XHRcdFx0XHRjb25zdCB3ZWJnbFRleHR1cmUgPSBwcm9wZXJ0aWVzLmdldCh0ZXh0dXJlKS5fX3dlYmdsVGV4dHVyZTtcblxuXHRcdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKHRhcmdldCwgd2ViZ2xUZXh0dXJlKTtcblx0XHRcdFx0XHRnZW5lcmF0ZU1pcG1hcCh0YXJnZXQpO1xuXHRcdFx0XHRcdHN0YXRlLnVuYmluZFRleHR1cmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZU11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCkge1xuXHRcdFx0aWYgKHJlbmRlclRhcmdldC51c2VSZW5kZXJidWZmZXIpIHtcblx0XHRcdFx0aWYgKGlzV2ViR0wyKSB7XG5cdFx0XHRcdFx0Y29uc3Qgd2lkdGggPSByZW5kZXJUYXJnZXQud2lkdGg7XG5cdFx0XHRcdFx0Y29uc3QgaGVpZ2h0ID0gcmVuZGVyVGFyZ2V0LmhlaWdodDtcblx0XHRcdFx0XHRsZXQgbWFzayA9IF9nbC5DT0xPUl9CVUZGRVJfQklUO1xuXHRcdFx0XHRcdGNvbnN0IGludmFsaWRhdGlvbkFycmF5ID0gW19nbC5DT0xPUl9BVFRBQ0hNRU5UMF07XG5cdFx0XHRcdFx0Y29uc3QgZGVwdGhTdHlsZSA9IHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyID8gX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCA6IF9nbC5ERVBUSF9BVFRBQ0hNRU5UO1xuXG5cdFx0XHRcdFx0aWYgKHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlcikge1xuXHRcdFx0XHRcdFx0aW52YWxpZGF0aW9uQXJyYXkucHVzaChkZXB0aFN0eWxlKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIXJlbmRlclRhcmdldC5pZ25vcmVEZXB0aEZvck11bHRpc2FtcGxlQ29weSkge1xuXHRcdFx0XHRcdFx0aWYgKHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlcikgbWFzayB8PSBfZ2wuREVQVEhfQlVGRkVSX0JJVDtcblx0XHRcdFx0XHRcdGlmIChyZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlcikgbWFzayB8PSBfZ2wuU1RFTkNJTF9CVUZGRVJfQklUO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldChyZW5kZXJUYXJnZXQpO1xuXHRcdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcihfZ2wuUkVBRF9GUkFNRUJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIpO1xuXHRcdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcihfZ2wuRFJBV19GUkFNRUJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIpO1xuXG5cdFx0XHRcdFx0aWYgKHJlbmRlclRhcmdldC5pZ25vcmVEZXB0aEZvck11bHRpc2FtcGxlQ29weSkge1xuXHRcdFx0XHRcdFx0X2dsLmludmFsaWRhdGVGcmFtZWJ1ZmZlcihfZ2wuUkVBRF9GUkFNRUJVRkZFUiwgW2RlcHRoU3R5bGVdKTtcblxuXHRcdFx0XHRcdFx0X2dsLmludmFsaWRhdGVGcmFtZWJ1ZmZlcihfZ2wuRFJBV19GUkFNRUJVRkZFUiwgW2RlcHRoU3R5bGVdKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRfZ2wuYmxpdEZyYW1lYnVmZmVyKDAsIDAsIHdpZHRoLCBoZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIG1hc2ssIF9nbC5ORUFSRVNUKTtcblxuXHRcdFx0XHRcdF9nbC5pbnZhbGlkYXRlRnJhbWVidWZmZXIoX2dsLlJFQURfRlJBTUVCVUZGRVIsIGludmFsaWRhdGlvbkFycmF5KTtcblxuXHRcdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcihfZ2wuUkVBRF9GUkFNRUJVRkZFUiwgbnVsbCk7XG5cdFx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKF9nbC5EUkFXX0ZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlcik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBXZWJHTE11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0IGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBXZWJHTDIuJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRSZW5kZXJUYXJnZXRTYW1wbGVzKHJlbmRlclRhcmdldCkge1xuXHRcdFx0cmV0dXJuIGlzV2ViR0wyICYmIChyZW5kZXJUYXJnZXQudXNlUmVuZGVyYnVmZmVyIHx8IHJlbmRlclRhcmdldC51c2VSZW5kZXJUb1RleHR1cmUpID8gTWF0aC5taW4obWF4U2FtcGxlcywgcmVuZGVyVGFyZ2V0LnNhbXBsZXMpIDogMDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cGRhdGVWaWRlb1RleHR1cmUodGV4dHVyZSkge1xuXHRcdFx0Y29uc3QgZnJhbWUgPSBpbmZvLnJlbmRlci5mcmFtZTsgLy8gQ2hlY2sgdGhlIGxhc3QgZnJhbWUgd2UgdXBkYXRlZCB0aGUgVmlkZW9UZXh0dXJlXG5cblx0XHRcdGlmIChfdmlkZW9UZXh0dXJlcy5nZXQodGV4dHVyZSkgIT09IGZyYW1lKSB7XG5cdFx0XHRcdF92aWRlb1RleHR1cmVzLnNldCh0ZXh0dXJlLCBmcmFtZSk7XG5cblx0XHRcdFx0dGV4dHVyZS51cGRhdGUoKTtcblx0XHRcdH1cblx0XHR9IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cblxuXHRcdGxldCB3YXJuZWRUZXh0dXJlMkQgPSBmYWxzZTtcblx0XHRsZXQgd2FybmVkVGV4dHVyZUN1YmUgPSBmYWxzZTtcblxuXHRcdGZ1bmN0aW9uIHNhZmVTZXRUZXh0dXJlMkQodGV4dHVyZSwgc2xvdCkge1xuXHRcdFx0aWYgKHRleHR1cmUgJiYgdGV4dHVyZS5pc1dlYkdMUmVuZGVyVGFyZ2V0KSB7XG5cdFx0XHRcdGlmICh3YXJuZWRUZXh0dXJlMkQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFRleHR1cmVzLnNhZmVTZXRUZXh0dXJlMkQ6IGRvblxcJ3QgdXNlIHJlbmRlciB0YXJnZXRzIGFzIHRleHR1cmVzLiBVc2UgdGhlaXIgLnRleHR1cmUgcHJvcGVydHkgaW5zdGVhZC4nKTtcblx0XHRcdFx0XHR3YXJuZWRUZXh0dXJlMkQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGV4dHVyZSA9IHRleHR1cmUudGV4dHVyZTtcblx0XHRcdH1cblxuXHRcdFx0c2V0VGV4dHVyZTJEKHRleHR1cmUsIHNsb3QpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNhZmVTZXRUZXh0dXJlQ3ViZSh0ZXh0dXJlLCBzbG90KSB7XG5cdFx0XHRpZiAodGV4dHVyZSAmJiB0ZXh0dXJlLmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0KSB7XG5cdFx0XHRcdGlmICh3YXJuZWRUZXh0dXJlQ3ViZSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMVGV4dHVyZXMuc2FmZVNldFRleHR1cmVDdWJlOiBkb25cXCd0IHVzZSBjdWJlIHJlbmRlciB0YXJnZXRzIGFzIHRleHR1cmVzLiBVc2UgdGhlaXIgLnRleHR1cmUgcHJvcGVydHkgaW5zdGVhZC4nKTtcblx0XHRcdFx0XHR3YXJuZWRUZXh0dXJlQ3ViZSA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0ZXh0dXJlID0gdGV4dHVyZS50ZXh0dXJlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZXRUZXh0dXJlQ3ViZSh0ZXh0dXJlLCBzbG90KTtcblx0XHR9IC8vXG5cblxuXHRcdHRoaXMuYWxsb2NhdGVUZXh0dXJlVW5pdCA9IGFsbG9jYXRlVGV4dHVyZVVuaXQ7XG5cdFx0dGhpcy5yZXNldFRleHR1cmVVbml0cyA9IHJlc2V0VGV4dHVyZVVuaXRzO1xuXHRcdHRoaXMuc2V0VGV4dHVyZTJEID0gc2V0VGV4dHVyZTJEO1xuXHRcdHRoaXMuc2V0VGV4dHVyZTJEQXJyYXkgPSBzZXRUZXh0dXJlMkRBcnJheTtcblx0XHR0aGlzLnNldFRleHR1cmUzRCA9IHNldFRleHR1cmUzRDtcblx0XHR0aGlzLnNldFRleHR1cmVDdWJlID0gc2V0VGV4dHVyZUN1YmU7XG5cdFx0dGhpcy5yZWJpbmRUZXh0dXJlcyA9IHJlYmluZFRleHR1cmVzO1xuXHRcdHRoaXMuc2V0dXBSZW5kZXJUYXJnZXQgPSBzZXR1cFJlbmRlclRhcmdldDtcblx0XHR0aGlzLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCA9IHVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcDtcblx0XHR0aGlzLnVwZGF0ZU11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0ID0gdXBkYXRlTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQ7XG5cdFx0dGhpcy5zZXR1cERlcHRoUmVuZGVyYnVmZmVyID0gc2V0dXBEZXB0aFJlbmRlcmJ1ZmZlcjtcblx0XHR0aGlzLnNldHVwRnJhbWVCdWZmZXJUZXh0dXJlID0gc2V0dXBGcmFtZUJ1ZmZlclRleHR1cmU7XG5cdFx0dGhpcy5zYWZlU2V0VGV4dHVyZTJEID0gc2FmZVNldFRleHR1cmUyRDtcblx0XHR0aGlzLnNhZmVTZXRUZXh0dXJlQ3ViZSA9IHNhZmVTZXRUZXh0dXJlQ3ViZTtcblx0fVxuXG5cdGZ1bmN0aW9uIFdlYkdMVXRpbHMoZ2wsIGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcykge1xuXHRcdGNvbnN0IGlzV2ViR0wyID0gY2FwYWJpbGl0aWVzLmlzV2ViR0wyO1xuXG5cdFx0ZnVuY3Rpb24gY29udmVydChwKSB7XG5cdFx0XHRsZXQgZXh0ZW5zaW9uO1xuXHRcdFx0aWYgKHAgPT09IFVuc2lnbmVkQnl0ZVR5cGUpIHJldHVybiBnbC5VTlNJR05FRF9CWVRFO1xuXHRcdFx0aWYgKHAgPT09IFVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSkgcmV0dXJuIGdsLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQ7XG5cdFx0XHRpZiAocCA9PT0gVW5zaWduZWRTaG9ydDU1NTFUeXBlKSByZXR1cm4gZ2wuVU5TSUdORURfU0hPUlRfNV81XzVfMTtcblx0XHRcdGlmIChwID09PSBVbnNpZ25lZFNob3J0NTY1VHlwZSkgcmV0dXJuIGdsLlVOU0lHTkVEX1NIT1JUXzVfNl81O1xuXHRcdFx0aWYgKHAgPT09IEJ5dGVUeXBlKSByZXR1cm4gZ2wuQllURTtcblx0XHRcdGlmIChwID09PSBTaG9ydFR5cGUpIHJldHVybiBnbC5TSE9SVDtcblx0XHRcdGlmIChwID09PSBVbnNpZ25lZFNob3J0VHlwZSkgcmV0dXJuIGdsLlVOU0lHTkVEX1NIT1JUO1xuXHRcdFx0aWYgKHAgPT09IEludFR5cGUpIHJldHVybiBnbC5JTlQ7XG5cdFx0XHRpZiAocCA9PT0gVW5zaWduZWRJbnRUeXBlKSByZXR1cm4gZ2wuVU5TSUdORURfSU5UO1xuXHRcdFx0aWYgKHAgPT09IEZsb2F0VHlwZSkgcmV0dXJuIGdsLkZMT0FUO1xuXG5cdFx0XHRpZiAocCA9PT0gSGFsZkZsb2F0VHlwZSkge1xuXHRcdFx0XHRpZiAoaXNXZWJHTDIpIHJldHVybiBnbC5IQUxGX0ZMT0FUO1xuXHRcdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCgnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcpO1xuXG5cdFx0XHRcdGlmIChleHRlbnNpb24gIT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gZXh0ZW5zaW9uLkhBTEZfRkxPQVRfT0VTO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChwID09PSBBbHBoYUZvcm1hdCkgcmV0dXJuIGdsLkFMUEhBO1xuXHRcdFx0aWYgKHAgPT09IFJHQkZvcm1hdCkgcmV0dXJuIGdsLlJHQjtcblx0XHRcdGlmIChwID09PSBSR0JBRm9ybWF0KSByZXR1cm4gZ2wuUkdCQTtcblx0XHRcdGlmIChwID09PSBMdW1pbmFuY2VGb3JtYXQpIHJldHVybiBnbC5MVU1JTkFOQ0U7XG5cdFx0XHRpZiAocCA9PT0gTHVtaW5hbmNlQWxwaGFGb3JtYXQpIHJldHVybiBnbC5MVU1JTkFOQ0VfQUxQSEE7XG5cdFx0XHRpZiAocCA9PT0gRGVwdGhGb3JtYXQpIHJldHVybiBnbC5ERVBUSF9DT01QT05FTlQ7XG5cdFx0XHRpZiAocCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0KSByZXR1cm4gZ2wuREVQVEhfU1RFTkNJTDtcblx0XHRcdGlmIChwID09PSBSZWRGb3JtYXQpIHJldHVybiBnbC5SRUQ7IC8vIFdlYkdMMiBmb3JtYXRzLlxuXG5cdFx0XHRpZiAocCA9PT0gUmVkSW50ZWdlckZvcm1hdCkgcmV0dXJuIGdsLlJFRF9JTlRFR0VSO1xuXHRcdFx0aWYgKHAgPT09IFJHRm9ybWF0KSByZXR1cm4gZ2wuUkc7XG5cdFx0XHRpZiAocCA9PT0gUkdJbnRlZ2VyRm9ybWF0KSByZXR1cm4gZ2wuUkdfSU5URUdFUjtcblx0XHRcdGlmIChwID09PSBSR0JJbnRlZ2VyRm9ybWF0KSByZXR1cm4gZ2wuUkdCX0lOVEVHRVI7XG5cdFx0XHRpZiAocCA9PT0gUkdCQUludGVnZXJGb3JtYXQpIHJldHVybiBnbC5SR0JBX0lOVEVHRVI7XG5cblx0XHRcdGlmIChwID09PSBSR0JfUzNUQ19EWFQxX0Zvcm1hdCB8fCBwID09PSBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9TM1RDX0RYVDNfRm9ybWF0IHx8IHAgPT09IFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCkge1xuXHRcdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCgnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnKTtcblxuXHRcdFx0XHRpZiAoZXh0ZW5zaW9uICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHAgPT09IFJHQl9TM1RDX0RYVDFfRm9ybWF0KSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFQ7XG5cdFx0XHRcdFx0aWYgKHAgPT09IFJHQkFfUzNUQ19EWFQxX0Zvcm1hdCkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVDtcblx0XHRcdFx0XHRpZiAocCA9PT0gUkdCQV9TM1RDX0RYVDNfRm9ybWF0KSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUO1xuXHRcdFx0XHRcdGlmIChwID09PSBSR0JBX1MzVENfRFhUNV9Gb3JtYXQpIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHAgPT09IFJHQl9QVlJUQ180QlBQVjFfRm9ybWF0IHx8IHAgPT09IFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0IHx8IHAgPT09IFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCB8fCBwID09PSBSR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQpIHtcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycpO1xuXG5cdFx0XHRcdGlmIChleHRlbnNpb24gIT09IG51bGwpIHtcblx0XHRcdFx0XHRpZiAocCA9PT0gUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQpIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNRztcblx0XHRcdFx0XHRpZiAocCA9PT0gUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQpIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNRztcblx0XHRcdFx0XHRpZiAocCA9PT0gUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0KSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HO1xuXHRcdFx0XHRcdGlmIChwID09PSBSR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQpIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHAgPT09IFJHQl9FVEMxX0Zvcm1hdCkge1xuXHRcdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCgnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnKTtcblxuXHRcdFx0XHRpZiAoZXh0ZW5zaW9uICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9FVEMxX1dFQkdMO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChwID09PSBSR0JfRVRDMl9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9FVEMyX0VBQ19Gb3JtYXQpIHtcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMnKTtcblxuXHRcdFx0XHRpZiAoZXh0ZW5zaW9uICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHAgPT09IFJHQl9FVEMyX0Zvcm1hdCkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQjhfRVRDMjtcblx0XHRcdFx0XHRpZiAocCA9PT0gUkdCQV9FVEMyX0VBQ19Gb3JtYXQpIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBOF9FVEMyX0VBQztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAocCA9PT0gUkdCQV9BU1RDXzR4NF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzV4NF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzV4NV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzZ4NV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzZ4Nl9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzh4NV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzh4Nl9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzh4OF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzEweDVfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ18xMHg2X0Zvcm1hdCB8fCBwID09PSBSR0JBX0FTVENfMTB4OF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzEweDEwX0Zvcm1hdCB8fCBwID09PSBSR0JBX0FTVENfMTJ4MTBfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ18xMngxMl9Gb3JtYXQgfHwgcCA9PT0gU1JHQjhfQUxQSEE4X0FTVENfNHg0X0Zvcm1hdCB8fCBwID09PSBTUkdCOF9BTFBIQThfQVNUQ181eDRfRm9ybWF0IHx8IHAgPT09IFNSR0I4X0FMUEhBOF9BU1RDXzV4NV9Gb3JtYXQgfHwgcCA9PT0gU1JHQjhfQUxQSEE4X0FTVENfNng1X0Zvcm1hdCB8fCBwID09PSBTUkdCOF9BTFBIQThfQVNUQ182eDZfRm9ybWF0IHx8IHAgPT09IFNSR0I4X0FMUEhBOF9BU1RDXzh4NV9Gb3JtYXQgfHwgcCA9PT0gU1JHQjhfQUxQSEE4X0FTVENfOHg2X0Zvcm1hdCB8fCBwID09PSBTUkdCOF9BTFBIQThfQVNUQ184eDhfRm9ybWF0IHx8IHAgPT09IFNSR0I4X0FMUEhBOF9BU1RDXzEweDVfRm9ybWF0IHx8IHAgPT09IFNSR0I4X0FMUEhBOF9BU1RDXzEweDZfRm9ybWF0IHx8IHAgPT09IFNSR0I4X0FMUEhBOF9BU1RDXzEweDhfRm9ybWF0IHx8IHAgPT09IFNSR0I4X0FMUEhBOF9BU1RDXzEweDEwX0Zvcm1hdCB8fCBwID09PSBTUkdCOF9BTFBIQThfQVNUQ18xMngxMF9Gb3JtYXQgfHwgcCA9PT0gU1JHQjhfQUxQSEE4X0FTVENfMTJ4MTJfRm9ybWF0KSB7XG5cdFx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfYXN0YycpO1xuXG5cdFx0XHRcdGlmIChleHRlbnNpb24gIT09IG51bGwpIHtcblx0XHRcdFx0XHQvLyBUT0RPIENvbXBsZXRlP1xuXHRcdFx0XHRcdHJldHVybiBwO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChwID09PSBSR0JBX0JQVENfRm9ybWF0KSB7XG5cdFx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCdFWFRfdGV4dHVyZV9jb21wcmVzc2lvbl9icHRjJyk7XG5cblx0XHRcdFx0aWYgKGV4dGVuc2lvbiAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdC8vIFRPRE8gQ29tcGxldGU/XG5cdFx0XHRcdFx0cmV0dXJuIHA7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHAgPT09IFVuc2lnbmVkSW50MjQ4VHlwZSkge1xuXHRcdFx0XHRpZiAoaXNXZWJHTDIpIHJldHVybiBnbC5VTlNJR05FRF9JTlRfMjRfODtcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ1dFQkdMX2RlcHRoX3RleHR1cmUnKTtcblxuXHRcdFx0XHRpZiAoZXh0ZW5zaW9uICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGV4dGVuc2lvbi5VTlNJR05FRF9JTlRfMjRfOF9XRUJHTDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRjb252ZXJ0OiBjb252ZXJ0XG5cdFx0fTtcblx0fVxuXG5cdGNsYXNzIEFycmF5Q2FtZXJhIGV4dGVuZHMgUGVyc3BlY3RpdmVDYW1lcmEge1xuXHRcdGNvbnN0cnVjdG9yKGFycmF5ID0gW10pIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLmNhbWVyYXMgPSBhcnJheTtcblx0XHR9XG5cblx0fVxuXG5cdEFycmF5Q2FtZXJhLnByb3RvdHlwZS5pc0FycmF5Q2FtZXJhID0gdHJ1ZTtcblxuXHRjbGFzcyBHcm91cCBleHRlbmRzIE9iamVjdDNEIHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnR3JvdXAnO1xuXHRcdH1cblxuXHR9XG5cblx0R3JvdXAucHJvdG90eXBlLmlzR3JvdXAgPSB0cnVlO1xuXG5cdGNvbnN0IF9tb3ZlRXZlbnQgPSB7XG5cdFx0dHlwZTogJ21vdmUnXG5cdH07XG5cblx0Y2xhc3MgV2ViWFJDb250cm9sbGVyIHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHRoaXMuX3RhcmdldFJheSA9IG51bGw7XG5cdFx0XHR0aGlzLl9ncmlwID0gbnVsbDtcblx0XHRcdHRoaXMuX2hhbmQgPSBudWxsO1xuXHRcdH1cblxuXHRcdGdldEhhbmRTcGFjZSgpIHtcblx0XHRcdGlmICh0aGlzLl9oYW5kID09PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuX2hhbmQgPSBuZXcgR3JvdXAoKTtcblx0XHRcdFx0dGhpcy5faGFuZC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX2hhbmQudmlzaWJsZSA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9oYW5kLmpvaW50cyA9IHt9O1xuXHRcdFx0XHR0aGlzLl9oYW5kLmlucHV0U3RhdGUgPSB7XG5cdFx0XHRcdFx0cGluY2hpbmc6IGZhbHNlXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLl9oYW5kO1xuXHRcdH1cblxuXHRcdGdldFRhcmdldFJheVNwYWNlKCkge1xuXHRcdFx0aWYgKHRoaXMuX3RhcmdldFJheSA9PT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLl90YXJnZXRSYXkgPSBuZXcgR3JvdXAoKTtcblx0XHRcdFx0dGhpcy5fdGFyZ2V0UmF5Lm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fdGFyZ2V0UmF5LnZpc2libGUgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fdGFyZ2V0UmF5Lmhhc0xpbmVhclZlbG9jaXR5ID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX3RhcmdldFJheS5saW5lYXJWZWxvY2l0eSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdHRoaXMuX3RhcmdldFJheS5oYXNBbmd1bGFyVmVsb2NpdHkgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fdGFyZ2V0UmF5LmFuZ3VsYXJWZWxvY2l0eSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLl90YXJnZXRSYXk7XG5cdFx0fVxuXG5cdFx0Z2V0R3JpcFNwYWNlKCkge1xuXHRcdFx0aWYgKHRoaXMuX2dyaXAgPT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5fZ3JpcCA9IG5ldyBHcm91cCgpO1xuXHRcdFx0XHR0aGlzLl9ncmlwLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fZ3JpcC52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX2dyaXAuaGFzTGluZWFyVmVsb2NpdHkgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fZ3JpcC5saW5lYXJWZWxvY2l0eSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdHRoaXMuX2dyaXAuaGFzQW5ndWxhclZlbG9jaXR5ID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX2dyaXAuYW5ndWxhclZlbG9jaXR5ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuX2dyaXA7XG5cdFx0fVxuXG5cdFx0ZGlzcGF0Y2hFdmVudChldmVudCkge1xuXHRcdFx0aWYgKHRoaXMuX3RhcmdldFJheSAhPT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLl90YXJnZXRSYXkuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9ncmlwICE9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuX2dyaXAuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9oYW5kICE9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuX2hhbmQuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGRpc2Nvbm5lY3QoaW5wdXRTb3VyY2UpIHtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudCh7XG5cdFx0XHRcdHR5cGU6ICdkaXNjb25uZWN0ZWQnLFxuXHRcdFx0XHRkYXRhOiBpbnB1dFNvdXJjZVxuXHRcdFx0fSk7XG5cblx0XHRcdGlmICh0aGlzLl90YXJnZXRSYXkgIT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5fdGFyZ2V0UmF5LnZpc2libGUgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX2dyaXAgIT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5fZ3JpcC52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9oYW5kICE9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuX2hhbmQudmlzaWJsZSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR1cGRhdGUoaW5wdXRTb3VyY2UsIGZyYW1lLCByZWZlcmVuY2VTcGFjZSkge1xuXHRcdFx0bGV0IGlucHV0UG9zZSA9IG51bGw7XG5cdFx0XHRsZXQgZ3JpcFBvc2UgPSBudWxsO1xuXHRcdFx0bGV0IGhhbmRQb3NlID0gbnVsbDtcblx0XHRcdGNvbnN0IHRhcmdldFJheSA9IHRoaXMuX3RhcmdldFJheTtcblx0XHRcdGNvbnN0IGdyaXAgPSB0aGlzLl9ncmlwO1xuXHRcdFx0Y29uc3QgaGFuZCA9IHRoaXMuX2hhbmQ7XG5cblx0XHRcdGlmIChpbnB1dFNvdXJjZSAmJiBmcmFtZS5zZXNzaW9uLnZpc2liaWxpdHlTdGF0ZSAhPT0gJ3Zpc2libGUtYmx1cnJlZCcpIHtcblx0XHRcdFx0aWYgKHRhcmdldFJheSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdGlucHV0UG9zZSA9IGZyYW1lLmdldFBvc2UoaW5wdXRTb3VyY2UudGFyZ2V0UmF5U3BhY2UsIHJlZmVyZW5jZVNwYWNlKTtcblxuXHRcdFx0XHRcdGlmIChpbnB1dFBvc2UgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdHRhcmdldFJheS5tYXRyaXguZnJvbUFycmF5KGlucHV0UG9zZS50cmFuc2Zvcm0ubWF0cml4KTtcblx0XHRcdFx0XHRcdHRhcmdldFJheS5tYXRyaXguZGVjb21wb3NlKHRhcmdldFJheS5wb3NpdGlvbiwgdGFyZ2V0UmF5LnJvdGF0aW9uLCB0YXJnZXRSYXkuc2NhbGUpO1xuXG5cdFx0XHRcdFx0XHRpZiAoaW5wdXRQb3NlLmxpbmVhclZlbG9jaXR5KSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFJheS5oYXNMaW5lYXJWZWxvY2l0eSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFJheS5saW5lYXJWZWxvY2l0eS5jb3B5KGlucHV0UG9zZS5saW5lYXJWZWxvY2l0eSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRSYXkuaGFzTGluZWFyVmVsb2NpdHkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKGlucHV0UG9zZS5hbmd1bGFyVmVsb2NpdHkpIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0UmF5Lmhhc0FuZ3VsYXJWZWxvY2l0eSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFJheS5hbmd1bGFyVmVsb2NpdHkuY29weShpbnB1dFBvc2UuYW5ndWxhclZlbG9jaXR5KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFJheS5oYXNBbmd1bGFyVmVsb2NpdHkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KF9tb3ZlRXZlbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChoYW5kICYmIGlucHV0U291cmNlLmhhbmQpIHtcblx0XHRcdFx0XHRoYW5kUG9zZSA9IHRydWU7XG5cblx0XHRcdFx0XHRmb3IgKGNvbnN0IGlucHV0am9pbnQgb2YgaW5wdXRTb3VyY2UuaGFuZC52YWx1ZXMoKSkge1xuXHRcdFx0XHRcdFx0Ly8gVXBkYXRlIHRoZSBqb2ludHMgZ3JvdXBzIHdpdGggdGhlIFhSSm9pbnQgcG9zZXNcblx0XHRcdFx0XHRcdGNvbnN0IGpvaW50UG9zZSA9IGZyYW1lLmdldEpvaW50UG9zZShpbnB1dGpvaW50LCByZWZlcmVuY2VTcGFjZSk7XG5cblx0XHRcdFx0XHRcdGlmIChoYW5kLmpvaW50c1tpbnB1dGpvaW50LmpvaW50TmFtZV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHQvLyBUaGUgdHJhbnNmb3JtIG9mIHRoaXMgam9pbnQgd2lsbCBiZSB1cGRhdGVkIHdpdGggdGhlIGpvaW50IHBvc2Ugb24gZWFjaCBmcmFtZVxuXHRcdFx0XHRcdFx0XHRjb25zdCBqb2ludCA9IG5ldyBHcm91cCgpO1xuXHRcdFx0XHRcdFx0XHRqb2ludC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGpvaW50LnZpc2libGUgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0aGFuZC5qb2ludHNbaW5wdXRqb2ludC5qb2ludE5hbWVdID0gam9pbnQ7IC8vID8/XG5cblx0XHRcdFx0XHRcdFx0aGFuZC5hZGQoam9pbnQpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjb25zdCBqb2ludCA9IGhhbmQuam9pbnRzW2lucHV0am9pbnQuam9pbnROYW1lXTtcblxuXHRcdFx0XHRcdFx0aWYgKGpvaW50UG9zZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRqb2ludC5tYXRyaXguZnJvbUFycmF5KGpvaW50UG9zZS50cmFuc2Zvcm0ubWF0cml4KTtcblx0XHRcdFx0XHRcdFx0am9pbnQubWF0cml4LmRlY29tcG9zZShqb2ludC5wb3NpdGlvbiwgam9pbnQucm90YXRpb24sIGpvaW50LnNjYWxlKTtcblx0XHRcdFx0XHRcdFx0am9pbnQuam9pbnRSYWRpdXMgPSBqb2ludFBvc2UucmFkaXVzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRqb2ludC52aXNpYmxlID0gam9pbnRQb3NlICE9PSBudWxsO1xuXHRcdFx0XHRcdH0gLy8gQ3VzdG9tIGV2ZW50c1xuXHRcdFx0XHRcdC8vIENoZWNrIHBpbmNoelxuXG5cblx0XHRcdFx0XHRjb25zdCBpbmRleFRpcCA9IGhhbmQuam9pbnRzWydpbmRleC1maW5nZXItdGlwJ107XG5cdFx0XHRcdFx0Y29uc3QgdGh1bWJUaXAgPSBoYW5kLmpvaW50c1sndGh1bWItdGlwJ107XG5cdFx0XHRcdFx0Y29uc3QgZGlzdGFuY2UgPSBpbmRleFRpcC5wb3NpdGlvbi5kaXN0YW5jZVRvKHRodW1iVGlwLnBvc2l0aW9uKTtcblx0XHRcdFx0XHRjb25zdCBkaXN0YW5jZVRvUGluY2ggPSAwLjAyO1xuXHRcdFx0XHRcdGNvbnN0IHRocmVzaG9sZCA9IDAuMDA1O1xuXG5cdFx0XHRcdFx0aWYgKGhhbmQuaW5wdXRTdGF0ZS5waW5jaGluZyAmJiBkaXN0YW5jZSA+IGRpc3RhbmNlVG9QaW5jaCArIHRocmVzaG9sZCkge1xuXHRcdFx0XHRcdFx0aGFuZC5pbnB1dFN0YXRlLnBpbmNoaW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoe1xuXHRcdFx0XHRcdFx0XHR0eXBlOiAncGluY2hlbmQnLFxuXHRcdFx0XHRcdFx0XHRoYW5kZWRuZXNzOiBpbnB1dFNvdXJjZS5oYW5kZWRuZXNzLFxuXHRcdFx0XHRcdFx0XHR0YXJnZXQ6IHRoaXNcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIWhhbmQuaW5wdXRTdGF0ZS5waW5jaGluZyAmJiBkaXN0YW5jZSA8PSBkaXN0YW5jZVRvUGluY2ggLSB0aHJlc2hvbGQpIHtcblx0XHRcdFx0XHRcdGhhbmQuaW5wdXRTdGF0ZS5waW5jaGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoe1xuXHRcdFx0XHRcdFx0XHR0eXBlOiAncGluY2hzdGFydCcsXG5cdFx0XHRcdFx0XHRcdGhhbmRlZG5lc3M6IGlucHV0U291cmNlLmhhbmRlZG5lc3MsXG5cdFx0XHRcdFx0XHRcdHRhcmdldDogdGhpc1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChncmlwICE9PSBudWxsICYmIGlucHV0U291cmNlLmdyaXBTcGFjZSkge1xuXHRcdFx0XHRcdFx0Z3JpcFBvc2UgPSBmcmFtZS5nZXRQb3NlKGlucHV0U291cmNlLmdyaXBTcGFjZSwgcmVmZXJlbmNlU3BhY2UpO1xuXG5cdFx0XHRcdFx0XHRpZiAoZ3JpcFBvc2UgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0Z3JpcC5tYXRyaXguZnJvbUFycmF5KGdyaXBQb3NlLnRyYW5zZm9ybS5tYXRyaXgpO1xuXHRcdFx0XHRcdFx0XHRncmlwLm1hdHJpeC5kZWNvbXBvc2UoZ3JpcC5wb3NpdGlvbiwgZ3JpcC5yb3RhdGlvbiwgZ3JpcC5zY2FsZSk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKGdyaXBQb3NlLmxpbmVhclZlbG9jaXR5KSB7XG5cdFx0XHRcdFx0XHRcdFx0Z3JpcC5oYXNMaW5lYXJWZWxvY2l0eSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0Z3JpcC5saW5lYXJWZWxvY2l0eS5jb3B5KGdyaXBQb3NlLmxpbmVhclZlbG9jaXR5KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRncmlwLmhhc0xpbmVhclZlbG9jaXR5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoZ3JpcFBvc2UuYW5ndWxhclZlbG9jaXR5KSB7XG5cdFx0XHRcdFx0XHRcdFx0Z3JpcC5oYXNBbmd1bGFyVmVsb2NpdHkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdGdyaXAuYW5ndWxhclZlbG9jaXR5LmNvcHkoZ3JpcFBvc2UuYW5ndWxhclZlbG9jaXR5KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRncmlwLmhhc0FuZ3VsYXJWZWxvY2l0eSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0YXJnZXRSYXkgIT09IG51bGwpIHtcblx0XHRcdFx0dGFyZ2V0UmF5LnZpc2libGUgPSBpbnB1dFBvc2UgIT09IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChncmlwICE9PSBudWxsKSB7XG5cdFx0XHRcdGdyaXAudmlzaWJsZSA9IGdyaXBQb3NlICE9PSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaGFuZCAhPT0gbnVsbCkge1xuXHRcdFx0XHRoYW5kLnZpc2libGUgPSBoYW5kUG9zZSAhPT0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBEZXB0aFRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblx0XHRjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCB0eXBlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBhbmlzb3Ryb3B5LCBmb3JtYXQpIHtcblx0XHRcdGZvcm1hdCA9IGZvcm1hdCAhPT0gdW5kZWZpbmVkID8gZm9ybWF0IDogRGVwdGhGb3JtYXQ7XG5cblx0XHRcdGlmIChmb3JtYXQgIT09IERlcHRoRm9ybWF0ICYmIGZvcm1hdCAhPT0gRGVwdGhTdGVuY2lsRm9ybWF0KSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignRGVwdGhUZXh0dXJlIGZvcm1hdCBtdXN0IGJlIGVpdGhlciBUSFJFRS5EZXB0aEZvcm1hdCBvciBUSFJFRS5EZXB0aFN0ZW5jaWxGb3JtYXQnKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGUgPT09IHVuZGVmaW5lZCAmJiBmb3JtYXQgPT09IERlcHRoRm9ybWF0KSB0eXBlID0gVW5zaWduZWRTaG9ydFR5cGU7XG5cdFx0XHRpZiAodHlwZSA9PT0gdW5kZWZpbmVkICYmIGZvcm1hdCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0KSB0eXBlID0gVW5zaWduZWRJbnQyNDhUeXBlO1xuXHRcdFx0c3VwZXIobnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5KTtcblx0XHRcdHRoaXMuaW1hZ2UgPSB7XG5cdFx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdFx0aGVpZ2h0OiBoZWlnaHRcblx0XHRcdH07XG5cdFx0XHR0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogTmVhcmVzdEZpbHRlcjtcblx0XHRcdHRoaXMubWluRmlsdGVyID0gbWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtaW5GaWx0ZXIgOiBOZWFyZXN0RmlsdGVyO1xuXHRcdFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblx0XHR9XG5cblx0fVxuXG5cdERlcHRoVGV4dHVyZS5wcm90b3R5cGUuaXNEZXB0aFRleHR1cmUgPSB0cnVlO1xuXG5cdGNsYXNzIFdlYlhSTWFuYWdlciBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cdFx0Y29uc3RydWN0b3IocmVuZGVyZXIsIGdsKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdFx0bGV0IHNlc3Npb24gPSBudWxsO1xuXHRcdFx0bGV0IGZyYW1lYnVmZmVyU2NhbGVGYWN0b3IgPSAxLjA7XG5cdFx0XHRsZXQgcmVmZXJlbmNlU3BhY2UgPSBudWxsO1xuXHRcdFx0bGV0IHJlZmVyZW5jZVNwYWNlVHlwZSA9ICdsb2NhbC1mbG9vcic7XG5cdFx0XHRjb25zdCBoYXNNdWx0aXNhbXBsZWRSZW5kZXJUb1RleHR1cmUgPSByZW5kZXJlci5leHRlbnNpb25zLmhhcygnV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlJyk7XG5cdFx0XHRsZXQgcG9zZSA9IG51bGw7XG5cdFx0XHRsZXQgZ2xCaW5kaW5nID0gbnVsbDtcblx0XHRcdGxldCBnbFByb2pMYXllciA9IG51bGw7XG5cdFx0XHRsZXQgZ2xCYXNlTGF5ZXIgPSBudWxsO1xuXHRcdFx0bGV0IGlzTXVsdGlzYW1wbGUgPSBmYWxzZTtcblx0XHRcdGxldCB4ckZyYW1lID0gbnVsbDtcblx0XHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSBnbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xuXHRcdFx0bGV0IGluaXRpYWxSZW5kZXJUYXJnZXQgPSBudWxsO1xuXHRcdFx0bGV0IG5ld1JlbmRlclRhcmdldCA9IG51bGw7XG5cdFx0XHRjb25zdCBjb250cm9sbGVycyA9IFtdO1xuXHRcdFx0Y29uc3QgaW5wdXRTb3VyY2VzTWFwID0gbmV3IE1hcCgpOyAvL1xuXG5cdFx0XHRjb25zdCBjYW1lcmFMID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCk7XG5cdFx0XHRjYW1lcmFMLmxheWVycy5lbmFibGUoMSk7XG5cdFx0XHRjYW1lcmFMLnZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoKTtcblx0XHRcdGNvbnN0IGNhbWVyYVIgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcblx0XHRcdGNhbWVyYVIubGF5ZXJzLmVuYWJsZSgyKTtcblx0XHRcdGNhbWVyYVIudmlld3BvcnQgPSBuZXcgVmVjdG9yNCgpO1xuXHRcdFx0Y29uc3QgY2FtZXJhcyA9IFtjYW1lcmFMLCBjYW1lcmFSXTtcblx0XHRcdGNvbnN0IGNhbWVyYVZSID0gbmV3IEFycmF5Q2FtZXJhKCk7XG5cdFx0XHRjYW1lcmFWUi5sYXllcnMuZW5hYmxlKDEpO1xuXHRcdFx0Y2FtZXJhVlIubGF5ZXJzLmVuYWJsZSgyKTtcblx0XHRcdGxldCBfY3VycmVudERlcHRoTmVhciA9IG51bGw7XG5cdFx0XHRsZXQgX2N1cnJlbnREZXB0aEZhciA9IG51bGw7IC8vXG5cblx0XHRcdHRoaXMuY2FtZXJhQXV0b1VwZGF0ZSA9IHRydWU7XG5cdFx0XHR0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMuaXNQcmVzZW50aW5nID0gZmFsc2U7XG5cblx0XHRcdHRoaXMuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uIChpbmRleCkge1xuXHRcdFx0XHRsZXQgY29udHJvbGxlciA9IGNvbnRyb2xsZXJzW2luZGV4XTtcblxuXHRcdFx0XHRpZiAoY29udHJvbGxlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Y29udHJvbGxlciA9IG5ldyBXZWJYUkNvbnRyb2xsZXIoKTtcblx0XHRcdFx0XHRjb250cm9sbGVyc1tpbmRleF0gPSBjb250cm9sbGVyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGNvbnRyb2xsZXIuZ2V0VGFyZ2V0UmF5U3BhY2UoKTtcblx0XHRcdH07XG5cblx0XHRcdHRoaXMuZ2V0Q29udHJvbGxlckdyaXAgPSBmdW5jdGlvbiAoaW5kZXgpIHtcblx0XHRcdFx0bGV0IGNvbnRyb2xsZXIgPSBjb250cm9sbGVyc1tpbmRleF07XG5cblx0XHRcdFx0aWYgKGNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnRyb2xsZXIgPSBuZXcgV2ViWFJDb250cm9sbGVyKCk7XG5cdFx0XHRcdFx0Y29udHJvbGxlcnNbaW5kZXhdID0gY29udHJvbGxlcjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBjb250cm9sbGVyLmdldEdyaXBTcGFjZSgpO1xuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5nZXRIYW5kID0gZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0XHRcdGxldCBjb250cm9sbGVyID0gY29udHJvbGxlcnNbaW5kZXhdO1xuXG5cdFx0XHRcdGlmIChjb250cm9sbGVyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRjb250cm9sbGVyID0gbmV3IFdlYlhSQ29udHJvbGxlcigpO1xuXHRcdFx0XHRcdGNvbnRyb2xsZXJzW2luZGV4XSA9IGNvbnRyb2xsZXI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gY29udHJvbGxlci5nZXRIYW5kU3BhY2UoKTtcblx0XHRcdH07IC8vXG5cblxuXHRcdFx0ZnVuY3Rpb24gb25TZXNzaW9uRXZlbnQoZXZlbnQpIHtcblx0XHRcdFx0Y29uc3QgY29udHJvbGxlciA9IGlucHV0U291cmNlc01hcC5nZXQoZXZlbnQuaW5wdXRTb3VyY2UpO1xuXG5cdFx0XHRcdGlmIChjb250cm9sbGVyKSB7XG5cdFx0XHRcdFx0Y29udHJvbGxlci5kaXNwYXRjaEV2ZW50KHtcblx0XHRcdFx0XHRcdHR5cGU6IGV2ZW50LnR5cGUsXG5cdFx0XHRcdFx0XHRkYXRhOiBldmVudC5pbnB1dFNvdXJjZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIG9uU2Vzc2lvbkVuZCgpIHtcblx0XHRcdFx0aW5wdXRTb3VyY2VzTWFwLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xsZXIsIGlucHV0U291cmNlKSB7XG5cdFx0XHRcdFx0Y29udHJvbGxlci5kaXNjb25uZWN0KGlucHV0U291cmNlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGlucHV0U291cmNlc01hcC5jbGVhcigpO1xuXHRcdFx0XHRfY3VycmVudERlcHRoTmVhciA9IG51bGw7XG5cdFx0XHRcdF9jdXJyZW50RGVwdGhGYXIgPSBudWxsOyAvLyByZXN0b3JlIGZyYW1lYnVmZmVyL3JlbmRlcmluZyBzdGF0ZVxuXG5cdFx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChpbml0aWFsUmVuZGVyVGFyZ2V0KTtcblx0XHRcdFx0Z2xCYXNlTGF5ZXIgPSBudWxsO1xuXHRcdFx0XHRnbFByb2pMYXllciA9IG51bGw7XG5cdFx0XHRcdGdsQmluZGluZyA9IG51bGw7XG5cdFx0XHRcdHNlc3Npb24gPSBudWxsO1xuXHRcdFx0XHRuZXdSZW5kZXJUYXJnZXQgPSBudWxsOyAvL1xuXG5cdFx0XHRcdGFuaW1hdGlvbi5zdG9wKCk7XG5cdFx0XHRcdHNjb3BlLmlzUHJlc2VudGluZyA9IGZhbHNlO1xuXHRcdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KHtcblx0XHRcdFx0XHR0eXBlOiAnc2Vzc2lvbmVuZCdcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc2V0RnJhbWVidWZmZXJTY2FsZUZhY3RvciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRmcmFtZWJ1ZmZlclNjYWxlRmFjdG9yID0gdmFsdWU7XG5cblx0XHRcdFx0aWYgKHNjb3BlLmlzUHJlc2VudGluZyA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViWFJNYW5hZ2VyOiBDYW5ub3QgY2hhbmdlIGZyYW1lYnVmZmVyIHNjYWxlIHdoaWxlIHByZXNlbnRpbmcuJyk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdHRoaXMuc2V0UmVmZXJlbmNlU3BhY2VUeXBlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdHJlZmVyZW5jZVNwYWNlVHlwZSA9IHZhbHVlO1xuXG5cdFx0XHRcdGlmIChzY29wZS5pc1ByZXNlbnRpbmcgPT09IHRydWUpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYlhSTWFuYWdlcjogQ2Fubm90IGNoYW5nZSByZWZlcmVuY2Ugc3BhY2UgdHlwZSB3aGlsZSBwcmVzZW50aW5nLicpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLmdldFJlZmVyZW5jZVNwYWNlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gcmVmZXJlbmNlU3BhY2U7XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLmdldEJhc2VMYXllciA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIGdsUHJvakxheWVyICE9PSBudWxsID8gZ2xQcm9qTGF5ZXIgOiBnbEJhc2VMYXllcjtcblx0XHRcdH07XG5cblx0XHRcdHRoaXMuZ2V0QmluZGluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIGdsQmluZGluZztcblx0XHRcdH07XG5cblx0XHRcdHRoaXMuZ2V0RnJhbWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiB4ckZyYW1lO1xuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5nZXRTZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gc2Vzc2lvbjtcblx0XHRcdH07XG5cblx0XHRcdHRoaXMuc2V0U2Vzc2lvbiA9IGFzeW5jIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRzZXNzaW9uID0gdmFsdWU7XG5cblx0XHRcdFx0aWYgKHNlc3Npb24gIT09IG51bGwpIHtcblx0XHRcdFx0XHRpbml0aWFsUmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cdFx0XHRcdFx0c2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3QnLCBvblNlc3Npb25FdmVudCk7XG5cdFx0XHRcdFx0c2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIG9uU2Vzc2lvbkV2ZW50KTtcblx0XHRcdFx0XHRzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGVuZCcsIG9uU2Vzc2lvbkV2ZW50KTtcblx0XHRcdFx0XHRzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoJ3NxdWVlemUnLCBvblNlc3Npb25FdmVudCk7XG5cdFx0XHRcdFx0c2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCdzcXVlZXplc3RhcnQnLCBvblNlc3Npb25FdmVudCk7XG5cdFx0XHRcdFx0c2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCdzcXVlZXplZW5kJywgb25TZXNzaW9uRXZlbnQpO1xuXHRcdFx0XHRcdHNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lcignZW5kJywgb25TZXNzaW9uRW5kKTtcblx0XHRcdFx0XHRzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0c291cmNlc2NoYW5nZScsIG9uSW5wdXRTb3VyY2VzQ2hhbmdlKTtcblxuXHRcdFx0XHRcdGlmIChhdHRyaWJ1dGVzLnhyQ29tcGF0aWJsZSAhPT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0YXdhaXQgZ2wubWFrZVhSQ29tcGF0aWJsZSgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChzZXNzaW9uLnJlbmRlclN0YXRlLmxheWVycyA9PT0gdW5kZWZpbmVkIHx8IHJlbmRlcmVyLmNhcGFiaWxpdGllcy5pc1dlYkdMMiA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGxheWVySW5pdCA9IHtcblx0XHRcdFx0XHRcdFx0YW50aWFsaWFzOiBzZXNzaW9uLnJlbmRlclN0YXRlLmxheWVycyA9PT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy5hbnRpYWxpYXMgOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRhbHBoYTogYXR0cmlidXRlcy5hbHBoYSxcblx0XHRcdFx0XHRcdFx0ZGVwdGg6IGF0dHJpYnV0ZXMuZGVwdGgsXG5cdFx0XHRcdFx0XHRcdHN0ZW5jaWw6IGF0dHJpYnV0ZXMuc3RlbmNpbCxcblx0XHRcdFx0XHRcdFx0ZnJhbWVidWZmZXJTY2FsZUZhY3RvcjogZnJhbWVidWZmZXJTY2FsZUZhY3RvclxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGdsQmFzZUxheWVyID0gbmV3IFhSV2ViR0xMYXllcihzZXNzaW9uLCBnbCwgbGF5ZXJJbml0KTtcblx0XHRcdFx0XHRcdHNlc3Npb24udXBkYXRlUmVuZGVyU3RhdGUoe1xuXHRcdFx0XHRcdFx0XHRiYXNlTGF5ZXI6IGdsQmFzZUxheWVyXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdG5ld1JlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldChnbEJhc2VMYXllci5mcmFtZWJ1ZmZlcldpZHRoLCBnbEJhc2VMYXllci5mcmFtZWJ1ZmZlckhlaWdodCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlzTXVsdGlzYW1wbGUgPSBhdHRyaWJ1dGVzLmFudGlhbGlhcztcblx0XHRcdFx0XHRcdGxldCBkZXB0aEZvcm1hdCA9IG51bGw7XG5cdFx0XHRcdFx0XHRsZXQgZGVwdGhUeXBlID0gbnVsbDtcblx0XHRcdFx0XHRcdGxldCBnbERlcHRoRm9ybWF0ID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0aWYgKGF0dHJpYnV0ZXMuZGVwdGgpIHtcblx0XHRcdFx0XHRcdFx0Z2xEZXB0aEZvcm1hdCA9IGF0dHJpYnV0ZXMuc3RlbmNpbCA/IGdsLkRFUFRIMjRfU1RFTkNJTDggOiBnbC5ERVBUSF9DT01QT05FTlQxNjtcblx0XHRcdFx0XHRcdFx0ZGVwdGhGb3JtYXQgPSBhdHRyaWJ1dGVzLnN0ZW5jaWwgPyBEZXB0aFN0ZW5jaWxGb3JtYXQgOiBEZXB0aEZvcm1hdDtcblx0XHRcdFx0XHRcdFx0ZGVwdGhUeXBlID0gYXR0cmlidXRlcy5zdGVuY2lsID8gVW5zaWduZWRJbnQyNDhUeXBlIDogVW5zaWduZWRTaG9ydFR5cGU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNvbnN0IHByb2plY3Rpb25sYXllckluaXQgPSB7XG5cdFx0XHRcdFx0XHRcdGNvbG9yRm9ybWF0OiBhdHRyaWJ1dGVzLmFscGhhIHx8IGlzTXVsdGlzYW1wbGUgPyBnbC5SR0JBOCA6IGdsLlJHQjgsXG5cdFx0XHRcdFx0XHRcdGRlcHRoRm9ybWF0OiBnbERlcHRoRm9ybWF0LFxuXHRcdFx0XHRcdFx0XHRzY2FsZUZhY3RvcjogZnJhbWVidWZmZXJTY2FsZUZhY3RvclxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGdsQmluZGluZyA9IG5ldyBYUldlYkdMQmluZGluZyhzZXNzaW9uLCBnbCk7XG5cdFx0XHRcdFx0XHRnbFByb2pMYXllciA9IGdsQmluZGluZy5jcmVhdGVQcm9qZWN0aW9uTGF5ZXIocHJvamVjdGlvbmxheWVySW5pdCk7XG5cdFx0XHRcdFx0XHRzZXNzaW9uLnVwZGF0ZVJlbmRlclN0YXRlKHtcblx0XHRcdFx0XHRcdFx0bGF5ZXJzOiBbZ2xQcm9qTGF5ZXJdXG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0aWYgKGlzTXVsdGlzYW1wbGUpIHtcblx0XHRcdFx0XHRcdFx0bmV3UmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQoZ2xQcm9qTGF5ZXIudGV4dHVyZVdpZHRoLCBnbFByb2pMYXllci50ZXh0dXJlSGVpZ2h0LCB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9ybWF0OiBSR0JBRm9ybWF0LFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFVuc2lnbmVkQnl0ZVR5cGUsXG5cdFx0XHRcdFx0XHRcdFx0ZGVwdGhUZXh0dXJlOiBuZXcgRGVwdGhUZXh0dXJlKGdsUHJvakxheWVyLnRleHR1cmVXaWR0aCwgZ2xQcm9qTGF5ZXIudGV4dHVyZUhlaWdodCwgZGVwdGhUeXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZXB0aEZvcm1hdCksXG5cdFx0XHRcdFx0XHRcdFx0c3RlbmNpbEJ1ZmZlcjogYXR0cmlidXRlcy5zdGVuY2lsLFxuXHRcdFx0XHRcdFx0XHRcdGlnbm9yZURlcHRoOiBnbFByb2pMYXllci5pZ25vcmVEZXB0aFZhbHVlcyxcblx0XHRcdFx0XHRcdFx0XHR1c2VSZW5kZXJUb1RleHR1cmU6IGhhc011bHRpc2FtcGxlZFJlbmRlclRvVGV4dHVyZVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdG5ld1JlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldChnbFByb2pMYXllci50ZXh0dXJlV2lkdGgsIGdsUHJvakxheWVyLnRleHR1cmVIZWlnaHQsIHtcblx0XHRcdFx0XHRcdFx0XHRmb3JtYXQ6IGF0dHJpYnV0ZXMuYWxwaGEgPyBSR0JBRm9ybWF0IDogUkdCRm9ybWF0LFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFVuc2lnbmVkQnl0ZVR5cGUsXG5cdFx0XHRcdFx0XHRcdFx0ZGVwdGhUZXh0dXJlOiBuZXcgRGVwdGhUZXh0dXJlKGdsUHJvakxheWVyLnRleHR1cmVXaWR0aCwgZ2xQcm9qTGF5ZXIudGV4dHVyZUhlaWdodCwgZGVwdGhUeXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZXB0aEZvcm1hdCksXG5cdFx0XHRcdFx0XHRcdFx0c3RlbmNpbEJ1ZmZlcjogYXR0cmlidXRlcy5zdGVuY2lsLFxuXHRcdFx0XHRcdFx0XHRcdGlnbm9yZURlcHRoOiBnbFByb2pMYXllci5pZ25vcmVEZXB0aFZhbHVlc1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IC8vIFNldCBmb3ZlYXRpb24gdG8gbWF4aW11bS5cblxuXG5cdFx0XHRcdFx0dGhpcy5zZXRGb3ZlYXRpb24oMCk7XG5cdFx0XHRcdFx0cmVmZXJlbmNlU3BhY2UgPSBhd2FpdCBzZXNzaW9uLnJlcXVlc3RSZWZlcmVuY2VTcGFjZShyZWZlcmVuY2VTcGFjZVR5cGUpO1xuXHRcdFx0XHRcdGFuaW1hdGlvbi5zZXRDb250ZXh0KHNlc3Npb24pO1xuXHRcdFx0XHRcdGFuaW1hdGlvbi5zdGFydCgpO1xuXHRcdFx0XHRcdHNjb3BlLmlzUHJlc2VudGluZyA9IHRydWU7XG5cdFx0XHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCh7XG5cdFx0XHRcdFx0XHR0eXBlOiAnc2Vzc2lvbnN0YXJ0J1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRmdW5jdGlvbiBvbklucHV0U291cmNlc0NoYW5nZShldmVudCkge1xuXHRcdFx0XHRjb25zdCBpbnB1dFNvdXJjZXMgPSBzZXNzaW9uLmlucHV0U291cmNlczsgLy8gQXNzaWduIGlucHV0U291cmNlcyB0byBhdmFpbGFibGUgY29udHJvbGxlcnNcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRyb2xsZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aW5wdXRTb3VyY2VzTWFwLnNldChpbnB1dFNvdXJjZXNbaV0sIGNvbnRyb2xsZXJzW2ldKTtcblx0XHRcdFx0fSAvLyBOb3RpZnkgZGlzY29ubmVjdGVkXG5cblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50LnJlbW92ZWQubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBpbnB1dFNvdXJjZSA9IGV2ZW50LnJlbW92ZWRbaV07XG5cdFx0XHRcdFx0Y29uc3QgY29udHJvbGxlciA9IGlucHV0U291cmNlc01hcC5nZXQoaW5wdXRTb3VyY2UpO1xuXG5cdFx0XHRcdFx0aWYgKGNvbnRyb2xsZXIpIHtcblx0XHRcdFx0XHRcdGNvbnRyb2xsZXIuZGlzcGF0Y2hFdmVudCh7XG5cdFx0XHRcdFx0XHRcdHR5cGU6ICdkaXNjb25uZWN0ZWQnLFxuXHRcdFx0XHRcdFx0XHRkYXRhOiBpbnB1dFNvdXJjZVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRpbnB1dFNvdXJjZXNNYXAuZGVsZXRlKGlucHV0U291cmNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gLy8gTm90aWZ5IGNvbm5lY3RlZFxuXG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBldmVudC5hZGRlZC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IGlucHV0U291cmNlID0gZXZlbnQuYWRkZWRbaV07XG5cdFx0XHRcdFx0Y29uc3QgY29udHJvbGxlciA9IGlucHV0U291cmNlc01hcC5nZXQoaW5wdXRTb3VyY2UpO1xuXG5cdFx0XHRcdFx0aWYgKGNvbnRyb2xsZXIpIHtcblx0XHRcdFx0XHRcdGNvbnRyb2xsZXIuZGlzcGF0Y2hFdmVudCh7XG5cdFx0XHRcdFx0XHRcdHR5cGU6ICdjb25uZWN0ZWQnLFxuXHRcdFx0XHRcdFx0XHRkYXRhOiBpbnB1dFNvdXJjZVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IC8vXG5cblxuXHRcdFx0Y29uc3QgY2FtZXJhTFBvcyA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBjYW1lcmFSUG9zID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdC8qKlxuXHRcdFx0ICogQXNzdW1lcyAyIGNhbWVyYXMgdGhhdCBhcmUgcGFyYWxsZWwgYW5kIHNoYXJlIGFuIFgtYXhpcywgYW5kIHRoYXRcblx0XHRcdCAqIHRoZSBjYW1lcmFzJyBwcm9qZWN0aW9uIGFuZCB3b3JsZCBtYXRyaWNlcyBoYXZlIGFscmVhZHkgYmVlbiBzZXQuXG5cdFx0XHQgKiBBbmQgdGhhdCBuZWFyIGFuZCBmYXIgcGxhbmVzIGFyZSBpZGVudGljYWwgZm9yIGJvdGggY2FtZXJhcy5cblx0XHRcdCAqIFZpc3VhbGl6YXRpb24gb2YgdGhpcyB0ZWNobmlxdWU6IGh0dHBzOi8vY29tcHV0ZXJncmFwaGljcy5zdGFja2V4Y2hhbmdlLmNvbS9hLzQ3NjVcblx0XHRcdCAqL1xuXG5cdFx0XHRmdW5jdGlvbiBzZXRQcm9qZWN0aW9uRnJvbVVuaW9uKGNhbWVyYSwgY2FtZXJhTCwgY2FtZXJhUikge1xuXHRcdFx0XHRjYW1lcmFMUG9zLnNldEZyb21NYXRyaXhQb3NpdGlvbihjYW1lcmFMLm1hdHJpeFdvcmxkKTtcblx0XHRcdFx0Y2FtZXJhUlBvcy5zZXRGcm9tTWF0cml4UG9zaXRpb24oY2FtZXJhUi5tYXRyaXhXb3JsZCk7XG5cdFx0XHRcdGNvbnN0IGlwZCA9IGNhbWVyYUxQb3MuZGlzdGFuY2VUbyhjYW1lcmFSUG9zKTtcblx0XHRcdFx0Y29uc3QgcHJvakwgPSBjYW1lcmFMLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHM7XG5cdFx0XHRcdGNvbnN0IHByb2pSID0gY2FtZXJhUi5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzOyAvLyBWUiBzeXN0ZW1zIHdpbGwgaGF2ZSBpZGVudGljYWwgZmFyIGFuZCBuZWFyIHBsYW5lcywgYW5kXG5cdFx0XHRcdC8vIG1vc3QgbGlrZWx5IGlkZW50aWNhbCB0b3AgYW5kIGJvdHRvbSBmcnVzdHVtIGV4dGVudHMuXG5cdFx0XHRcdC8vIFVzZSB0aGUgbGVmdCBjYW1lcmEgZm9yIHRoZXNlIHZhbHVlcy5cblxuXHRcdFx0XHRjb25zdCBuZWFyID0gcHJvakxbMTRdIC8gKHByb2pMWzEwXSAtIDEpO1xuXHRcdFx0XHRjb25zdCBmYXIgPSBwcm9qTFsxNF0gLyAocHJvakxbMTBdICsgMSk7XG5cdFx0XHRcdGNvbnN0IHRvcEZvdiA9IChwcm9qTFs5XSArIDEpIC8gcHJvakxbNV07XG5cdFx0XHRcdGNvbnN0IGJvdHRvbUZvdiA9IChwcm9qTFs5XSAtIDEpIC8gcHJvakxbNV07XG5cdFx0XHRcdGNvbnN0IGxlZnRGb3YgPSAocHJvakxbOF0gLSAxKSAvIHByb2pMWzBdO1xuXHRcdFx0XHRjb25zdCByaWdodEZvdiA9IChwcm9qUls4XSArIDEpIC8gcHJvalJbMF07XG5cdFx0XHRcdGNvbnN0IGxlZnQgPSBuZWFyICogbGVmdEZvdjtcblx0XHRcdFx0Y29uc3QgcmlnaHQgPSBuZWFyICogcmlnaHRGb3Y7IC8vIENhbGN1bGF0ZSB0aGUgbmV3IGNhbWVyYSdzIHBvc2l0aW9uIG9mZnNldCBmcm9tIHRoZVxuXHRcdFx0XHQvLyBsZWZ0IGNhbWVyYS4geE9mZnNldCBzaG91bGQgYmUgcm91Z2hseSBoYWxmIGBpcGRgLlxuXG5cdFx0XHRcdGNvbnN0IHpPZmZzZXQgPSBpcGQgLyAoLWxlZnRGb3YgKyByaWdodEZvdik7XG5cdFx0XHRcdGNvbnN0IHhPZmZzZXQgPSB6T2Zmc2V0ICogLWxlZnRGb3Y7IC8vIFRPRE86IEJldHRlciB3YXkgdG8gYXBwbHkgdGhpcyBvZmZzZXQ/XG5cblx0XHRcdFx0Y2FtZXJhTC5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoY2FtZXJhLnBvc2l0aW9uLCBjYW1lcmEucXVhdGVybmlvbiwgY2FtZXJhLnNjYWxlKTtcblx0XHRcdFx0Y2FtZXJhLnRyYW5zbGF0ZVgoeE9mZnNldCk7XG5cdFx0XHRcdGNhbWVyYS50cmFuc2xhdGVaKHpPZmZzZXQpO1xuXHRcdFx0XHRjYW1lcmEubWF0cml4V29ybGQuY29tcG9zZShjYW1lcmEucG9zaXRpb24sIGNhbWVyYS5xdWF0ZXJuaW9uLCBjYW1lcmEuc2NhbGUpO1xuXHRcdFx0XHRjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoY2FtZXJhLm1hdHJpeFdvcmxkKS5pbnZlcnQoKTsgLy8gRmluZCB0aGUgdW5pb24gb2YgdGhlIGZydXN0dW0gdmFsdWVzIG9mIHRoZSBjYW1lcmFzIGFuZCBzY2FsZVxuXHRcdFx0XHQvLyB0aGUgdmFsdWVzIHNvIHRoYXQgdGhlIG5lYXIgcGxhbmUncyBwb3NpdGlvbiBkb2VzIG5vdCBjaGFuZ2UgaW4gd29ybGQgc3BhY2UsXG5cdFx0XHRcdC8vIGFsdGhvdWdoIG11c3Qgbm93IGJlIHJlbGF0aXZlIHRvIHRoZSBuZXcgdW5pb24gY2FtZXJhLlxuXG5cdFx0XHRcdGNvbnN0IG5lYXIyID0gbmVhciArIHpPZmZzZXQ7XG5cdFx0XHRcdGNvbnN0IGZhcjIgPSBmYXIgKyB6T2Zmc2V0O1xuXHRcdFx0XHRjb25zdCBsZWZ0MiA9IGxlZnQgLSB4T2Zmc2V0O1xuXHRcdFx0XHRjb25zdCByaWdodDIgPSByaWdodCArIChpcGQgLSB4T2Zmc2V0KTtcblx0XHRcdFx0Y29uc3QgdG9wMiA9IHRvcEZvdiAqIGZhciAvIGZhcjIgKiBuZWFyMjtcblx0XHRcdFx0Y29uc3QgYm90dG9tMiA9IGJvdHRvbUZvdiAqIGZhciAvIGZhcjIgKiBuZWFyMjtcblx0XHRcdFx0Y2FtZXJhLnByb2plY3Rpb25NYXRyaXgubWFrZVBlcnNwZWN0aXZlKGxlZnQyLCByaWdodDIsIHRvcDIsIGJvdHRvbTIsIG5lYXIyLCBmYXIyKTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gdXBkYXRlQ2FtZXJhKGNhbWVyYSwgcGFyZW50KSB7XG5cdFx0XHRcdGlmIChwYXJlbnQgPT09IG51bGwpIHtcblx0XHRcdFx0XHRjYW1lcmEubWF0cml4V29ybGQuY29weShjYW1lcmEubWF0cml4KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjYW1lcmEubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyhwYXJlbnQubWF0cml4V29ybGQsIGNhbWVyYS5tYXRyaXgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KGNhbWVyYS5tYXRyaXhXb3JsZCkuaW52ZXJ0KCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudXBkYXRlQ2FtZXJhID0gZnVuY3Rpb24gKGNhbWVyYSkge1xuXHRcdFx0XHRpZiAoc2Vzc2lvbiA9PT0gbnVsbCkgcmV0dXJuO1xuXHRcdFx0XHRjYW1lcmFWUi5uZWFyID0gY2FtZXJhUi5uZWFyID0gY2FtZXJhTC5uZWFyID0gY2FtZXJhLm5lYXI7XG5cdFx0XHRcdGNhbWVyYVZSLmZhciA9IGNhbWVyYVIuZmFyID0gY2FtZXJhTC5mYXIgPSBjYW1lcmEuZmFyO1xuXG5cdFx0XHRcdGlmIChfY3VycmVudERlcHRoTmVhciAhPT0gY2FtZXJhVlIubmVhciB8fCBfY3VycmVudERlcHRoRmFyICE9PSBjYW1lcmFWUi5mYXIpIHtcblx0XHRcdFx0XHQvLyBOb3RlIHRoYXQgdGhlIG5ldyByZW5kZXJTdGF0ZSB3b24ndCBhcHBseSB1bnRpbCB0aGUgbmV4dCBmcmFtZS4gU2VlICMxODMyMFxuXHRcdFx0XHRcdHNlc3Npb24udXBkYXRlUmVuZGVyU3RhdGUoe1xuXHRcdFx0XHRcdFx0ZGVwdGhOZWFyOiBjYW1lcmFWUi5uZWFyLFxuXHRcdFx0XHRcdFx0ZGVwdGhGYXI6IGNhbWVyYVZSLmZhclxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdF9jdXJyZW50RGVwdGhOZWFyID0gY2FtZXJhVlIubmVhcjtcblx0XHRcdFx0XHRfY3VycmVudERlcHRoRmFyID0gY2FtZXJhVlIuZmFyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgcGFyZW50ID0gY2FtZXJhLnBhcmVudDtcblx0XHRcdFx0Y29uc3QgY2FtZXJhcyA9IGNhbWVyYVZSLmNhbWVyYXM7XG5cdFx0XHRcdHVwZGF0ZUNhbWVyYShjYW1lcmFWUiwgcGFyZW50KTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNhbWVyYXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR1cGRhdGVDYW1lcmEoY2FtZXJhc1tpXSwgcGFyZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbWVyYVZSLm1hdHJpeFdvcmxkLmRlY29tcG9zZShjYW1lcmFWUi5wb3NpdGlvbiwgY2FtZXJhVlIucXVhdGVybmlvbiwgY2FtZXJhVlIuc2NhbGUpOyAvLyB1cGRhdGUgdXNlciBjYW1lcmEgYW5kIGl0cyBjaGlsZHJlblxuXG5cdFx0XHRcdGNhbWVyYS5wb3NpdGlvbi5jb3B5KGNhbWVyYVZSLnBvc2l0aW9uKTtcblx0XHRcdFx0Y2FtZXJhLnF1YXRlcm5pb24uY29weShjYW1lcmFWUi5xdWF0ZXJuaW9uKTtcblx0XHRcdFx0Y2FtZXJhLnNjYWxlLmNvcHkoY2FtZXJhVlIuc2NhbGUpO1xuXHRcdFx0XHRjYW1lcmEubWF0cml4LmNvcHkoY2FtZXJhVlIubWF0cml4KTtcblx0XHRcdFx0Y2FtZXJhLm1hdHJpeFdvcmxkLmNvcHkoY2FtZXJhVlIubWF0cml4V29ybGQpO1xuXHRcdFx0XHRjb25zdCBjaGlsZHJlbiA9IGNhbWVyYS5jaGlsZHJlbjtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGNoaWxkcmVuW2ldLnVwZGF0ZU1hdHJpeFdvcmxkKHRydWUpO1xuXHRcdFx0XHR9IC8vIHVwZGF0ZSBwcm9qZWN0aW9uIG1hdHJpeCBmb3IgcHJvcGVyIHZpZXcgZnJ1c3R1bSBjdWxsaW5nXG5cblxuXHRcdFx0XHRpZiAoY2FtZXJhcy5sZW5ndGggPT09IDIpIHtcblx0XHRcdFx0XHRzZXRQcm9qZWN0aW9uRnJvbVVuaW9uKGNhbWVyYVZSLCBjYW1lcmFMLCBjYW1lcmFSKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBhc3N1bWUgc2luZ2xlIGNhbWVyYSBzZXR1cCAoQVIpXG5cdFx0XHRcdFx0Y2FtZXJhVlIucHJvamVjdGlvbk1hdHJpeC5jb3B5KGNhbWVyYUwucHJvamVjdGlvbk1hdHJpeCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdHRoaXMuZ2V0Q2FtZXJhID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gY2FtZXJhVlI7XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLmdldEZvdmVhdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKGdsUHJvakxheWVyICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGdsUHJvakxheWVyLmZpeGVkRm92ZWF0aW9uO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGdsQmFzZUxheWVyICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGdsQmFzZUxheWVyLmZpeGVkRm92ZWF0aW9uO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdH07XG5cblx0XHRcdHRoaXMuc2V0Rm92ZWF0aW9uID0gZnVuY3Rpb24gKGZvdmVhdGlvbikge1xuXHRcdFx0XHQvLyAwID0gbm8gZm92ZWF0aW9uID0gZnVsbCByZXNvbHV0aW9uXG5cdFx0XHRcdC8vIDEgPSBtYXhpbXVtIGZvdmVhdGlvbiA9IHRoZSBlZGdlcyByZW5kZXIgYXQgbG93ZXIgcmVzb2x1dGlvblxuXHRcdFx0XHRpZiAoZ2xQcm9qTGF5ZXIgIT09IG51bGwpIHtcblx0XHRcdFx0XHRnbFByb2pMYXllci5maXhlZEZvdmVhdGlvbiA9IGZvdmVhdGlvbjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChnbEJhc2VMYXllciAhPT0gbnVsbCAmJiBnbEJhc2VMYXllci5maXhlZEZvdmVhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Z2xCYXNlTGF5ZXIuZml4ZWRGb3ZlYXRpb24gPSBmb3ZlYXRpb247XG5cdFx0XHRcdH1cblx0XHRcdH07IC8vIEFuaW1hdGlvbiBMb29wXG5cblxuXHRcdFx0bGV0IG9uQW5pbWF0aW9uRnJhbWVDYWxsYmFjayA9IG51bGw7XG5cblx0XHRcdGZ1bmN0aW9uIG9uQW5pbWF0aW9uRnJhbWUodGltZSwgZnJhbWUpIHtcblx0XHRcdFx0cG9zZSA9IGZyYW1lLmdldFZpZXdlclBvc2UocmVmZXJlbmNlU3BhY2UpO1xuXHRcdFx0XHR4ckZyYW1lID0gZnJhbWU7XG5cblx0XHRcdFx0aWYgKHBvc2UgIT09IG51bGwpIHtcblx0XHRcdFx0XHRjb25zdCB2aWV3cyA9IHBvc2Uudmlld3M7XG5cblx0XHRcdFx0XHRpZiAoZ2xCYXNlTGF5ZXIgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldEZyYW1lYnVmZmVyKG5ld1JlbmRlclRhcmdldCwgZ2xCYXNlTGF5ZXIuZnJhbWVidWZmZXIpO1xuXHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KG5ld1JlbmRlclRhcmdldCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGV0IGNhbWVyYVZSTmVlZHNVcGRhdGUgPSBmYWxzZTsgLy8gY2hlY2sgaWYgaXQncyBuZWNlc3NhcnkgdG8gcmVidWlsZCBjYW1lcmFWUidzIGNhbWVyYSBsaXN0XG5cblx0XHRcdFx0XHRpZiAodmlld3MubGVuZ3RoICE9PSBjYW1lcmFWUi5jYW1lcmFzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0Y2FtZXJhVlIuY2FtZXJhcy5sZW5ndGggPSAwO1xuXHRcdFx0XHRcdFx0Y2FtZXJhVlJOZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB2aWV3cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgdmlldyA9IHZpZXdzW2ldO1xuXHRcdFx0XHRcdFx0bGV0IHZpZXdwb3J0ID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0aWYgKGdsQmFzZUxheWVyICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHZpZXdwb3J0ID0gZ2xCYXNlTGF5ZXIuZ2V0Vmlld3BvcnQodmlldyk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBnbFN1YkltYWdlID0gZ2xCaW5kaW5nLmdldFZpZXdTdWJJbWFnZShnbFByb2pMYXllciwgdmlldyk7XG5cdFx0XHRcdFx0XHRcdHZpZXdwb3J0ID0gZ2xTdWJJbWFnZS52aWV3cG9ydDsgLy8gRm9yIHNpZGUtYnktc2lkZSBwcm9qZWN0aW9uLCB3ZSBvbmx5IHByb2R1Y2UgYSBzaW5nbGUgdGV4dHVyZSBmb3IgYm90aCBleWVzLlxuXG5cdFx0XHRcdFx0XHRcdGlmIChpID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0VGV4dHVyZXMobmV3UmVuZGVyVGFyZ2V0LCBnbFN1YkltYWdlLmNvbG9yVGV4dHVyZSwgZ2xQcm9qTGF5ZXIuaWdub3JlRGVwdGhWYWx1ZXMgPyB1bmRlZmluZWQgOiBnbFN1YkltYWdlLmRlcHRoU3RlbmNpbFRleHR1cmUpO1xuXHRcdFx0XHRcdFx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChuZXdSZW5kZXJUYXJnZXQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNvbnN0IGNhbWVyYSA9IGNhbWVyYXNbaV07XG5cdFx0XHRcdFx0XHRjYW1lcmEubWF0cml4LmZyb21BcnJheSh2aWV3LnRyYW5zZm9ybS5tYXRyaXgpO1xuXHRcdFx0XHRcdFx0Y2FtZXJhLnByb2plY3Rpb25NYXRyaXguZnJvbUFycmF5KHZpZXcucHJvamVjdGlvbk1hdHJpeCk7XG5cdFx0XHRcdFx0XHRjYW1lcmEudmlld3BvcnQuc2V0KHZpZXdwb3J0LngsIHZpZXdwb3J0LnksIHZpZXdwb3J0LndpZHRoLCB2aWV3cG9ydC5oZWlnaHQpO1xuXG5cdFx0XHRcdFx0XHRpZiAoaSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRjYW1lcmFWUi5tYXRyaXguY29weShjYW1lcmEubWF0cml4KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKGNhbWVyYVZSTmVlZHNVcGRhdGUgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0Y2FtZXJhVlIuY2FtZXJhcy5wdXNoKGNhbWVyYSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IC8vXG5cblxuXHRcdFx0XHRjb25zdCBpbnB1dFNvdXJjZXMgPSBzZXNzaW9uLmlucHV0U291cmNlcztcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRyb2xsZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgY29udHJvbGxlciA9IGNvbnRyb2xsZXJzW2ldO1xuXHRcdFx0XHRcdGNvbnN0IGlucHV0U291cmNlID0gaW5wdXRTb3VyY2VzW2ldO1xuXHRcdFx0XHRcdGNvbnRyb2xsZXIudXBkYXRlKGlucHV0U291cmNlLCBmcmFtZSwgcmVmZXJlbmNlU3BhY2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG9uQW5pbWF0aW9uRnJhbWVDYWxsYmFjaykgb25BbmltYXRpb25GcmFtZUNhbGxiYWNrKHRpbWUsIGZyYW1lKTtcblx0XHRcdFx0eHJGcmFtZSA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGFuaW1hdGlvbiA9IG5ldyBXZWJHTEFuaW1hdGlvbigpO1xuXHRcdFx0YW5pbWF0aW9uLnNldEFuaW1hdGlvbkxvb3Aob25BbmltYXRpb25GcmFtZSk7XG5cblx0XHRcdHRoaXMuc2V0QW5pbWF0aW9uTG9vcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0XHRvbkFuaW1hdGlvbkZyYW1lQ2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdH07XG5cblx0XHRcdHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHt9O1xuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gV2ViR0xNYXRlcmlhbHMocHJvcGVydGllcykge1xuXHRcdGZ1bmN0aW9uIHJlZnJlc2hGb2dVbmlmb3Jtcyh1bmlmb3JtcywgZm9nKSB7XG5cdFx0XHR1bmlmb3Jtcy5mb2dDb2xvci52YWx1ZS5jb3B5KGZvZy5jb2xvcik7XG5cblx0XHRcdGlmIChmb2cuaXNGb2cpIHtcblx0XHRcdFx0dW5pZm9ybXMuZm9nTmVhci52YWx1ZSA9IGZvZy5uZWFyO1xuXHRcdFx0XHR1bmlmb3Jtcy5mb2dGYXIudmFsdWUgPSBmb2cuZmFyO1xuXHRcdFx0fSBlbHNlIGlmIChmb2cuaXNGb2dFeHAyKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmZvZ0RlbnNpdHkudmFsdWUgPSBmb2cuZGVuc2l0eTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWZyZXNoTWF0ZXJpYWxVbmlmb3Jtcyh1bmlmb3JtcywgbWF0ZXJpYWwsIHBpeGVsUmF0aW8sIGhlaWdodCwgdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0KSB7XG5cdFx0XHRpZiAobWF0ZXJpYWwuaXNNZXNoQmFzaWNNYXRlcmlhbCkge1xuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24odW5pZm9ybXMsIG1hdGVyaWFsKTtcblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuaXNNZXNoTGFtYmVydE1hdGVyaWFsKSB7XG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbih1bmlmb3JtcywgbWF0ZXJpYWwpO1xuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNMYW1iZXJ0KHVuaWZvcm1zLCBtYXRlcmlhbCk7XG5cdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLmlzTWVzaFRvb25NYXRlcmlhbCkge1xuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24odW5pZm9ybXMsIG1hdGVyaWFsKTtcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zVG9vbih1bmlmb3JtcywgbWF0ZXJpYWwpO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5pc01lc2hQaG9uZ01hdGVyaWFsKSB7XG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbih1bmlmb3JtcywgbWF0ZXJpYWwpO1xuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNQaG9uZyh1bmlmb3JtcywgbWF0ZXJpYWwpO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsKSB7XG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbih1bmlmb3JtcywgbWF0ZXJpYWwpO1xuXG5cdFx0XHRcdGlmIChtYXRlcmlhbC5pc01lc2hQaHlzaWNhbE1hdGVyaWFsKSB7XG5cdFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zUGh5c2ljYWwodW5pZm9ybXMsIG1hdGVyaWFsLCB0cmFuc21pc3Npb25SZW5kZXJUYXJnZXQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc1N0YW5kYXJkKHVuaWZvcm1zLCBtYXRlcmlhbCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuaXNNZXNoTWF0Y2FwTWF0ZXJpYWwpIHtcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKHVuaWZvcm1zLCBtYXRlcmlhbCk7XG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc01hdGNhcCh1bmlmb3JtcywgbWF0ZXJpYWwpO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5pc01lc2hEZXB0aE1hdGVyaWFsKSB7XG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbih1bmlmb3JtcywgbWF0ZXJpYWwpO1xuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNEZXB0aCh1bmlmb3JtcywgbWF0ZXJpYWwpO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5pc01lc2hEaXN0YW5jZU1hdGVyaWFsKSB7XG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbih1bmlmb3JtcywgbWF0ZXJpYWwpO1xuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNEaXN0YW5jZSh1bmlmb3JtcywgbWF0ZXJpYWwpO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5pc01lc2hOb3JtYWxNYXRlcmlhbCkge1xuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24odW5pZm9ybXMsIG1hdGVyaWFsKTtcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTm9ybWFsKHVuaWZvcm1zLCBtYXRlcmlhbCk7XG5cdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLmlzTGluZUJhc2ljTWF0ZXJpYWwpIHtcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTGluZSh1bmlmb3JtcywgbWF0ZXJpYWwpO1xuXG5cdFx0XHRcdGlmIChtYXRlcmlhbC5pc0xpbmVEYXNoZWRNYXRlcmlhbCkge1xuXHRcdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0Rhc2godW5pZm9ybXMsIG1hdGVyaWFsKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5pc1BvaW50c01hdGVyaWFsKSB7XG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc1BvaW50cyh1bmlmb3JtcywgbWF0ZXJpYWwsIHBpeGVsUmF0aW8sIGhlaWdodCk7XG5cdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLmlzU3ByaXRlTWF0ZXJpYWwpIHtcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zU3ByaXRlcyh1bmlmb3JtcywgbWF0ZXJpYWwpO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5pc1NoYWRvd01hdGVyaWFsKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmNvbG9yLnZhbHVlLmNvcHkobWF0ZXJpYWwuY29sb3IpO1xuXHRcdFx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCkge1xuXHRcdFx0XHRtYXRlcmlhbC51bmlmb3Jtc05lZWRVcGRhdGUgPSBmYWxzZTsgLy8gIzE1NTgxXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zQ29tbW9uKHVuaWZvcm1zLCBtYXRlcmlhbCkge1xuXHRcdFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cblx0XHRcdGlmIChtYXRlcmlhbC5jb2xvcikge1xuXHRcdFx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlLmNvcHkobWF0ZXJpYWwuY29sb3IpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwuZW1pc3NpdmUpIHtcblx0XHRcdFx0dW5pZm9ybXMuZW1pc3NpdmUudmFsdWUuY29weShtYXRlcmlhbC5lbWlzc2l2ZSkubXVsdGlwbHlTY2FsYXIobWF0ZXJpYWwuZW1pc3NpdmVJbnRlbnNpdHkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwubWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLm1hcC52YWx1ZSA9IG1hdGVyaWFsLm1hcDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1hdGVyaWFsLmFscGhhTWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmFscGhhTWFwLnZhbHVlID0gbWF0ZXJpYWwuYWxwaGFNYXA7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC5zcGVjdWxhck1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5zcGVjdWxhck1hcC52YWx1ZSA9IG1hdGVyaWFsLnNwZWN1bGFyTWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwuYWxwaGFUZXN0ID4gMCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5hbHBoYVRlc3QudmFsdWUgPSBtYXRlcmlhbC5hbHBoYVRlc3Q7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGVudk1hcCA9IHByb3BlcnRpZXMuZ2V0KG1hdGVyaWFsKS5lbnZNYXA7XG5cblx0XHRcdGlmIChlbnZNYXApIHtcblx0XHRcdFx0dW5pZm9ybXMuZW52TWFwLnZhbHVlID0gZW52TWFwO1xuXHRcdFx0XHR1bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlID0gZW52TWFwLmlzQ3ViZVRleHR1cmUgJiYgZW52TWFwLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9PT0gZmFsc2UgPyAtMSA6IDE7XG5cdFx0XHRcdHVuaWZvcm1zLnJlZmxlY3Rpdml0eS52YWx1ZSA9IG1hdGVyaWFsLnJlZmxlY3Rpdml0eTtcblx0XHRcdFx0dW5pZm9ybXMuaW9yLnZhbHVlID0gbWF0ZXJpYWwuaW9yO1xuXHRcdFx0XHR1bmlmb3Jtcy5yZWZyYWN0aW9uUmF0aW8udmFsdWUgPSBtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW87XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC5saWdodE1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5saWdodE1hcC52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwO1xuXHRcdFx0XHR1bmlmb3Jtcy5saWdodE1hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwuYW9NYXApIHtcblx0XHRcdFx0dW5pZm9ybXMuYW9NYXAudmFsdWUgPSBtYXRlcmlhbC5hb01hcDtcblx0XHRcdFx0dW5pZm9ybXMuYW9NYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5hb01hcEludGVuc2l0eTtcblx0XHRcdH0gLy8gdXYgcmVwZWF0IGFuZCBvZmZzZXQgc2V0dGluZyBwcmlvcml0aWVzXG5cdFx0XHQvLyAxLiBjb2xvciBtYXBcblx0XHRcdC8vIDIuIHNwZWN1bGFyIG1hcFxuXHRcdFx0Ly8gMy4gZGlzcGxhY2VtZW50TWFwIG1hcFxuXHRcdFx0Ly8gNC4gbm9ybWFsIG1hcFxuXHRcdFx0Ly8gNS4gYnVtcCBtYXBcblx0XHRcdC8vIDYuIHJvdWdobmVzc01hcCBtYXBcblx0XHRcdC8vIDcuIG1ldGFsbmVzc01hcCBtYXBcblx0XHRcdC8vIDguIGFscGhhTWFwIG1hcFxuXHRcdFx0Ly8gOS4gZW1pc3NpdmVNYXAgbWFwXG5cdFx0XHQvLyAxMC4gY2xlYXJjb2F0IG1hcFxuXHRcdFx0Ly8gMTEuIGNsZWFyY29hdCBub3JtYWwgbWFwXG5cdFx0XHQvLyAxMi4gY2xlYXJjb2F0IHJvdWdobmVzc01hcCBtYXBcblx0XHRcdC8vIDEzLiBzcGVjdWxhciBpbnRlbnNpdHkgbWFwXG5cdFx0XHQvLyAxNC4gc3BlY3VsYXIgdGludCBtYXBcblx0XHRcdC8vIDE1LiB0cmFuc21pc3Npb24gbWFwXG5cdFx0XHQvLyAxNi4gdGhpY2tuZXNzIG1hcFxuXG5cblx0XHRcdGxldCB1dlNjYWxlTWFwO1xuXG5cdFx0XHRpZiAobWF0ZXJpYWwubWFwKSB7XG5cdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5tYXA7XG5cdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLnNwZWN1bGFyTWFwKSB7XG5cdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5zcGVjdWxhck1hcDtcblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwKSB7XG5cdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLm5vcm1hbE1hcCkge1xuXHRcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5idW1wTWFwKSB7XG5cdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5idW1wTWFwO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5yb3VnaG5lc3NNYXApIHtcblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLnJvdWdobmVzc01hcDtcblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwubWV0YWxuZXNzTWFwKSB7XG5cdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5tZXRhbG5lc3NNYXA7XG5cdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLmFscGhhTWFwKSB7XG5cdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5hbHBoYU1hcDtcblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuZW1pc3NpdmVNYXApIHtcblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5jbGVhcmNvYXRNYXApIHtcblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmNsZWFyY29hdE1hcDtcblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsTWFwKSB7XG5cdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxNYXA7XG5cdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzc01hcCkge1xuXHRcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzTWFwO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbC5zcGVjdWxhckludGVuc2l0eU1hcCkge1xuXHRcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuc3BlY3VsYXJJbnRlbnNpdHlNYXA7XG5cdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLnNwZWN1bGFyQ29sb3JNYXApIHtcblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLnNwZWN1bGFyQ29sb3JNYXA7XG5cdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLnRyYW5zbWlzc2lvbk1hcCkge1xuXHRcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwudHJhbnNtaXNzaW9uTWFwO1xuXHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbC50aGlja25lc3NNYXApIHtcblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLnRoaWNrbmVzc01hcDtcblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuc2hlZW5Db2xvck1hcCkge1xuXHRcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuc2hlZW5Db2xvck1hcDtcblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3NNYXApIHtcblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzTWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodXZTY2FsZU1hcCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdGlmICh1dlNjYWxlTWFwLmlzV2ViR0xSZW5kZXJUYXJnZXQpIHtcblx0XHRcdFx0XHR1dlNjYWxlTWFwID0gdXZTY2FsZU1hcC50ZXh0dXJlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHV2U2NhbGVNYXAubWF0cml4QXV0b1VwZGF0ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdHV2U2NhbGVNYXAudXBkYXRlTWF0cml4KCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR1bmlmb3Jtcy51dlRyYW5zZm9ybS52YWx1ZS5jb3B5KHV2U2NhbGVNYXAubWF0cml4KTtcblx0XHRcdH0gLy8gdXYgcmVwZWF0IGFuZCBvZmZzZXQgc2V0dGluZyBwcmlvcml0aWVzIGZvciB1djJcblx0XHRcdC8vIDEuIGFvIG1hcFxuXHRcdFx0Ly8gMi4gbGlnaHQgbWFwXG5cblxuXHRcdFx0bGV0IHV2MlNjYWxlTWFwO1xuXG5cdFx0XHRpZiAobWF0ZXJpYWwuYW9NYXApIHtcblx0XHRcdFx0dXYyU2NhbGVNYXAgPSBtYXRlcmlhbC5hb01hcDtcblx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWwubGlnaHRNYXApIHtcblx0XHRcdFx0dXYyU2NhbGVNYXAgPSBtYXRlcmlhbC5saWdodE1hcDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHV2MlNjYWxlTWFwICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Ly8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdFx0aWYgKHV2MlNjYWxlTWFwLmlzV2ViR0xSZW5kZXJUYXJnZXQpIHtcblx0XHRcdFx0XHR1djJTY2FsZU1hcCA9IHV2MlNjYWxlTWFwLnRleHR1cmU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodXYyU2NhbGVNYXAubWF0cml4QXV0b1VwZGF0ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdHV2MlNjYWxlTWFwLnVwZGF0ZU1hdHJpeCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dW5pZm9ybXMudXYyVHJhbnNmb3JtLnZhbHVlLmNvcHkodXYyU2NhbGVNYXAubWF0cml4KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNMaW5lKHVuaWZvcm1zLCBtYXRlcmlhbCkge1xuXHRcdFx0dW5pZm9ybXMuZGlmZnVzZS52YWx1ZS5jb3B5KG1hdGVyaWFsLmNvbG9yKTtcblx0XHRcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0Rhc2godW5pZm9ybXMsIG1hdGVyaWFsKSB7XG5cdFx0XHR1bmlmb3Jtcy5kYXNoU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplO1xuXHRcdFx0dW5pZm9ybXMudG90YWxTaXplLnZhbHVlID0gbWF0ZXJpYWwuZGFzaFNpemUgKyBtYXRlcmlhbC5nYXBTaXplO1xuXHRcdFx0dW5pZm9ybXMuc2NhbGUudmFsdWUgPSBtYXRlcmlhbC5zY2FsZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQb2ludHModW5pZm9ybXMsIG1hdGVyaWFsLCBwaXhlbFJhdGlvLCBoZWlnaHQpIHtcblx0XHRcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUuY29weShtYXRlcmlhbC5jb2xvcik7XG5cdFx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblx0XHRcdHVuaWZvcm1zLnNpemUudmFsdWUgPSBtYXRlcmlhbC5zaXplICogcGl4ZWxSYXRpbztcblx0XHRcdHVuaWZvcm1zLnNjYWxlLnZhbHVlID0gaGVpZ2h0ICogMC41O1xuXG5cdFx0XHRpZiAobWF0ZXJpYWwubWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLm1hcC52YWx1ZSA9IG1hdGVyaWFsLm1hcDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1hdGVyaWFsLmFscGhhTWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmFscGhhTWFwLnZhbHVlID0gbWF0ZXJpYWwuYWxwaGFNYXA7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC5hbHBoYVRlc3QgPiAwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmFscGhhVGVzdC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhVGVzdDtcblx0XHRcdH0gLy8gdXYgcmVwZWF0IGFuZCBvZmZzZXQgc2V0dGluZyBwcmlvcml0aWVzXG5cdFx0XHQvLyAxLiBjb2xvciBtYXBcblx0XHRcdC8vIDIuIGFscGhhIG1hcFxuXG5cblx0XHRcdGxldCB1dlNjYWxlTWFwO1xuXG5cdFx0XHRpZiAobWF0ZXJpYWwubWFwKSB7XG5cdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5tYXA7XG5cdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLmFscGhhTWFwKSB7XG5cdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5hbHBoYU1hcDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHV2U2NhbGVNYXAgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAodXZTY2FsZU1hcC5tYXRyaXhBdXRvVXBkYXRlID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0dXZTY2FsZU1hcC51cGRhdGVNYXRyaXgoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHVuaWZvcm1zLnV2VHJhbnNmb3JtLnZhbHVlLmNvcHkodXZTY2FsZU1hcC5tYXRyaXgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1Nwcml0ZXModW5pZm9ybXMsIG1hdGVyaWFsKSB7XG5cdFx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlLmNvcHkobWF0ZXJpYWwuY29sb3IpO1xuXHRcdFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cdFx0XHR1bmlmb3Jtcy5yb3RhdGlvbi52YWx1ZSA9IG1hdGVyaWFsLnJvdGF0aW9uO1xuXG5cdFx0XHRpZiAobWF0ZXJpYWwubWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLm1hcC52YWx1ZSA9IG1hdGVyaWFsLm1hcDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1hdGVyaWFsLmFscGhhTWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmFscGhhTWFwLnZhbHVlID0gbWF0ZXJpYWwuYWxwaGFNYXA7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC5hbHBoYVRlc3QgPiAwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmFscGhhVGVzdC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhVGVzdDtcblx0XHRcdH0gLy8gdXYgcmVwZWF0IGFuZCBvZmZzZXQgc2V0dGluZyBwcmlvcml0aWVzXG5cdFx0XHQvLyAxLiBjb2xvciBtYXBcblx0XHRcdC8vIDIuIGFscGhhIG1hcFxuXG5cblx0XHRcdGxldCB1dlNjYWxlTWFwO1xuXG5cdFx0XHRpZiAobWF0ZXJpYWwubWFwKSB7XG5cdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5tYXA7XG5cdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLmFscGhhTWFwKSB7XG5cdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5hbHBoYU1hcDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHV2U2NhbGVNYXAgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAodXZTY2FsZU1hcC5tYXRyaXhBdXRvVXBkYXRlID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0dXZTY2FsZU1hcC51cGRhdGVNYXRyaXgoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHVuaWZvcm1zLnV2VHJhbnNmb3JtLnZhbHVlLmNvcHkodXZTY2FsZU1hcC5tYXRyaXgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xhbWJlcnQodW5pZm9ybXMsIG1hdGVyaWFsKSB7XG5cdFx0XHRpZiAobWF0ZXJpYWwuZW1pc3NpdmVNYXApIHtcblx0XHRcdFx0dW5pZm9ybXMuZW1pc3NpdmVNYXAudmFsdWUgPSBtYXRlcmlhbC5lbWlzc2l2ZU1hcDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQaG9uZyh1bmlmb3JtcywgbWF0ZXJpYWwpIHtcblx0XHRcdHVuaWZvcm1zLnNwZWN1bGFyLnZhbHVlLmNvcHkobWF0ZXJpYWwuc3BlY3VsYXIpO1xuXHRcdFx0dW5pZm9ybXMuc2hpbmluZXNzLnZhbHVlID0gTWF0aC5tYXgobWF0ZXJpYWwuc2hpbmluZXNzLCAxZS00KTsgLy8gdG8gcHJldmVudCBwb3coIDAuMCwgMC4wIClcblxuXHRcdFx0aWYgKG1hdGVyaWFsLmVtaXNzaXZlTWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlTWFwLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC5idW1wTWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmJ1bXBNYXAudmFsdWUgPSBtYXRlcmlhbC5idW1wTWFwO1xuXHRcdFx0XHR1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgPSBtYXRlcmlhbC5idW1wU2NhbGU7XG5cdFx0XHRcdGlmIChtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSkgdW5pZm9ybXMuYnVtcFNjYWxlLnZhbHVlICo9IC0xO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwubm9ybWFsTWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLm5vcm1hbE1hcC52YWx1ZSA9IG1hdGVyaWFsLm5vcm1hbE1hcDtcblx0XHRcdFx0dW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUuY29weShtYXRlcmlhbC5ub3JtYWxTY2FsZSk7XG5cdFx0XHRcdGlmIChtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSkgdW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUubmVnYXRlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXApIHtcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50Qmlhcztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNUb29uKHVuaWZvcm1zLCBtYXRlcmlhbCkge1xuXHRcdFx0aWYgKG1hdGVyaWFsLmdyYWRpZW50TWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmdyYWRpZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZ3JhZGllbnRNYXA7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC5lbWlzc2l2ZU1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5lbWlzc2l2ZU1hcC52YWx1ZSA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwuYnVtcE1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5idW1wTWFwLnZhbHVlID0gbWF0ZXJpYWwuYnVtcE1hcDtcblx0XHRcdFx0dW5pZm9ybXMuYnVtcFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuYnVtcFNjYWxlO1xuXHRcdFx0XHRpZiAobWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUpIHVuaWZvcm1zLmJ1bXBTY2FsZS52YWx1ZSAqPSAtMTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1hdGVyaWFsLm5vcm1hbE1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5ub3JtYWxNYXAudmFsdWUgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLm5vcm1hbFNjYWxlLnZhbHVlLmNvcHkobWF0ZXJpYWwubm9ybWFsU2NhbGUpO1xuXHRcdFx0XHRpZiAobWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUpIHVuaWZvcm1zLm5vcm1hbFNjYWxlLnZhbHVlLm5lZ2F0ZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zU3RhbmRhcmQodW5pZm9ybXMsIG1hdGVyaWFsKSB7XG5cdFx0XHR1bmlmb3Jtcy5yb3VnaG5lc3MudmFsdWUgPSBtYXRlcmlhbC5yb3VnaG5lc3M7XG5cdFx0XHR1bmlmb3Jtcy5tZXRhbG5lc3MudmFsdWUgPSBtYXRlcmlhbC5tZXRhbG5lc3M7XG5cblx0XHRcdGlmIChtYXRlcmlhbC5yb3VnaG5lc3NNYXApIHtcblx0XHRcdFx0dW5pZm9ybXMucm91Z2huZXNzTWFwLnZhbHVlID0gbWF0ZXJpYWwucm91Z2huZXNzTWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwubWV0YWxuZXNzTWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLm1ldGFsbmVzc01hcC52YWx1ZSA9IG1hdGVyaWFsLm1ldGFsbmVzc01hcDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1hdGVyaWFsLmVtaXNzaXZlTWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlTWFwLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC5idW1wTWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmJ1bXBNYXAudmFsdWUgPSBtYXRlcmlhbC5idW1wTWFwO1xuXHRcdFx0XHR1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgPSBtYXRlcmlhbC5idW1wU2NhbGU7XG5cdFx0XHRcdGlmIChtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSkgdW5pZm9ybXMuYnVtcFNjYWxlLnZhbHVlICo9IC0xO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwubm9ybWFsTWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLm5vcm1hbE1hcC52YWx1ZSA9IG1hdGVyaWFsLm5vcm1hbE1hcDtcblx0XHRcdFx0dW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUuY29weShtYXRlcmlhbC5ub3JtYWxTY2FsZSk7XG5cdFx0XHRcdGlmIChtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSkgdW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUubmVnYXRlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXApIHtcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50Qmlhcztcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZW52TWFwID0gcHJvcGVydGllcy5nZXQobWF0ZXJpYWwpLmVudk1hcDtcblxuXHRcdFx0aWYgKGVudk1hcCkge1xuXHRcdFx0XHQvL3VuaWZvcm1zLmVudk1hcC52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcDsgLy8gcGFydCBvZiB1bmlmb3JtcyBjb21tb25cblx0XHRcdFx0dW5pZm9ybXMuZW52TWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwuZW52TWFwSW50ZW5zaXR5O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1BoeXNpY2FsKHVuaWZvcm1zLCBtYXRlcmlhbCwgdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0KSB7XG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNTdGFuZGFyZCh1bmlmb3JtcywgbWF0ZXJpYWwpO1xuXHRcdFx0dW5pZm9ybXMuaW9yLnZhbHVlID0gbWF0ZXJpYWwuaW9yOyAvLyBhbHNvIHBhcnQgb2YgdW5pZm9ybXMgY29tbW9uXG5cblx0XHRcdGlmIChtYXRlcmlhbC5zaGVlbiA+IDApIHtcblx0XHRcdFx0dW5pZm9ybXMuc2hlZW5Db2xvci52YWx1ZS5jb3B5KG1hdGVyaWFsLnNoZWVuQ29sb3IpLm11bHRpcGx5U2NhbGFyKG1hdGVyaWFsLnNoZWVuKTtcblx0XHRcdFx0dW5pZm9ybXMuc2hlZW5Sb3VnaG5lc3MudmFsdWUgPSBtYXRlcmlhbC5zaGVlblJvdWdobmVzcztcblxuXHRcdFx0XHRpZiAobWF0ZXJpYWwuc2hlZW5Db2xvck1hcCkge1xuXHRcdFx0XHRcdHVuaWZvcm1zLnNoZWVuQ29sb3JNYXAudmFsdWUgPSBtYXRlcmlhbC5zaGVlbkNvbG9yTWFwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzTWFwKSB7XG5cdFx0XHRcdFx0dW5pZm9ybXMuc2hlZW5Sb3VnaG5lc3NNYXAudmFsdWUgPSBtYXRlcmlhbC5zaGVlblJvdWdobmVzc01hcDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwuY2xlYXJjb2F0ID4gMCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5jbGVhcmNvYXQudmFsdWUgPSBtYXRlcmlhbC5jbGVhcmNvYXQ7XG5cdFx0XHRcdHVuaWZvcm1zLmNsZWFyY29hdFJvdWdobmVzcy52YWx1ZSA9IG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcztcblxuXHRcdFx0XHRpZiAobWF0ZXJpYWwuY2xlYXJjb2F0TWFwKSB7XG5cdFx0XHRcdFx0dW5pZm9ybXMuY2xlYXJjb2F0TWFwLnZhbHVlID0gbWF0ZXJpYWwuY2xlYXJjb2F0TWFwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzc01hcCkge1xuXHRcdFx0XHRcdHVuaWZvcm1zLmNsZWFyY29hdFJvdWdobmVzc01hcC52YWx1ZSA9IG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzc01hcDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChtYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxNYXApIHtcblx0XHRcdFx0XHR1bmlmb3Jtcy5jbGVhcmNvYXROb3JtYWxTY2FsZS52YWx1ZS5jb3B5KG1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbFNjYWxlKTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5jbGVhcmNvYXROb3JtYWxNYXAudmFsdWUgPSBtYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxNYXA7XG5cblx0XHRcdFx0XHRpZiAobWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUpIHtcblx0XHRcdFx0XHRcdHVuaWZvcm1zLmNsZWFyY29hdE5vcm1hbFNjYWxlLnZhbHVlLm5lZ2F0ZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwudHJhbnNtaXNzaW9uID4gMCkge1xuXHRcdFx0XHR1bmlmb3Jtcy50cmFuc21pc3Npb24udmFsdWUgPSBtYXRlcmlhbC50cmFuc21pc3Npb247XG5cdFx0XHRcdHVuaWZvcm1zLnRyYW5zbWlzc2lvblNhbXBsZXJNYXAudmFsdWUgPSB0cmFuc21pc3Npb25SZW5kZXJUYXJnZXQudGV4dHVyZTtcblx0XHRcdFx0dW5pZm9ybXMudHJhbnNtaXNzaW9uU2FtcGxlclNpemUudmFsdWUuc2V0KHRyYW5zbWlzc2lvblJlbmRlclRhcmdldC53aWR0aCwgdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0LmhlaWdodCk7XG5cblx0XHRcdFx0aWYgKG1hdGVyaWFsLnRyYW5zbWlzc2lvbk1hcCkge1xuXHRcdFx0XHRcdHVuaWZvcm1zLnRyYW5zbWlzc2lvbk1hcC52YWx1ZSA9IG1hdGVyaWFsLnRyYW5zbWlzc2lvbk1hcDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHVuaWZvcm1zLnRoaWNrbmVzcy52YWx1ZSA9IG1hdGVyaWFsLnRoaWNrbmVzcztcblxuXHRcdFx0XHRpZiAobWF0ZXJpYWwudGhpY2tuZXNzTWFwKSB7XG5cdFx0XHRcdFx0dW5pZm9ybXMudGhpY2tuZXNzTWFwLnZhbHVlID0gbWF0ZXJpYWwudGhpY2tuZXNzTWFwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dW5pZm9ybXMuYXR0ZW51YXRpb25EaXN0YW5jZS52YWx1ZSA9IG1hdGVyaWFsLmF0dGVudWF0aW9uRGlzdGFuY2U7XG5cdFx0XHRcdHVuaWZvcm1zLmF0dGVudWF0aW9uQ29sb3IudmFsdWUuY29weShtYXRlcmlhbC5hdHRlbnVhdGlvbkNvbG9yKTtcblx0XHRcdH1cblxuXHRcdFx0dW5pZm9ybXMuc3BlY3VsYXJJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhckludGVuc2l0eTtcblx0XHRcdHVuaWZvcm1zLnNwZWN1bGFyQ29sb3IudmFsdWUuY29weShtYXRlcmlhbC5zcGVjdWxhckNvbG9yKTtcblxuXHRcdFx0aWYgKG1hdGVyaWFsLnNwZWN1bGFySW50ZW5zaXR5TWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLnNwZWN1bGFySW50ZW5zaXR5TWFwLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXJJbnRlbnNpdHlNYXA7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC5zcGVjdWxhckNvbG9yTWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLnNwZWN1bGFyQ29sb3JNYXAudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhckNvbG9yTWFwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc01hdGNhcCh1bmlmb3JtcywgbWF0ZXJpYWwpIHtcblx0XHRcdGlmIChtYXRlcmlhbC5tYXRjYXApIHtcblx0XHRcdFx0dW5pZm9ybXMubWF0Y2FwLnZhbHVlID0gbWF0ZXJpYWwubWF0Y2FwO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwuYnVtcE1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5idW1wTWFwLnZhbHVlID0gbWF0ZXJpYWwuYnVtcE1hcDtcblx0XHRcdFx0dW5pZm9ybXMuYnVtcFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuYnVtcFNjYWxlO1xuXHRcdFx0XHRpZiAobWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUpIHVuaWZvcm1zLmJ1bXBTY2FsZS52YWx1ZSAqPSAtMTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1hdGVyaWFsLm5vcm1hbE1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5ub3JtYWxNYXAudmFsdWUgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLm5vcm1hbFNjYWxlLnZhbHVlLmNvcHkobWF0ZXJpYWwubm9ybWFsU2NhbGUpO1xuXHRcdFx0XHRpZiAobWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUpIHVuaWZvcm1zLm5vcm1hbFNjYWxlLnZhbHVlLm5lZ2F0ZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zRGVwdGgodW5pZm9ybXMsIG1hdGVyaWFsKSB7XG5cdFx0XHRpZiAobWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zRGlzdGFuY2UodW5pZm9ybXMsIG1hdGVyaWFsKSB7XG5cdFx0XHRpZiAobWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XG5cdFx0XHR9XG5cblx0XHRcdHVuaWZvcm1zLnJlZmVyZW5jZVBvc2l0aW9uLnZhbHVlLmNvcHkobWF0ZXJpYWwucmVmZXJlbmNlUG9zaXRpb24pO1xuXHRcdFx0dW5pZm9ybXMubmVhckRpc3RhbmNlLnZhbHVlID0gbWF0ZXJpYWwubmVhckRpc3RhbmNlO1xuXHRcdFx0dW5pZm9ybXMuZmFyRGlzdGFuY2UudmFsdWUgPSBtYXRlcmlhbC5mYXJEaXN0YW5jZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNOb3JtYWwodW5pZm9ybXMsIG1hdGVyaWFsKSB7XG5cdFx0XHRpZiAobWF0ZXJpYWwuYnVtcE1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5idW1wTWFwLnZhbHVlID0gbWF0ZXJpYWwuYnVtcE1hcDtcblx0XHRcdFx0dW5pZm9ybXMuYnVtcFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuYnVtcFNjYWxlO1xuXHRcdFx0XHRpZiAobWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUpIHVuaWZvcm1zLmJ1bXBTY2FsZS52YWx1ZSAqPSAtMTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1hdGVyaWFsLm5vcm1hbE1hcCkge1xuXHRcdFx0XHR1bmlmb3Jtcy5ub3JtYWxNYXAudmFsdWUgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLm5vcm1hbFNjYWxlLnZhbHVlLmNvcHkobWF0ZXJpYWwubm9ybWFsU2NhbGUpO1xuXHRcdFx0XHRpZiAobWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUpIHVuaWZvcm1zLm5vcm1hbFNjYWxlLnZhbHVlLm5lZ2F0ZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwKSB7XG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHJlZnJlc2hGb2dVbmlmb3JtczogcmVmcmVzaEZvZ1VuaWZvcm1zLFxuXHRcdFx0cmVmcmVzaE1hdGVyaWFsVW5pZm9ybXM6IHJlZnJlc2hNYXRlcmlhbFVuaWZvcm1zXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUNhbnZhc0VsZW1lbnQoKSB7XG5cdFx0Y29uc3QgY2FudmFzID0gY3JlYXRlRWxlbWVudE5TKCdjYW52YXMnKTtcblx0XHRjYW52YXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cdFx0cmV0dXJuIGNhbnZhcztcblx0fVxuXG5cdGZ1bmN0aW9uIFdlYkdMUmVuZGVyZXIocGFyYW1ldGVycyA9IHt9KSB7XG5cdFx0Y29uc3QgX2NhbnZhcyA9IHBhcmFtZXRlcnMuY2FudmFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmNhbnZhcyA6IGNyZWF0ZUNhbnZhc0VsZW1lbnQoKSxcblx0XHRcdFx0XHRfY29udGV4dCA9IHBhcmFtZXRlcnMuY29udGV4dCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5jb250ZXh0IDogbnVsbCxcblx0XHRcdFx0XHRfYWxwaGEgPSBwYXJhbWV0ZXJzLmFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFscGhhIDogZmFsc2UsXG5cdFx0XHRcdFx0X2RlcHRoID0gcGFyYW1ldGVycy5kZXB0aCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5kZXB0aCA6IHRydWUsXG5cdFx0XHRcdFx0X3N0ZW5jaWwgPSBwYXJhbWV0ZXJzLnN0ZW5jaWwgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc3RlbmNpbCA6IHRydWUsXG5cdFx0XHRcdFx0X2FudGlhbGlhcyA9IHBhcmFtZXRlcnMuYW50aWFsaWFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFudGlhbGlhcyA6IGZhbHNlLFxuXHRcdFx0XHRcdF9wcmVtdWx0aXBsaWVkQWxwaGEgPSBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgOiB0cnVlLFxuXHRcdFx0XHRcdF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBwYXJhbWV0ZXJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgOiBmYWxzZSxcblx0XHRcdFx0XHRfcG93ZXJQcmVmZXJlbmNlID0gcGFyYW1ldGVycy5wb3dlclByZWZlcmVuY2UgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucG93ZXJQcmVmZXJlbmNlIDogJ2RlZmF1bHQnLFxuXHRcdFx0XHRcdF9mYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0ID0gcGFyYW1ldGVycy5mYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQgOiBmYWxzZTtcblxuXHRcdGxldCBjdXJyZW50UmVuZGVyTGlzdCA9IG51bGw7XG5cdFx0bGV0IGN1cnJlbnRSZW5kZXJTdGF0ZSA9IG51bGw7IC8vIHJlbmRlcigpIGNhbiBiZSBjYWxsZWQgZnJvbSB3aXRoaW4gYSBjYWxsYmFjayB0cmlnZ2VyZWQgYnkgYW5vdGhlciByZW5kZXIuXG5cdFx0Ly8gV2UgdHJhY2sgdGhpcyBzbyB0aGF0IHRoZSBuZXN0ZWQgcmVuZGVyIGNhbGwgZ2V0cyBpdHMgbGlzdCBhbmQgc3RhdGUgaXNvbGF0ZWQgZnJvbSB0aGUgcGFyZW50IHJlbmRlciBjYWxsLlxuXG5cdFx0Y29uc3QgcmVuZGVyTGlzdFN0YWNrID0gW107XG5cdFx0Y29uc3QgcmVuZGVyU3RhdGVTdGFjayA9IFtdOyAvLyBwdWJsaWMgcHJvcGVydGllc1xuXG5cdFx0dGhpcy5kb21FbGVtZW50ID0gX2NhbnZhczsgLy8gRGVidWcgY29uZmlndXJhdGlvbiBjb250YWluZXJcblxuXHRcdHRoaXMuZGVidWcgPSB7XG5cdFx0XHQvKipcblx0XHRcdCAqIEVuYWJsZXMgZXJyb3IgY2hlY2tpbmcgYW5kIHJlcG9ydGluZyB3aGVuIHNoYWRlciBwcm9ncmFtcyBhcmUgYmVpbmcgY29tcGlsZWRcblx0XHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdFx0ICovXG5cdFx0XHRjaGVja1NoYWRlckVycm9yczogdHJ1ZVxuXHRcdH07IC8vIGNsZWFyaW5nXG5cblx0XHR0aGlzLmF1dG9DbGVhciA9IHRydWU7XG5cdFx0dGhpcy5hdXRvQ2xlYXJDb2xvciA9IHRydWU7XG5cdFx0dGhpcy5hdXRvQ2xlYXJEZXB0aCA9IHRydWU7XG5cdFx0dGhpcy5hdXRvQ2xlYXJTdGVuY2lsID0gdHJ1ZTsgLy8gc2NlbmUgZ3JhcGhcblxuXHRcdHRoaXMuc29ydE9iamVjdHMgPSB0cnVlOyAvLyB1c2VyLWRlZmluZWQgY2xpcHBpbmdcblxuXHRcdHRoaXMuY2xpcHBpbmdQbGFuZXMgPSBbXTtcblx0XHR0aGlzLmxvY2FsQ2xpcHBpbmdFbmFibGVkID0gZmFsc2U7IC8vIHBoeXNpY2FsbHkgYmFzZWQgc2hhZGluZ1xuXG5cdFx0dGhpcy5nYW1tYUZhY3RvciA9IDIuMDsgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cblx0XHR0aGlzLm91dHB1dEVuY29kaW5nID0gTGluZWFyRW5jb2Rpbmc7IC8vIHBoeXNpY2FsIGxpZ2h0c1xuXG5cdFx0dGhpcy5waHlzaWNhbGx5Q29ycmVjdExpZ2h0cyA9IGZhbHNlOyAvLyB0b25lIG1hcHBpbmdcblxuXHRcdHRoaXMudG9uZU1hcHBpbmcgPSBOb1RvbmVNYXBwaW5nO1xuXHRcdHRoaXMudG9uZU1hcHBpbmdFeHBvc3VyZSA9IDEuMDsgLy8gaW50ZXJuYWwgcHJvcGVydGllc1xuXG5cdFx0Y29uc3QgX3RoaXMgPSB0aGlzO1xuXG5cdFx0bGV0IF9pc0NvbnRleHRMb3N0ID0gZmFsc2U7IC8vIGludGVybmFsIHN0YXRlIGNhY2hlXG5cblx0XHRsZXQgX2N1cnJlbnRBY3RpdmVDdWJlRmFjZSA9IDA7XG5cdFx0bGV0IF9jdXJyZW50QWN0aXZlTWlwbWFwTGV2ZWwgPSAwO1xuXHRcdGxldCBfY3VycmVudFJlbmRlclRhcmdldCA9IG51bGw7XG5cblx0XHRsZXQgX2N1cnJlbnRNYXRlcmlhbElkID0gLTE7XG5cblx0XHRsZXQgX2N1cnJlbnRDYW1lcmEgPSBudWxsO1xuXG5cdFx0Y29uc3QgX2N1cnJlbnRWaWV3cG9ydCA9IG5ldyBWZWN0b3I0KCk7XG5cblx0XHRjb25zdCBfY3VycmVudFNjaXNzb3IgPSBuZXcgVmVjdG9yNCgpO1xuXG5cdFx0bGV0IF9jdXJyZW50U2Npc3NvclRlc3QgPSBudWxsOyAvL1xuXG5cdFx0bGV0IF93aWR0aCA9IF9jYW52YXMud2lkdGg7XG5cdFx0bGV0IF9oZWlnaHQgPSBfY2FudmFzLmhlaWdodDtcblx0XHRsZXQgX3BpeGVsUmF0aW8gPSAxO1xuXHRcdGxldCBfb3BhcXVlU29ydCA9IG51bGw7XG5cdFx0bGV0IF90cmFuc3BhcmVudFNvcnQgPSBudWxsO1xuXG5cdFx0Y29uc3QgX3ZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoMCwgMCwgX3dpZHRoLCBfaGVpZ2h0KTtcblxuXHRcdGNvbnN0IF9zY2lzc29yID0gbmV3IFZlY3RvcjQoMCwgMCwgX3dpZHRoLCBfaGVpZ2h0KTtcblxuXHRcdGxldCBfc2Npc3NvclRlc3QgPSBmYWxzZTsgLy9cblxuXHRcdGNvbnN0IF9jdXJyZW50RHJhd0J1ZmZlcnMgPSBbXTsgLy8gZnJ1c3R1bVxuXG5cdFx0Y29uc3QgX2ZydXN0dW0gPSBuZXcgRnJ1c3R1bSgpOyAvLyBjbGlwcGluZ1xuXG5cblx0XHRsZXQgX2NsaXBwaW5nRW5hYmxlZCA9IGZhbHNlO1xuXHRcdGxldCBfbG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBmYWxzZTsgLy8gdHJhbnNtaXNzaW9uXG5cblx0XHRsZXQgX3RyYW5zbWlzc2lvblJlbmRlclRhcmdldCA9IG51bGw7IC8vIGNhbWVyYSBtYXRyaWNlcyBjYWNoZVxuXG5cdFx0Y29uc3QgX3Byb2pTY3JlZW5NYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0Y29uc3QgX3ZlY3RvcjMgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Y29uc3QgX2VtcHR5U2NlbmUgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kOiBudWxsLFxuXHRcdFx0Zm9nOiBudWxsLFxuXHRcdFx0ZW52aXJvbm1lbnQ6IG51bGwsXG5cdFx0XHRvdmVycmlkZU1hdGVyaWFsOiBudWxsLFxuXHRcdFx0aXNTY2VuZTogdHJ1ZVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRUYXJnZXRQaXhlbFJhdGlvKCkge1xuXHRcdFx0cmV0dXJuIF9jdXJyZW50UmVuZGVyVGFyZ2V0ID09PSBudWxsID8gX3BpeGVsUmF0aW8gOiAxO1xuXHRcdH0gLy8gaW5pdGlhbGl6ZVxuXG5cblx0XHRsZXQgX2dsID0gX2NvbnRleHQ7XG5cblx0XHRmdW5jdGlvbiBnZXRDb250ZXh0KGNvbnRleHROYW1lcywgY29udGV4dEF0dHJpYnV0ZXMpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY29udGV4dE5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGNvbnRleHROYW1lID0gY29udGV4dE5hbWVzW2ldO1xuXG5cdFx0XHRcdGNvbnN0IGNvbnRleHQgPSBfY2FudmFzLmdldENvbnRleHQoY29udGV4dE5hbWUsIGNvbnRleHRBdHRyaWJ1dGVzKTtcblxuXHRcdFx0XHRpZiAoY29udGV4dCAhPT0gbnVsbCkgcmV0dXJuIGNvbnRleHQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBjb250ZXh0QXR0cmlidXRlcyA9IHtcblx0XHRcdFx0YWxwaGE6IF9hbHBoYSxcblx0XHRcdFx0ZGVwdGg6IF9kZXB0aCxcblx0XHRcdFx0c3RlbmNpbDogX3N0ZW5jaWwsXG5cdFx0XHRcdGFudGlhbGlhczogX2FudGlhbGlhcyxcblx0XHRcdFx0cHJlbXVsdGlwbGllZEFscGhhOiBfcHJlbXVsdGlwbGllZEFscGhhLFxuXHRcdFx0XHRwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIsXG5cdFx0XHRcdHBvd2VyUHJlZmVyZW5jZTogX3Bvd2VyUHJlZmVyZW5jZSxcblx0XHRcdFx0ZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogX2ZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXRcblx0XHRcdH07IC8vIE9mZnNjcmVlbkNhbnZhcyBkb2VzIG5vdCBoYXZlIHNldEF0dHJpYnV0ZSwgc2VlICMyMjgxMVxuXG5cdFx0XHRpZiAoJ3NldEF0dHJpYnV0ZScgaW4gX2NhbnZhcykgX2NhbnZhcy5zZXRBdHRyaWJ1dGUoJ2RhdGEtZW5naW5lJywgYHRocmVlLmpzIHIke1JFVklTSU9OfWApOyAvLyBldmVudCBsaXN0ZW5lcnMgbXVzdCBiZSByZWdpc3RlcmVkIGJlZm9yZSBXZWJHTCBjb250ZXh0IGlzIGNyZWF0ZWQsIHNlZSAjMTI3NTNcblxuXHRcdFx0X2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0Jywgb25Db250ZXh0TG9zdCwgZmFsc2UpO1xuXG5cdFx0XHRfY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgb25Db250ZXh0UmVzdG9yZSwgZmFsc2UpO1xuXG5cdFx0XHRpZiAoX2dsID09PSBudWxsKSB7XG5cdFx0XHRcdGNvbnN0IGNvbnRleHROYW1lcyA9IFsnd2ViZ2wyJywgJ3dlYmdsJywgJ2V4cGVyaW1lbnRhbC13ZWJnbCddO1xuXG5cdFx0XHRcdGlmIChfdGhpcy5pc1dlYkdMMVJlbmRlcmVyID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0Y29udGV4dE5hbWVzLnNoaWZ0KCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfZ2wgPSBnZXRDb250ZXh0KGNvbnRleHROYW1lcywgY29udGV4dEF0dHJpYnV0ZXMpO1xuXG5cdFx0XHRcdGlmIChfZ2wgPT09IG51bGwpIHtcblx0XHRcdFx0XHRpZiAoZ2V0Q29udGV4dChjb250ZXh0TmFtZXMpKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQgd2l0aCB5b3VyIHNlbGVjdGVkIGF0dHJpYnV0ZXMuJyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dC4nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gLy8gU29tZSBleHBlcmltZW50YWwtd2ViZ2wgaW1wbGVtZW50YXRpb25zIGRvIG5vdCBoYXZlIGdldFNoYWRlclByZWNpc2lvbkZvcm1hdFxuXG5cblx0XHRcdGlmIChfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0X2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0J3JhbmdlTWluJzogMSxcblx0XHRcdFx0XHRcdCdyYW5nZU1heCc6IDEsXG5cdFx0XHRcdFx0XHQncHJlY2lzaW9uJzogMVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMUmVuZGVyZXI6ICcgKyBlcnJvci5tZXNzYWdlKTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblxuXHRcdGxldCBleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMsIHN0YXRlLCBpbmZvO1xuXHRcdGxldCBwcm9wZXJ0aWVzLCB0ZXh0dXJlcywgY3ViZW1hcHMsIGN1YmV1dm1hcHMsIGF0dHJpYnV0ZXMsIGdlb21ldHJpZXMsIG9iamVjdHM7XG5cdFx0bGV0IHByb2dyYW1DYWNoZSwgbWF0ZXJpYWxzLCByZW5kZXJMaXN0cywgcmVuZGVyU3RhdGVzLCBjbGlwcGluZywgc2hhZG93TWFwO1xuXHRcdGxldCBiYWNrZ3JvdW5kLCBtb3JwaHRhcmdldHMsIGJ1ZmZlclJlbmRlcmVyLCBpbmRleGVkQnVmZmVyUmVuZGVyZXI7XG5cdFx0bGV0IHV0aWxzLCBiaW5kaW5nU3RhdGVzO1xuXG5cdFx0ZnVuY3Rpb24gaW5pdEdMQ29udGV4dCgpIHtcblx0XHRcdGV4dGVuc2lvbnMgPSBuZXcgV2ViR0xFeHRlbnNpb25zKF9nbCk7XG5cdFx0XHRjYXBhYmlsaXRpZXMgPSBuZXcgV2ViR0xDYXBhYmlsaXRpZXMoX2dsLCBleHRlbnNpb25zLCBwYXJhbWV0ZXJzKTtcblx0XHRcdGV4dGVuc2lvbnMuaW5pdChjYXBhYmlsaXRpZXMpO1xuXHRcdFx0dXRpbHMgPSBuZXcgV2ViR0xVdGlscyhfZ2wsIGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcyk7XG5cdFx0XHRzdGF0ZSA9IG5ldyBXZWJHTFN0YXRlKF9nbCwgZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzKTtcblx0XHRcdF9jdXJyZW50RHJhd0J1ZmZlcnNbMF0gPSBfZ2wuQkFDSztcblx0XHRcdGluZm8gPSBuZXcgV2ViR0xJbmZvKF9nbCk7XG5cdFx0XHRwcm9wZXJ0aWVzID0gbmV3IFdlYkdMUHJvcGVydGllcygpO1xuXHRcdFx0dGV4dHVyZXMgPSBuZXcgV2ViR0xUZXh0dXJlcyhfZ2wsIGV4dGVuc2lvbnMsIHN0YXRlLCBwcm9wZXJ0aWVzLCBjYXBhYmlsaXRpZXMsIHV0aWxzLCBpbmZvKTtcblx0XHRcdGN1YmVtYXBzID0gbmV3IFdlYkdMQ3ViZU1hcHMoX3RoaXMpO1xuXHRcdFx0Y3ViZXV2bWFwcyA9IG5ldyBXZWJHTEN1YmVVVk1hcHMoX3RoaXMpO1xuXHRcdFx0YXR0cmlidXRlcyA9IG5ldyBXZWJHTEF0dHJpYnV0ZXMoX2dsLCBjYXBhYmlsaXRpZXMpO1xuXHRcdFx0YmluZGluZ1N0YXRlcyA9IG5ldyBXZWJHTEJpbmRpbmdTdGF0ZXMoX2dsLCBleHRlbnNpb25zLCBhdHRyaWJ1dGVzLCBjYXBhYmlsaXRpZXMpO1xuXHRcdFx0Z2VvbWV0cmllcyA9IG5ldyBXZWJHTEdlb21ldHJpZXMoX2dsLCBhdHRyaWJ1dGVzLCBpbmZvLCBiaW5kaW5nU3RhdGVzKTtcblx0XHRcdG9iamVjdHMgPSBuZXcgV2ViR0xPYmplY3RzKF9nbCwgZ2VvbWV0cmllcywgYXR0cmlidXRlcywgaW5mbyk7XG5cdFx0XHRtb3JwaHRhcmdldHMgPSBuZXcgV2ViR0xNb3JwaHRhcmdldHMoX2dsLCBjYXBhYmlsaXRpZXMsIHRleHR1cmVzKTtcblx0XHRcdGNsaXBwaW5nID0gbmV3IFdlYkdMQ2xpcHBpbmcocHJvcGVydGllcyk7XG5cdFx0XHRwcm9ncmFtQ2FjaGUgPSBuZXcgV2ViR0xQcm9ncmFtcyhfdGhpcywgY3ViZW1hcHMsIGN1YmV1dm1hcHMsIGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcywgYmluZGluZ1N0YXRlcywgY2xpcHBpbmcpO1xuXHRcdFx0bWF0ZXJpYWxzID0gbmV3IFdlYkdMTWF0ZXJpYWxzKHByb3BlcnRpZXMpO1xuXHRcdFx0cmVuZGVyTGlzdHMgPSBuZXcgV2ViR0xSZW5kZXJMaXN0cyhwcm9wZXJ0aWVzKTtcblx0XHRcdHJlbmRlclN0YXRlcyA9IG5ldyBXZWJHTFJlbmRlclN0YXRlcyhleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMpO1xuXHRcdFx0YmFja2dyb3VuZCA9IG5ldyBXZWJHTEJhY2tncm91bmQoX3RoaXMsIGN1YmVtYXBzLCBzdGF0ZSwgb2JqZWN0cywgX3ByZW11bHRpcGxpZWRBbHBoYSk7XG5cdFx0XHRzaGFkb3dNYXAgPSBuZXcgV2ViR0xTaGFkb3dNYXAoX3RoaXMsIG9iamVjdHMsIGNhcGFiaWxpdGllcyk7XG5cdFx0XHRidWZmZXJSZW5kZXJlciA9IG5ldyBXZWJHTEJ1ZmZlclJlbmRlcmVyKF9nbCwgZXh0ZW5zaW9ucywgaW5mbywgY2FwYWJpbGl0aWVzKTtcblx0XHRcdGluZGV4ZWRCdWZmZXJSZW5kZXJlciA9IG5ldyBXZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlcihfZ2wsIGV4dGVuc2lvbnMsIGluZm8sIGNhcGFiaWxpdGllcyk7XG5cdFx0XHRpbmZvLnByb2dyYW1zID0gcHJvZ3JhbUNhY2hlLnByb2dyYW1zO1xuXHRcdFx0X3RoaXMuY2FwYWJpbGl0aWVzID0gY2FwYWJpbGl0aWVzO1xuXHRcdFx0X3RoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG5cdFx0XHRfdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcblx0XHRcdF90aGlzLnJlbmRlckxpc3RzID0gcmVuZGVyTGlzdHM7XG5cdFx0XHRfdGhpcy5zaGFkb3dNYXAgPSBzaGFkb3dNYXA7XG5cdFx0XHRfdGhpcy5zdGF0ZSA9IHN0YXRlO1xuXHRcdFx0X3RoaXMuaW5mbyA9IGluZm87XG5cdFx0fVxuXG5cdFx0aW5pdEdMQ29udGV4dCgpOyAvLyB4clxuXG5cdFx0Y29uc3QgeHIgPSBuZXcgV2ViWFJNYW5hZ2VyKF90aGlzLCBfZ2wpO1xuXHRcdHRoaXMueHIgPSB4cjsgLy8gQVBJXG5cblx0XHR0aGlzLmdldENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gX2dsO1xuXHRcdH07XG5cblx0XHR0aGlzLmdldENvbnRleHRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIF9nbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xuXHRcdH07XG5cblx0XHR0aGlzLmZvcmNlQ29udGV4dExvc3MgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRjb25zdCBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCgnV0VCR0xfbG9zZV9jb250ZXh0Jyk7XG5cdFx0XHRpZiAoZXh0ZW5zaW9uKSBleHRlbnNpb24ubG9zZUNvbnRleHQoKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5mb3JjZUNvbnRleHRSZXN0b3JlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0Y29uc3QgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ1dFQkdMX2xvc2VfY29udGV4dCcpO1xuXHRcdFx0aWYgKGV4dGVuc2lvbikgZXh0ZW5zaW9uLnJlc3RvcmVDb250ZXh0KCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBfcGl4ZWxSYXRpbztcblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXHRcdFx0X3BpeGVsUmF0aW8gPSB2YWx1ZTtcblx0XHRcdHRoaXMuc2V0U2l6ZShfd2lkdGgsIF9oZWlnaHQsIGZhbHNlKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRTaXplID0gZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldC5zZXQoX3dpZHRoLCBfaGVpZ2h0KTtcblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRTaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIHVwZGF0ZVN0eWxlKSB7XG5cdFx0XHRpZiAoeHIuaXNQcmVzZW50aW5nKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogQ2FuXFwndCBjaGFuZ2Ugc2l6ZSB3aGlsZSBWUiBkZXZpY2UgaXMgcHJlc2VudGluZy4nKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRfd2lkdGggPSB3aWR0aDtcblx0XHRcdF9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XHRfY2FudmFzLndpZHRoID0gTWF0aC5mbG9vcih3aWR0aCAqIF9waXhlbFJhdGlvKTtcblx0XHRcdF9jYW52YXMuaGVpZ2h0ID0gTWF0aC5mbG9vcihoZWlnaHQgKiBfcGl4ZWxSYXRpbyk7XG5cblx0XHRcdGlmICh1cGRhdGVTdHlsZSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0X2NhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4Jztcblx0XHRcdFx0X2NhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNldFZpZXdwb3J0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXHRcdH07XG5cblx0XHR0aGlzLmdldERyYXdpbmdCdWZmZXJTaXplID0gZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldC5zZXQoX3dpZHRoICogX3BpeGVsUmF0aW8sIF9oZWlnaHQgKiBfcGl4ZWxSYXRpbykuZmxvb3IoKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5zZXREcmF3aW5nQnVmZmVyU2l6ZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCBwaXhlbFJhdGlvKSB7XG5cdFx0XHRfd2lkdGggPSB3aWR0aDtcblx0XHRcdF9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XHRfcGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG5cdFx0XHRfY2FudmFzLndpZHRoID0gTWF0aC5mbG9vcih3aWR0aCAqIHBpeGVsUmF0aW8pO1xuXHRcdFx0X2NhbnZhcy5oZWlnaHQgPSBNYXRoLmZsb29yKGhlaWdodCAqIHBpeGVsUmF0aW8pO1xuXHRcdFx0dGhpcy5zZXRWaWV3cG9ydCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRDdXJyZW50Vmlld3BvcnQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoX2N1cnJlbnRWaWV3cG9ydCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0Vmlld3BvcnQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoX3ZpZXdwb3J0KTtcblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRWaWV3cG9ydCA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0XHRpZiAoeC5pc1ZlY3RvcjQpIHtcblx0XHRcdFx0X3ZpZXdwb3J0LnNldCh4LngsIHgueSwgeC56LCB4LncpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X3ZpZXdwb3J0LnNldCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblx0XHRcdH1cblxuXHRcdFx0c3RhdGUudmlld3BvcnQoX2N1cnJlbnRWaWV3cG9ydC5jb3B5KF92aWV3cG9ydCkubXVsdGlwbHlTY2FsYXIoX3BpeGVsUmF0aW8pLmZsb29yKCkpO1xuXHRcdH07XG5cblx0XHR0aGlzLmdldFNjaXNzb3IgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoX3NjaXNzb3IpO1xuXHRcdH07XG5cblx0XHR0aGlzLnNldFNjaXNzb3IgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdFx0aWYgKHguaXNWZWN0b3I0KSB7XG5cdFx0XHRcdF9zY2lzc29yLnNldCh4LngsIHgueSwgeC56LCB4LncpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X3NjaXNzb3Iuc2V0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdGF0ZS5zY2lzc29yKF9jdXJyZW50U2Npc3Nvci5jb3B5KF9zY2lzc29yKS5tdWx0aXBseVNjYWxhcihfcGl4ZWxSYXRpbykuZmxvb3IoKSk7XG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0U2Npc3NvclRlc3QgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gX3NjaXNzb3JUZXN0O1xuXHRcdH07XG5cblx0XHR0aGlzLnNldFNjaXNzb3JUZXN0ID0gZnVuY3Rpb24gKGJvb2xlYW4pIHtcblx0XHRcdHN0YXRlLnNldFNjaXNzb3JUZXN0KF9zY2lzc29yVGVzdCA9IGJvb2xlYW4pO1xuXHRcdH07XG5cblx0XHR0aGlzLnNldE9wYXF1ZVNvcnQgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG5cdFx0XHRfb3BhcXVlU29ydCA9IG1ldGhvZDtcblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRUcmFuc3BhcmVudFNvcnQgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG5cdFx0XHRfdHJhbnNwYXJlbnRTb3J0ID0gbWV0aG9kO1xuXHRcdH07IC8vIENsZWFyaW5nXG5cblxuXHRcdHRoaXMuZ2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRcdHJldHVybiB0YXJnZXQuY29weShiYWNrZ3JvdW5kLmdldENsZWFyQ29sb3IoKSk7XG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGJhY2tncm91bmQuc2V0Q2xlYXJDb2xvci5hcHBseShiYWNrZ3JvdW5kLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cblx0XHR0aGlzLmdldENsZWFyQWxwaGEgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gYmFja2dyb3VuZC5nZXRDbGVhckFscGhhKCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0Q2xlYXJBbHBoYSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGJhY2tncm91bmQuc2V0Q2xlYXJBbHBoYS5hcHBseShiYWNrZ3JvdW5kLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cblx0XHR0aGlzLmNsZWFyID0gZnVuY3Rpb24gKGNvbG9yLCBkZXB0aCwgc3RlbmNpbCkge1xuXHRcdFx0bGV0IGJpdHMgPSAwO1xuXHRcdFx0aWYgKGNvbG9yID09PSB1bmRlZmluZWQgfHwgY29sb3IpIGJpdHMgfD0gX2dsLkNPTE9SX0JVRkZFUl9CSVQ7XG5cdFx0XHRpZiAoZGVwdGggPT09IHVuZGVmaW5lZCB8fCBkZXB0aCkgYml0cyB8PSBfZ2wuREVQVEhfQlVGRkVSX0JJVDtcblx0XHRcdGlmIChzdGVuY2lsID09PSB1bmRlZmluZWQgfHwgc3RlbmNpbCkgYml0cyB8PSBfZ2wuU1RFTkNJTF9CVUZGRVJfQklUO1xuXG5cdFx0XHRfZ2wuY2xlYXIoYml0cyk7XG5cdFx0fTtcblxuXHRcdHRoaXMuY2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuY2xlYXIodHJ1ZSwgZmFsc2UsIGZhbHNlKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5jbGVhckRlcHRoID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5jbGVhcihmYWxzZSwgdHJ1ZSwgZmFsc2UpO1xuXHRcdH07XG5cblx0XHR0aGlzLmNsZWFyU3RlbmNpbCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuY2xlYXIoZmFsc2UsIGZhbHNlLCB0cnVlKTtcblx0XHR9OyAvL1xuXG5cblx0XHR0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRfY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCBvbkNvbnRleHRMb3N0LCBmYWxzZSk7XG5cblx0XHRcdF9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCBvbkNvbnRleHRSZXN0b3JlLCBmYWxzZSk7XG5cblx0XHRcdHJlbmRlckxpc3RzLmRpc3Bvc2UoKTtcblx0XHRcdHJlbmRlclN0YXRlcy5kaXNwb3NlKCk7XG5cdFx0XHRwcm9wZXJ0aWVzLmRpc3Bvc2UoKTtcblx0XHRcdGN1YmVtYXBzLmRpc3Bvc2UoKTtcblx0XHRcdGN1YmV1dm1hcHMuZGlzcG9zZSgpO1xuXHRcdFx0b2JqZWN0cy5kaXNwb3NlKCk7XG5cdFx0XHRiaW5kaW5nU3RhdGVzLmRpc3Bvc2UoKTtcblx0XHRcdHhyLmRpc3Bvc2UoKTtcblx0XHRcdHhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25zdGFydCcsIG9uWFJTZXNzaW9uU3RhcnQpO1xuXHRcdFx0eHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vzc2lvbmVuZCcsIG9uWFJTZXNzaW9uRW5kKTtcblxuXHRcdFx0aWYgKF90cmFuc21pc3Npb25SZW5kZXJUYXJnZXQpIHtcblx0XHRcdFx0X3RyYW5zbWlzc2lvblJlbmRlclRhcmdldC5kaXNwb3NlKCk7XG5cblx0XHRcdFx0X3RyYW5zbWlzc2lvblJlbmRlclRhcmdldCA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGFuaW1hdGlvbi5zdG9wKCk7XG5cdFx0fTsgLy8gRXZlbnRzXG5cblxuXHRcdGZ1bmN0aW9uIG9uQ29udGV4dExvc3QoZXZlbnQpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRjb25zb2xlLmxvZygnVEhSRUUuV2ViR0xSZW5kZXJlcjogQ29udGV4dCBMb3N0LicpO1xuXHRcdFx0X2lzQ29udGV4dExvc3QgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uQ29udGV4dFJlc3RvcmUoKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnVEhSRUUuV2ViR0xSZW5kZXJlcjogQ29udGV4dCBSZXN0b3JlZC4nKTtcblx0XHRcdF9pc0NvbnRleHRMb3N0ID0gZmFsc2U7XG5cdFx0XHRjb25zdCBpbmZvQXV0b1Jlc2V0ID0gaW5mby5hdXRvUmVzZXQ7XG5cdFx0XHRjb25zdCBzaGFkb3dNYXBFbmFibGVkID0gc2hhZG93TWFwLmVuYWJsZWQ7XG5cdFx0XHRjb25zdCBzaGFkb3dNYXBBdXRvVXBkYXRlID0gc2hhZG93TWFwLmF1dG9VcGRhdGU7XG5cdFx0XHRjb25zdCBzaGFkb3dNYXBOZWVkc1VwZGF0ZSA9IHNoYWRvd01hcC5uZWVkc1VwZGF0ZTtcblx0XHRcdGNvbnN0IHNoYWRvd01hcFR5cGUgPSBzaGFkb3dNYXAudHlwZTtcblx0XHRcdGluaXRHTENvbnRleHQoKTtcblx0XHRcdGluZm8uYXV0b1Jlc2V0ID0gaW5mb0F1dG9SZXNldDtcblx0XHRcdHNoYWRvd01hcC5lbmFibGVkID0gc2hhZG93TWFwRW5hYmxlZDtcblx0XHRcdHNoYWRvd01hcC5hdXRvVXBkYXRlID0gc2hhZG93TWFwQXV0b1VwZGF0ZTtcblx0XHRcdHNoYWRvd01hcC5uZWVkc1VwZGF0ZSA9IHNoYWRvd01hcE5lZWRzVXBkYXRlO1xuXHRcdFx0c2hhZG93TWFwLnR5cGUgPSBzaGFkb3dNYXBUeXBlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uTWF0ZXJpYWxEaXNwb3NlKGV2ZW50KSB7XG5cdFx0XHRjb25zdCBtYXRlcmlhbCA9IGV2ZW50LnRhcmdldDtcblx0XHRcdG1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvbk1hdGVyaWFsRGlzcG9zZSk7XG5cdFx0XHRkZWFsbG9jYXRlTWF0ZXJpYWwobWF0ZXJpYWwpO1xuXHRcdH0gLy8gQnVmZmVyIGRlYWxsb2NhdGlvblxuXG5cblx0XHRmdW5jdGlvbiBkZWFsbG9jYXRlTWF0ZXJpYWwobWF0ZXJpYWwpIHtcblx0XHRcdHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2VzKG1hdGVyaWFsKTtcblx0XHRcdHByb3BlcnRpZXMucmVtb3ZlKG1hdGVyaWFsKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlcyhtYXRlcmlhbCkge1xuXHRcdFx0Y29uc3QgcHJvZ3JhbXMgPSBwcm9wZXJ0aWVzLmdldChtYXRlcmlhbCkucHJvZ3JhbXM7XG5cblx0XHRcdGlmIChwcm9ncmFtcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHByb2dyYW1zLmZvckVhY2goZnVuY3Rpb24gKHByb2dyYW0pIHtcblx0XHRcdFx0XHRwcm9ncmFtQ2FjaGUucmVsZWFzZVByb2dyYW0ocHJvZ3JhbSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gLy8gQnVmZmVyIHJlbmRlcmluZ1xuXG5cblx0XHR0aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCA9IGZ1bmN0aW9uIChjYW1lcmEsIHNjZW5lLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXApIHtcblx0XHRcdGlmIChzY2VuZSA9PT0gbnVsbCkgc2NlbmUgPSBfZW1wdHlTY2VuZTsgLy8gcmVuZGVyQnVmZmVyRGlyZWN0IHNlY29uZCBwYXJhbWV0ZXIgdXNlZCB0byBiZSBmb2cgKGNvdWxkIGJlIG51bGwpXG5cblx0XHRcdGNvbnN0IGZyb250RmFjZUNXID0gb2JqZWN0LmlzTWVzaCAmJiBvYmplY3QubWF0cml4V29ybGQuZGV0ZXJtaW5hbnQoKSA8IDA7XG5cdFx0XHRjb25zdCBwcm9ncmFtID0gc2V0UHJvZ3JhbShjYW1lcmEsIHNjZW5lLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCk7XG5cdFx0XHRzdGF0ZS5zZXRNYXRlcmlhbChtYXRlcmlhbCwgZnJvbnRGYWNlQ1cpOyAvL1xuXG5cdFx0XHRsZXQgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjsgLy9cblxuXHRcdFx0aWYgKGluZGV4ID09PSBudWxsKSB7XG5cdFx0XHRcdGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uLmNvdW50ID09PSAwKSByZXR1cm47XG5cdFx0XHR9IGVsc2UgaWYgKGluZGV4LmNvdW50ID09PSAwKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gLy9cblxuXG5cdFx0XHRsZXQgcmFuZ2VGYWN0b3IgPSAxO1xuXG5cdFx0XHRpZiAobWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlKSB7XG5cdFx0XHRcdGluZGV4ID0gZ2VvbWV0cmllcy5nZXRXaXJlZnJhbWVBdHRyaWJ1dGUoZ2VvbWV0cnkpO1xuXHRcdFx0XHRyYW5nZUZhY3RvciA9IDI7XG5cdFx0XHR9XG5cblx0XHRcdGJpbmRpbmdTdGF0ZXMuc2V0dXAob2JqZWN0LCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIGluZGV4KTtcblx0XHRcdGxldCBhdHRyaWJ1dGU7XG5cdFx0XHRsZXQgcmVuZGVyZXIgPSBidWZmZXJSZW5kZXJlcjtcblxuXHRcdFx0aWYgKGluZGV4ICE9PSBudWxsKSB7XG5cdFx0XHRcdGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMuZ2V0KGluZGV4KTtcblx0XHRcdFx0cmVuZGVyZXIgPSBpbmRleGVkQnVmZmVyUmVuZGVyZXI7XG5cdFx0XHRcdHJlbmRlcmVyLnNldEluZGV4KGF0dHJpYnV0ZSk7XG5cdFx0XHR9IC8vXG5cblxuXHRcdFx0Y29uc3QgZGF0YUNvdW50ID0gaW5kZXggIT09IG51bGwgPyBpbmRleC5jb3VudCA6IHBvc2l0aW9uLmNvdW50O1xuXHRcdFx0Y29uc3QgcmFuZ2VTdGFydCA9IGdlb21ldHJ5LmRyYXdSYW5nZS5zdGFydCAqIHJhbmdlRmFjdG9yO1xuXHRcdFx0Y29uc3QgcmFuZ2VDb3VudCA9IGdlb21ldHJ5LmRyYXdSYW5nZS5jb3VudCAqIHJhbmdlRmFjdG9yO1xuXHRcdFx0Y29uc3QgZ3JvdXBTdGFydCA9IGdyb3VwICE9PSBudWxsID8gZ3JvdXAuc3RhcnQgKiByYW5nZUZhY3RvciA6IDA7XG5cdFx0XHRjb25zdCBncm91cENvdW50ID0gZ3JvdXAgIT09IG51bGwgPyBncm91cC5jb3VudCAqIHJhbmdlRmFjdG9yIDogSW5maW5pdHk7XG5cdFx0XHRjb25zdCBkcmF3U3RhcnQgPSBNYXRoLm1heChyYW5nZVN0YXJ0LCBncm91cFN0YXJ0KTtcblx0XHRcdGNvbnN0IGRyYXdFbmQgPSBNYXRoLm1pbihkYXRhQ291bnQsIHJhbmdlU3RhcnQgKyByYW5nZUNvdW50LCBncm91cFN0YXJ0ICsgZ3JvdXBDb3VudCkgLSAxO1xuXHRcdFx0Y29uc3QgZHJhd0NvdW50ID0gTWF0aC5tYXgoMCwgZHJhd0VuZCAtIGRyYXdTdGFydCArIDEpO1xuXHRcdFx0aWYgKGRyYXdDb3VudCA9PT0gMCkgcmV0dXJuOyAvL1xuXG5cdFx0XHRpZiAob2JqZWN0LmlzTWVzaCkge1xuXHRcdFx0XHRpZiAobWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0c3RhdGUuc2V0TGluZVdpZHRoKG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCAqIGdldFRhcmdldFBpeGVsUmF0aW8oKSk7XG5cdFx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZShfZ2wuTElORVMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoX2dsLlRSSUFOR0xFUyk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAob2JqZWN0LmlzTGluZSkge1xuXHRcdFx0XHRsZXQgbGluZVdpZHRoID0gbWF0ZXJpYWwubGluZXdpZHRoO1xuXHRcdFx0XHRpZiAobGluZVdpZHRoID09PSB1bmRlZmluZWQpIGxpbmVXaWR0aCA9IDE7IC8vIE5vdCB1c2luZyBMaW5lKk1hdGVyaWFsXG5cblx0XHRcdFx0c3RhdGUuc2V0TGluZVdpZHRoKGxpbmVXaWR0aCAqIGdldFRhcmdldFBpeGVsUmF0aW8oKSk7XG5cblx0XHRcdFx0aWYgKG9iamVjdC5pc0xpbmVTZWdtZW50cykge1xuXHRcdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoX2dsLkxJTkVTKTtcblx0XHRcdFx0fSBlbHNlIGlmIChvYmplY3QuaXNMaW5lTG9vcCkge1xuXHRcdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoX2dsLkxJTkVfTE9PUCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZShfZ2wuTElORV9TVFJJUCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAob2JqZWN0LmlzUG9pbnRzKSB7XG5cdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoX2dsLlBPSU5UUyk7XG5cdFx0XHR9IGVsc2UgaWYgKG9iamVjdC5pc1Nwcml0ZSkge1xuXHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKF9nbC5UUklBTkdMRVMpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob2JqZWN0LmlzSW5zdGFuY2VkTWVzaCkge1xuXHRcdFx0XHRyZW5kZXJlci5yZW5kZXJJbnN0YW5jZXMoZHJhd1N0YXJ0LCBkcmF3Q291bnQsIG9iamVjdC5jb3VudCk7XG5cdFx0XHR9IGVsc2UgaWYgKGdlb21ldHJ5LmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkpIHtcblx0XHRcdFx0Y29uc3QgaW5zdGFuY2VDb3VudCA9IE1hdGgubWluKGdlb21ldHJ5Lmluc3RhbmNlQ291bnQsIGdlb21ldHJ5Ll9tYXhJbnN0YW5jZUNvdW50KTtcblx0XHRcdFx0cmVuZGVyZXIucmVuZGVySW5zdGFuY2VzKGRyYXdTdGFydCwgZHJhd0NvdW50LCBpbnN0YW5jZUNvdW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlbmRlcmVyLnJlbmRlcihkcmF3U3RhcnQsIGRyYXdDb3VudCk7XG5cdFx0XHR9XG5cdFx0fTsgLy8gQ29tcGlsZVxuXG5cblx0XHR0aGlzLmNvbXBpbGUgPSBmdW5jdGlvbiAoc2NlbmUsIGNhbWVyYSkge1xuXHRcdFx0Y3VycmVudFJlbmRlclN0YXRlID0gcmVuZGVyU3RhdGVzLmdldChzY2VuZSk7XG5cdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUuaW5pdCgpO1xuXHRcdFx0cmVuZGVyU3RhdGVTdGFjay5wdXNoKGN1cnJlbnRSZW5kZXJTdGF0ZSk7XG5cdFx0XHRzY2VuZS50cmF2ZXJzZVZpc2libGUoZnVuY3Rpb24gKG9iamVjdCkge1xuXHRcdFx0XHRpZiAob2JqZWN0LmlzTGlnaHQgJiYgb2JqZWN0LmxheWVycy50ZXN0KGNhbWVyYS5sYXllcnMpKSB7XG5cdFx0XHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLnB1c2hMaWdodChvYmplY3QpO1xuXG5cdFx0XHRcdFx0aWYgKG9iamVjdC5jYXN0U2hhZG93KSB7XG5cdFx0XHRcdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUucHVzaFNoYWRvdyhvYmplY3QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUuc2V0dXBMaWdodHMoX3RoaXMucGh5c2ljYWxseUNvcnJlY3RMaWdodHMpO1xuXHRcdFx0c2NlbmUudHJhdmVyc2UoZnVuY3Rpb24gKG9iamVjdCkge1xuXHRcdFx0XHRjb25zdCBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuXHRcdFx0XHRpZiAobWF0ZXJpYWwpIHtcblx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShtYXRlcmlhbCkpIHtcblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbWF0ZXJpYWwubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbWF0ZXJpYWwyID0gbWF0ZXJpYWxbaV07XG5cdFx0XHRcdFx0XHRcdGdldFByb2dyYW0obWF0ZXJpYWwyLCBzY2VuZSwgb2JqZWN0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Z2V0UHJvZ3JhbShtYXRlcmlhbCwgc2NlbmUsIG9iamVjdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHJlbmRlclN0YXRlU3RhY2sucG9wKCk7XG5cdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUgPSBudWxsO1xuXHRcdH07IC8vIEFuaW1hdGlvbiBMb29wXG5cblxuXHRcdGxldCBvbkFuaW1hdGlvbkZyYW1lQ2FsbGJhY2sgPSBudWxsO1xuXG5cdFx0ZnVuY3Rpb24gb25BbmltYXRpb25GcmFtZSh0aW1lKSB7XG5cdFx0XHRpZiAob25BbmltYXRpb25GcmFtZUNhbGxiYWNrKSBvbkFuaW1hdGlvbkZyYW1lQ2FsbGJhY2sodGltZSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25YUlNlc3Npb25TdGFydCgpIHtcblx0XHRcdGFuaW1hdGlvbi5zdG9wKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25YUlNlc3Npb25FbmQoKSB7XG5cdFx0XHRhbmltYXRpb24uc3RhcnQoKTtcblx0XHR9XG5cblx0XHRjb25zdCBhbmltYXRpb24gPSBuZXcgV2ViR0xBbmltYXRpb24oKTtcblx0XHRhbmltYXRpb24uc2V0QW5pbWF0aW9uTG9vcChvbkFuaW1hdGlvbkZyYW1lKTtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIGFuaW1hdGlvbi5zZXRDb250ZXh0KHdpbmRvdyk7XG5cblx0XHR0aGlzLnNldEFuaW1hdGlvbkxvb3AgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdG9uQW5pbWF0aW9uRnJhbWVDYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdFx0eHIuc2V0QW5pbWF0aW9uTG9vcChjYWxsYmFjayk7XG5cdFx0XHRjYWxsYmFjayA9PT0gbnVsbCA/IGFuaW1hdGlvbi5zdG9wKCkgOiBhbmltYXRpb24uc3RhcnQoKTtcblx0XHR9O1xuXG5cdFx0eHIuYWRkRXZlbnRMaXN0ZW5lcignc2Vzc2lvbnN0YXJ0Jywgb25YUlNlc3Npb25TdGFydCk7XG5cdFx0eHIuYWRkRXZlbnRMaXN0ZW5lcignc2Vzc2lvbmVuZCcsIG9uWFJTZXNzaW9uRW5kKTsgLy8gUmVuZGVyaW5nXG5cblx0XHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uIChzY2VuZSwgY2FtZXJhKSB7XG5cdFx0XHRpZiAoY2FtZXJhICE9PSB1bmRlZmluZWQgJiYgY2FtZXJhLmlzQ2FtZXJhICE9PSB0cnVlKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVuZGVyOiBjYW1lcmEgaXMgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkNhbWVyYS4nKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoX2lzQ29udGV4dExvc3QgPT09IHRydWUpIHJldHVybjsgLy8gdXBkYXRlIHNjZW5lIGdyYXBoXG5cblx0XHRcdGlmIChzY2VuZS5hdXRvVXBkYXRlID09PSB0cnVlKSBzY2VuZS51cGRhdGVNYXRyaXhXb3JsZCgpOyAvLyB1cGRhdGUgY2FtZXJhIG1hdHJpY2VzIGFuZCBmcnVzdHVtXG5cblx0XHRcdGlmIChjYW1lcmEucGFyZW50ID09PSBudWxsKSBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdFx0aWYgKHhyLmVuYWJsZWQgPT09IHRydWUgJiYgeHIuaXNQcmVzZW50aW5nID09PSB0cnVlKSB7XG5cdFx0XHRcdGlmICh4ci5jYW1lcmFBdXRvVXBkYXRlID09PSB0cnVlKSB4ci51cGRhdGVDYW1lcmEoY2FtZXJhKTtcblx0XHRcdFx0Y2FtZXJhID0geHIuZ2V0Q2FtZXJhKCk7IC8vIHVzZSBYUiBjYW1lcmEgZm9yIHJlbmRlcmluZ1xuXHRcdFx0fSAvL1xuXG5cblx0XHRcdGlmIChzY2VuZS5pc1NjZW5lID09PSB0cnVlKSBzY2VuZS5vbkJlZm9yZVJlbmRlcihfdGhpcywgc2NlbmUsIGNhbWVyYSwgX2N1cnJlbnRSZW5kZXJUYXJnZXQpO1xuXHRcdFx0Y3VycmVudFJlbmRlclN0YXRlID0gcmVuZGVyU3RhdGVzLmdldChzY2VuZSwgcmVuZGVyU3RhdGVTdGFjay5sZW5ndGgpO1xuXHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLmluaXQoKTtcblx0XHRcdHJlbmRlclN0YXRlU3RhY2sucHVzaChjdXJyZW50UmVuZGVyU3RhdGUpO1xuXG5cdFx0XHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlKTtcblxuXHRcdFx0X2ZydXN0dW0uc2V0RnJvbVByb2plY3Rpb25NYXRyaXgoX3Byb2pTY3JlZW5NYXRyaXgpO1xuXG5cdFx0XHRfbG9jYWxDbGlwcGluZ0VuYWJsZWQgPSB0aGlzLmxvY2FsQ2xpcHBpbmdFbmFibGVkO1xuXHRcdFx0X2NsaXBwaW5nRW5hYmxlZCA9IGNsaXBwaW5nLmluaXQodGhpcy5jbGlwcGluZ1BsYW5lcywgX2xvY2FsQ2xpcHBpbmdFbmFibGVkLCBjYW1lcmEpO1xuXHRcdFx0Y3VycmVudFJlbmRlckxpc3QgPSByZW5kZXJMaXN0cy5nZXQoc2NlbmUsIHJlbmRlckxpc3RTdGFjay5sZW5ndGgpO1xuXHRcdFx0Y3VycmVudFJlbmRlckxpc3QuaW5pdCgpO1xuXHRcdFx0cmVuZGVyTGlzdFN0YWNrLnB1c2goY3VycmVudFJlbmRlckxpc3QpO1xuXHRcdFx0cHJvamVjdE9iamVjdChzY2VuZSwgY2FtZXJhLCAwLCBfdGhpcy5zb3J0T2JqZWN0cyk7XG5cdFx0XHRjdXJyZW50UmVuZGVyTGlzdC5maW5pc2goKTtcblxuXHRcdFx0aWYgKF90aGlzLnNvcnRPYmplY3RzID09PSB0cnVlKSB7XG5cdFx0XHRcdGN1cnJlbnRSZW5kZXJMaXN0LnNvcnQoX29wYXF1ZVNvcnQsIF90cmFuc3BhcmVudFNvcnQpO1xuXHRcdFx0fSAvL1xuXG5cblx0XHRcdGlmIChfY2xpcHBpbmdFbmFibGVkID09PSB0cnVlKSBjbGlwcGluZy5iZWdpblNoYWRvd3MoKTtcblx0XHRcdGNvbnN0IHNoYWRvd3NBcnJheSA9IGN1cnJlbnRSZW5kZXJTdGF0ZS5zdGF0ZS5zaGFkb3dzQXJyYXk7XG5cdFx0XHRzaGFkb3dNYXAucmVuZGVyKHNoYWRvd3NBcnJheSwgc2NlbmUsIGNhbWVyYSk7XG5cdFx0XHRpZiAoX2NsaXBwaW5nRW5hYmxlZCA9PT0gdHJ1ZSkgY2xpcHBpbmcuZW5kU2hhZG93cygpOyAvL1xuXG5cdFx0XHRpZiAodGhpcy5pbmZvLmF1dG9SZXNldCA9PT0gdHJ1ZSkgdGhpcy5pbmZvLnJlc2V0KCk7IC8vXG5cblx0XHRcdGJhY2tncm91bmQucmVuZGVyKGN1cnJlbnRSZW5kZXJMaXN0LCBzY2VuZSk7IC8vIHJlbmRlciBzY2VuZVxuXG5cdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUuc2V0dXBMaWdodHMoX3RoaXMucGh5c2ljYWxseUNvcnJlY3RMaWdodHMpO1xuXG5cdFx0XHRpZiAoY2FtZXJhLmlzQXJyYXlDYW1lcmEpIHtcblx0XHRcdFx0Y29uc3QgY2FtZXJhcyA9IGNhbWVyYS5jYW1lcmFzO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gY2FtZXJhcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBjYW1lcmEyID0gY2FtZXJhc1tpXTtcblx0XHRcdFx0XHRyZW5kZXJTY2VuZShjdXJyZW50UmVuZGVyTGlzdCwgc2NlbmUsIGNhbWVyYTIsIGNhbWVyYTIudmlld3BvcnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZW5kZXJTY2VuZShjdXJyZW50UmVuZGVyTGlzdCwgc2NlbmUsIGNhbWVyYSk7XG5cdFx0XHR9IC8vXG5cblxuXHRcdFx0aWYgKF9jdXJyZW50UmVuZGVyVGFyZ2V0ICE9PSBudWxsKSB7XG5cdFx0XHRcdC8vIHJlc29sdmUgbXVsdGlzYW1wbGUgcmVuZGVyYnVmZmVycyB0byBhIHNpbmdsZS1zYW1wbGUgdGV4dHVyZSBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0dGV4dHVyZXMudXBkYXRlTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQoX2N1cnJlbnRSZW5kZXJUYXJnZXQpOyAvLyBHZW5lcmF0ZSBtaXBtYXAgaWYgd2UncmUgdXNpbmcgYW55IGtpbmQgb2YgbWlwbWFwIGZpbHRlcmluZ1xuXG5cdFx0XHRcdHRleHR1cmVzLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcChfY3VycmVudFJlbmRlclRhcmdldCk7XG5cdFx0XHR9IC8vXG5cblxuXHRcdFx0aWYgKHNjZW5lLmlzU2NlbmUgPT09IHRydWUpIHNjZW5lLm9uQWZ0ZXJSZW5kZXIoX3RoaXMsIHNjZW5lLCBjYW1lcmEpOyAvLyBFbnN1cmUgZGVwdGggYnVmZmVyIHdyaXRpbmcgaXMgZW5hYmxlZCBzbyBpdCBjYW4gYmUgY2xlYXJlZCBvbiBuZXh0IHJlbmRlclxuXG5cdFx0XHRzdGF0ZS5idWZmZXJzLmRlcHRoLnNldFRlc3QodHJ1ZSk7XG5cdFx0XHRzdGF0ZS5idWZmZXJzLmRlcHRoLnNldE1hc2sodHJ1ZSk7XG5cdFx0XHRzdGF0ZS5idWZmZXJzLmNvbG9yLnNldE1hc2sodHJ1ZSk7XG5cdFx0XHRzdGF0ZS5zZXRQb2x5Z29uT2Zmc2V0KGZhbHNlKTsgLy8gX2dsLmZpbmlzaCgpO1xuXG5cdFx0XHRiaW5kaW5nU3RhdGVzLnJlc2V0RGVmYXVsdFN0YXRlKCk7XG5cdFx0XHRfY3VycmVudE1hdGVyaWFsSWQgPSAtMTtcblx0XHRcdF9jdXJyZW50Q2FtZXJhID0gbnVsbDtcblx0XHRcdHJlbmRlclN0YXRlU3RhY2sucG9wKCk7XG5cblx0XHRcdGlmIChyZW5kZXJTdGF0ZVN0YWNrLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y3VycmVudFJlbmRlclN0YXRlID0gcmVuZGVyU3RhdGVTdGFja1tyZW5kZXJTdGF0ZVN0YWNrLmxlbmd0aCAtIDFdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3VycmVudFJlbmRlclN0YXRlID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0cmVuZGVyTGlzdFN0YWNrLnBvcCgpO1xuXG5cdFx0XHRpZiAocmVuZGVyTGlzdFN0YWNrLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y3VycmVudFJlbmRlckxpc3QgPSByZW5kZXJMaXN0U3RhY2tbcmVuZGVyTGlzdFN0YWNrLmxlbmd0aCAtIDFdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3VycmVudFJlbmRlckxpc3QgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBwcm9qZWN0T2JqZWN0KG9iamVjdCwgY2FtZXJhLCBncm91cE9yZGVyLCBzb3J0T2JqZWN0cykge1xuXHRcdFx0aWYgKG9iamVjdC52aXNpYmxlID09PSBmYWxzZSkgcmV0dXJuO1xuXHRcdFx0Y29uc3QgdmlzaWJsZSA9IG9iamVjdC5sYXllcnMudGVzdChjYW1lcmEubGF5ZXJzKTtcblxuXHRcdFx0aWYgKHZpc2libGUpIHtcblx0XHRcdFx0aWYgKG9iamVjdC5pc0dyb3VwKSB7XG5cdFx0XHRcdFx0Z3JvdXBPcmRlciA9IG9iamVjdC5yZW5kZXJPcmRlcjtcblx0XHRcdFx0fSBlbHNlIGlmIChvYmplY3QuaXNMT0QpIHtcblx0XHRcdFx0XHRpZiAob2JqZWN0LmF1dG9VcGRhdGUgPT09IHRydWUpIG9iamVjdC51cGRhdGUoY2FtZXJhKTtcblx0XHRcdFx0fSBlbHNlIGlmIChvYmplY3QuaXNMaWdodCkge1xuXHRcdFx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZS5wdXNoTGlnaHQob2JqZWN0KTtcblxuXHRcdFx0XHRcdGlmIChvYmplY3QuY2FzdFNoYWRvdykge1xuXHRcdFx0XHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLnB1c2hTaGFkb3cob2JqZWN0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAob2JqZWN0LmlzU3ByaXRlKSB7XG5cdFx0XHRcdFx0aWYgKCFvYmplY3QuZnJ1c3R1bUN1bGxlZCB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzU3ByaXRlKG9iamVjdCkpIHtcblx0XHRcdFx0XHRcdGlmIChzb3J0T2JqZWN0cykge1xuXHRcdFx0XHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24ob2JqZWN0Lm1hdHJpeFdvcmxkKS5hcHBseU1hdHJpeDQoX3Byb2pTY3JlZW5NYXRyaXgpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjb25zdCBnZW9tZXRyeSA9IG9iamVjdHMudXBkYXRlKG9iamVjdCk7XG5cdFx0XHRcdFx0XHRjb25zdCBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuXHRcdFx0XHRcdFx0aWYgKG1hdGVyaWFsLnZpc2libGUpIHtcblx0XHRcdFx0XHRcdFx0Y3VycmVudFJlbmRlckxpc3QucHVzaChvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXBPcmRlciwgX3ZlY3RvcjMueiwgbnVsbCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKG9iamVjdC5pc01lc2ggfHwgb2JqZWN0LmlzTGluZSB8fCBvYmplY3QuaXNQb2ludHMpIHtcblx0XHRcdFx0XHRpZiAob2JqZWN0LmlzU2tpbm5lZE1lc2gpIHtcblx0XHRcdFx0XHRcdC8vIHVwZGF0ZSBza2VsZXRvbiBvbmx5IG9uY2UgaW4gYSBmcmFtZVxuXHRcdFx0XHRcdFx0aWYgKG9iamVjdC5za2VsZXRvbi5mcmFtZSAhPT0gaW5mby5yZW5kZXIuZnJhbWUpIHtcblx0XHRcdFx0XHRcdFx0b2JqZWN0LnNrZWxldG9uLnVwZGF0ZSgpO1xuXHRcdFx0XHRcdFx0XHRvYmplY3Quc2tlbGV0b24uZnJhbWUgPSBpbmZvLnJlbmRlci5mcmFtZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIW9iamVjdC5mcnVzdHVtQ3VsbGVkIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3Qob2JqZWN0KSkge1xuXHRcdFx0XHRcdFx0aWYgKHNvcnRPYmplY3RzKSB7XG5cdFx0XHRcdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbihvYmplY3QubWF0cml4V29ybGQpLmFwcGx5TWF0cml4NChfcHJvalNjcmVlbk1hdHJpeCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gb2JqZWN0cy51cGRhdGUob2JqZWN0KTtcblx0XHRcdFx0XHRcdGNvbnN0IG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG5cdFx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShtYXRlcmlhbCkpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXG5cdFx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzW2ldO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbFtncm91cC5tYXRlcmlhbEluZGV4XTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChncm91cE1hdGVyaWFsICYmIGdyb3VwTWF0ZXJpYWwudmlzaWJsZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudFJlbmRlckxpc3QucHVzaChvYmplY3QsIGdlb21ldHJ5LCBncm91cE1hdGVyaWFsLCBncm91cE9yZGVyLCBfdmVjdG9yMy56LCBncm91cCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLnZpc2libGUpIHtcblx0XHRcdFx0XHRcdFx0Y3VycmVudFJlbmRlckxpc3QucHVzaChvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXBPcmRlciwgX3ZlY3RvcjMueiwgbnVsbCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRwcm9qZWN0T2JqZWN0KGNoaWxkcmVuW2ldLCBjYW1lcmEsIGdyb3VwT3JkZXIsIHNvcnRPYmplY3RzKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW5kZXJTY2VuZShjdXJyZW50UmVuZGVyTGlzdCwgc2NlbmUsIGNhbWVyYSwgdmlld3BvcnQpIHtcblx0XHRcdGNvbnN0IG9wYXF1ZU9iamVjdHMgPSBjdXJyZW50UmVuZGVyTGlzdC5vcGFxdWU7XG5cdFx0XHRjb25zdCB0cmFuc21pc3NpdmVPYmplY3RzID0gY3VycmVudFJlbmRlckxpc3QudHJhbnNtaXNzaXZlO1xuXHRcdFx0Y29uc3QgdHJhbnNwYXJlbnRPYmplY3RzID0gY3VycmVudFJlbmRlckxpc3QudHJhbnNwYXJlbnQ7XG5cdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUuc2V0dXBMaWdodHNWaWV3KGNhbWVyYSk7XG5cdFx0XHRpZiAodHJhbnNtaXNzaXZlT2JqZWN0cy5sZW5ndGggPiAwKSByZW5kZXJUcmFuc21pc3Npb25QYXNzKG9wYXF1ZU9iamVjdHMsIHNjZW5lLCBjYW1lcmEpO1xuXHRcdFx0aWYgKHZpZXdwb3J0KSBzdGF0ZS52aWV3cG9ydChfY3VycmVudFZpZXdwb3J0LmNvcHkodmlld3BvcnQpKTtcblx0XHRcdGlmIChvcGFxdWVPYmplY3RzLmxlbmd0aCA+IDApIHJlbmRlck9iamVjdHMob3BhcXVlT2JqZWN0cywgc2NlbmUsIGNhbWVyYSk7XG5cdFx0XHRpZiAodHJhbnNtaXNzaXZlT2JqZWN0cy5sZW5ndGggPiAwKSByZW5kZXJPYmplY3RzKHRyYW5zbWlzc2l2ZU9iamVjdHMsIHNjZW5lLCBjYW1lcmEpO1xuXHRcdFx0aWYgKHRyYW5zcGFyZW50T2JqZWN0cy5sZW5ndGggPiAwKSByZW5kZXJPYmplY3RzKHRyYW5zcGFyZW50T2JqZWN0cywgc2NlbmUsIGNhbWVyYSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVuZGVyVHJhbnNtaXNzaW9uUGFzcyhvcGFxdWVPYmplY3RzLCBzY2VuZSwgY2FtZXJhKSB7XG5cdFx0XHRpZiAoX3RyYW5zbWlzc2lvblJlbmRlclRhcmdldCA9PT0gbnVsbCkge1xuXHRcdFx0XHRjb25zdCBuZWVkc0FudGlhbGlhcyA9IF9hbnRpYWxpYXMgPT09IHRydWUgJiYgY2FwYWJpbGl0aWVzLmlzV2ViR0wyID09PSB0cnVlO1xuXHRcdFx0XHRjb25zdCByZW5kZXJUYXJnZXRUeXBlID0gbmVlZHNBbnRpYWxpYXMgPyBXZWJHTE11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0IDogV2ViR0xSZW5kZXJUYXJnZXQ7XG5cdFx0XHRcdF90cmFuc21pc3Npb25SZW5kZXJUYXJnZXQgPSBuZXcgcmVuZGVyVGFyZ2V0VHlwZSgxMDI0LCAxMDI0LCB7XG5cdFx0XHRcdFx0Z2VuZXJhdGVNaXBtYXBzOiB0cnVlLFxuXHRcdFx0XHRcdHR5cGU6IHV0aWxzLmNvbnZlcnQoSGFsZkZsb2F0VHlwZSkgIT09IG51bGwgPyBIYWxmRmxvYXRUeXBlIDogVW5zaWduZWRCeXRlVHlwZSxcblx0XHRcdFx0XHRtaW5GaWx0ZXI6IExpbmVhck1pcG1hcExpbmVhckZpbHRlcixcblx0XHRcdFx0XHRtYWdGaWx0ZXI6IE5lYXJlc3RGaWx0ZXIsXG5cdFx0XHRcdFx0d3JhcFM6IENsYW1wVG9FZGdlV3JhcHBpbmcsXG5cdFx0XHRcdFx0d3JhcFQ6IENsYW1wVG9FZGdlV3JhcHBpbmcsXG5cdFx0XHRcdFx0dXNlUmVuZGVyVG9UZXh0dXJlOiBleHRlbnNpb25zLmhhcygnV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlJylcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGN1cnJlbnRSZW5kZXJUYXJnZXQgPSBfdGhpcy5nZXRSZW5kZXJUYXJnZXQoKTtcblxuXHRcdFx0X3RoaXMuc2V0UmVuZGVyVGFyZ2V0KF90cmFuc21pc3Npb25SZW5kZXJUYXJnZXQpO1xuXG5cdFx0XHRfdGhpcy5jbGVhcigpOyAvLyBUdXJuIG9mZiB0aGUgZmVhdHVyZXMgd2hpY2ggY2FuIGFmZmVjdCB0aGUgZnJhZyBjb2xvciBmb3Igb3BhcXVlIG9iamVjdHMgcGFzcy5cblx0XHRcdC8vIE90aGVyd2lzZSB0aGV5IGFyZSBhcHBsaWVkIHR3aWNlIGluIG9wYXF1ZSBvYmplY3RzIHBhc3MgYW5kIHRyYW5zbWlzc2lvbiBvYmplY3RzIHBhc3MuXG5cblxuXHRcdFx0Y29uc3QgY3VycmVudFRvbmVNYXBwaW5nID0gX3RoaXMudG9uZU1hcHBpbmc7XG5cdFx0XHRfdGhpcy50b25lTWFwcGluZyA9IE5vVG9uZU1hcHBpbmc7XG5cdFx0XHRyZW5kZXJPYmplY3RzKG9wYXF1ZU9iamVjdHMsIHNjZW5lLCBjYW1lcmEpO1xuXHRcdFx0X3RoaXMudG9uZU1hcHBpbmcgPSBjdXJyZW50VG9uZU1hcHBpbmc7XG5cdFx0XHR0ZXh0dXJlcy51cGRhdGVNdWx0aXNhbXBsZVJlbmRlclRhcmdldChfdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0KTtcblx0XHRcdHRleHR1cmVzLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcChfdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0KTtcblxuXHRcdFx0X3RoaXMuc2V0UmVuZGVyVGFyZ2V0KGN1cnJlbnRSZW5kZXJUYXJnZXQpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbmRlck9iamVjdHMocmVuZGVyTGlzdCwgc2NlbmUsIGNhbWVyYSkge1xuXHRcdFx0Y29uc3Qgb3ZlcnJpZGVNYXRlcmlhbCA9IHNjZW5lLmlzU2NlbmUgPT09IHRydWUgPyBzY2VuZS5vdmVycmlkZU1hdGVyaWFsIDogbnVsbDtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSByZW5kZXJMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjb25zdCByZW5kZXJJdGVtID0gcmVuZGVyTGlzdFtpXTtcblx0XHRcdFx0Y29uc3Qgb2JqZWN0ID0gcmVuZGVySXRlbS5vYmplY3Q7XG5cdFx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gcmVuZGVySXRlbS5nZW9tZXRyeTtcblx0XHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSBvdmVycmlkZU1hdGVyaWFsID09PSBudWxsID8gcmVuZGVySXRlbS5tYXRlcmlhbCA6IG92ZXJyaWRlTWF0ZXJpYWw7XG5cdFx0XHRcdGNvbnN0IGdyb3VwID0gcmVuZGVySXRlbS5ncm91cDtcblxuXHRcdFx0XHRpZiAob2JqZWN0LmxheWVycy50ZXN0KGNhbWVyYS5sYXllcnMpKSB7XG5cdFx0XHRcdFx0cmVuZGVyT2JqZWN0KG9iamVjdCwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW5kZXJPYmplY3Qob2JqZWN0LCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwKSB7XG5cdFx0XHRvYmplY3Qub25CZWZvcmVSZW5kZXIoX3RoaXMsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXApO1xuXHRcdFx0b2JqZWN0Lm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCk7XG5cdFx0XHRvYmplY3Qubm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeChvYmplY3QubW9kZWxWaWV3TWF0cml4KTtcblx0XHRcdG1hdGVyaWFsLm9uQmVmb3JlUmVuZGVyKF90aGlzLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgb2JqZWN0LCBncm91cCk7XG5cblx0XHRcdGlmIChtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gdHJ1ZSAmJiBtYXRlcmlhbC5zaWRlID09PSBEb3VibGVTaWRlKSB7XG5cdFx0XHRcdG1hdGVyaWFsLnNpZGUgPSBCYWNrU2lkZTtcblx0XHRcdFx0bWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdF90aGlzLnJlbmRlckJ1ZmZlckRpcmVjdChjYW1lcmEsIHNjZW5lLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXApO1xuXG5cdFx0XHRcdG1hdGVyaWFsLnNpZGUgPSBGcm9udFNpZGU7XG5cdFx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRfdGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QoY2FtZXJhLCBzY2VuZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBvYmplY3QsIGdyb3VwKTtcblxuXHRcdFx0XHRtYXRlcmlhbC5zaWRlID0gRG91YmxlU2lkZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF90aGlzLnJlbmRlckJ1ZmZlckRpcmVjdChjYW1lcmEsIHNjZW5lLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXApO1xuXHRcdFx0fVxuXG5cdFx0XHRvYmplY3Qub25BZnRlclJlbmRlcihfdGhpcywgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0UHJvZ3JhbShtYXRlcmlhbCwgc2NlbmUsIG9iamVjdCkge1xuXHRcdFx0aWYgKHNjZW5lLmlzU2NlbmUgIT09IHRydWUpIHNjZW5lID0gX2VtcHR5U2NlbmU7IC8vIHNjZW5lIGNvdWxkIGJlIGEgTWVzaCwgTGluZSwgUG9pbnRzLCAuLi5cblxuXHRcdFx0Y29uc3QgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQobWF0ZXJpYWwpO1xuXHRcdFx0Y29uc3QgbGlnaHRzID0gY3VycmVudFJlbmRlclN0YXRlLnN0YXRlLmxpZ2h0cztcblx0XHRcdGNvbnN0IHNoYWRvd3NBcnJheSA9IGN1cnJlbnRSZW5kZXJTdGF0ZS5zdGF0ZS5zaGFkb3dzQXJyYXk7XG5cdFx0XHRjb25zdCBsaWdodHNTdGF0ZVZlcnNpb24gPSBsaWdodHMuc3RhdGUudmVyc2lvbjtcblx0XHRcdGNvbnN0IHBhcmFtZXRlcnMgPSBwcm9ncmFtQ2FjaGUuZ2V0UGFyYW1ldGVycyhtYXRlcmlhbCwgbGlnaHRzLnN0YXRlLCBzaGFkb3dzQXJyYXksIHNjZW5lLCBvYmplY3QpO1xuXHRcdFx0Y29uc3QgcHJvZ3JhbUNhY2hlS2V5ID0gcHJvZ3JhbUNhY2hlLmdldFByb2dyYW1DYWNoZUtleShwYXJhbWV0ZXJzKTtcblx0XHRcdGxldCBwcm9ncmFtcyA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtczsgLy8gYWx3YXlzIHVwZGF0ZSBlbnZpcm9ubWVudCBhbmQgZm9nIC0gY2hhbmdpbmcgdGhlc2UgdHJpZ2dlciBhbiBnZXRQcm9ncmFtIGNhbGwsIGJ1dCBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHByb2dyYW0gZG9lc24ndCBjaGFuZ2VcblxuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmVudmlyb25tZW50ID0gbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCA/IHNjZW5lLmVudmlyb25tZW50IDogbnVsbDtcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5mb2cgPSBzY2VuZS5mb2c7XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuZW52TWFwID0gKG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPyBjdWJldXZtYXBzIDogY3ViZW1hcHMpLmdldChtYXRlcmlhbC5lbnZNYXAgfHwgbWF0ZXJpYWxQcm9wZXJ0aWVzLmVudmlyb25tZW50KTtcblxuXHRcdFx0aWYgKHByb2dyYW1zID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Ly8gbmV3IG1hdGVyaWFsXG5cdFx0XHRcdG1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvbk1hdGVyaWFsRGlzcG9zZSk7XG5cdFx0XHRcdHByb2dyYW1zID0gbmV3IE1hcCgpO1xuXHRcdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbXMgPSBwcm9ncmFtcztcblx0XHRcdH1cblxuXHRcdFx0bGV0IHByb2dyYW0gPSBwcm9ncmFtcy5nZXQocHJvZ3JhbUNhY2hlS2V5KTtcblxuXHRcdFx0aWYgKHByb2dyYW0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQvLyBlYXJseSBvdXQgaWYgcHJvZ3JhbSBhbmQgbGlnaHQgc3RhdGUgaXMgaWRlbnRpY2FsXG5cdFx0XHRcdGlmIChtYXRlcmlhbFByb3BlcnRpZXMuY3VycmVudFByb2dyYW0gPT09IHByb2dyYW0gJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmxpZ2h0c1N0YXRlVmVyc2lvbiA9PT0gbGlnaHRzU3RhdGVWZXJzaW9uKSB7XG5cdFx0XHRcdFx0dXBkYXRlQ29tbW9uTWF0ZXJpYWxQcm9wZXJ0aWVzKG1hdGVyaWFsLCBwYXJhbWV0ZXJzKTtcblx0XHRcdFx0XHRyZXR1cm4gcHJvZ3JhbTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGFyYW1ldGVycy51bmlmb3JtcyA9IHByb2dyYW1DYWNoZS5nZXRVbmlmb3JtcyhtYXRlcmlhbCk7XG5cdFx0XHRcdG1hdGVyaWFsLm9uQnVpbGQob2JqZWN0LCBwYXJhbWV0ZXJzLCBfdGhpcyk7XG5cdFx0XHRcdG1hdGVyaWFsLm9uQmVmb3JlQ29tcGlsZShwYXJhbWV0ZXJzLCBfdGhpcyk7XG5cdFx0XHRcdHByb2dyYW0gPSBwcm9ncmFtQ2FjaGUuYWNxdWlyZVByb2dyYW0ocGFyYW1ldGVycywgcHJvZ3JhbUNhY2hlS2V5KTtcblx0XHRcdFx0cHJvZ3JhbXMuc2V0KHByb2dyYW1DYWNoZUtleSwgcHJvZ3JhbSk7XG5cdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3JtcyA9IHBhcmFtZXRlcnMudW5pZm9ybXM7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHVuaWZvcm1zID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zO1xuXG5cdFx0XHRpZiAoIW1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgJiYgIW1hdGVyaWFsLmlzUmF3U2hhZGVyTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuY2xpcHBpbmcgPT09IHRydWUpIHtcblx0XHRcdFx0dW5pZm9ybXMuY2xpcHBpbmdQbGFuZXMgPSBjbGlwcGluZy51bmlmb3JtO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGVDb21tb25NYXRlcmlhbFByb3BlcnRpZXMobWF0ZXJpYWwsIHBhcmFtZXRlcnMpOyAvLyBzdG9yZSB0aGUgbGlnaHQgc2V0dXAgaXQgd2FzIGNyZWF0ZWQgZm9yXG5cblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5uZWVkc0xpZ2h0cyA9IG1hdGVyaWFsTmVlZHNMaWdodHMobWF0ZXJpYWwpO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmxpZ2h0c1N0YXRlVmVyc2lvbiA9IGxpZ2h0c1N0YXRlVmVyc2lvbjtcblxuXHRcdFx0aWYgKG1hdGVyaWFsUHJvcGVydGllcy5uZWVkc0xpZ2h0cykge1xuXHRcdFx0XHQvLyB3aXJlIHVwIHRoZSBtYXRlcmlhbCB0byB0aGlzIHJlbmRlcmVyJ3MgbGlnaHRpbmcgc3RhdGVcblx0XHRcdFx0dW5pZm9ybXMuYW1iaWVudExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMuc3RhdGUuYW1iaWVudDtcblx0XHRcdFx0dW5pZm9ybXMubGlnaHRQcm9iZS52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5wcm9iZTtcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodHMudmFsdWUgPSBsaWdodHMuc3RhdGUuZGlyZWN0aW9uYWw7XG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzLnZhbHVlID0gbGlnaHRzLnN0YXRlLmRpcmVjdGlvbmFsU2hhZG93O1xuXHRcdFx0XHR1bmlmb3Jtcy5zcG90TGlnaHRzLnZhbHVlID0gbGlnaHRzLnN0YXRlLnNwb3Q7XG5cdFx0XHRcdHVuaWZvcm1zLnNwb3RMaWdodFNoYWRvd3MudmFsdWUgPSBsaWdodHMuc3RhdGUuc3BvdFNoYWRvdztcblx0XHRcdFx0dW5pZm9ybXMucmVjdEFyZWFMaWdodHMudmFsdWUgPSBsaWdodHMuc3RhdGUucmVjdEFyZWE7XG5cdFx0XHRcdHVuaWZvcm1zLmx0Y18xLnZhbHVlID0gbGlnaHRzLnN0YXRlLnJlY3RBcmVhTFRDMTtcblx0XHRcdFx0dW5pZm9ybXMubHRjXzIudmFsdWUgPSBsaWdodHMuc3RhdGUucmVjdEFyZWFMVEMyO1xuXHRcdFx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0cy52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5wb2ludDtcblx0XHRcdFx0dW5pZm9ybXMucG9pbnRMaWdodFNoYWRvd3MudmFsdWUgPSBsaWdodHMuc3RhdGUucG9pbnRTaGFkb3c7XG5cdFx0XHRcdHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodHMudmFsdWUgPSBsaWdodHMuc3RhdGUuaGVtaTtcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxTaGFkb3dNYXAudmFsdWUgPSBsaWdodHMuc3RhdGUuZGlyZWN0aW9uYWxTaGFkb3dNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4LnZhbHVlID0gbGlnaHRzLnN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4O1xuXHRcdFx0XHR1bmlmb3Jtcy5zcG90U2hhZG93TWFwLnZhbHVlID0gbGlnaHRzLnN0YXRlLnNwb3RTaGFkb3dNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLnNwb3RTaGFkb3dNYXRyaXgudmFsdWUgPSBsaWdodHMuc3RhdGUuc3BvdFNoYWRvd01hdHJpeDtcblx0XHRcdFx0dW5pZm9ybXMucG9pbnRTaGFkb3dNYXAudmFsdWUgPSBsaWdodHMuc3RhdGUucG9pbnRTaGFkb3dNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLnBvaW50U2hhZG93TWF0cml4LnZhbHVlID0gbGlnaHRzLnN0YXRlLnBvaW50U2hhZG93TWF0cml4OyAvLyBUT0RPIChhYmVsbmF0aW9uKTogYWRkIGFyZWEgbGlnaHRzIHNoYWRvdyBpbmZvIHRvIHVuaWZvcm1zXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHByb2dVbmlmb3JtcyA9IHByb2dyYW0uZ2V0VW5pZm9ybXMoKTtcblx0XHRcdGNvbnN0IHVuaWZvcm1zTGlzdCA9IFdlYkdMVW5pZm9ybXMuc2VxV2l0aFZhbHVlKHByb2dVbmlmb3Jtcy5zZXEsIHVuaWZvcm1zKTtcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5jdXJyZW50UHJvZ3JhbSA9IHByb2dyYW07XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0ID0gdW5pZm9ybXNMaXN0O1xuXHRcdFx0cmV0dXJuIHByb2dyYW07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlQ29tbW9uTWF0ZXJpYWxQcm9wZXJ0aWVzKG1hdGVyaWFsLCBwYXJhbWV0ZXJzKSB7XG5cdFx0XHRjb25zdCBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldChtYXRlcmlhbCk7XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMub3V0cHV0RW5jb2RpbmcgPSBwYXJhbWV0ZXJzLm91dHB1dEVuY29kaW5nO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmluc3RhbmNpbmcgPSBwYXJhbWV0ZXJzLmluc3RhbmNpbmc7XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuc2tpbm5pbmcgPSBwYXJhbWV0ZXJzLnNraW5uaW5nO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLm1vcnBoVGFyZ2V0cyA9IHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLm1vcnBoTm9ybWFscyA9IHBhcmFtZXRlcnMubW9ycGhOb3JtYWxzO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLm1vcnBoVGFyZ2V0c0NvdW50ID0gcGFyYW1ldGVycy5tb3JwaFRhcmdldHNDb3VudDtcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5udW1DbGlwcGluZ1BsYW5lcyA9IHBhcmFtZXRlcnMubnVtQ2xpcHBpbmdQbGFuZXM7XG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMubnVtSW50ZXJzZWN0aW9uID0gcGFyYW1ldGVycy5udW1DbGlwSW50ZXJzZWN0aW9uO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLnZlcnRleEFscGhhcyA9IHBhcmFtZXRlcnMudmVydGV4QWxwaGFzO1xuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLnZlcnRleFRhbmdlbnRzID0gcGFyYW1ldGVycy52ZXJ0ZXhUYW5nZW50cztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXRQcm9ncmFtKGNhbWVyYSwgc2NlbmUsIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0KSB7XG5cdFx0XHRpZiAoc2NlbmUuaXNTY2VuZSAhPT0gdHJ1ZSkgc2NlbmUgPSBfZW1wdHlTY2VuZTsgLy8gc2NlbmUgY291bGQgYmUgYSBNZXNoLCBMaW5lLCBQb2ludHMsIC4uLlxuXG5cdFx0XHR0ZXh0dXJlcy5yZXNldFRleHR1cmVVbml0cygpO1xuXHRcdFx0Y29uc3QgZm9nID0gc2NlbmUuZm9nO1xuXHRcdFx0Y29uc3QgZW52aXJvbm1lbnQgPSBtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsID8gc2NlbmUuZW52aXJvbm1lbnQgOiBudWxsO1xuXHRcdFx0Y29uc3QgZW5jb2RpbmcgPSBfY3VycmVudFJlbmRlclRhcmdldCA9PT0gbnVsbCA/IF90aGlzLm91dHB1dEVuY29kaW5nIDogX2N1cnJlbnRSZW5kZXJUYXJnZXQudGV4dHVyZS5lbmNvZGluZztcblx0XHRcdGNvbnN0IGVudk1hcCA9IChtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsID8gY3ViZXV2bWFwcyA6IGN1YmVtYXBzKS5nZXQobWF0ZXJpYWwuZW52TWFwIHx8IGVudmlyb25tZW50KTtcblx0XHRcdGNvbnN0IHZlcnRleEFscGhhcyA9IG1hdGVyaWFsLnZlcnRleENvbG9ycyA9PT0gdHJ1ZSAmJiAhIWdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IgJiYgZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5pdGVtU2l6ZSA9PT0gNDtcblx0XHRcdGNvbnN0IHZlcnRleFRhbmdlbnRzID0gISFtYXRlcmlhbC5ub3JtYWxNYXAgJiYgISFnZW9tZXRyeS5hdHRyaWJ1dGVzLnRhbmdlbnQ7XG5cdFx0XHRjb25zdCBtb3JwaFRhcmdldHMgPSAhIWdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdGNvbnN0IG1vcnBoTm9ybWFscyA9ICEhZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbDtcblx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0c0NvdW50ID0gISFnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gPyBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24ubGVuZ3RoIDogMDtcblx0XHRcdGNvbnN0IG1hdGVyaWFsUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KG1hdGVyaWFsKTtcblx0XHRcdGNvbnN0IGxpZ2h0cyA9IGN1cnJlbnRSZW5kZXJTdGF0ZS5zdGF0ZS5saWdodHM7XG5cblx0XHRcdGlmIChfY2xpcHBpbmdFbmFibGVkID09PSB0cnVlKSB7XG5cdFx0XHRcdGlmIChfbG9jYWxDbGlwcGluZ0VuYWJsZWQgPT09IHRydWUgfHwgY2FtZXJhICE9PSBfY3VycmVudENhbWVyYSkge1xuXHRcdFx0XHRcdGNvbnN0IHVzZUNhY2hlID0gY2FtZXJhID09PSBfY3VycmVudENhbWVyYSAmJiBtYXRlcmlhbC5pZCA9PT0gX2N1cnJlbnRNYXRlcmlhbElkOyAvLyB3ZSBtaWdodCB3YW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiB3aXRoIHNvbWUgQ2xpcHBpbmdHcm91cFxuXHRcdFx0XHRcdC8vIG9iamVjdCBpbnN0ZWFkIG9mIHRoZSBtYXRlcmlhbCwgb25jZSBpdCBiZWNvbWVzIGZlYXNpYmxlXG5cdFx0XHRcdFx0Ly8gKCM4NDY1LCAjODM3OSlcblxuXHRcdFx0XHRcdGNsaXBwaW5nLnNldFN0YXRlKG1hdGVyaWFsLCBjYW1lcmEsIHVzZUNhY2hlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSAvL1xuXG5cblx0XHRcdGxldCBuZWVkc1Byb2dyYW1DaGFuZ2UgPSBmYWxzZTtcblxuXHRcdFx0aWYgKG1hdGVyaWFsLnZlcnNpb24gPT09IG1hdGVyaWFsUHJvcGVydGllcy5fX3ZlcnNpb24pIHtcblx0XHRcdFx0aWYgKG1hdGVyaWFsUHJvcGVydGllcy5uZWVkc0xpZ2h0cyAmJiBtYXRlcmlhbFByb3BlcnRpZXMubGlnaHRzU3RhdGVWZXJzaW9uICE9PSBsaWdodHMuc3RhdGUudmVyc2lvbikge1xuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWxQcm9wZXJ0aWVzLm91dHB1dEVuY29kaW5nICE9PSBlbmNvZGluZykge1xuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAob2JqZWN0LmlzSW5zdGFuY2VkTWVzaCAmJiBtYXRlcmlhbFByb3BlcnRpZXMuaW5zdGFuY2luZyA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFvYmplY3QuaXNJbnN0YW5jZWRNZXNoICYmIG1hdGVyaWFsUHJvcGVydGllcy5pbnN0YW5jaW5nID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChvYmplY3QuaXNTa2lubmVkTWVzaCAmJiBtYXRlcmlhbFByb3BlcnRpZXMuc2tpbm5pbmcgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICghb2JqZWN0LmlzU2tpbm5lZE1lc2ggJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLnNraW5uaW5nID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbFByb3BlcnRpZXMuZW52TWFwICE9PSBlbnZNYXApIHtcblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsLmZvZyAmJiBtYXRlcmlhbFByb3BlcnRpZXMuZm9nICE9PSBmb2cpIHtcblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsUHJvcGVydGllcy5udW1DbGlwcGluZ1BsYW5lcyAhPT0gdW5kZWZpbmVkICYmIChtYXRlcmlhbFByb3BlcnRpZXMubnVtQ2xpcHBpbmdQbGFuZXMgIT09IGNsaXBwaW5nLm51bVBsYW5lcyB8fCBtYXRlcmlhbFByb3BlcnRpZXMubnVtSW50ZXJzZWN0aW9uICE9PSBjbGlwcGluZy5udW1JbnRlcnNlY3Rpb24pKSB7XG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChtYXRlcmlhbFByb3BlcnRpZXMudmVydGV4QWxwaGFzICE9PSB2ZXJ0ZXhBbHBoYXMpIHtcblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsUHJvcGVydGllcy52ZXJ0ZXhUYW5nZW50cyAhPT0gdmVydGV4VGFuZ2VudHMpIHtcblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG1hdGVyaWFsUHJvcGVydGllcy5tb3JwaFRhcmdldHMgIT09IG1vcnBoVGFyZ2V0cykge1xuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAobWF0ZXJpYWxQcm9wZXJ0aWVzLm1vcnBoTm9ybWFscyAhPT0gbW9ycGhOb3JtYWxzKSB7XG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChjYXBhYmlsaXRpZXMuaXNXZWJHTDIgPT09IHRydWUgJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLm1vcnBoVGFyZ2V0c0NvdW50ICE9PSBtb3JwaFRhcmdldHNDb3VudCkge1xuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5fX3ZlcnNpb24gPSBtYXRlcmlhbC52ZXJzaW9uO1xuXHRcdFx0fSAvL1xuXG5cblx0XHRcdGxldCBwcm9ncmFtID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLmN1cnJlbnRQcm9ncmFtO1xuXG5cdFx0XHRpZiAobmVlZHNQcm9ncmFtQ2hhbmdlID09PSB0cnVlKSB7XG5cdFx0XHRcdHByb2dyYW0gPSBnZXRQcm9ncmFtKG1hdGVyaWFsLCBzY2VuZSwgb2JqZWN0KTtcblx0XHRcdH1cblxuXHRcdFx0bGV0IHJlZnJlc2hQcm9ncmFtID0gZmFsc2U7XG5cdFx0XHRsZXQgcmVmcmVzaE1hdGVyaWFsID0gZmFsc2U7XG5cdFx0XHRsZXQgcmVmcmVzaExpZ2h0cyA9IGZhbHNlO1xuXHRcdFx0Y29uc3QgcF91bmlmb3JtcyA9IHByb2dyYW0uZ2V0VW5pZm9ybXMoKSxcblx0XHRcdFx0XHRcdG1fdW5pZm9ybXMgPSBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXM7XG5cblx0XHRcdGlmIChzdGF0ZS51c2VQcm9ncmFtKHByb2dyYW0ucHJvZ3JhbSkpIHtcblx0XHRcdFx0cmVmcmVzaFByb2dyYW0gPSB0cnVlO1xuXHRcdFx0XHRyZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1xuXHRcdFx0XHRyZWZyZXNoTGlnaHRzID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1hdGVyaWFsLmlkICE9PSBfY3VycmVudE1hdGVyaWFsSWQpIHtcblx0XHRcdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gbWF0ZXJpYWwuaWQ7XG5cdFx0XHRcdHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChyZWZyZXNoUHJvZ3JhbSB8fCBfY3VycmVudENhbWVyYSAhPT0gY2FtZXJhKSB7XG5cdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAncHJvamVjdGlvbk1hdHJpeCcsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4KTtcblxuXHRcdFx0XHRpZiAoY2FwYWJpbGl0aWVzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIpIHtcblx0XHRcdFx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKF9nbCwgJ2xvZ0RlcHRoQnVmRkMnLCAyLjAgLyAoTWF0aC5sb2coY2FtZXJhLmZhciArIDEuMCkgLyBNYXRoLkxOMikpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKF9jdXJyZW50Q2FtZXJhICE9PSBjYW1lcmEpIHtcblx0XHRcdFx0XHRfY3VycmVudENhbWVyYSA9IGNhbWVyYTsgLy8gbGlnaHRpbmcgdW5pZm9ybXMgZGVwZW5kIG9uIHRoZSBjYW1lcmEgc28gZW5mb3JjZSBhbiB1cGRhdGVcblx0XHRcdFx0XHQvLyBub3csIGluIGNhc2UgdGhpcyBtYXRlcmlhbCBzdXBwb3J0cyBsaWdodHMgLSBvciBsYXRlciwgd2hlblxuXHRcdFx0XHRcdC8vIHRoZSBuZXh0IG1hdGVyaWFsIHRoYXQgZG9lcyBnZXRzIGFjdGl2YXRlZDpcblxuXHRcdFx0XHRcdHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7IC8vIHNldCB0byB0cnVlIG9uIG1hdGVyaWFsIGNoYW5nZVxuXG5cdFx0XHRcdFx0cmVmcmVzaExpZ2h0cyA9IHRydWU7IC8vIHJlbWFpbnMgc2V0IHVudGlsIHVwZGF0ZSBkb25lXG5cdFx0XHRcdH0gLy8gbG9hZCBtYXRlcmlhbCBzcGVjaWZpYyB1bmlmb3Jtc1xuXHRcdFx0XHQvLyAoc2hhZGVyIG1hdGVyaWFsIGFsc28gZ2V0cyB0aGVtIGZvciB0aGUgc2FrZSBvZiBnZW5lcmljaXR5KVxuXG5cblx0XHRcdFx0aWYgKG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hUb29uTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCB8fCBtYXRlcmlhbC5lbnZNYXApIHtcblx0XHRcdFx0XHRjb25zdCB1Q2FtUG9zID0gcF91bmlmb3Jtcy5tYXAuY2FtZXJhUG9zaXRpb247XG5cblx0XHRcdFx0XHRpZiAodUNhbVBvcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHR1Q2FtUG9zLnNldFZhbHVlKF9nbCwgX3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGNhbWVyYS5tYXRyaXhXb3JsZCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChtYXRlcmlhbC5pc01lc2hQaG9uZ01hdGVyaWFsIHx8IG1hdGVyaWFsLmlzTWVzaFRvb25NYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hMYW1iZXJ0TWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNNZXNoQmFzaWNNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsIHx8IG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwpIHtcblx0XHRcdFx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKF9nbCwgJ2lzT3J0aG9ncmFwaGljJywgY2FtZXJhLmlzT3J0aG9ncmFwaGljQ2FtZXJhID09PSB0cnVlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChtYXRlcmlhbC5pc01lc2hQaG9uZ01hdGVyaWFsIHx8IG1hdGVyaWFsLmlzTWVzaFRvb25NYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hMYW1iZXJ0TWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNNZXNoQmFzaWNNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsIHx8IG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNTaGFkb3dNYXRlcmlhbCB8fCBvYmplY3QuaXNTa2lubmVkTWVzaCkge1xuXHRcdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAndmlld01hdHJpeCcsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IC8vIHNraW5uaW5nIGFuZCBtb3JwaCB0YXJnZXQgdW5pZm9ybXMgbXVzdCBiZSBzZXQgZXZlbiBpZiBtYXRlcmlhbCBkaWRuJ3QgY2hhbmdlXG5cdFx0XHQvLyBhdXRvLXNldHRpbmcgb2YgdGV4dHVyZSB1bml0IGZvciBib25lIGFuZCBtb3JwaCB0ZXh0dXJlIG11c3QgZ28gYmVmb3JlIG90aGVyIHRleHR1cmVzXG5cdFx0XHQvLyBvdGhlcndpc2UgdGV4dHVyZXMgdXNlZCBmb3Igc2tpbm5pbmcgYW5kIG1vcnBoaW5nIGNhbiB0YWtlIG92ZXIgdGV4dHVyZSB1bml0cyByZXNlcnZlZCBmb3Igb3RoZXIgbWF0ZXJpYWwgdGV4dHVyZXNcblxuXG5cdFx0XHRpZiAob2JqZWN0LmlzU2tpbm5lZE1lc2gpIHtcblx0XHRcdFx0cF91bmlmb3Jtcy5zZXRPcHRpb25hbChfZ2wsIG9iamVjdCwgJ2JpbmRNYXRyaXgnKTtcblx0XHRcdFx0cF91bmlmb3Jtcy5zZXRPcHRpb25hbChfZ2wsIG9iamVjdCwgJ2JpbmRNYXRyaXhJbnZlcnNlJyk7XG5cdFx0XHRcdGNvbnN0IHNrZWxldG9uID0gb2JqZWN0LnNrZWxldG9uO1xuXG5cdFx0XHRcdGlmIChza2VsZXRvbikge1xuXHRcdFx0XHRcdGlmIChjYXBhYmlsaXRpZXMuZmxvYXRWZXJ0ZXhUZXh0dXJlcykge1xuXHRcdFx0XHRcdFx0aWYgKHNrZWxldG9uLmJvbmVUZXh0dXJlID09PSBudWxsKSBza2VsZXRvbi5jb21wdXRlQm9uZVRleHR1cmUoKTtcblx0XHRcdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAnYm9uZVRleHR1cmUnLCBza2VsZXRvbi5ib25lVGV4dHVyZSwgdGV4dHVyZXMpO1xuXHRcdFx0XHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZShfZ2wsICdib25lVGV4dHVyZVNpemUnLCBza2VsZXRvbi5ib25lVGV4dHVyZVNpemUpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwX3VuaWZvcm1zLnNldE9wdGlvbmFsKF9nbCwgc2tlbGV0b24sICdib25lTWF0cmljZXMnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCEhZ2VvbWV0cnkgJiYgKGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkIHx8IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgIT09IHVuZGVmaW5lZCkpIHtcblx0XHRcdFx0bW9ycGh0YXJnZXRzLnVwZGF0ZShvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcHJvZ3JhbSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChyZWZyZXNoTWF0ZXJpYWwgfHwgbWF0ZXJpYWxQcm9wZXJ0aWVzLnJlY2VpdmVTaGFkb3cgIT09IG9iamVjdC5yZWNlaXZlU2hhZG93KSB7XG5cdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5yZWNlaXZlU2hhZG93ID0gb2JqZWN0LnJlY2VpdmVTaGFkb3c7XG5cdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAncmVjZWl2ZVNoYWRvdycsIG9iamVjdC5yZWNlaXZlU2hhZG93KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHJlZnJlc2hNYXRlcmlhbCkge1xuXHRcdFx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKF9nbCwgJ3RvbmVNYXBwaW5nRXhwb3N1cmUnLCBfdGhpcy50b25lTWFwcGluZ0V4cG9zdXJlKTtcblxuXHRcdFx0XHRpZiAobWF0ZXJpYWxQcm9wZXJ0aWVzLm5lZWRzTGlnaHRzKSB7XG5cdFx0XHRcdFx0Ly8gdGhlIGN1cnJlbnQgbWF0ZXJpYWwgcmVxdWlyZXMgbGlnaHRpbmcgaW5mb1xuXHRcdFx0XHRcdC8vIG5vdGU6IGFsbCBsaWdodGluZyB1bmlmb3JtcyBhcmUgYWx3YXlzIHNldCBjb3JyZWN0bHlcblx0XHRcdFx0XHQvLyB0aGV5IHNpbXBseSByZWZlcmVuY2UgdGhlIHJlbmRlcmVyJ3Mgc3RhdGUgZm9yIHRoZWlyXG5cdFx0XHRcdFx0Ly8gdmFsdWVzXG5cdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHQvLyB1c2UgdGhlIGN1cnJlbnQgbWF0ZXJpYWwncyAubmVlZHNVcGRhdGUgZmxhZ3MgdG8gc2V0XG5cdFx0XHRcdFx0Ly8gdGhlIEdMIHN0YXRlIHdoZW4gcmVxdWlyZWRcblx0XHRcdFx0XHRtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZShtX3VuaWZvcm1zLCByZWZyZXNoTGlnaHRzKTtcblx0XHRcdFx0fSAvLyByZWZyZXNoIHVuaWZvcm1zIGNvbW1vbiB0byBzZXZlcmFsIG1hdGVyaWFsc1xuXG5cblx0XHRcdFx0aWYgKGZvZyAmJiBtYXRlcmlhbC5mb2cpIHtcblx0XHRcdFx0XHRtYXRlcmlhbHMucmVmcmVzaEZvZ1VuaWZvcm1zKG1fdW5pZm9ybXMsIGZvZyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtYXRlcmlhbHMucmVmcmVzaE1hdGVyaWFsVW5pZm9ybXMobV91bmlmb3JtcywgbWF0ZXJpYWwsIF9waXhlbFJhdGlvLCBfaGVpZ2h0LCBfdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0KTtcblx0XHRcdFx0V2ViR0xVbmlmb3Jtcy51cGxvYWQoX2dsLCBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0LCBtX3VuaWZvcm1zLCB0ZXh0dXJlcyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsICYmIG1hdGVyaWFsLnVuaWZvcm1zTmVlZFVwZGF0ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRXZWJHTFVuaWZvcm1zLnVwbG9hZChfZ2wsIG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QsIG1fdW5pZm9ybXMsIHRleHR1cmVzKTtcblx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXRlcmlhbC5pc1Nwcml0ZU1hdGVyaWFsKSB7XG5cdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAnY2VudGVyJywgb2JqZWN0LmNlbnRlcik7XG5cdFx0XHR9IC8vIGNvbW1vbiBtYXRyaWNlc1xuXG5cblx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAnbW9kZWxWaWV3TWF0cml4Jywgb2JqZWN0Lm1vZGVsVmlld01hdHJpeCk7XG5cdFx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKF9nbCwgJ25vcm1hbE1hdHJpeCcsIG9iamVjdC5ub3JtYWxNYXRyaXgpO1xuXHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZShfZ2wsICdtb2RlbE1hdHJpeCcsIG9iamVjdC5tYXRyaXhXb3JsZCk7XG5cdFx0XHRyZXR1cm4gcHJvZ3JhbTtcblx0XHR9IC8vIElmIHVuaWZvcm1zIGFyZSBtYXJrZWQgYXMgY2xlYW4sIHRoZXkgZG9uJ3QgbmVlZCB0byBiZSBsb2FkZWQgdG8gdGhlIEdQVS5cblxuXG5cdFx0ZnVuY3Rpb24gbWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUodW5pZm9ybXMsIHZhbHVlKSB7XG5cdFx0XHR1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXHRcdFx0dW5pZm9ybXMubGlnaHRQcm9iZS5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cdFx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXHRcdFx0dW5pZm9ybXMucG9pbnRMaWdodFNoYWRvd3MubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHRcdHVuaWZvcm1zLnNwb3RMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHRcdHVuaWZvcm1zLnNwb3RMaWdodFNoYWRvd3MubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHRcdHVuaWZvcm1zLnJlY3RBcmVhTGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cdFx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbWF0ZXJpYWxOZWVkc0xpZ2h0cyhtYXRlcmlhbCkge1xuXHRcdFx0cmV0dXJuIG1hdGVyaWFsLmlzTWVzaExhbWJlcnRNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hUb29uTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsIHx8IG1hdGVyaWFsLmlzU2hhZG93TWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCAmJiBtYXRlcmlhbC5saWdodHMgPT09IHRydWU7XG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRBY3RpdmVDdWJlRmFjZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBfY3VycmVudEFjdGl2ZUN1YmVGYWNlO1xuXHRcdH07XG5cblx0XHR0aGlzLmdldEFjdGl2ZU1pcG1hcExldmVsID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIF9jdXJyZW50QWN0aXZlTWlwbWFwTGV2ZWw7XG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0UmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIF9jdXJyZW50UmVuZGVyVGFyZ2V0O1xuXHRcdH07XG5cblx0XHR0aGlzLnNldFJlbmRlclRhcmdldFRleHR1cmVzID0gZnVuY3Rpb24gKHJlbmRlclRhcmdldCwgY29sb3JUZXh0dXJlLCBkZXB0aFRleHR1cmUpIHtcblx0XHRcdHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldC50ZXh0dXJlKS5fX3dlYmdsVGV4dHVyZSA9IGNvbG9yVGV4dHVyZTtcblx0XHRcdHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUpLl9fd2ViZ2xUZXh0dXJlID0gZGVwdGhUZXh0dXJlO1xuXHRcdFx0Y29uc3QgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldCk7XG5cdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9faGFzRXh0ZXJuYWxUZXh0dXJlcyA9IHRydWU7XG5cblx0XHRcdGlmIChyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9faGFzRXh0ZXJuYWxUZXh0dXJlcykge1xuXHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fYXV0b0FsbG9jYXRlRGVwdGhCdWZmZXIgPSBkZXB0aFRleHR1cmUgPT09IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRpZiAoIXJlbmRlclRhcmdldFByb3BlcnRpZXMuX19hdXRvQWxsb2NhdGVEZXB0aEJ1ZmZlcikge1xuXHRcdFx0XHRcdC8vIFRoZSBtdWx0aXNhbXBsZV9yZW5kZXJfdG9fdGV4dHVyZSBleHRlbnNpb24gZG9lc24ndCB3b3JrIHByb3Blcmx5IGlmIHRoZXJlXG5cdFx0XHRcdFx0Ly8gYXJlIG1pZGZyYW1lIGZsdXNoZXMgYW5kIGFuIGV4dGVybmFsIGRlcHRoIGJ1ZmZlci4gRGlzYWJsZSB1c2Ugb2YgdGhlIGV4dGVuc2lvbi5cblx0XHRcdFx0XHRpZiAocmVuZGVyVGFyZ2V0LnVzZVJlbmRlclRvVGV4dHVyZSkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCdyZW5kZXItdG8tdGV4dHVyZSBleHRlbnNpb24gd2FzIGRpc2FibGVkIGJlY2F1c2UgYW4gZXh0ZXJuYWwgdGV4dHVyZSB3YXMgcHJvdmlkZWQnKTtcblx0XHRcdFx0XHRcdHJlbmRlclRhcmdldC51c2VSZW5kZXJUb1RleHR1cmUgPSBmYWxzZTtcblx0XHRcdFx0XHRcdHJlbmRlclRhcmdldC51c2VSZW5kZXJidWZmZXIgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR0aGlzLnNldFJlbmRlclRhcmdldEZyYW1lYnVmZmVyID0gZnVuY3Rpb24gKHJlbmRlclRhcmdldCwgZGVmYXVsdEZyYW1lYnVmZmVyKSB7XG5cdFx0XHRjb25zdCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0KTtcblx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyID0gZGVmYXVsdEZyYW1lYnVmZmVyO1xuXHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3VzZURlZmF1bHRGcmFtZWJ1ZmZlciA9IGRlZmF1bHRGcmFtZWJ1ZmZlciA9PT0gdW5kZWZpbmVkO1xuXHRcdH07XG5cblx0XHR0aGlzLnNldFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uIChyZW5kZXJUYXJnZXQsIGFjdGl2ZUN1YmVGYWNlID0gMCwgYWN0aXZlTWlwbWFwTGV2ZWwgPSAwKSB7XG5cdFx0XHRfY3VycmVudFJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcblx0XHRcdF9jdXJyZW50QWN0aXZlQ3ViZUZhY2UgPSBhY3RpdmVDdWJlRmFjZTtcblx0XHRcdF9jdXJyZW50QWN0aXZlTWlwbWFwTGV2ZWwgPSBhY3RpdmVNaXBtYXBMZXZlbDtcblx0XHRcdGxldCB1c2VEZWZhdWx0RnJhbWVidWZmZXIgPSB0cnVlO1xuXG5cdFx0XHRpZiAocmVuZGVyVGFyZ2V0KSB7XG5cdFx0XHRcdGNvbnN0IHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldChyZW5kZXJUYXJnZXQpO1xuXG5cdFx0XHRcdGlmIChyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fdXNlRGVmYXVsdEZyYW1lYnVmZmVyICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHQvLyBXZSBuZWVkIHRvIG1ha2Ugc3VyZSB0byByZWJpbmQgdGhlIGZyYW1lYnVmZmVyLlxuXHRcdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcihfZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXHRcdFx0XHRcdHVzZURlZmF1bHRGcmFtZWJ1ZmZlciA9IGZhbHNlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0ZXh0dXJlcy5zZXR1cFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHJlbmRlclRhcmdldFByb3BlcnRpZXMuX19oYXNFeHRlcm5hbFRleHR1cmVzKSB7XG5cdFx0XHRcdFx0Ly8gQ29sb3IgYW5kIGRlcHRoIHRleHR1cmUgbXVzdCBiZSByZWJvdW5kIGluIG9yZGVyIGZvciB0aGUgc3dhcGNoYWluIHRvIHVwZGF0ZS5cblx0XHRcdFx0XHR0ZXh0dXJlcy5yZWJpbmRUZXh0dXJlcyhyZW5kZXJUYXJnZXQsIHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldC50ZXh0dXJlKS5fX3dlYmdsVGV4dHVyZSwgcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSkuX193ZWJnbFRleHR1cmUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGxldCBmcmFtZWJ1ZmZlciA9IG51bGw7XG5cdFx0XHRsZXQgaXNDdWJlID0gZmFsc2U7XG5cdFx0XHRsZXQgaXNSZW5kZXJUYXJnZXQzRCA9IGZhbHNlO1xuXG5cdFx0XHRpZiAocmVuZGVyVGFyZ2V0KSB7XG5cdFx0XHRcdGNvbnN0IHRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcblxuXHRcdFx0XHRpZiAodGV4dHVyZS5pc0RhdGFUZXh0dXJlM0QgfHwgdGV4dHVyZS5pc0RhdGFUZXh0dXJlMkRBcnJheSkge1xuXHRcdFx0XHRcdGlzUmVuZGVyVGFyZ2V0M0QgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgX193ZWJnbEZyYW1lYnVmZmVyID0gcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0KS5fX3dlYmdsRnJhbWVidWZmZXI7XG5cblx0XHRcdFx0aWYgKHJlbmRlclRhcmdldC5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCkge1xuXHRcdFx0XHRcdGZyYW1lYnVmZmVyID0gX193ZWJnbEZyYW1lYnVmZmVyW2FjdGl2ZUN1YmVGYWNlXTtcblx0XHRcdFx0XHRpc0N1YmUgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHJlbmRlclRhcmdldC51c2VSZW5kZXJidWZmZXIpIHtcblx0XHRcdFx0XHRmcmFtZWJ1ZmZlciA9IHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldCkuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZyYW1lYnVmZmVyID0gX193ZWJnbEZyYW1lYnVmZmVyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2N1cnJlbnRWaWV3cG9ydC5jb3B5KHJlbmRlclRhcmdldC52aWV3cG9ydCk7XG5cblx0XHRcdFx0X2N1cnJlbnRTY2lzc29yLmNvcHkocmVuZGVyVGFyZ2V0LnNjaXNzb3IpO1xuXG5cdFx0XHRcdF9jdXJyZW50U2Npc3NvclRlc3QgPSByZW5kZXJUYXJnZXQuc2Npc3NvclRlc3Q7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfY3VycmVudFZpZXdwb3J0LmNvcHkoX3ZpZXdwb3J0KS5tdWx0aXBseVNjYWxhcihfcGl4ZWxSYXRpbykuZmxvb3IoKTtcblxuXHRcdFx0XHRfY3VycmVudFNjaXNzb3IuY29weShfc2Npc3NvcikubXVsdGlwbHlTY2FsYXIoX3BpeGVsUmF0aW8pLmZsb29yKCk7XG5cblx0XHRcdFx0X2N1cnJlbnRTY2lzc29yVGVzdCA9IF9zY2lzc29yVGVzdDtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZnJhbWVidWZmZXJCb3VuZCA9IHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcihfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTtcblxuXHRcdFx0aWYgKGZyYW1lYnVmZmVyQm91bmQgJiYgY2FwYWJpbGl0aWVzLmRyYXdCdWZmZXJzICYmIHVzZURlZmF1bHRGcmFtZWJ1ZmZlcikge1xuXHRcdFx0XHRsZXQgbmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0XHRpZiAocmVuZGVyVGFyZ2V0KSB7XG5cdFx0XHRcdFx0aWYgKHJlbmRlclRhcmdldC5pc1dlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlcyA9IHJlbmRlclRhcmdldC50ZXh0dXJlO1xuXG5cdFx0XHRcdFx0XHRpZiAoX2N1cnJlbnREcmF3QnVmZmVycy5sZW5ndGggIT09IHRleHR1cmVzLmxlbmd0aCB8fCBfY3VycmVudERyYXdCdWZmZXJzWzBdICE9PSBfZ2wuQ09MT1JfQVRUQUNITUVOVDApIHtcblx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gdGV4dHVyZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdF9jdXJyZW50RHJhd0J1ZmZlcnNbaV0gPSBfZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0X2N1cnJlbnREcmF3QnVmZmVycy5sZW5ndGggPSB0ZXh0dXJlcy5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdG5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKF9jdXJyZW50RHJhd0J1ZmZlcnMubGVuZ3RoICE9PSAxIHx8IF9jdXJyZW50RHJhd0J1ZmZlcnNbMF0gIT09IF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCkge1xuXHRcdFx0XHRcdFx0XHRfY3VycmVudERyYXdCdWZmZXJzWzBdID0gX2dsLkNPTE9SX0FUVEFDSE1FTlQwO1xuXHRcdFx0XHRcdFx0XHRfY3VycmVudERyYXdCdWZmZXJzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0XHRcdG5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKF9jdXJyZW50RHJhd0J1ZmZlcnMubGVuZ3RoICE9PSAxIHx8IF9jdXJyZW50RHJhd0J1ZmZlcnNbMF0gIT09IF9nbC5CQUNLKSB7XG5cdFx0XHRcdFx0XHRfY3VycmVudERyYXdCdWZmZXJzWzBdID0gX2dsLkJBQ0s7XG5cdFx0XHRcdFx0XHRfY3VycmVudERyYXdCdWZmZXJzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0XHRuZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG5lZWRzVXBkYXRlKSB7XG5cdFx0XHRcdFx0aWYgKGNhcGFiaWxpdGllcy5pc1dlYkdMMikge1xuXHRcdFx0XHRcdFx0X2dsLmRyYXdCdWZmZXJzKF9jdXJyZW50RHJhd0J1ZmZlcnMpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRleHRlbnNpb25zLmdldCgnV0VCR0xfZHJhd19idWZmZXJzJykuZHJhd0J1ZmZlcnNXRUJHTChfY3VycmVudERyYXdCdWZmZXJzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0c3RhdGUudmlld3BvcnQoX2N1cnJlbnRWaWV3cG9ydCk7XG5cdFx0XHRzdGF0ZS5zY2lzc29yKF9jdXJyZW50U2Npc3Nvcik7XG5cdFx0XHRzdGF0ZS5zZXRTY2lzc29yVGVzdChfY3VycmVudFNjaXNzb3JUZXN0KTtcblxuXHRcdFx0aWYgKGlzQ3ViZSkge1xuXHRcdFx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldC50ZXh0dXJlKTtcblxuXHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoX2dsLkZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBhY3RpdmVDdWJlRmFjZSwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUsIGFjdGl2ZU1pcG1hcExldmVsKTtcblx0XHRcdH0gZWxzZSBpZiAoaXNSZW5kZXJUYXJnZXQzRCkge1xuXHRcdFx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldC50ZXh0dXJlKTtcblx0XHRcdFx0Y29uc3QgbGF5ZXIgPSBhY3RpdmVDdWJlRmFjZSB8fCAwO1xuXG5cdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmVMYXllcihfZ2wuRlJBTUVCVUZGRVIsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUsIGFjdGl2ZU1pcG1hcExldmVsIHx8IDAsIGxheWVyKTtcblx0XHRcdH1cblxuXHRcdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gLTE7IC8vIHJlc2V0IGN1cnJlbnQgbWF0ZXJpYWwgdG8gZW5zdXJlIGNvcnJlY3QgdW5pZm9ybSBiaW5kaW5nc1xuXHRcdH07XG5cblx0XHR0aGlzLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHMgPSBmdW5jdGlvbiAocmVuZGVyVGFyZ2V0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBidWZmZXIsIGFjdGl2ZUN1YmVGYWNlSW5kZXgpIHtcblx0XHRcdGlmICghKHJlbmRlclRhcmdldCAmJiByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldCkpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LicpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGxldCBmcmFtZWJ1ZmZlciA9IHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldCkuX193ZWJnbEZyYW1lYnVmZmVyO1xuXG5cdFx0XHRpZiAocmVuZGVyVGFyZ2V0LmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0ICYmIGFjdGl2ZUN1YmVGYWNlSW5kZXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRmcmFtZWJ1ZmZlciA9IGZyYW1lYnVmZmVyW2FjdGl2ZUN1YmVGYWNlSW5kZXhdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZnJhbWVidWZmZXIpIHtcblx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y29uc3QgdGV4dHVyZSA9IHJlbmRlclRhcmdldC50ZXh0dXJlO1xuXHRcdFx0XHRcdGNvbnN0IHRleHR1cmVGb3JtYXQgPSB0ZXh0dXJlLmZvcm1hdDtcblx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlVHlwZSA9IHRleHR1cmUudHlwZTtcblxuXHRcdFx0XHRcdGlmICh0ZXh0dXJlRm9ybWF0ICE9PSBSR0JBRm9ybWF0ICYmIHV0aWxzLmNvbnZlcnQodGV4dHVyZUZvcm1hdCkgIT09IF9nbC5nZXRQYXJhbWV0ZXIoX2dsLklNUExFTUVOVEFUSU9OX0NPTE9SX1JFQURfRk9STUFUKSkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFJHQkEgb3IgaW1wbGVtZW50YXRpb24gZGVmaW5lZCBmb3JtYXQuJyk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29uc3QgaGFsZkZsb2F0U3VwcG9ydGVkQnlFeHQgPSB0ZXh0dXJlVHlwZSA9PT0gSGFsZkZsb2F0VHlwZSAmJiAoZXh0ZW5zaW9ucy5oYXMoJ0VYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCcpIHx8IGNhcGFiaWxpdGllcy5pc1dlYkdMMiAmJiBleHRlbnNpb25zLmhhcygnRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcpKTtcblxuXHRcdFx0XHRcdGlmICh0ZXh0dXJlVHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZSAmJiB1dGlscy5jb252ZXJ0KHRleHR1cmVUeXBlKSAhPT0gX2dsLmdldFBhcmFtZXRlcihfZ2wuSU1QTEVNRU5UQVRJT05fQ09MT1JfUkVBRF9UWVBFKSAmJiAvLyBFZGdlIGFuZCBDaHJvbWUgTWFjIDwgNTIgKCM5NTEzKVxuXHRcdFx0XHRcdCEodGV4dHVyZVR5cGUgPT09IEZsb2F0VHlwZSAmJiAoY2FwYWJpbGl0aWVzLmlzV2ViR0wyIHx8IGV4dGVuc2lvbnMuaGFzKCdPRVNfdGV4dHVyZV9mbG9hdCcpIHx8IGV4dGVuc2lvbnMuaGFzKCdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnKSkpICYmIC8vIENocm9tZSBNYWMgPj0gNTIgYW5kIEZpcmVmb3hcblx0XHRcdFx0XHQhaGFsZkZsb2F0U3VwcG9ydGVkQnlFeHQpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBpbiBVbnNpZ25lZEJ5dGVUeXBlIG9yIGltcGxlbWVudGF0aW9uIGRlZmluZWQgdHlwZS4nKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoX2dsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoX2dsLkZSQU1FQlVGRkVSKSA9PT0gX2dsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKSB7XG5cdFx0XHRcdFx0XHQvLyB0aGUgZm9sbG93aW5nIGlmIHN0YXRlbWVudCBlbnN1cmVzIHZhbGlkIHJlYWQgcmVxdWVzdHMgKG5vIG91dC1vZi1ib3VuZHMgcGl4ZWxzLCBzZWUgIzg2MDQpXG5cdFx0XHRcdFx0XHRpZiAoeCA+PSAwICYmIHggPD0gcmVuZGVyVGFyZ2V0LndpZHRoIC0gd2lkdGggJiYgeSA+PSAwICYmIHkgPD0gcmVuZGVyVGFyZ2V0LmhlaWdodCAtIGhlaWdodCkge1xuXHRcdFx0XHRcdFx0XHRfZ2wucmVhZFBpeGVscyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB1dGlscy5jb252ZXJ0KHRleHR1cmVGb3JtYXQpLCB1dGlscy5jb252ZXJ0KHRleHR1cmVUeXBlKSwgYnVmZmVyKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZWFkUGl4ZWxzIGZyb20gcmVuZGVyVGFyZ2V0IGZhaWxlZC4gRnJhbWVidWZmZXIgbm90IGNvbXBsZXRlLicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHQvLyByZXN0b3JlIGZyYW1lYnVmZmVyIG9mIGN1cnJlbnQgcmVuZGVyIHRhcmdldCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRjb25zdCBmcmFtZWJ1ZmZlciA9IF9jdXJyZW50UmVuZGVyVGFyZ2V0ICE9PSBudWxsID8gcHJvcGVydGllcy5nZXQoX2N1cnJlbnRSZW5kZXJUYXJnZXQpLl9fd2ViZ2xGcmFtZWJ1ZmZlciA6IG51bGw7XG5cdFx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHRoaXMuY29weUZyYW1lYnVmZmVyVG9UZXh0dXJlID0gZnVuY3Rpb24gKHBvc2l0aW9uLCB0ZXh0dXJlLCBsZXZlbCA9IDApIHtcblx0XHRcdGNvbnN0IGxldmVsU2NhbGUgPSBNYXRoLnBvdygyLCAtbGV2ZWwpO1xuXHRcdFx0Y29uc3Qgd2lkdGggPSBNYXRoLmZsb29yKHRleHR1cmUuaW1hZ2Uud2lkdGggKiBsZXZlbFNjYWxlKTtcblx0XHRcdGNvbnN0IGhlaWdodCA9IE1hdGguZmxvb3IodGV4dHVyZS5pbWFnZS5oZWlnaHQgKiBsZXZlbFNjYWxlKTtcblx0XHRcdGxldCBnbEZvcm1hdCA9IHV0aWxzLmNvbnZlcnQodGV4dHVyZS5mb3JtYXQpO1xuXG5cdFx0XHRpZiAoY2FwYWJpbGl0aWVzLmlzV2ViR0wyKSB7XG5cdFx0XHRcdC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTExMjAxMDBcblx0XHRcdFx0Ly8gTm90IG5lZWRlZCBpbiBDaHJvbWUgOTMrXG5cdFx0XHRcdGlmIChnbEZvcm1hdCA9PT0gX2dsLlJHQikgZ2xGb3JtYXQgPSBfZ2wuUkdCODtcblx0XHRcdFx0aWYgKGdsRm9ybWF0ID09PSBfZ2wuUkdCQSkgZ2xGb3JtYXQgPSBfZ2wuUkdCQTg7XG5cdFx0XHR9XG5cblx0XHRcdHRleHR1cmVzLnNldFRleHR1cmUyRCh0ZXh0dXJlLCAwKTtcblxuXHRcdFx0X2dsLmNvcHlUZXhJbWFnZTJEKF9nbC5URVhUVVJFXzJELCBsZXZlbCwgZ2xGb3JtYXQsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHdpZHRoLCBoZWlnaHQsIDApO1xuXG5cdFx0XHRzdGF0ZS51bmJpbmRUZXh0dXJlKCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuY29weVRleHR1cmVUb1RleHR1cmUgPSBmdW5jdGlvbiAocG9zaXRpb24sIHNyY1RleHR1cmUsIGRzdFRleHR1cmUsIGxldmVsID0gMCkge1xuXHRcdFx0Y29uc3Qgd2lkdGggPSBzcmNUZXh0dXJlLmltYWdlLndpZHRoO1xuXHRcdFx0Y29uc3QgaGVpZ2h0ID0gc3JjVGV4dHVyZS5pbWFnZS5oZWlnaHQ7XG5cdFx0XHRjb25zdCBnbEZvcm1hdCA9IHV0aWxzLmNvbnZlcnQoZHN0VGV4dHVyZS5mb3JtYXQpO1xuXHRcdFx0Y29uc3QgZ2xUeXBlID0gdXRpbHMuY29udmVydChkc3RUZXh0dXJlLnR5cGUpO1xuXHRcdFx0dGV4dHVyZXMuc2V0VGV4dHVyZTJEKGRzdFRleHR1cmUsIDApOyAvLyBBcyBhbm90aGVyIHRleHR1cmUgdXBsb2FkIG1heSBoYXZlIGNoYW5nZWQgcGl4ZWxTdG9yZWlcblx0XHRcdC8vIHBhcmFtZXRlcnMsIG1ha2Ugc3VyZSB0aGV5IGFyZSBjb3JyZWN0IGZvciB0aGUgZHN0VGV4dHVyZVxuXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIGRzdFRleHR1cmUuZmxpcFkpO1xuXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoX2dsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgZHN0VGV4dHVyZS5wcmVtdWx0aXBseUFscGhhKTtcblxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKF9nbC5VTlBBQ0tfQUxJR05NRU5ULCBkc3RUZXh0dXJlLnVucGFja0FsaWdubWVudCk7XG5cblx0XHRcdGlmIChzcmNUZXh0dXJlLmlzRGF0YVRleHR1cmUpIHtcblx0XHRcdFx0X2dsLnRleFN1YkltYWdlMkQoX2dsLlRFWFRVUkVfMkQsIGxldmVsLCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB3aWR0aCwgaGVpZ2h0LCBnbEZvcm1hdCwgZ2xUeXBlLCBzcmNUZXh0dXJlLmltYWdlLmRhdGEpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHNyY1RleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSkge1xuXHRcdFx0XHRcdF9nbC5jb21wcmVzc2VkVGV4U3ViSW1hZ2UyRChfZ2wuVEVYVFVSRV8yRCwgbGV2ZWwsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHNyY1RleHR1cmUubWlwbWFwc1swXS53aWR0aCwgc3JjVGV4dHVyZS5taXBtYXBzWzBdLmhlaWdodCwgZ2xGb3JtYXQsIHNyY1RleHR1cmUubWlwbWFwc1swXS5kYXRhKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfZ2wudGV4U3ViSW1hZ2UyRChfZ2wuVEVYVFVSRV8yRCwgbGV2ZWwsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIGdsRm9ybWF0LCBnbFR5cGUsIHNyY1RleHR1cmUuaW1hZ2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IC8vIEdlbmVyYXRlIG1pcG1hcHMgb25seSB3aGVuIGNvcHlpbmcgbGV2ZWwgMFxuXG5cblx0XHRcdGlmIChsZXZlbCA9PT0gMCAmJiBkc3RUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcykgX2dsLmdlbmVyYXRlTWlwbWFwKF9nbC5URVhUVVJFXzJEKTtcblx0XHRcdHN0YXRlLnVuYmluZFRleHR1cmUoKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5jb3B5VGV4dHVyZVRvVGV4dHVyZTNEID0gZnVuY3Rpb24gKHNvdXJjZUJveCwgcG9zaXRpb24sIHNyY1RleHR1cmUsIGRzdFRleHR1cmUsIGxldmVsID0gMCkge1xuXHRcdFx0aWYgKF90aGlzLmlzV2ViR0wxUmVuZGVyZXIpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyLmNvcHlUZXh0dXJlVG9UZXh0dXJlM0Q6IGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBXZWJHTDIuJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgd2lkdGggPSBzb3VyY2VCb3gubWF4LnggLSBzb3VyY2VCb3gubWluLnggKyAxO1xuXHRcdFx0Y29uc3QgaGVpZ2h0ID0gc291cmNlQm94Lm1heC55IC0gc291cmNlQm94Lm1pbi55ICsgMTtcblx0XHRcdGNvbnN0IGRlcHRoID0gc291cmNlQm94Lm1heC56IC0gc291cmNlQm94Lm1pbi56ICsgMTtcblx0XHRcdGNvbnN0IGdsRm9ybWF0ID0gdXRpbHMuY29udmVydChkc3RUZXh0dXJlLmZvcm1hdCk7XG5cdFx0XHRjb25zdCBnbFR5cGUgPSB1dGlscy5jb252ZXJ0KGRzdFRleHR1cmUudHlwZSk7XG5cdFx0XHRsZXQgZ2xUYXJnZXQ7XG5cblx0XHRcdGlmIChkc3RUZXh0dXJlLmlzRGF0YVRleHR1cmUzRCkge1xuXHRcdFx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlM0QoZHN0VGV4dHVyZSwgMCk7XG5cdFx0XHRcdGdsVGFyZ2V0ID0gX2dsLlRFWFRVUkVfM0Q7XG5cdFx0XHR9IGVsc2UgaWYgKGRzdFRleHR1cmUuaXNEYXRhVGV4dHVyZTJEQXJyYXkpIHtcblx0XHRcdFx0dGV4dHVyZXMuc2V0VGV4dHVyZTJEQXJyYXkoZHN0VGV4dHVyZSwgMCk7XG5cdFx0XHRcdGdsVGFyZ2V0ID0gX2dsLlRFWFRVUkVfMkRfQVJSQVk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXIuY29weVRleHR1cmVUb1RleHR1cmUzRDogb25seSBzdXBwb3J0cyBUSFJFRS5EYXRhVGV4dHVyZTNEIGFuZCBUSFJFRS5EYXRhVGV4dHVyZTJEQXJyYXkuJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBkc3RUZXh0dXJlLmZsaXBZKTtcblxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKF9nbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGRzdFRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSk7XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX0FMSUdOTUVOVCwgZHN0VGV4dHVyZS51bnBhY2tBbGlnbm1lbnQpO1xuXG5cdFx0XHRjb25zdCB1bnBhY2tSb3dMZW4gPSBfZ2wuZ2V0UGFyYW1ldGVyKF9nbC5VTlBBQ0tfUk9XX0xFTkdUSCk7XG5cblx0XHRcdGNvbnN0IHVucGFja0ltYWdlSGVpZ2h0ID0gX2dsLmdldFBhcmFtZXRlcihfZ2wuVU5QQUNLX0lNQUdFX0hFSUdIVCk7XG5cblx0XHRcdGNvbnN0IHVucGFja1NraXBQaXhlbHMgPSBfZ2wuZ2V0UGFyYW1ldGVyKF9nbC5VTlBBQ0tfU0tJUF9QSVhFTFMpO1xuXG5cdFx0XHRjb25zdCB1bnBhY2tTa2lwUm93cyA9IF9nbC5nZXRQYXJhbWV0ZXIoX2dsLlVOUEFDS19TS0lQX1JPV1MpO1xuXG5cdFx0XHRjb25zdCB1bnBhY2tTa2lwSW1hZ2VzID0gX2dsLmdldFBhcmFtZXRlcihfZ2wuVU5QQUNLX1NLSVBfSU1BR0VTKTtcblxuXHRcdFx0Y29uc3QgaW1hZ2UgPSBzcmNUZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUgPyBzcmNUZXh0dXJlLm1pcG1hcHNbMF0gOiBzcmNUZXh0dXJlLmltYWdlO1xuXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoX2dsLlVOUEFDS19ST1dfTEVOR1RILCBpbWFnZS53aWR0aCk7XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX0lNQUdFX0hFSUdIVCwgaW1hZ2UuaGVpZ2h0KTtcblxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKF9nbC5VTlBBQ0tfU0tJUF9QSVhFTFMsIHNvdXJjZUJveC5taW4ueCk7XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX1NLSVBfUk9XUywgc291cmNlQm94Lm1pbi55KTtcblxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKF9nbC5VTlBBQ0tfU0tJUF9JTUFHRVMsIHNvdXJjZUJveC5taW4ueik7XG5cblx0XHRcdGlmIChzcmNUZXh0dXJlLmlzRGF0YVRleHR1cmUgfHwgc3JjVGV4dHVyZS5pc0RhdGFUZXh0dXJlM0QpIHtcblx0XHRcdFx0X2dsLnRleFN1YkltYWdlM0QoZ2xUYXJnZXQsIGxldmVsLCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56LCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UuZGF0YSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoc3JjVGV4dHVyZS5pc0NvbXByZXNzZWRUZXh0dXJlKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyLmNvcHlUZXh0dXJlVG9UZXh0dXJlM0Q6IHVudGVzdGVkIHN1cHBvcnQgZm9yIGNvbXByZXNzZWQgc3JjVGV4dHVyZS4nKTtcblxuXHRcdFx0XHRcdF9nbC5jb21wcmVzc2VkVGV4U3ViSW1hZ2UzRChnbFRhcmdldCwgbGV2ZWwsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnosIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBnbEZvcm1hdCwgaW1hZ2UuZGF0YSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X2dsLnRleFN1YkltYWdlM0QoZ2xUYXJnZXQsIGxldmVsLCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56LCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX1JPV19MRU5HVEgsIHVucGFja1Jvd0xlbik7XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX0lNQUdFX0hFSUdIVCwgdW5wYWNrSW1hZ2VIZWlnaHQpO1xuXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoX2dsLlVOUEFDS19TS0lQX1BJWEVMUywgdW5wYWNrU2tpcFBpeGVscyk7XG5cblx0XHRcdF9nbC5waXhlbFN0b3JlaShfZ2wuVU5QQUNLX1NLSVBfUk9XUywgdW5wYWNrU2tpcFJvd3MpO1xuXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoX2dsLlVOUEFDS19TS0lQX0lNQUdFUywgdW5wYWNrU2tpcEltYWdlcyk7IC8vIEdlbmVyYXRlIG1pcG1hcHMgb25seSB3aGVuIGNvcHlpbmcgbGV2ZWwgMFxuXG5cblx0XHRcdGlmIChsZXZlbCA9PT0gMCAmJiBkc3RUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcykgX2dsLmdlbmVyYXRlTWlwbWFwKGdsVGFyZ2V0KTtcblx0XHRcdHN0YXRlLnVuYmluZFRleHR1cmUoKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5pbml0VGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlKSB7XG5cdFx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlMkQodGV4dHVyZSwgMCk7XG5cdFx0XHRzdGF0ZS51bmJpbmRUZXh0dXJlKCk7XG5cdFx0fTtcblxuXHRcdHRoaXMucmVzZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdF9jdXJyZW50QWN0aXZlQ3ViZUZhY2UgPSAwO1xuXHRcdFx0X2N1cnJlbnRBY3RpdmVNaXBtYXBMZXZlbCA9IDA7XG5cdFx0XHRfY3VycmVudFJlbmRlclRhcmdldCA9IG51bGw7XG5cdFx0XHRzdGF0ZS5yZXNldCgpO1xuXHRcdFx0YmluZGluZ1N0YXRlcy5yZXNldCgpO1xuXHRcdH07XG5cblx0XHRpZiAodHlwZW9mIF9fVEhSRUVfREVWVE9PTFNfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdF9fVEhSRUVfREVWVE9PTFNfXy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnb2JzZXJ2ZScsIHtcblx0XHRcdFx0ZGV0YWlsOiB0aGlzXG5cdFx0XHR9KSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXHRcdH1cblx0fVxuXG5cdFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLmlzV2ViR0xSZW5kZXJlciA9IHRydWU7XG5cblx0Y2xhc3MgV2ViR0wxUmVuZGVyZXIgZXh0ZW5kcyBXZWJHTFJlbmRlcmVyIHt9XG5cblx0V2ViR0wxUmVuZGVyZXIucHJvdG90eXBlLmlzV2ViR0wxUmVuZGVyZXIgPSB0cnVlO1xuXG5cdGNsYXNzIEZvZ0V4cDIge1xuXHRcdGNvbnN0cnVjdG9yKGNvbG9yLCBkZW5zaXR5ID0gMC4wMDAyNSkge1xuXHRcdFx0dGhpcy5uYW1lID0gJyc7XG5cdFx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKGNvbG9yKTtcblx0XHRcdHRoaXMuZGVuc2l0eSA9IGRlbnNpdHk7XG5cdFx0fVxuXG5cdFx0Y2xvbmUoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEZvZ0V4cDIodGhpcy5jb2xvciwgdGhpcy5kZW5zaXR5KTtcblx0XHR9XG5cblx0XHR0b0pTT04oKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0eXBlOiAnRm9nRXhwMicsXG5cdFx0XHRcdGNvbG9yOiB0aGlzLmNvbG9yLmdldEhleCgpLFxuXHRcdFx0XHRkZW5zaXR5OiB0aGlzLmRlbnNpdHlcblx0XHRcdH07XG5cdFx0fVxuXG5cdH1cblxuXHRGb2dFeHAyLnByb3RvdHlwZS5pc0ZvZ0V4cDIgPSB0cnVlO1xuXG5cdGNsYXNzIEZvZyB7XG5cdFx0Y29uc3RydWN0b3IoY29sb3IsIG5lYXIgPSAxLCBmYXIgPSAxMDAwKSB7XG5cdFx0XHR0aGlzLm5hbWUgPSAnJztcblx0XHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoY29sb3IpO1xuXHRcdFx0dGhpcy5uZWFyID0gbmVhcjtcblx0XHRcdHRoaXMuZmFyID0gZmFyO1xuXHRcdH1cblxuXHRcdGNsb25lKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBGb2codGhpcy5jb2xvciwgdGhpcy5uZWFyLCB0aGlzLmZhcik7XG5cdFx0fVxuXG5cdFx0dG9KU09OKCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dHlwZTogJ0ZvZycsXG5cdFx0XHRcdGNvbG9yOiB0aGlzLmNvbG9yLmdldEhleCgpLFxuXHRcdFx0XHRuZWFyOiB0aGlzLm5lYXIsXG5cdFx0XHRcdGZhcjogdGhpcy5mYXJcblx0XHRcdH07XG5cdFx0fVxuXG5cdH1cblxuXHRGb2cucHJvdG90eXBlLmlzRm9nID0gdHJ1ZTtcblxuXHRjbGFzcyBTY2VuZSBleHRlbmRzIE9iamVjdDNEIHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnU2NlbmUnO1xuXHRcdFx0dGhpcy5iYWNrZ3JvdW5kID0gbnVsbDtcblx0XHRcdHRoaXMuZW52aXJvbm1lbnQgPSBudWxsO1xuXHRcdFx0dGhpcy5mb2cgPSBudWxsO1xuXHRcdFx0dGhpcy5vdmVycmlkZU1hdGVyaWFsID0gbnVsbDtcblx0XHRcdHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7IC8vIGNoZWNrZWQgYnkgdGhlIHJlbmRlcmVyXG5cblx0XHRcdGlmICh0eXBlb2YgX19USFJFRV9ERVZUT09MU19fICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRfX1RIUkVFX0RFVlRPT0xTX18uZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ29ic2VydmUnLCB7XG5cdFx0XHRcdFx0ZGV0YWlsOiB0aGlzXG5cdFx0XHRcdH0pKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UsIHJlY3Vyc2l2ZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UsIHJlY3Vyc2l2ZSk7XG5cdFx0XHRpZiAoc291cmNlLmJhY2tncm91bmQgIT09IG51bGwpIHRoaXMuYmFja2dyb3VuZCA9IHNvdXJjZS5iYWNrZ3JvdW5kLmNsb25lKCk7XG5cdFx0XHRpZiAoc291cmNlLmVudmlyb25tZW50ICE9PSBudWxsKSB0aGlzLmVudmlyb25tZW50ID0gc291cmNlLmVudmlyb25tZW50LmNsb25lKCk7XG5cdFx0XHRpZiAoc291cmNlLmZvZyAhPT0gbnVsbCkgdGhpcy5mb2cgPSBzb3VyY2UuZm9nLmNsb25lKCk7XG5cdFx0XHRpZiAoc291cmNlLm92ZXJyaWRlTWF0ZXJpYWwgIT09IG51bGwpIHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IHNvdXJjZS5vdmVycmlkZU1hdGVyaWFsLmNsb25lKCk7XG5cdFx0XHR0aGlzLmF1dG9VcGRhdGUgPSBzb3VyY2UuYXV0b1VwZGF0ZTtcblx0XHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dG9KU09OKG1ldGEpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04obWV0YSk7XG5cdFx0XHRpZiAodGhpcy5mb2cgIT09IG51bGwpIGRhdGEub2JqZWN0LmZvZyA9IHRoaXMuZm9nLnRvSlNPTigpO1xuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdH1cblxuXHRTY2VuZS5wcm90b3R5cGUuaXNTY2VuZSA9IHRydWU7XG5cblx0Y2xhc3MgSW50ZXJsZWF2ZWRCdWZmZXIge1xuXHRcdGNvbnN0cnVjdG9yKGFycmF5LCBzdHJpZGUpIHtcblx0XHRcdHRoaXMuYXJyYXkgPSBhcnJheTtcblx0XHRcdHRoaXMuc3RyaWRlID0gc3RyaWRlO1xuXHRcdFx0dGhpcy5jb3VudCA9IGFycmF5ICE9PSB1bmRlZmluZWQgPyBhcnJheS5sZW5ndGggLyBzdHJpZGUgOiAwO1xuXHRcdFx0dGhpcy51c2FnZSA9IFN0YXRpY0RyYXdVc2FnZTtcblx0XHRcdHRoaXMudXBkYXRlUmFuZ2UgPSB7XG5cdFx0XHRcdG9mZnNldDogMCxcblx0XHRcdFx0Y291bnQ6IC0xXG5cdFx0XHR9O1xuXHRcdFx0dGhpcy52ZXJzaW9uID0gMDtcblx0XHRcdHRoaXMudXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXHRcdH1cblxuXHRcdG9uVXBsb2FkQ2FsbGJhY2soKSB7fVxuXG5cdFx0c2V0IG5lZWRzVXBkYXRlKHZhbHVlKSB7XG5cdFx0XHRpZiAodmFsdWUgPT09IHRydWUpIHRoaXMudmVyc2lvbisrO1xuXHRcdH1cblxuXHRcdHNldFVzYWdlKHZhbHVlKSB7XG5cdFx0XHR0aGlzLnVzYWdlID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0dGhpcy5hcnJheSA9IG5ldyBzb3VyY2UuYXJyYXkuY29uc3RydWN0b3Ioc291cmNlLmFycmF5KTtcblx0XHRcdHRoaXMuY291bnQgPSBzb3VyY2UuY291bnQ7XG5cdFx0XHR0aGlzLnN0cmlkZSA9IHNvdXJjZS5zdHJpZGU7XG5cdFx0XHR0aGlzLnVzYWdlID0gc291cmNlLnVzYWdlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29weUF0KGluZGV4MSwgYXR0cmlidXRlLCBpbmRleDIpIHtcblx0XHRcdGluZGV4MSAqPSB0aGlzLnN0cmlkZTtcblx0XHRcdGluZGV4MiAqPSBhdHRyaWJ1dGUuc3RyaWRlO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuc3RyaWRlOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuYXJyYXlbaW5kZXgxICsgaV0gPSBhdHRyaWJ1dGUuYXJyYXlbaW5kZXgyICsgaV07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldCh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuXHRcdFx0dGhpcy5hcnJheS5zZXQodmFsdWUsIG9mZnNldCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbG9uZShkYXRhKSB7XG5cdFx0XHRpZiAoZGF0YS5hcnJheUJ1ZmZlcnMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRkYXRhLmFycmF5QnVmZmVycyA9IHt9O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5hcnJheS5idWZmZXIuX3V1aWQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZGF0YS5hcnJheUJ1ZmZlcnNbdGhpcy5hcnJheS5idWZmZXIuX3V1aWRdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ZGF0YS5hcnJheUJ1ZmZlcnNbdGhpcy5hcnJheS5idWZmZXIuX3V1aWRdID0gdGhpcy5hcnJheS5zbGljZSgwKS5idWZmZXI7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGFycmF5ID0gbmV3IHRoaXMuYXJyYXkuY29uc3RydWN0b3IoZGF0YS5hcnJheUJ1ZmZlcnNbdGhpcy5hcnJheS5idWZmZXIuX3V1aWRdKTtcblx0XHRcdGNvbnN0IGliID0gbmV3IHRoaXMuY29uc3RydWN0b3IoYXJyYXksIHRoaXMuc3RyaWRlKTtcblx0XHRcdGliLnNldFVzYWdlKHRoaXMudXNhZ2UpO1xuXHRcdFx0cmV0dXJuIGliO1xuXHRcdH1cblxuXHRcdG9uVXBsb2FkKGNhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLm9uVXBsb2FkQ2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRvSlNPTihkYXRhKSB7XG5cdFx0XHRpZiAoZGF0YS5hcnJheUJ1ZmZlcnMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRkYXRhLmFycmF5QnVmZmVycyA9IHt9O1xuXHRcdFx0fSAvLyBnZW5lcmF0ZSBVVUlEIGZvciBhcnJheSBidWZmZXIgaWYgbmVjZXNzYXJ5XG5cblxuXHRcdFx0aWYgKHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5hcnJheS5idWZmZXIuX3V1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGRhdGEuYXJyYXlCdWZmZXJzW3RoaXMuYXJyYXkuYnVmZmVyLl91dWlkXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGRhdGEuYXJyYXlCdWZmZXJzW3RoaXMuYXJyYXkuYnVmZmVyLl91dWlkXSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG5ldyBVaW50MzJBcnJheSh0aGlzLmFycmF5LmJ1ZmZlcikpO1xuXHRcdFx0fSAvL1xuXG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHV1aWQ6IHRoaXMudXVpZCxcblx0XHRcdFx0YnVmZmVyOiB0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCxcblx0XHRcdFx0dHlwZTogdGhpcy5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLFxuXHRcdFx0XHRzdHJpZGU6IHRoaXMuc3RyaWRlXG5cdFx0XHR9O1xuXHRcdH1cblxuXHR9XG5cblx0SW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlLmlzSW50ZXJsZWF2ZWRCdWZmZXIgPSB0cnVlO1xuXG5cdGNvbnN0IF92ZWN0b3IkNiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNsYXNzIEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlIHtcblx0XHRjb25zdHJ1Y3RvcihpbnRlcmxlYXZlZEJ1ZmZlciwgaXRlbVNpemUsIG9mZnNldCwgbm9ybWFsaXplZCA9IGZhbHNlKSB7XG5cdFx0XHR0aGlzLm5hbWUgPSAnJztcblx0XHRcdHRoaXMuZGF0YSA9IGludGVybGVhdmVkQnVmZmVyO1xuXHRcdFx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xuXHRcdFx0dGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG5cdFx0XHR0aGlzLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkID09PSB0cnVlO1xuXHRcdH1cblxuXHRcdGdldCBjb3VudCgpIHtcblx0XHRcdHJldHVybiB0aGlzLmRhdGEuY291bnQ7XG5cdFx0fVxuXG5cdFx0Z2V0IGFycmF5KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheTtcblx0XHR9XG5cblx0XHRzZXQgbmVlZHNVcGRhdGUodmFsdWUpIHtcblx0XHRcdHRoaXMuZGF0YS5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdGFwcGx5TWF0cml4NChtKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuZGF0YS5jb3VudDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRfdmVjdG9yJDYueCA9IHRoaXMuZ2V0WChpKTtcblx0XHRcdFx0X3ZlY3RvciQ2LnkgPSB0aGlzLmdldFkoaSk7XG5cdFx0XHRcdF92ZWN0b3IkNi56ID0gdGhpcy5nZXRaKGkpO1xuXG5cdFx0XHRcdF92ZWN0b3IkNi5hcHBseU1hdHJpeDQobSk7XG5cblx0XHRcdFx0dGhpcy5zZXRYWVooaSwgX3ZlY3RvciQ2LngsIF92ZWN0b3IkNi55LCBfdmVjdG9yJDYueik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGFwcGx5Tm9ybWFsTWF0cml4KG0pIHtcblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5jb3VudDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRfdmVjdG9yJDYueCA9IHRoaXMuZ2V0WChpKTtcblx0XHRcdFx0X3ZlY3RvciQ2LnkgPSB0aGlzLmdldFkoaSk7XG5cdFx0XHRcdF92ZWN0b3IkNi56ID0gdGhpcy5nZXRaKGkpO1xuXG5cdFx0XHRcdF92ZWN0b3IkNi5hcHBseU5vcm1hbE1hdHJpeChtKTtcblxuXHRcdFx0XHR0aGlzLnNldFhZWihpLCBfdmVjdG9yJDYueCwgX3ZlY3RvciQ2LnksIF92ZWN0b3IkNi56KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dHJhbnNmb3JtRGlyZWN0aW9uKG0pIHtcblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5jb3VudDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRfdmVjdG9yJDYueCA9IHRoaXMuZ2V0WChpKTtcblx0XHRcdFx0X3ZlY3RvciQ2LnkgPSB0aGlzLmdldFkoaSk7XG5cdFx0XHRcdF92ZWN0b3IkNi56ID0gdGhpcy5nZXRaKGkpO1xuXG5cdFx0XHRcdF92ZWN0b3IkNi50cmFuc2Zvcm1EaXJlY3Rpb24obSk7XG5cblx0XHRcdFx0dGhpcy5zZXRYWVooaSwgX3ZlY3RvciQ2LngsIF92ZWN0b3IkNi55LCBfdmVjdG9yJDYueik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldFgoaW5kZXgsIHgpIHtcblx0XHRcdHRoaXMuZGF0YS5hcnJheVtpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldF0gPSB4O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0WShpbmRleCwgeSkge1xuXHRcdFx0dGhpcy5kYXRhLmFycmF5W2luZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMV0gPSB5O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0WihpbmRleCwgeikge1xuXHRcdFx0dGhpcy5kYXRhLmFycmF5W2luZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMl0gPSB6O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0VyhpbmRleCwgdykge1xuXHRcdFx0dGhpcy5kYXRhLmFycmF5W2luZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgM10gPSB3O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Z2V0WChpbmRleCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheVtpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldF07XG5cdFx0fVxuXG5cdFx0Z2V0WShpbmRleCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheVtpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDFdO1xuXHRcdH1cblxuXHRcdGdldFooaW5kZXgpIHtcblx0XHRcdHJldHVybiB0aGlzLmRhdGEuYXJyYXlbaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAyXTtcblx0XHR9XG5cblx0XHRnZXRXKGluZGV4KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kYXRhLmFycmF5W2luZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgM107XG5cdFx0fVxuXG5cdFx0c2V0WFkoaW5kZXgsIHgsIHkpIHtcblx0XHRcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cdFx0XHR0aGlzLmRhdGEuYXJyYXlbaW5kZXggKyAwXSA9IHg7XG5cdFx0XHR0aGlzLmRhdGEuYXJyYXlbaW5kZXggKyAxXSA9IHk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRYWVooaW5kZXgsIHgsIHksIHopIHtcblx0XHRcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cdFx0XHR0aGlzLmRhdGEuYXJyYXlbaW5kZXggKyAwXSA9IHg7XG5cdFx0XHR0aGlzLmRhdGEuYXJyYXlbaW5kZXggKyAxXSA9IHk7XG5cdFx0XHR0aGlzLmRhdGEuYXJyYXlbaW5kZXggKyAyXSA9IHo7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRYWVpXKGluZGV4LCB4LCB5LCB6LCB3KSB7XG5cdFx0XHRpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xuXHRcdFx0dGhpcy5kYXRhLmFycmF5W2luZGV4ICsgMF0gPSB4O1xuXHRcdFx0dGhpcy5kYXRhLmFycmF5W2luZGV4ICsgMV0gPSB5O1xuXHRcdFx0dGhpcy5kYXRhLmFycmF5W2luZGV4ICsgMl0gPSB6O1xuXHRcdFx0dGhpcy5kYXRhLmFycmF5W2luZGV4ICsgM10gPSB3O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y2xvbmUoZGF0YSkge1xuXHRcdFx0aWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUuY2xvbmUoKTogQ2xvbmluZyBhbiBpbnRlcmxhdmVkIGJ1ZmZlciBhdHRyaWJ1dGUgd2lsbCBkZWludGVybGVhdmUgYnVmZmVyIGRhdGEuJyk7XG5cdFx0XHRcdGNvbnN0IGFycmF5ID0gW107XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvdW50OyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBpbmRleCA9IGkgKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuaXRlbVNpemU7IGorKykge1xuXHRcdFx0XHRcdFx0YXJyYXkucHVzaCh0aGlzLmRhdGEuYXJyYXlbaW5kZXggKyBqXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUobmV3IHRoaXMuYXJyYXkuY29uc3RydWN0b3IoYXJyYXkpLCB0aGlzLml0ZW1TaXplLCB0aGlzLm5vcm1hbGl6ZWQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGRhdGEuaW50ZXJsZWF2ZWRCdWZmZXJzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRkYXRhLmludGVybGVhdmVkQnVmZmVycyA9IHt9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGRhdGEuaW50ZXJsZWF2ZWRCdWZmZXJzW3RoaXMuZGF0YS51dWlkXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0ZGF0YS5pbnRlcmxlYXZlZEJ1ZmZlcnNbdGhpcy5kYXRhLnV1aWRdID0gdGhpcy5kYXRhLmNsb25lKGRhdGEpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZShkYXRhLmludGVybGVhdmVkQnVmZmVyc1t0aGlzLmRhdGEudXVpZF0sIHRoaXMuaXRlbVNpemUsIHRoaXMub2Zmc2V0LCB0aGlzLm5vcm1hbGl6ZWQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRvSlNPTihkYXRhKSB7XG5cdFx0XHRpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS50b0pTT04oKTogU2VyaWFsaXppbmcgYW4gaW50ZXJsYXZlZCBidWZmZXIgYXR0cmlidXRlIHdpbGwgZGVpbnRlcmxlYXZlIGJ1ZmZlciBkYXRhLicpO1xuXHRcdFx0XHRjb25zdCBhcnJheSA9IFtdO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb3VudDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgaW5kZXggPSBpICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLml0ZW1TaXplOyBqKyspIHtcblx0XHRcdFx0XHRcdGFycmF5LnB1c2godGhpcy5kYXRhLmFycmF5W2luZGV4ICsgal0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSAvLyBkZWludGVybGVhdmUgZGF0YSBhbmQgc2F2ZSBpdCBhcyBhbiBvcmRpbmFyeSBidWZmZXIgYXR0cmlidXRlIGZvciBub3dcblxuXG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0aXRlbVNpemU6IHRoaXMuaXRlbVNpemUsXG5cdFx0XHRcdFx0dHlwZTogdGhpcy5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLFxuXHRcdFx0XHRcdGFycmF5OiBhcnJheSxcblx0XHRcdFx0XHRub3JtYWxpemVkOiB0aGlzLm5vcm1hbGl6ZWRcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHNhdmUgYXMgdHJ1ZSBpbnRlcmxhdmVkIGF0dHJpYnR1ZVxuXHRcdFx0XHRpZiAoZGF0YS5pbnRlcmxlYXZlZEJ1ZmZlcnMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGRhdGEuaW50ZXJsZWF2ZWRCdWZmZXJzID0ge307XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZGF0YS5pbnRlcmxlYXZlZEJ1ZmZlcnNbdGhpcy5kYXRhLnV1aWRdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRkYXRhLmludGVybGVhdmVkQnVmZmVyc1t0aGlzLmRhdGEudXVpZF0gPSB0aGlzLmRhdGEudG9KU09OKGRhdGEpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRpc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlOiB0cnVlLFxuXHRcdFx0XHRcdGl0ZW1TaXplOiB0aGlzLml0ZW1TaXplLFxuXHRcdFx0XHRcdGRhdGE6IHRoaXMuZGF0YS51dWlkLFxuXHRcdFx0XHRcdG9mZnNldDogdGhpcy5vZmZzZXQsXG5cdFx0XHRcdFx0bm9ybWFsaXplZDogdGhpcy5ub3JtYWxpemVkXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH1cblxuXHRJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA9IHRydWU7XG5cblx0LyoqXG5cdCAqIHBhcmFtZXRlcnMgPSB7XG5cdCAqXHRjb2xvcjogPGhleD4sXG5cdCAqXHRtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcdHJvdGF0aW9uOiA8ZmxvYXQ+LFxuXHQgKlx0c2l6ZUF0dGVudWF0aW9uOiA8Ym9vbD5cblx0ICogfVxuXHQgKi9cblxuXHRjbGFzcyBTcHJpdGVNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblx0XHRjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ1Nwcml0ZU1hdGVyaWFsJztcblx0XHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoMHhmZmZmZmYpO1xuXHRcdFx0dGhpcy5tYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLnJvdGF0aW9uID0gMDtcblx0XHRcdHRoaXMuc2l6ZUF0dGVudWF0aW9uID0gdHJ1ZTtcblx0XHRcdHRoaXMudHJhbnNwYXJlbnQgPSB0cnVlO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMocGFyYW1ldGVycyk7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdHRoaXMuY29sb3IuY29weShzb3VyY2UuY29sb3IpO1xuXHRcdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXHRcdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblx0XHRcdHRoaXMucm90YXRpb24gPSBzb3VyY2Uucm90YXRpb247XG5cdFx0XHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHNvdXJjZS5zaXplQXR0ZW51YXRpb247XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdFNwcml0ZU1hdGVyaWFsLnByb3RvdHlwZS5pc1Nwcml0ZU1hdGVyaWFsID0gdHJ1ZTtcblxuXHRsZXQgX2dlb21ldHJ5O1xuXG5cdGNvbnN0IF9pbnRlcnNlY3RQb2ludCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF93b3JsZFNjYWxlID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX212UG9zaXRpb24gPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfYWxpZ25lZFBvc2l0aW9uID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IyKCk7XG5cblx0Y29uc3QgX3JvdGF0ZWRQb3NpdGlvbiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMigpO1xuXG5cdGNvbnN0IF92aWV3V29ybGRNYXRyaXggPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDQoKTtcblxuXHRjb25zdCBfdkEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfdkIgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfdkMgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfdXZBID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IyKCk7XG5cblx0Y29uc3QgX3V2QiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMigpO1xuXG5cdGNvbnN0IF91dkMgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjIoKTtcblxuXHRjbGFzcyBTcHJpdGUgZXh0ZW5kcyBPYmplY3QzRCB7XG5cdFx0Y29uc3RydWN0b3IobWF0ZXJpYWwpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnU3ByaXRlJztcblxuXHRcdFx0aWYgKF9nZW9tZXRyeSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdF9nZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0XHRjb25zdCBmbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFstMC41LCAtMC41LCAwLCAwLCAwLCAwLjUsIC0wLjUsIDAsIDEsIDAsIDAuNSwgMC41LCAwLCAxLCAxLCAtMC41LCAwLjUsIDAsIDAsIDFdKTtcblx0XHRcdFx0Y29uc3QgaW50ZXJsZWF2ZWRCdWZmZXIgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXIoZmxvYXQzMkFycmF5LCA1KTtcblxuXHRcdFx0XHRfZ2VvbWV0cnkuc2V0SW5kZXgoWzAsIDEsIDIsIDAsIDIsIDNdKTtcblxuXHRcdFx0XHRfZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZShpbnRlcmxlYXZlZEJ1ZmZlciwgMywgMCwgZmFsc2UpKTtcblxuXHRcdFx0XHRfZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCd1dicsIG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZShpbnRlcmxlYXZlZEJ1ZmZlciwgMiwgMywgZmFsc2UpKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5nZW9tZXRyeSA9IF9nZW9tZXRyeTtcblx0XHRcdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwgOiBuZXcgU3ByaXRlTWF0ZXJpYWwoKTtcblx0XHRcdHRoaXMuY2VudGVyID0gbmV3IFZlY3RvcjIoMC41LCAwLjUpO1xuXHRcdH1cblxuXHRcdHJheWNhc3QocmF5Y2FzdGVyLCBpbnRlcnNlY3RzKSB7XG5cdFx0XHRpZiAocmF5Y2FzdGVyLmNhbWVyYSA9PT0gbnVsbCkge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5TcHJpdGU6IFwiUmF5Y2FzdGVyLmNhbWVyYVwiIG5lZWRzIHRvIGJlIHNldCBpbiBvcmRlciB0byByYXljYXN0IGFnYWluc3Qgc3ByaXRlcy4nKTtcblx0XHRcdH1cblxuXHRcdFx0X3dvcmxkU2NhbGUuc2V0RnJvbU1hdHJpeFNjYWxlKHRoaXMubWF0cml4V29ybGQpO1xuXG5cdFx0XHRfdmlld1dvcmxkTWF0cml4LmNvcHkocmF5Y2FzdGVyLmNhbWVyYS5tYXRyaXhXb3JsZCk7XG5cblx0XHRcdHRoaXMubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMocmF5Y2FzdGVyLmNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIHRoaXMubWF0cml4V29ybGQpO1xuXG5cdFx0XHRfbXZQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5tb2RlbFZpZXdNYXRyaXgpO1xuXG5cdFx0XHRpZiAocmF5Y2FzdGVyLmNhbWVyYS5pc1BlcnNwZWN0aXZlQ2FtZXJhICYmIHRoaXMubWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uID09PSBmYWxzZSkge1xuXHRcdFx0XHRfd29ybGRTY2FsZS5tdWx0aXBseVNjYWxhcigtX212UG9zaXRpb24ueik7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHJvdGF0aW9uID0gdGhpcy5tYXRlcmlhbC5yb3RhdGlvbjtcblx0XHRcdGxldCBzaW4sIGNvcztcblxuXHRcdFx0aWYgKHJvdGF0aW9uICE9PSAwKSB7XG5cdFx0XHRcdGNvcyA9IE1hdGguY29zKHJvdGF0aW9uKTtcblx0XHRcdFx0c2luID0gTWF0aC5zaW4ocm90YXRpb24pO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBjZW50ZXIgPSB0aGlzLmNlbnRlcjtcblx0XHRcdHRyYW5zZm9ybVZlcnRleChfdkEuc2V0KC0wLjUsIC0wLjUsIDApLCBfbXZQb3NpdGlvbiwgY2VudGVyLCBfd29ybGRTY2FsZSwgc2luLCBjb3MpO1xuXHRcdFx0dHJhbnNmb3JtVmVydGV4KF92Qi5zZXQoMC41LCAtMC41LCAwKSwgX212UG9zaXRpb24sIGNlbnRlciwgX3dvcmxkU2NhbGUsIHNpbiwgY29zKTtcblx0XHRcdHRyYW5zZm9ybVZlcnRleChfdkMuc2V0KDAuNSwgMC41LCAwKSwgX212UG9zaXRpb24sIGNlbnRlciwgX3dvcmxkU2NhbGUsIHNpbiwgY29zKTtcblxuXHRcdFx0X3V2QS5zZXQoMCwgMCk7XG5cblx0XHRcdF91dkIuc2V0KDEsIDApO1xuXG5cdFx0XHRfdXZDLnNldCgxLCAxKTsgLy8gY2hlY2sgZmlyc3QgdHJpYW5nbGVcblxuXG5cdFx0XHRsZXQgaW50ZXJzZWN0ID0gcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RUcmlhbmdsZShfdkEsIF92QiwgX3ZDLCBmYWxzZSwgX2ludGVyc2VjdFBvaW50KTtcblxuXHRcdFx0aWYgKGludGVyc2VjdCA9PT0gbnVsbCkge1xuXHRcdFx0XHQvLyBjaGVjayBzZWNvbmQgdHJpYW5nbGVcblx0XHRcdFx0dHJhbnNmb3JtVmVydGV4KF92Qi5zZXQoLTAuNSwgMC41LCAwKSwgX212UG9zaXRpb24sIGNlbnRlciwgX3dvcmxkU2NhbGUsIHNpbiwgY29zKTtcblxuXHRcdFx0XHRfdXZCLnNldCgwLCAxKTtcblxuXHRcdFx0XHRpbnRlcnNlY3QgPSByYXljYXN0ZXIucmF5LmludGVyc2VjdFRyaWFuZ2xlKF92QSwgX3ZDLCBfdkIsIGZhbHNlLCBfaW50ZXJzZWN0UG9pbnQpO1xuXG5cdFx0XHRcdGlmIChpbnRlcnNlY3QgPT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKF9pbnRlcnNlY3RQb2ludCk7XG5cdFx0XHRpZiAoZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIpIHJldHVybjtcblx0XHRcdGludGVyc2VjdHMucHVzaCh7XG5cdFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcblx0XHRcdFx0cG9pbnQ6IF9pbnRlcnNlY3RQb2ludC5jbG9uZSgpLFxuXHRcdFx0XHR1djogVHJpYW5nbGUuZ2V0VVYoX2ludGVyc2VjdFBvaW50LCBfdkEsIF92QiwgX3ZDLCBfdXZBLCBfdXZCLCBfdXZDLCBuZXcgVmVjdG9yMigpKSxcblx0XHRcdFx0ZmFjZTogbnVsbCxcblx0XHRcdFx0b2JqZWN0OiB0aGlzXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0aWYgKHNvdXJjZS5jZW50ZXIgIT09IHVuZGVmaW5lZCkgdGhpcy5jZW50ZXIuY29weShzb3VyY2UuY2VudGVyKTtcblx0XHRcdHRoaXMubWF0ZXJpYWwgPSBzb3VyY2UubWF0ZXJpYWw7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdFNwcml0ZS5wcm90b3R5cGUuaXNTcHJpdGUgPSB0cnVlO1xuXG5cdGZ1bmN0aW9uIHRyYW5zZm9ybVZlcnRleCh2ZXJ0ZXhQb3NpdGlvbiwgbXZQb3NpdGlvbiwgY2VudGVyLCBzY2FsZSwgc2luLCBjb3MpIHtcblx0XHQvLyBjb21wdXRlIHBvc2l0aW9uIGluIGNhbWVyYSBzcGFjZVxuXHRcdF9hbGlnbmVkUG9zaXRpb24uc3ViVmVjdG9ycyh2ZXJ0ZXhQb3NpdGlvbiwgY2VudGVyKS5hZGRTY2FsYXIoMC41KS5tdWx0aXBseShzY2FsZSk7IC8vIHRvIGNoZWNrIGlmIHJvdGF0aW9uIGlzIG5vdCB6ZXJvXG5cblxuXHRcdGlmIChzaW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0X3JvdGF0ZWRQb3NpdGlvbi54ID0gY29zICogX2FsaWduZWRQb3NpdGlvbi54IC0gc2luICogX2FsaWduZWRQb3NpdGlvbi55O1xuXHRcdFx0X3JvdGF0ZWRQb3NpdGlvbi55ID0gc2luICogX2FsaWduZWRQb3NpdGlvbi54ICsgY29zICogX2FsaWduZWRQb3NpdGlvbi55O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRfcm90YXRlZFBvc2l0aW9uLmNvcHkoX2FsaWduZWRQb3NpdGlvbik7XG5cdFx0fVxuXG5cdFx0dmVydGV4UG9zaXRpb24uY29weShtdlBvc2l0aW9uKTtcblx0XHR2ZXJ0ZXhQb3NpdGlvbi54ICs9IF9yb3RhdGVkUG9zaXRpb24ueDtcblx0XHR2ZXJ0ZXhQb3NpdGlvbi55ICs9IF9yb3RhdGVkUG9zaXRpb24ueTsgLy8gdHJhbnNmb3JtIHRvIHdvcmxkIHNwYWNlXG5cblx0XHR2ZXJ0ZXhQb3NpdGlvbi5hcHBseU1hdHJpeDQoX3ZpZXdXb3JsZE1hdHJpeCk7XG5cdH1cblxuXHRjb25zdCBfdjEkMiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF92MiQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y2xhc3MgTE9EIGV4dGVuZHMgT2JqZWN0M0Qge1xuXHRcdGNvbnN0cnVjdG9yKCkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMuX2N1cnJlbnRMZXZlbCA9IDA7XG5cdFx0XHR0aGlzLnR5cGUgPSAnTE9EJztcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcblx0XHRcdFx0bGV2ZWxzOiB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogW11cblx0XHRcdFx0fSxcblx0XHRcdFx0aXNMT0Q6IHtcblx0XHRcdFx0XHR2YWx1ZTogdHJ1ZVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlLCBmYWxzZSk7XG5cdFx0XHRjb25zdCBsZXZlbHMgPSBzb3VyY2UubGV2ZWxzO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgbGV2ZWwgPSBsZXZlbHNbaV07XG5cdFx0XHRcdHRoaXMuYWRkTGV2ZWwobGV2ZWwub2JqZWN0LmNsb25lKCksIGxldmVsLmRpc3RhbmNlKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5hdXRvVXBkYXRlID0gc291cmNlLmF1dG9VcGRhdGU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRhZGRMZXZlbChvYmplY3QsIGRpc3RhbmNlID0gMCkge1xuXHRcdFx0ZGlzdGFuY2UgPSBNYXRoLmFicyhkaXN0YW5jZSk7XG5cdFx0XHRjb25zdCBsZXZlbHMgPSB0aGlzLmxldmVscztcblx0XHRcdGxldCBsO1xuXG5cdFx0XHRmb3IgKGwgPSAwOyBsIDwgbGV2ZWxzLmxlbmd0aDsgbCsrKSB7XG5cdFx0XHRcdGlmIChkaXN0YW5jZSA8IGxldmVsc1tsXS5kaXN0YW5jZSkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGxldmVscy5zcGxpY2UobCwgMCwge1xuXHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG5cdFx0XHRcdG9iamVjdDogb2JqZWN0XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuYWRkKG9iamVjdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRnZXRDdXJyZW50TGV2ZWwoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY3VycmVudExldmVsO1xuXHRcdH1cblxuXHRcdGdldE9iamVjdEZvckRpc3RhbmNlKGRpc3RhbmNlKSB7XG5cdFx0XHRjb25zdCBsZXZlbHMgPSB0aGlzLmxldmVscztcblxuXHRcdFx0aWYgKGxldmVscy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGxldCBpLCBsO1xuXG5cdFx0XHRcdGZvciAoaSA9IDEsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKGRpc3RhbmNlIDwgbGV2ZWxzW2ldLmRpc3RhbmNlKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbGV2ZWxzW2kgLSAxXS5vYmplY3Q7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHJheWNhc3QocmF5Y2FzdGVyLCBpbnRlcnNlY3RzKSB7XG5cdFx0XHRjb25zdCBsZXZlbHMgPSB0aGlzLmxldmVscztcblxuXHRcdFx0aWYgKGxldmVscy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdF92MSQyLnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLm1hdHJpeFdvcmxkKTtcblxuXHRcdFx0XHRjb25zdCBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oX3YxJDIpO1xuXHRcdFx0XHR0aGlzLmdldE9iamVjdEZvckRpc3RhbmNlKGRpc3RhbmNlKS5yYXljYXN0KHJheWNhc3RlciwgaW50ZXJzZWN0cyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dXBkYXRlKGNhbWVyYSkge1xuXHRcdFx0Y29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cblx0XHRcdGlmIChsZXZlbHMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRfdjEkMi5zZXRGcm9tTWF0cml4UG9zaXRpb24oY2FtZXJhLm1hdHJpeFdvcmxkKTtcblxuXHRcdFx0XHRfdjIkMS5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5tYXRyaXhXb3JsZCk7XG5cblx0XHRcdFx0Y29uc3QgZGlzdGFuY2UgPSBfdjEkMi5kaXN0YW5jZVRvKF92MiQxKSAvIGNhbWVyYS56b29tO1xuXHRcdFx0XHRsZXZlbHNbMF0ub2JqZWN0LnZpc2libGUgPSB0cnVlO1xuXHRcdFx0XHRsZXQgaSwgbDtcblxuXHRcdFx0XHRmb3IgKGkgPSAxLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGlmIChkaXN0YW5jZSA+PSBsZXZlbHNbaV0uZGlzdGFuY2UpIHtcblx0XHRcdFx0XHRcdGxldmVsc1tpIC0gMV0ub2JqZWN0LnZpc2libGUgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGxldmVsc1tpXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2N1cnJlbnRMZXZlbCA9IGkgLSAxO1xuXG5cdFx0XHRcdGZvciAoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0bGV2ZWxzW2ldLm9iamVjdC52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0b0pTT04obWV0YSkge1xuXHRcdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTihtZXRhKTtcblx0XHRcdGlmICh0aGlzLmF1dG9VcGRhdGUgPT09IGZhbHNlKSBkYXRhLm9iamVjdC5hdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRkYXRhLm9iamVjdC5sZXZlbHMgPSBbXTtcblx0XHRcdGNvbnN0IGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgbGV2ZWwgPSBsZXZlbHNbaV07XG5cdFx0XHRcdGRhdGEub2JqZWN0LmxldmVscy5wdXNoKHtcblx0XHRcdFx0XHRvYmplY3Q6IGxldmVsLm9iamVjdC51dWlkLFxuXHRcdFx0XHRcdGRpc3RhbmNlOiBsZXZlbC5kaXN0YW5jZVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdH1cblxuXHRjb25zdCBfYmFzZVBvc2l0aW9uID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3NraW5JbmRleCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yNCgpO1xuXG5cdGNvbnN0IF9za2luV2VpZ2h0ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3I0KCk7XG5cblx0Y29uc3QgX3ZlY3RvciQ1ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX21hdHJpeCA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuXG5cdGNsYXNzIFNraW5uZWRNZXNoIGV4dGVuZHMgTWVzaCB7XG5cdFx0Y29uc3RydWN0b3IoZ2VvbWV0cnksIG1hdGVyaWFsKSB7XG5cdFx0XHRzdXBlcihnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuXHRcdFx0dGhpcy50eXBlID0gJ1NraW5uZWRNZXNoJztcblx0XHRcdHRoaXMuYmluZE1vZGUgPSAnYXR0YWNoZWQnO1xuXHRcdFx0dGhpcy5iaW5kTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblx0XHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UgPSBuZXcgTWF0cml4NCgpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLmJpbmRNb2RlID0gc291cmNlLmJpbmRNb2RlO1xuXHRcdFx0dGhpcy5iaW5kTWF0cml4LmNvcHkoc291cmNlLmJpbmRNYXRyaXgpO1xuXHRcdFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZS5jb3B5KHNvdXJjZS5iaW5kTWF0cml4SW52ZXJzZSk7XG5cdFx0XHR0aGlzLnNrZWxldG9uID0gc291cmNlLnNrZWxldG9uO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0YmluZChza2VsZXRvbiwgYmluZE1hdHJpeCkge1xuXHRcdFx0dGhpcy5za2VsZXRvbiA9IHNrZWxldG9uO1xuXG5cdFx0XHRpZiAoYmluZE1hdHJpeCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQodHJ1ZSk7XG5cdFx0XHRcdHRoaXMuc2tlbGV0b24uY2FsY3VsYXRlSW52ZXJzZXMoKTtcblx0XHRcdFx0YmluZE1hdHJpeCA9IHRoaXMubWF0cml4V29ybGQ7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuYmluZE1hdHJpeC5jb3B5KGJpbmRNYXRyaXgpO1xuXHRcdFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZS5jb3B5KGJpbmRNYXRyaXgpLmludmVydCgpO1xuXHRcdH1cblxuXHRcdHBvc2UoKSB7XG5cdFx0XHR0aGlzLnNrZWxldG9uLnBvc2UoKTtcblx0XHR9XG5cblx0XHRub3JtYWxpemVTa2luV2VpZ2h0cygpIHtcblx0XHRcdGNvbnN0IHZlY3RvciA9IG5ldyBWZWN0b3I0KCk7XG5cdFx0XHRjb25zdCBza2luV2VpZ2h0ID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnNraW5XZWlnaHQ7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gc2tpbldlaWdodC5jb3VudDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2ZWN0b3IueCA9IHNraW5XZWlnaHQuZ2V0WChpKTtcblx0XHRcdFx0dmVjdG9yLnkgPSBza2luV2VpZ2h0LmdldFkoaSk7XG5cdFx0XHRcdHZlY3Rvci56ID0gc2tpbldlaWdodC5nZXRaKGkpO1xuXHRcdFx0XHR2ZWN0b3IudyA9IHNraW5XZWlnaHQuZ2V0VyhpKTtcblx0XHRcdFx0Y29uc3Qgc2NhbGUgPSAxLjAgLyB2ZWN0b3IubWFuaGF0dGFuTGVuZ3RoKCk7XG5cblx0XHRcdFx0aWYgKHNjYWxlICE9PSBJbmZpbml0eSkge1xuXHRcdFx0XHRcdHZlY3Rvci5tdWx0aXBseVNjYWxhcihzY2FsZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmVjdG9yLnNldCgxLCAwLCAwLCAwKTsgLy8gZG8gc29tZXRoaW5nIHJlYXNvbmFibGVcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNraW5XZWlnaHQuc2V0WFlaVyhpLCB2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56LCB2ZWN0b3Iudyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dXBkYXRlTWF0cml4V29ybGQoZm9yY2UpIHtcblx0XHRcdHN1cGVyLnVwZGF0ZU1hdHJpeFdvcmxkKGZvcmNlKTtcblxuXHRcdFx0aWYgKHRoaXMuYmluZE1vZGUgPT09ICdhdHRhY2hlZCcpIHtcblx0XHRcdFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZS5jb3B5KHRoaXMubWF0cml4V29ybGQpLmludmVydCgpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLmJpbmRNb2RlID09PSAnZGV0YWNoZWQnKSB7XG5cdFx0XHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuY29weSh0aGlzLmJpbmRNYXRyaXgpLmludmVydCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5Ta2lubmVkTWVzaDogVW5yZWNvZ25pemVkIGJpbmRNb2RlOiAnICsgdGhpcy5iaW5kTW9kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ym9uZVRyYW5zZm9ybShpbmRleCwgdGFyZ2V0KSB7XG5cdFx0XHRjb25zdCBza2VsZXRvbiA9IHRoaXMuc2tlbGV0b247XG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cblx0XHRcdF9za2luSW5kZXguZnJvbUJ1ZmZlckF0dHJpYnV0ZShnZW9tZXRyeS5hdHRyaWJ1dGVzLnNraW5JbmRleCwgaW5kZXgpO1xuXG5cdFx0XHRfc2tpbldlaWdodC5mcm9tQnVmZmVyQXR0cmlidXRlKGdlb21ldHJ5LmF0dHJpYnV0ZXMuc2tpbldlaWdodCwgaW5kZXgpO1xuXG5cdFx0XHRfYmFzZVBvc2l0aW9uLmNvcHkodGFyZ2V0KS5hcHBseU1hdHJpeDQodGhpcy5iaW5kTWF0cml4KTtcblxuXHRcdFx0dGFyZ2V0LnNldCgwLCAwLCAwKTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdFx0Y29uc3Qgd2VpZ2h0ID0gX3NraW5XZWlnaHQuZ2V0Q29tcG9uZW50KGkpO1xuXG5cdFx0XHRcdGlmICh3ZWlnaHQgIT09IDApIHtcblx0XHRcdFx0XHRjb25zdCBib25lSW5kZXggPSBfc2tpbkluZGV4LmdldENvbXBvbmVudChpKTtcblxuXHRcdFx0XHRcdF9tYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhza2VsZXRvbi5ib25lc1tib25lSW5kZXhdLm1hdHJpeFdvcmxkLCBza2VsZXRvbi5ib25lSW52ZXJzZXNbYm9uZUluZGV4XSk7XG5cblx0XHRcdFx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKF92ZWN0b3IkNS5jb3B5KF9iYXNlUG9zaXRpb24pLmFwcGx5TWF0cml4NChfbWF0cml4KSwgd2VpZ2h0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmFwcGx5TWF0cml4NCh0aGlzLmJpbmRNYXRyaXhJbnZlcnNlKTtcblx0XHR9XG5cblx0fVxuXG5cdFNraW5uZWRNZXNoLnByb3RvdHlwZS5pc1NraW5uZWRNZXNoID0gdHJ1ZTtcblxuXHRjbGFzcyBCb25lIGV4dGVuZHMgT2JqZWN0M0Qge1xuXHRcdGNvbnN0cnVjdG9yKCkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdCb25lJztcblx0XHR9XG5cblx0fVxuXG5cdEJvbmUucHJvdG90eXBlLmlzQm9uZSA9IHRydWU7XG5cblx0Y2xhc3MgRGF0YVRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblx0XHRjb25zdHJ1Y3RvcihkYXRhID0gbnVsbCwgd2lkdGggPSAxLCBoZWlnaHQgPSAxLCBmb3JtYXQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyID0gTmVhcmVzdEZpbHRlciwgbWluRmlsdGVyID0gTmVhcmVzdEZpbHRlciwgYW5pc290cm9weSwgZW5jb2RpbmcpIHtcblx0XHRcdHN1cGVyKG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgZW5jb2RpbmcpO1xuXHRcdFx0dGhpcy5pbWFnZSA9IHtcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IGhlaWdodFxuXHRcdFx0fTtcblx0XHRcdHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyO1xuXHRcdFx0dGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXI7XG5cdFx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xuXHRcdFx0dGhpcy51bnBhY2tBbGlnbm1lbnQgPSAxO1xuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXG5cdH1cblxuXHREYXRhVGV4dHVyZS5wcm90b3R5cGUuaXNEYXRhVGV4dHVyZSA9IHRydWU7XG5cblx0Y29uc3QgX29mZnNldE1hdHJpeCA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuXG5cdGNvbnN0IF9pZGVudGl0eU1hdHJpeCA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuXG5cdGNsYXNzIFNrZWxldG9uIHtcblx0XHRjb25zdHJ1Y3Rvcihib25lcyA9IFtdLCBib25lSW52ZXJzZXMgPSBbXSkge1xuXHRcdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cdFx0XHR0aGlzLmJvbmVzID0gYm9uZXMuc2xpY2UoMCk7XG5cdFx0XHR0aGlzLmJvbmVJbnZlcnNlcyA9IGJvbmVJbnZlcnNlcztcblx0XHRcdHRoaXMuYm9uZU1hdHJpY2VzID0gbnVsbDtcblx0XHRcdHRoaXMuYm9uZVRleHR1cmUgPSBudWxsO1xuXHRcdFx0dGhpcy5ib25lVGV4dHVyZVNpemUgPSAwO1xuXHRcdFx0dGhpcy5mcmFtZSA9IC0xO1xuXHRcdFx0dGhpcy5pbml0KCk7XG5cdFx0fVxuXG5cdFx0aW5pdCgpIHtcblx0XHRcdGNvbnN0IGJvbmVzID0gdGhpcy5ib25lcztcblx0XHRcdGNvbnN0IGJvbmVJbnZlcnNlcyA9IHRoaXMuYm9uZUludmVyc2VzO1xuXHRcdFx0dGhpcy5ib25lTWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KGJvbmVzLmxlbmd0aCAqIDE2KTsgLy8gY2FsY3VsYXRlIGludmVyc2UgYm9uZSBtYXRyaWNlcyBpZiBuZWNlc3NhcnlcblxuXHRcdFx0aWYgKGJvbmVJbnZlcnNlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0dGhpcy5jYWxjdWxhdGVJbnZlcnNlcygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gaGFuZGxlIHNwZWNpYWwgY2FzZVxuXHRcdFx0XHRpZiAoYm9uZXMubGVuZ3RoICE9PSBib25lSW52ZXJzZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5Ta2VsZXRvbjogTnVtYmVyIG9mIGludmVyc2UgYm9uZSBtYXRyaWNlcyBkb2VzIG5vdCBtYXRjaCBhbW91bnQgb2YgYm9uZXMuJyk7XG5cdFx0XHRcdFx0dGhpcy5ib25lSW52ZXJzZXMgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRcdFx0dGhpcy5ib25lSW52ZXJzZXMucHVzaChuZXcgTWF0cml4NCgpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRjYWxjdWxhdGVJbnZlcnNlcygpIHtcblx0XHRcdHRoaXMuYm9uZUludmVyc2VzLmxlbmd0aCA9IDA7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBpbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0XHRpZiAodGhpcy5ib25lc1tpXSkge1xuXHRcdFx0XHRcdGludmVyc2UuY29weSh0aGlzLmJvbmVzW2ldLm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuYm9uZUludmVyc2VzLnB1c2goaW52ZXJzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cG9zZSgpIHtcblx0XHRcdC8vIHJlY292ZXIgdGhlIGJpbmQtdGltZSB3b3JsZCBtYXRyaWNlc1xuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gdGhpcy5ib25lcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGJvbmUgPSB0aGlzLmJvbmVzW2ldO1xuXG5cdFx0XHRcdGlmIChib25lKSB7XG5cdFx0XHRcdFx0Ym9uZS5tYXRyaXhXb3JsZC5jb3B5KHRoaXMuYm9uZUludmVyc2VzW2ldKS5pbnZlcnQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSAvLyBjb21wdXRlIHRoZSBsb2NhbCBtYXRyaWNlcywgcG9zaXRpb25zLCByb3RhdGlvbnMgYW5kIHNjYWxlc1xuXG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBib25lID0gdGhpcy5ib25lc1tpXTtcblxuXHRcdFx0XHRpZiAoYm9uZSkge1xuXHRcdFx0XHRcdGlmIChib25lLnBhcmVudCAmJiBib25lLnBhcmVudC5pc0JvbmUpIHtcblx0XHRcdFx0XHRcdGJvbmUubWF0cml4LmNvcHkoYm9uZS5wYXJlbnQubWF0cml4V29ybGQpLmludmVydCgpO1xuXHRcdFx0XHRcdFx0Ym9uZS5tYXRyaXgubXVsdGlwbHkoYm9uZS5tYXRyaXhXb3JsZCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJvbmUubWF0cml4LmNvcHkoYm9uZS5tYXRyaXhXb3JsZCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ym9uZS5tYXRyaXguZGVjb21wb3NlKGJvbmUucG9zaXRpb24sIGJvbmUucXVhdGVybmlvbiwgYm9uZS5zY2FsZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR1cGRhdGUoKSB7XG5cdFx0XHRjb25zdCBib25lcyA9IHRoaXMuYm9uZXM7XG5cdFx0XHRjb25zdCBib25lSW52ZXJzZXMgPSB0aGlzLmJvbmVJbnZlcnNlcztcblx0XHRcdGNvbnN0IGJvbmVNYXRyaWNlcyA9IHRoaXMuYm9uZU1hdHJpY2VzO1xuXHRcdFx0Y29uc3QgYm9uZVRleHR1cmUgPSB0aGlzLmJvbmVUZXh0dXJlOyAvLyBmbGF0dGVuIGJvbmUgbWF0cmljZXMgdG8gYXJyYXlcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHQvLyBjb21wdXRlIHRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIG9yaWdpbmFsIHRyYW5zZm9ybVxuXHRcdFx0XHRjb25zdCBtYXRyaXggPSBib25lc1tpXSA/IGJvbmVzW2ldLm1hdHJpeFdvcmxkIDogX2lkZW50aXR5TWF0cml4O1xuXG5cdFx0XHRcdF9vZmZzZXRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhtYXRyaXgsIGJvbmVJbnZlcnNlc1tpXSk7XG5cblx0XHRcdFx0X29mZnNldE1hdHJpeC50b0FycmF5KGJvbmVNYXRyaWNlcywgaSAqIDE2KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGJvbmVUZXh0dXJlICE9PSBudWxsKSB7XG5cdFx0XHRcdGJvbmVUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgU2tlbGV0b24odGhpcy5ib25lcywgdGhpcy5ib25lSW52ZXJzZXMpO1xuXHRcdH1cblxuXHRcdGNvbXB1dGVCb25lVGV4dHVyZSgpIHtcblx0XHRcdC8vIGxheW91dCAoMSBtYXRyaXggPSA0IHBpeGVscylcblx0XHRcdC8vXHRcdFx0UkdCQSBSR0JBIFJHQkEgUkdCQSAoPT4gY29sdW1uMSwgY29sdW1uMiwgY29sdW1uMywgY29sdW1uNClcblx0XHRcdC8vXHR3aXRoXHQ4eDhcdHBpeGVsIHRleHR1cmUgbWF4XHQgMTYgYm9uZXMgKiA0IHBpeGVscyA9XHQoOCAqIDgpXG5cdFx0XHQvL1x0XHRcdCAxNngxNiBwaXhlbCB0ZXh0dXJlIG1heFx0IDY0IGJvbmVzICogNCBwaXhlbHMgPSAoMTYgKiAxNilcblx0XHRcdC8vXHRcdFx0IDMyeDMyIHBpeGVsIHRleHR1cmUgbWF4XHQyNTYgYm9uZXMgKiA0IHBpeGVscyA9ICgzMiAqIDMyKVxuXHRcdFx0Ly9cdFx0XHQgNjR4NjQgcGl4ZWwgdGV4dHVyZSBtYXggMTAyNCBib25lcyAqIDQgcGl4ZWxzID0gKDY0ICogNjQpXG5cdFx0XHRsZXQgc2l6ZSA9IE1hdGguc3FydCh0aGlzLmJvbmVzLmxlbmd0aCAqIDQpOyAvLyA0IHBpeGVscyBuZWVkZWQgZm9yIDEgbWF0cml4XG5cblx0XHRcdHNpemUgPSBjZWlsUG93ZXJPZlR3byhzaXplKTtcblx0XHRcdHNpemUgPSBNYXRoLm1heChzaXplLCA0KTtcblx0XHRcdGNvbnN0IGJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSAqIHNpemUgKiA0KTsgLy8gNCBmbG9hdHMgcGVyIFJHQkEgcGl4ZWxcblxuXHRcdFx0Ym9uZU1hdHJpY2VzLnNldCh0aGlzLmJvbmVNYXRyaWNlcyk7IC8vIGNvcHkgY3VycmVudCB2YWx1ZXNcblxuXHRcdFx0Y29uc3QgYm9uZVRleHR1cmUgPSBuZXcgRGF0YVRleHR1cmUoYm9uZU1hdHJpY2VzLCBzaXplLCBzaXplLCBSR0JBRm9ybWF0LCBGbG9hdFR5cGUpO1xuXHRcdFx0dGhpcy5ib25lTWF0cmljZXMgPSBib25lTWF0cmljZXM7XG5cdFx0XHR0aGlzLmJvbmVUZXh0dXJlID0gYm9uZVRleHR1cmU7XG5cdFx0XHR0aGlzLmJvbmVUZXh0dXJlU2l6ZSA9IHNpemU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRnZXRCb25lQnlOYW1lKG5hbWUpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBib25lID0gdGhpcy5ib25lc1tpXTtcblxuXHRcdFx0XHRpZiAoYm9uZS5uYW1lID09PSBuYW1lKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJvbmU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRkaXNwb3NlKCkge1xuXHRcdFx0aWYgKHRoaXMuYm9uZVRleHR1cmUgIT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5ib25lVGV4dHVyZS5kaXNwb3NlKCk7XG5cdFx0XHRcdHRoaXMuYm9uZVRleHR1cmUgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZyb21KU09OKGpzb24sIGJvbmVzKSB7XG5cdFx0XHR0aGlzLnV1aWQgPSBqc29uLnV1aWQ7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0ganNvbi5ib25lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgdXVpZCA9IGpzb24uYm9uZXNbaV07XG5cdFx0XHRcdGxldCBib25lID0gYm9uZXNbdXVpZF07XG5cblx0XHRcdFx0aWYgKGJvbmUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuU2tlbGV0b246IE5vIGJvbmUgZm91bmQgd2l0aCBVVUlEOicsIHV1aWQpO1xuXHRcdFx0XHRcdGJvbmUgPSBuZXcgQm9uZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5ib25lcy5wdXNoKGJvbmUpO1xuXHRcdFx0XHR0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KGpzb24uYm9uZUludmVyc2VzW2ldKSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuaW5pdCgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dG9KU09OKCkge1xuXHRcdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdFx0bWV0YWRhdGE6IHtcblx0XHRcdFx0XHR2ZXJzaW9uOiA0LjUsXG5cdFx0XHRcdFx0dHlwZTogJ1NrZWxldG9uJyxcblx0XHRcdFx0XHRnZW5lcmF0b3I6ICdTa2VsZXRvbi50b0pTT04nXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGJvbmVzOiBbXSxcblx0XHRcdFx0Ym9uZUludmVyc2VzOiBbXVxuXHRcdFx0fTtcblx0XHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcblx0XHRcdGNvbnN0IGJvbmVzID0gdGhpcy5ib25lcztcblx0XHRcdGNvbnN0IGJvbmVJbnZlcnNlcyA9IHRoaXMuYm9uZUludmVyc2VzO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGJvbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBib25lID0gYm9uZXNbaV07XG5cdFx0XHRcdGRhdGEuYm9uZXMucHVzaChib25lLnV1aWQpO1xuXHRcdFx0XHRjb25zdCBib25lSW52ZXJzZSA9IGJvbmVJbnZlcnNlc1tpXTtcblx0XHRcdFx0ZGF0YS5ib25lSW52ZXJzZXMucHVzaChib25lSW52ZXJzZS50b0FycmF5KCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cdFx0Y29uc3RydWN0b3IoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkLCBtZXNoUGVyQXR0cmlidXRlID0gMSkge1xuXHRcdFx0aWYgKHR5cGVvZiBub3JtYWxpemVkID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRtZXNoUGVyQXR0cmlidXRlID0gbm9ybWFsaXplZDtcblx0XHRcdFx0bm9ybWFsaXplZCA9IGZhbHNlO1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGU6IFRoZSBjb25zdHJ1Y3RvciBub3cgZXhwZWN0cyBub3JtYWxpemVkIGFzIHRoZSB0aGlyZCBhcmd1bWVudC4nKTtcblx0XHRcdH1cblxuXHRcdFx0c3VwZXIoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcblx0XHRcdHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IG1lc2hQZXJBdHRyaWJ1dGU7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IHNvdXJjZS5tZXNoUGVyQXR0cmlidXRlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dG9KU09OKCkge1xuXHRcdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXHRcdFx0ZGF0YS5tZXNoUGVyQXR0cmlidXRlID0gdGhpcy5tZXNoUGVyQXR0cmlidXRlO1xuXHRcdFx0ZGF0YS5pc0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0fVxuXG5cdEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuXG5cdGNvbnN0IF9pbnN0YW5jZUxvY2FsTWF0cml4ID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5cblx0Y29uc3QgX2luc3RhbmNlV29ybGRNYXRyaXggPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDQoKTtcblxuXHRjb25zdCBfaW5zdGFuY2VJbnRlcnNlY3RzID0gW107XG5cblx0Y29uc3QgX21lc2ggPSAvKkBfX1BVUkVfXyovbmV3IE1lc2goKTtcblxuXHRjbGFzcyBJbnN0YW5jZWRNZXNoIGV4dGVuZHMgTWVzaCB7XG5cdFx0Y29uc3RydWN0b3IoZ2VvbWV0cnksIG1hdGVyaWFsLCBjb3VudCkge1xuXHRcdFx0c3VwZXIoZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHRcdHRoaXMuaW5zdGFuY2VNYXRyaXggPSBuZXcgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkoY291bnQgKiAxNiksIDE2KTtcblx0XHRcdHRoaXMuaW5zdGFuY2VDb2xvciA9IG51bGw7XG5cdFx0XHR0aGlzLmNvdW50ID0gY291bnQ7XG5cdFx0XHR0aGlzLmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0dGhpcy5pbnN0YW5jZU1hdHJpeC5jb3B5KHNvdXJjZS5pbnN0YW5jZU1hdHJpeCk7XG5cdFx0XHRpZiAoc291cmNlLmluc3RhbmNlQ29sb3IgIT09IG51bGwpIHRoaXMuaW5zdGFuY2VDb2xvciA9IHNvdXJjZS5pbnN0YW5jZUNvbG9yLmNsb25lKCk7XG5cdFx0XHR0aGlzLmNvdW50ID0gc291cmNlLmNvdW50O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Z2V0Q29sb3JBdChpbmRleCwgY29sb3IpIHtcblx0XHRcdGNvbG9yLmZyb21BcnJheSh0aGlzLmluc3RhbmNlQ29sb3IuYXJyYXksIGluZGV4ICogMyk7XG5cdFx0fVxuXG5cdFx0Z2V0TWF0cml4QXQoaW5kZXgsIG1hdHJpeCkge1xuXHRcdFx0bWF0cml4LmZyb21BcnJheSh0aGlzLmluc3RhbmNlTWF0cml4LmFycmF5LCBpbmRleCAqIDE2KTtcblx0XHR9XG5cblx0XHRyYXljYXN0KHJheWNhc3RlciwgaW50ZXJzZWN0cykge1xuXHRcdFx0Y29uc3QgbWF0cml4V29ybGQgPSB0aGlzLm1hdHJpeFdvcmxkO1xuXHRcdFx0Y29uc3QgcmF5Y2FzdFRpbWVzID0gdGhpcy5jb3VudDtcblx0XHRcdF9tZXNoLmdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRcdF9tZXNoLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcblx0XHRcdGlmIChfbWVzaC5tYXRlcmlhbCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cblx0XHRcdGZvciAobGV0IGluc3RhbmNlSWQgPSAwOyBpbnN0YW5jZUlkIDwgcmF5Y2FzdFRpbWVzOyBpbnN0YW5jZUlkKyspIHtcblx0XHRcdFx0Ly8gY2FsY3VsYXRlIHRoZSB3b3JsZCBtYXRyaXggZm9yIGVhY2ggaW5zdGFuY2Vcblx0XHRcdFx0dGhpcy5nZXRNYXRyaXhBdChpbnN0YW5jZUlkLCBfaW5zdGFuY2VMb2NhbE1hdHJpeCk7XG5cblx0XHRcdFx0X2luc3RhbmNlV29ybGRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhtYXRyaXhXb3JsZCwgX2luc3RhbmNlTG9jYWxNYXRyaXgpOyAvLyB0aGUgbWVzaCByZXByZXNlbnRzIHRoaXMgc2luZ2xlIGluc3RhbmNlXG5cblxuXHRcdFx0XHRfbWVzaC5tYXRyaXhXb3JsZCA9IF9pbnN0YW5jZVdvcmxkTWF0cml4O1xuXG5cdFx0XHRcdF9tZXNoLnJheWNhc3QocmF5Y2FzdGVyLCBfaW5zdGFuY2VJbnRlcnNlY3RzKTsgLy8gcHJvY2VzcyB0aGUgcmVzdWx0IG9mIHJheWNhc3RcblxuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gX2luc3RhbmNlSW50ZXJzZWN0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBpbnRlcnNlY3QgPSBfaW5zdGFuY2VJbnRlcnNlY3RzW2ldO1xuXHRcdFx0XHRcdGludGVyc2VjdC5pbnN0YW5jZUlkID0gaW5zdGFuY2VJZDtcblx0XHRcdFx0XHRpbnRlcnNlY3Qub2JqZWN0ID0gdGhpcztcblx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goaW50ZXJzZWN0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9pbnN0YW5jZUludGVyc2VjdHMubGVuZ3RoID0gMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzZXRDb2xvckF0KGluZGV4LCBjb2xvcikge1xuXHRcdFx0aWYgKHRoaXMuaW5zdGFuY2VDb2xvciA9PT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLmluc3RhbmNlQ29sb3IgPSBuZXcgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkodGhpcy5pbnN0YW5jZU1hdHJpeC5jb3VudCAqIDMpLCAzKTtcblx0XHRcdH1cblxuXHRcdFx0Y29sb3IudG9BcnJheSh0aGlzLmluc3RhbmNlQ29sb3IuYXJyYXksIGluZGV4ICogMyk7XG5cdFx0fVxuXG5cdFx0c2V0TWF0cml4QXQoaW5kZXgsIG1hdHJpeCkge1xuXHRcdFx0bWF0cml4LnRvQXJyYXkodGhpcy5pbnN0YW5jZU1hdHJpeC5hcnJheSwgaW5kZXggKiAxNik7XG5cdFx0fVxuXG5cdFx0dXBkYXRlTW9ycGhUYXJnZXRzKCkge31cblxuXHRcdGRpc3Bvc2UoKSB7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoe1xuXHRcdFx0XHR0eXBlOiAnZGlzcG9zZSdcblx0XHRcdH0pO1xuXHRcdH1cblxuXHR9XG5cblx0SW5zdGFuY2VkTWVzaC5wcm90b3R5cGUuaXNJbnN0YW5jZWRNZXNoID0gdHJ1ZTtcblxuXHQvKipcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICpcdGNvbG9yOiA8aGV4Pixcblx0ICpcdG9wYWNpdHk6IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHRsaW5ld2lkdGg6IDxmbG9hdD4sXG5cdCAqXHRsaW5lY2FwOiBcInJvdW5kXCIsXG5cdCAqXHRsaW5lam9pbjogXCJyb3VuZFwiXG5cdCAqIH1cblx0ICovXG5cblx0Y2xhc3MgTGluZUJhc2ljTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cdFx0Y29uc3RydWN0b3IocGFyYW1ldGVycykge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdMaW5lQmFzaWNNYXRlcmlhbCc7XG5cdFx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKDB4ZmZmZmZmKTtcblx0XHRcdHRoaXMubGluZXdpZHRoID0gMTtcblx0XHRcdHRoaXMubGluZWNhcCA9ICdyb3VuZCc7XG5cdFx0XHR0aGlzLmxpbmVqb2luID0gJ3JvdW5kJztcblx0XHRcdHRoaXMuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLmNvbG9yLmNvcHkoc291cmNlLmNvbG9yKTtcblx0XHRcdHRoaXMubGluZXdpZHRoID0gc291cmNlLmxpbmV3aWR0aDtcblx0XHRcdHRoaXMubGluZWNhcCA9IHNvdXJjZS5saW5lY2FwO1xuXHRcdFx0dGhpcy5saW5lam9pbiA9IHNvdXJjZS5saW5lam9pbjtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0TGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmlzTGluZUJhc2ljTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdGNvbnN0IF9zdGFydCQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX2VuZCQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX2ludmVyc2VNYXRyaXgkMSA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuXG5cdGNvbnN0IF9yYXkkMSA9IC8qQF9fUFVSRV9fKi9uZXcgUmF5KCk7XG5cblx0Y29uc3QgX3NwaGVyZSQxID0gLypAX19QVVJFX18qL25ldyBTcGhlcmUoKTtcblxuXHRjbGFzcyBMaW5lIGV4dGVuZHMgT2JqZWN0M0Qge1xuXHRcdGNvbnN0cnVjdG9yKGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCksIG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCkpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnTGluZSc7XG5cdFx0XHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG5cdFx0XHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cdFx0XHR0aGlzLnVwZGF0ZU1vcnBoVGFyZ2V0cygpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLm1hdGVyaWFsID0gc291cmNlLm1hdGVyaWFsO1xuXHRcdFx0dGhpcy5nZW9tZXRyeSA9IHNvdXJjZS5nZW9tZXRyeTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNvbXB1dGVMaW5lRGlzdGFuY2VzKCkge1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG5cdFx0XHRpZiAoZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSkge1xuXHRcdFx0XHQvLyB3ZSBhc3N1bWUgbm9uLWluZGV4ZWQgZ2VvbWV0cnlcblx0XHRcdFx0aWYgKGdlb21ldHJ5LmluZGV4ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0XHRcdGNvbnN0IGxpbmVEaXN0YW5jZXMgPSBbMF07XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMSwgbCA9IHBvc2l0aW9uQXR0cmlidXRlLmNvdW50OyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRfc3RhcnQkMS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCBpIC0gMSk7XG5cblx0XHRcdFx0XHRcdF9lbmQkMS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCBpKTtcblxuXHRcdFx0XHRcdFx0bGluZURpc3RhbmNlc1tpXSA9IGxpbmVEaXN0YW5jZXNbaSAtIDFdO1xuXHRcdFx0XHRcdFx0bGluZURpc3RhbmNlc1tpXSArPSBfc3RhcnQkMS5kaXN0YW5jZVRvKF9lbmQkMSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdsaW5lRGlzdGFuY2UnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShsaW5lRGlzdGFuY2VzLCAxKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5MaW5lLmNvbXB1dGVMaW5lRGlzdGFuY2VzKCk6IENvbXB1dGF0aW9uIG9ubHkgcG9zc2libGUgd2l0aCBub24taW5kZXhlZCBCdWZmZXJHZW9tZXRyeS4nKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChnZW9tZXRyeS5pc0dlb21ldHJ5KSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkxpbmUuY29tcHV0ZUxpbmVEaXN0YW5jZXMoKSBubyBsb25nZXIgc3VwcG9ydHMgVEhSRUUuR2VvbWV0cnkuIFVzZSBUSFJFRS5CdWZmZXJHZW9tZXRyeSBpbnN0ZWFkLicpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRyYXljYXN0KHJheWNhc3RlciwgaW50ZXJzZWN0cykge1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdFx0Y29uc3QgbWF0cml4V29ybGQgPSB0aGlzLm1hdHJpeFdvcmxkO1xuXHRcdFx0Y29uc3QgdGhyZXNob2xkID0gcmF5Y2FzdGVyLnBhcmFtcy5MaW5lLnRocmVzaG9sZDtcblx0XHRcdGNvbnN0IGRyYXdSYW5nZSA9IGdlb21ldHJ5LmRyYXdSYW5nZTsgLy8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmUgZGlzdGFuY2UgdG8gcmF5XG5cblx0XHRcdGlmIChnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRcdF9zcGhlcmUkMS5jb3B5KGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlKTtcblxuXHRcdFx0X3NwaGVyZSQxLmFwcGx5TWF0cml4NChtYXRyaXhXb3JsZCk7XG5cblx0XHRcdF9zcGhlcmUkMS5yYWRpdXMgKz0gdGhyZXNob2xkO1xuXHRcdFx0aWYgKHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0c1NwaGVyZShfc3BoZXJlJDEpID09PSBmYWxzZSkgcmV0dXJuOyAvL1xuXG5cdFx0XHRfaW52ZXJzZU1hdHJpeCQxLmNvcHkobWF0cml4V29ybGQpLmludmVydCgpO1xuXG5cdFx0XHRfcmF5JDEuY29weShyYXljYXN0ZXIucmF5KS5hcHBseU1hdHJpeDQoX2ludmVyc2VNYXRyaXgkMSk7XG5cblx0XHRcdGNvbnN0IGxvY2FsVGhyZXNob2xkID0gdGhyZXNob2xkIC8gKCh0aGlzLnNjYWxlLnggKyB0aGlzLnNjYWxlLnkgKyB0aGlzLnNjYWxlLnopIC8gMyk7XG5cdFx0XHRjb25zdCBsb2NhbFRocmVzaG9sZFNxID0gbG9jYWxUaHJlc2hvbGQgKiBsb2NhbFRocmVzaG9sZDtcblx0XHRcdGNvbnN0IHZTdGFydCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCB2RW5kID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IGludGVyU2VnbWVudCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBpbnRlclJheSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBzdGVwID0gdGhpcy5pc0xpbmVTZWdtZW50cyA/IDIgOiAxO1xuXG5cdFx0XHRpZiAoZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSkge1xuXHRcdFx0XHRjb25zdCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblx0XHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRcdGlmIChpbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgZHJhd1JhbmdlLnN0YXJ0KTtcblx0XHRcdFx0XHRjb25zdCBlbmQgPSBNYXRoLm1pbihpbmRleC5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSBzdGFydCwgbCA9IGVuZCAtIDE7IGkgPCBsOyBpICs9IHN0ZXApIHtcblx0XHRcdFx0XHRcdGNvbnN0IGEgPSBpbmRleC5nZXRYKGkpO1xuXHRcdFx0XHRcdFx0Y29uc3QgYiA9IGluZGV4LmdldFgoaSArIDEpO1xuXHRcdFx0XHRcdFx0dlN0YXJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyaWJ1dGUsIGEpO1xuXHRcdFx0XHRcdFx0dkVuZC5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCBiKTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgZGlzdFNxID0gX3JheSQxLmRpc3RhbmNlU3FUb1NlZ21lbnQodlN0YXJ0LCB2RW5kLCBpbnRlclJheSwgaW50ZXJTZWdtZW50KTtcblxuXHRcdFx0XHRcdFx0aWYgKGRpc3RTcSA+IGxvY2FsVGhyZXNob2xkU3EpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0aW50ZXJSYXkuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4V29ybGQpOyAvL01vdmUgYmFjayB0byB3b3JsZCBzcGFjZSBmb3IgZGlzdGFuY2UgY2FsY3VsYXRpb25cblxuXHRcdFx0XHRcdFx0Y29uc3QgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKGludGVyUmF5KTtcblx0XHRcdFx0XHRcdGlmIChkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhcikgY29udGludWU7XG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG5cdFx0XHRcdFx0XHRcdC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xuXHRcdFx0XHRcdFx0XHQvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcblx0XHRcdFx0XHRcdFx0cG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKSxcblx0XHRcdFx0XHRcdFx0aW5kZXg6IGksXG5cdFx0XHRcdFx0XHRcdGZhY2U6IG51bGwsXG5cdFx0XHRcdFx0XHRcdGZhY2VJbmRleDogbnVsbCxcblx0XHRcdFx0XHRcdFx0b2JqZWN0OiB0aGlzXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc3Qgc3RhcnQgPSBNYXRoLm1heCgwLCBkcmF3UmFuZ2Uuc3RhcnQpO1xuXHRcdFx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKHBvc2l0aW9uQXR0cmlidXRlLmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IHN0YXJ0LCBsID0gZW5kIC0gMTsgaSA8IGw7IGkgKz0gc3RlcCkge1xuXHRcdFx0XHRcdFx0dlN0YXJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyaWJ1dGUsIGkpO1xuXHRcdFx0XHRcdFx0dkVuZC5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCBpICsgMSk7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGRpc3RTcSA9IF9yYXkkMS5kaXN0YW5jZVNxVG9TZWdtZW50KHZTdGFydCwgdkVuZCwgaW50ZXJSYXksIGludGVyU2VnbWVudCk7XG5cblx0XHRcdFx0XHRcdGlmIChkaXN0U3EgPiBsb2NhbFRocmVzaG9sZFNxKSBjb250aW51ZTtcblx0XHRcdFx0XHRcdGludGVyUmF5LmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKTsgLy9Nb3ZlIGJhY2sgdG8gd29ybGQgc3BhY2UgZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXG5cblx0XHRcdFx0XHRcdGNvbnN0IGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyhpbnRlclJheSk7XG5cdFx0XHRcdFx0XHRpZiAoZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0XHRcdFx0XHQvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cblx0XHRcdFx0XHRcdFx0Ly8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXG5cdFx0XHRcdFx0XHRcdHBvaW50OiBpbnRlclNlZ21lbnQuY2xvbmUoKS5hcHBseU1hdHJpeDQodGhpcy5tYXRyaXhXb3JsZCksXG5cdFx0XHRcdFx0XHRcdGluZGV4OiBpLFxuXHRcdFx0XHRcdFx0XHRmYWNlOiBudWxsLFxuXHRcdFx0XHRcdFx0XHRmYWNlSW5kZXg6IG51bGwsXG5cdFx0XHRcdFx0XHRcdG9iamVjdDogdGhpc1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGdlb21ldHJ5LmlzR2VvbWV0cnkpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuTGluZS5yYXljYXN0KCkgbm8gbG9uZ2VyIHN1cHBvcnRzIFRIUkVFLkdlb21ldHJ5LiBVc2UgVEhSRUUuQnVmZmVyR2VvbWV0cnkgaW5zdGVhZC4nKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR1cGRhdGVNb3JwaFRhcmdldHMoKSB7XG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cblx0XHRcdGlmIChnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5KSB7XG5cdFx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcblx0XHRcdFx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG1vcnBoQXR0cmlidXRlcyk7XG5cblx0XHRcdFx0aWYgKGtleXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzW2tleXNbMF1dO1xuXG5cdFx0XHRcdFx0aWYgKG1vcnBoQXR0cmlidXRlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XG5cdFx0XHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xuXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBtID0gMCwgbWwgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IG0gPCBtbDsgbSsrKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG5hbWUgPSBtb3JwaEF0dHJpYnV0ZVttXS5uYW1lIHx8IFN0cmluZyhtKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCgwKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbbmFtZV0gPSBtO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xuXG5cdFx0XHRcdGlmIChtb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCAmJiBtb3JwaFRhcmdldHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkxpbmUudXBkYXRlTW9ycGhUYXJnZXRzKCkgZG9lcyBub3Qgc3VwcG9ydCBUSFJFRS5HZW9tZXRyeS4gVXNlIFRIUkVFLkJ1ZmZlckdlb21ldHJ5IGluc3RlYWQuJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0fVxuXG5cdExpbmUucHJvdG90eXBlLmlzTGluZSA9IHRydWU7XG5cblx0Y29uc3QgX3N0YXJ0ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX2VuZCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNsYXNzIExpbmVTZWdtZW50cyBleHRlbmRzIExpbmUge1xuXHRcdGNvbnN0cnVjdG9yKGdlb21ldHJ5LCBtYXRlcmlhbCkge1xuXHRcdFx0c3VwZXIoZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHRcdHRoaXMudHlwZSA9ICdMaW5lU2VnbWVudHMnO1xuXHRcdH1cblxuXHRcdGNvbXB1dGVMaW5lRGlzdGFuY2VzKCkge1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG5cdFx0XHRpZiAoZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSkge1xuXHRcdFx0XHQvLyB3ZSBhc3N1bWUgbm9uLWluZGV4ZWQgZ2VvbWV0cnlcblx0XHRcdFx0aWYgKGdlb21ldHJ5LmluZGV4ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0XHRcdGNvbnN0IGxpbmVEaXN0YW5jZXMgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gcG9zaXRpb25BdHRyaWJ1dGUuY291bnQ7IGkgPCBsOyBpICs9IDIpIHtcblx0XHRcdFx0XHRcdF9zdGFydC5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCBpKTtcblxuXHRcdFx0XHRcdFx0X2VuZC5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCBpICsgMSk7XG5cblx0XHRcdFx0XHRcdGxpbmVEaXN0YW5jZXNbaV0gPSBpID09PSAwID8gMCA6IGxpbmVEaXN0YW5jZXNbaSAtIDFdO1xuXHRcdFx0XHRcdFx0bGluZURpc3RhbmNlc1tpICsgMV0gPSBsaW5lRGlzdGFuY2VzW2ldICsgX3N0YXJ0LmRpc3RhbmNlVG8oX2VuZCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdsaW5lRGlzdGFuY2UnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShsaW5lRGlzdGFuY2VzLCAxKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5MaW5lU2VnbWVudHMuY29tcHV0ZUxpbmVEaXN0YW5jZXMoKTogQ29tcHV0YXRpb24gb25seSBwb3NzaWJsZSB3aXRoIG5vbi1pbmRleGVkIEJ1ZmZlckdlb21ldHJ5LicpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGdlb21ldHJ5LmlzR2VvbWV0cnkpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuTGluZVNlZ21lbnRzLmNvbXB1dGVMaW5lRGlzdGFuY2VzKCkgbm8gbG9uZ2VyIHN1cHBvcnRzIFRIUkVFLkdlb21ldHJ5LiBVc2UgVEhSRUUuQnVmZmVyR2VvbWV0cnkgaW5zdGVhZC4nKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRMaW5lU2VnbWVudHMucHJvdG90eXBlLmlzTGluZVNlZ21lbnRzID0gdHJ1ZTtcblxuXHRjbGFzcyBMaW5lTG9vcCBleHRlbmRzIExpbmUge1xuXHRcdGNvbnN0cnVjdG9yKGdlb21ldHJ5LCBtYXRlcmlhbCkge1xuXHRcdFx0c3VwZXIoZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHRcdHRoaXMudHlwZSA9ICdMaW5lTG9vcCc7XG5cdFx0fVxuXG5cdH1cblxuXHRMaW5lTG9vcC5wcm90b3R5cGUuaXNMaW5lTG9vcCA9IHRydWU7XG5cblx0LyoqXG5cdCAqIHBhcmFtZXRlcnMgPSB7XG5cdCAqXHRjb2xvcjogPGhleD4sXG5cdCAqXHRvcGFjaXR5OiA8ZmxvYXQ+LFxuXHQgKlx0bWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlx0YWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqXHRzaXplOiA8ZmxvYXQ+LFxuXHQgKlx0c2l6ZUF0dGVudWF0aW9uOiA8Ym9vbD5cblx0ICpcblx0ICogfVxuXHQgKi9cblxuXHRjbGFzcyBQb2ludHNNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblx0XHRjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ1BvaW50c01hdGVyaWFsJztcblx0XHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoMHhmZmZmZmYpO1xuXHRcdFx0dGhpcy5tYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLnNpemUgPSAxO1xuXHRcdFx0dGhpcy5zaXplQXR0ZW51YXRpb24gPSB0cnVlO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMocGFyYW1ldGVycyk7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdHRoaXMuY29sb3IuY29weShzb3VyY2UuY29sb3IpO1xuXHRcdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXHRcdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblx0XHRcdHRoaXMuc2l6ZSA9IHNvdXJjZS5zaXplO1xuXHRcdFx0dGhpcy5zaXplQXR0ZW51YXRpb24gPSBzb3VyY2Uuc2l6ZUF0dGVudWF0aW9uO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRQb2ludHNNYXRlcmlhbC5wcm90b3R5cGUuaXNQb2ludHNNYXRlcmlhbCA9IHRydWU7XG5cblx0Y29uc3QgX2ludmVyc2VNYXRyaXggPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDQoKTtcblxuXHRjb25zdCBfcmF5ID0gLypAX19QVVJFX18qL25ldyBSYXkoKTtcblxuXHRjb25zdCBfc3BoZXJlID0gLypAX19QVVJFX18qL25ldyBTcGhlcmUoKTtcblxuXHRjb25zdCBfcG9zaXRpb24kMiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNsYXNzIFBvaW50cyBleHRlbmRzIE9iamVjdDNEIHtcblx0XHRjb25zdHJ1Y3RvcihnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpLCBtYXRlcmlhbCA9IG5ldyBQb2ludHNNYXRlcmlhbCgpKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ1BvaW50cyc7XG5cdFx0XHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG5cdFx0XHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cdFx0XHR0aGlzLnVwZGF0ZU1vcnBoVGFyZ2V0cygpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLm1hdGVyaWFsID0gc291cmNlLm1hdGVyaWFsO1xuXHRcdFx0dGhpcy5nZW9tZXRyeSA9IHNvdXJjZS5nZW9tZXRyeTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHJheWNhc3QocmF5Y2FzdGVyLCBpbnRlcnNlY3RzKSB7XG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0XHRjb25zdCBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XG5cdFx0XHRjb25zdCB0aHJlc2hvbGQgPSByYXljYXN0ZXIucGFyYW1zLlBvaW50cy50aHJlc2hvbGQ7XG5cdFx0XHRjb25zdCBkcmF3UmFuZ2UgPSBnZW9tZXRyeS5kcmF3UmFuZ2U7IC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxuXG5cdFx0XHRpZiAoZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwpIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0XHRfc3BoZXJlLmNvcHkoZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUpO1xuXG5cdFx0XHRfc3BoZXJlLmFwcGx5TWF0cml4NChtYXRyaXhXb3JsZCk7XG5cblx0XHRcdF9zcGhlcmUucmFkaXVzICs9IHRocmVzaG9sZDtcblx0XHRcdGlmIChyYXljYXN0ZXIucmF5LmludGVyc2VjdHNTcGhlcmUoX3NwaGVyZSkgPT09IGZhbHNlKSByZXR1cm47IC8vXG5cblx0XHRcdF9pbnZlcnNlTWF0cml4LmNvcHkobWF0cml4V29ybGQpLmludmVydCgpO1xuXG5cdFx0XHRfcmF5LmNvcHkocmF5Y2FzdGVyLnJheSkuYXBwbHlNYXRyaXg0KF9pbnZlcnNlTWF0cml4KTtcblxuXHRcdFx0Y29uc3QgbG9jYWxUaHJlc2hvbGQgPSB0aHJlc2hvbGQgLyAoKHRoaXMuc2NhbGUueCArIHRoaXMuc2NhbGUueSArIHRoaXMuc2NhbGUueikgLyAzKTtcblx0XHRcdGNvbnN0IGxvY2FsVGhyZXNob2xkU3EgPSBsb2NhbFRocmVzaG9sZCAqIGxvY2FsVGhyZXNob2xkO1xuXG5cdFx0XHRpZiAoZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSkge1xuXHRcdFx0XHRjb25zdCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblx0XHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRcdGlmIChpbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgZHJhd1JhbmdlLnN0YXJ0KTtcblx0XHRcdFx0XHRjb25zdCBlbmQgPSBNYXRoLm1pbihpbmRleC5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSBzdGFydCwgaWwgPSBlbmQ7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBhID0gaW5kZXguZ2V0WChpKTtcblxuXHRcdFx0XHRcdFx0X3Bvc2l0aW9uJDIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbkF0dHJpYnV0ZSwgYSk7XG5cblx0XHRcdFx0XHRcdHRlc3RQb2ludChfcG9zaXRpb24kMiwgYSwgbG9jYWxUaHJlc2hvbGRTcSwgbWF0cml4V29ybGQsIHJheWNhc3RlciwgaW50ZXJzZWN0cywgdGhpcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgZHJhd1JhbmdlLnN0YXJ0KTtcblx0XHRcdFx0XHRjb25zdCBlbmQgPSBNYXRoLm1pbihwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSBzdGFydCwgbCA9IGVuZDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0X3Bvc2l0aW9uJDIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbkF0dHJpYnV0ZSwgaSk7XG5cblx0XHRcdFx0XHRcdHRlc3RQb2ludChfcG9zaXRpb24kMiwgaSwgbG9jYWxUaHJlc2hvbGRTcSwgbWF0cml4V29ybGQsIHJheWNhc3RlciwgaW50ZXJzZWN0cywgdGhpcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5Qb2ludHMucmF5Y2FzdCgpIG5vIGxvbmdlciBzdXBwb3J0cyBUSFJFRS5HZW9tZXRyeS4gVXNlIFRIUkVFLkJ1ZmZlckdlb21ldHJ5IGluc3RlYWQuJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dXBkYXRlTW9ycGhUYXJnZXRzKCkge1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG5cdFx0XHRpZiAoZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSkge1xuXHRcdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXM7XG5cdFx0XHRcdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhtb3JwaEF0dHJpYnV0ZXMpO1xuXG5cdFx0XHRcdGlmIChrZXlzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1trZXlzWzBdXTtcblxuXHRcdFx0XHRcdGlmIChtb3JwaEF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IFtdO1xuXHRcdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSB7fTtcblxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgbSA9IDAsIG1sID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBtIDwgbWw7IG0rKykge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBuYW1lID0gbW9ycGhBdHRyaWJ1dGVbbV0ubmFtZSB8fCBTdHJpbmcobSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnB1c2goMCk7XG5cdFx0XHRcdFx0XHRcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5W25hbWVdID0gbTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcblxuXHRcdFx0XHRpZiAobW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgJiYgbW9ycGhUYXJnZXRzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5Qb2ludHMudXBkYXRlTW9ycGhUYXJnZXRzKCkgZG9lcyBub3Qgc3VwcG9ydCBUSFJFRS5HZW9tZXRyeS4gVXNlIFRIUkVFLkJ1ZmZlckdlb21ldHJ5IGluc3RlYWQuJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0fVxuXG5cdFBvaW50cy5wcm90b3R5cGUuaXNQb2ludHMgPSB0cnVlO1xuXG5cdGZ1bmN0aW9uIHRlc3RQb2ludChwb2ludCwgaW5kZXgsIGxvY2FsVGhyZXNob2xkU3EsIG1hdHJpeFdvcmxkLCByYXljYXN0ZXIsIGludGVyc2VjdHMsIG9iamVjdCkge1xuXHRcdGNvbnN0IHJheVBvaW50RGlzdGFuY2VTcSA9IF9yYXkuZGlzdGFuY2VTcVRvUG9pbnQocG9pbnQpO1xuXG5cdFx0aWYgKHJheVBvaW50RGlzdGFuY2VTcSA8IGxvY2FsVGhyZXNob2xkU3EpIHtcblx0XHRcdGNvbnN0IGludGVyc2VjdFBvaW50ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0X3JheS5jbG9zZXN0UG9pbnRUb1BvaW50KHBvaW50LCBpbnRlcnNlY3RQb2ludCk7XG5cblx0XHRcdGludGVyc2VjdFBvaW50LmFwcGx5TWF0cml4NChtYXRyaXhXb3JsZCk7XG5cdFx0XHRjb25zdCBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oaW50ZXJzZWN0UG9pbnQpO1xuXHRcdFx0aWYgKGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyKSByZXR1cm47XG5cdFx0XHRpbnRlcnNlY3RzLnB1c2goe1xuXHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG5cdFx0XHRcdGRpc3RhbmNlVG9SYXk6IE1hdGguc3FydChyYXlQb2ludERpc3RhbmNlU3EpLFxuXHRcdFx0XHRwb2ludDogaW50ZXJzZWN0UG9pbnQsXG5cdFx0XHRcdGluZGV4OiBpbmRleCxcblx0XHRcdFx0ZmFjZTogbnVsbCxcblx0XHRcdFx0b2JqZWN0OiBvYmplY3Rcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdGNsYXNzIFZpZGVvVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXHRcdGNvbnN0cnVjdG9yKHZpZGVvLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkpIHtcblx0XHRcdHN1cGVyKHZpZGVvLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkpO1xuXHRcdFx0dGhpcy5mb3JtYXQgPSBmb3JtYXQgIT09IHVuZGVmaW5lZCA/IGZvcm1hdCA6IFJHQkZvcm1hdDtcblx0XHRcdHRoaXMubWluRmlsdGVyID0gbWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtaW5GaWx0ZXIgOiBMaW5lYXJGaWx0ZXI7XG5cdFx0XHR0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogTGluZWFyRmlsdGVyO1xuXHRcdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblx0XHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdFx0ZnVuY3Rpb24gdXBkYXRlVmlkZW8oKSB7XG5cdFx0XHRcdHNjb3BlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0dmlkZW8ucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjayh1cGRhdGVWaWRlbyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICgncmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjaycgaW4gdmlkZW8pIHtcblx0XHRcdFx0dmlkZW8ucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjayh1cGRhdGVWaWRlbyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y2xvbmUoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5pbWFnZSkuY29weSh0aGlzKTtcblx0XHR9XG5cblx0XHR1cGRhdGUoKSB7XG5cdFx0XHRjb25zdCB2aWRlbyA9IHRoaXMuaW1hZ2U7XG5cdFx0XHRjb25zdCBoYXNWaWRlb0ZyYW1lQ2FsbGJhY2sgPSAoJ3JlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2snIGluIHZpZGVvKTtcblxuXHRcdFx0aWYgKGhhc1ZpZGVvRnJhbWVDYWxsYmFjayA9PT0gZmFsc2UgJiYgdmlkZW8ucmVhZHlTdGF0ZSA+PSB2aWRlby5IQVZFX0NVUlJFTlRfREFUQSkge1xuXHRcdFx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0fVxuXG5cdFZpZGVvVGV4dHVyZS5wcm90b3R5cGUuaXNWaWRlb1RleHR1cmUgPSB0cnVlO1xuXG5cdGNsYXNzIENvbXByZXNzZWRUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG5cdFx0Y29uc3RydWN0b3IobWlwbWFwcywgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBhbmlzb3Ryb3B5LCBlbmNvZGluZykge1xuXHRcdFx0c3VwZXIobnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyk7XG5cdFx0XHR0aGlzLmltYWdlID0ge1xuXHRcdFx0XHR3aWR0aDogd2lkdGgsXG5cdFx0XHRcdGhlaWdodDogaGVpZ2h0XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5taXBtYXBzID0gbWlwbWFwczsgLy8gbm8gZmxpcHBpbmcgZm9yIGN1YmUgdGV4dHVyZXNcblx0XHRcdC8vIChhbHNvIGZsaXBwaW5nIGRvZXNuJ3Qgd29yayBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlcyApXG5cblx0XHRcdHRoaXMuZmxpcFkgPSBmYWxzZTsgLy8gY2FuJ3QgZ2VuZXJhdGUgbWlwbWFwcyBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlc1xuXHRcdFx0Ly8gbWlwcyBtdXN0IGJlIGVtYmVkZGVkIGluIEREUyBmaWxlc1xuXG5cdFx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXHRcdH1cblxuXHR9XG5cblx0Q29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlLmlzQ29tcHJlc3NlZFRleHR1cmUgPSB0cnVlO1xuXG5cdGNsYXNzIENhbnZhc1RleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblx0XHRjb25zdHJ1Y3RvcihjYW52YXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSkge1xuXHRcdFx0c3VwZXIoY2FudmFzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkpO1xuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXG5cdH1cblxuXHRDYW52YXNUZXh0dXJlLnByb3RvdHlwZS5pc0NhbnZhc1RleHR1cmUgPSB0cnVlO1xuXG5cdGNsYXNzIENpcmNsZUdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXHRcdGNvbnN0cnVjdG9yKHJhZGl1cyA9IDEsIHNlZ21lbnRzID0gOCwgdGhldGFTdGFydCA9IDAsIHRoZXRhTGVuZ3RoID0gTWF0aC5QSSAqIDIpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnQ2lyY2xlR2VvbWV0cnknO1xuXHRcdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxuXHRcdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0XHRcdH07XG5cdFx0XHRzZWdtZW50cyA9IE1hdGgubWF4KDMsIHNlZ21lbnRzKTsgLy8gYnVmZmVyc1xuXG5cdFx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdFx0Y29uc3QgdXZzID0gW107IC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IHV2ID0gbmV3IFZlY3RvcjIoKTsgLy8gY2VudGVyIHBvaW50XG5cblx0XHRcdHZlcnRpY2VzLnB1c2goMCwgMCwgMCk7XG5cdFx0XHRub3JtYWxzLnB1c2goMCwgMCwgMSk7XG5cdFx0XHR1dnMucHVzaCgwLjUsIDAuNSk7XG5cblx0XHRcdGZvciAobGV0IHMgPSAwLCBpID0gMzsgcyA8PSBzZWdtZW50czsgcysrLCBpICs9IDMpIHtcblx0XHRcdFx0Y29uc3Qgc2VnbWVudCA9IHRoZXRhU3RhcnQgKyBzIC8gc2VnbWVudHMgKiB0aGV0YUxlbmd0aDsgLy8gdmVydGV4XG5cblx0XHRcdFx0dmVydGV4LnggPSByYWRpdXMgKiBNYXRoLmNvcyhzZWdtZW50KTtcblx0XHRcdFx0dmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLnNpbihzZWdtZW50KTtcblx0XHRcdFx0dmVydGljZXMucHVzaCh2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56KTsgLy8gbm9ybWFsXG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKDAsIDAsIDEpOyAvLyB1dnNcblxuXHRcdFx0XHR1di54ID0gKHZlcnRpY2VzW2ldIC8gcmFkaXVzICsgMSkgLyAyO1xuXHRcdFx0XHR1di55ID0gKHZlcnRpY2VzW2kgKyAxXSAvIHJhZGl1cyArIDEpIC8gMjtcblx0XHRcdFx0dXZzLnB1c2godXYueCwgdXYueSk7XG5cdFx0XHR9IC8vIGluZGljZXNcblxuXG5cdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSsrKSB7XG5cdFx0XHRcdGluZGljZXMucHVzaChpLCBpICsgMSwgMCk7XG5cdFx0XHR9IC8vIGJ1aWxkIGdlb21ldHJ5XG5cblxuXHRcdFx0dGhpcy5zZXRJbmRleChpbmRpY2VzKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobm9ybWFscywgMykpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodXZzLCAyKSk7XG5cdFx0fVxuXG5cdFx0c3RhdGljIGZyb21KU09OKGRhdGEpIHtcblx0XHRcdHJldHVybiBuZXcgQ2lyY2xlR2VvbWV0cnkoZGF0YS5yYWRpdXMsIGRhdGEuc2VnbWVudHMsIGRhdGEudGhldGFTdGFydCwgZGF0YS50aGV0YUxlbmd0aCk7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBDeWxpbmRlckdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXHRcdGNvbnN0cnVjdG9yKHJhZGl1c1RvcCA9IDEsIHJhZGl1c0JvdHRvbSA9IDEsIGhlaWdodCA9IDEsIHJhZGlhbFNlZ21lbnRzID0gOCwgaGVpZ2h0U2VnbWVudHMgPSAxLCBvcGVuRW5kZWQgPSBmYWxzZSwgdGhldGFTdGFydCA9IDAsIHRoZXRhTGVuZ3RoID0gTWF0aC5QSSAqIDIpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnQ3lsaW5kZXJHZW9tZXRyeSc7XG5cdFx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRcdHJhZGl1c1RvcDogcmFkaXVzVG9wLFxuXHRcdFx0XHRyYWRpdXNCb3R0b206IHJhZGl1c0JvdHRvbSxcblx0XHRcdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcblx0XHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuXHRcdFx0XHRvcGVuRW5kZWQ6IG9wZW5FbmRlZCxcblx0XHRcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdFx0XHR9O1xuXHRcdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdFx0cmFkaWFsU2VnbWVudHMgPSBNYXRoLmZsb29yKHJhZGlhbFNlZ21lbnRzKTtcblx0XHRcdGhlaWdodFNlZ21lbnRzID0gTWF0aC5mbG9vcihoZWlnaHRTZWdtZW50cyk7IC8vIGJ1ZmZlcnNcblxuXHRcdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRcdGNvbnN0IHV2cyA9IFtdOyAvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRjb25zdCBpbmRleEFycmF5ID0gW107XG5cdFx0XHRjb25zdCBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcblx0XHRcdGxldCBncm91cFN0YXJ0ID0gMDsgLy8gZ2VuZXJhdGUgZ2VvbWV0cnlcblxuXHRcdFx0Z2VuZXJhdGVUb3JzbygpO1xuXG5cdFx0XHRpZiAob3BlbkVuZGVkID09PSBmYWxzZSkge1xuXHRcdFx0XHRpZiAocmFkaXVzVG9wID4gMCkgZ2VuZXJhdGVDYXAodHJ1ZSk7XG5cdFx0XHRcdGlmIChyYWRpdXNCb3R0b20gPiAwKSBnZW5lcmF0ZUNhcChmYWxzZSk7XG5cdFx0XHR9IC8vIGJ1aWxkIGdlb21ldHJ5XG5cblxuXHRcdFx0dGhpcy5zZXRJbmRleChpbmRpY2VzKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobm9ybWFscywgMykpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodXZzLCAyKSk7XG5cblx0XHRcdGZ1bmN0aW9uIGdlbmVyYXRlVG9yc28oKSB7XG5cdFx0XHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdGxldCBncm91cENvdW50ID0gMDsgLy8gdGhpcyB3aWxsIGJlIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBub3JtYWxcblxuXHRcdFx0XHRjb25zdCBzbG9wZSA9IChyYWRpdXNCb3R0b20gLSByYWRpdXNUb3ApIC8gaGVpZ2h0OyAvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0XHRcdFx0Zm9yIChsZXQgeSA9IDA7IHkgPD0gaGVpZ2h0U2VnbWVudHM7IHkrKykge1xuXHRcdFx0XHRcdGNvbnN0IGluZGV4Um93ID0gW107XG5cdFx0XHRcdFx0Y29uc3QgdiA9IHkgLyBoZWlnaHRTZWdtZW50czsgLy8gY2FsY3VsYXRlIHRoZSByYWRpdXMgb2YgdGhlIGN1cnJlbnQgcm93XG5cblx0XHRcdFx0XHRjb25zdCByYWRpdXMgPSB2ICogKHJhZGl1c0JvdHRvbSAtIHJhZGl1c1RvcCkgKyByYWRpdXNUb3A7XG5cblx0XHRcdFx0XHRmb3IgKGxldCB4ID0gMDsgeCA8PSByYWRpYWxTZWdtZW50czsgeCsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB1ID0geCAvIHJhZGlhbFNlZ21lbnRzO1xuXHRcdFx0XHRcdFx0Y29uc3QgdGhldGEgPSB1ICogdGhldGFMZW5ndGggKyB0aGV0YVN0YXJ0O1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2luVGhldGEgPSBNYXRoLnNpbih0aGV0YSk7XG5cdFx0XHRcdFx0XHRjb25zdCBjb3NUaGV0YSA9IE1hdGguY29zKHRoZXRhKTsgLy8gdmVydGV4XG5cblx0XHRcdFx0XHRcdHZlcnRleC54ID0gcmFkaXVzICogc2luVGhldGE7XG5cdFx0XHRcdFx0XHR2ZXJ0ZXgueSA9IC12ICogaGVpZ2h0ICsgaGFsZkhlaWdodDtcblx0XHRcdFx0XHRcdHZlcnRleC56ID0gcmFkaXVzICogY29zVGhldGE7XG5cdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnopOyAvLyBub3JtYWxcblxuXHRcdFx0XHRcdFx0bm9ybWFsLnNldChzaW5UaGV0YSwgc2xvcGUsIGNvc1RoZXRhKS5ub3JtYWxpemUoKTtcblx0XHRcdFx0XHRcdG5vcm1hbHMucHVzaChub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56KTsgLy8gdXZcblxuXHRcdFx0XHRcdFx0dXZzLnB1c2godSwgMSAtIHYpOyAvLyBzYXZlIGluZGV4IG9mIHZlcnRleCBpbiByZXNwZWN0aXZlIHJvd1xuXG5cdFx0XHRcdFx0XHRpbmRleFJvdy5wdXNoKGluZGV4KyspO1xuXHRcdFx0XHRcdH0gLy8gbm93IHNhdmUgdmVydGljZXMgb2YgdGhlIHJvdyBpbiBvdXIgaW5kZXggYXJyYXlcblxuXG5cdFx0XHRcdFx0aW5kZXhBcnJheS5wdXNoKGluZGV4Um93KTtcblx0XHRcdFx0fSAvLyBnZW5lcmF0ZSBpbmRpY2VzXG5cblxuXHRcdFx0XHRmb3IgKGxldCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4KyspIHtcblx0XHRcdFx0XHRmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5KyspIHtcblx0XHRcdFx0XHRcdC8vIHdlIHVzZSB0aGUgaW5kZXggYXJyYXkgdG8gYWNjZXNzIHRoZSBjb3JyZWN0IGluZGljZXNcblx0XHRcdFx0XHRcdGNvbnN0IGEgPSBpbmRleEFycmF5W3ldW3hdO1xuXHRcdFx0XHRcdFx0Y29uc3QgYiA9IGluZGV4QXJyYXlbeSArIDFdW3hdO1xuXHRcdFx0XHRcdFx0Y29uc3QgYyA9IGluZGV4QXJyYXlbeSArIDFdW3ggKyAxXTtcblx0XHRcdFx0XHRcdGNvbnN0IGQgPSBpbmRleEFycmF5W3ldW3ggKyAxXTsgLy8gZmFjZXNcblxuXHRcdFx0XHRcdFx0aW5kaWNlcy5wdXNoKGEsIGIsIGQpO1xuXHRcdFx0XHRcdFx0aW5kaWNlcy5wdXNoKGIsIGMsIGQpOyAvLyB1cGRhdGUgZ3JvdXAgY291bnRlclxuXG5cdFx0XHRcdFx0XHRncm91cENvdW50ICs9IDY7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IC8vIGFkZCBhIGdyb3VwIHRvIHRoZSBnZW9tZXRyeS4gdGhpcyB3aWxsIGVuc3VyZSBtdWx0aSBtYXRlcmlhbCBzdXBwb3J0XG5cblxuXHRcdFx0XHRzY29wZS5hZGRHcm91cChncm91cFN0YXJ0LCBncm91cENvdW50LCAwKTsgLy8gY2FsY3VsYXRlIG5ldyBzdGFydCB2YWx1ZSBmb3IgZ3JvdXBzXG5cblx0XHRcdFx0Z3JvdXBTdGFydCArPSBncm91cENvdW50O1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBnZW5lcmF0ZUNhcCh0b3ApIHtcblx0XHRcdFx0Ly8gc2F2ZSB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNlbnRlciB2ZXJ0ZXhcblx0XHRcdFx0Y29uc3QgY2VudGVySW5kZXhTdGFydCA9IGluZGV4O1xuXHRcdFx0XHRjb25zdCB1diA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0XHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdGxldCBncm91cENvdW50ID0gMDtcblx0XHRcdFx0Y29uc3QgcmFkaXVzID0gdG9wID09PSB0cnVlID8gcmFkaXVzVG9wIDogcmFkaXVzQm90dG9tO1xuXHRcdFx0XHRjb25zdCBzaWduID0gdG9wID09PSB0cnVlID8gMSA6IC0xOyAvLyBmaXJzdCB3ZSBnZW5lcmF0ZSB0aGUgY2VudGVyIHZlcnRleCBkYXRhIG9mIHRoZSBjYXAuXG5cdFx0XHRcdC8vIGJlY2F1c2UgdGhlIGdlb21ldHJ5IG5lZWRzIG9uZSBzZXQgb2YgdXZzIHBlciBmYWNlLFxuXHRcdFx0XHQvLyB3ZSBtdXN0IGdlbmVyYXRlIGEgY2VudGVyIHZlcnRleCBwZXIgZmFjZS9zZWdtZW50XG5cblx0XHRcdFx0Zm9yIChsZXQgeCA9IDE7IHggPD0gcmFkaWFsU2VnbWVudHM7IHgrKykge1xuXHRcdFx0XHRcdC8vIHZlcnRleFxuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goMCwgaGFsZkhlaWdodCAqIHNpZ24sIDApOyAvLyBub3JtYWxcblxuXHRcdFx0XHRcdG5vcm1hbHMucHVzaCgwLCBzaWduLCAwKTsgLy8gdXZcblxuXHRcdFx0XHRcdHV2cy5wdXNoKDAuNSwgMC41KTsgLy8gaW5jcmVhc2UgaW5kZXhcblxuXHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdH0gLy8gc2F2ZSB0aGUgaW5kZXggb2YgdGhlIGxhc3QgY2VudGVyIHZlcnRleFxuXG5cblx0XHRcdFx0Y29uc3QgY2VudGVySW5kZXhFbmQgPSBpbmRleDsgLy8gbm93IHdlIGdlbmVyYXRlIHRoZSBzdXJyb3VuZGluZyB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0XHRcdFx0Zm9yIChsZXQgeCA9IDA7IHggPD0gcmFkaWFsU2VnbWVudHM7IHgrKykge1xuXHRcdFx0XHRcdGNvbnN0IHUgPSB4IC8gcmFkaWFsU2VnbWVudHM7XG5cdFx0XHRcdFx0Y29uc3QgdGhldGEgPSB1ICogdGhldGFMZW5ndGggKyB0aGV0YVN0YXJ0O1xuXHRcdFx0XHRcdGNvbnN0IGNvc1RoZXRhID0gTWF0aC5jb3ModGhldGEpO1xuXHRcdFx0XHRcdGNvbnN0IHNpblRoZXRhID0gTWF0aC5zaW4odGhldGEpOyAvLyB2ZXJ0ZXhcblxuXHRcdFx0XHRcdHZlcnRleC54ID0gcmFkaXVzICogc2luVGhldGE7XG5cdFx0XHRcdFx0dmVydGV4LnkgPSBoYWxmSGVpZ2h0ICogc2lnbjtcblx0XHRcdFx0XHR2ZXJ0ZXgueiA9IHJhZGl1cyAqIGNvc1RoZXRhO1xuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2godmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueik7IC8vIG5vcm1hbFxuXG5cdFx0XHRcdFx0bm9ybWFscy5wdXNoKDAsIHNpZ24sIDApOyAvLyB1dlxuXG5cdFx0XHRcdFx0dXYueCA9IGNvc1RoZXRhICogMC41ICsgMC41O1xuXHRcdFx0XHRcdHV2LnkgPSBzaW5UaGV0YSAqIDAuNSAqIHNpZ24gKyAwLjU7XG5cdFx0XHRcdFx0dXZzLnB1c2godXYueCwgdXYueSk7IC8vIGluY3JlYXNlIGluZGV4XG5cblx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHR9IC8vIGdlbmVyYXRlIGluZGljZXNcblxuXG5cdFx0XHRcdGZvciAobGV0IHggPSAwOyB4IDwgcmFkaWFsU2VnbWVudHM7IHgrKykge1xuXHRcdFx0XHRcdGNvbnN0IGMgPSBjZW50ZXJJbmRleFN0YXJ0ICsgeDtcblx0XHRcdFx0XHRjb25zdCBpID0gY2VudGVySW5kZXhFbmQgKyB4O1xuXG5cdFx0XHRcdFx0aWYgKHRvcCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0Ly8gZmFjZSB0b3Bcblx0XHRcdFx0XHRcdGluZGljZXMucHVzaChpLCBpICsgMSwgYyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIGZhY2UgYm90dG9tXG5cdFx0XHRcdFx0XHRpbmRpY2VzLnB1c2goaSArIDEsIGksIGMpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGdyb3VwQ291bnQgKz0gMztcblx0XHRcdFx0fSAvLyBhZGQgYSBncm91cCB0byB0aGUgZ2VvbWV0cnkuIHRoaXMgd2lsbCBlbnN1cmUgbXVsdGkgbWF0ZXJpYWwgc3VwcG9ydFxuXG5cblx0XHRcdFx0c2NvcGUuYWRkR3JvdXAoZ3JvdXBTdGFydCwgZ3JvdXBDb3VudCwgdG9wID09PSB0cnVlID8gMSA6IDIpOyAvLyBjYWxjdWxhdGUgbmV3IHN0YXJ0IHZhbHVlIGZvciBncm91cHNcblxuXHRcdFx0XHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c3RhdGljIGZyb21KU09OKGRhdGEpIHtcblx0XHRcdHJldHVybiBuZXcgQ3lsaW5kZXJHZW9tZXRyeShkYXRhLnJhZGl1c1RvcCwgZGF0YS5yYWRpdXNCb3R0b20sIGRhdGEuaGVpZ2h0LCBkYXRhLnJhZGlhbFNlZ21lbnRzLCBkYXRhLmhlaWdodFNlZ21lbnRzLCBkYXRhLm9wZW5FbmRlZCwgZGF0YS50aGV0YVN0YXJ0LCBkYXRhLnRoZXRhTGVuZ3RoKTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIENvbmVHZW9tZXRyeSBleHRlbmRzIEN5bGluZGVyR2VvbWV0cnkge1xuXHRcdGNvbnN0cnVjdG9yKHJhZGl1cyA9IDEsIGhlaWdodCA9IDEsIHJhZGlhbFNlZ21lbnRzID0gOCwgaGVpZ2h0U2VnbWVudHMgPSAxLCBvcGVuRW5kZWQgPSBmYWxzZSwgdGhldGFTdGFydCA9IDAsIHRoZXRhTGVuZ3RoID0gTWF0aC5QSSAqIDIpIHtcblx0XHRcdHN1cGVyKDAsIHJhZGl1cywgaGVpZ2h0LCByYWRpYWxTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGgpO1xuXHRcdFx0dGhpcy50eXBlID0gJ0NvbmVHZW9tZXRyeSc7XG5cdFx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG5cdFx0XHRcdG9wZW5FbmRlZDogb3BlbkVuZGVkLFxuXHRcdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0c3RhdGljIGZyb21KU09OKGRhdGEpIHtcblx0XHRcdHJldHVybiBuZXcgQ29uZUdlb21ldHJ5KGRhdGEucmFkaXVzLCBkYXRhLmhlaWdodCwgZGF0YS5yYWRpYWxTZWdtZW50cywgZGF0YS5oZWlnaHRTZWdtZW50cywgZGF0YS5vcGVuRW5kZWQsIGRhdGEudGhldGFTdGFydCwgZGF0YS50aGV0YUxlbmd0aCk7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBQb2x5aGVkcm9uR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cdFx0Y29uc3RydWN0b3IodmVydGljZXMgPSBbXSwgaW5kaWNlcyA9IFtdLCByYWRpdXMgPSAxLCBkZXRhaWwgPSAwKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ1BvbHloZWRyb25HZW9tZXRyeSc7XG5cdFx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRcdHZlcnRpY2VzOiB2ZXJ0aWNlcyxcblx0XHRcdFx0aW5kaWNlczogaW5kaWNlcyxcblx0XHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRcdGRldGFpbDogZGV0YWlsXG5cdFx0XHR9OyAvLyBkZWZhdWx0IGJ1ZmZlciBkYXRhXG5cblx0XHRcdGNvbnN0IHZlcnRleEJ1ZmZlciA9IFtdO1xuXHRcdFx0Y29uc3QgdXZCdWZmZXIgPSBbXTsgLy8gdGhlIHN1YmRpdmlzaW9uIGNyZWF0ZXMgdGhlIHZlcnRleCBidWZmZXIgZGF0YVxuXG5cdFx0XHRzdWJkaXZpZGUoZGV0YWlsKTsgLy8gYWxsIHZlcnRpY2VzIHNob3VsZCBsaWUgb24gYSBjb25jZXB0dWFsIHNwaGVyZSB3aXRoIGEgZ2l2ZW4gcmFkaXVzXG5cblx0XHRcdGFwcGx5UmFkaXVzKHJhZGl1cyk7IC8vIGZpbmFsbHksIGNyZWF0ZSB0aGUgdXYgZGF0YVxuXG5cdFx0XHRnZW5lcmF0ZVVWcygpOyAvLyBidWlsZCBub24taW5kZXhlZCBnZW9tZXRyeVxuXG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0ZXhCdWZmZXIsIDMpKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0ZXhCdWZmZXIuc2xpY2UoKSwgMykpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodXZCdWZmZXIsIDIpKTtcblxuXHRcdFx0aWYgKGRldGFpbCA9PT0gMCkge1xuXHRcdFx0XHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7IC8vIGZsYXQgbm9ybWFsc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5ub3JtYWxpemVOb3JtYWxzKCk7IC8vIHNtb290aCBub3JtYWxzXG5cdFx0XHR9IC8vIGhlbHBlciBmdW5jdGlvbnNcblxuXG5cdFx0XHRmdW5jdGlvbiBzdWJkaXZpZGUoZGV0YWlsKSB7XG5cdFx0XHRcdGNvbnN0IGEgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHRjb25zdCBiID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0Y29uc3QgYyA9IG5ldyBWZWN0b3IzKCk7IC8vIGl0ZXJhdGUgb3ZlciBhbGwgZmFjZXMgYW5kIGFwcGx5IGEgc3ViZGl2aXNvbiB3aXRoIHRoZSBnaXZlbiBkZXRhaWwgdmFsdWVcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdFx0XHQvLyBnZXQgdGhlIHZlcnRpY2VzIG9mIHRoZSBmYWNlXG5cdFx0XHRcdFx0Z2V0VmVydGV4QnlJbmRleChpbmRpY2VzW2kgKyAwXSwgYSk7XG5cdFx0XHRcdFx0Z2V0VmVydGV4QnlJbmRleChpbmRpY2VzW2kgKyAxXSwgYik7XG5cdFx0XHRcdFx0Z2V0VmVydGV4QnlJbmRleChpbmRpY2VzW2kgKyAyXSwgYyk7IC8vIHBlcmZvcm0gc3ViZGl2aXNpb25cblxuXHRcdFx0XHRcdHN1YmRpdmlkZUZhY2UoYSwgYiwgYywgZGV0YWlsKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBzdWJkaXZpZGVGYWNlKGEsIGIsIGMsIGRldGFpbCkge1xuXHRcdFx0XHRjb25zdCBjb2xzID0gZGV0YWlsICsgMTsgLy8gd2UgdXNlIHRoaXMgbXVsdGlkaW1lbnNpb25hbCBhcnJheSBhcyBhIGRhdGEgc3RydWN0dXJlIGZvciBjcmVhdGluZyB0aGUgc3ViZGl2aXNpb25cblxuXHRcdFx0XHRjb25zdCB2ID0gW107IC8vIGNvbnN0cnVjdCBhbGwgb2YgdGhlIHZlcnRpY2VzIGZvciB0aGlzIHN1YmRpdmlzaW9uXG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPD0gY29sczsgaSsrKSB7XG5cdFx0XHRcdFx0dltpXSA9IFtdO1xuXHRcdFx0XHRcdGNvbnN0IGFqID0gYS5jbG9uZSgpLmxlcnAoYywgaSAvIGNvbHMpO1xuXHRcdFx0XHRcdGNvbnN0IGJqID0gYi5jbG9uZSgpLmxlcnAoYywgaSAvIGNvbHMpO1xuXHRcdFx0XHRcdGNvbnN0IHJvd3MgPSBjb2xzIC0gaTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDw9IHJvd3M7IGorKykge1xuXHRcdFx0XHRcdFx0aWYgKGogPT09IDAgJiYgaSA9PT0gY29scykge1xuXHRcdFx0XHRcdFx0XHR2W2ldW2pdID0gYWo7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2W2ldW2pdID0gYWouY2xvbmUoKS5sZXJwKGJqLCBqIC8gcm93cyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IC8vIGNvbnN0cnVjdCBhbGwgb2YgdGhlIGZhY2VzXG5cblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNvbHM7IGkrKykge1xuXHRcdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgMiAqIChjb2xzIC0gaSkgLSAxOyBqKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IGsgPSBNYXRoLmZsb29yKGogLyAyKTtcblxuXHRcdFx0XHRcdFx0aWYgKGogJSAyID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdHB1c2hWZXJ0ZXgodltpXVtrICsgMV0pO1xuXHRcdFx0XHRcdFx0XHRwdXNoVmVydGV4KHZbaSArIDFdW2tdKTtcblx0XHRcdFx0XHRcdFx0cHVzaFZlcnRleCh2W2ldW2tdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHB1c2hWZXJ0ZXgodltpXVtrICsgMV0pO1xuXHRcdFx0XHRcdFx0XHRwdXNoVmVydGV4KHZbaSArIDFdW2sgKyAxXSk7XG5cdFx0XHRcdFx0XHRcdHB1c2hWZXJ0ZXgodltpICsgMV1ba10pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBhcHBseVJhZGl1cyhyYWRpdXMpIHtcblx0XHRcdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTsgLy8gaXRlcmF0ZSBvdmVyIHRoZSBlbnRpcmUgYnVmZmVyIGFuZCBhcHBseSB0aGUgcmFkaXVzIHRvIGVhY2ggdmVydGV4XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0ZXhCdWZmZXIubGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdFx0XHR2ZXJ0ZXgueCA9IHZlcnRleEJ1ZmZlcltpICsgMF07XG5cdFx0XHRcdFx0dmVydGV4LnkgPSB2ZXJ0ZXhCdWZmZXJbaSArIDFdO1xuXHRcdFx0XHRcdHZlcnRleC56ID0gdmVydGV4QnVmZmVyW2kgKyAyXTtcblx0XHRcdFx0XHR2ZXJ0ZXgubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIocmFkaXVzKTtcblx0XHRcdFx0XHR2ZXJ0ZXhCdWZmZXJbaSArIDBdID0gdmVydGV4Lng7XG5cdFx0XHRcdFx0dmVydGV4QnVmZmVyW2kgKyAxXSA9IHZlcnRleC55O1xuXHRcdFx0XHRcdHZlcnRleEJ1ZmZlcltpICsgMl0gPSB2ZXJ0ZXguejtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBnZW5lcmF0ZVVWcygpIHtcblx0XHRcdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRleEJ1ZmZlci5sZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0XHRcdHZlcnRleC54ID0gdmVydGV4QnVmZmVyW2kgKyAwXTtcblx0XHRcdFx0XHR2ZXJ0ZXgueSA9IHZlcnRleEJ1ZmZlcltpICsgMV07XG5cdFx0XHRcdFx0dmVydGV4LnogPSB2ZXJ0ZXhCdWZmZXJbaSArIDJdO1xuXHRcdFx0XHRcdGNvbnN0IHUgPSBhemltdXRoKHZlcnRleCkgLyAyIC8gTWF0aC5QSSArIDAuNTtcblx0XHRcdFx0XHRjb25zdCB2ID0gaW5jbGluYXRpb24odmVydGV4KSAvIE1hdGguUEkgKyAwLjU7XG5cdFx0XHRcdFx0dXZCdWZmZXIucHVzaCh1LCAxIC0gdik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb3JyZWN0VVZzKCk7XG5cdFx0XHRcdGNvcnJlY3RTZWFtKCk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGNvcnJlY3RTZWFtKCkge1xuXHRcdFx0XHQvLyBoYW5kbGUgY2FzZSB3aGVuIGZhY2Ugc3RyYWRkbGVzIHRoZSBzZWFtLCBzZWUgIzMyNjlcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB1dkJ1ZmZlci5sZW5ndGg7IGkgKz0gNikge1xuXHRcdFx0XHRcdC8vIHV2IGRhdGEgb2YgYSBzaW5nbGUgZmFjZVxuXHRcdFx0XHRcdGNvbnN0IHgwID0gdXZCdWZmZXJbaSArIDBdO1xuXHRcdFx0XHRcdGNvbnN0IHgxID0gdXZCdWZmZXJbaSArIDJdO1xuXHRcdFx0XHRcdGNvbnN0IHgyID0gdXZCdWZmZXJbaSArIDRdO1xuXHRcdFx0XHRcdGNvbnN0IG1heCA9IE1hdGgubWF4KHgwLCB4MSwgeDIpO1xuXHRcdFx0XHRcdGNvbnN0IG1pbiA9IE1hdGgubWluKHgwLCB4MSwgeDIpOyAvLyAwLjkgaXMgc29tZXdoYXQgYXJiaXRyYXJ5XG5cblx0XHRcdFx0XHRpZiAobWF4ID4gMC45ICYmIG1pbiA8IDAuMSkge1xuXHRcdFx0XHRcdFx0aWYgKHgwIDwgMC4yKSB1dkJ1ZmZlcltpICsgMF0gKz0gMTtcblx0XHRcdFx0XHRcdGlmICh4MSA8IDAuMikgdXZCdWZmZXJbaSArIDJdICs9IDE7XG5cdFx0XHRcdFx0XHRpZiAoeDIgPCAwLjIpIHV2QnVmZmVyW2kgKyA0XSArPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBwdXNoVmVydGV4KHZlcnRleCkge1xuXHRcdFx0XHR2ZXJ0ZXhCdWZmZXIucHVzaCh2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56KTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZ2V0VmVydGV4QnlJbmRleChpbmRleCwgdmVydGV4KSB7XG5cdFx0XHRcdGNvbnN0IHN0cmlkZSA9IGluZGV4ICogMztcblx0XHRcdFx0dmVydGV4LnggPSB2ZXJ0aWNlc1tzdHJpZGUgKyAwXTtcblx0XHRcdFx0dmVydGV4LnkgPSB2ZXJ0aWNlc1tzdHJpZGUgKyAxXTtcblx0XHRcdFx0dmVydGV4LnogPSB2ZXJ0aWNlc1tzdHJpZGUgKyAyXTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gY29ycmVjdFVWcygpIHtcblx0XHRcdFx0Y29uc3QgYSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdGNvbnN0IGIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHRjb25zdCBjID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0Y29uc3QgY2VudHJvaWQgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHRjb25zdCB1dkEgPSBuZXcgVmVjdG9yMigpO1xuXHRcdFx0XHRjb25zdCB1dkIgPSBuZXcgVmVjdG9yMigpO1xuXHRcdFx0XHRjb25zdCB1dkMgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHZlcnRleEJ1ZmZlci5sZW5ndGg7IGkgKz0gOSwgaiArPSA2KSB7XG5cdFx0XHRcdFx0YS5zZXQodmVydGV4QnVmZmVyW2kgKyAwXSwgdmVydGV4QnVmZmVyW2kgKyAxXSwgdmVydGV4QnVmZmVyW2kgKyAyXSk7XG5cdFx0XHRcdFx0Yi5zZXQodmVydGV4QnVmZmVyW2kgKyAzXSwgdmVydGV4QnVmZmVyW2kgKyA0XSwgdmVydGV4QnVmZmVyW2kgKyA1XSk7XG5cdFx0XHRcdFx0Yy5zZXQodmVydGV4QnVmZmVyW2kgKyA2XSwgdmVydGV4QnVmZmVyW2kgKyA3XSwgdmVydGV4QnVmZmVyW2kgKyA4XSk7XG5cdFx0XHRcdFx0dXZBLnNldCh1dkJ1ZmZlcltqICsgMF0sIHV2QnVmZmVyW2ogKyAxXSk7XG5cdFx0XHRcdFx0dXZCLnNldCh1dkJ1ZmZlcltqICsgMl0sIHV2QnVmZmVyW2ogKyAzXSk7XG5cdFx0XHRcdFx0dXZDLnNldCh1dkJ1ZmZlcltqICsgNF0sIHV2QnVmZmVyW2ogKyA1XSk7XG5cdFx0XHRcdFx0Y2VudHJvaWQuY29weShhKS5hZGQoYikuYWRkKGMpLmRpdmlkZVNjYWxhcigzKTtcblx0XHRcdFx0XHRjb25zdCBhemkgPSBhemltdXRoKGNlbnRyb2lkKTtcblx0XHRcdFx0XHRjb3JyZWN0VVYodXZBLCBqICsgMCwgYSwgYXppKTtcblx0XHRcdFx0XHRjb3JyZWN0VVYodXZCLCBqICsgMiwgYiwgYXppKTtcblx0XHRcdFx0XHRjb3JyZWN0VVYodXZDLCBqICsgNCwgYywgYXppKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBjb3JyZWN0VVYodXYsIHN0cmlkZSwgdmVjdG9yLCBhemltdXRoKSB7XG5cdFx0XHRcdGlmIChhemltdXRoIDwgMCAmJiB1di54ID09PSAxKSB7XG5cdFx0XHRcdFx0dXZCdWZmZXJbc3RyaWRlXSA9IHV2LnggLSAxO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHZlY3Rvci54ID09PSAwICYmIHZlY3Rvci56ID09PSAwKSB7XG5cdFx0XHRcdFx0dXZCdWZmZXJbc3RyaWRlXSA9IGF6aW11dGggLyAyIC8gTWF0aC5QSSArIDAuNTtcblx0XHRcdFx0fVxuXHRcdFx0fSAvLyBBbmdsZSBhcm91bmQgdGhlIFkgYXhpcywgY291bnRlci1jbG9ja3dpc2Ugd2hlbiBsb29raW5nIGZyb20gYWJvdmUuXG5cblxuXHRcdFx0ZnVuY3Rpb24gYXppbXV0aCh2ZWN0b3IpIHtcblx0XHRcdFx0cmV0dXJuIE1hdGguYXRhbjIodmVjdG9yLnosIC12ZWN0b3IueCk7XG5cdFx0XHR9IC8vIEFuZ2xlIGFib3ZlIHRoZSBYWiBwbGFuZS5cblxuXG5cdFx0XHRmdW5jdGlvbiBpbmNsaW5hdGlvbih2ZWN0b3IpIHtcblx0XHRcdFx0cmV0dXJuIE1hdGguYXRhbjIoLXZlY3Rvci55LCBNYXRoLnNxcnQodmVjdG9yLnggKiB2ZWN0b3IueCArIHZlY3Rvci56ICogdmVjdG9yLnopKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzdGF0aWMgZnJvbUpTT04oZGF0YSkge1xuXHRcdFx0cmV0dXJuIG5ldyBQb2x5aGVkcm9uR2VvbWV0cnkoZGF0YS52ZXJ0aWNlcywgZGF0YS5pbmRpY2VzLCBkYXRhLnJhZGl1cywgZGF0YS5kZXRhaWxzKTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIERvZGVjYWhlZHJvbkdlb21ldHJ5IGV4dGVuZHMgUG9seWhlZHJvbkdlb21ldHJ5IHtcblx0XHRjb25zdHJ1Y3RvcihyYWRpdXMgPSAxLCBkZXRhaWwgPSAwKSB7XG5cdFx0XHRjb25zdCB0ID0gKDEgKyBNYXRoLnNxcnQoNSkpIC8gMjtcblx0XHRcdGNvbnN0IHIgPSAxIC8gdDtcblx0XHRcdGNvbnN0IHZlcnRpY2VzID0gWy8vICjCsTEsIMKxMSwgwrExKVxuXHRcdFx0LTEsIC0xLCAtMSwgLTEsIC0xLCAxLCAtMSwgMSwgLTEsIC0xLCAxLCAxLCAxLCAtMSwgLTEsIDEsIC0xLCAxLCAxLCAxLCAtMSwgMSwgMSwgMSwgLy8gKDAsIMKxMS/PhiwgwrHPhilcblx0XHRcdDAsIC1yLCAtdCwgMCwgLXIsIHQsIDAsIHIsIC10LCAwLCByLCB0LCAvLyAowrExL8+GLCDCsc+GLCAwKVxuXHRcdFx0LXIsIC10LCAwLCAtciwgdCwgMCwgciwgLXQsIDAsIHIsIHQsIDAsIC8vICjCsc+GLCAwLCDCsTEvz4YpXG5cdFx0XHQtdCwgMCwgLXIsIHQsIDAsIC1yLCAtdCwgMCwgciwgdCwgMCwgcl07XG5cdFx0XHRjb25zdCBpbmRpY2VzID0gWzMsIDExLCA3LCAzLCA3LCAxNSwgMywgMTUsIDEzLCA3LCAxOSwgMTcsIDcsIDE3LCA2LCA3LCA2LCAxNSwgMTcsIDQsIDgsIDE3LCA4LCAxMCwgMTcsIDEwLCA2LCA4LCAwLCAxNiwgOCwgMTYsIDIsIDgsIDIsIDEwLCAwLCAxMiwgMSwgMCwgMSwgMTgsIDAsIDE4LCAxNiwgNiwgMTAsIDIsIDYsIDIsIDEzLCA2LCAxMywgMTUsIDIsIDE2LCAxOCwgMiwgMTgsIDMsIDIsIDMsIDEzLCAxOCwgMSwgOSwgMTgsIDksIDExLCAxOCwgMTEsIDMsIDQsIDE0LCAxMiwgNCwgMTIsIDAsIDQsIDAsIDgsIDExLCA5LCA1LCAxMSwgNSwgMTksIDExLCAxOSwgNywgMTksIDUsIDE0LCAxOSwgMTQsIDQsIDE5LCA0LCAxNywgMSwgMTIsIDE0LCAxLCAxNCwgNSwgMSwgNSwgOV07XG5cdFx0XHRzdXBlcih2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwpO1xuXHRcdFx0dGhpcy50eXBlID0gJ0RvZGVjYWhlZHJvbkdlb21ldHJ5Jztcblx0XHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRcdGRldGFpbDogZGV0YWlsXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHN0YXRpYyBmcm9tSlNPTihkYXRhKSB7XG5cdFx0XHRyZXR1cm4gbmV3IERvZGVjYWhlZHJvbkdlb21ldHJ5KGRhdGEucmFkaXVzLCBkYXRhLmRldGFpbCk7XG5cdFx0fVxuXG5cdH1cblxuXHRjb25zdCBfdjAgPSBuZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF92MSQxID0gbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfdHJpYW5nbGUgPSBuZXcgVHJpYW5nbGUoKTtcblxuXHRjbGFzcyBFZGdlc0dlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXHRcdGNvbnN0cnVjdG9yKGdlb21ldHJ5ID0gbnVsbCwgdGhyZXNob2xkQW5nbGUgPSAxKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ0VkZ2VzR2VvbWV0cnknO1xuXHRcdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnksXG5cdFx0XHRcdHRocmVzaG9sZEFuZ2xlOiB0aHJlc2hvbGRBbmdsZVxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKGdlb21ldHJ5ICE9PSBudWxsKSB7XG5cdFx0XHRcdGNvbnN0IHByZWNpc2lvblBvaW50cyA9IDQ7XG5cdFx0XHRcdGNvbnN0IHByZWNpc2lvbiA9IE1hdGgucG93KDEwLCBwcmVjaXNpb25Qb2ludHMpO1xuXHRcdFx0XHRjb25zdCB0aHJlc2hvbGREb3QgPSBNYXRoLmNvcyhERUcyUkFEICogdGhyZXNob2xkQW5nbGUpO1xuXHRcdFx0XHRjb25zdCBpbmRleEF0dHIgPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuXHRcdFx0XHRjb25zdCBwb3NpdGlvbkF0dHIgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XG5cdFx0XHRcdGNvbnN0IGluZGV4Q291bnQgPSBpbmRleEF0dHIgPyBpbmRleEF0dHIuY291bnQgOiBwb3NpdGlvbkF0dHIuY291bnQ7XG5cdFx0XHRcdGNvbnN0IGluZGV4QXJyID0gWzAsIDAsIDBdO1xuXHRcdFx0XHRjb25zdCB2ZXJ0S2V5cyA9IFsnYScsICdiJywgJ2MnXTtcblx0XHRcdFx0Y29uc3QgaGFzaGVzID0gbmV3IEFycmF5KDMpO1xuXHRcdFx0XHRjb25zdCBlZGdlRGF0YSA9IHt9O1xuXHRcdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXhDb3VudDsgaSArPSAzKSB7XG5cdFx0XHRcdFx0aWYgKGluZGV4QXR0cikge1xuXHRcdFx0XHRcdFx0aW5kZXhBcnJbMF0gPSBpbmRleEF0dHIuZ2V0WChpKTtcblx0XHRcdFx0XHRcdGluZGV4QXJyWzFdID0gaW5kZXhBdHRyLmdldFgoaSArIDEpO1xuXHRcdFx0XHRcdFx0aW5kZXhBcnJbMl0gPSBpbmRleEF0dHIuZ2V0WChpICsgMik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGluZGV4QXJyWzBdID0gaTtcblx0XHRcdFx0XHRcdGluZGV4QXJyWzFdID0gaSArIDE7XG5cdFx0XHRcdFx0XHRpbmRleEFyclsyXSA9IGkgKyAyO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IHtcblx0XHRcdFx0XHRcdGEsXG5cdFx0XHRcdFx0XHRiLFxuXHRcdFx0XHRcdFx0Y1xuXHRcdFx0XHRcdH0gPSBfdHJpYW5nbGU7XG5cdFx0XHRcdFx0YS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0ciwgaW5kZXhBcnJbMF0pO1xuXHRcdFx0XHRcdGIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbkF0dHIsIGluZGV4QXJyWzFdKTtcblx0XHRcdFx0XHRjLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyLCBpbmRleEFyclsyXSk7XG5cblx0XHRcdFx0XHRfdHJpYW5nbGUuZ2V0Tm9ybWFsKF9ub3JtYWwpOyAvLyBjcmVhdGUgaGFzaGVzIGZvciB0aGUgZWRnZSBmcm9tIHRoZSB2ZXJ0aWNlc1xuXG5cblx0XHRcdFx0XHRoYXNoZXNbMF0gPSBgJHtNYXRoLnJvdW5kKGEueCAqIHByZWNpc2lvbil9LCR7TWF0aC5yb3VuZChhLnkgKiBwcmVjaXNpb24pfSwke01hdGgucm91bmQoYS56ICogcHJlY2lzaW9uKX1gO1xuXHRcdFx0XHRcdGhhc2hlc1sxXSA9IGAke01hdGgucm91bmQoYi54ICogcHJlY2lzaW9uKX0sJHtNYXRoLnJvdW5kKGIueSAqIHByZWNpc2lvbil9LCR7TWF0aC5yb3VuZChiLnogKiBwcmVjaXNpb24pfWA7XG5cdFx0XHRcdFx0aGFzaGVzWzJdID0gYCR7TWF0aC5yb3VuZChjLnggKiBwcmVjaXNpb24pfSwke01hdGgucm91bmQoYy55ICogcHJlY2lzaW9uKX0sJHtNYXRoLnJvdW5kKGMueiAqIHByZWNpc2lvbil9YDsgLy8gc2tpcCBkZWdlbmVyYXRlIHRyaWFuZ2xlc1xuXG5cdFx0XHRcdFx0aWYgKGhhc2hlc1swXSA9PT0gaGFzaGVzWzFdIHx8IGhhc2hlc1sxXSA9PT0gaGFzaGVzWzJdIHx8IGhhc2hlc1syXSA9PT0gaGFzaGVzWzBdKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9IC8vIGl0ZXJhdGUgb3ZlciBldmVyeSBlZGdlXG5cblxuXHRcdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgMzsgaisrKSB7XG5cdFx0XHRcdFx0XHQvLyBnZXQgdGhlIGZpcnN0IGFuZCBuZXh0IHZlcnRleCBtYWtpbmcgdXAgdGhlIGVkZ2Vcblx0XHRcdFx0XHRcdGNvbnN0IGpOZXh0ID0gKGogKyAxKSAlIDM7XG5cdFx0XHRcdFx0XHRjb25zdCB2ZWNIYXNoMCA9IGhhc2hlc1tqXTtcblx0XHRcdFx0XHRcdGNvbnN0IHZlY0hhc2gxID0gaGFzaGVzW2pOZXh0XTtcblx0XHRcdFx0XHRcdGNvbnN0IHYwID0gX3RyaWFuZ2xlW3ZlcnRLZXlzW2pdXTtcblx0XHRcdFx0XHRcdGNvbnN0IHYxID0gX3RyaWFuZ2xlW3ZlcnRLZXlzW2pOZXh0XV07XG5cdFx0XHRcdFx0XHRjb25zdCBoYXNoID0gYCR7dmVjSGFzaDB9XyR7dmVjSGFzaDF9YDtcblx0XHRcdFx0XHRcdGNvbnN0IHJldmVyc2VIYXNoID0gYCR7dmVjSGFzaDF9XyR7dmVjSGFzaDB9YDtcblxuXHRcdFx0XHRcdFx0aWYgKHJldmVyc2VIYXNoIGluIGVkZ2VEYXRhICYmIGVkZ2VEYXRhW3JldmVyc2VIYXNoXSkge1xuXHRcdFx0XHRcdFx0XHQvLyBpZiB3ZSBmb3VuZCBhIHNpYmxpbmcgZWRnZSBhZGQgaXQgaW50byB0aGUgdmVydGV4IGFycmF5IGlmXG5cdFx0XHRcdFx0XHRcdC8vIGl0IG1lZXRzIHRoZSBhbmdsZSB0aHJlc2hvbGQgYW5kIGRlbGV0ZSB0aGUgZWRnZSBmcm9tIHRoZSBtYXAuXG5cdFx0XHRcdFx0XHRcdGlmIChfbm9ybWFsLmRvdChlZGdlRGF0YVtyZXZlcnNlSGFzaF0ubm9ybWFsKSA8PSB0aHJlc2hvbGREb3QpIHtcblx0XHRcdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKHYwLngsIHYwLnksIHYwLnopO1xuXHRcdFx0XHRcdFx0XHRcdHZlcnRpY2VzLnB1c2godjEueCwgdjEueSwgdjEueik7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRlZGdlRGF0YVtyZXZlcnNlSGFzaF0gPSBudWxsO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICghKGhhc2ggaW4gZWRnZURhdGEpKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGlmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGVkZ2UgaGVyZSB0aGVuIHNraXAgYWRkaW5nIGEgbmV3IG9uZVxuXHRcdFx0XHRcdFx0XHRlZGdlRGF0YVtoYXNoXSA9IHtcblx0XHRcdFx0XHRcdFx0XHRpbmRleDA6IGluZGV4QXJyW2pdLFxuXHRcdFx0XHRcdFx0XHRcdGluZGV4MTogaW5kZXhBcnJbak5leHRdLFxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbDogX25vcm1hbC5jbG9uZSgpXG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IC8vIGl0ZXJhdGUgb3ZlciBhbGwgcmVtYWluaW5nLCB1bm1hdGNoZWQgZWRnZXMgYW5kIGFkZCB0aGVtIHRvIHRoZSB2ZXJ0ZXggYXJyYXlcblxuXG5cdFx0XHRcdGZvciAoY29uc3Qga2V5IGluIGVkZ2VEYXRhKSB7XG5cdFx0XHRcdFx0aWYgKGVkZ2VEYXRhW2tleV0pIHtcblx0XHRcdFx0XHRcdGNvbnN0IHtcblx0XHRcdFx0XHRcdFx0aW5kZXgwLFxuXHRcdFx0XHRcdFx0XHRpbmRleDFcblx0XHRcdFx0XHRcdH0gPSBlZGdlRGF0YVtrZXldO1xuXG5cdFx0XHRcdFx0XHRfdjAuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbkF0dHIsIGluZGV4MCk7XG5cblx0XHRcdFx0XHRcdF92MSQxLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyLCBpbmRleDEpO1xuXG5cdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKF92MC54LCBfdjAueSwgX3YwLnopO1xuXHRcdFx0XHRcdFx0dmVydGljZXMucHVzaChfdjEkMS54LCBfdjEkMS55LCBfdjEkMS56KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0aWNlcywgMykpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIEV4dGVuc2libGUgY3VydmUgb2JqZWN0LlxuXHQgKlxuXHQgKiBTb21lIGNvbW1vbiBvZiBjdXJ2ZSBtZXRob2RzOlxuXHQgKiAuZ2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ICksIC5nZXRUYW5nZW50KCB0LCBvcHRpb25hbFRhcmdldCApXG5cdCAqIC5nZXRQb2ludEF0KCB1LCBvcHRpb25hbFRhcmdldCApLCAuZ2V0VGFuZ2VudEF0KCB1LCBvcHRpb25hbFRhcmdldCApXG5cdCAqIC5nZXRQb2ludHMoKSwgLmdldFNwYWNlZFBvaW50cygpXG5cdCAqIC5nZXRMZW5ndGgoKVxuXHQgKiAudXBkYXRlQXJjTGVuZ3RocygpXG5cdCAqXG5cdCAqIFRoaXMgZm9sbG93aW5nIGN1cnZlcyBpbmhlcml0IGZyb20gVEhSRUUuQ3VydmU6XG5cdCAqXG5cdCAqIC0tIDJEIGN1cnZlcyAtLVxuXHQgKiBUSFJFRS5BcmNDdXJ2ZVxuXHQgKiBUSFJFRS5DdWJpY0JlemllckN1cnZlXG5cdCAqIFRIUkVFLkVsbGlwc2VDdXJ2ZVxuXHQgKiBUSFJFRS5MaW5lQ3VydmVcblx0ICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmVcblx0ICogVEhSRUUuU3BsaW5lQ3VydmVcblx0ICpcblx0ICogLS0gM0QgY3VydmVzIC0tXG5cdCAqIFRIUkVFLkNhdG11bGxSb21DdXJ2ZTNcblx0ICogVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTNcblx0ICogVEhSRUUuTGluZUN1cnZlM1xuXHQgKiBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTNcblx0ICpcblx0ICogQSBzZXJpZXMgb2YgY3VydmVzIGNhbiBiZSByZXByZXNlbnRlZCBhcyBhIFRIUkVFLkN1cnZlUGF0aC5cblx0ICpcblx0ICoqL1xuXG5cdGNsYXNzIEN1cnZlIHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHRoaXMudHlwZSA9ICdDdXJ2ZSc7XG5cdFx0XHR0aGlzLmFyY0xlbmd0aERpdmlzaW9ucyA9IDIwMDtcblx0XHR9IC8vIFZpcnR1YWwgYmFzZSBjbGFzcyBtZXRob2QgdG8gb3ZlcndyaXRlIGFuZCBpbXBsZW1lbnQgaW4gc3ViY2xhc3Nlc1xuXHRcdC8vXHQtIHQgWzAgLi4gMV1cblxuXG5cdFx0Z2V0UG9pbnQoKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkN1cnZlOiAuZ2V0UG9pbnQoKSBub3QgaW1wbGVtZW50ZWQuJyk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9IC8vIEdldCBwb2ludCBhdCByZWxhdGl2ZSBwb3NpdGlvbiBpbiBjdXJ2ZSBhY2NvcmRpbmcgdG8gYXJjIGxlbmd0aFxuXHRcdC8vIC0gdSBbMCAuLiAxXVxuXG5cblx0XHRnZXRQb2ludEF0KHUsIG9wdGlvbmFsVGFyZ2V0KSB7XG5cdFx0XHRjb25zdCB0ID0gdGhpcy5nZXRVdG9UbWFwcGluZyh1KTtcblx0XHRcdHJldHVybiB0aGlzLmdldFBvaW50KHQsIG9wdGlvbmFsVGFyZ2V0KTtcblx0XHR9IC8vIEdldCBzZXF1ZW5jZSBvZiBwb2ludHMgdXNpbmcgZ2V0UG9pbnQoIHQgKVxuXG5cblx0XHRnZXRQb2ludHMoZGl2aXNpb25zID0gNSkge1xuXHRcdFx0Y29uc3QgcG9pbnRzID0gW107XG5cblx0XHRcdGZvciAobGV0IGQgPSAwOyBkIDw9IGRpdmlzaW9uczsgZCsrKSB7XG5cdFx0XHRcdHBvaW50cy5wdXNoKHRoaXMuZ2V0UG9pbnQoZCAvIGRpdmlzaW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcG9pbnRzO1xuXHRcdH0gLy8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludEF0KCB1IClcblxuXG5cdFx0Z2V0U3BhY2VkUG9pbnRzKGRpdmlzaW9ucyA9IDUpIHtcblx0XHRcdGNvbnN0IHBvaW50cyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQrKykge1xuXHRcdFx0XHRwb2ludHMucHVzaCh0aGlzLmdldFBvaW50QXQoZCAvIGRpdmlzaW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcG9pbnRzO1xuXHRcdH0gLy8gR2V0IHRvdGFsIGN1cnZlIGFyYyBsZW5ndGhcblxuXG5cdFx0Z2V0TGVuZ3RoKCkge1xuXHRcdFx0Y29uc3QgbGVuZ3RocyA9IHRoaXMuZ2V0TGVuZ3RocygpO1xuXHRcdFx0cmV0dXJuIGxlbmd0aHNbbGVuZ3Rocy5sZW5ndGggLSAxXTtcblx0XHR9IC8vIEdldCBsaXN0IG9mIGN1bXVsYXRpdmUgc2VnbWVudCBsZW5ndGhzXG5cblxuXHRcdGdldExlbmd0aHMoZGl2aXNpb25zID0gdGhpcy5hcmNMZW5ndGhEaXZpc2lvbnMpIHtcblx0XHRcdGlmICh0aGlzLmNhY2hlQXJjTGVuZ3RocyAmJiB0aGlzLmNhY2hlQXJjTGVuZ3Rocy5sZW5ndGggPT09IGRpdmlzaW9ucyArIDEgJiYgIXRoaXMubmVlZHNVcGRhdGUpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY2FjaGVBcmNMZW5ndGhzO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRjb25zdCBjYWNoZSA9IFtdO1xuXHRcdFx0bGV0IGN1cnJlbnQsXG5cdFx0XHRcdFx0bGFzdCA9IHRoaXMuZ2V0UG9pbnQoMCk7XG5cdFx0XHRsZXQgc3VtID0gMDtcblx0XHRcdGNhY2hlLnB1c2goMCk7XG5cblx0XHRcdGZvciAobGV0IHAgPSAxOyBwIDw9IGRpdmlzaW9uczsgcCsrKSB7XG5cdFx0XHRcdGN1cnJlbnQgPSB0aGlzLmdldFBvaW50KHAgLyBkaXZpc2lvbnMpO1xuXHRcdFx0XHRzdW0gKz0gY3VycmVudC5kaXN0YW5jZVRvKGxhc3QpO1xuXHRcdFx0XHRjYWNoZS5wdXNoKHN1bSk7XG5cdFx0XHRcdGxhc3QgPSBjdXJyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmNhY2hlQXJjTGVuZ3RocyA9IGNhY2hlO1xuXHRcdFx0cmV0dXJuIGNhY2hlOyAvLyB7IHN1bXM6IGNhY2hlLCBzdW06IHN1bSB9OyBTdW0gaXMgaW4gdGhlIGxhc3QgZWxlbWVudC5cblx0XHR9XG5cblx0XHR1cGRhdGVBcmNMZW5ndGhzKCkge1xuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHR0aGlzLmdldExlbmd0aHMoKTtcblx0XHR9IC8vIEdpdmVuIHUgKCAwIC4uIDEgKSwgZ2V0IGEgdCB0byBmaW5kIHAuIFRoaXMgZ2l2ZXMgeW91IHBvaW50cyB3aGljaCBhcmUgZXF1aWRpc3RhbnRcblxuXG5cdFx0Z2V0VXRvVG1hcHBpbmcodSwgZGlzdGFuY2UpIHtcblx0XHRcdGNvbnN0IGFyY0xlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcblx0XHRcdGxldCBpID0gMDtcblx0XHRcdGNvbnN0IGlsID0gYXJjTGVuZ3Rocy5sZW5ndGg7XG5cdFx0XHRsZXQgdGFyZ2V0QXJjTGVuZ3RoOyAvLyBUaGUgdGFyZ2V0ZWQgdSBkaXN0YW5jZSB2YWx1ZSB0byBnZXRcblxuXHRcdFx0aWYgKGRpc3RhbmNlKSB7XG5cdFx0XHRcdHRhcmdldEFyY0xlbmd0aCA9IGRpc3RhbmNlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGFyZ2V0QXJjTGVuZ3RoID0gdSAqIGFyY0xlbmd0aHNbaWwgLSAxXTtcblx0XHRcdH0gLy8gYmluYXJ5IHNlYXJjaCBmb3IgdGhlIGluZGV4IHdpdGggbGFyZ2VzdCB2YWx1ZSBzbWFsbGVyIHRoYW4gdGFyZ2V0IHUgZGlzdGFuY2VcblxuXG5cdFx0XHRsZXQgbG93ID0gMCxcblx0XHRcdFx0XHRoaWdoID0gaWwgLSAxLFxuXHRcdFx0XHRcdGNvbXBhcmlzb247XG5cblx0XHRcdHdoaWxlIChsb3cgPD0gaGlnaCkge1xuXHRcdFx0XHRpID0gTWF0aC5mbG9vcihsb3cgKyAoaGlnaCAtIGxvdykgLyAyKTsgLy8gbGVzcyBsaWtlbHkgdG8gb3ZlcmZsb3csIHRob3VnaCBwcm9iYWJseSBub3QgaXNzdWUgaGVyZSwgSlMgZG9lc24ndCByZWFsbHkgaGF2ZSBpbnRlZ2VycywgYWxsIG51bWJlcnMgYXJlIGZsb2F0c1xuXG5cdFx0XHRcdGNvbXBhcmlzb24gPSBhcmNMZW5ndGhzW2ldIC0gdGFyZ2V0QXJjTGVuZ3RoO1xuXG5cdFx0XHRcdGlmIChjb21wYXJpc29uIDwgMCkge1xuXHRcdFx0XHRcdGxvdyA9IGkgKyAxO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNvbXBhcmlzb24gPiAwKSB7XG5cdFx0XHRcdFx0aGlnaCA9IGkgLSAxO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGhpZ2ggPSBpO1xuXHRcdFx0XHRcdGJyZWFrOyAvLyBET05FXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aSA9IGhpZ2g7XG5cblx0XHRcdGlmIChhcmNMZW5ndGhzW2ldID09PSB0YXJnZXRBcmNMZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIGkgLyAoaWwgLSAxKTtcblx0XHRcdH0gLy8gd2UgY291bGQgZ2V0IGZpbmVyIGdyYWluIGF0IGxlbmd0aHMsIG9yIHVzZSBzaW1wbGUgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcblxuXG5cdFx0XHRjb25zdCBsZW5ndGhCZWZvcmUgPSBhcmNMZW5ndGhzW2ldO1xuXHRcdFx0Y29uc3QgbGVuZ3RoQWZ0ZXIgPSBhcmNMZW5ndGhzW2kgKyAxXTtcblx0XHRcdGNvbnN0IHNlZ21lbnRMZW5ndGggPSBsZW5ndGhBZnRlciAtIGxlbmd0aEJlZm9yZTsgLy8gZGV0ZXJtaW5lIHdoZXJlIHdlIGFyZSBiZXR3ZWVuIHRoZSAnYmVmb3JlJyBhbmQgJ2FmdGVyJyBwb2ludHNcblxuXHRcdFx0Y29uc3Qgc2VnbWVudEZyYWN0aW9uID0gKHRhcmdldEFyY0xlbmd0aCAtIGxlbmd0aEJlZm9yZSkgLyBzZWdtZW50TGVuZ3RoOyAvLyBhZGQgdGhhdCBmcmFjdGlvbmFsIGFtb3VudCB0byB0XG5cblx0XHRcdGNvbnN0IHQgPSAoaSArIHNlZ21lbnRGcmFjdGlvbikgLyAoaWwgLSAxKTtcblx0XHRcdHJldHVybiB0O1xuXHRcdH0gLy8gUmV0dXJucyBhIHVuaXQgdmVjdG9yIHRhbmdlbnQgYXQgdFxuXHRcdC8vIEluIGNhc2UgYW55IHN1YiBjdXJ2ZSBkb2VzIG5vdCBpbXBsZW1lbnQgaXRzIHRhbmdlbnQgZGVyaXZhdGlvbixcblx0XHQvLyAyIHBvaW50cyBhIHNtYWxsIGRlbHRhIGFwYXJ0IHdpbGwgYmUgdXNlZCB0byBmaW5kIGl0cyBncmFkaWVudFxuXHRcdC8vIHdoaWNoIHNlZW1zIHRvIGdpdmUgYSByZWFzb25hYmxlIGFwcHJveGltYXRpb25cblxuXG5cdFx0Z2V0VGFuZ2VudCh0LCBvcHRpb25hbFRhcmdldCkge1xuXHRcdFx0Y29uc3QgZGVsdGEgPSAwLjAwMDE7XG5cdFx0XHRsZXQgdDEgPSB0IC0gZGVsdGE7XG5cdFx0XHRsZXQgdDIgPSB0ICsgZGVsdGE7IC8vIENhcHBpbmcgaW4gY2FzZSBvZiBkYW5nZXJcblxuXHRcdFx0aWYgKHQxIDwgMCkgdDEgPSAwO1xuXHRcdFx0aWYgKHQyID4gMSkgdDIgPSAxO1xuXHRcdFx0Y29uc3QgcHQxID0gdGhpcy5nZXRQb2ludCh0MSk7XG5cdFx0XHRjb25zdCBwdDIgPSB0aGlzLmdldFBvaW50KHQyKTtcblx0XHRcdGNvbnN0IHRhbmdlbnQgPSBvcHRpb25hbFRhcmdldCB8fCAocHQxLmlzVmVjdG9yMiA/IG5ldyBWZWN0b3IyKCkgOiBuZXcgVmVjdG9yMygpKTtcblx0XHRcdHRhbmdlbnQuY29weShwdDIpLnN1YihwdDEpLm5vcm1hbGl6ZSgpO1xuXHRcdFx0cmV0dXJuIHRhbmdlbnQ7XG5cdFx0fVxuXG5cdFx0Z2V0VGFuZ2VudEF0KHUsIG9wdGlvbmFsVGFyZ2V0KSB7XG5cdFx0XHRjb25zdCB0ID0gdGhpcy5nZXRVdG9UbWFwcGluZyh1KTtcblx0XHRcdHJldHVybiB0aGlzLmdldFRhbmdlbnQodCwgb3B0aW9uYWxUYXJnZXQpO1xuXHRcdH1cblxuXHRcdGNvbXB1dGVGcmVuZXRGcmFtZXMoc2VnbWVudHMsIGNsb3NlZCkge1xuXHRcdFx0Ly8gc2VlIGh0dHA6Ly93d3cuY3MuaW5kaWFuYS5lZHUvcHViL3RlY2hyZXBvcnRzL1RSNDI1LnBkZlxuXHRcdFx0Y29uc3Qgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IHRhbmdlbnRzID0gW107XG5cdFx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0XHRjb25zdCBiaW5vcm1hbHMgPSBbXTtcblx0XHRcdGNvbnN0IHZlYyA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBtYXQgPSBuZXcgTWF0cml4NCgpOyAvLyBjb21wdXRlIHRoZSB0YW5nZW50IHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgY3VydmVcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPD0gc2VnbWVudHM7IGkrKykge1xuXHRcdFx0XHRjb25zdCB1ID0gaSAvIHNlZ21lbnRzO1xuXHRcdFx0XHR0YW5nZW50c1tpXSA9IHRoaXMuZ2V0VGFuZ2VudEF0KHUsIG5ldyBWZWN0b3IzKCkpO1xuXHRcdFx0fSAvLyBzZWxlY3QgYW4gaW5pdGlhbCBub3JtYWwgdmVjdG9yIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGZpcnN0IHRhbmdlbnQgdmVjdG9yLFxuXHRcdFx0Ly8gYW5kIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG1pbmltdW0gdGFuZ2VudCB4eXogY29tcG9uZW50XG5cblxuXHRcdFx0bm9ybWFsc1swXSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRiaW5vcm1hbHNbMF0gPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0bGV0IG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XG5cdFx0XHRjb25zdCB0eCA9IE1hdGguYWJzKHRhbmdlbnRzWzBdLngpO1xuXHRcdFx0Y29uc3QgdHkgPSBNYXRoLmFicyh0YW5nZW50c1swXS55KTtcblx0XHRcdGNvbnN0IHR6ID0gTWF0aC5hYnModGFuZ2VudHNbMF0ueik7XG5cblx0XHRcdGlmICh0eCA8PSBtaW4pIHtcblx0XHRcdFx0bWluID0gdHg7XG5cdFx0XHRcdG5vcm1hbC5zZXQoMSwgMCwgMCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eSA8PSBtaW4pIHtcblx0XHRcdFx0bWluID0gdHk7XG5cdFx0XHRcdG5vcm1hbC5zZXQoMCwgMSwgMCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eiA8PSBtaW4pIHtcblx0XHRcdFx0bm9ybWFsLnNldCgwLCAwLCAxKTtcblx0XHRcdH1cblxuXHRcdFx0dmVjLmNyb3NzVmVjdG9ycyh0YW5nZW50c1swXSwgbm9ybWFsKS5ub3JtYWxpemUoKTtcblx0XHRcdG5vcm1hbHNbMF0uY3Jvc3NWZWN0b3JzKHRhbmdlbnRzWzBdLCB2ZWMpO1xuXHRcdFx0Ymlub3JtYWxzWzBdLmNyb3NzVmVjdG9ycyh0YW5nZW50c1swXSwgbm9ybWFsc1swXSk7IC8vIGNvbXB1dGUgdGhlIHNsb3dseS12YXJ5aW5nIG5vcm1hbCBhbmQgYmlub3JtYWwgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBjdXJ2ZVxuXG5cdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSsrKSB7XG5cdFx0XHRcdG5vcm1hbHNbaV0gPSBub3JtYWxzW2kgLSAxXS5jbG9uZSgpO1xuXHRcdFx0XHRiaW5vcm1hbHNbaV0gPSBiaW5vcm1hbHNbaSAtIDFdLmNsb25lKCk7XG5cdFx0XHRcdHZlYy5jcm9zc1ZlY3RvcnModGFuZ2VudHNbaSAtIDFdLCB0YW5nZW50c1tpXSk7XG5cblx0XHRcdFx0aWYgKHZlYy5sZW5ndGgoKSA+IE51bWJlci5FUFNJTE9OKSB7XG5cdFx0XHRcdFx0dmVjLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHRcdGNvbnN0IHRoZXRhID0gTWF0aC5hY29zKGNsYW1wKHRhbmdlbnRzW2kgLSAxXS5kb3QodGFuZ2VudHNbaV0pLCAtMSwgMSkpOyAvLyBjbGFtcCBmb3IgZmxvYXRpbmcgcHQgZXJyb3JzXG5cblx0XHRcdFx0XHRub3JtYWxzW2ldLmFwcGx5TWF0cml4NChtYXQubWFrZVJvdGF0aW9uQXhpcyh2ZWMsIHRoZXRhKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiaW5vcm1hbHNbaV0uY3Jvc3NWZWN0b3JzKHRhbmdlbnRzW2ldLCBub3JtYWxzW2ldKTtcblx0XHRcdH0gLy8gaWYgdGhlIGN1cnZlIGlzIGNsb3NlZCwgcG9zdHByb2Nlc3MgdGhlIHZlY3RvcnMgc28gdGhlIGZpcnN0IGFuZCBsYXN0IG5vcm1hbCB2ZWN0b3JzIGFyZSB0aGUgc2FtZVxuXG5cblx0XHRcdGlmIChjbG9zZWQgPT09IHRydWUpIHtcblx0XHRcdFx0bGV0IHRoZXRhID0gTWF0aC5hY29zKGNsYW1wKG5vcm1hbHNbMF0uZG90KG5vcm1hbHNbc2VnbWVudHNdKSwgLTEsIDEpKTtcblx0XHRcdFx0dGhldGEgLz0gc2VnbWVudHM7XG5cblx0XHRcdFx0aWYgKHRhbmdlbnRzWzBdLmRvdCh2ZWMuY3Jvc3NWZWN0b3JzKG5vcm1hbHNbMF0sIG5vcm1hbHNbc2VnbWVudHNdKSkgPiAwKSB7XG5cdFx0XHRcdFx0dGhldGEgPSAtdGhldGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSsrKSB7XG5cdFx0XHRcdFx0Ly8gdHdpc3QgYSBsaXR0bGUuLi5cblx0XHRcdFx0XHRub3JtYWxzW2ldLmFwcGx5TWF0cml4NChtYXQubWFrZVJvdGF0aW9uQXhpcyh0YW5nZW50c1tpXSwgdGhldGEgKiBpKSk7XG5cdFx0XHRcdFx0Ymlub3JtYWxzW2ldLmNyb3NzVmVjdG9ycyh0YW5nZW50c1tpXSwgbm9ybWFsc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dGFuZ2VudHM6IHRhbmdlbnRzLFxuXHRcdFx0XHRub3JtYWxzOiBub3JtYWxzLFxuXHRcdFx0XHRiaW5vcm1hbHM6IGJpbm9ybWFsc1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zID0gc291cmNlLmFyY0xlbmd0aERpdmlzaW9ucztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRvSlNPTigpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdFx0dmVyc2lvbjogNC41LFxuXHRcdFx0XHRcdHR5cGU6ICdDdXJ2ZScsXG5cdFx0XHRcdFx0Z2VuZXJhdG9yOiAnQ3VydmUudG9KU09OJ1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZGF0YS5hcmNMZW5ndGhEaXZpc2lvbnMgPSB0aGlzLmFyY0xlbmd0aERpdmlzaW9ucztcblx0XHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdGZyb21KU09OKGpzb24pIHtcblx0XHRcdHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zID0ganNvbi5hcmNMZW5ndGhEaXZpc2lvbnM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIEVsbGlwc2VDdXJ2ZSBleHRlbmRzIEN1cnZlIHtcblx0XHRjb25zdHJ1Y3RvcihhWCA9IDAsIGFZID0gMCwgeFJhZGl1cyA9IDEsIHlSYWRpdXMgPSAxLCBhU3RhcnRBbmdsZSA9IDAsIGFFbmRBbmdsZSA9IE1hdGguUEkgKiAyLCBhQ2xvY2t3aXNlID0gZmFsc2UsIGFSb3RhdGlvbiA9IDApIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnRWxsaXBzZUN1cnZlJztcblx0XHRcdHRoaXMuYVggPSBhWDtcblx0XHRcdHRoaXMuYVkgPSBhWTtcblx0XHRcdHRoaXMueFJhZGl1cyA9IHhSYWRpdXM7XG5cdFx0XHR0aGlzLnlSYWRpdXMgPSB5UmFkaXVzO1xuXHRcdFx0dGhpcy5hU3RhcnRBbmdsZSA9IGFTdGFydEFuZ2xlO1xuXHRcdFx0dGhpcy5hRW5kQW5nbGUgPSBhRW5kQW5nbGU7XG5cdFx0XHR0aGlzLmFDbG9ja3dpc2UgPSBhQ2xvY2t3aXNlO1xuXHRcdFx0dGhpcy5hUm90YXRpb24gPSBhUm90YXRpb247XG5cdFx0fVxuXG5cdFx0Z2V0UG9pbnQodCwgb3B0aW9uYWxUYXJnZXQpIHtcblx0XHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcblx0XHRcdGNvbnN0IHR3b1BpID0gTWF0aC5QSSAqIDI7XG5cdFx0XHRsZXQgZGVsdGFBbmdsZSA9IHRoaXMuYUVuZEFuZ2xlIC0gdGhpcy5hU3RhcnRBbmdsZTtcblx0XHRcdGNvbnN0IHNhbWVQb2ludHMgPSBNYXRoLmFicyhkZWx0YUFuZ2xlKSA8IE51bWJlci5FUFNJTE9OOyAvLyBlbnN1cmVzIHRoYXQgZGVsdGFBbmdsZSBpcyAwIC4uIDIgUElcblxuXHRcdFx0d2hpbGUgKGRlbHRhQW5nbGUgPCAwKSBkZWx0YUFuZ2xlICs9IHR3b1BpO1xuXG5cdFx0XHR3aGlsZSAoZGVsdGFBbmdsZSA+IHR3b1BpKSBkZWx0YUFuZ2xlIC09IHR3b1BpO1xuXG5cdFx0XHRpZiAoZGVsdGFBbmdsZSA8IE51bWJlci5FUFNJTE9OKSB7XG5cdFx0XHRcdGlmIChzYW1lUG9pbnRzKSB7XG5cdFx0XHRcdFx0ZGVsdGFBbmdsZSA9IDA7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVsdGFBbmdsZSA9IHR3b1BpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmFDbG9ja3dpc2UgPT09IHRydWUgJiYgIXNhbWVQb2ludHMpIHtcblx0XHRcdFx0aWYgKGRlbHRhQW5nbGUgPT09IHR3b1BpKSB7XG5cdFx0XHRcdFx0ZGVsdGFBbmdsZSA9IC10d29QaTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWx0YUFuZ2xlID0gZGVsdGFBbmdsZSAtIHR3b1BpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGFuZ2xlID0gdGhpcy5hU3RhcnRBbmdsZSArIHQgKiBkZWx0YUFuZ2xlO1xuXHRcdFx0bGV0IHggPSB0aGlzLmFYICsgdGhpcy54UmFkaXVzICogTWF0aC5jb3MoYW5nbGUpO1xuXHRcdFx0bGV0IHkgPSB0aGlzLmFZICsgdGhpcy55UmFkaXVzICogTWF0aC5zaW4oYW5nbGUpO1xuXG5cdFx0XHRpZiAodGhpcy5hUm90YXRpb24gIT09IDApIHtcblx0XHRcdFx0Y29uc3QgY29zID0gTWF0aC5jb3ModGhpcy5hUm90YXRpb24pO1xuXHRcdFx0XHRjb25zdCBzaW4gPSBNYXRoLnNpbih0aGlzLmFSb3RhdGlvbik7XG5cdFx0XHRcdGNvbnN0IHR4ID0geCAtIHRoaXMuYVg7XG5cdFx0XHRcdGNvbnN0IHR5ID0geSAtIHRoaXMuYVk7IC8vIFJvdGF0ZSB0aGUgcG9pbnQgYWJvdXQgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZS5cblxuXHRcdFx0XHR4ID0gdHggKiBjb3MgLSB0eSAqIHNpbiArIHRoaXMuYVg7XG5cdFx0XHRcdHkgPSB0eCAqIHNpbiArIHR5ICogY29zICsgdGhpcy5hWTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHBvaW50LnNldCh4LCB5KTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0dGhpcy5hWCA9IHNvdXJjZS5hWDtcblx0XHRcdHRoaXMuYVkgPSBzb3VyY2UuYVk7XG5cdFx0XHR0aGlzLnhSYWRpdXMgPSBzb3VyY2UueFJhZGl1cztcblx0XHRcdHRoaXMueVJhZGl1cyA9IHNvdXJjZS55UmFkaXVzO1xuXHRcdFx0dGhpcy5hU3RhcnRBbmdsZSA9IHNvdXJjZS5hU3RhcnRBbmdsZTtcblx0XHRcdHRoaXMuYUVuZEFuZ2xlID0gc291cmNlLmFFbmRBbmdsZTtcblx0XHRcdHRoaXMuYUNsb2Nrd2lzZSA9IHNvdXJjZS5hQ2xvY2t3aXNlO1xuXHRcdFx0dGhpcy5hUm90YXRpb24gPSBzb3VyY2UuYVJvdGF0aW9uO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dG9KU09OKCkge1xuXHRcdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXHRcdFx0ZGF0YS5hWCA9IHRoaXMuYVg7XG5cdFx0XHRkYXRhLmFZID0gdGhpcy5hWTtcblx0XHRcdGRhdGEueFJhZGl1cyA9IHRoaXMueFJhZGl1cztcblx0XHRcdGRhdGEueVJhZGl1cyA9IHRoaXMueVJhZGl1cztcblx0XHRcdGRhdGEuYVN0YXJ0QW5nbGUgPSB0aGlzLmFTdGFydEFuZ2xlO1xuXHRcdFx0ZGF0YS5hRW5kQW5nbGUgPSB0aGlzLmFFbmRBbmdsZTtcblx0XHRcdGRhdGEuYUNsb2Nrd2lzZSA9IHRoaXMuYUNsb2Nrd2lzZTtcblx0XHRcdGRhdGEuYVJvdGF0aW9uID0gdGhpcy5hUm90YXRpb247XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHRmcm9tSlNPTihqc29uKSB7XG5cdFx0XHRzdXBlci5mcm9tSlNPTihqc29uKTtcblx0XHRcdHRoaXMuYVggPSBqc29uLmFYO1xuXHRcdFx0dGhpcy5hWSA9IGpzb24uYVk7XG5cdFx0XHR0aGlzLnhSYWRpdXMgPSBqc29uLnhSYWRpdXM7XG5cdFx0XHR0aGlzLnlSYWRpdXMgPSBqc29uLnlSYWRpdXM7XG5cdFx0XHR0aGlzLmFTdGFydEFuZ2xlID0ganNvbi5hU3RhcnRBbmdsZTtcblx0XHRcdHRoaXMuYUVuZEFuZ2xlID0ganNvbi5hRW5kQW5nbGU7XG5cdFx0XHR0aGlzLmFDbG9ja3dpc2UgPSBqc29uLmFDbG9ja3dpc2U7XG5cdFx0XHR0aGlzLmFSb3RhdGlvbiA9IGpzb24uYVJvdGF0aW9uO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRFbGxpcHNlQ3VydmUucHJvdG90eXBlLmlzRWxsaXBzZUN1cnZlID0gdHJ1ZTtcblxuXHRjbGFzcyBBcmNDdXJ2ZSBleHRlbmRzIEVsbGlwc2VDdXJ2ZSB7XG5cdFx0Y29uc3RydWN0b3IoYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlKSB7XG5cdFx0XHRzdXBlcihhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UpO1xuXHRcdFx0dGhpcy50eXBlID0gJ0FyY0N1cnZlJztcblx0XHR9XG5cblx0fVxuXG5cdEFyY0N1cnZlLnByb3RvdHlwZS5pc0FyY0N1cnZlID0gdHJ1ZTtcblxuXHQvKipcblx0ICogQ2VudHJpcGV0YWwgQ2F0bXVsbFJvbSBDdXJ2ZSAtIHdoaWNoIGlzIHVzZWZ1bCBmb3IgYXZvaWRpbmdcblx0ICogY3VzcHMgYW5kIHNlbGYtaW50ZXJzZWN0aW9ucyBpbiBub24tdW5pZm9ybSBjYXRtdWxsIHJvbSBjdXJ2ZXMuXG5cdCAqIGh0dHA6Ly93d3cuY2VteXVrc2VsLmNvbS9yZXNlYXJjaC9jYXRtdWxscm9tX3BhcmFtL2NhdG11bGxyb20ucGRmXG5cdCAqXG5cdCAqIGN1cnZlLnR5cGUgYWNjZXB0cyBjZW50cmlwZXRhbChkZWZhdWx0KSwgY2hvcmRhbCBhbmQgY2F0bXVsbHJvbVxuXHQgKiBjdXJ2ZS50ZW5zaW9uIGlzIHVzZWQgZm9yIGNhdG11bGxyb20gd2hpY2ggZGVmYXVsdHMgdG8gMC41XG5cdCAqL1xuXG5cdC8qXG5cdEJhc2VkIG9uIGFuIG9wdGltaXplZCBjKysgc29sdXRpb24gaW5cblx0IC0gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85NDg5NzM2L2NhdG11bGwtcm9tLWN1cnZlLXdpdGgtbm8tY3VzcHMtYW5kLW5vLXNlbGYtaW50ZXJzZWN0aW9ucy9cblx0IC0gaHR0cDovL2lkZW9uZS5jb20vTm9FYlZNXG5cblx0VGhpcyBDdWJpY1BvbHkgY2xhc3MgY291bGQgYmUgdXNlZCBmb3IgcmV1c2luZyBzb21lIHZhcmlhYmxlcyBhbmQgY2FsY3VsYXRpb25zLFxuXHRidXQgZm9yIHRocmVlLmpzIGN1cnZlIHVzZSwgaXQgY291bGQgYmUgcG9zc2libGUgaW5saW5lZCBhbmQgZmxhdHRlbiBpbnRvIGEgc2luZ2xlIGZ1bmN0aW9uIGNhbGxcblx0d2hpY2ggY2FuIGJlIHBsYWNlZCBpbiBDdXJ2ZVV0aWxzLlxuXHQqL1xuXG5cdGZ1bmN0aW9uIEN1YmljUG9seSgpIHtcblx0XHRsZXQgYzAgPSAwLFxuXHRcdFx0XHRjMSA9IDAsXG5cdFx0XHRcdGMyID0gMCxcblx0XHRcdFx0YzMgPSAwO1xuXHRcdC8qXG5cdFx0ICogQ29tcHV0ZSBjb2VmZmljaWVudHMgZm9yIGEgY3ViaWMgcG9seW5vbWlhbFxuXHRcdCAqXHQgcChzKSA9IGMwICsgYzEqcyArIGMyKnNeMiArIGMzKnNeM1xuXHRcdCAqIHN1Y2ggdGhhdFxuXHRcdCAqXHQgcCgwKSA9IHgwLCBwKDEpID0geDFcblx0XHQgKlx0YW5kXG5cdFx0ICpcdCBwJygwKSA9IHQwLCBwJygxKSA9IHQxLlxuXHRcdCAqL1xuXG5cdFx0ZnVuY3Rpb24gaW5pdCh4MCwgeDEsIHQwLCB0MSkge1xuXHRcdFx0YzAgPSB4MDtcblx0XHRcdGMxID0gdDA7XG5cdFx0XHRjMiA9IC0zICogeDAgKyAzICogeDEgLSAyICogdDAgLSB0MTtcblx0XHRcdGMzID0gMiAqIHgwIC0gMiAqIHgxICsgdDAgKyB0MTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0aW5pdENhdG11bGxSb206IGZ1bmN0aW9uICh4MCwgeDEsIHgyLCB4MywgdGVuc2lvbikge1xuXHRcdFx0XHRpbml0KHgxLCB4MiwgdGVuc2lvbiAqICh4MiAtIHgwKSwgdGVuc2lvbiAqICh4MyAtIHgxKSk7XG5cdFx0XHR9LFxuXHRcdFx0aW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tOiBmdW5jdGlvbiAoeDAsIHgxLCB4MiwgeDMsIGR0MCwgZHQxLCBkdDIpIHtcblx0XHRcdFx0Ly8gY29tcHV0ZSB0YW5nZW50cyB3aGVuIHBhcmFtZXRlcml6ZWQgaW4gW3QxLHQyXVxuXHRcdFx0XHRsZXQgdDEgPSAoeDEgLSB4MCkgLyBkdDAgLSAoeDIgLSB4MCkgLyAoZHQwICsgZHQxKSArICh4MiAtIHgxKSAvIGR0MTtcblx0XHRcdFx0bGV0IHQyID0gKHgyIC0geDEpIC8gZHQxIC0gKHgzIC0geDEpIC8gKGR0MSArIGR0MikgKyAoeDMgLSB4MikgLyBkdDI7IC8vIHJlc2NhbGUgdGFuZ2VudHMgZm9yIHBhcmFtZXRyaXphdGlvbiBpbiBbMCwxXVxuXG5cdFx0XHRcdHQxICo9IGR0MTtcblx0XHRcdFx0dDIgKj0gZHQxO1xuXHRcdFx0XHRpbml0KHgxLCB4MiwgdDEsIHQyKTtcblx0XHRcdH0sXG5cdFx0XHRjYWxjOiBmdW5jdGlvbiAodCkge1xuXHRcdFx0XHRjb25zdCB0MiA9IHQgKiB0O1xuXHRcdFx0XHRjb25zdCB0MyA9IHQyICogdDtcblx0XHRcdFx0cmV0dXJuIGMwICsgYzEgKiB0ICsgYzIgKiB0MiArIGMzICogdDM7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSAvL1xuXG5cblx0Y29uc3QgdG1wID0gbmV3IFZlY3RvcjMoKTtcblx0Y29uc3QgcHggPSBuZXcgQ3ViaWNQb2x5KCksXG5cdFx0XHRcdHB5ID0gbmV3IEN1YmljUG9seSgpLFxuXHRcdFx0XHRweiA9IG5ldyBDdWJpY1BvbHkoKTtcblxuXHRjbGFzcyBDYXRtdWxsUm9tQ3VydmUzIGV4dGVuZHMgQ3VydmUge1xuXHRcdGNvbnN0cnVjdG9yKHBvaW50cyA9IFtdLCBjbG9zZWQgPSBmYWxzZSwgY3VydmVUeXBlID0gJ2NlbnRyaXBldGFsJywgdGVuc2lvbiA9IDAuNSkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdDYXRtdWxsUm9tQ3VydmUzJztcblx0XHRcdHRoaXMucG9pbnRzID0gcG9pbnRzO1xuXHRcdFx0dGhpcy5jbG9zZWQgPSBjbG9zZWQ7XG5cdFx0XHR0aGlzLmN1cnZlVHlwZSA9IGN1cnZlVHlwZTtcblx0XHRcdHRoaXMudGVuc2lvbiA9IHRlbnNpb247XG5cdFx0fVxuXG5cdFx0Z2V0UG9pbnQodCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMygpKSB7XG5cdFx0XHRjb25zdCBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0O1xuXHRcdFx0Y29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cdFx0XHRjb25zdCBsID0gcG9pbnRzLmxlbmd0aDtcblx0XHRcdGNvbnN0IHAgPSAobCAtICh0aGlzLmNsb3NlZCA/IDAgOiAxKSkgKiB0O1xuXHRcdFx0bGV0IGludFBvaW50ID0gTWF0aC5mbG9vcihwKTtcblx0XHRcdGxldCB3ZWlnaHQgPSBwIC0gaW50UG9pbnQ7XG5cblx0XHRcdGlmICh0aGlzLmNsb3NlZCkge1xuXHRcdFx0XHRpbnRQb2ludCArPSBpbnRQb2ludCA+IDAgPyAwIDogKE1hdGguZmxvb3IoTWF0aC5hYnMoaW50UG9pbnQpIC8gbCkgKyAxKSAqIGw7XG5cdFx0XHR9IGVsc2UgaWYgKHdlaWdodCA9PT0gMCAmJiBpbnRQb2ludCA9PT0gbCAtIDEpIHtcblx0XHRcdFx0aW50UG9pbnQgPSBsIC0gMjtcblx0XHRcdFx0d2VpZ2h0ID0gMTtcblx0XHRcdH1cblxuXHRcdFx0bGV0IHAwLCBwMzsgLy8gNCBwb2ludHMgKHAxICYgcDIgZGVmaW5lZCBiZWxvdylcblxuXHRcdFx0aWYgKHRoaXMuY2xvc2VkIHx8IGludFBvaW50ID4gMCkge1xuXHRcdFx0XHRwMCA9IHBvaW50c1soaW50UG9pbnQgLSAxKSAlIGxdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gZXh0cmFwb2xhdGUgZmlyc3QgcG9pbnRcblx0XHRcdFx0dG1wLnN1YlZlY3RvcnMocG9pbnRzWzBdLCBwb2ludHNbMV0pLmFkZChwb2ludHNbMF0pO1xuXHRcdFx0XHRwMCA9IHRtcDtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcDEgPSBwb2ludHNbaW50UG9pbnQgJSBsXTtcblx0XHRcdGNvbnN0IHAyID0gcG9pbnRzWyhpbnRQb2ludCArIDEpICUgbF07XG5cblx0XHRcdGlmICh0aGlzLmNsb3NlZCB8fCBpbnRQb2ludCArIDIgPCBsKSB7XG5cdFx0XHRcdHAzID0gcG9pbnRzWyhpbnRQb2ludCArIDIpICUgbF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBleHRyYXBvbGF0ZSBsYXN0IHBvaW50XG5cdFx0XHRcdHRtcC5zdWJWZWN0b3JzKHBvaW50c1tsIC0gMV0sIHBvaW50c1tsIC0gMl0pLmFkZChwb2ludHNbbCAtIDFdKTtcblx0XHRcdFx0cDMgPSB0bXA7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmN1cnZlVHlwZSA9PT0gJ2NlbnRyaXBldGFsJyB8fCB0aGlzLmN1cnZlVHlwZSA9PT0gJ2Nob3JkYWwnKSB7XG5cdFx0XHRcdC8vIGluaXQgQ2VudHJpcGV0YWwgLyBDaG9yZGFsIENhdG11bGwtUm9tXG5cdFx0XHRcdGNvbnN0IHBvdyA9IHRoaXMuY3VydmVUeXBlID09PSAnY2hvcmRhbCcgPyAwLjUgOiAwLjI1O1xuXHRcdFx0XHRsZXQgZHQwID0gTWF0aC5wb3cocDAuZGlzdGFuY2VUb1NxdWFyZWQocDEpLCBwb3cpO1xuXHRcdFx0XHRsZXQgZHQxID0gTWF0aC5wb3cocDEuZGlzdGFuY2VUb1NxdWFyZWQocDIpLCBwb3cpO1xuXHRcdFx0XHRsZXQgZHQyID0gTWF0aC5wb3cocDIuZGlzdGFuY2VUb1NxdWFyZWQocDMpLCBwb3cpOyAvLyBzYWZldHkgY2hlY2sgZm9yIHJlcGVhdGVkIHBvaW50c1xuXG5cdFx0XHRcdGlmIChkdDEgPCAxZS00KSBkdDEgPSAxLjA7XG5cdFx0XHRcdGlmIChkdDAgPCAxZS00KSBkdDAgPSBkdDE7XG5cdFx0XHRcdGlmIChkdDIgPCAxZS00KSBkdDIgPSBkdDE7XG5cdFx0XHRcdHB4LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbShwMC54LCBwMS54LCBwMi54LCBwMy54LCBkdDAsIGR0MSwgZHQyKTtcblx0XHRcdFx0cHkuaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKHAwLnksIHAxLnksIHAyLnksIHAzLnksIGR0MCwgZHQxLCBkdDIpO1xuXHRcdFx0XHRwei5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20ocDAueiwgcDEueiwgcDIueiwgcDMueiwgZHQwLCBkdDEsIGR0Mik7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuY3VydmVUeXBlID09PSAnY2F0bXVsbHJvbScpIHtcblx0XHRcdFx0cHguaW5pdENhdG11bGxSb20ocDAueCwgcDEueCwgcDIueCwgcDMueCwgdGhpcy50ZW5zaW9uKTtcblx0XHRcdFx0cHkuaW5pdENhdG11bGxSb20ocDAueSwgcDEueSwgcDIueSwgcDMueSwgdGhpcy50ZW5zaW9uKTtcblx0XHRcdFx0cHouaW5pdENhdG11bGxSb20ocDAueiwgcDEueiwgcDIueiwgcDMueiwgdGhpcy50ZW5zaW9uKTtcblx0XHRcdH1cblxuXHRcdFx0cG9pbnQuc2V0KHB4LmNhbGMod2VpZ2h0KSwgcHkuY2FsYyh3ZWlnaHQpLCBwei5jYWxjKHdlaWdodCkpO1xuXHRcdFx0cmV0dXJuIHBvaW50O1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLnBvaW50cyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHNvdXJjZS5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHBvaW50ID0gc291cmNlLnBvaW50c1tpXTtcblx0XHRcdFx0dGhpcy5wb2ludHMucHVzaChwb2ludC5jbG9uZSgpKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5jbG9zZWQgPSBzb3VyY2UuY2xvc2VkO1xuXHRcdFx0dGhpcy5jdXJ2ZVR5cGUgPSBzb3VyY2UuY3VydmVUeXBlO1xuXHRcdFx0dGhpcy50ZW5zaW9uID0gc291cmNlLnRlbnNpb247XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0b0pTT04oKSB7XG5cdFx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cdFx0XHRkYXRhLnBvaW50cyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBwb2ludCA9IHRoaXMucG9pbnRzW2ldO1xuXHRcdFx0XHRkYXRhLnBvaW50cy5wdXNoKHBvaW50LnRvQXJyYXkoKSk7XG5cdFx0XHR9XG5cblx0XHRcdGRhdGEuY2xvc2VkID0gdGhpcy5jbG9zZWQ7XG5cdFx0XHRkYXRhLmN1cnZlVHlwZSA9IHRoaXMuY3VydmVUeXBlO1xuXHRcdFx0ZGF0YS50ZW5zaW9uID0gdGhpcy50ZW5zaW9uO1xuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0ZnJvbUpTT04oanNvbikge1xuXHRcdFx0c3VwZXIuZnJvbUpTT04oanNvbik7XG5cdFx0XHR0aGlzLnBvaW50cyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGpzb24ucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBwb2ludCA9IGpzb24ucG9pbnRzW2ldO1xuXHRcdFx0XHR0aGlzLnBvaW50cy5wdXNoKG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KHBvaW50KSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuY2xvc2VkID0ganNvbi5jbG9zZWQ7XG5cdFx0XHR0aGlzLmN1cnZlVHlwZSA9IGpzb24uY3VydmVUeXBlO1xuXHRcdFx0dGhpcy50ZW5zaW9uID0ganNvbi50ZW5zaW9uO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRDYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZS5pc0NhdG11bGxSb21DdXJ2ZTMgPSB0cnVlO1xuXG5cdC8qKlxuXHQgKiBCZXppZXIgQ3VydmVzIGZvcm11bGFzIG9idGFpbmVkIGZyb21cblx0ICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Cw6l6aWVyX2N1cnZlXG5cdCAqL1xuXHRmdW5jdGlvbiBDYXRtdWxsUm9tKHQsIHAwLCBwMSwgcDIsIHAzKSB7XG5cdFx0Y29uc3QgdjAgPSAocDIgLSBwMCkgKiAwLjU7XG5cdFx0Y29uc3QgdjEgPSAocDMgLSBwMSkgKiAwLjU7XG5cdFx0Y29uc3QgdDIgPSB0ICogdDtcblx0XHRjb25zdCB0MyA9IHQgKiB0Mjtcblx0XHRyZXR1cm4gKDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEpICogdDMgKyAoLTMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxKSAqIHQyICsgdjAgKiB0ICsgcDE7XG5cdH0gLy9cblxuXG5cdGZ1bmN0aW9uIFF1YWRyYXRpY0JlemllclAwKHQsIHApIHtcblx0XHRjb25zdCBrID0gMSAtIHQ7XG5cdFx0cmV0dXJuIGsgKiBrICogcDtcblx0fVxuXG5cdGZ1bmN0aW9uIFF1YWRyYXRpY0JlemllclAxKHQsIHApIHtcblx0XHRyZXR1cm4gMiAqICgxIC0gdCkgKiB0ICogcDtcblx0fVxuXG5cdGZ1bmN0aW9uIFF1YWRyYXRpY0JlemllclAyKHQsIHApIHtcblx0XHRyZXR1cm4gdCAqIHQgKiBwO1xuXHR9XG5cblx0ZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyKHQsIHAwLCBwMSwgcDIpIHtcblx0XHRyZXR1cm4gUXVhZHJhdGljQmV6aWVyUDAodCwgcDApICsgUXVhZHJhdGljQmV6aWVyUDEodCwgcDEpICsgUXVhZHJhdGljQmV6aWVyUDIodCwgcDIpO1xuXHR9IC8vXG5cblxuXHRmdW5jdGlvbiBDdWJpY0JlemllclAwKHQsIHApIHtcblx0XHRjb25zdCBrID0gMSAtIHQ7XG5cdFx0cmV0dXJuIGsgKiBrICogayAqIHA7XG5cdH1cblxuXHRmdW5jdGlvbiBDdWJpY0JlemllclAxKHQsIHApIHtcblx0XHRjb25zdCBrID0gMSAtIHQ7XG5cdFx0cmV0dXJuIDMgKiBrICogayAqIHQgKiBwO1xuXHR9XG5cblx0ZnVuY3Rpb24gQ3ViaWNCZXppZXJQMih0LCBwKSB7XG5cdFx0cmV0dXJuIDMgKiAoMSAtIHQpICogdCAqIHQgKiBwO1xuXHR9XG5cblx0ZnVuY3Rpb24gQ3ViaWNCZXppZXJQMyh0LCBwKSB7XG5cdFx0cmV0dXJuIHQgKiB0ICogdCAqIHA7XG5cdH1cblxuXHRmdW5jdGlvbiBDdWJpY0Jlemllcih0LCBwMCwgcDEsIHAyLCBwMykge1xuXHRcdHJldHVybiBDdWJpY0JlemllclAwKHQsIHAwKSArIEN1YmljQmV6aWVyUDEodCwgcDEpICsgQ3ViaWNCZXppZXJQMih0LCBwMikgKyBDdWJpY0JlemllclAzKHQsIHAzKTtcblx0fVxuXG5cdGNsYXNzIEN1YmljQmV6aWVyQ3VydmUgZXh0ZW5kcyBDdXJ2ZSB7XG5cdFx0Y29uc3RydWN0b3IodjAgPSBuZXcgVmVjdG9yMigpLCB2MSA9IG5ldyBWZWN0b3IyKCksIHYyID0gbmV3IFZlY3RvcjIoKSwgdjMgPSBuZXcgVmVjdG9yMigpKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ0N1YmljQmV6aWVyQ3VydmUnO1xuXHRcdFx0dGhpcy52MCA9IHYwO1xuXHRcdFx0dGhpcy52MSA9IHYxO1xuXHRcdFx0dGhpcy52MiA9IHYyO1xuXHRcdFx0dGhpcy52MyA9IHYzO1xuXHRcdH1cblxuXHRcdGdldFBvaW50KHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjIoKSkge1xuXHRcdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblx0XHRcdGNvbnN0IHYwID0gdGhpcy52MCxcblx0XHRcdFx0XHRcdHYxID0gdGhpcy52MSxcblx0XHRcdFx0XHRcdHYyID0gdGhpcy52Mixcblx0XHRcdFx0XHRcdHYzID0gdGhpcy52Mztcblx0XHRcdHBvaW50LnNldChDdWJpY0Jlemllcih0LCB2MC54LCB2MS54LCB2Mi54LCB2My54KSwgQ3ViaWNCZXppZXIodCwgdjAueSwgdjEueSwgdjIueSwgdjMueSkpO1xuXHRcdFx0cmV0dXJuIHBvaW50O1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLnYwLmNvcHkoc291cmNlLnYwKTtcblx0XHRcdHRoaXMudjEuY29weShzb3VyY2UudjEpO1xuXHRcdFx0dGhpcy52Mi5jb3B5KHNvdXJjZS52Mik7XG5cdFx0XHR0aGlzLnYzLmNvcHkoc291cmNlLnYzKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRvSlNPTigpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblx0XHRcdGRhdGEudjAgPSB0aGlzLnYwLnRvQXJyYXkoKTtcblx0XHRcdGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcblx0XHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblx0XHRcdGRhdGEudjMgPSB0aGlzLnYzLnRvQXJyYXkoKTtcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdGZyb21KU09OKGpzb24pIHtcblx0XHRcdHN1cGVyLmZyb21KU09OKGpzb24pO1xuXHRcdFx0dGhpcy52MC5mcm9tQXJyYXkoanNvbi52MCk7XG5cdFx0XHR0aGlzLnYxLmZyb21BcnJheShqc29uLnYxKTtcblx0XHRcdHRoaXMudjIuZnJvbUFycmF5KGpzb24udjIpO1xuXHRcdFx0dGhpcy52My5mcm9tQXJyYXkoanNvbi52Myk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdEN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmlzQ3ViaWNCZXppZXJDdXJ2ZSA9IHRydWU7XG5cblx0Y2xhc3MgQ3ViaWNCZXppZXJDdXJ2ZTMgZXh0ZW5kcyBDdXJ2ZSB7XG5cdFx0Y29uc3RydWN0b3IodjAgPSBuZXcgVmVjdG9yMygpLCB2MSA9IG5ldyBWZWN0b3IzKCksIHYyID0gbmV3IFZlY3RvcjMoKSwgdjMgPSBuZXcgVmVjdG9yMygpKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ0N1YmljQmV6aWVyQ3VydmUzJztcblx0XHRcdHRoaXMudjAgPSB2MDtcblx0XHRcdHRoaXMudjEgPSB2MTtcblx0XHRcdHRoaXMudjIgPSB2Mjtcblx0XHRcdHRoaXMudjMgPSB2Mztcblx0XHR9XG5cblx0XHRnZXRQb2ludCh0LCBvcHRpb25hbFRhcmdldCA9IG5ldyBWZWN0b3IzKCkpIHtcblx0XHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQ7XG5cdFx0XHRjb25zdCB2MCA9IHRoaXMudjAsXG5cdFx0XHRcdFx0XHR2MSA9IHRoaXMudjEsXG5cdFx0XHRcdFx0XHR2MiA9IHRoaXMudjIsXG5cdFx0XHRcdFx0XHR2MyA9IHRoaXMudjM7XG5cdFx0XHRwb2ludC5zZXQoQ3ViaWNCZXppZXIodCwgdjAueCwgdjEueCwgdjIueCwgdjMueCksIEN1YmljQmV6aWVyKHQsIHYwLnksIHYxLnksIHYyLnksIHYzLnkpLCBDdWJpY0Jlemllcih0LCB2MC56LCB2MS56LCB2Mi56LCB2My56KSk7XG5cdFx0XHRyZXR1cm4gcG9pbnQ7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdHRoaXMudjAuY29weShzb3VyY2UudjApO1xuXHRcdFx0dGhpcy52MS5jb3B5KHNvdXJjZS52MSk7XG5cdFx0XHR0aGlzLnYyLmNvcHkoc291cmNlLnYyKTtcblx0XHRcdHRoaXMudjMuY29weShzb3VyY2UudjMpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dG9KU09OKCkge1xuXHRcdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXHRcdFx0ZGF0YS52MCA9IHRoaXMudjAudG9BcnJheSgpO1xuXHRcdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xuXHRcdFx0ZGF0YS52MyA9IHRoaXMudjMudG9BcnJheSgpO1xuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0ZnJvbUpTT04oanNvbikge1xuXHRcdFx0c3VwZXIuZnJvbUpTT04oanNvbik7XG5cdFx0XHR0aGlzLnYwLmZyb21BcnJheShqc29uLnYwKTtcblx0XHRcdHRoaXMudjEuZnJvbUFycmF5KGpzb24udjEpO1xuXHRcdFx0dGhpcy52Mi5mcm9tQXJyYXkoanNvbi52Mik7XG5cdFx0XHR0aGlzLnYzLmZyb21BcnJheShqc29uLnYzKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0Q3ViaWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlLmlzQ3ViaWNCZXppZXJDdXJ2ZTMgPSB0cnVlO1xuXG5cdGNsYXNzIExpbmVDdXJ2ZSBleHRlbmRzIEN1cnZlIHtcblx0XHRjb25zdHJ1Y3Rvcih2MSA9IG5ldyBWZWN0b3IyKCksIHYyID0gbmV3IFZlY3RvcjIoKSkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdMaW5lQ3VydmUnO1xuXHRcdFx0dGhpcy52MSA9IHYxO1xuXHRcdFx0dGhpcy52MiA9IHYyO1xuXHRcdH1cblxuXHRcdGdldFBvaW50KHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjIoKSkge1xuXHRcdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdFx0aWYgKHQgPT09IDEpIHtcblx0XHRcdFx0cG9pbnQuY29weSh0aGlzLnYyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvaW50LmNvcHkodGhpcy52Mikuc3ViKHRoaXMudjEpO1xuXHRcdFx0XHRwb2ludC5tdWx0aXBseVNjYWxhcih0KS5hZGQodGhpcy52MSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwb2ludDtcblx0XHR9IC8vIExpbmUgY3VydmUgaXMgbGluZWFyLCBzbyB3ZSBjYW4gb3ZlcndyaXRlIGRlZmF1bHQgZ2V0UG9pbnRBdFxuXG5cblx0XHRnZXRQb2ludEF0KHUsIG9wdGlvbmFsVGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRQb2ludCh1LCBvcHRpb25hbFRhcmdldCk7XG5cdFx0fVxuXG5cdFx0Z2V0VGFuZ2VudCh0LCBvcHRpb25hbFRhcmdldCkge1xuXHRcdFx0Y29uc3QgdGFuZ2VudCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XG5cdFx0XHR0YW5nZW50LmNvcHkodGhpcy52Mikuc3ViKHRoaXMudjEpLm5vcm1hbGl6ZSgpO1xuXHRcdFx0cmV0dXJuIHRhbmdlbnQ7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdHRoaXMudjEuY29weShzb3VyY2UudjEpO1xuXHRcdFx0dGhpcy52Mi5jb3B5KHNvdXJjZS52Mik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0b0pTT04oKSB7XG5cdFx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cdFx0XHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XG5cdFx0XHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHRmcm9tSlNPTihqc29uKSB7XG5cdFx0XHRzdXBlci5mcm9tSlNPTihqc29uKTtcblx0XHRcdHRoaXMudjEuZnJvbUFycmF5KGpzb24udjEpO1xuXHRcdFx0dGhpcy52Mi5mcm9tQXJyYXkoanNvbi52Mik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdExpbmVDdXJ2ZS5wcm90b3R5cGUuaXNMaW5lQ3VydmUgPSB0cnVlO1xuXG5cdGNsYXNzIExpbmVDdXJ2ZTMgZXh0ZW5kcyBDdXJ2ZSB7XG5cdFx0Y29uc3RydWN0b3IodjEgPSBuZXcgVmVjdG9yMygpLCB2MiA9IG5ldyBWZWN0b3IzKCkpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnTGluZUN1cnZlMyc7XG5cdFx0XHR0aGlzLmlzTGluZUN1cnZlMyA9IHRydWU7XG5cdFx0XHR0aGlzLnYxID0gdjE7XG5cdFx0XHR0aGlzLnYyID0gdjI7XG5cdFx0fVxuXG5cdFx0Z2V0UG9pbnQodCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMygpKSB7XG5cdFx0XHRjb25zdCBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0O1xuXG5cdFx0XHRpZiAodCA9PT0gMSkge1xuXHRcdFx0XHRwb2ludC5jb3B5KHRoaXMudjIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG9pbnQuY29weSh0aGlzLnYyKS5zdWIodGhpcy52MSk7XG5cdFx0XHRcdHBvaW50Lm11bHRpcGx5U2NhbGFyKHQpLmFkZCh0aGlzLnYxKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHBvaW50O1xuXHRcdH0gLy8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XG5cblxuXHRcdGdldFBvaW50QXQodSwgb3B0aW9uYWxUYXJnZXQpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFBvaW50KHUsIG9wdGlvbmFsVGFyZ2V0KTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0dGhpcy52MS5jb3B5KHNvdXJjZS52MSk7XG5cdFx0XHR0aGlzLnYyLmNvcHkoc291cmNlLnYyKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRvSlNPTigpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblx0XHRcdGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcblx0XHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdGZyb21KU09OKGpzb24pIHtcblx0XHRcdHN1cGVyLmZyb21KU09OKGpzb24pO1xuXHRcdFx0dGhpcy52MS5mcm9tQXJyYXkoanNvbi52MSk7XG5cdFx0XHR0aGlzLnYyLmZyb21BcnJheShqc29uLnYyKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgUXVhZHJhdGljQmV6aWVyQ3VydmUgZXh0ZW5kcyBDdXJ2ZSB7XG5cdFx0Y29uc3RydWN0b3IodjAgPSBuZXcgVmVjdG9yMigpLCB2MSA9IG5ldyBWZWN0b3IyKCksIHYyID0gbmV3IFZlY3RvcjIoKSkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdRdWFkcmF0aWNCZXppZXJDdXJ2ZSc7XG5cdFx0XHR0aGlzLnYwID0gdjA7XG5cdFx0XHR0aGlzLnYxID0gdjE7XG5cdFx0XHR0aGlzLnYyID0gdjI7XG5cdFx0fVxuXG5cdFx0Z2V0UG9pbnQodCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMigpKSB7XG5cdFx0XHRjb25zdCBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0O1xuXHRcdFx0Y29uc3QgdjAgPSB0aGlzLnYwLFxuXHRcdFx0XHRcdFx0djEgPSB0aGlzLnYxLFxuXHRcdFx0XHRcdFx0djIgPSB0aGlzLnYyO1xuXHRcdFx0cG9pbnQuc2V0KFF1YWRyYXRpY0Jlemllcih0LCB2MC54LCB2MS54LCB2Mi54KSwgUXVhZHJhdGljQmV6aWVyKHQsIHYwLnksIHYxLnksIHYyLnkpKTtcblx0XHRcdHJldHVybiBwb2ludDtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0dGhpcy52MC5jb3B5KHNvdXJjZS52MCk7XG5cdFx0XHR0aGlzLnYxLmNvcHkoc291cmNlLnYxKTtcblx0XHRcdHRoaXMudjIuY29weShzb3VyY2UudjIpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dG9KU09OKCkge1xuXHRcdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXHRcdFx0ZGF0YS52MCA9IHRoaXMudjAudG9BcnJheSgpO1xuXHRcdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0ZnJvbUpTT04oanNvbikge1xuXHRcdFx0c3VwZXIuZnJvbUpTT04oanNvbik7XG5cdFx0XHR0aGlzLnYwLmZyb21BcnJheShqc29uLnYwKTtcblx0XHRcdHRoaXMudjEuZnJvbUFycmF5KGpzb24udjEpO1xuXHRcdFx0dGhpcy52Mi5mcm9tQXJyYXkoanNvbi52Mik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdFF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5pc1F1YWRyYXRpY0JlemllckN1cnZlID0gdHJ1ZTtcblxuXHRjbGFzcyBRdWFkcmF0aWNCZXppZXJDdXJ2ZTMgZXh0ZW5kcyBDdXJ2ZSB7XG5cdFx0Y29uc3RydWN0b3IodjAgPSBuZXcgVmVjdG9yMygpLCB2MSA9IG5ldyBWZWN0b3IzKCksIHYyID0gbmV3IFZlY3RvcjMoKSkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdRdWFkcmF0aWNCZXppZXJDdXJ2ZTMnO1xuXHRcdFx0dGhpcy52MCA9IHYwO1xuXHRcdFx0dGhpcy52MSA9IHYxO1xuXHRcdFx0dGhpcy52MiA9IHYyO1xuXHRcdH1cblxuXHRcdGdldFBvaW50KHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjMoKSkge1xuXHRcdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblx0XHRcdGNvbnN0IHYwID0gdGhpcy52MCxcblx0XHRcdFx0XHRcdHYxID0gdGhpcy52MSxcblx0XHRcdFx0XHRcdHYyID0gdGhpcy52Mjtcblx0XHRcdHBvaW50LnNldChRdWFkcmF0aWNCZXppZXIodCwgdjAueCwgdjEueCwgdjIueCksIFF1YWRyYXRpY0Jlemllcih0LCB2MC55LCB2MS55LCB2Mi55KSwgUXVhZHJhdGljQmV6aWVyKHQsIHYwLnosIHYxLnosIHYyLnopKTtcblx0XHRcdHJldHVybiBwb2ludDtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0dGhpcy52MC5jb3B5KHNvdXJjZS52MCk7XG5cdFx0XHR0aGlzLnYxLmNvcHkoc291cmNlLnYxKTtcblx0XHRcdHRoaXMudjIuY29weShzb3VyY2UudjIpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dG9KU09OKCkge1xuXHRcdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXHRcdFx0ZGF0YS52MCA9IHRoaXMudjAudG9BcnJheSgpO1xuXHRcdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0ZnJvbUpTT04oanNvbikge1xuXHRcdFx0c3VwZXIuZnJvbUpTT04oanNvbik7XG5cdFx0XHR0aGlzLnYwLmZyb21BcnJheShqc29uLnYwKTtcblx0XHRcdHRoaXMudjEuZnJvbUFycmF5KGpzb24udjEpO1xuXHRcdFx0dGhpcy52Mi5mcm9tQXJyYXkoanNvbi52Mik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdFF1YWRyYXRpY0JlemllckN1cnZlMy5wcm90b3R5cGUuaXNRdWFkcmF0aWNCZXppZXJDdXJ2ZTMgPSB0cnVlO1xuXG5cdGNsYXNzIFNwbGluZUN1cnZlIGV4dGVuZHMgQ3VydmUge1xuXHRcdGNvbnN0cnVjdG9yKHBvaW50cyA9IFtdKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ1NwbGluZUN1cnZlJztcblx0XHRcdHRoaXMucG9pbnRzID0gcG9pbnRzO1xuXHRcdH1cblxuXHRcdGdldFBvaW50KHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjIoKSkge1xuXHRcdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblx0XHRcdGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHRcdFx0Y29uc3QgcCA9IChwb2ludHMubGVuZ3RoIC0gMSkgKiB0O1xuXHRcdFx0Y29uc3QgaW50UG9pbnQgPSBNYXRoLmZsb29yKHApO1xuXHRcdFx0Y29uc3Qgd2VpZ2h0ID0gcCAtIGludFBvaW50O1xuXHRcdFx0Y29uc3QgcDAgPSBwb2ludHNbaW50UG9pbnQgPT09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMV07XG5cdFx0XHRjb25zdCBwMSA9IHBvaW50c1tpbnRQb2ludF07XG5cdFx0XHRjb25zdCBwMiA9IHBvaW50c1tpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAyID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDFdO1xuXHRcdFx0Y29uc3QgcDMgPSBwb2ludHNbaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMyA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyXTtcblx0XHRcdHBvaW50LnNldChDYXRtdWxsUm9tKHdlaWdodCwgcDAueCwgcDEueCwgcDIueCwgcDMueCksIENhdG11bGxSb20od2VpZ2h0LCBwMC55LCBwMS55LCBwMi55LCBwMy55KSk7XG5cdFx0XHRyZXR1cm4gcG9pbnQ7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdHRoaXMucG9pbnRzID0gW107XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gc291cmNlLnBvaW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgcG9pbnQgPSBzb3VyY2UucG9pbnRzW2ldO1xuXHRcdFx0XHR0aGlzLnBvaW50cy5wdXNoKHBvaW50LmNsb25lKCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0b0pTT04oKSB7XG5cdFx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cdFx0XHRkYXRhLnBvaW50cyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBwb2ludCA9IHRoaXMucG9pbnRzW2ldO1xuXHRcdFx0XHRkYXRhLnBvaW50cy5wdXNoKHBvaW50LnRvQXJyYXkoKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdGZyb21KU09OKGpzb24pIHtcblx0XHRcdHN1cGVyLmZyb21KU09OKGpzb24pO1xuXHRcdFx0dGhpcy5wb2ludHMgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBqc29uLnBvaW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgcG9pbnQgPSBqc29uLnBvaW50c1tpXTtcblx0XHRcdFx0dGhpcy5wb2ludHMucHVzaChuZXcgVmVjdG9yMigpLmZyb21BcnJheShwb2ludCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdFNwbGluZUN1cnZlLnByb3RvdHlwZS5pc1NwbGluZUN1cnZlID0gdHJ1ZTtcblxuXHR2YXIgQ3VydmVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRcdF9fcHJvdG9fXzogbnVsbCxcblx0XHRBcmNDdXJ2ZTogQXJjQ3VydmUsXG5cdFx0Q2F0bXVsbFJvbUN1cnZlMzogQ2F0bXVsbFJvbUN1cnZlMyxcblx0XHRDdWJpY0JlemllckN1cnZlOiBDdWJpY0JlemllckN1cnZlLFxuXHRcdEN1YmljQmV6aWVyQ3VydmUzOiBDdWJpY0JlemllckN1cnZlMyxcblx0XHRFbGxpcHNlQ3VydmU6IEVsbGlwc2VDdXJ2ZSxcblx0XHRMaW5lQ3VydmU6IExpbmVDdXJ2ZSxcblx0XHRMaW5lQ3VydmUzOiBMaW5lQ3VydmUzLFxuXHRcdFF1YWRyYXRpY0JlemllckN1cnZlOiBRdWFkcmF0aWNCZXppZXJDdXJ2ZSxcblx0XHRRdWFkcmF0aWNCZXppZXJDdXJ2ZTM6IFF1YWRyYXRpY0JlemllckN1cnZlMyxcblx0XHRTcGxpbmVDdXJ2ZTogU3BsaW5lQ3VydmVcblx0fSk7XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCAqXHRDdXJ2ZWQgUGF0aCAtIGEgY3VydmUgcGF0aCBpcyBzaW1wbHkgYSBhcnJheSBvZiBjb25uZWN0ZWRcblx0ICpcdGN1cnZlcywgYnV0IHJldGFpbnMgdGhlIGFwaSBvZiBhIGN1cnZlXG5cdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRjbGFzcyBDdXJ2ZVBhdGggZXh0ZW5kcyBDdXJ2ZSB7XG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ0N1cnZlUGF0aCc7XG5cdFx0XHR0aGlzLmN1cnZlcyA9IFtdO1xuXHRcdFx0dGhpcy5hdXRvQ2xvc2UgPSBmYWxzZTsgLy8gQXV0b21hdGljYWxseSBjbG9zZXMgdGhlIHBhdGhcblx0XHR9XG5cblx0XHRhZGQoY3VydmUpIHtcblx0XHRcdHRoaXMuY3VydmVzLnB1c2goY3VydmUpO1xuXHRcdH1cblxuXHRcdGNsb3NlUGF0aCgpIHtcblx0XHRcdC8vIEFkZCBhIGxpbmUgY3VydmUgaWYgc3RhcnQgYW5kIGVuZCBvZiBsaW5lcyBhcmUgbm90IGNvbm5lY3RlZFxuXHRcdFx0Y29uc3Qgc3RhcnRQb2ludCA9IHRoaXMuY3VydmVzWzBdLmdldFBvaW50KDApO1xuXHRcdFx0Y29uc3QgZW5kUG9pbnQgPSB0aGlzLmN1cnZlc1t0aGlzLmN1cnZlcy5sZW5ndGggLSAxXS5nZXRQb2ludCgxKTtcblxuXHRcdFx0aWYgKCFzdGFydFBvaW50LmVxdWFscyhlbmRQb2ludCkpIHtcblx0XHRcdFx0dGhpcy5jdXJ2ZXMucHVzaChuZXcgTGluZUN1cnZlKGVuZFBvaW50LCBzdGFydFBvaW50KSk7XG5cdFx0XHR9XG5cdFx0fSAvLyBUbyBnZXQgYWNjdXJhdGUgcG9pbnQgd2l0aCByZWZlcmVuY2UgdG9cblx0XHQvLyBlbnRpcmUgcGF0aCBkaXN0YW5jZSBhdCB0aW1lIHQsXG5cdFx0Ly8gZm9sbG93aW5nIGhhcyB0byBiZSBkb25lOlxuXHRcdC8vIDEuIExlbmd0aCBvZiBlYWNoIHN1YiBwYXRoIGhhdmUgdG8gYmUga25vd25cblx0XHQvLyAyLiBMb2NhdGUgYW5kIGlkZW50aWZ5IHR5cGUgb2YgY3VydmVcblx0XHQvLyAzLiBHZXQgdCBmb3IgdGhlIGN1cnZlXG5cdFx0Ly8gNC4gUmV0dXJuIGN1cnZlLmdldFBvaW50QXQodCcpXG5cblxuXHRcdGdldFBvaW50KHQsIG9wdGlvbmFsVGFyZ2V0KSB7XG5cdFx0XHRjb25zdCBkID0gdCAqIHRoaXMuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRjb25zdCBjdXJ2ZUxlbmd0aHMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuXHRcdFx0bGV0IGkgPSAwOyAvLyBUbyB0aGluayBhYm91dCBib3VuZGFyaWVzIHBvaW50cy5cblxuXHRcdFx0d2hpbGUgKGkgPCBjdXJ2ZUxlbmd0aHMubGVuZ3RoKSB7XG5cdFx0XHRcdGlmIChjdXJ2ZUxlbmd0aHNbaV0gPj0gZCkge1xuXHRcdFx0XHRcdGNvbnN0IGRpZmYgPSBjdXJ2ZUxlbmd0aHNbaV0gLSBkO1xuXHRcdFx0XHRcdGNvbnN0IGN1cnZlID0gdGhpcy5jdXJ2ZXNbaV07XG5cdFx0XHRcdFx0Y29uc3Qgc2VnbWVudExlbmd0aCA9IGN1cnZlLmdldExlbmd0aCgpO1xuXHRcdFx0XHRcdGNvbnN0IHUgPSBzZWdtZW50TGVuZ3RoID09PSAwID8gMCA6IDEgLSBkaWZmIC8gc2VnbWVudExlbmd0aDtcblx0XHRcdFx0XHRyZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCh1LCBvcHRpb25hbFRhcmdldCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpKys7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsOyAvLyBsb29wIHdoZXJlIHN1bSAhPSAwLCBzdW0gPiBkICwgc3VtKzEgPGRcblx0XHR9IC8vIFdlIGNhbm5vdCB1c2UgdGhlIGRlZmF1bHQgVEhSRUUuQ3VydmUgZ2V0UG9pbnQoKSB3aXRoIGdldExlbmd0aCgpIGJlY2F1c2UgaW5cblx0XHQvLyBUSFJFRS5DdXJ2ZSwgZ2V0TGVuZ3RoKCkgZGVwZW5kcyBvbiBnZXRQb2ludCgpIGJ1dCBpbiBUSFJFRS5DdXJ2ZVBhdGhcblx0XHQvLyBnZXRQb2ludCgpIGRlcGVuZHMgb24gZ2V0TGVuZ3RoXG5cblxuXHRcdGdldExlbmd0aCgpIHtcblx0XHRcdGNvbnN0IGxlbnMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuXHRcdFx0cmV0dXJuIGxlbnNbbGVucy5sZW5ndGggLSAxXTtcblx0XHR9IC8vIGNhY2hlTGVuZ3RocyBtdXN0IGJlIHJlY2FsY3VsYXRlZC5cblxuXG5cdFx0dXBkYXRlQXJjTGVuZ3RocygpIHtcblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0dGhpcy5jYWNoZUxlbmd0aHMgPSBudWxsO1xuXHRcdFx0dGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtcblx0XHR9IC8vIENvbXB1dGUgbGVuZ3RocyBhbmQgY2FjaGUgdGhlbVxuXHRcdC8vIFdlIGNhbm5vdCBvdmVyd3JpdGUgZ2V0TGVuZ3RocygpIGJlY2F1c2UgVXRvVCBtYXBwaW5nIHVzZXMgaXQuXG5cblxuXHRcdGdldEN1cnZlTGVuZ3RocygpIHtcblx0XHRcdC8vIFdlIHVzZSBjYWNoZSB2YWx1ZXMgaWYgY3VydmVzIGFuZCBjYWNoZSBhcnJheSBhcmUgc2FtZSBsZW5ndGhcblx0XHRcdGlmICh0aGlzLmNhY2hlTGVuZ3RocyAmJiB0aGlzLmNhY2hlTGVuZ3Rocy5sZW5ndGggPT09IHRoaXMuY3VydmVzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jYWNoZUxlbmd0aHM7XG5cdFx0XHR9IC8vIEdldCBsZW5ndGggb2Ygc3ViLWN1cnZlXG5cdFx0XHQvLyBQdXNoIHN1bXMgaW50byBjYWNoZWQgYXJyYXlcblxuXG5cdFx0XHRjb25zdCBsZW5ndGhzID0gW107XG5cdFx0XHRsZXQgc3VtcyA9IDA7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHN1bXMgKz0gdGhpcy5jdXJ2ZXNbaV0uZ2V0TGVuZ3RoKCk7XG5cdFx0XHRcdGxlbmd0aHMucHVzaChzdW1zKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5jYWNoZUxlbmd0aHMgPSBsZW5ndGhzO1xuXHRcdFx0cmV0dXJuIGxlbmd0aHM7XG5cdFx0fVxuXG5cdFx0Z2V0U3BhY2VkUG9pbnRzKGRpdmlzaW9ucyA9IDQwKSB7XG5cdFx0XHRjb25zdCBwb2ludHMgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPD0gZGl2aXNpb25zOyBpKyspIHtcblx0XHRcdFx0cG9pbnRzLnB1c2godGhpcy5nZXRQb2ludChpIC8gZGl2aXNpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmF1dG9DbG9zZSkge1xuXHRcdFx0XHRwb2ludHMucHVzaChwb2ludHNbMF0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcG9pbnRzO1xuXHRcdH1cblxuXHRcdGdldFBvaW50cyhkaXZpc2lvbnMgPSAxMikge1xuXHRcdFx0Y29uc3QgcG9pbnRzID0gW107XG5cdFx0XHRsZXQgbGFzdDtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGN1cnZlcyA9IHRoaXMuY3VydmVzOyBpIDwgY3VydmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGN1cnZlID0gY3VydmVzW2ldO1xuXHRcdFx0XHRjb25zdCByZXNvbHV0aW9uID0gY3VydmUgJiYgY3VydmUuaXNFbGxpcHNlQ3VydmUgPyBkaXZpc2lvbnMgKiAyIDogY3VydmUgJiYgKGN1cnZlLmlzTGluZUN1cnZlIHx8IGN1cnZlLmlzTGluZUN1cnZlMykgPyAxIDogY3VydmUgJiYgY3VydmUuaXNTcGxpbmVDdXJ2ZSA/IGRpdmlzaW9ucyAqIGN1cnZlLnBvaW50cy5sZW5ndGggOiBkaXZpc2lvbnM7XG5cdFx0XHRcdGNvbnN0IHB0cyA9IGN1cnZlLmdldFBvaW50cyhyZXNvbHV0aW9uKTtcblxuXHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IHB0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdGNvbnN0IHBvaW50ID0gcHRzW2pdO1xuXHRcdFx0XHRcdGlmIChsYXN0ICYmIGxhc3QuZXF1YWxzKHBvaW50KSkgY29udGludWU7IC8vIGVuc3VyZXMgbm8gY29uc2VjdXRpdmUgcG9pbnRzIGFyZSBkdXBsaWNhdGVzXG5cblx0XHRcdFx0XHRwb2ludHMucHVzaChwb2ludCk7XG5cdFx0XHRcdFx0bGFzdCA9IHBvaW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmF1dG9DbG9zZSAmJiBwb2ludHMubGVuZ3RoID4gMSAmJiAhcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXS5lcXVhbHMocG9pbnRzWzBdKSkge1xuXHRcdFx0XHRwb2ludHMucHVzaChwb2ludHNbMF0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcG9pbnRzO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLmN1cnZlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHNvdXJjZS5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGN1cnZlID0gc291cmNlLmN1cnZlc1tpXTtcblx0XHRcdFx0dGhpcy5jdXJ2ZXMucHVzaChjdXJ2ZS5jbG9uZSgpKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5hdXRvQ2xvc2UgPSBzb3VyY2UuYXV0b0Nsb3NlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dG9KU09OKCkge1xuXHRcdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXHRcdFx0ZGF0YS5hdXRvQ2xvc2UgPSB0aGlzLmF1dG9DbG9zZTtcblx0XHRcdGRhdGEuY3VydmVzID0gW107XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGN1cnZlID0gdGhpcy5jdXJ2ZXNbaV07XG5cdFx0XHRcdGRhdGEuY3VydmVzLnB1c2goY3VydmUudG9KU09OKCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHRmcm9tSlNPTihqc29uKSB7XG5cdFx0XHRzdXBlci5mcm9tSlNPTihqc29uKTtcblx0XHRcdHRoaXMuYXV0b0Nsb3NlID0ganNvbi5hdXRvQ2xvc2U7XG5cdFx0XHR0aGlzLmN1cnZlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGpzb24uY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBjdXJ2ZSA9IGpzb24uY3VydmVzW2ldO1xuXHRcdFx0XHR0aGlzLmN1cnZlcy5wdXNoKG5ldyBDdXJ2ZXNbY3VydmUudHlwZV0oKS5mcm9tSlNPTihjdXJ2ZSkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIFBhdGggZXh0ZW5kcyBDdXJ2ZVBhdGgge1xuXHRcdGNvbnN0cnVjdG9yKHBvaW50cykge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdQYXRoJztcblx0XHRcdHRoaXMuY3VycmVudFBvaW50ID0gbmV3IFZlY3RvcjIoKTtcblxuXHRcdFx0aWYgKHBvaW50cykge1xuXHRcdFx0XHR0aGlzLnNldEZyb21Qb2ludHMocG9pbnRzKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzZXRGcm9tUG9pbnRzKHBvaW50cykge1xuXHRcdFx0dGhpcy5tb3ZlVG8ocG9pbnRzWzBdLngsIHBvaW50c1swXS55KTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDEsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMubGluZVRvKHBvaW50c1tpXS54LCBwb2ludHNbaV0ueSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdG1vdmVUbyh4LCB5KSB7XG5cdFx0XHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoeCwgeSk7IC8vIFRPRE8gY29uc2lkZXIgcmVmZXJlbmNpbmcgdmVjdG9ycyBpbnN0ZWFkIG9mIGNvcHlpbmc/XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGxpbmVUbyh4LCB5KSB7XG5cdFx0XHRjb25zdCBjdXJ2ZSA9IG5ldyBMaW5lQ3VydmUodGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSwgbmV3IFZlY3RvcjIoeCwgeSkpO1xuXHRcdFx0dGhpcy5jdXJ2ZXMucHVzaChjdXJ2ZSk7XG5cdFx0XHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoeCwgeSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRxdWFkcmF0aWNDdXJ2ZVRvKGFDUHgsIGFDUHksIGFYLCBhWSkge1xuXHRcdFx0Y29uc3QgY3VydmUgPSBuZXcgUXVhZHJhdGljQmV6aWVyQ3VydmUodGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSwgbmV3IFZlY3RvcjIoYUNQeCwgYUNQeSksIG5ldyBWZWN0b3IyKGFYLCBhWSkpO1xuXHRcdFx0dGhpcy5jdXJ2ZXMucHVzaChjdXJ2ZSk7XG5cdFx0XHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoYVgsIGFZKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGJlemllckN1cnZlVG8oYUNQMXgsIGFDUDF5LCBhQ1AyeCwgYUNQMnksIGFYLCBhWSkge1xuXHRcdFx0Y29uc3QgY3VydmUgPSBuZXcgQ3ViaWNCZXppZXJDdXJ2ZSh0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpLCBuZXcgVmVjdG9yMihhQ1AxeCwgYUNQMXkpLCBuZXcgVmVjdG9yMihhQ1AyeCwgYUNQMnkpLCBuZXcgVmVjdG9yMihhWCwgYVkpKTtcblx0XHRcdHRoaXMuY3VydmVzLnB1c2goY3VydmUpO1xuXHRcdFx0dGhpcy5jdXJyZW50UG9pbnQuc2V0KGFYLCBhWSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzcGxpbmVUaHJ1KHB0c1xuXHRcdC8qQXJyYXkgb2YgVmVjdG9yKi9cblx0XHQpIHtcblx0XHRcdGNvbnN0IG5wdHMgPSBbdGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKV0uY29uY2F0KHB0cyk7XG5cdFx0XHRjb25zdCBjdXJ2ZSA9IG5ldyBTcGxpbmVDdXJ2ZShucHRzKTtcblx0XHRcdHRoaXMuY3VydmVzLnB1c2goY3VydmUpO1xuXHRcdFx0dGhpcy5jdXJyZW50UG9pbnQuY29weShwdHNbcHRzLmxlbmd0aCAtIDFdKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGFyYyhhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UpIHtcblx0XHRcdGNvbnN0IHgwID0gdGhpcy5jdXJyZW50UG9pbnQueDtcblx0XHRcdGNvbnN0IHkwID0gdGhpcy5jdXJyZW50UG9pbnQueTtcblx0XHRcdHRoaXMuYWJzYXJjKGFYICsgeDAsIGFZICsgeTAsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0YWJzYXJjKGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSkge1xuXHRcdFx0dGhpcy5hYnNlbGxpcHNlKGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRlbGxpcHNlKGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uKSB7XG5cdFx0XHRjb25zdCB4MCA9IHRoaXMuY3VycmVudFBvaW50Lng7XG5cdFx0XHRjb25zdCB5MCA9IHRoaXMuY3VycmVudFBvaW50Lnk7XG5cdFx0XHR0aGlzLmFic2VsbGlwc2UoYVggKyB4MCwgYVkgKyB5MCwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGFic2VsbGlwc2UoYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24pIHtcblx0XHRcdGNvbnN0IGN1cnZlID0gbmV3IEVsbGlwc2VDdXJ2ZShhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbik7XG5cblx0XHRcdGlmICh0aGlzLmN1cnZlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdC8vIGlmIGEgcHJldmlvdXMgY3VydmUgaXMgcHJlc2VudCwgYXR0ZW1wdCB0byBqb2luXG5cdFx0XHRcdGNvbnN0IGZpcnN0UG9pbnQgPSBjdXJ2ZS5nZXRQb2ludCgwKTtcblxuXHRcdFx0XHRpZiAoIWZpcnN0UG9pbnQuZXF1YWxzKHRoaXMuY3VycmVudFBvaW50KSkge1xuXHRcdFx0XHRcdHRoaXMubGluZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmN1cnZlcy5wdXNoKGN1cnZlKTtcblx0XHRcdGNvbnN0IGxhc3RQb2ludCA9IGN1cnZlLmdldFBvaW50KDEpO1xuXHRcdFx0dGhpcy5jdXJyZW50UG9pbnQuY29weShsYXN0UG9pbnQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdHRoaXMuY3VycmVudFBvaW50LmNvcHkoc291cmNlLmN1cnJlbnRQb2ludCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0b0pTT04oKSB7XG5cdFx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cdFx0XHRkYXRhLmN1cnJlbnRQb2ludCA9IHRoaXMuY3VycmVudFBvaW50LnRvQXJyYXkoKTtcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdGZyb21KU09OKGpzb24pIHtcblx0XHRcdHN1cGVyLmZyb21KU09OKGpzb24pO1xuXHRcdFx0dGhpcy5jdXJyZW50UG9pbnQuZnJvbUFycmF5KGpzb24uY3VycmVudFBvaW50KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgU2hhcGUgZXh0ZW5kcyBQYXRoIHtcblx0XHRjb25zdHJ1Y3Rvcihwb2ludHMpIHtcblx0XHRcdHN1cGVyKHBvaW50cyk7XG5cdFx0XHR0aGlzLnV1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdTaGFwZSc7XG5cdFx0XHR0aGlzLmhvbGVzID0gW107XG5cdFx0fVxuXG5cdFx0Z2V0UG9pbnRzSG9sZXMoZGl2aXNpb25zKSB7XG5cdFx0XHRjb25zdCBob2xlc1B0cyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGhvbGVzUHRzW2ldID0gdGhpcy5ob2xlc1tpXS5nZXRQb2ludHMoZGl2aXNpb25zKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGhvbGVzUHRzO1xuXHRcdH0gLy8gZ2V0IHBvaW50cyBvZiBzaGFwZSBhbmQgaG9sZXMgKGtleXBvaW50cyBiYXNlZCBvbiBzZWdtZW50cyBwYXJhbWV0ZXIpXG5cblxuXHRcdGV4dHJhY3RQb2ludHMoZGl2aXNpb25zKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzaGFwZTogdGhpcy5nZXRQb2ludHMoZGl2aXNpb25zKSxcblx0XHRcdFx0aG9sZXM6IHRoaXMuZ2V0UG9pbnRzSG9sZXMoZGl2aXNpb25zKVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0dGhpcy5ob2xlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHNvdXJjZS5ob2xlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgaG9sZSA9IHNvdXJjZS5ob2xlc1tpXTtcblx0XHRcdFx0dGhpcy5ob2xlcy5wdXNoKGhvbGUuY2xvbmUoKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRvSlNPTigpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblx0XHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcblx0XHRcdGRhdGEuaG9sZXMgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBob2xlID0gdGhpcy5ob2xlc1tpXTtcblx0XHRcdFx0ZGF0YS5ob2xlcy5wdXNoKGhvbGUudG9KU09OKCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHRmcm9tSlNPTihqc29uKSB7XG5cdFx0XHRzdXBlci5mcm9tSlNPTihqc29uKTtcblx0XHRcdHRoaXMudXVpZCA9IGpzb24udXVpZDtcblx0XHRcdHRoaXMuaG9sZXMgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBqc29uLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBob2xlID0ganNvbi5ob2xlc1tpXTtcblx0XHRcdFx0dGhpcy5ob2xlcy5wdXNoKG5ldyBQYXRoKCkuZnJvbUpTT04oaG9sZSkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBQb3J0IGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9lYXJjdXQgKHYyLjIuMilcblx0ICovXG5cdGNvbnN0IEVhcmN1dCA9IHtcblx0XHR0cmlhbmd1bGF0ZTogZnVuY3Rpb24gKGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0gPSAyKSB7XG5cdFx0XHRjb25zdCBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aDtcblx0XHRcdGNvbnN0IG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuXHRcdFx0bGV0IG91dGVyTm9kZSA9IGxpbmtlZExpc3QoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSwgdHJ1ZSk7XG5cdFx0XHRjb25zdCB0cmlhbmdsZXMgPSBbXTtcblx0XHRcdGlmICghb3V0ZXJOb2RlIHx8IG91dGVyTm9kZS5uZXh0ID09PSBvdXRlck5vZGUucHJldikgcmV0dXJuIHRyaWFuZ2xlcztcblx0XHRcdGxldCBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCB4LCB5LCBpbnZTaXplO1xuXHRcdFx0aWYgKGhhc0hvbGVzKSBvdXRlck5vZGUgPSBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pOyAvLyBpZiB0aGUgc2hhcGUgaXMgbm90IHRvbyBzaW1wbGUsIHdlJ2xsIHVzZSB6LW9yZGVyIGN1cnZlIGhhc2ggbGF0ZXI7IGNhbGN1bGF0ZSBwb2x5Z29uIGJib3hcblxuXHRcdFx0aWYgKGRhdGEubGVuZ3RoID4gODAgKiBkaW0pIHtcblx0XHRcdFx0bWluWCA9IG1heFggPSBkYXRhWzBdO1xuXHRcdFx0XHRtaW5ZID0gbWF4WSA9IGRhdGFbMV07XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IGRpbTsgaSA8IG91dGVyTGVuOyBpICs9IGRpbSkge1xuXHRcdFx0XHRcdHggPSBkYXRhW2ldO1xuXHRcdFx0XHRcdHkgPSBkYXRhW2kgKyAxXTtcblx0XHRcdFx0XHRpZiAoeCA8IG1pblgpIG1pblggPSB4O1xuXHRcdFx0XHRcdGlmICh5IDwgbWluWSkgbWluWSA9IHk7XG5cdFx0XHRcdFx0aWYgKHggPiBtYXhYKSBtYXhYID0geDtcblx0XHRcdFx0XHRpZiAoeSA+IG1heFkpIG1heFkgPSB5O1xuXHRcdFx0XHR9IC8vIG1pblgsIG1pblkgYW5kIGludlNpemUgYXJlIGxhdGVyIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkcyBpbnRvIGludGVnZXJzIGZvciB6LW9yZGVyIGNhbGN1bGF0aW9uXG5cblxuXHRcdFx0XHRpbnZTaXplID0gTWF0aC5tYXgobWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcblx0XHRcdFx0aW52U2l6ZSA9IGludlNpemUgIT09IDAgPyAxIC8gaW52U2l6ZSA6IDA7XG5cdFx0XHR9XG5cblx0XHRcdGVhcmN1dExpbmtlZChvdXRlck5vZGUsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcblx0XHRcdHJldHVybiB0cmlhbmdsZXM7XG5cdFx0fVxuXHR9OyAvLyBjcmVhdGUgYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QgZnJvbSBwb2x5Z29uIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcblxuXHRmdW5jdGlvbiBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgY2xvY2t3aXNlKSB7XG5cdFx0bGV0IGksIGxhc3Q7XG5cblx0XHRpZiAoY2xvY2t3aXNlID09PSBzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkgPiAwKSB7XG5cdFx0XHRmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChpID0gZW5kIC0gZGltOyBpID49IHN0YXJ0OyBpIC09IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuXHRcdH1cblxuXHRcdGlmIChsYXN0ICYmIGVxdWFscyhsYXN0LCBsYXN0Lm5leHQpKSB7XG5cdFx0XHRyZW1vdmVOb2RlKGxhc3QpO1xuXHRcdFx0bGFzdCA9IGxhc3QubmV4dDtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGFzdDtcblx0fSAvLyBlbGltaW5hdGUgY29saW5lYXIgb3IgZHVwbGljYXRlIHBvaW50c1xuXG5cblx0ZnVuY3Rpb24gZmlsdGVyUG9pbnRzKHN0YXJ0LCBlbmQpIHtcblx0XHRpZiAoIXN0YXJ0KSByZXR1cm4gc3RhcnQ7XG5cdFx0aWYgKCFlbmQpIGVuZCA9IHN0YXJ0O1xuXHRcdGxldCBwID0gc3RhcnQsXG5cdFx0XHRcdGFnYWluO1xuXG5cdFx0ZG8ge1xuXHRcdFx0YWdhaW4gPSBmYWxzZTtcblxuXHRcdFx0aWYgKCFwLnN0ZWluZXIgJiYgKGVxdWFscyhwLCBwLm5leHQpIHx8IGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID09PSAwKSkge1xuXHRcdFx0XHRyZW1vdmVOb2RlKHApO1xuXHRcdFx0XHRwID0gZW5kID0gcC5wcmV2O1xuXHRcdFx0XHRpZiAocCA9PT0gcC5uZXh0KSBicmVhaztcblx0XHRcdFx0YWdhaW4gPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cCA9IHAubmV4dDtcblx0XHRcdH1cblx0XHR9IHdoaWxlIChhZ2FpbiB8fCBwICE9PSBlbmQpO1xuXG5cdFx0cmV0dXJuIGVuZDtcblx0fSAvLyBtYWluIGVhciBzbGljaW5nIGxvb3Agd2hpY2ggdHJpYW5ndWxhdGVzIGEgcG9seWdvbiAoZ2l2ZW4gYXMgYSBsaW5rZWQgbGlzdClcblxuXG5cdGZ1bmN0aW9uIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCBwYXNzKSB7XG5cdFx0aWYgKCFlYXIpIHJldHVybjsgLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuXG5cdFx0aWYgKCFwYXNzICYmIGludlNpemUpIGluZGV4Q3VydmUoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcblx0XHRsZXQgc3RvcCA9IGVhcixcblx0XHRcdFx0cHJldixcblx0XHRcdFx0bmV4dDsgLy8gaXRlcmF0ZSB0aHJvdWdoIGVhcnMsIHNsaWNpbmcgdGhlbSBvbmUgYnkgb25lXG5cblx0XHR3aGlsZSAoZWFyLnByZXYgIT09IGVhci5uZXh0KSB7XG5cdFx0XHRwcmV2ID0gZWFyLnByZXY7XG5cdFx0XHRuZXh0ID0gZWFyLm5leHQ7XG5cblx0XHRcdGlmIChpbnZTaXplID8gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSA6IGlzRWFyKGVhcikpIHtcblx0XHRcdFx0Ly8gY3V0IG9mZiB0aGUgdHJpYW5nbGVcblx0XHRcdFx0dHJpYW5nbGVzLnB1c2gocHJldi5pIC8gZGltKTtcblx0XHRcdFx0dHJpYW5nbGVzLnB1c2goZWFyLmkgLyBkaW0pO1xuXHRcdFx0XHR0cmlhbmdsZXMucHVzaChuZXh0LmkgLyBkaW0pO1xuXHRcdFx0XHRyZW1vdmVOb2RlKGVhcik7IC8vIHNraXBwaW5nIHRoZSBuZXh0IHZlcnRleCBsZWFkcyB0byBsZXNzIHNsaXZlciB0cmlhbmdsZXNcblxuXHRcdFx0XHRlYXIgPSBuZXh0Lm5leHQ7XG5cdFx0XHRcdHN0b3AgPSBuZXh0Lm5leHQ7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRlYXIgPSBuZXh0OyAvLyBpZiB3ZSBsb29wZWQgdGhyb3VnaCB0aGUgd2hvbGUgcmVtYWluaW5nIHBvbHlnb24gYW5kIGNhbid0IGZpbmQgYW55IG1vcmUgZWFyc1xuXG5cdFx0XHRpZiAoZWFyID09PSBzdG9wKSB7XG5cdFx0XHRcdC8vIHRyeSBmaWx0ZXJpbmcgcG9pbnRzIGFuZCBzbGljaW5nIGFnYWluXG5cdFx0XHRcdGlmICghcGFzcykge1xuXHRcdFx0XHRcdGVhcmN1dExpbmtlZChmaWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDEpOyAvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxuXHRcdFx0XHR9IGVsc2UgaWYgKHBhc3MgPT09IDEpIHtcblx0XHRcdFx0XHRlYXIgPSBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKGZpbHRlclBvaW50cyhlYXIpLCB0cmlhbmdsZXMsIGRpbSk7XG5cdFx0XHRcdFx0ZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDIpOyAvLyBhcyBhIGxhc3QgcmVzb3J0LCB0cnkgc3BsaXR0aW5nIHRoZSByZW1haW5pbmcgcG9seWdvbiBpbnRvIHR3b1xuXHRcdFx0XHR9IGVsc2UgaWYgKHBhc3MgPT09IDIpIHtcblx0XHRcdFx0XHRzcGxpdEVhcmN1dChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fSAvLyBjaGVjayB3aGV0aGVyIGEgcG9seWdvbiBub2RlIGZvcm1zIGEgdmFsaWQgZWFyIHdpdGggYWRqYWNlbnQgbm9kZXNcblxuXG5cdGZ1bmN0aW9uIGlzRWFyKGVhcikge1xuXHRcdGNvbnN0IGEgPSBlYXIucHJldixcblx0XHRcdFx0XHRiID0gZWFyLFxuXHRcdFx0XHRcdGMgPSBlYXIubmV4dDtcblx0XHRpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cdFx0Ly8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIG90aGVyIHBvaW50cyBpbnNpZGUgdGhlIHBvdGVudGlhbCBlYXJcblxuXHRcdGxldCBwID0gZWFyLm5leHQubmV4dDtcblxuXHRcdHdoaWxlIChwICE9PSBlYXIucHJldikge1xuXHRcdFx0aWYgKHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiYgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0cCA9IHAubmV4dDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuXHRcdGNvbnN0IGEgPSBlYXIucHJldixcblx0XHRcdFx0XHRiID0gZWFyLFxuXHRcdFx0XHRcdGMgPSBlYXIubmV4dDtcblx0XHRpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cdFx0Ly8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcblxuXHRcdGNvbnN0IG1pblRYID0gYS54IDwgYi54ID8gYS54IDwgYy54ID8gYS54IDogYy54IDogYi54IDwgYy54ID8gYi54IDogYy54LFxuXHRcdFx0XHRcdG1pblRZID0gYS55IDwgYi55ID8gYS55IDwgYy55ID8gYS55IDogYy55IDogYi55IDwgYy55ID8gYi55IDogYy55LFxuXHRcdFx0XHRcdG1heFRYID0gYS54ID4gYi54ID8gYS54ID4gYy54ID8gYS54IDogYy54IDogYi54ID4gYy54ID8gYi54IDogYy54LFxuXHRcdFx0XHRcdG1heFRZID0gYS55ID4gYi55ID8gYS55ID4gYy55ID8gYS55IDogYy55IDogYi55ID4gYy55ID8gYi55IDogYy55OyAvLyB6LW9yZGVyIHJhbmdlIGZvciB0aGUgY3VycmVudCB0cmlhbmdsZSBiYm94O1xuXG5cdFx0Y29uc3QgbWluWiA9IHpPcmRlcihtaW5UWCwgbWluVFksIG1pblgsIG1pblksIGludlNpemUpLFxuXHRcdFx0XHRcdG1heFogPSB6T3JkZXIobWF4VFgsIG1heFRZLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcblx0XHRsZXQgcCA9IGVhci5wcmV2Wixcblx0XHRcdFx0biA9IGVhci5uZXh0WjsgLy8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgaW4gYm90aCBkaXJlY3Rpb25zXG5cblx0XHR3aGlsZSAocCAmJiBwLnogPj0gbWluWiAmJiBuICYmIG4ueiA8PSBtYXhaKSB7XG5cdFx0XHRpZiAocCAhPT0gZWFyLnByZXYgJiYgcCAhPT0gZWFyLm5leHQgJiYgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJiBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRwID0gcC5wcmV2Wjtcblx0XHRcdGlmIChuICE9PSBlYXIucHJldiAmJiBuICE9PSBlYXIubmV4dCAmJiBwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgbi54LCBuLnkpICYmIGFyZWEobi5wcmV2LCBuLCBuLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcblx0XHRcdG4gPSBuLm5leHRaO1xuXHRcdH0gLy8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBkZWNyZWFzaW5nIHotb3JkZXJcblxuXG5cdFx0d2hpbGUgKHAgJiYgcC56ID49IG1pblopIHtcblx0XHRcdGlmIChwICE9PSBlYXIucHJldiAmJiBwICE9PSBlYXIubmV4dCAmJiBwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcblx0XHRcdHAgPSBwLnByZXZaO1xuXHRcdH0gLy8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBpbmNyZWFzaW5nIHotb3JkZXJcblxuXG5cdFx0d2hpbGUgKG4gJiYgbi56IDw9IG1heFopIHtcblx0XHRcdGlmIChuICE9PSBlYXIucHJldiAmJiBuICE9PSBlYXIubmV4dCAmJiBwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgbi54LCBuLnkpICYmIGFyZWEobi5wcmV2LCBuLCBuLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcblx0XHRcdG4gPSBuLm5leHRaO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IC8vIGdvIHRocm91Z2ggYWxsIHBvbHlnb24gbm9kZXMgYW5kIGN1cmUgc21hbGwgbG9jYWwgc2VsZi1pbnRlcnNlY3Rpb25zXG5cblxuXHRmdW5jdGlvbiBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSkge1xuXHRcdGxldCBwID0gc3RhcnQ7XG5cblx0XHRkbyB7XG5cdFx0XHRjb25zdCBhID0gcC5wcmV2LFxuXHRcdFx0XHRcdFx0YiA9IHAubmV4dC5uZXh0O1xuXG5cdFx0XHRpZiAoIWVxdWFscyhhLCBiKSAmJiBpbnRlcnNlY3RzKGEsIHAsIHAubmV4dCwgYikgJiYgbG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpKSB7XG5cdFx0XHRcdHRyaWFuZ2xlcy5wdXNoKGEuaSAvIGRpbSk7XG5cdFx0XHRcdHRyaWFuZ2xlcy5wdXNoKHAuaSAvIGRpbSk7XG5cdFx0XHRcdHRyaWFuZ2xlcy5wdXNoKGIuaSAvIGRpbSk7IC8vIHJlbW92ZSB0d28gbm9kZXMgaW52b2x2ZWRcblxuXHRcdFx0XHRyZW1vdmVOb2RlKHApO1xuXHRcdFx0XHRyZW1vdmVOb2RlKHAubmV4dCk7XG5cdFx0XHRcdHAgPSBzdGFydCA9IGI7XG5cdFx0XHR9XG5cblx0XHRcdHAgPSBwLm5leHQ7XG5cdFx0fSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG5cdFx0cmV0dXJuIGZpbHRlclBvaW50cyhwKTtcblx0fSAvLyB0cnkgc3BsaXR0aW5nIHBvbHlnb24gaW50byB0d28gYW5kIHRyaWFuZ3VsYXRlIHRoZW0gaW5kZXBlbmRlbnRseVxuXG5cblx0ZnVuY3Rpb24gc3BsaXRFYXJjdXQoc3RhcnQsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG5cdFx0Ly8gbG9vayBmb3IgYSB2YWxpZCBkaWFnb25hbCB0aGF0IGRpdmlkZXMgdGhlIHBvbHlnb24gaW50byB0d29cblx0XHRsZXQgYSA9IHN0YXJ0O1xuXG5cdFx0ZG8ge1xuXHRcdFx0bGV0IGIgPSBhLm5leHQubmV4dDtcblxuXHRcdFx0d2hpbGUgKGIgIT09IGEucHJldikge1xuXHRcdFx0XHRpZiAoYS5pICE9PSBiLmkgJiYgaXNWYWxpZERpYWdvbmFsKGEsIGIpKSB7XG5cdFx0XHRcdFx0Ly8gc3BsaXQgdGhlIHBvbHlnb24gaW4gdHdvIGJ5IHRoZSBkaWFnb25hbFxuXHRcdFx0XHRcdGxldCBjID0gc3BsaXRQb2x5Z29uKGEsIGIpOyAvLyBmaWx0ZXIgY29saW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuXG5cdFx0XHRcdFx0YSA9IGZpbHRlclBvaW50cyhhLCBhLm5leHQpO1xuXHRcdFx0XHRcdGMgPSBmaWx0ZXJQb2ludHMoYywgYy5uZXh0KTsgLy8gcnVuIGVhcmN1dCBvbiBlYWNoIGhhbGZcblxuXHRcdFx0XHRcdGVhcmN1dExpbmtlZChhLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG5cdFx0XHRcdFx0ZWFyY3V0TGlua2VkKGMsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiID0gYi5uZXh0O1xuXHRcdFx0fVxuXG5cdFx0XHRhID0gYS5uZXh0O1xuXHRcdH0gd2hpbGUgKGEgIT09IHN0YXJ0KTtcblx0fSAvLyBsaW5rIGV2ZXJ5IGhvbGUgaW50byB0aGUgb3V0ZXIgbG9vcCwgcHJvZHVjaW5nIGEgc2luZ2xlLXJpbmcgcG9seWdvbiB3aXRob3V0IGhvbGVzXG5cblxuXHRmdW5jdGlvbiBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pIHtcblx0XHRjb25zdCBxdWV1ZSA9IFtdO1xuXHRcdGxldCBpLCBsZW4sIHN0YXJ0LCBlbmQsIGxpc3Q7XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0c3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcblx0XHRcdGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG5cdFx0XHRsaXN0ID0gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGZhbHNlKTtcblx0XHRcdGlmIChsaXN0ID09PSBsaXN0Lm5leHQpIGxpc3Quc3RlaW5lciA9IHRydWU7XG5cdFx0XHRxdWV1ZS5wdXNoKGdldExlZnRtb3N0KGxpc3QpKTtcblx0XHR9XG5cblx0XHRxdWV1ZS5zb3J0KGNvbXBhcmVYKTsgLy8gcHJvY2VzcyBob2xlcyBmcm9tIGxlZnQgdG8gcmlnaHRcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0ZWxpbWluYXRlSG9sZShxdWV1ZVtpXSwgb3V0ZXJOb2RlKTtcblx0XHRcdG91dGVyTm9kZSA9IGZpbHRlclBvaW50cyhvdXRlck5vZGUsIG91dGVyTm9kZS5uZXh0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0ZXJOb2RlO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29tcGFyZVgoYSwgYikge1xuXHRcdHJldHVybiBhLnggLSBiLng7XG5cdH0gLy8gZmluZCBhIGJyaWRnZSBiZXR3ZWVuIHZlcnRpY2VzIHRoYXQgY29ubmVjdHMgaG9sZSB3aXRoIGFuIG91dGVyIHJpbmcgYW5kIGFuZCBsaW5rIGl0XG5cblxuXHRmdW5jdGlvbiBlbGltaW5hdGVIb2xlKGhvbGUsIG91dGVyTm9kZSkge1xuXHRcdG91dGVyTm9kZSA9IGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSk7XG5cblx0XHRpZiAob3V0ZXJOb2RlKSB7XG5cdFx0XHRjb25zdCBiID0gc3BsaXRQb2x5Z29uKG91dGVyTm9kZSwgaG9sZSk7IC8vIGZpbHRlciBjb2xsaW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuXG5cdFx0XHRmaWx0ZXJQb2ludHMob3V0ZXJOb2RlLCBvdXRlck5vZGUubmV4dCk7XG5cdFx0XHRmaWx0ZXJQb2ludHMoYiwgYi5uZXh0KTtcblx0XHR9XG5cdH0gLy8gRGF2aWQgRWJlcmx5J3MgYWxnb3JpdGhtIGZvciBmaW5kaW5nIGEgYnJpZGdlIGJldHdlZW4gaG9sZSBhbmQgb3V0ZXIgcG9seWdvblxuXG5cblx0ZnVuY3Rpb24gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKSB7XG5cdFx0bGV0IHAgPSBvdXRlck5vZGU7XG5cdFx0Y29uc3QgaHggPSBob2xlLng7XG5cdFx0Y29uc3QgaHkgPSBob2xlLnk7XG5cdFx0bGV0IHF4ID0gLUluZmluaXR5LFxuXHRcdFx0XHRtOyAvLyBmaW5kIGEgc2VnbWVudCBpbnRlcnNlY3RlZCBieSBhIHJheSBmcm9tIHRoZSBob2xlJ3MgbGVmdG1vc3QgcG9pbnQgdG8gdGhlIGxlZnQ7XG5cdFx0Ly8gc2VnbWVudCdzIGVuZHBvaW50IHdpdGggbGVzc2VyIHggd2lsbCBiZSBwb3RlbnRpYWwgY29ubmVjdGlvbiBwb2ludFxuXG5cdFx0ZG8ge1xuXHRcdFx0aWYgKGh5IDw9IHAueSAmJiBoeSA+PSBwLm5leHQueSAmJiBwLm5leHQueSAhPT0gcC55KSB7XG5cdFx0XHRcdGNvbnN0IHggPSBwLnggKyAoaHkgLSBwLnkpICogKHAubmV4dC54IC0gcC54KSAvIChwLm5leHQueSAtIHAueSk7XG5cblx0XHRcdFx0aWYgKHggPD0gaHggJiYgeCA+IHF4KSB7XG5cdFx0XHRcdFx0cXggPSB4O1xuXG5cdFx0XHRcdFx0aWYgKHggPT09IGh4KSB7XG5cdFx0XHRcdFx0XHRpZiAoaHkgPT09IHAueSkgcmV0dXJuIHA7XG5cdFx0XHRcdFx0XHRpZiAoaHkgPT09IHAubmV4dC55KSByZXR1cm4gcC5uZXh0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG0gPSBwLnggPCBwLm5leHQueCA/IHAgOiBwLm5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cCA9IHAubmV4dDtcblx0XHR9IHdoaWxlIChwICE9PSBvdXRlck5vZGUpO1xuXG5cdFx0aWYgKCFtKSByZXR1cm4gbnVsbDtcblx0XHRpZiAoaHggPT09IHF4KSByZXR1cm4gbTsgLy8gaG9sZSB0b3VjaGVzIG91dGVyIHNlZ21lbnQ7IHBpY2sgbGVmdG1vc3QgZW5kcG9pbnRcblx0XHQvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBvZiBob2xlIHBvaW50LCBzZWdtZW50IGludGVyc2VjdGlvbiBhbmQgZW5kcG9pbnQ7XG5cdFx0Ly8gaWYgdGhlcmUgYXJlIG5vIHBvaW50cyBmb3VuZCwgd2UgaGF2ZSBhIHZhbGlkIGNvbm5lY3Rpb247XG5cdFx0Ly8gb3RoZXJ3aXNlIGNob29zZSB0aGUgcG9pbnQgb2YgdGhlIG1pbmltdW0gYW5nbGUgd2l0aCB0aGUgcmF5IGFzIGNvbm5lY3Rpb24gcG9pbnRcblxuXHRcdGNvbnN0IHN0b3AgPSBtLFxuXHRcdFx0XHRcdG14ID0gbS54LFxuXHRcdFx0XHRcdG15ID0gbS55O1xuXHRcdGxldCB0YW5NaW4gPSBJbmZpbml0eSxcblx0XHRcdFx0dGFuO1xuXHRcdHAgPSBtO1xuXG5cdFx0ZG8ge1xuXHRcdFx0aWYgKGh4ID49IHAueCAmJiBwLnggPj0gbXggJiYgaHggIT09IHAueCAmJiBwb2ludEluVHJpYW5nbGUoaHkgPCBteSA/IGh4IDogcXgsIGh5LCBteCwgbXksIGh5IDwgbXkgPyBxeCA6IGh4LCBoeSwgcC54LCBwLnkpKSB7XG5cdFx0XHRcdHRhbiA9IE1hdGguYWJzKGh5IC0gcC55KSAvIChoeCAtIHAueCk7IC8vIHRhbmdlbnRpYWxcblxuXHRcdFx0XHRpZiAobG9jYWxseUluc2lkZShwLCBob2xlKSAmJiAodGFuIDwgdGFuTWluIHx8IHRhbiA9PT0gdGFuTWluICYmIChwLnggPiBtLnggfHwgcC54ID09PSBtLnggJiYgc2VjdG9yQ29udGFpbnNTZWN0b3IobSwgcCkpKSkge1xuXHRcdFx0XHRcdG0gPSBwO1xuXHRcdFx0XHRcdHRhbk1pbiA9IHRhbjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRwID0gcC5uZXh0O1xuXHRcdH0gd2hpbGUgKHAgIT09IHN0b3ApO1xuXG5cdFx0cmV0dXJuIG07XG5cdH0gLy8gd2hldGhlciBzZWN0b3IgaW4gdmVydGV4IG0gY29udGFpbnMgc2VjdG9yIGluIHZlcnRleCBwIGluIHRoZSBzYW1lIGNvb3JkaW5hdGVzXG5cblxuXHRmdW5jdGlvbiBzZWN0b3JDb250YWluc1NlY3RvcihtLCBwKSB7XG5cdFx0cmV0dXJuIGFyZWEobS5wcmV2LCBtLCBwLnByZXYpIDwgMCAmJiBhcmVhKHAubmV4dCwgbSwgbS5uZXh0KSA8IDA7XG5cdH0gLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuXG5cblx0ZnVuY3Rpb24gaW5kZXhDdXJ2ZShzdGFydCwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuXHRcdGxldCBwID0gc3RhcnQ7XG5cblx0XHRkbyB7XG5cdFx0XHRpZiAocC56ID09PSBudWxsKSBwLnogPSB6T3JkZXIocC54LCBwLnksIG1pblgsIG1pblksIGludlNpemUpO1xuXHRcdFx0cC5wcmV2WiA9IHAucHJldjtcblx0XHRcdHAubmV4dFogPSBwLm5leHQ7XG5cdFx0XHRwID0gcC5uZXh0O1xuXHRcdH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuXHRcdHAucHJldloubmV4dFogPSBudWxsO1xuXHRcdHAucHJldlogPSBudWxsO1xuXHRcdHNvcnRMaW5rZWQocCk7XG5cdH0gLy8gU2ltb24gVGF0aGFtJ3MgbGlua2VkIGxpc3QgbWVyZ2Ugc29ydCBhbGdvcml0aG1cblx0Ly8gaHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9hbGdvcml0aG1zL2xpc3Rzb3J0Lmh0bWxcblxuXG5cdGZ1bmN0aW9uIHNvcnRMaW5rZWQobGlzdCkge1xuXHRcdGxldCBpLFxuXHRcdFx0XHRwLFxuXHRcdFx0XHRxLFxuXHRcdFx0XHRlLFxuXHRcdFx0XHR0YWlsLFxuXHRcdFx0XHRudW1NZXJnZXMsXG5cdFx0XHRcdHBTaXplLFxuXHRcdFx0XHRxU2l6ZSxcblx0XHRcdFx0aW5TaXplID0gMTtcblxuXHRcdGRvIHtcblx0XHRcdHAgPSBsaXN0O1xuXHRcdFx0bGlzdCA9IG51bGw7XG5cdFx0XHR0YWlsID0gbnVsbDtcblx0XHRcdG51bU1lcmdlcyA9IDA7XG5cblx0XHRcdHdoaWxlIChwKSB7XG5cdFx0XHRcdG51bU1lcmdlcysrO1xuXHRcdFx0XHRxID0gcDtcblx0XHRcdFx0cFNpemUgPSAwO1xuXG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBpblNpemU7IGkrKykge1xuXHRcdFx0XHRcdHBTaXplKys7XG5cdFx0XHRcdFx0cSA9IHEubmV4dFo7XG5cdFx0XHRcdFx0aWYgKCFxKSBicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHFTaXplID0gaW5TaXplO1xuXG5cdFx0XHRcdHdoaWxlIChwU2l6ZSA+IDAgfHwgcVNpemUgPiAwICYmIHEpIHtcblx0XHRcdFx0XHRpZiAocFNpemUgIT09IDAgJiYgKHFTaXplID09PSAwIHx8ICFxIHx8IHAueiA8PSBxLnopKSB7XG5cdFx0XHRcdFx0XHRlID0gcDtcblx0XHRcdFx0XHRcdHAgPSBwLm5leHRaO1xuXHRcdFx0XHRcdFx0cFNpemUtLTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZSA9IHE7XG5cdFx0XHRcdFx0XHRxID0gcS5uZXh0Wjtcblx0XHRcdFx0XHRcdHFTaXplLS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHRhaWwpIHRhaWwubmV4dFogPSBlO2Vsc2UgbGlzdCA9IGU7XG5cdFx0XHRcdFx0ZS5wcmV2WiA9IHRhaWw7XG5cdFx0XHRcdFx0dGFpbCA9IGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwID0gcTtcblx0XHRcdH1cblxuXHRcdFx0dGFpbC5uZXh0WiA9IG51bGw7XG5cdFx0XHRpblNpemUgKj0gMjtcblx0XHR9IHdoaWxlIChudW1NZXJnZXMgPiAxKTtcblxuXHRcdHJldHVybiBsaXN0O1xuXHR9IC8vIHotb3JkZXIgb2YgYSBwb2ludCBnaXZlbiBjb29yZHMgYW5kIGludmVyc2Ugb2YgdGhlIGxvbmdlciBzaWRlIG9mIGRhdGEgYmJveFxuXG5cblx0ZnVuY3Rpb24gek9yZGVyKHgsIHksIG1pblgsIG1pblksIGludlNpemUpIHtcblx0XHQvLyBjb29yZHMgYXJlIHRyYW5zZm9ybWVkIGludG8gbm9uLW5lZ2F0aXZlIDE1LWJpdCBpbnRlZ2VyIHJhbmdlXG5cdFx0eCA9IDMyNzY3ICogKHggLSBtaW5YKSAqIGludlNpemU7XG5cdFx0eSA9IDMyNzY3ICogKHkgLSBtaW5ZKSAqIGludlNpemU7XG5cdFx0eCA9ICh4IHwgeCA8PCA4KSAmIDB4MDBGRjAwRkY7XG5cdFx0eCA9ICh4IHwgeCA8PCA0KSAmIDB4MEYwRjBGMEY7XG5cdFx0eCA9ICh4IHwgeCA8PCAyKSAmIDB4MzMzMzMzMzM7XG5cdFx0eCA9ICh4IHwgeCA8PCAxKSAmIDB4NTU1NTU1NTU7XG5cdFx0eSA9ICh5IHwgeSA8PCA4KSAmIDB4MDBGRjAwRkY7XG5cdFx0eSA9ICh5IHwgeSA8PCA0KSAmIDB4MEYwRjBGMEY7XG5cdFx0eSA9ICh5IHwgeSA8PCAyKSAmIDB4MzMzMzMzMzM7XG5cdFx0eSA9ICh5IHwgeSA8PCAxKSAmIDB4NTU1NTU1NTU7XG5cdFx0cmV0dXJuIHggfCB5IDw8IDE7XG5cdH0gLy8gZmluZCB0aGUgbGVmdG1vc3Qgbm9kZSBvZiBhIHBvbHlnb24gcmluZ1xuXG5cblx0ZnVuY3Rpb24gZ2V0TGVmdG1vc3Qoc3RhcnQpIHtcblx0XHRsZXQgcCA9IHN0YXJ0LFxuXHRcdFx0XHRsZWZ0bW9zdCA9IHN0YXJ0O1xuXG5cdFx0ZG8ge1xuXHRcdFx0aWYgKHAueCA8IGxlZnRtb3N0LnggfHwgcC54ID09PSBsZWZ0bW9zdC54ICYmIHAueSA8IGxlZnRtb3N0LnkpIGxlZnRtb3N0ID0gcDtcblx0XHRcdHAgPSBwLm5leHQ7XG5cdFx0fSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG5cdFx0cmV0dXJuIGxlZnRtb3N0O1xuXHR9IC8vIGNoZWNrIGlmIGEgcG9pbnQgbGllcyB3aXRoaW4gYSBjb252ZXggdHJpYW5nbGVcblxuXG5cdGZ1bmN0aW9uIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBweCwgcHkpIHtcblx0XHRyZXR1cm4gKGN4IC0gcHgpICogKGF5IC0gcHkpIC0gKGF4IC0gcHgpICogKGN5IC0gcHkpID49IDAgJiYgKGF4IC0gcHgpICogKGJ5IC0gcHkpIC0gKGJ4IC0gcHgpICogKGF5IC0gcHkpID49IDAgJiYgKGJ4IC0gcHgpICogKGN5IC0gcHkpIC0gKGN4IC0gcHgpICogKGJ5IC0gcHkpID49IDA7XG5cdH0gLy8gY2hlY2sgaWYgYSBkaWFnb25hbCBiZXR3ZWVuIHR3byBwb2x5Z29uIG5vZGVzIGlzIHZhbGlkIChsaWVzIGluIHBvbHlnb24gaW50ZXJpb3IpXG5cblxuXHRmdW5jdGlvbiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikge1xuXHRcdHJldHVybiBhLm5leHQuaSAhPT0gYi5pICYmIGEucHJldi5pICE9PSBiLmkgJiYgIWludGVyc2VjdHNQb2x5Z29uKGEsIGIpICYmICggLy8gZG9uZXMndCBpbnRlcnNlY3Qgb3RoZXIgZWRnZXNcblx0XHRsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkgJiYgbWlkZGxlSW5zaWRlKGEsIGIpICYmICggLy8gbG9jYWxseSB2aXNpYmxlXG5cdFx0YXJlYShhLnByZXYsIGEsIGIucHJldikgfHwgYXJlYShhLCBiLnByZXYsIGIpKSB8fCAvLyBkb2VzIG5vdCBjcmVhdGUgb3Bwb3NpdGUtZmFjaW5nIHNlY3RvcnNcblx0XHRlcXVhbHMoYSwgYikgJiYgYXJlYShhLnByZXYsIGEsIGEubmV4dCkgPiAwICYmIGFyZWEoYi5wcmV2LCBiLCBiLm5leHQpID4gMCk7IC8vIHNwZWNpYWwgemVyby1sZW5ndGggY2FzZVxuXHR9IC8vIHNpZ25lZCBhcmVhIG9mIGEgdHJpYW5nbGVcblxuXG5cdGZ1bmN0aW9uIGFyZWEocCwgcSwgcikge1xuXHRcdHJldHVybiAocS55IC0gcC55KSAqIChyLnggLSBxLngpIC0gKHEueCAtIHAueCkgKiAoci55IC0gcS55KTtcblx0fSAvLyBjaGVjayBpZiB0d28gcG9pbnRzIGFyZSBlcXVhbFxuXG5cblx0ZnVuY3Rpb24gZXF1YWxzKHAxLCBwMikge1xuXHRcdHJldHVybiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnk7XG5cdH0gLy8gY2hlY2sgaWYgdHdvIHNlZ21lbnRzIGludGVyc2VjdFxuXG5cblx0ZnVuY3Rpb24gaW50ZXJzZWN0cyhwMSwgcTEsIHAyLCBxMikge1xuXHRcdGNvbnN0IG8xID0gc2lnbihhcmVhKHAxLCBxMSwgcDIpKTtcblx0XHRjb25zdCBvMiA9IHNpZ24oYXJlYShwMSwgcTEsIHEyKSk7XG5cdFx0Y29uc3QgbzMgPSBzaWduKGFyZWEocDIsIHEyLCBwMSkpO1xuXHRcdGNvbnN0IG80ID0gc2lnbihhcmVhKHAyLCBxMiwgcTEpKTtcblx0XHRpZiAobzEgIT09IG8yICYmIG8zICE9PSBvNCkgcmV0dXJuIHRydWU7IC8vIGdlbmVyYWwgY2FzZVxuXG5cdFx0aWYgKG8xID09PSAwICYmIG9uU2VnbWVudChwMSwgcDIsIHExKSkgcmV0dXJuIHRydWU7IC8vIHAxLCBxMSBhbmQgcDIgYXJlIGNvbGxpbmVhciBhbmQgcDIgbGllcyBvbiBwMXExXG5cblx0XHRpZiAobzIgPT09IDAgJiYgb25TZWdtZW50KHAxLCBxMiwgcTEpKSByZXR1cm4gdHJ1ZTsgLy8gcDEsIHExIGFuZCBxMiBhcmUgY29sbGluZWFyIGFuZCBxMiBsaWVzIG9uIHAxcTFcblxuXHRcdGlmIChvMyA9PT0gMCAmJiBvblNlZ21lbnQocDIsIHAxLCBxMikpIHJldHVybiB0cnVlOyAvLyBwMiwgcTIgYW5kIHAxIGFyZSBjb2xsaW5lYXIgYW5kIHAxIGxpZXMgb24gcDJxMlxuXG5cdFx0aWYgKG80ID09PSAwICYmIG9uU2VnbWVudChwMiwgcTEsIHEyKSkgcmV0dXJuIHRydWU7IC8vIHAyLCBxMiBhbmQgcTEgYXJlIGNvbGxpbmVhciBhbmQgcTEgbGllcyBvbiBwMnEyXG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gLy8gZm9yIGNvbGxpbmVhciBwb2ludHMgcCwgcSwgciwgY2hlY2sgaWYgcG9pbnQgcSBsaWVzIG9uIHNlZ21lbnQgcHJcblxuXG5cdGZ1bmN0aW9uIG9uU2VnbWVudChwLCBxLCByKSB7XG5cdFx0cmV0dXJuIHEueCA8PSBNYXRoLm1heChwLngsIHIueCkgJiYgcS54ID49IE1hdGgubWluKHAueCwgci54KSAmJiBxLnkgPD0gTWF0aC5tYXgocC55LCByLnkpICYmIHEueSA+PSBNYXRoLm1pbihwLnksIHIueSk7XG5cdH1cblxuXHRmdW5jdGlvbiBzaWduKG51bSkge1xuXHRcdHJldHVybiBudW0gPiAwID8gMSA6IG51bSA8IDAgPyAtMSA6IDA7XG5cdH0gLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGludGVyc2VjdHMgYW55IHBvbHlnb24gc2VnbWVudHNcblxuXG5cdGZ1bmN0aW9uIGludGVyc2VjdHNQb2x5Z29uKGEsIGIpIHtcblx0XHRsZXQgcCA9IGE7XG5cblx0XHRkbyB7XG5cdFx0XHRpZiAocC5pICE9PSBhLmkgJiYgcC5uZXh0LmkgIT09IGEuaSAmJiBwLmkgIT09IGIuaSAmJiBwLm5leHQuaSAhPT0gYi5pICYmIGludGVyc2VjdHMocCwgcC5uZXh0LCBhLCBiKSkgcmV0dXJuIHRydWU7XG5cdFx0XHRwID0gcC5uZXh0O1xuXHRcdH0gd2hpbGUgKHAgIT09IGEpO1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IC8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpcyBsb2NhbGx5IGluc2lkZSB0aGUgcG9seWdvblxuXG5cblx0ZnVuY3Rpb24gbG9jYWxseUluc2lkZShhLCBiKSB7XG5cdFx0cmV0dXJuIGFyZWEoYS5wcmV2LCBhLCBhLm5leHQpIDwgMCA/IGFyZWEoYSwgYiwgYS5uZXh0KSA+PSAwICYmIGFyZWEoYSwgYS5wcmV2LCBiKSA+PSAwIDogYXJlYShhLCBiLCBhLnByZXYpIDwgMCB8fCBhcmVhKGEsIGEubmV4dCwgYikgPCAwO1xuXHR9IC8vIGNoZWNrIGlmIHRoZSBtaWRkbGUgcG9pbnQgb2YgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGluc2lkZSB0aGUgcG9seWdvblxuXG5cblx0ZnVuY3Rpb24gbWlkZGxlSW5zaWRlKGEsIGIpIHtcblx0XHRsZXQgcCA9IGEsXG5cdFx0XHRcdGluc2lkZSA9IGZhbHNlO1xuXHRcdGNvbnN0IHB4ID0gKGEueCArIGIueCkgLyAyLFxuXHRcdFx0XHRcdHB5ID0gKGEueSArIGIueSkgLyAyO1xuXG5cdFx0ZG8ge1xuXHRcdFx0aWYgKHAueSA+IHB5ICE9PSBwLm5leHQueSA+IHB5ICYmIHAubmV4dC55ICE9PSBwLnkgJiYgcHggPCAocC5uZXh0LnggLSBwLngpICogKHB5IC0gcC55KSAvIChwLm5leHQueSAtIHAueSkgKyBwLngpIGluc2lkZSA9ICFpbnNpZGU7XG5cdFx0XHRwID0gcC5uZXh0O1xuXHRcdH0gd2hpbGUgKHAgIT09IGEpO1xuXG5cdFx0cmV0dXJuIGluc2lkZTtcblx0fSAvLyBsaW5rIHR3byBwb2x5Z29uIHZlcnRpY2VzIHdpdGggYSBicmlkZ2U7IGlmIHRoZSB2ZXJ0aWNlcyBiZWxvbmcgdG8gdGhlIHNhbWUgcmluZywgaXQgc3BsaXRzIHBvbHlnb24gaW50byB0d287XG5cdC8vIGlmIG9uZSBiZWxvbmdzIHRvIHRoZSBvdXRlciByaW5nIGFuZCBhbm90aGVyIHRvIGEgaG9sZSwgaXQgbWVyZ2VzIGl0IGludG8gYSBzaW5nbGUgcmluZ1xuXG5cblx0ZnVuY3Rpb24gc3BsaXRQb2x5Z29uKGEsIGIpIHtcblx0XHRjb25zdCBhMiA9IG5ldyBOb2RlKGEuaSwgYS54LCBhLnkpLFxuXHRcdFx0XHRcdGIyID0gbmV3IE5vZGUoYi5pLCBiLngsIGIueSksXG5cdFx0XHRcdFx0YW4gPSBhLm5leHQsXG5cdFx0XHRcdFx0YnAgPSBiLnByZXY7XG5cdFx0YS5uZXh0ID0gYjtcblx0XHRiLnByZXYgPSBhO1xuXHRcdGEyLm5leHQgPSBhbjtcblx0XHRhbi5wcmV2ID0gYTI7XG5cdFx0YjIubmV4dCA9IGEyO1xuXHRcdGEyLnByZXYgPSBiMjtcblx0XHRicC5uZXh0ID0gYjI7XG5cdFx0YjIucHJldiA9IGJwO1xuXHRcdHJldHVybiBiMjtcblx0fSAvLyBjcmVhdGUgYSBub2RlIGFuZCBvcHRpb25hbGx5IGxpbmsgaXQgd2l0aCBwcmV2aW91cyBvbmUgKGluIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0KVxuXG5cblx0ZnVuY3Rpb24gaW5zZXJ0Tm9kZShpLCB4LCB5LCBsYXN0KSB7XG5cdFx0Y29uc3QgcCA9IG5ldyBOb2RlKGksIHgsIHkpO1xuXG5cdFx0aWYgKCFsYXN0KSB7XG5cdFx0XHRwLnByZXYgPSBwO1xuXHRcdFx0cC5uZXh0ID0gcDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cC5uZXh0ID0gbGFzdC5uZXh0O1xuXHRcdFx0cC5wcmV2ID0gbGFzdDtcblx0XHRcdGxhc3QubmV4dC5wcmV2ID0gcDtcblx0XHRcdGxhc3QubmV4dCA9IHA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHA7XG5cdH1cblxuXHRmdW5jdGlvbiByZW1vdmVOb2RlKHApIHtcblx0XHRwLm5leHQucHJldiA9IHAucHJldjtcblx0XHRwLnByZXYubmV4dCA9IHAubmV4dDtcblx0XHRpZiAocC5wcmV2WikgcC5wcmV2Wi5uZXh0WiA9IHAubmV4dFo7XG5cdFx0aWYgKHAubmV4dFopIHAubmV4dFoucHJldlogPSBwLnByZXZaO1xuXHR9XG5cblx0ZnVuY3Rpb24gTm9kZShpLCB4LCB5KSB7XG5cdFx0Ly8gdmVydGV4IGluZGV4IGluIGNvb3JkaW5hdGVzIGFycmF5XG5cdFx0dGhpcy5pID0gaTsgLy8gdmVydGV4IGNvb3JkaW5hdGVzXG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7IC8vIHByZXZpb3VzIGFuZCBuZXh0IHZlcnRleCBub2RlcyBpbiBhIHBvbHlnb24gcmluZ1xuXG5cdFx0dGhpcy5wcmV2ID0gbnVsbDtcblx0XHR0aGlzLm5leHQgPSBudWxsOyAvLyB6LW9yZGVyIGN1cnZlIHZhbHVlXG5cblx0XHR0aGlzLnogPSBudWxsOyAvLyBwcmV2aW91cyBhbmQgbmV4dCBub2RlcyBpbiB6LW9yZGVyXG5cblx0XHR0aGlzLnByZXZaID0gbnVsbDtcblx0XHR0aGlzLm5leHRaID0gbnVsbDsgLy8gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhIHN0ZWluZXIgcG9pbnRcblxuXHRcdHRoaXMuc3RlaW5lciA9IGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pIHtcblx0XHRsZXQgc3VtID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSBzdGFydCwgaiA9IGVuZCAtIGRpbTsgaSA8IGVuZDsgaSArPSBkaW0pIHtcblx0XHRcdHN1bSArPSAoZGF0YVtqXSAtIGRhdGFbaV0pICogKGRhdGFbaSArIDFdICsgZGF0YVtqICsgMV0pO1xuXHRcdFx0aiA9IGk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN1bTtcblx0fVxuXG5cdGNsYXNzIFNoYXBlVXRpbHMge1xuXHRcdC8vIGNhbGN1bGF0ZSBhcmVhIG9mIHRoZSBjb250b3VyIHBvbHlnb25cblx0XHRzdGF0aWMgYXJlYShjb250b3VyKSB7XG5cdFx0XHRjb25zdCBuID0gY29udG91ci5sZW5ndGg7XG5cdFx0XHRsZXQgYSA9IDAuMDtcblxuXHRcdFx0Zm9yIChsZXQgcCA9IG4gLSAxLCBxID0gMDsgcSA8IG47IHAgPSBxKyspIHtcblx0XHRcdFx0YSArPSBjb250b3VyW3BdLnggKiBjb250b3VyW3FdLnkgLSBjb250b3VyW3FdLnggKiBjb250b3VyW3BdLnk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhICogMC41O1xuXHRcdH1cblxuXHRcdHN0YXRpYyBpc0Nsb2NrV2lzZShwdHMpIHtcblx0XHRcdHJldHVybiBTaGFwZVV0aWxzLmFyZWEocHRzKSA8IDA7XG5cdFx0fVxuXG5cdFx0c3RhdGljIHRyaWFuZ3VsYXRlU2hhcGUoY29udG91ciwgaG9sZXMpIHtcblx0XHRcdGNvbnN0IHZlcnRpY2VzID0gW107IC8vIGZsYXQgYXJyYXkgb2YgdmVydGljZXMgbGlrZSBbIHgwLHkwLCB4MSx5MSwgeDIseTIsIC4uLiBdXG5cblx0XHRcdGNvbnN0IGhvbGVJbmRpY2VzID0gW107IC8vIGFycmF5IG9mIGhvbGUgaW5kaWNlc1xuXG5cdFx0XHRjb25zdCBmYWNlcyA9IFtdOyAvLyBmaW5hbCBhcnJheSBvZiB2ZXJ0ZXggaW5kaWNlcyBsaWtlIFsgWyBhLGIsZCBdLCBbIGIsYyxkIF0gXVxuXG5cdFx0XHRyZW1vdmVEdXBFbmRQdHMoY29udG91cik7XG5cdFx0XHRhZGRDb250b3VyKHZlcnRpY2VzLCBjb250b3VyKTsgLy9cblxuXHRcdFx0bGV0IGhvbGVJbmRleCA9IGNvbnRvdXIubGVuZ3RoO1xuXHRcdFx0aG9sZXMuZm9yRWFjaChyZW1vdmVEdXBFbmRQdHMpO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGhvbGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGhvbGVJbmRpY2VzLnB1c2goaG9sZUluZGV4KTtcblx0XHRcdFx0aG9sZUluZGV4ICs9IGhvbGVzW2ldLmxlbmd0aDtcblx0XHRcdFx0YWRkQ29udG91cih2ZXJ0aWNlcywgaG9sZXNbaV0pO1xuXHRcdFx0fSAvL1xuXG5cblx0XHRcdGNvbnN0IHRyaWFuZ2xlcyA9IEVhcmN1dC50cmlhbmd1bGF0ZSh2ZXJ0aWNlcywgaG9sZUluZGljZXMpOyAvL1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0XHRmYWNlcy5wdXNoKHRyaWFuZ2xlcy5zbGljZShpLCBpICsgMykpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFjZXM7XG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiByZW1vdmVEdXBFbmRQdHMocG9pbnRzKSB7XG5cdFx0Y29uc3QgbCA9IHBvaW50cy5sZW5ndGg7XG5cblx0XHRpZiAobCA+IDIgJiYgcG9pbnRzW2wgLSAxXS5lcXVhbHMocG9pbnRzWzBdKSkge1xuXHRcdFx0cG9pbnRzLnBvcCgpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGFkZENvbnRvdXIodmVydGljZXMsIGNvbnRvdXIpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRvdXIubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZlcnRpY2VzLnB1c2goY29udG91cltpXS54KTtcblx0XHRcdHZlcnRpY2VzLnB1c2goY29udG91cltpXS55KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBleHRydWRlZCBnZW9tZXRyeSBmcm9tIGEgcGF0aCBzaGFwZS5cblx0ICpcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICpcblx0ICpcdGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXNcblx0ICpcdHN0ZXBzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBmb3Igei1zaWRlIGV4dHJ1c2lvbnMgLyB1c2VkIGZvciBzdWJkaXZpZGluZyBzZWdtZW50cyBvZiBleHRydWRlIHNwbGluZSB0b29cblx0ICpcdGRlcHRoOiA8ZmxvYXQ+LCAvLyBEZXB0aCB0byBleHRydWRlIHRoZSBzaGFwZVxuXHQgKlxuXHQgKlx0YmV2ZWxFbmFibGVkOiA8Ym9vbD4sIC8vIHR1cm4gb24gYmV2ZWxcblx0ICpcdGJldmVsVGhpY2tuZXNzOiA8ZmxvYXQ+LCAvLyBob3cgZGVlcCBpbnRvIHRoZSBvcmlnaW5hbCBzaGFwZSBiZXZlbCBnb2VzXG5cdCAqXHRiZXZlbFNpemU6IDxmbG9hdD4sIC8vIGhvdyBmYXIgZnJvbSBzaGFwZSBvdXRsaW5lIChpbmNsdWRpbmcgYmV2ZWxPZmZzZXQpIGlzIGJldmVsXG5cdCAqXHRiZXZlbE9mZnNldDogPGZsb2F0PiwgLy8gaG93IGZhciBmcm9tIHNoYXBlIG91dGxpbmUgZG9lcyBiZXZlbCBzdGFydFxuXHQgKlx0YmV2ZWxTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBiZXZlbCBsYXllcnNcblx0ICpcblx0ICpcdGV4dHJ1ZGVQYXRoOiA8VEhSRUUuQ3VydmU+IC8vIGN1cnZlIHRvIGV4dHJ1ZGUgc2hhcGUgYWxvbmdcblx0ICpcblx0ICpcdFVWR2VuZXJhdG9yOiA8T2JqZWN0PiAvLyBvYmplY3QgdGhhdCBwcm92aWRlcyBVViBnZW5lcmF0b3IgZnVuY3Rpb25zXG5cdCAqXG5cdCAqIH1cblx0ICovXG5cblx0Y2xhc3MgRXh0cnVkZUdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXHRcdGNvbnN0cnVjdG9yKHNoYXBlcyA9IG5ldyBTaGFwZShbbmV3IFZlY3RvcjIoMC41LCAwLjUpLCBuZXcgVmVjdG9yMigtMC41LCAwLjUpLCBuZXcgVmVjdG9yMigtMC41LCAtMC41KSwgbmV3IFZlY3RvcjIoMC41LCAtMC41KV0pLCBvcHRpb25zID0ge30pIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnRXh0cnVkZUdlb21ldHJ5Jztcblx0XHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdFx0c2hhcGVzOiBzaGFwZXMsXG5cdFx0XHRcdG9wdGlvbnM6IG9wdGlvbnNcblx0XHRcdH07XG5cdFx0XHRzaGFwZXMgPSBBcnJheS5pc0FycmF5KHNoYXBlcykgPyBzaGFwZXMgOiBbc2hhcGVzXTtcblx0XHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblx0XHRcdGNvbnN0IHZlcnRpY2VzQXJyYXkgPSBbXTtcblx0XHRcdGNvbnN0IHV2QXJyYXkgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHNoYXBlID0gc2hhcGVzW2ldO1xuXHRcdFx0XHRhZGRTaGFwZShzaGFwZSk7XG5cdFx0XHR9IC8vIGJ1aWxkIGdlb21ldHJ5XG5cblxuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXNBcnJheSwgMykpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodXZBcnJheSwgMikpO1xuXHRcdFx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpOyAvLyBmdW5jdGlvbnNcblxuXHRcdFx0ZnVuY3Rpb24gYWRkU2hhcGUoc2hhcGUpIHtcblx0XHRcdFx0Y29uc3QgcGxhY2Vob2xkZXIgPSBbXTsgLy8gb3B0aW9uc1xuXG5cdFx0XHRcdGNvbnN0IGN1cnZlU2VnbWVudHMgPSBvcHRpb25zLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3VydmVTZWdtZW50cyA6IDEyO1xuXHRcdFx0XHRjb25zdCBzdGVwcyA9IG9wdGlvbnMuc3RlcHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RlcHMgOiAxO1xuXHRcdFx0XHRsZXQgZGVwdGggPSBvcHRpb25zLmRlcHRoICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlcHRoIDogMTtcblx0XHRcdFx0bGV0IGJldmVsRW5hYmxlZCA9IG9wdGlvbnMuYmV2ZWxFbmFibGVkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsRW5hYmxlZCA6IHRydWU7XG5cdFx0XHRcdGxldCBiZXZlbFRoaWNrbmVzcyA9IG9wdGlvbnMuYmV2ZWxUaGlja25lc3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxUaGlja25lc3MgOiAwLjI7XG5cdFx0XHRcdGxldCBiZXZlbFNpemUgPSBvcHRpb25zLmJldmVsU2l6ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNpemUgOiBiZXZlbFRoaWNrbmVzcyAtIDAuMTtcblx0XHRcdFx0bGV0IGJldmVsT2Zmc2V0ID0gb3B0aW9ucy5iZXZlbE9mZnNldCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbE9mZnNldCA6IDA7XG5cdFx0XHRcdGxldCBiZXZlbFNlZ21lbnRzID0gb3B0aW9ucy5iZXZlbFNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2VnbWVudHMgOiAzO1xuXHRcdFx0XHRjb25zdCBleHRydWRlUGF0aCA9IG9wdGlvbnMuZXh0cnVkZVBhdGg7XG5cdFx0XHRcdGNvbnN0IHV2Z2VuID0gb3B0aW9ucy5VVkdlbmVyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5VVkdlbmVyYXRvciA6IFdvcmxkVVZHZW5lcmF0b3I7IC8vIGRlcHJlY2F0ZWQgb3B0aW9uc1xuXG5cdFx0XHRcdGlmIChvcHRpb25zLmFtb3VudCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5FeHRydWRlQnVmZmVyR2VvbWV0cnk6IGFtb3VudCBoYXMgYmVlbiByZW5hbWVkIHRvIGRlcHRoLicpO1xuXHRcdFx0XHRcdGRlcHRoID0gb3B0aW9ucy5hbW91bnQ7XG5cdFx0XHRcdH0gLy9cblxuXG5cdFx0XHRcdGxldCBleHRydWRlUHRzLFxuXHRcdFx0XHRcdFx0ZXh0cnVkZUJ5UGF0aCA9IGZhbHNlO1xuXHRcdFx0XHRsZXQgc3BsaW5lVHViZSwgYmlub3JtYWwsIG5vcm1hbCwgcG9zaXRpb24yO1xuXG5cdFx0XHRcdGlmIChleHRydWRlUGF0aCkge1xuXHRcdFx0XHRcdGV4dHJ1ZGVQdHMgPSBleHRydWRlUGF0aC5nZXRTcGFjZWRQb2ludHMoc3RlcHMpO1xuXHRcdFx0XHRcdGV4dHJ1ZGVCeVBhdGggPSB0cnVlO1xuXHRcdFx0XHRcdGJldmVsRW5hYmxlZCA9IGZhbHNlOyAvLyBiZXZlbHMgbm90IHN1cHBvcnRlZCBmb3IgcGF0aCBleHRydXNpb25cblx0XHRcdFx0XHQvLyBTRVRVUCBUTkIgdmFyaWFibGVzXG5cdFx0XHRcdFx0Ly8gVE9ETzEgLSBoYXZlIGEgLmlzQ2xvc2VkIGluIHNwbGluZT9cblxuXHRcdFx0XHRcdHNwbGluZVR1YmUgPSBleHRydWRlUGF0aC5jb21wdXRlRnJlbmV0RnJhbWVzKHN0ZXBzLCBmYWxzZSk7IC8vIGNvbnNvbGUubG9nKHNwbGluZVR1YmUsICdzcGxpbmVUdWJlJywgc3BsaW5lVHViZS5ub3JtYWxzLmxlbmd0aCwgJ3N0ZXBzJywgc3RlcHMsICdleHRydWRlUHRzJywgZXh0cnVkZVB0cy5sZW5ndGgpO1xuXG5cdFx0XHRcdFx0Ymlub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHRcdG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdFx0cG9zaXRpb24yID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0fSAvLyBTYWZlZ3VhcmRzIGlmIGJldmVscyBhcmUgbm90IGVuYWJsZWRcblxuXG5cdFx0XHRcdGlmICghYmV2ZWxFbmFibGVkKSB7XG5cdFx0XHRcdFx0YmV2ZWxTZWdtZW50cyA9IDA7XG5cdFx0XHRcdFx0YmV2ZWxUaGlja25lc3MgPSAwO1xuXHRcdFx0XHRcdGJldmVsU2l6ZSA9IDA7XG5cdFx0XHRcdFx0YmV2ZWxPZmZzZXQgPSAwO1xuXHRcdFx0XHR9IC8vIFZhcmlhYmxlcyBpbml0aWFsaXphdGlvblxuXG5cblx0XHRcdFx0Y29uc3Qgc2hhcGVQb2ludHMgPSBzaGFwZS5leHRyYWN0UG9pbnRzKGN1cnZlU2VnbWVudHMpO1xuXHRcdFx0XHRsZXQgdmVydGljZXMgPSBzaGFwZVBvaW50cy5zaGFwZTtcblx0XHRcdFx0Y29uc3QgaG9sZXMgPSBzaGFwZVBvaW50cy5ob2xlcztcblx0XHRcdFx0Y29uc3QgcmV2ZXJzZSA9ICFTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKHZlcnRpY2VzKTtcblxuXHRcdFx0XHRpZiAocmV2ZXJzZSkge1xuXHRcdFx0XHRcdHZlcnRpY2VzID0gdmVydGljZXMucmV2ZXJzZSgpOyAvLyBNYXliZSB3ZSBzaG91bGQgYWxzbyBjaGVjayBpZiBob2xlcyBhcmUgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiwganVzdCB0byBiZSBzYWZlIC4uLlxuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGgrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgYWhvbGUgPSBob2xlc1toXTtcblxuXHRcdFx0XHRcdFx0aWYgKFNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoYWhvbGUpKSB7XG5cdFx0XHRcdFx0XHRcdGhvbGVzW2hdID0gYWhvbGUucmV2ZXJzZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGZhY2VzID0gU2hhcGVVdGlscy50cmlhbmd1bGF0ZVNoYXBlKHZlcnRpY2VzLCBob2xlcyk7XG5cdFx0XHRcdC8qIFZlcnRpY2VzICovXG5cblx0XHRcdFx0Y29uc3QgY29udG91ciA9IHZlcnRpY2VzOyAvLyB2ZXJ0aWNlcyBoYXMgYWxsIHBvaW50cyBidXQgY29udG91ciBoYXMgb25seSBwb2ludHMgb2YgY2lyY3VtZmVyZW5jZVxuXG5cdFx0XHRcdGZvciAobGV0IGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoKyspIHtcblx0XHRcdFx0XHRjb25zdCBhaG9sZSA9IGhvbGVzW2hdO1xuXHRcdFx0XHRcdHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KGFob2xlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZ1bmN0aW9uIHNjYWxlUHQyKHB0LCB2ZWMsIHNpemUpIHtcblx0XHRcdFx0XHRpZiAoIXZlYykgY29uc29sZS5lcnJvcignVEhSRUUuRXh0cnVkZUdlb21ldHJ5OiB2ZWMgZG9lcyBub3QgZXhpc3QnKTtcblx0XHRcdFx0XHRyZXR1cm4gdmVjLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoc2l6ZSkuYWRkKHB0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHZsZW4gPSB2ZXJ0aWNlcy5sZW5ndGgsXG5cdFx0XHRcdFx0XHRcdGZsZW4gPSBmYWNlcy5sZW5ndGg7IC8vIEZpbmQgZGlyZWN0aW9ucyBmb3IgcG9pbnQgbW92ZW1lbnRcblxuXHRcdFx0XHRmdW5jdGlvbiBnZXRCZXZlbFZlYyhpblB0LCBpblByZXYsIGluTmV4dCkge1xuXHRcdFx0XHRcdC8vIGNvbXB1dGVzIGZvciBpblB0IHRoZSBjb3JyZXNwb25kaW5nIHBvaW50IGluUHQnIG9uIGEgbmV3IGNvbnRvdXJcblx0XHRcdFx0XHQvL1x0IHNoaWZ0ZWQgYnkgMSB1bml0IChsZW5ndGggb2Ygbm9ybWFsaXplZCB2ZWN0b3IpIHRvIHRoZSBsZWZ0XG5cdFx0XHRcdFx0Ly8gaWYgd2Ugd2FsayBhbG9uZyBjb250b3VyIGNsb2Nrd2lzZSwgdGhpcyBuZXcgY29udG91ciBpcyBvdXRzaWRlIHRoZSBvbGQgb25lXG5cdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHQvLyBpblB0JyBpcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gbGluZXMgcGFyYWxsZWwgdG8gdGhlIHR3b1xuXHRcdFx0XHRcdC8vXHRhZGphY2VudCBlZGdlcyBvZiBpblB0IGF0IGEgZGlzdGFuY2Ugb2YgMSB1bml0IG9uIHRoZSBsZWZ0IHNpZGUuXG5cdFx0XHRcdFx0bGV0IHZfdHJhbnNfeCwgdl90cmFuc195LCBzaHJpbmtfYnk7IC8vIHJlc3VsdGluZyB0cmFuc2xhdGlvbiB2ZWN0b3IgZm9yIGluUHRcblx0XHRcdFx0XHQvLyBnb29kIHJlYWRpbmcgZm9yIGdlb21ldHJ5IGFsZ29yaXRobXMgKGhlcmU6IGxpbmUtbGluZSBpbnRlcnNlY3Rpb24pXG5cdFx0XHRcdFx0Ly8gaHR0cDovL2dlb21hbGdvcml0aG1zLmNvbS9hMDUtX2ludGVyc2VjdC0xLmh0bWxcblxuXHRcdFx0XHRcdGNvbnN0IHZfcHJldl94ID0gaW5QdC54IC0gaW5QcmV2LngsXG5cdFx0XHRcdFx0XHRcdFx0dl9wcmV2X3kgPSBpblB0LnkgLSBpblByZXYueTtcblx0XHRcdFx0XHRjb25zdCB2X25leHRfeCA9IGluTmV4dC54IC0gaW5QdC54LFxuXHRcdFx0XHRcdFx0XHRcdHZfbmV4dF95ID0gaW5OZXh0LnkgLSBpblB0Lnk7XG5cdFx0XHRcdFx0Y29uc3Qgdl9wcmV2X2xlbnNxID0gdl9wcmV2X3ggKiB2X3ByZXZfeCArIHZfcHJldl95ICogdl9wcmV2X3k7IC8vIGNoZWNrIGZvciBjb2xsaW5lYXIgZWRnZXNcblxuXHRcdFx0XHRcdGNvbnN0IGNvbGxpbmVhcjAgPSB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeDtcblxuXHRcdFx0XHRcdGlmIChNYXRoLmFicyhjb2xsaW5lYXIwKSA+IE51bWJlci5FUFNJTE9OKSB7XG5cdFx0XHRcdFx0XHQvLyBub3QgY29sbGluZWFyXG5cdFx0XHRcdFx0XHQvLyBsZW5ndGggb2YgdmVjdG9ycyBmb3Igbm9ybWFsaXppbmdcblx0XHRcdFx0XHRcdGNvbnN0IHZfcHJldl9sZW4gPSBNYXRoLnNxcnQodl9wcmV2X2xlbnNxKTtcblx0XHRcdFx0XHRcdGNvbnN0IHZfbmV4dF9sZW4gPSBNYXRoLnNxcnQodl9uZXh0X3ggKiB2X25leHRfeCArIHZfbmV4dF95ICogdl9uZXh0X3kpOyAvLyBzaGlmdCBhZGphY2VudCBwb2ludHMgYnkgdW5pdCB2ZWN0b3JzIHRvIHRoZSBsZWZ0XG5cblx0XHRcdFx0XHRcdGNvbnN0IHB0UHJldlNoaWZ0X3ggPSBpblByZXYueCAtIHZfcHJldl95IC8gdl9wcmV2X2xlbjtcblx0XHRcdFx0XHRcdGNvbnN0IHB0UHJldlNoaWZ0X3kgPSBpblByZXYueSArIHZfcHJldl94IC8gdl9wcmV2X2xlbjtcblx0XHRcdFx0XHRcdGNvbnN0IHB0TmV4dFNoaWZ0X3ggPSBpbk5leHQueCAtIHZfbmV4dF95IC8gdl9uZXh0X2xlbjtcblx0XHRcdFx0XHRcdGNvbnN0IHB0TmV4dFNoaWZ0X3kgPSBpbk5leHQueSArIHZfbmV4dF94IC8gdl9uZXh0X2xlbjsgLy8gc2NhbGluZyBmYWN0b3IgZm9yIHZfcHJldiB0byBpbnRlcnNlY3Rpb24gcG9pbnRcblxuXHRcdFx0XHRcdFx0Y29uc3Qgc2YgPSAoKHB0TmV4dFNoaWZ0X3ggLSBwdFByZXZTaGlmdF94KSAqIHZfbmV4dF95IC0gKHB0TmV4dFNoaWZ0X3kgLSBwdFByZXZTaGlmdF95KSAqIHZfbmV4dF94KSAvICh2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCk7IC8vIHZlY3RvciBmcm9tIGluUHQgdG8gaW50ZXJzZWN0aW9uIHBvaW50XG5cblx0XHRcdFx0XHRcdHZfdHJhbnNfeCA9IHB0UHJldlNoaWZ0X3ggKyB2X3ByZXZfeCAqIHNmIC0gaW5QdC54O1xuXHRcdFx0XHRcdFx0dl90cmFuc195ID0gcHRQcmV2U2hpZnRfeSArIHZfcHJldl95ICogc2YgLSBpblB0Lnk7IC8vIERvbid0IG5vcm1hbGl6ZSEsIG90aGVyd2lzZSBzaGFycCBjb3JuZXJzIGJlY29tZSB1Z2x5XG5cdFx0XHRcdFx0XHQvL1x0YnV0IHByZXZlbnQgY3Jhenkgc3Bpa2VzXG5cblx0XHRcdFx0XHRcdGNvbnN0IHZfdHJhbnNfbGVuc3EgPSB2X3RyYW5zX3ggKiB2X3RyYW5zX3ggKyB2X3RyYW5zX3kgKiB2X3RyYW5zX3k7XG5cblx0XHRcdFx0XHRcdGlmICh2X3RyYW5zX2xlbnNxIDw9IDIpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBWZWN0b3IyKHZfdHJhbnNfeCwgdl90cmFuc195KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCh2X3RyYW5zX2xlbnNxIC8gMik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIGhhbmRsZSBzcGVjaWFsIGNhc2Ugb2YgY29sbGluZWFyIGVkZ2VzXG5cdFx0XHRcdFx0XHRsZXQgZGlyZWN0aW9uX2VxID0gZmFsc2U7IC8vIGFzc3VtZXM6IG9wcG9zaXRlXG5cblx0XHRcdFx0XHRcdGlmICh2X3ByZXZfeCA+IE51bWJlci5FUFNJTE9OKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh2X25leHRfeCA+IE51bWJlci5FUFNJTE9OKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aWYgKHZfcHJldl94IDwgLU51bWJlci5FUFNJTE9OKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHZfbmV4dF94IDwgLU51bWJlci5FUFNJTE9OKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkaXJlY3Rpb25fZXEgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoTWF0aC5zaWduKHZfcHJldl95KSA9PT0gTWF0aC5zaWduKHZfbmV4dF95KSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKGRpcmVjdGlvbl9lcSkge1xuXHRcdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNlcXVlbmNlXCIpO1xuXHRcdFx0XHRcdFx0XHR2X3RyYW5zX3ggPSAtdl9wcmV2X3k7XG5cdFx0XHRcdFx0XHRcdHZfdHJhbnNfeSA9IHZfcHJldl94O1xuXHRcdFx0XHRcdFx0XHRzaHJpbmtfYnkgPSBNYXRoLnNxcnQodl9wcmV2X2xlbnNxKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc3Bpa2VcIik7XG5cdFx0XHRcdFx0XHRcdHZfdHJhbnNfeCA9IHZfcHJldl94O1xuXHRcdFx0XHRcdFx0XHR2X3RyYW5zX3kgPSB2X3ByZXZfeTtcblx0XHRcdFx0XHRcdFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KHZfcHJldl9sZW5zcSAvIDIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBuZXcgVmVjdG9yMih2X3RyYW5zX3ggLyBzaHJpbmtfYnksIHZfdHJhbnNfeSAvIHNocmlua19ieSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBjb250b3VyTW92ZW1lbnRzID0gW107XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGgsIGogPSBpbCAtIDEsIGsgPSBpICsgMTsgaSA8IGlsOyBpKyssIGorKywgaysrKSB7XG5cdFx0XHRcdFx0aWYgKGogPT09IGlsKSBqID0gMDtcblx0XHRcdFx0XHRpZiAoayA9PT0gaWwpIGsgPSAwOyAvL1x0KGopLS0tKGkpLS0tKGspXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ2ksaixrJywgaSwgaiAsIGspXG5cblx0XHRcdFx0XHRjb250b3VyTW92ZW1lbnRzW2ldID0gZ2V0QmV2ZWxWZWMoY29udG91cltpXSwgY29udG91cltqXSwgY29udG91cltrXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBob2xlc01vdmVtZW50cyA9IFtdO1xuXHRcdFx0XHRsZXQgb25lSG9sZU1vdmVtZW50cyxcblx0XHRcdFx0XHRcdHZlcnRpY2VzTW92ZW1lbnRzID0gY29udG91ck1vdmVtZW50cy5jb25jYXQoKTtcblxuXHRcdFx0XHRmb3IgKGxldCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgYWhvbGUgPSBob2xlc1toXTtcblx0XHRcdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gW107XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGgsIGogPSBpbCAtIDEsIGsgPSBpICsgMTsgaSA8IGlsOyBpKyssIGorKywgaysrKSB7XG5cdFx0XHRcdFx0XHRpZiAoaiA9PT0gaWwpIGogPSAwO1xuXHRcdFx0XHRcdFx0aWYgKGsgPT09IGlsKSBrID0gMDsgLy9cdChqKS0tLShpKS0tLShrKVxuXG5cdFx0XHRcdFx0XHRvbmVIb2xlTW92ZW1lbnRzW2ldID0gZ2V0QmV2ZWxWZWMoYWhvbGVbaV0sIGFob2xlW2pdLCBhaG9sZVtrXSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aG9sZXNNb3ZlbWVudHMucHVzaChvbmVIb2xlTW92ZW1lbnRzKTtcblx0XHRcdFx0XHR2ZXJ0aWNlc01vdmVtZW50cyA9IHZlcnRpY2VzTW92ZW1lbnRzLmNvbmNhdChvbmVIb2xlTW92ZW1lbnRzKTtcblx0XHRcdFx0fSAvLyBMb29wIGJldmVsU2VnbWVudHMsIDEgZm9yIHRoZSBmcm9udCwgMSBmb3IgdGhlIGJhY2tcblxuXG5cdFx0XHRcdGZvciAobGV0IGIgPSAwOyBiIDwgYmV2ZWxTZWdtZW50czsgYisrKSB7XG5cdFx0XHRcdFx0Ly9mb3IgKCBiID0gYmV2ZWxTZWdtZW50czsgYiA+IDA7IGIgLS0gKSB7XG5cdFx0XHRcdFx0Y29uc3QgdCA9IGIgLyBiZXZlbFNlZ21lbnRzO1xuXHRcdFx0XHRcdGNvbnN0IHogPSBiZXZlbFRoaWNrbmVzcyAqIE1hdGguY29zKHQgKiBNYXRoLlBJIC8gMik7XG5cdFx0XHRcdFx0Y29uc3QgYnMgPSBiZXZlbFNpemUgKiBNYXRoLnNpbih0ICogTWF0aC5QSSAvIDIpICsgYmV2ZWxPZmZzZXQ7IC8vIGNvbnRyYWN0IHNoYXBlXG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IHZlcnQgPSBzY2FsZVB0Mihjb250b3VyW2ldLCBjb250b3VyTW92ZW1lbnRzW2ldLCBicyk7XG5cdFx0XHRcdFx0XHR2KHZlcnQueCwgdmVydC55LCAteik7XG5cdFx0XHRcdFx0fSAvLyBleHBhbmQgaG9sZXNcblxuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGgrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgYWhvbGUgPSBob2xlc1toXTtcblx0XHRcdFx0XHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1toXTtcblxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRjb25zdCB2ZXJ0ID0gc2NhbGVQdDIoYWhvbGVbaV0sIG9uZUhvbGVNb3ZlbWVudHNbaV0sIGJzKTtcblx0XHRcdFx0XHRcdFx0dih2ZXJ0LngsIHZlcnQueSwgLXopO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGJzID0gYmV2ZWxTaXplICsgYmV2ZWxPZmZzZXQ7IC8vIEJhY2sgZmFjaW5nIHZlcnRpY2VzXG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB2bGVuOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCB2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIodmVydGljZXNbaV0sIHZlcnRpY2VzTW92ZW1lbnRzW2ldLCBicykgOiB2ZXJ0aWNlc1tpXTtcblxuXHRcdFx0XHRcdGlmICghZXh0cnVkZUJ5UGF0aCkge1xuXHRcdFx0XHRcdFx0dih2ZXJ0LngsIHZlcnQueSwgMCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgMCBdLnksIGV4dHJ1ZGVQdHNbIDAgXS54ICk7XG5cdFx0XHRcdFx0XHRub3JtYWwuY29weShzcGxpbmVUdWJlLm5vcm1hbHNbMF0pLm11bHRpcGx5U2NhbGFyKHZlcnQueCk7XG5cdFx0XHRcdFx0XHRiaW5vcm1hbC5jb3B5KHNwbGluZVR1YmUuYmlub3JtYWxzWzBdKS5tdWx0aXBseVNjYWxhcih2ZXJ0LnkpO1xuXHRcdFx0XHRcdFx0cG9zaXRpb24yLmNvcHkoZXh0cnVkZVB0c1swXSkuYWRkKG5vcm1hbCkuYWRkKGJpbm9ybWFsKTtcblx0XHRcdFx0XHRcdHYocG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IC8vIEFkZCBzdGVwcGVkIHZlcnRpY2VzLi4uXG5cdFx0XHRcdC8vIEluY2x1ZGluZyBmcm9udCBmYWNpbmcgdmVydGljZXNcblxuXG5cdFx0XHRcdGZvciAobGV0IHMgPSAxOyBzIDw9IHN0ZXBzOyBzKyspIHtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHZsZW47IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgdmVydCA9IGJldmVsRW5hYmxlZCA/IHNjYWxlUHQyKHZlcnRpY2VzW2ldLCB2ZXJ0aWNlc01vdmVtZW50c1tpXSwgYnMpIDogdmVydGljZXNbaV07XG5cblx0XHRcdFx0XHRcdGlmICghZXh0cnVkZUJ5UGF0aCkge1xuXHRcdFx0XHRcdFx0XHR2KHZlcnQueCwgdmVydC55LCBkZXB0aCAvIHN0ZXBzICogcyk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgcyAtIDEgXS54ICk7XG5cdFx0XHRcdFx0XHRcdG5vcm1hbC5jb3B5KHNwbGluZVR1YmUubm9ybWFsc1tzXSkubXVsdGlwbHlTY2FsYXIodmVydC54KTtcblx0XHRcdFx0XHRcdFx0Ymlub3JtYWwuY29weShzcGxpbmVUdWJlLmJpbm9ybWFsc1tzXSkubXVsdGlwbHlTY2FsYXIodmVydC55KTtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24yLmNvcHkoZXh0cnVkZVB0c1tzXSkuYWRkKG5vcm1hbCkuYWRkKGJpbm9ybWFsKTtcblx0XHRcdFx0XHRcdFx0dihwb3NpdGlvbjIueCwgcG9zaXRpb24yLnksIHBvc2l0aW9uMi56KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gLy8gQWRkIGJldmVsIHNlZ21lbnRzIHBsYW5lc1xuXHRcdFx0XHQvL2ZvciAoIGIgPSAxOyBiIDw9IGJldmVsU2VnbWVudHM7IGIgKysgKSB7XG5cblxuXHRcdFx0XHRmb3IgKGxldCBiID0gYmV2ZWxTZWdtZW50cyAtIDE7IGIgPj0gMDsgYi0tKSB7XG5cdFx0XHRcdFx0Y29uc3QgdCA9IGIgLyBiZXZlbFNlZ21lbnRzO1xuXHRcdFx0XHRcdGNvbnN0IHogPSBiZXZlbFRoaWNrbmVzcyAqIE1hdGguY29zKHQgKiBNYXRoLlBJIC8gMik7XG5cdFx0XHRcdFx0Y29uc3QgYnMgPSBiZXZlbFNpemUgKiBNYXRoLnNpbih0ICogTWF0aC5QSSAvIDIpICsgYmV2ZWxPZmZzZXQ7IC8vIGNvbnRyYWN0IHNoYXBlXG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IHZlcnQgPSBzY2FsZVB0Mihjb250b3VyW2ldLCBjb250b3VyTW92ZW1lbnRzW2ldLCBicyk7XG5cdFx0XHRcdFx0XHR2KHZlcnQueCwgdmVydC55LCBkZXB0aCArIHopO1xuXHRcdFx0XHRcdH0gLy8gZXhwYW5kIGhvbGVzXG5cblxuXHRcdFx0XHRcdGZvciAobGV0IGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IGFob2xlID0gaG9sZXNbaF07XG5cdFx0XHRcdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbaF07XG5cblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgdmVydCA9IHNjYWxlUHQyKGFob2xlW2ldLCBvbmVIb2xlTW92ZW1lbnRzW2ldLCBicyk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCFleHRydWRlQnlQYXRoKSB7XG5cdFx0XHRcdFx0XHRcdFx0dih2ZXJ0LngsIHZlcnQueSwgZGVwdGggKyB6KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR2KHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1tzdGVwcyAtIDFdLnksIGV4dHJ1ZGVQdHNbc3RlcHMgLSAxXS54ICsgeik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0LyogRmFjZXMgKi9cblx0XHRcdFx0Ly8gVG9wIGFuZCBib3R0b20gZmFjZXNcblxuXG5cdFx0XHRcdGJ1aWxkTGlkRmFjZXMoKTsgLy8gU2lkZXMgZmFjZXNcblxuXHRcdFx0XHRidWlsZFNpZGVGYWNlcygpOyAvLy8vL1x0SW50ZXJuYWwgZnVuY3Rpb25zXG5cblx0XHRcdFx0ZnVuY3Rpb24gYnVpbGRMaWRGYWNlcygpIHtcblx0XHRcdFx0XHRjb25zdCBzdGFydCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcblxuXHRcdFx0XHRcdGlmIChiZXZlbEVuYWJsZWQpIHtcblx0XHRcdFx0XHRcdGxldCBsYXllciA9IDA7IC8vIHN0ZXBzICsgMVxuXG5cdFx0XHRcdFx0XHRsZXQgb2Zmc2V0ID0gdmxlbiAqIGxheWVyOyAvLyBCb3R0b20gZmFjZXNcblxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBmbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZmFjZSA9IGZhY2VzW2ldO1xuXHRcdFx0XHRcdFx0XHRmMyhmYWNlWzJdICsgb2Zmc2V0LCBmYWNlWzFdICsgb2Zmc2V0LCBmYWNlWzBdICsgb2Zmc2V0KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0bGF5ZXIgPSBzdGVwcyArIGJldmVsU2VnbWVudHMgKiAyO1xuXHRcdFx0XHRcdFx0b2Zmc2V0ID0gdmxlbiAqIGxheWVyOyAvLyBUb3AgZmFjZXNcblxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBmbGVuOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZmFjZSA9IGZhY2VzW2ldO1xuXHRcdFx0XHRcdFx0XHRmMyhmYWNlWzBdICsgb2Zmc2V0LCBmYWNlWzFdICsgb2Zmc2V0LCBmYWNlWzJdICsgb2Zmc2V0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gQm90dG9tIGZhY2VzXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGZsZW47IGkrKykge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBmYWNlID0gZmFjZXNbaV07XG5cdFx0XHRcdFx0XHRcdGYzKGZhY2VbMl0sIGZhY2VbMV0sIGZhY2VbMF0pO1xuXHRcdFx0XHRcdFx0fSAvLyBUb3AgZmFjZXNcblxuXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGZsZW47IGkrKykge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBmYWNlID0gZmFjZXNbaV07XG5cdFx0XHRcdFx0XHRcdGYzKGZhY2VbMF0gKyB2bGVuICogc3RlcHMsIGZhY2VbMV0gKyB2bGVuICogc3RlcHMsIGZhY2VbMl0gKyB2bGVuICogc3RlcHMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHNjb3BlLmFkZEdyb3VwKHN0YXJ0LCB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDMgLSBzdGFydCwgMCk7XG5cdFx0XHRcdH0gLy8gQ3JlYXRlIGZhY2VzIGZvciB0aGUgei1zaWRlcyBvZiB0aGUgc2hhcGVcblxuXG5cdFx0XHRcdGZ1bmN0aW9uIGJ1aWxkU2lkZUZhY2VzKCkge1xuXHRcdFx0XHRcdGNvbnN0IHN0YXJ0ID0gdmVydGljZXNBcnJheS5sZW5ndGggLyAzO1xuXHRcdFx0XHRcdGxldCBsYXllcm9mZnNldCA9IDA7XG5cdFx0XHRcdFx0c2lkZXdhbGxzKGNvbnRvdXIsIGxheWVyb2Zmc2V0KTtcblx0XHRcdFx0XHRsYXllcm9mZnNldCArPSBjb250b3VyLmxlbmd0aDtcblxuXHRcdFx0XHRcdGZvciAobGV0IGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IGFob2xlID0gaG9sZXNbaF07XG5cdFx0XHRcdFx0XHRzaWRld2FsbHMoYWhvbGUsIGxheWVyb2Zmc2V0KTsgLy8sIHRydWVcblxuXHRcdFx0XHRcdFx0bGF5ZXJvZmZzZXQgKz0gYWhvbGUubGVuZ3RoO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHNjb3BlLmFkZEdyb3VwKHN0YXJ0LCB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDMgLSBzdGFydCwgMSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmdW5jdGlvbiBzaWRld2FsbHMoY29udG91ciwgbGF5ZXJvZmZzZXQpIHtcblx0XHRcdFx0XHRsZXQgaSA9IGNvbnRvdXIubGVuZ3RoO1xuXG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+PSAwKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBqID0gaTtcblx0XHRcdFx0XHRcdGxldCBrID0gaSAtIDE7XG5cdFx0XHRcdFx0XHRpZiAoayA8IDApIGsgPSBjb250b3VyLmxlbmd0aCAtIDE7IC8vY29uc29sZS5sb2coJ2InLCBpLGosIGktMSwgayx2ZXJ0aWNlcy5sZW5ndGgpO1xuXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBzID0gMCwgc2wgPSBzdGVwcyArIGJldmVsU2VnbWVudHMgKiAyOyBzIDwgc2w7IHMrKykge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBzbGVuMSA9IHZsZW4gKiBzO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBzbGVuMiA9IHZsZW4gKiAocyArIDEpO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBhID0gbGF5ZXJvZmZzZXQgKyBqICsgc2xlbjEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGIgPSBsYXllcm9mZnNldCArIGsgKyBzbGVuMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0YyA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4yLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkID0gbGF5ZXJvZmZzZXQgKyBqICsgc2xlbjI7XG5cdFx0XHRcdFx0XHRcdGY0KGEsIGIsIGMsIGQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZ1bmN0aW9uIHYoeCwgeSwgeikge1xuXHRcdFx0XHRcdHBsYWNlaG9sZGVyLnB1c2goeCk7XG5cdFx0XHRcdFx0cGxhY2Vob2xkZXIucHVzaCh5KTtcblx0XHRcdFx0XHRwbGFjZWhvbGRlci5wdXNoKHopO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZnVuY3Rpb24gZjMoYSwgYiwgYykge1xuXHRcdFx0XHRcdGFkZFZlcnRleChhKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoYik7XG5cdFx0XHRcdFx0YWRkVmVydGV4KGMpO1xuXHRcdFx0XHRcdGNvbnN0IG5leHRJbmRleCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcblx0XHRcdFx0XHRjb25zdCB1dnMgPSB1dmdlbi5nZW5lcmF0ZVRvcFVWKHNjb3BlLCB2ZXJ0aWNlc0FycmF5LCBuZXh0SW5kZXggLSAzLCBuZXh0SW5kZXggLSAyLCBuZXh0SW5kZXggLSAxKTtcblx0XHRcdFx0XHRhZGRVVih1dnNbMF0pO1xuXHRcdFx0XHRcdGFkZFVWKHV2c1sxXSk7XG5cdFx0XHRcdFx0YWRkVVYodXZzWzJdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZ1bmN0aW9uIGY0KGEsIGIsIGMsIGQpIHtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoYSk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KGIpO1xuXHRcdFx0XHRcdGFkZFZlcnRleChkKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoYik7XG5cdFx0XHRcdFx0YWRkVmVydGV4KGMpO1xuXHRcdFx0XHRcdGFkZFZlcnRleChkKTtcblx0XHRcdFx0XHRjb25zdCBuZXh0SW5kZXggPSB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDM7XG5cdFx0XHRcdFx0Y29uc3QgdXZzID0gdXZnZW4uZ2VuZXJhdGVTaWRlV2FsbFVWKHNjb3BlLCB2ZXJ0aWNlc0FycmF5LCBuZXh0SW5kZXggLSA2LCBuZXh0SW5kZXggLSAzLCBuZXh0SW5kZXggLSAyLCBuZXh0SW5kZXggLSAxKTtcblx0XHRcdFx0XHRhZGRVVih1dnNbMF0pO1xuXHRcdFx0XHRcdGFkZFVWKHV2c1sxXSk7XG5cdFx0XHRcdFx0YWRkVVYodXZzWzNdKTtcblx0XHRcdFx0XHRhZGRVVih1dnNbMV0pO1xuXHRcdFx0XHRcdGFkZFVWKHV2c1syXSk7XG5cdFx0XHRcdFx0YWRkVVYodXZzWzNdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZ1bmN0aW9uIGFkZFZlcnRleChpbmRleCkge1xuXHRcdFx0XHRcdHZlcnRpY2VzQXJyYXkucHVzaChwbGFjZWhvbGRlcltpbmRleCAqIDMgKyAwXSk7XG5cdFx0XHRcdFx0dmVydGljZXNBcnJheS5wdXNoKHBsYWNlaG9sZGVyW2luZGV4ICogMyArIDFdKTtcblx0XHRcdFx0XHR2ZXJ0aWNlc0FycmF5LnB1c2gocGxhY2Vob2xkZXJbaW5kZXggKiAzICsgMl0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZnVuY3Rpb24gYWRkVVYodmVjdG9yMikge1xuXHRcdFx0XHRcdHV2QXJyYXkucHVzaCh2ZWN0b3IyLngpO1xuXHRcdFx0XHRcdHV2QXJyYXkucHVzaCh2ZWN0b3IyLnkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dG9KU09OKCkge1xuXHRcdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXHRcdFx0Y29uc3Qgc2hhcGVzID0gdGhpcy5wYXJhbWV0ZXJzLnNoYXBlcztcblx0XHRcdGNvbnN0IG9wdGlvbnMgPSB0aGlzLnBhcmFtZXRlcnMub3B0aW9ucztcblx0XHRcdHJldHVybiB0b0pTT04kMShzaGFwZXMsIG9wdGlvbnMsIGRhdGEpO1xuXHRcdH1cblxuXHRcdHN0YXRpYyBmcm9tSlNPTihkYXRhLCBzaGFwZXMpIHtcblx0XHRcdGNvbnN0IGdlb21ldHJ5U2hhcGVzID0gW107XG5cblx0XHRcdGZvciAobGV0IGogPSAwLCBqbCA9IGRhdGEuc2hhcGVzLmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcblx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBzaGFwZXNbZGF0YS5zaGFwZXNbal1dO1xuXHRcdFx0XHRnZW9tZXRyeVNoYXBlcy5wdXNoKHNoYXBlKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZXh0cnVkZVBhdGggPSBkYXRhLm9wdGlvbnMuZXh0cnVkZVBhdGg7XG5cblx0XHRcdGlmIChleHRydWRlUGF0aCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGRhdGEub3B0aW9ucy5leHRydWRlUGF0aCA9IG5ldyBDdXJ2ZXNbZXh0cnVkZVBhdGgudHlwZV0oKS5mcm9tSlNPTihleHRydWRlUGF0aCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgRXh0cnVkZUdlb21ldHJ5KGdlb21ldHJ5U2hhcGVzLCBkYXRhLm9wdGlvbnMpO1xuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgV29ybGRVVkdlbmVyYXRvciA9IHtcblx0XHRnZW5lcmF0ZVRvcFVWOiBmdW5jdGlvbiAoZ2VvbWV0cnksIHZlcnRpY2VzLCBpbmRleEEsIGluZGV4QiwgaW5kZXhDKSB7XG5cdFx0XHRjb25zdCBhX3ggPSB2ZXJ0aWNlc1tpbmRleEEgKiAzXTtcblx0XHRcdGNvbnN0IGFfeSA9IHZlcnRpY2VzW2luZGV4QSAqIDMgKyAxXTtcblx0XHRcdGNvbnN0IGJfeCA9IHZlcnRpY2VzW2luZGV4QiAqIDNdO1xuXHRcdFx0Y29uc3QgYl95ID0gdmVydGljZXNbaW5kZXhCICogMyArIDFdO1xuXHRcdFx0Y29uc3QgY194ID0gdmVydGljZXNbaW5kZXhDICogM107XG5cdFx0XHRjb25zdCBjX3kgPSB2ZXJ0aWNlc1tpbmRleEMgKiAzICsgMV07XG5cdFx0XHRyZXR1cm4gW25ldyBWZWN0b3IyKGFfeCwgYV95KSwgbmV3IFZlY3RvcjIoYl94LCBiX3kpLCBuZXcgVmVjdG9yMihjX3gsIGNfeSldO1xuXHRcdH0sXG5cdFx0Z2VuZXJhdGVTaWRlV2FsbFVWOiBmdW5jdGlvbiAoZ2VvbWV0cnksIHZlcnRpY2VzLCBpbmRleEEsIGluZGV4QiwgaW5kZXhDLCBpbmRleEQpIHtcblx0XHRcdGNvbnN0IGFfeCA9IHZlcnRpY2VzW2luZGV4QSAqIDNdO1xuXHRcdFx0Y29uc3QgYV95ID0gdmVydGljZXNbaW5kZXhBICogMyArIDFdO1xuXHRcdFx0Y29uc3QgYV96ID0gdmVydGljZXNbaW5kZXhBICogMyArIDJdO1xuXHRcdFx0Y29uc3QgYl94ID0gdmVydGljZXNbaW5kZXhCICogM107XG5cdFx0XHRjb25zdCBiX3kgPSB2ZXJ0aWNlc1tpbmRleEIgKiAzICsgMV07XG5cdFx0XHRjb25zdCBiX3ogPSB2ZXJ0aWNlc1tpbmRleEIgKiAzICsgMl07XG5cdFx0XHRjb25zdCBjX3ggPSB2ZXJ0aWNlc1tpbmRleEMgKiAzXTtcblx0XHRcdGNvbnN0IGNfeSA9IHZlcnRpY2VzW2luZGV4QyAqIDMgKyAxXTtcblx0XHRcdGNvbnN0IGNfeiA9IHZlcnRpY2VzW2luZGV4QyAqIDMgKyAyXTtcblx0XHRcdGNvbnN0IGRfeCA9IHZlcnRpY2VzW2luZGV4RCAqIDNdO1xuXHRcdFx0Y29uc3QgZF95ID0gdmVydGljZXNbaW5kZXhEICogMyArIDFdO1xuXHRcdFx0Y29uc3QgZF96ID0gdmVydGljZXNbaW5kZXhEICogMyArIDJdO1xuXG5cdFx0XHRpZiAoTWF0aC5hYnMoYV95IC0gYl95KSA8IE1hdGguYWJzKGFfeCAtIGJfeCkpIHtcblx0XHRcdFx0cmV0dXJuIFtuZXcgVmVjdG9yMihhX3gsIDEgLSBhX3opLCBuZXcgVmVjdG9yMihiX3gsIDEgLSBiX3opLCBuZXcgVmVjdG9yMihjX3gsIDEgLSBjX3opLCBuZXcgVmVjdG9yMihkX3gsIDEgLSBkX3opXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBbbmV3IFZlY3RvcjIoYV95LCAxIC0gYV96KSwgbmV3IFZlY3RvcjIoYl95LCAxIC0gYl96KSwgbmV3IFZlY3RvcjIoY195LCAxIC0gY196KSwgbmV3IFZlY3RvcjIoZF95LCAxIC0gZF96KV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdGZ1bmN0aW9uIHRvSlNPTiQxKHNoYXBlcywgb3B0aW9ucywgZGF0YSkge1xuXHRcdGRhdGEuc2hhcGVzID0gW107XG5cblx0XHRpZiAoQXJyYXkuaXNBcnJheShzaGFwZXMpKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBzaGFwZXNbaV07XG5cdFx0XHRcdGRhdGEuc2hhcGVzLnB1c2goc2hhcGUudXVpZCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEuc2hhcGVzLnB1c2goc2hhcGVzLnV1aWQpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmV4dHJ1ZGVQYXRoICE9PSB1bmRlZmluZWQpIGRhdGEub3B0aW9ucy5leHRydWRlUGF0aCA9IG9wdGlvbnMuZXh0cnVkZVBhdGgudG9KU09OKCk7XG5cdFx0cmV0dXJuIGRhdGE7XG5cdH1cblxuXHRjbGFzcyBJY29zYWhlZHJvbkdlb21ldHJ5IGV4dGVuZHMgUG9seWhlZHJvbkdlb21ldHJ5IHtcblx0XHRjb25zdHJ1Y3RvcihyYWRpdXMgPSAxLCBkZXRhaWwgPSAwKSB7XG5cdFx0XHRjb25zdCB0ID0gKDEgKyBNYXRoLnNxcnQoNSkpIC8gMjtcblx0XHRcdGNvbnN0IHZlcnRpY2VzID0gWy0xLCB0LCAwLCAxLCB0LCAwLCAtMSwgLXQsIDAsIDEsIC10LCAwLCAwLCAtMSwgdCwgMCwgMSwgdCwgMCwgLTEsIC10LCAwLCAxLCAtdCwgdCwgMCwgLTEsIHQsIDAsIDEsIC10LCAwLCAtMSwgLXQsIDAsIDFdO1xuXHRcdFx0Y29uc3QgaW5kaWNlcyA9IFswLCAxMSwgNSwgMCwgNSwgMSwgMCwgMSwgNywgMCwgNywgMTAsIDAsIDEwLCAxMSwgMSwgNSwgOSwgNSwgMTEsIDQsIDExLCAxMCwgMiwgMTAsIDcsIDYsIDcsIDEsIDgsIDMsIDksIDQsIDMsIDQsIDIsIDMsIDIsIDYsIDMsIDYsIDgsIDMsIDgsIDksIDQsIDksIDUsIDIsIDQsIDExLCA2LCAyLCAxMCwgOCwgNiwgNywgOSwgOCwgMV07XG5cdFx0XHRzdXBlcih2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwpO1xuXHRcdFx0dGhpcy50eXBlID0gJ0ljb3NhaGVkcm9uR2VvbWV0cnknO1xuXHRcdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdFx0ZGV0YWlsOiBkZXRhaWxcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0c3RhdGljIGZyb21KU09OKGRhdGEpIHtcblx0XHRcdHJldHVybiBuZXcgSWNvc2FoZWRyb25HZW9tZXRyeShkYXRhLnJhZGl1cywgZGF0YS5kZXRhaWwpO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgTGF0aGVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblx0XHRjb25zdHJ1Y3Rvcihwb2ludHMgPSBbbmV3IFZlY3RvcjIoMCwgMC41KSwgbmV3IFZlY3RvcjIoMC41LCAwKSwgbmV3IFZlY3RvcjIoMCwgLTAuNSldLCBzZWdtZW50cyA9IDEyLCBwaGlTdGFydCA9IDAsIHBoaUxlbmd0aCA9IE1hdGguUEkgKiAyKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ0xhdGhlR2VvbWV0cnknO1xuXHRcdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0XHRwb2ludHM6IHBvaW50cyxcblx0XHRcdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxuXHRcdFx0XHRwaGlTdGFydDogcGhpU3RhcnQsXG5cdFx0XHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoXG5cdFx0XHR9O1xuXHRcdFx0c2VnbWVudHMgPSBNYXRoLmZsb29yKHNlZ21lbnRzKTsgLy8gY2xhbXAgcGhpTGVuZ3RoIHNvIGl0J3MgaW4gcmFuZ2Ugb2YgWyAwLCAyUEkgXVxuXG5cdFx0XHRwaGlMZW5ndGggPSBjbGFtcChwaGlMZW5ndGgsIDAsIE1hdGguUEkgKiAyKTsgLy8gYnVmZmVyc1xuXG5cdFx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0Y29uc3QgdXZzID0gW107IC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdFx0Y29uc3QgaW52ZXJzZVNlZ21lbnRzID0gMS4wIC8gc2VnbWVudHM7XG5cdFx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgdXYgPSBuZXcgVmVjdG9yMigpOyAvLyBnZW5lcmF0ZSB2ZXJ0aWNlcyBhbmQgdXZzXG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDw9IHNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgcGhpID0gcGhpU3RhcnQgKyBpICogaW52ZXJzZVNlZ21lbnRzICogcGhpTGVuZ3RoO1xuXHRcdFx0XHRjb25zdCBzaW4gPSBNYXRoLnNpbihwaGkpO1xuXHRcdFx0XHRjb25zdCBjb3MgPSBNYXRoLmNvcyhwaGkpO1xuXG5cdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDw9IHBvaW50cy5sZW5ndGggLSAxOyBqKyspIHtcblx0XHRcdFx0XHQvLyB2ZXJ0ZXhcblx0XHRcdFx0XHR2ZXJ0ZXgueCA9IHBvaW50c1tqXS54ICogc2luO1xuXHRcdFx0XHRcdHZlcnRleC55ID0gcG9pbnRzW2pdLnk7XG5cdFx0XHRcdFx0dmVydGV4LnogPSBwb2ludHNbal0ueCAqIGNvcztcblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnopOyAvLyB1dlxuXG5cdFx0XHRcdFx0dXYueCA9IGkgLyBzZWdtZW50cztcblx0XHRcdFx0XHR1di55ID0gaiAvIChwb2ludHMubGVuZ3RoIC0gMSk7XG5cdFx0XHRcdFx0dXZzLnB1c2godXYueCwgdXYueSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gLy8gaW5kaWNlc1xuXG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHM7IGkrKykge1xuXHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IHBvaW50cy5sZW5ndGggLSAxOyBqKyspIHtcblx0XHRcdFx0XHRjb25zdCBiYXNlID0gaiArIGkgKiBwb2ludHMubGVuZ3RoO1xuXHRcdFx0XHRcdGNvbnN0IGEgPSBiYXNlO1xuXHRcdFx0XHRcdGNvbnN0IGIgPSBiYXNlICsgcG9pbnRzLmxlbmd0aDtcblx0XHRcdFx0XHRjb25zdCBjID0gYmFzZSArIHBvaW50cy5sZW5ndGggKyAxO1xuXHRcdFx0XHRcdGNvbnN0IGQgPSBiYXNlICsgMTsgLy8gZmFjZXNcblxuXHRcdFx0XHRcdGluZGljZXMucHVzaChhLCBiLCBkKTtcblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goYiwgYywgZCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gLy8gYnVpbGQgZ2VvbWV0cnlcblxuXG5cdFx0XHR0aGlzLnNldEluZGV4KGluZGljZXMpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHV2cywgMikpOyAvLyBnZW5lcmF0ZSBub3JtYWxzXG5cblx0XHRcdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTsgLy8gaWYgdGhlIGdlb21ldHJ5IGlzIGNsb3NlZCwgd2UgbmVlZCB0byBhdmVyYWdlIHRoZSBub3JtYWxzIGFsb25nIHRoZSBzZWFtLlxuXHRcdFx0Ly8gYmVjYXVzZSB0aGUgY29ycmVzcG9uZGluZyB2ZXJ0aWNlcyBhcmUgaWRlbnRpY2FsIChidXQgc3RpbGwgaGF2ZSBkaWZmZXJlbnQgVVZzKS5cblxuXHRcdFx0aWYgKHBoaUxlbmd0aCA9PT0gTWF0aC5QSSAqIDIpIHtcblx0XHRcdFx0Y29uc3Qgbm9ybWFscyA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XG5cdFx0XHRcdGNvbnN0IG4xID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0Y29uc3QgbjIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHRjb25zdCBuID0gbmV3IFZlY3RvcjMoKTsgLy8gdGhpcyBpcyB0aGUgYnVmZmVyIG9mZnNldCBmb3IgdGhlIGxhc3QgbGluZSBvZiB2ZXJ0aWNlc1xuXG5cdFx0XHRcdGNvbnN0IGJhc2UgPSBzZWdtZW50cyAqIHBvaW50cy5sZW5ndGggKiAzO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKywgaiArPSAzKSB7XG5cdFx0XHRcdFx0Ly8gc2VsZWN0IHRoZSBub3JtYWwgb2YgdGhlIHZlcnRleCBpbiB0aGUgZmlyc3QgbGluZVxuXHRcdFx0XHRcdG4xLnggPSBub3JtYWxzW2ogKyAwXTtcblx0XHRcdFx0XHRuMS55ID0gbm9ybWFsc1tqICsgMV07XG5cdFx0XHRcdFx0bjEueiA9IG5vcm1hbHNbaiArIDJdOyAvLyBzZWxlY3QgdGhlIG5vcm1hbCBvZiB0aGUgdmVydGV4IGluIHRoZSBsYXN0IGxpbmVcblxuXHRcdFx0XHRcdG4yLnggPSBub3JtYWxzW2Jhc2UgKyBqICsgMF07XG5cdFx0XHRcdFx0bjIueSA9IG5vcm1hbHNbYmFzZSArIGogKyAxXTtcblx0XHRcdFx0XHRuMi56ID0gbm9ybWFsc1tiYXNlICsgaiArIDJdOyAvLyBhdmVyYWdlIG5vcm1hbHNcblxuXHRcdFx0XHRcdG4uYWRkVmVjdG9ycyhuMSwgbjIpLm5vcm1hbGl6ZSgpOyAvLyBhc3NpZ24gdGhlIG5ldyB2YWx1ZXMgdG8gYm90aCBub3JtYWxzXG5cblx0XHRcdFx0XHRub3JtYWxzW2ogKyAwXSA9IG5vcm1hbHNbYmFzZSArIGogKyAwXSA9IG4ueDtcblx0XHRcdFx0XHRub3JtYWxzW2ogKyAxXSA9IG5vcm1hbHNbYmFzZSArIGogKyAxXSA9IG4ueTtcblx0XHRcdFx0XHRub3JtYWxzW2ogKyAyXSA9IG5vcm1hbHNbYmFzZSArIGogKyAyXSA9IG4uejtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHN0YXRpYyBmcm9tSlNPTihkYXRhKSB7XG5cdFx0XHRyZXR1cm4gbmV3IExhdGhlR2VvbWV0cnkoZGF0YS5wb2ludHMsIGRhdGEuc2VnbWVudHMsIGRhdGEucGhpU3RhcnQsIGRhdGEucGhpTGVuZ3RoKTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIE9jdGFoZWRyb25HZW9tZXRyeSBleHRlbmRzIFBvbHloZWRyb25HZW9tZXRyeSB7XG5cdFx0Y29uc3RydWN0b3IocmFkaXVzID0gMSwgZGV0YWlsID0gMCkge1xuXHRcdFx0Y29uc3QgdmVydGljZXMgPSBbMSwgMCwgMCwgLTEsIDAsIDAsIDAsIDEsIDAsIDAsIC0xLCAwLCAwLCAwLCAxLCAwLCAwLCAtMV07XG5cdFx0XHRjb25zdCBpbmRpY2VzID0gWzAsIDIsIDQsIDAsIDQsIDMsIDAsIDMsIDUsIDAsIDUsIDIsIDEsIDIsIDUsIDEsIDUsIDMsIDEsIDMsIDQsIDEsIDQsIDJdO1xuXHRcdFx0c3VwZXIodmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsKTtcblx0XHRcdHRoaXMudHlwZSA9ICdPY3RhaGVkcm9uR2VvbWV0cnknO1xuXHRcdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdFx0ZGV0YWlsOiBkZXRhaWxcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0c3RhdGljIGZyb21KU09OKGRhdGEpIHtcblx0XHRcdHJldHVybiBuZXcgT2N0YWhlZHJvbkdlb21ldHJ5KGRhdGEucmFkaXVzLCBkYXRhLmRldGFpbCk7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBSaW5nR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cdFx0Y29uc3RydWN0b3IoaW5uZXJSYWRpdXMgPSAwLjUsIG91dGVyUmFkaXVzID0gMSwgdGhldGFTZWdtZW50cyA9IDgsIHBoaVNlZ21lbnRzID0gMSwgdGhldGFTdGFydCA9IDAsIHRoZXRhTGVuZ3RoID0gTWF0aC5QSSAqIDIpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnUmluZ0dlb21ldHJ5Jztcblx0XHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdFx0aW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxuXHRcdFx0XHRvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXG5cdFx0XHRcdHRoZXRhU2VnbWVudHM6IHRoZXRhU2VnbWVudHMsXG5cdFx0XHRcdHBoaVNlZ21lbnRzOiBwaGlTZWdtZW50cyxcblx0XHRcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdFx0XHR9O1xuXHRcdFx0dGhldGFTZWdtZW50cyA9IE1hdGgubWF4KDMsIHRoZXRhU2VnbWVudHMpO1xuXHRcdFx0cGhpU2VnbWVudHMgPSBNYXRoLm1heCgxLCBwaGlTZWdtZW50cyk7IC8vIGJ1ZmZlcnNcblxuXHRcdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRcdGNvbnN0IHV2cyA9IFtdOyAvLyBzb21lIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdFx0bGV0IHJhZGl1cyA9IGlubmVyUmFkaXVzO1xuXHRcdFx0Y29uc3QgcmFkaXVzU3RlcCA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIHBoaVNlZ21lbnRzO1xuXHRcdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IHV2ID0gbmV3IFZlY3RvcjIoKTsgLy8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG5cdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8PSBwaGlTZWdtZW50czsgaisrKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDw9IHRoZXRhU2VnbWVudHM7IGkrKykge1xuXHRcdFx0XHRcdC8vIHZhbHVlcyBhcmUgZ2VuZXJhdGUgZnJvbSB0aGUgaW5zaWRlIG9mIHRoZSByaW5nIHRvIHRoZSBvdXRzaWRlXG5cdFx0XHRcdFx0Y29uc3Qgc2VnbWVudCA9IHRoZXRhU3RhcnQgKyBpIC8gdGhldGFTZWdtZW50cyAqIHRoZXRhTGVuZ3RoOyAvLyB2ZXJ0ZXhcblxuXHRcdFx0XHRcdHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5jb3Moc2VnbWVudCk7XG5cdFx0XHRcdFx0dmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLnNpbihzZWdtZW50KTtcblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnopOyAvLyBub3JtYWxcblxuXHRcdFx0XHRcdG5vcm1hbHMucHVzaCgwLCAwLCAxKTsgLy8gdXZcblxuXHRcdFx0XHRcdHV2LnggPSAodmVydGV4LnggLyBvdXRlclJhZGl1cyArIDEpIC8gMjtcblx0XHRcdFx0XHR1di55ID0gKHZlcnRleC55IC8gb3V0ZXJSYWRpdXMgKyAxKSAvIDI7XG5cdFx0XHRcdFx0dXZzLnB1c2godXYueCwgdXYueSk7XG5cdFx0XHRcdH0gLy8gaW5jcmVhc2UgdGhlIHJhZGl1cyBmb3IgbmV4dCByb3cgb2YgdmVydGljZXNcblxuXG5cdFx0XHRcdHJhZGl1cyArPSByYWRpdXNTdGVwO1xuXHRcdFx0fSAvLyBpbmRpY2VzXG5cblxuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBwaGlTZWdtZW50czsgaisrKSB7XG5cdFx0XHRcdGNvbnN0IHRoZXRhU2VnbWVudExldmVsID0gaiAqICh0aGV0YVNlZ21lbnRzICsgMSk7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGV0YVNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBzZWdtZW50ID0gaSArIHRoZXRhU2VnbWVudExldmVsO1xuXHRcdFx0XHRcdGNvbnN0IGEgPSBzZWdtZW50O1xuXHRcdFx0XHRcdGNvbnN0IGIgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDE7XG5cdFx0XHRcdFx0Y29uc3QgYyA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMjtcblx0XHRcdFx0XHRjb25zdCBkID0gc2VnbWVudCArIDE7IC8vIGZhY2VzXG5cblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goYSwgYiwgZCk7XG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKGIsIGMsIGQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IC8vIGJ1aWxkIGdlb21ldHJ5XG5cblxuXHRcdFx0dGhpcy5zZXRJbmRleChpbmRpY2VzKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobm9ybWFscywgMykpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodXZzLCAyKSk7XG5cdFx0fVxuXG5cdFx0c3RhdGljIGZyb21KU09OKGRhdGEpIHtcblx0XHRcdHJldHVybiBuZXcgUmluZ0dlb21ldHJ5KGRhdGEuaW5uZXJSYWRpdXMsIGRhdGEub3V0ZXJSYWRpdXMsIGRhdGEudGhldGFTZWdtZW50cywgZGF0YS5waGlTZWdtZW50cywgZGF0YS50aGV0YVN0YXJ0LCBkYXRhLnRoZXRhTGVuZ3RoKTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIFNoYXBlR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cdFx0Y29uc3RydWN0b3Ioc2hhcGVzID0gbmV3IFNoYXBlKFtuZXcgVmVjdG9yMigwLCAwLjUpLCBuZXcgVmVjdG9yMigtMC41LCAtMC41KSwgbmV3IFZlY3RvcjIoMC41LCAtMC41KV0pLCBjdXJ2ZVNlZ21lbnRzID0gMTIpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnU2hhcGVHZW9tZXRyeSc7XG5cdFx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRcdHNoYXBlczogc2hhcGVzLFxuXHRcdFx0XHRjdXJ2ZVNlZ21lbnRzOiBjdXJ2ZVNlZ21lbnRzXG5cdFx0XHR9OyAvLyBidWZmZXJzXG5cblx0XHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblx0XHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0XHRjb25zdCB1dnMgPSBbXTsgLy8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0XHRsZXQgZ3JvdXBTdGFydCA9IDA7XG5cdFx0XHRsZXQgZ3JvdXBDb3VudCA9IDA7IC8vIGFsbG93IHNpbmdsZSBhbmQgYXJyYXkgdmFsdWVzIGZvciBcInNoYXBlc1wiIHBhcmFtZXRlclxuXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShzaGFwZXMpID09PSBmYWxzZSkge1xuXHRcdFx0XHRhZGRTaGFwZShzaGFwZXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRhZGRTaGFwZShzaGFwZXNbaV0pO1xuXHRcdFx0XHRcdHRoaXMuYWRkR3JvdXAoZ3JvdXBTdGFydCwgZ3JvdXBDb3VudCwgaSk7IC8vIGVuYWJsZXMgTXVsdGlNYXRlcmlhbCBzdXBwb3J0XG5cblx0XHRcdFx0XHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XG5cdFx0XHRcdFx0Z3JvdXBDb3VudCA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH0gLy8gYnVpbGQgZ2VvbWV0cnlcblxuXG5cdFx0XHR0aGlzLnNldEluZGV4KGluZGljZXMpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShub3JtYWxzLCAzKSk7XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTsgLy8gaGVscGVyIGZ1bmN0aW9uc1xuXG5cdFx0XHRmdW5jdGlvbiBhZGRTaGFwZShzaGFwZSkge1xuXHRcdFx0XHRjb25zdCBpbmRleE9mZnNldCA9IHZlcnRpY2VzLmxlbmd0aCAvIDM7XG5cdFx0XHRcdGNvbnN0IHBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoY3VydmVTZWdtZW50cyk7XG5cdFx0XHRcdGxldCBzaGFwZVZlcnRpY2VzID0gcG9pbnRzLnNoYXBlO1xuXHRcdFx0XHRjb25zdCBzaGFwZUhvbGVzID0gcG9pbnRzLmhvbGVzOyAvLyBjaGVjayBkaXJlY3Rpb24gb2YgdmVydGljZXNcblxuXHRcdFx0XHRpZiAoU2hhcGVVdGlscy5pc0Nsb2NrV2lzZShzaGFwZVZlcnRpY2VzKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRzaGFwZVZlcnRpY2VzID0gc2hhcGVWZXJ0aWNlcy5yZXZlcnNlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHNoYXBlSG9sZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3Qgc2hhcGVIb2xlID0gc2hhcGVIb2xlc1tpXTtcblxuXHRcdFx0XHRcdGlmIChTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKHNoYXBlSG9sZSkgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdHNoYXBlSG9sZXNbaV0gPSBzaGFwZUhvbGUucmV2ZXJzZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGZhY2VzID0gU2hhcGVVdGlscy50cmlhbmd1bGF0ZVNoYXBlKHNoYXBlVmVydGljZXMsIHNoYXBlSG9sZXMpOyAvLyBqb2luIHZlcnRpY2VzIG9mIGlubmVyIGFuZCBvdXRlciBwYXRocyB0byBhIHNpbmdsZSBhcnJheVxuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gc2hhcGVIb2xlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBzaGFwZUhvbGUgPSBzaGFwZUhvbGVzW2ldO1xuXHRcdFx0XHRcdHNoYXBlVmVydGljZXMgPSBzaGFwZVZlcnRpY2VzLmNvbmNhdChzaGFwZUhvbGUpO1xuXHRcdFx0XHR9IC8vIHZlcnRpY2VzLCBub3JtYWxzLCB1dnNcblxuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gc2hhcGVWZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCB2ZXJ0ZXggPSBzaGFwZVZlcnRpY2VzW2ldO1xuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2godmVydGV4LngsIHZlcnRleC55LCAwKTtcblx0XHRcdFx0XHRub3JtYWxzLnB1c2goMCwgMCwgMSk7XG5cdFx0XHRcdFx0dXZzLnB1c2godmVydGV4LngsIHZlcnRleC55KTsgLy8gd29ybGQgdXZzXG5cdFx0XHRcdH0gLy8gaW5jaWRlc1xuXG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBmYWNlID0gZmFjZXNbaV07XG5cdFx0XHRcdFx0Y29uc3QgYSA9IGZhY2VbMF0gKyBpbmRleE9mZnNldDtcblx0XHRcdFx0XHRjb25zdCBiID0gZmFjZVsxXSArIGluZGV4T2Zmc2V0O1xuXHRcdFx0XHRcdGNvbnN0IGMgPSBmYWNlWzJdICsgaW5kZXhPZmZzZXQ7XG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKGEsIGIsIGMpO1xuXHRcdFx0XHRcdGdyb3VwQ291bnQgKz0gMztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRvSlNPTigpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblx0XHRcdGNvbnN0IHNoYXBlcyA9IHRoaXMucGFyYW1ldGVycy5zaGFwZXM7XG5cdFx0XHRyZXR1cm4gdG9KU09OKHNoYXBlcywgZGF0YSk7XG5cdFx0fVxuXG5cdFx0c3RhdGljIGZyb21KU09OKGRhdGEsIHNoYXBlcykge1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnlTaGFwZXMgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaiA9IDAsIGpsID0gZGF0YS5zaGFwZXMubGVuZ3RoOyBqIDwgamw7IGorKykge1xuXHRcdFx0XHRjb25zdCBzaGFwZSA9IHNoYXBlc1tkYXRhLnNoYXBlc1tqXV07XG5cdFx0XHRcdGdlb21ldHJ5U2hhcGVzLnB1c2goc2hhcGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IFNoYXBlR2VvbWV0cnkoZ2VvbWV0cnlTaGFwZXMsIGRhdGEuY3VydmVTZWdtZW50cyk7XG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiB0b0pTT04oc2hhcGVzLCBkYXRhKSB7XG5cdFx0ZGF0YS5zaGFwZXMgPSBbXTtcblxuXHRcdGlmIChBcnJheS5pc0FycmF5KHNoYXBlcykpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gc2hhcGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRjb25zdCBzaGFwZSA9IHNoYXBlc1tpXTtcblx0XHRcdFx0ZGF0YS5zaGFwZXMucHVzaChzaGFwZS51dWlkKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YS5zaGFwZXMucHVzaChzaGFwZXMudXVpZCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGE7XG5cdH1cblxuXHRjbGFzcyBTcGhlcmVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblx0XHRjb25zdHJ1Y3RvcihyYWRpdXMgPSAxLCB3aWR0aFNlZ21lbnRzID0gMzIsIGhlaWdodFNlZ21lbnRzID0gMTYsIHBoaVN0YXJ0ID0gMCwgcGhpTGVuZ3RoID0gTWF0aC5QSSAqIDIsIHRoZXRhU3RhcnQgPSAwLCB0aGV0YUxlbmd0aCA9IE1hdGguUEkpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnU3BoZXJlR2VvbWV0cnknO1xuXHRcdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcblx0XHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuXHRcdFx0XHRwaGlTdGFydDogcGhpU3RhcnQsXG5cdFx0XHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoLFxuXHRcdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0XHRcdH07XG5cdFx0XHR3aWR0aFNlZ21lbnRzID0gTWF0aC5tYXgoMywgTWF0aC5mbG9vcih3aWR0aFNlZ21lbnRzKSk7XG5cdFx0XHRoZWlnaHRTZWdtZW50cyA9IE1hdGgubWF4KDIsIE1hdGguZmxvb3IoaGVpZ2h0U2VnbWVudHMpKTtcblx0XHRcdGNvbnN0IHRoZXRhRW5kID0gTWF0aC5taW4odGhldGFTdGFydCArIHRoZXRhTGVuZ3RoLCBNYXRoLlBJKTtcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRjb25zdCBncmlkID0gW107XG5cdFx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3Qgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTsgLy8gYnVmZmVyc1xuXG5cdFx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdFx0Y29uc3QgdXZzID0gW107IC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdFx0Zm9yIChsZXQgaXkgPSAwOyBpeSA8PSBoZWlnaHRTZWdtZW50czsgaXkrKykge1xuXHRcdFx0XHRjb25zdCB2ZXJ0aWNlc1JvdyA9IFtdO1xuXHRcdFx0XHRjb25zdCB2ID0gaXkgLyBoZWlnaHRTZWdtZW50czsgLy8gc3BlY2lhbCBjYXNlIGZvciB0aGUgcG9sZXNcblxuXHRcdFx0XHRsZXQgdU9mZnNldCA9IDA7XG5cblx0XHRcdFx0aWYgKGl5ID09IDAgJiYgdGhldGFTdGFydCA9PSAwKSB7XG5cdFx0XHRcdFx0dU9mZnNldCA9IDAuNSAvIHdpZHRoU2VnbWVudHM7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXkgPT0gaGVpZ2h0U2VnbWVudHMgJiYgdGhldGFFbmQgPT0gTWF0aC5QSSkge1xuXHRcdFx0XHRcdHVPZmZzZXQgPSAtMC41IC8gd2lkdGhTZWdtZW50cztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAobGV0IGl4ID0gMDsgaXggPD0gd2lkdGhTZWdtZW50czsgaXgrKykge1xuXHRcdFx0XHRcdGNvbnN0IHUgPSBpeCAvIHdpZHRoU2VnbWVudHM7IC8vIHZlcnRleFxuXG5cdFx0XHRcdFx0dmVydGV4LnggPSAtcmFkaXVzICogTWF0aC5jb3MocGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoKSAqIE1hdGguc2luKHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGgpO1xuXHRcdFx0XHRcdHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5jb3ModGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCk7XG5cdFx0XHRcdFx0dmVydGV4LnogPSByYWRpdXMgKiBNYXRoLnNpbihwaGlTdGFydCArIHUgKiBwaGlMZW5ndGgpICogTWF0aC5zaW4odGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCk7XG5cdFx0XHRcdFx0dmVydGljZXMucHVzaCh2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56KTsgLy8gbm9ybWFsXG5cblx0XHRcdFx0XHRub3JtYWwuY29weSh2ZXJ0ZXgpLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHRcdG5vcm1hbHMucHVzaChub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56KTsgLy8gdXZcblxuXHRcdFx0XHRcdHV2cy5wdXNoKHUgKyB1T2Zmc2V0LCAxIC0gdik7XG5cdFx0XHRcdFx0dmVydGljZXNSb3cucHVzaChpbmRleCsrKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdyaWQucHVzaCh2ZXJ0aWNlc1Jvdyk7XG5cdFx0XHR9IC8vIGluZGljZXNcblxuXG5cdFx0XHRmb3IgKGxldCBpeSA9IDA7IGl5IDwgaGVpZ2h0U2VnbWVudHM7IGl5KyspIHtcblx0XHRcdFx0Zm9yIChsZXQgaXggPSAwOyBpeCA8IHdpZHRoU2VnbWVudHM7IGl4KyspIHtcblx0XHRcdFx0XHRjb25zdCBhID0gZ3JpZFtpeV1baXggKyAxXTtcblx0XHRcdFx0XHRjb25zdCBiID0gZ3JpZFtpeV1baXhdO1xuXHRcdFx0XHRcdGNvbnN0IGMgPSBncmlkW2l5ICsgMV1baXhdO1xuXHRcdFx0XHRcdGNvbnN0IGQgPSBncmlkW2l5ICsgMV1baXggKyAxXTtcblx0XHRcdFx0XHRpZiAoaXkgIT09IDAgfHwgdGhldGFTdGFydCA+IDApIGluZGljZXMucHVzaChhLCBiLCBkKTtcblx0XHRcdFx0XHRpZiAoaXkgIT09IGhlaWdodFNlZ21lbnRzIC0gMSB8fCB0aGV0YUVuZCA8IE1hdGguUEkpIGluZGljZXMucHVzaChiLCBjLCBkKTtcblx0XHRcdFx0fVxuXHRcdFx0fSAvLyBidWlsZCBnZW9tZXRyeVxuXG5cblx0XHRcdHRoaXMuc2V0SW5kZXgoaW5kaWNlcyk7XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0aWNlcywgMykpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKG5vcm1hbHMsIDMpKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHV2cywgMikpO1xuXHRcdH1cblxuXHRcdHN0YXRpYyBmcm9tSlNPTihkYXRhKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNwaGVyZUdlb21ldHJ5KGRhdGEucmFkaXVzLCBkYXRhLndpZHRoU2VnbWVudHMsIGRhdGEuaGVpZ2h0U2VnbWVudHMsIGRhdGEucGhpU3RhcnQsIGRhdGEucGhpTGVuZ3RoLCBkYXRhLnRoZXRhU3RhcnQsIGRhdGEudGhldGFMZW5ndGgpO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgVGV0cmFoZWRyb25HZW9tZXRyeSBleHRlbmRzIFBvbHloZWRyb25HZW9tZXRyeSB7XG5cdFx0Y29uc3RydWN0b3IocmFkaXVzID0gMSwgZGV0YWlsID0gMCkge1xuXHRcdFx0Y29uc3QgdmVydGljZXMgPSBbMSwgMSwgMSwgLTEsIC0xLCAxLCAtMSwgMSwgLTEsIDEsIC0xLCAtMV07XG5cdFx0XHRjb25zdCBpbmRpY2VzID0gWzIsIDEsIDAsIDAsIDMsIDIsIDEsIDMsIDAsIDIsIDMsIDFdO1xuXHRcdFx0c3VwZXIodmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsKTtcblx0XHRcdHRoaXMudHlwZSA9ICdUZXRyYWhlZHJvbkdlb21ldHJ5Jztcblx0XHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRcdGRldGFpbDogZGV0YWlsXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHN0YXRpYyBmcm9tSlNPTihkYXRhKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFRldHJhaGVkcm9uR2VvbWV0cnkoZGF0YS5yYWRpdXMsIGRhdGEuZGV0YWlsKTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIFRvcnVzR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cdFx0Y29uc3RydWN0b3IocmFkaXVzID0gMSwgdHViZSA9IDAuNCwgcmFkaWFsU2VnbWVudHMgPSA4LCB0dWJ1bGFyU2VnbWVudHMgPSA2LCBhcmMgPSBNYXRoLlBJICogMikge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdUb3J1c0dlb21ldHJ5Jztcblx0XHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRcdHR1YmU6IHR1YmUsXG5cdFx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcblx0XHRcdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXG5cdFx0XHRcdGFyYzogYXJjXG5cdFx0XHR9O1xuXHRcdFx0cmFkaWFsU2VnbWVudHMgPSBNYXRoLmZsb29yKHJhZGlhbFNlZ21lbnRzKTtcblx0XHRcdHR1YnVsYXJTZWdtZW50cyA9IE1hdGguZmxvb3IodHVidWxhclNlZ21lbnRzKTsgLy8gYnVmZmVyc1xuXG5cdFx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdFx0Y29uc3QgdXZzID0gW107IC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdFx0Y29uc3QgY2VudGVyID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpOyAvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqKyspIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCB1ID0gaSAvIHR1YnVsYXJTZWdtZW50cyAqIGFyYztcblx0XHRcdFx0XHRjb25zdCB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7IC8vIHZlcnRleFxuXG5cdFx0XHRcdFx0dmVydGV4LnggPSAocmFkaXVzICsgdHViZSAqIE1hdGguY29zKHYpKSAqIE1hdGguY29zKHUpO1xuXHRcdFx0XHRcdHZlcnRleC55ID0gKHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyh2KSkgKiBNYXRoLnNpbih1KTtcblx0XHRcdFx0XHR2ZXJ0ZXgueiA9IHR1YmUgKiBNYXRoLnNpbih2KTtcblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnopOyAvLyBub3JtYWxcblxuXHRcdFx0XHRcdGNlbnRlci54ID0gcmFkaXVzICogTWF0aC5jb3ModSk7XG5cdFx0XHRcdFx0Y2VudGVyLnkgPSByYWRpdXMgKiBNYXRoLnNpbih1KTtcblx0XHRcdFx0XHRub3JtYWwuc3ViVmVjdG9ycyh2ZXJ0ZXgsIGNlbnRlcikubm9ybWFsaXplKCk7XG5cdFx0XHRcdFx0bm9ybWFscy5wdXNoKG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnopOyAvLyB1dlxuXG5cdFx0XHRcdFx0dXZzLnB1c2goaSAvIHR1YnVsYXJTZWdtZW50cyk7XG5cdFx0XHRcdFx0dXZzLnB1c2goaiAvIHJhZGlhbFNlZ21lbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSAvLyBnZW5lcmF0ZSBpbmRpY2VzXG5cblxuXHRcdFx0Zm9yIChsZXQgaiA9IDE7IGogPD0gcmFkaWFsU2VnbWVudHM7IGorKykge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkrKykge1xuXHRcdFx0XHRcdC8vIGluZGljZXNcblx0XHRcdFx0XHRjb25zdCBhID0gKHR1YnVsYXJTZWdtZW50cyArIDEpICogaiArIGkgLSAxO1xuXHRcdFx0XHRcdGNvbnN0IGIgPSAodHVidWxhclNlZ21lbnRzICsgMSkgKiAoaiAtIDEpICsgaSAtIDE7XG5cdFx0XHRcdFx0Y29uc3QgYyA9ICh0dWJ1bGFyU2VnbWVudHMgKyAxKSAqIChqIC0gMSkgKyBpO1xuXHRcdFx0XHRcdGNvbnN0IGQgPSAodHVidWxhclNlZ21lbnRzICsgMSkgKiBqICsgaTsgLy8gZmFjZXNcblxuXHRcdFx0XHRcdGluZGljZXMucHVzaChhLCBiLCBkKTtcblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goYiwgYywgZCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gLy8gYnVpbGQgZ2VvbWV0cnlcblxuXG5cdFx0XHR0aGlzLnNldEluZGV4KGluZGljZXMpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShub3JtYWxzLCAzKSk7XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTtcblx0XHR9XG5cblx0XHRzdGF0aWMgZnJvbUpTT04oZGF0YSkge1xuXHRcdFx0cmV0dXJuIG5ldyBUb3J1c0dlb21ldHJ5KGRhdGEucmFkaXVzLCBkYXRhLnR1YmUsIGRhdGEucmFkaWFsU2VnbWVudHMsIGRhdGEudHVidWxhclNlZ21lbnRzLCBkYXRhLmFyYyk7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBUb3J1c0tub3RHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblx0XHRjb25zdHJ1Y3RvcihyYWRpdXMgPSAxLCB0dWJlID0gMC40LCB0dWJ1bGFyU2VnbWVudHMgPSA2NCwgcmFkaWFsU2VnbWVudHMgPSA4LCBwID0gMiwgcSA9IDMpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnVG9ydXNLbm90R2VvbWV0cnknO1xuXHRcdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdFx0dHViZTogdHViZSxcblx0XHRcdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXG5cdFx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcblx0XHRcdFx0cDogcCxcblx0XHRcdFx0cTogcVxuXHRcdFx0fTtcblx0XHRcdHR1YnVsYXJTZWdtZW50cyA9IE1hdGguZmxvb3IodHVidWxhclNlZ21lbnRzKTtcblx0XHRcdHJhZGlhbFNlZ21lbnRzID0gTWF0aC5mbG9vcihyYWRpYWxTZWdtZW50cyk7IC8vIGJ1ZmZlcnNcblxuXHRcdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRcdGNvbnN0IHV2cyA9IFtdOyAvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgUDEgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgUDIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgQiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBUID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IE4gPSBuZXcgVmVjdG9yMygpOyAvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgKytpKSB7XG5cdFx0XHRcdC8vIHRoZSByYWRpYW4gXCJ1XCIgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIHBvc2l0aW9uIG9uIHRoZSB0b3J1cyBjdXJ2ZSBvZiB0aGUgY3VycmVudCB0dWJ1bGFyIHNlZ2VtZW50XG5cdFx0XHRcdGNvbnN0IHUgPSBpIC8gdHVidWxhclNlZ21lbnRzICogcCAqIE1hdGguUEkgKiAyOyAvLyBub3cgd2UgY2FsY3VsYXRlIHR3byBwb2ludHMuIFAxIGlzIG91ciBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSBjdXJ2ZSwgUDIgaXMgYSBsaXR0bGUgZmFydGhlciBhaGVhZC5cblx0XHRcdFx0Ly8gdGhlc2UgcG9pbnRzIGFyZSB1c2VkIHRvIGNyZWF0ZSBhIHNwZWNpYWwgXCJjb29yZGluYXRlIHNwYWNlXCIsIHdoaWNoIGlzIG5lY2Vzc2FyeSB0byBjYWxjdWxhdGUgdGhlIGNvcnJlY3QgdmVydGV4IHBvc2l0aW9uc1xuXG5cdFx0XHRcdGNhbGN1bGF0ZVBvc2l0aW9uT25DdXJ2ZSh1LCBwLCBxLCByYWRpdXMsIFAxKTtcblx0XHRcdFx0Y2FsY3VsYXRlUG9zaXRpb25PbkN1cnZlKHUgKyAwLjAxLCBwLCBxLCByYWRpdXMsIFAyKTsgLy8gY2FsY3VsYXRlIG9ydGhvbm9ybWFsIGJhc2lzXG5cblx0XHRcdFx0VC5zdWJWZWN0b3JzKFAyLCBQMSk7XG5cdFx0XHRcdE4uYWRkVmVjdG9ycyhQMiwgUDEpO1xuXHRcdFx0XHRCLmNyb3NzVmVjdG9ycyhULCBOKTtcblx0XHRcdFx0Ti5jcm9zc1ZlY3RvcnMoQiwgVCk7IC8vIG5vcm1hbGl6ZSBCLCBOLiBUIGNhbiBiZSBpZ25vcmVkLCB3ZSBkb24ndCB1c2UgaXRcblxuXHRcdFx0XHRCLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHROLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyArK2opIHtcblx0XHRcdFx0XHQvLyBub3cgY2FsY3VsYXRlIHRoZSB2ZXJ0aWNlcy4gdGhleSBhcmUgbm90aGluZyBtb3JlIHRoYW4gYW4gZXh0cnVzaW9uIG9mIHRoZSB0b3J1cyBjdXJ2ZS5cblx0XHRcdFx0XHQvLyBiZWNhdXNlIHdlIGV4dHJ1ZGUgYSBzaGFwZSBpbiB0aGUgeHktcGxhbmUsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsY3VsYXRlIGEgei12YWx1ZS5cblx0XHRcdFx0XHRjb25zdCB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XG5cdFx0XHRcdFx0Y29uc3QgY3ggPSAtdHViZSAqIE1hdGguY29zKHYpO1xuXHRcdFx0XHRcdGNvbnN0IGN5ID0gdHViZSAqIE1hdGguc2luKHYpOyAvLyBub3cgY2FsY3VsYXRlIHRoZSBmaW5hbCB2ZXJ0ZXggcG9zaXRpb24uXG5cdFx0XHRcdFx0Ly8gZmlyc3Qgd2Ugb3JpZW50IHRoZSBleHRydXNpb24gd2l0aCBvdXIgYmFzaXMgdmVjdG9zLCB0aGVuIHdlIGFkZCBpdCB0byB0aGUgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgY3VydmVcblxuXHRcdFx0XHRcdHZlcnRleC54ID0gUDEueCArIChjeCAqIE4ueCArIGN5ICogQi54KTtcblx0XHRcdFx0XHR2ZXJ0ZXgueSA9IFAxLnkgKyAoY3ggKiBOLnkgKyBjeSAqIEIueSk7XG5cdFx0XHRcdFx0dmVydGV4LnogPSBQMS56ICsgKGN4ICogTi56ICsgY3kgKiBCLnopO1xuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2godmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueik7IC8vIG5vcm1hbCAoUDEgaXMgYWx3YXlzIHRoZSBjZW50ZXIvb3JpZ2luIG9mIHRoZSBleHRydXNpb24sIHRodXMgd2UgY2FuIHVzZSBpdCB0byBjYWxjdWxhdGUgdGhlIG5vcm1hbClcblxuXHRcdFx0XHRcdG5vcm1hbC5zdWJWZWN0b3JzKHZlcnRleCwgUDEpLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHRcdG5vcm1hbHMucHVzaChub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56KTsgLy8gdXZcblxuXHRcdFx0XHRcdHV2cy5wdXNoKGkgLyB0dWJ1bGFyU2VnbWVudHMpO1xuXHRcdFx0XHRcdHV2cy5wdXNoKGogLyByYWRpYWxTZWdtZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdH0gLy8gZ2VuZXJhdGUgaW5kaWNlc1xuXG5cblx0XHRcdGZvciAobGV0IGogPSAxOyBqIDw9IHR1YnVsYXJTZWdtZW50czsgaisrKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDw9IHJhZGlhbFNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0XHQvLyBpbmRpY2VzXG5cdFx0XHRcdFx0Y29uc3QgYSA9IChyYWRpYWxTZWdtZW50cyArIDEpICogKGogLSAxKSArIChpIC0gMSk7XG5cdFx0XHRcdFx0Y29uc3QgYiA9IChyYWRpYWxTZWdtZW50cyArIDEpICogaiArIChpIC0gMSk7XG5cdFx0XHRcdFx0Y29uc3QgYyA9IChyYWRpYWxTZWdtZW50cyArIDEpICogaiArIGk7XG5cdFx0XHRcdFx0Y29uc3QgZCA9IChyYWRpYWxTZWdtZW50cyArIDEpICogKGogLSAxKSArIGk7IC8vIGZhY2VzXG5cblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goYSwgYiwgZCk7XG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKGIsIGMsIGQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IC8vIGJ1aWxkIGdlb21ldHJ5XG5cblxuXHRcdFx0dGhpcy5zZXRJbmRleChpbmRpY2VzKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobm9ybWFscywgMykpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodXZzLCAyKSk7IC8vIHRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgdG9ydXMgY3VydmVcblxuXHRcdFx0ZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25PbkN1cnZlKHUsIHAsIHEsIHJhZGl1cywgcG9zaXRpb24pIHtcblx0XHRcdFx0Y29uc3QgY3UgPSBNYXRoLmNvcyh1KTtcblx0XHRcdFx0Y29uc3Qgc3UgPSBNYXRoLnNpbih1KTtcblx0XHRcdFx0Y29uc3QgcXVPdmVyUCA9IHEgLyBwICogdTtcblx0XHRcdFx0Y29uc3QgY3MgPSBNYXRoLmNvcyhxdU92ZXJQKTtcblx0XHRcdFx0cG9zaXRpb24ueCA9IHJhZGl1cyAqICgyICsgY3MpICogMC41ICogY3U7XG5cdFx0XHRcdHBvc2l0aW9uLnkgPSByYWRpdXMgKiAoMiArIGNzKSAqIHN1ICogMC41O1xuXHRcdFx0XHRwb3NpdGlvbi56ID0gcmFkaXVzICogTWF0aC5zaW4ocXVPdmVyUCkgKiAwLjU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c3RhdGljIGZyb21KU09OKGRhdGEpIHtcblx0XHRcdHJldHVybiBuZXcgVG9ydXNLbm90R2VvbWV0cnkoZGF0YS5yYWRpdXMsIGRhdGEudHViZSwgZGF0YS50dWJ1bGFyU2VnbWVudHMsIGRhdGEucmFkaWFsU2VnbWVudHMsIGRhdGEucCwgZGF0YS5xKTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIFR1YmVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblx0XHRjb25zdHJ1Y3RvcihwYXRoID0gbmV3IFF1YWRyYXRpY0JlemllckN1cnZlMyhuZXcgVmVjdG9yMygtMSwgLTEsIDApLCBuZXcgVmVjdG9yMygtMSwgMSwgMCksIG5ldyBWZWN0b3IzKDEsIDEsIDApKSwgdHVidWxhclNlZ21lbnRzID0gNjQsIHJhZGl1cyA9IDEsIHJhZGlhbFNlZ21lbnRzID0gOCwgY2xvc2VkID0gZmFsc2UpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnVHViZUdlb21ldHJ5Jztcblx0XHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdFx0cGF0aDogcGF0aCxcblx0XHRcdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXG5cdFx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG5cdFx0XHRcdGNsb3NlZDogY2xvc2VkXG5cdFx0XHR9O1xuXHRcdFx0Y29uc3QgZnJhbWVzID0gcGF0aC5jb21wdXRlRnJlbmV0RnJhbWVzKHR1YnVsYXJTZWdtZW50cywgY2xvc2VkKTsgLy8gZXhwb3NlIGludGVybmFsc1xuXG5cdFx0XHR0aGlzLnRhbmdlbnRzID0gZnJhbWVzLnRhbmdlbnRzO1xuXHRcdFx0dGhpcy5ub3JtYWxzID0gZnJhbWVzLm5vcm1hbHM7XG5cdFx0XHR0aGlzLmJpbm9ybWFscyA9IGZyYW1lcy5iaW5vcm1hbHM7IC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCB1diA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0XHRsZXQgUCA9IG5ldyBWZWN0b3IzKCk7IC8vIGJ1ZmZlclxuXG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdFx0Y29uc3QgdXZzID0gW107XG5cdFx0XHRjb25zdCBpbmRpY2VzID0gW107IC8vIGNyZWF0ZSBidWZmZXIgZGF0YVxuXG5cdFx0XHRnZW5lcmF0ZUJ1ZmZlckRhdGEoKTsgLy8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdFx0dGhpcy5zZXRJbmRleChpbmRpY2VzKTtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobm9ybWFscywgMykpO1xuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodXZzLCAyKSk7IC8vIGZ1bmN0aW9uc1xuXG5cdFx0XHRmdW5jdGlvbiBnZW5lcmF0ZUJ1ZmZlckRhdGEoKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdHVidWxhclNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0XHRnZW5lcmF0ZVNlZ21lbnQoaSk7XG5cdFx0XHRcdH0gLy8gaWYgdGhlIGdlb21ldHJ5IGlzIG5vdCBjbG9zZWQsIGdlbmVyYXRlIHRoZSBsYXN0IHJvdyBvZiB2ZXJ0aWNlcyBhbmQgbm9ybWFsc1xuXHRcdFx0XHQvLyBhdCB0aGUgcmVndWxhciBwb3NpdGlvbiBvbiB0aGUgZ2l2ZW4gcGF0aFxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBpZiB0aGUgZ2VvbWV0cnkgaXMgY2xvc2VkLCBkdXBsaWNhdGUgdGhlIGZpcnN0IHJvdyBvZiB2ZXJ0aWNlcyBhbmQgbm9ybWFscyAodXZzIHdpbGwgZGlmZmVyKVxuXG5cblx0XHRcdFx0Z2VuZXJhdGVTZWdtZW50KGNsb3NlZCA9PT0gZmFsc2UgPyB0dWJ1bGFyU2VnbWVudHMgOiAwKTsgLy8gdXZzIGFyZSBnZW5lcmF0ZWQgaW4gYSBzZXBhcmF0ZSBmdW5jdGlvbi5cblx0XHRcdFx0Ly8gdGhpcyBtYWtlcyBpdCBlYXN5IGNvbXB1dGUgY29ycmVjdCB2YWx1ZXMgZm9yIGNsb3NlZCBnZW9tZXRyaWVzXG5cblx0XHRcdFx0Z2VuZXJhdGVVVnMoKTsgLy8gZmluYWxseSBjcmVhdGUgZmFjZXNcblxuXHRcdFx0XHRnZW5lcmF0ZUluZGljZXMoKTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZ2VuZXJhdGVTZWdtZW50KGkpIHtcblx0XHRcdFx0Ly8gd2UgdXNlIGdldFBvaW50QXQgdG8gc2FtcGxlIGV2ZW5seSBkaXN0cmlidXRlZCBwb2ludHMgZnJvbSB0aGUgZ2l2ZW4gcGF0aFxuXHRcdFx0XHRQID0gcGF0aC5nZXRQb2ludEF0KGkgLyB0dWJ1bGFyU2VnbWVudHMsIFApOyAvLyByZXRyaWV2ZSBjb3JyZXNwb25kaW5nIG5vcm1hbCBhbmQgYmlub3JtYWxcblxuXHRcdFx0XHRjb25zdCBOID0gZnJhbWVzLm5vcm1hbHNbaV07XG5cdFx0XHRcdGNvbnN0IEIgPSBmcmFtZXMuYmlub3JtYWxzW2ldOyAvLyBnZW5lcmF0ZSBub3JtYWxzIGFuZCB2ZXJ0aWNlcyBmb3IgdGhlIGN1cnJlbnQgc2VnbWVudFxuXG5cdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqKyspIHtcblx0XHRcdFx0XHRjb25zdCB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XG5cdFx0XHRcdFx0Y29uc3Qgc2luID0gTWF0aC5zaW4odik7XG5cdFx0XHRcdFx0Y29uc3QgY29zID0gLU1hdGguY29zKHYpOyAvLyBub3JtYWxcblxuXHRcdFx0XHRcdG5vcm1hbC54ID0gY29zICogTi54ICsgc2luICogQi54O1xuXHRcdFx0XHRcdG5vcm1hbC55ID0gY29zICogTi55ICsgc2luICogQi55O1xuXHRcdFx0XHRcdG5vcm1hbC56ID0gY29zICogTi56ICsgc2luICogQi56O1xuXHRcdFx0XHRcdG5vcm1hbC5ub3JtYWxpemUoKTtcblx0XHRcdFx0XHRub3JtYWxzLnB1c2gobm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueik7IC8vIHZlcnRleFxuXG5cdFx0XHRcdFx0dmVydGV4LnggPSBQLnggKyByYWRpdXMgKiBub3JtYWwueDtcblx0XHRcdFx0XHR2ZXJ0ZXgueSA9IFAueSArIHJhZGl1cyAqIG5vcm1hbC55O1xuXHRcdFx0XHRcdHZlcnRleC56ID0gUC56ICsgcmFkaXVzICogbm9ybWFsLno7XG5cdFx0XHRcdFx0dmVydGljZXMucHVzaCh2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBnZW5lcmF0ZUluZGljZXMoKSB7XG5cdFx0XHRcdGZvciAobGV0IGogPSAxOyBqIDw9IHR1YnVsYXJTZWdtZW50czsgaisrKSB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPD0gcmFkaWFsU2VnbWVudHM7IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgYSA9IChyYWRpYWxTZWdtZW50cyArIDEpICogKGogLSAxKSArIChpIC0gMSk7XG5cdFx0XHRcdFx0XHRjb25zdCBiID0gKHJhZGlhbFNlZ21lbnRzICsgMSkgKiBqICsgKGkgLSAxKTtcblx0XHRcdFx0XHRcdGNvbnN0IGMgPSAocmFkaWFsU2VnbWVudHMgKyAxKSAqIGogKyBpO1xuXHRcdFx0XHRcdFx0Y29uc3QgZCA9IChyYWRpYWxTZWdtZW50cyArIDEpICogKGogLSAxKSArIGk7IC8vIGZhY2VzXG5cblx0XHRcdFx0XHRcdGluZGljZXMucHVzaChhLCBiLCBkKTtcblx0XHRcdFx0XHRcdGluZGljZXMucHVzaChiLCBjLCBkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZ2VuZXJhdGVVVnMoKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSsrKSB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGorKykge1xuXHRcdFx0XHRcdFx0dXYueCA9IGkgLyB0dWJ1bGFyU2VnbWVudHM7XG5cdFx0XHRcdFx0XHR1di55ID0gaiAvIHJhZGlhbFNlZ21lbnRzO1xuXHRcdFx0XHRcdFx0dXZzLnB1c2godXYueCwgdXYueSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dG9KU09OKCkge1xuXHRcdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXHRcdFx0ZGF0YS5wYXRoID0gdGhpcy5wYXJhbWV0ZXJzLnBhdGgudG9KU09OKCk7XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHRzdGF0aWMgZnJvbUpTT04oZGF0YSkge1xuXHRcdFx0Ly8gVGhpcyBvbmx5IHdvcmtzIGZvciBidWlsdC1pbiBjdXJ2ZXMgKGUuZy4gQ2F0bXVsbFJvbUN1cnZlMykuXG5cdFx0XHQvLyBVc2VyIGRlZmluZWQgY3VydmVzIG9yIGluc3RhbmNlcyBvZiBDdXJ2ZVBhdGggd2lsbCBub3QgYmUgZGVzZXJpYWxpemVkLlxuXHRcdFx0cmV0dXJuIG5ldyBUdWJlR2VvbWV0cnkobmV3IEN1cnZlc1tkYXRhLnBhdGgudHlwZV0oKS5mcm9tSlNPTihkYXRhLnBhdGgpLCBkYXRhLnR1YnVsYXJTZWdtZW50cywgZGF0YS5yYWRpdXMsIGRhdGEucmFkaWFsU2VnbWVudHMsIGRhdGEuY2xvc2VkKTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIFdpcmVmcmFtZUdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXHRcdGNvbnN0cnVjdG9yKGdlb21ldHJ5ID0gbnVsbCkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdXaXJlZnJhbWVHZW9tZXRyeSc7XG5cdFx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRcdGdlb21ldHJ5OiBnZW9tZXRyeVxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKGdlb21ldHJ5ICE9PSBudWxsKSB7XG5cdFx0XHRcdC8vIGJ1ZmZlclxuXHRcdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0XHRjb25zdCBlZGdlcyA9IG5ldyBTZXQoKTsgLy8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0XHRcdGNvbnN0IHN0YXJ0ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0Y29uc3QgZW5kID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0XHRpZiAoZ2VvbWV0cnkuaW5kZXggIT09IG51bGwpIHtcblx0XHRcdFx0XHQvLyBpbmRleGVkIEJ1ZmZlckdlb21ldHJ5XG5cdFx0XHRcdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0XHRcdGNvbnN0IGluZGljZXMgPSBnZW9tZXRyeS5pbmRleDtcblx0XHRcdFx0XHRsZXQgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXG5cdFx0XHRcdFx0aWYgKGdyb3Vwcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRcdGdyb3VwcyA9IFt7XG5cdFx0XHRcdFx0XHRcdHN0YXJ0OiAwLFxuXHRcdFx0XHRcdFx0XHRjb3VudDogaW5kaWNlcy5jb3VudCxcblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWxJbmRleDogMFxuXHRcdFx0XHRcdFx0fV07XG5cdFx0XHRcdFx0fSAvLyBjcmVhdGUgYSBkYXRhIHN0cnVjdHVyZSB0aGF0IGNvbnRhaW5zIGFsbCBlZ2VzIHdpdGhvdXQgZHVwbGljYXRlc1xuXG5cblx0XHRcdFx0XHRmb3IgKGxldCBvID0gMCwgb2wgPSBncm91cHMubGVuZ3RoOyBvIDwgb2w7ICsrbykge1xuXHRcdFx0XHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbb107XG5cdFx0XHRcdFx0XHRjb25zdCBncm91cFN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XG5cdFx0XHRcdFx0XHRjb25zdCBncm91cENvdW50ID0gZ3JvdXAuY291bnQ7XG5cblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSBncm91cFN0YXJ0LCBsID0gZ3JvdXBTdGFydCArIGdyb3VwQ291bnQ7IGkgPCBsOyBpICs9IDMpIHtcblx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCAzOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBpbmRleDEgPSBpbmRpY2VzLmdldFgoaSArIGopO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGluZGV4MiA9IGluZGljZXMuZ2V0WChpICsgKGogKyAxKSAlIDMpO1xuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb24sIGluZGV4MSk7XG5cdFx0XHRcdFx0XHRcdFx0ZW5kLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb24sIGluZGV4Mik7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoaXNVbmlxdWVFZGdlKHN0YXJ0LCBlbmQsIGVkZ2VzKSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmVydGljZXMucHVzaChzdGFydC54LCBzdGFydC55LCBzdGFydC56KTtcblx0XHRcdFx0XHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goZW5kLngsIGVuZC55LCBlbmQueik7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIG5vbi1pbmRleGVkIEJ1ZmZlckdlb21ldHJ5XG5cdFx0XHRcdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBwb3NpdGlvbi5jb3VudCAvIDM7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgMzsgaisrKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHRocmVlIGVkZ2VzIHBlciB0cmlhbmdsZSwgYW4gZWRnZSBpcyByZXByZXNlbnRlZCBhcyAoaW5kZXgxLCBpbmRleDIpXG5cdFx0XHRcdFx0XHRcdC8vIGUuZy4gdGhlIGZpcnN0IHRyaWFuZ2xlIGhhcyB0aGUgZm9sbG93aW5nIGVkZ2VzOiAoMCwxKSwoMSwyKSwoMiwwKVxuXHRcdFx0XHRcdFx0XHRjb25zdCBpbmRleDEgPSAzICogaSArIGo7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGluZGV4MiA9IDMgKiBpICsgKGogKyAxKSAlIDM7XG5cdFx0XHRcdFx0XHRcdHN0YXJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb24sIGluZGV4MSk7XG5cdFx0XHRcdFx0XHRcdGVuZC5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uLCBpbmRleDIpO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChpc1VuaXF1ZUVkZ2Uoc3RhcnQsIGVuZCwgZWRnZXMpID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmVydGljZXMucHVzaChzdGFydC54LCBzdGFydC55LCBzdGFydC56KTtcblx0XHRcdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKGVuZC54LCBlbmQueSwgZW5kLnopO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IC8vIGJ1aWxkIGdlb21ldHJ5XG5cblxuXHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0aWNlcywgMykpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gaXNVbmlxdWVFZGdlKHN0YXJ0LCBlbmQsIGVkZ2VzKSB7XG5cdFx0Y29uc3QgaGFzaDEgPSBgJHtzdGFydC54fSwke3N0YXJ0Lnl9LCR7c3RhcnQuen0tJHtlbmQueH0sJHtlbmQueX0sJHtlbmQuen1gO1xuXHRcdGNvbnN0IGhhc2gyID0gYCR7ZW5kLnh9LCR7ZW5kLnl9LCR7ZW5kLnp9LSR7c3RhcnQueH0sJHtzdGFydC55fSwke3N0YXJ0Lnp9YDsgLy8gY29pbmNpZGVudCBlZGdlXG5cblx0XHRpZiAoZWRnZXMuaGFzKGhhc2gxKSA9PT0gdHJ1ZSB8fCBlZGdlcy5oYXMoaGFzaDIpID09PSB0cnVlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVkZ2VzLmFkZChoYXNoMSwgaGFzaDIpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG5cblx0dmFyIEdlb21ldHJpZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdFx0X19wcm90b19fOiBudWxsLFxuXHRcdEJveEdlb21ldHJ5OiBCb3hHZW9tZXRyeSxcblx0XHRCb3hCdWZmZXJHZW9tZXRyeTogQm94R2VvbWV0cnksXG5cdFx0Q2lyY2xlR2VvbWV0cnk6IENpcmNsZUdlb21ldHJ5LFxuXHRcdENpcmNsZUJ1ZmZlckdlb21ldHJ5OiBDaXJjbGVHZW9tZXRyeSxcblx0XHRDb25lR2VvbWV0cnk6IENvbmVHZW9tZXRyeSxcblx0XHRDb25lQnVmZmVyR2VvbWV0cnk6IENvbmVHZW9tZXRyeSxcblx0XHRDeWxpbmRlckdlb21ldHJ5OiBDeWxpbmRlckdlb21ldHJ5LFxuXHRcdEN5bGluZGVyQnVmZmVyR2VvbWV0cnk6IEN5bGluZGVyR2VvbWV0cnksXG5cdFx0RG9kZWNhaGVkcm9uR2VvbWV0cnk6IERvZGVjYWhlZHJvbkdlb21ldHJ5LFxuXHRcdERvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5OiBEb2RlY2FoZWRyb25HZW9tZXRyeSxcblx0XHRFZGdlc0dlb21ldHJ5OiBFZGdlc0dlb21ldHJ5LFxuXHRcdEV4dHJ1ZGVHZW9tZXRyeTogRXh0cnVkZUdlb21ldHJ5LFxuXHRcdEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeTogRXh0cnVkZUdlb21ldHJ5LFxuXHRcdEljb3NhaGVkcm9uR2VvbWV0cnk6IEljb3NhaGVkcm9uR2VvbWV0cnksXG5cdFx0SWNvc2FoZWRyb25CdWZmZXJHZW9tZXRyeTogSWNvc2FoZWRyb25HZW9tZXRyeSxcblx0XHRMYXRoZUdlb21ldHJ5OiBMYXRoZUdlb21ldHJ5LFxuXHRcdExhdGhlQnVmZmVyR2VvbWV0cnk6IExhdGhlR2VvbWV0cnksXG5cdFx0T2N0YWhlZHJvbkdlb21ldHJ5OiBPY3RhaGVkcm9uR2VvbWV0cnksXG5cdFx0T2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5OiBPY3RhaGVkcm9uR2VvbWV0cnksXG5cdFx0UGxhbmVHZW9tZXRyeTogUGxhbmVHZW9tZXRyeSxcblx0XHRQbGFuZUJ1ZmZlckdlb21ldHJ5OiBQbGFuZUdlb21ldHJ5LFxuXHRcdFBvbHloZWRyb25HZW9tZXRyeTogUG9seWhlZHJvbkdlb21ldHJ5LFxuXHRcdFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeTogUG9seWhlZHJvbkdlb21ldHJ5LFxuXHRcdFJpbmdHZW9tZXRyeTogUmluZ0dlb21ldHJ5LFxuXHRcdFJpbmdCdWZmZXJHZW9tZXRyeTogUmluZ0dlb21ldHJ5LFxuXHRcdFNoYXBlR2VvbWV0cnk6IFNoYXBlR2VvbWV0cnksXG5cdFx0U2hhcGVCdWZmZXJHZW9tZXRyeTogU2hhcGVHZW9tZXRyeSxcblx0XHRTcGhlcmVHZW9tZXRyeTogU3BoZXJlR2VvbWV0cnksXG5cdFx0U3BoZXJlQnVmZmVyR2VvbWV0cnk6IFNwaGVyZUdlb21ldHJ5LFxuXHRcdFRldHJhaGVkcm9uR2VvbWV0cnk6IFRldHJhaGVkcm9uR2VvbWV0cnksXG5cdFx0VGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeTogVGV0cmFoZWRyb25HZW9tZXRyeSxcblx0XHRUb3J1c0dlb21ldHJ5OiBUb3J1c0dlb21ldHJ5LFxuXHRcdFRvcnVzQnVmZmVyR2VvbWV0cnk6IFRvcnVzR2VvbWV0cnksXG5cdFx0VG9ydXNLbm90R2VvbWV0cnk6IFRvcnVzS25vdEdlb21ldHJ5LFxuXHRcdFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5OiBUb3J1c0tub3RHZW9tZXRyeSxcblx0XHRUdWJlR2VvbWV0cnk6IFR1YmVHZW9tZXRyeSxcblx0XHRUdWJlQnVmZmVyR2VvbWV0cnk6IFR1YmVHZW9tZXRyeSxcblx0XHRXaXJlZnJhbWVHZW9tZXRyeTogV2lyZWZyYW1lR2VvbWV0cnlcblx0fSk7XG5cblx0LyoqXG5cdCAqIHBhcmFtZXRlcnMgPSB7XG5cdCAqXHRjb2xvcjogPFRIUkVFLkNvbG9yPlxuXHQgKiB9XG5cdCAqL1xuXG5cdGNsYXNzIFNoYWRvd01hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXHRcdGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnU2hhZG93TWF0ZXJpYWwnO1xuXHRcdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvcigweDAwMDAwMCk7XG5cdFx0XHR0aGlzLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLmNvbG9yLmNvcHkoc291cmNlLmNvbG9yKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0U2hhZG93TWF0ZXJpYWwucHJvdG90eXBlLmlzU2hhZG93TWF0ZXJpYWwgPSB0cnVlO1xuXG5cdC8qKlxuXHQgKiBwYXJhbWV0ZXJzID0ge1xuXHQgKlx0Y29sb3I6IDxoZXg+LFxuXHQgKlx0cm91Z2huZXNzOiA8ZmxvYXQ+LFxuXHQgKlx0bWV0YWxuZXNzOiA8ZmxvYXQ+LFxuXHQgKlx0b3BhY2l0eTogPGZsb2F0Pixcblx0ICpcblx0ICpcdG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICpcdGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlx0bGlnaHRNYXBJbnRlbnNpdHk6IDxmbG9hdD5cblx0ICpcblx0ICpcdGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlx0YW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cblx0ICpcblx0ICpcdGVtaXNzaXZlOiA8aGV4Pixcblx0ICpcdGVtaXNzaXZlSW50ZW5zaXR5OiA8ZmxvYXQ+XG5cdCAqXHRlbWlzc2l2ZU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICpcdGJ1bXBNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRidW1wU2NhbGU6IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHRub3JtYWxNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRub3JtYWxNYXBUeXBlOiBUSFJFRS5UYW5nZW50U3BhY2VOb3JtYWxNYXAsXG5cdCAqXHRub3JtYWxTY2FsZTogPFZlY3RvcjI+LFxuXHQgKlxuXHQgKlx0ZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlx0ZGlzcGxhY2VtZW50U2NhbGU6IDxmbG9hdD4sXG5cdCAqXHRkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKlx0cm91Z2huZXNzTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKlx0bWV0YWxuZXNzTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKlx0YWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqXHRlbnZNYXA6IG5ldyBUSFJFRS5DdWJlVGV4dHVyZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXG5cdCAqXHRlbnZNYXBJbnRlbnNpdHk6IDxmbG9hdD5cblx0ICpcblx0ICpcdHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0Pixcblx0ICpcblx0ICpcdHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuXHQgKlx0d2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKlx0ZmxhdFNoYWRpbmc6IDxib29sPlxuXHQgKiB9XG5cdCAqL1xuXG5cdGNsYXNzIE1lc2hTdGFuZGFyZE1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuXHRcdGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLmRlZmluZXMgPSB7XG5cdFx0XHRcdCdTVEFOREFSRCc6ICcnXG5cdFx0XHR9O1xuXHRcdFx0dGhpcy50eXBlID0gJ01lc2hTdGFuZGFyZE1hdGVyaWFsJztcblx0XHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoMHhmZmZmZmYpOyAvLyBkaWZmdXNlXG5cblx0XHRcdHRoaXMucm91Z2huZXNzID0gMS4wO1xuXHRcdFx0dGhpcy5tZXRhbG5lc3MgPSAwLjA7XG5cdFx0XHR0aGlzLm1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcblx0XHRcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XG5cdFx0XHR0aGlzLmFvTWFwID0gbnVsbDtcblx0XHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG5cdFx0XHR0aGlzLmVtaXNzaXZlID0gbmV3IENvbG9yKDB4MDAwMDAwKTtcblx0XHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSAxLjA7XG5cdFx0XHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcblx0XHRcdHRoaXMuYnVtcE1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmJ1bXBTY2FsZSA9IDE7XG5cdFx0XHR0aGlzLm5vcm1hbE1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBUYW5nZW50U3BhY2VOb3JtYWxNYXA7XG5cdFx0XHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoMSwgMSk7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG5cdFx0XHR0aGlzLnJvdWdobmVzc01hcCA9IG51bGw7XG5cdFx0XHR0aGlzLm1ldGFsbmVzc01hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblx0XHRcdHRoaXMuZW52TWFwID0gbnVsbDtcblx0XHRcdHRoaXMuZW52TWFwSW50ZW5zaXR5ID0gMS4wO1xuXHRcdFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xuXHRcdFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG5cdFx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblx0XHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBmYWxzZTtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLmRlZmluZXMgPSB7XG5cdFx0XHRcdCdTVEFOREFSRCc6ICcnXG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5jb2xvci5jb3B5KHNvdXJjZS5jb2xvcik7XG5cdFx0XHR0aGlzLnJvdWdobmVzcyA9IHNvdXJjZS5yb3VnaG5lc3M7XG5cdFx0XHR0aGlzLm1ldGFsbmVzcyA9IHNvdXJjZS5tZXRhbG5lc3M7XG5cdFx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cdFx0XHR0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xuXHRcdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcblx0XHRcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XG5cdFx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xuXHRcdFx0dGhpcy5lbWlzc2l2ZS5jb3B5KHNvdXJjZS5lbWlzc2l2ZSk7XG5cdFx0XHR0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xuXHRcdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IHNvdXJjZS5lbWlzc2l2ZUludGVuc2l0eTtcblx0XHRcdHRoaXMuYnVtcE1hcCA9IHNvdXJjZS5idW1wTWFwO1xuXHRcdFx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xuXHRcdFx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xuXHRcdFx0dGhpcy5ub3JtYWxNYXBUeXBlID0gc291cmNlLm5vcm1hbE1hcFR5cGU7XG5cdFx0XHR0aGlzLm5vcm1hbFNjYWxlLmNvcHkoc291cmNlLm5vcm1hbFNjYWxlKTtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50Qmlhcztcblx0XHRcdHRoaXMucm91Z2huZXNzTWFwID0gc291cmNlLnJvdWdobmVzc01hcDtcblx0XHRcdHRoaXMubWV0YWxuZXNzTWFwID0gc291cmNlLm1ldGFsbmVzc01hcDtcblx0XHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cdFx0XHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XG5cdFx0XHR0aGlzLmVudk1hcEludGVuc2l0eSA9IHNvdXJjZS5lbnZNYXBJbnRlbnNpdHk7XG5cdFx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XG5cdFx0XHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdFx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdFx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cdFx0XHR0aGlzLmZsYXRTaGFkaW5nID0gc291cmNlLmZsYXRTaGFkaW5nO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRNZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCA9IHRydWU7XG5cblx0LyoqXG5cdCAqIHBhcmFtZXRlcnMgPSB7XG5cdCAqXHRjbGVhcmNvYXQ6IDxmbG9hdD4sXG5cdCAqXHRjbGVhcmNvYXRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRjbGVhcmNvYXRSb3VnaG5lc3M6IDxmbG9hdD4sXG5cdCAqXHRjbGVhcmNvYXRSb3VnaG5lc3NNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRjbGVhcmNvYXROb3JtYWxTY2FsZTogPFZlY3RvcjI+LFxuXHQgKlx0Y2xlYXJjb2F0Tm9ybWFsTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKlx0aW9yOiA8ZmxvYXQ+LFxuXHQgKlx0cmVmbGVjdGl2aXR5OiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKlx0c2hlZW46IDxmbG9hdD4sXG5cdCAqXHRzaGVlbkNvbG9yOiA8Q29sb3I+LFxuXHQgKlx0c2hlZW5Db2xvck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcdHNoZWVuUm91Z2huZXNzOiA8ZmxvYXQ+LFxuXHQgKlx0c2hlZW5Sb3VnaG5lc3NNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqXHR0cmFuc21pc3Npb246IDxmbG9hdD4sXG5cdCAqXHR0cmFuc21pc3Npb25NYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqXHR0aGlja25lc3M6IDxmbG9hdD4sXG5cdCAqXHR0aGlja25lc3NNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRhdHRlbnVhdGlvbkRpc3RhbmNlOiA8ZmxvYXQ+LFxuXHQgKlx0YXR0ZW51YXRpb25Db2xvcjogPENvbG9yPixcblx0ICpcblx0ICpcdHNwZWN1bGFySW50ZW5zaXR5OiA8ZmxvYXQ+LFxuXHQgKlx0c3BlY3VsYXJJbnRlbnNpdHlNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRzcGVjdWxhckNvbG9yOiA8Q29sb3I+LFxuXHQgKlx0c3BlY3VsYXJDb2xvck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKVxuXHQgKiB9XG5cdCAqL1xuXG5cdGNsYXNzIE1lc2hQaHlzaWNhbE1hdGVyaWFsIGV4dGVuZHMgTWVzaFN0YW5kYXJkTWF0ZXJpYWwge1xuXHRcdGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLmRlZmluZXMgPSB7XG5cdFx0XHRcdCdTVEFOREFSRCc6ICcnLFxuXHRcdFx0XHQnUEhZU0lDQUwnOiAnJ1xuXHRcdFx0fTtcblx0XHRcdHRoaXMudHlwZSA9ICdNZXNoUGh5c2ljYWxNYXRlcmlhbCc7XG5cdFx0XHR0aGlzLmNsZWFyY29hdE1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmNsZWFyY29hdFJvdWdobmVzcyA9IDAuMDtcblx0XHRcdHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwID0gbnVsbDtcblx0XHRcdHRoaXMuY2xlYXJjb2F0Tm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMigxLCAxKTtcblx0XHRcdHRoaXMuY2xlYXJjb2F0Tm9ybWFsTWFwID0gbnVsbDtcblx0XHRcdHRoaXMuaW9yID0gMS41O1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZWZsZWN0aXZpdHknLCB7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiBjbGFtcCgyLjUgKiAodGhpcy5pb3IgLSAxKSAvICh0aGlzLmlvciArIDEpLCAwLCAxKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0OiBmdW5jdGlvbiAocmVmbGVjdGl2aXR5KSB7XG5cdFx0XHRcdFx0dGhpcy5pb3IgPSAoMSArIDAuNCAqIHJlZmxlY3Rpdml0eSkgLyAoMSAtIDAuNCAqIHJlZmxlY3Rpdml0eSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5zaGVlbkNvbG9yID0gbmV3IENvbG9yKDB4MDAwMDAwKTtcblx0XHRcdHRoaXMuc2hlZW5Db2xvck1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLnNoZWVuUm91Z2huZXNzID0gMS4wO1xuXHRcdFx0dGhpcy5zaGVlblJvdWdobmVzc01hcCA9IG51bGw7XG5cdFx0XHR0aGlzLnRyYW5zbWlzc2lvbk1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLnRoaWNrbmVzcyA9IDA7XG5cdFx0XHR0aGlzLnRoaWNrbmVzc01hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmF0dGVudWF0aW9uRGlzdGFuY2UgPSAwLjA7XG5cdFx0XHR0aGlzLmF0dGVudWF0aW9uQ29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSk7XG5cdFx0XHR0aGlzLnNwZWN1bGFySW50ZW5zaXR5ID0gMS4wO1xuXHRcdFx0dGhpcy5zcGVjdWxhckludGVuc2l0eU1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLnNwZWN1bGFyQ29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSk7XG5cdFx0XHR0aGlzLnNwZWN1bGFyQ29sb3JNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5fc2hlZW4gPSAwLjA7XG5cdFx0XHR0aGlzLl9jbGVhcmNvYXQgPSAwO1xuXHRcdFx0dGhpcy5fdHJhbnNtaXNzaW9uID0gMDtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuXHRcdH1cblxuXHRcdGdldCBzaGVlbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9zaGVlbjtcblx0XHR9XG5cblx0XHRzZXQgc2hlZW4odmFsdWUpIHtcblx0XHRcdGlmICh0aGlzLl9zaGVlbiA+IDAgIT09IHZhbHVlID4gMCkge1xuXHRcdFx0XHR0aGlzLnZlcnNpb24rKztcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc2hlZW4gPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRnZXQgY2xlYXJjb2F0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2NsZWFyY29hdDtcblx0XHR9XG5cblx0XHRzZXQgY2xlYXJjb2F0KHZhbHVlKSB7XG5cdFx0XHRpZiAodGhpcy5fY2xlYXJjb2F0ID4gMCAhPT0gdmFsdWUgPiAwKSB7XG5cdFx0XHRcdHRoaXMudmVyc2lvbisrO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9jbGVhcmNvYXQgPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRnZXQgdHJhbnNtaXNzaW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3RyYW5zbWlzc2lvbjtcblx0XHR9XG5cblx0XHRzZXQgdHJhbnNtaXNzaW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAodGhpcy5fdHJhbnNtaXNzaW9uID4gMCAhPT0gdmFsdWUgPiAwKSB7XG5cdFx0XHRcdHRoaXMudmVyc2lvbisrO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl90cmFuc21pc3Npb24gPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0dGhpcy5kZWZpbmVzID0ge1xuXHRcdFx0XHQnU1RBTkRBUkQnOiAnJyxcblx0XHRcdFx0J1BIWVNJQ0FMJzogJydcblx0XHRcdH07XG5cdFx0XHR0aGlzLmNsZWFyY29hdCA9IHNvdXJjZS5jbGVhcmNvYXQ7XG5cdFx0XHR0aGlzLmNsZWFyY29hdE1hcCA9IHNvdXJjZS5jbGVhcmNvYXRNYXA7XG5cdFx0XHR0aGlzLmNsZWFyY29hdFJvdWdobmVzcyA9IHNvdXJjZS5jbGVhcmNvYXRSb3VnaG5lc3M7XG5cdFx0XHR0aGlzLmNsZWFyY29hdFJvdWdobmVzc01hcCA9IHNvdXJjZS5jbGVhcmNvYXRSb3VnaG5lc3NNYXA7XG5cdFx0XHR0aGlzLmNsZWFyY29hdE5vcm1hbE1hcCA9IHNvdXJjZS5jbGVhcmNvYXROb3JtYWxNYXA7XG5cdFx0XHR0aGlzLmNsZWFyY29hdE5vcm1hbFNjYWxlLmNvcHkoc291cmNlLmNsZWFyY29hdE5vcm1hbFNjYWxlKTtcblx0XHRcdHRoaXMuaW9yID0gc291cmNlLmlvcjtcblx0XHRcdHRoaXMuc2hlZW4gPSBzb3VyY2Uuc2hlZW47XG5cdFx0XHR0aGlzLnNoZWVuQ29sb3IuY29weShzb3VyY2Uuc2hlZW5Db2xvcik7XG5cdFx0XHR0aGlzLnNoZWVuQ29sb3JNYXAgPSBzb3VyY2Uuc2hlZW5Db2xvck1hcDtcblx0XHRcdHRoaXMuc2hlZW5Sb3VnaG5lc3MgPSBzb3VyY2Uuc2hlZW5Sb3VnaG5lc3M7XG5cdFx0XHR0aGlzLnNoZWVuUm91Z2huZXNzTWFwID0gc291cmNlLnNoZWVuUm91Z2huZXNzTWFwO1xuXHRcdFx0dGhpcy50cmFuc21pc3Npb24gPSBzb3VyY2UudHJhbnNtaXNzaW9uO1xuXHRcdFx0dGhpcy50cmFuc21pc3Npb25NYXAgPSBzb3VyY2UudHJhbnNtaXNzaW9uTWFwO1xuXHRcdFx0dGhpcy50aGlja25lc3MgPSBzb3VyY2UudGhpY2tuZXNzO1xuXHRcdFx0dGhpcy50aGlja25lc3NNYXAgPSBzb3VyY2UudGhpY2tuZXNzTWFwO1xuXHRcdFx0dGhpcy5hdHRlbnVhdGlvbkRpc3RhbmNlID0gc291cmNlLmF0dGVudWF0aW9uRGlzdGFuY2U7XG5cdFx0XHR0aGlzLmF0dGVudWF0aW9uQ29sb3IuY29weShzb3VyY2UuYXR0ZW51YXRpb25Db2xvcik7XG5cdFx0XHR0aGlzLnNwZWN1bGFySW50ZW5zaXR5ID0gc291cmNlLnNwZWN1bGFySW50ZW5zaXR5O1xuXHRcdFx0dGhpcy5zcGVjdWxhckludGVuc2l0eU1hcCA9IHNvdXJjZS5zcGVjdWxhckludGVuc2l0eU1hcDtcblx0XHRcdHRoaXMuc3BlY3VsYXJDb2xvci5jb3B5KHNvdXJjZS5zcGVjdWxhckNvbG9yKTtcblx0XHRcdHRoaXMuc3BlY3VsYXJDb2xvck1hcCA9IHNvdXJjZS5zcGVjdWxhckNvbG9yTWFwO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRNZXNoUGh5c2ljYWxNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoUGh5c2ljYWxNYXRlcmlhbCA9IHRydWU7XG5cblx0LyoqXG5cdCAqIHBhcmFtZXRlcnMgPSB7XG5cdCAqXHRjb2xvcjogPGhleD4sXG5cdCAqXHRzcGVjdWxhcjogPGhleD4sXG5cdCAqXHRzaGluaW5lc3M6IDxmbG9hdD4sXG5cdCAqXHRvcGFjaXR5OiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKlx0bWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKlx0bGlnaHRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRsaWdodE1hcEludGVuc2l0eTogPGZsb2F0PlxuXHQgKlxuXHQgKlx0YW9NYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRhb01hcEludGVuc2l0eTogPGZsb2F0PlxuXHQgKlxuXHQgKlx0ZW1pc3NpdmU6IDxoZXg+LFxuXHQgKlx0ZW1pc3NpdmVJbnRlbnNpdHk6IDxmbG9hdD5cblx0ICpcdGVtaXNzaXZlTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKlx0YnVtcE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcdGJ1bXBTY2FsZTogPGZsb2F0Pixcblx0ICpcblx0ICpcdG5vcm1hbE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcdG5vcm1hbE1hcFR5cGU6IFRIUkVFLlRhbmdlbnRTcGFjZU5vcm1hbE1hcCxcblx0ICpcdG5vcm1hbFNjYWxlOiA8VmVjdG9yMj4sXG5cdCAqXG5cdCAqXHRkaXNwbGFjZW1lbnRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRkaXNwbGFjZW1lbnRTY2FsZTogPGZsb2F0Pixcblx0ICpcdGRpc3BsYWNlbWVudEJpYXM6IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHRzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICpcdGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKlx0ZW52TWFwOiBuZXcgVEhSRUUuQ3ViZVRleHR1cmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxuXHQgKlx0Y29tYmluZTogVEhSRUUuTXVsdGlwbHlPcGVyYXRpb24sXG5cdCAqXHRyZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG5cdCAqXHRyZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHR3aXJlZnJhbWU6IDxib29sZWFuPixcblx0ICpcdHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0Pixcblx0ICpcblx0ICpcdGZsYXRTaGFkaW5nOiA8Ym9vbD5cblx0ICogfVxuXHQgKi9cblxuXHRjbGFzcyBNZXNoUGhvbmdNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblx0XHRjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ01lc2hQaG9uZ01hdGVyaWFsJztcblx0XHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoMHhmZmZmZmYpOyAvLyBkaWZmdXNlXG5cblx0XHRcdHRoaXMuc3BlY3VsYXIgPSBuZXcgQ29sb3IoMHgxMTExMTEpO1xuXHRcdFx0dGhpcy5zaGluaW5lc3MgPSAzMDtcblx0XHRcdHRoaXMubWFwID0gbnVsbDtcblx0XHRcdHRoaXMubGlnaHRNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcblx0XHRcdHRoaXMuYW9NYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblx0XHRcdHRoaXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoMHgwMDAwMDApO1xuXHRcdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcblx0XHRcdHRoaXMuZW1pc3NpdmVNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5idW1wTWFwID0gbnVsbDtcblx0XHRcdHRoaXMuYnVtcFNjYWxlID0gMTtcblx0XHRcdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcblx0XHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IFRhbmdlbnRTcGFjZU5vcm1hbE1hcDtcblx0XHRcdHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMigxLCAxKTtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcblx0XHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmVudk1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmNvbWJpbmUgPSBNdWx0aXBseU9wZXJhdGlvbjtcblx0XHRcdHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcblx0XHRcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblx0XHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cdFx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cdFx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuXHRcdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG5cdFx0XHR0aGlzLmZsYXRTaGFkaW5nID0gZmFsc2U7XG5cdFx0XHR0aGlzLnNldFZhbHVlcyhwYXJhbWV0ZXJzKTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0dGhpcy5jb2xvci5jb3B5KHNvdXJjZS5jb2xvcik7XG5cdFx0XHR0aGlzLnNwZWN1bGFyLmNvcHkoc291cmNlLnNwZWN1bGFyKTtcblx0XHRcdHRoaXMuc2hpbmluZXNzID0gc291cmNlLnNoaW5pbmVzcztcblx0XHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblx0XHRcdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XG5cdFx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXHRcdFx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcblx0XHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XG5cdFx0XHR0aGlzLmVtaXNzaXZlLmNvcHkoc291cmNlLmVtaXNzaXZlKTtcblx0XHRcdHRoaXMuZW1pc3NpdmVNYXAgPSBzb3VyY2UuZW1pc3NpdmVNYXA7XG5cdFx0XHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gc291cmNlLmVtaXNzaXZlSW50ZW5zaXR5O1xuXHRcdFx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XG5cdFx0XHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XG5cdFx0XHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XG5cdFx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBzb3VyY2Uubm9ybWFsTWFwVHlwZTtcblx0XHRcdHRoaXMubm9ybWFsU2NhbGUuY29weShzb3VyY2Uubm9ybWFsU2NhbGUpO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xuXHRcdFx0dGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcblx0XHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cdFx0XHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XG5cdFx0XHR0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcblx0XHRcdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcblx0XHRcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcblx0XHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuXHRcdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcblx0XHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBzb3VyY2UuZmxhdFNoYWRpbmc7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdE1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hQaG9uZ01hdGVyaWFsID0gdHJ1ZTtcblxuXHQvKipcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICpcdGNvbG9yOiA8aGV4Pixcblx0ICpcblx0ICpcdG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcdGdyYWRpZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKlx0bGlnaHRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRsaWdodE1hcEludGVuc2l0eTogPGZsb2F0PlxuXHQgKlxuXHQgKlx0YW9NYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRhb01hcEludGVuc2l0eTogPGZsb2F0PlxuXHQgKlxuXHQgKlx0ZW1pc3NpdmU6IDxoZXg+LFxuXHQgKlx0ZW1pc3NpdmVJbnRlbnNpdHk6IDxmbG9hdD5cblx0ICpcdGVtaXNzaXZlTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKlx0YnVtcE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcdGJ1bXBTY2FsZTogPGZsb2F0Pixcblx0ICpcblx0ICpcdG5vcm1hbE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcdG5vcm1hbE1hcFR5cGU6IFRIUkVFLlRhbmdlbnRTcGFjZU5vcm1hbE1hcCxcblx0ICpcdG5vcm1hbFNjYWxlOiA8VmVjdG9yMj4sXG5cdCAqXG5cdCAqXHRkaXNwbGFjZW1lbnRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRkaXNwbGFjZW1lbnRTY2FsZTogPGZsb2F0Pixcblx0ICpcdGRpc3BsYWNlbWVudEJpYXM6IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHRhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICpcdHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuXHQgKlx0d2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKiB9XG5cdCAqL1xuXG5cdGNsYXNzIE1lc2hUb29uTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cdFx0Y29uc3RydWN0b3IocGFyYW1ldGVycykge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMuZGVmaW5lcyA9IHtcblx0XHRcdFx0J1RPT04nOiAnJ1xuXHRcdFx0fTtcblx0XHRcdHRoaXMudHlwZSA9ICdNZXNoVG9vbk1hdGVyaWFsJztcblx0XHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoMHhmZmZmZmYpO1xuXHRcdFx0dGhpcy5tYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5ncmFkaWVudE1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcblx0XHRcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XG5cdFx0XHR0aGlzLmFvTWFwID0gbnVsbDtcblx0XHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG5cdFx0XHR0aGlzLmVtaXNzaXZlID0gbmV3IENvbG9yKDB4MDAwMDAwKTtcblx0XHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSAxLjA7XG5cdFx0XHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcblx0XHRcdHRoaXMuYnVtcE1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmJ1bXBTY2FsZSA9IDE7XG5cdFx0XHR0aGlzLm5vcm1hbE1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBUYW5nZW50U3BhY2VOb3JtYWxNYXA7XG5cdFx0XHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoMSwgMSk7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG5cdFx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblx0XHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cdFx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cdFx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuXHRcdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG5cdFx0XHR0aGlzLnNldFZhbHVlcyhwYXJhbWV0ZXJzKTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UpO1xuXHRcdFx0dGhpcy5jb2xvci5jb3B5KHNvdXJjZS5jb2xvcik7XG5cdFx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cdFx0XHR0aGlzLmdyYWRpZW50TWFwID0gc291cmNlLmdyYWRpZW50TWFwO1xuXHRcdFx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcblx0XHRcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBzb3VyY2UubGlnaHRNYXBJbnRlbnNpdHk7XG5cdFx0XHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xuXHRcdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcblx0XHRcdHRoaXMuZW1pc3NpdmUuY29weShzb3VyY2UuZW1pc3NpdmUpO1xuXHRcdFx0dGhpcy5lbWlzc2l2ZU1hcCA9IHNvdXJjZS5lbWlzc2l2ZU1hcDtcblx0XHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBzb3VyY2UuZW1pc3NpdmVJbnRlbnNpdHk7XG5cdFx0XHR0aGlzLmJ1bXBNYXAgPSBzb3VyY2UuYnVtcE1hcDtcblx0XHRcdHRoaXMuYnVtcFNjYWxlID0gc291cmNlLmJ1bXBTY2FsZTtcblx0XHRcdHRoaXMubm9ybWFsTWFwID0gc291cmNlLm5vcm1hbE1hcDtcblx0XHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IHNvdXJjZS5ub3JtYWxNYXBUeXBlO1xuXHRcdFx0dGhpcy5ub3JtYWxTY2FsZS5jb3B5KHNvdXJjZS5ub3JtYWxTY2FsZSk7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XG5cdFx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXHRcdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuXHRcdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuXHRcdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XG5cdFx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRNZXNoVG9vbk1hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hUb29uTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdC8qKlxuXHQgKiBwYXJhbWV0ZXJzID0ge1xuXHQgKlx0b3BhY2l0eTogPGZsb2F0Pixcblx0ICpcblx0ICpcdGJ1bXBNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRidW1wU2NhbGU6IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHRub3JtYWxNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXHRub3JtYWxNYXBUeXBlOiBUSFJFRS5UYW5nZW50U3BhY2VOb3JtYWxNYXAsXG5cdCAqXHRub3JtYWxTY2FsZTogPFZlY3RvcjI+LFxuXHQgKlxuXHQgKlx0ZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlx0ZGlzcGxhY2VtZW50U2NhbGU6IDxmbG9hdD4sXG5cdCAqXHRkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKlx0d2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG5cdCAqXHR3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD5cblx0ICpcblx0ICpcdGZsYXRTaGFkaW5nOiA8Ym9vbD5cblx0ICogfVxuXHQgKi9cblxuXHRjbGFzcyBNZXNoTm9ybWFsTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cdFx0Y29uc3RydWN0b3IocGFyYW1ldGVycykge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdNZXNoTm9ybWFsTWF0ZXJpYWwnO1xuXHRcdFx0dGhpcy5idW1wTWFwID0gbnVsbDtcblx0XHRcdHRoaXMuYnVtcFNjYWxlID0gMTtcblx0XHRcdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcblx0XHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IFRhbmdlbnRTcGFjZU5vcm1hbE1hcDtcblx0XHRcdHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMigxLCAxKTtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcblx0XHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cdFx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cdFx0XHR0aGlzLmZvZyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5mbGF0U2hhZGluZyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMocGFyYW1ldGVycyk7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdHRoaXMuYnVtcE1hcCA9IHNvdXJjZS5idW1wTWFwO1xuXHRcdFx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xuXHRcdFx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xuXHRcdFx0dGhpcy5ub3JtYWxNYXBUeXBlID0gc291cmNlLm5vcm1hbE1hcFR5cGU7XG5cdFx0XHR0aGlzLm5vcm1hbFNjYWxlLmNvcHkoc291cmNlLm5vcm1hbFNjYWxlKTtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50Qmlhcztcblx0XHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBzb3VyY2UuZmxhdFNoYWRpbmc7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdE1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoTm9ybWFsTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdC8qKlxuXHQgKiBwYXJhbWV0ZXJzID0ge1xuXHQgKlx0Y29sb3I6IDxoZXg+LFxuXHQgKlx0b3BhY2l0eTogPGZsb2F0Pixcblx0ICpcblx0ICpcdG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICpcdGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlx0bGlnaHRNYXBJbnRlbnNpdHk6IDxmbG9hdD5cblx0ICpcblx0ICpcdGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlx0YW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cblx0ICpcblx0ICpcdGVtaXNzaXZlOiA8aGV4Pixcblx0ICpcdGVtaXNzaXZlSW50ZW5zaXR5OiA8ZmxvYXQ+XG5cdCAqXHRlbWlzc2l2ZU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICpcdHNwZWN1bGFyTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKlx0YWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqXHRlbnZNYXA6IG5ldyBUSFJFRS5DdWJlVGV4dHVyZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXG5cdCAqXHRjb21iaW5lOiBUSFJFRS5NdWx0aXBseSxcblx0ICpcdHJlZmxlY3Rpdml0eTogPGZsb2F0Pixcblx0ICpcdHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0Pixcblx0ICpcblx0ICpcdHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuXHQgKlx0d2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKiB9XG5cdCAqL1xuXG5cdGNsYXNzIE1lc2hMYW1iZXJ0TWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XG5cdFx0Y29uc3RydWN0b3IocGFyYW1ldGVycykge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdNZXNoTGFtYmVydE1hdGVyaWFsJztcblx0XHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoMHhmZmZmZmYpOyAvLyBkaWZmdXNlXG5cblx0XHRcdHRoaXMubWFwID0gbnVsbDtcblx0XHRcdHRoaXMubGlnaHRNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcblx0XHRcdHRoaXMuYW9NYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblx0XHRcdHRoaXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoMHgwMDAwMDApO1xuXHRcdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcblx0XHRcdHRoaXMuZW1pc3NpdmVNYXAgPSBudWxsO1xuXHRcdFx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblx0XHRcdHRoaXMuZW52TWFwID0gbnVsbDtcblx0XHRcdHRoaXMuY29tYmluZSA9IE11bHRpcGx5T3BlcmF0aW9uO1xuXHRcdFx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xuXHRcdFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xuXHRcdFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG5cdFx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblx0XHRcdHRoaXMuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLmNvbG9yLmNvcHkoc291cmNlLmNvbG9yKTtcblx0XHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblx0XHRcdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XG5cdFx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXHRcdFx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcblx0XHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XG5cdFx0XHR0aGlzLmVtaXNzaXZlLmNvcHkoc291cmNlLmVtaXNzaXZlKTtcblx0XHRcdHRoaXMuZW1pc3NpdmVNYXAgPSBzb3VyY2UuZW1pc3NpdmVNYXA7XG5cdFx0XHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gc291cmNlLmVtaXNzaXZlSW50ZW5zaXR5O1xuXHRcdFx0dGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcblx0XHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cdFx0XHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XG5cdFx0XHR0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcblx0XHRcdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcblx0XHRcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcblx0XHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuXHRcdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0TWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoTGFtYmVydE1hdGVyaWFsID0gdHJ1ZTtcblxuXHQvKipcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICpcdGNvbG9yOiA8aGV4Pixcblx0ICpcdG9wYWNpdHk6IDxmbG9hdD4sXG5cdCAqXG5cdCAqXHRtYXRjYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqXHRtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqXHRidW1wTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlx0YnVtcFNjYWxlOiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKlx0bm9ybWFsTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlx0bm9ybWFsTWFwVHlwZTogVEhSRUUuVGFuZ2VudFNwYWNlTm9ybWFsTWFwLFxuXHQgKlx0bm9ybWFsU2NhbGU6IDxWZWN0b3IyPixcblx0ICpcblx0ICpcdGRpc3BsYWNlbWVudE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcdGRpc3BsYWNlbWVudFNjYWxlOiA8ZmxvYXQ+LFxuXHQgKlx0ZGlzcGxhY2VtZW50QmlhczogPGZsb2F0Pixcblx0ICpcblx0ICpcdGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKlx0ZmxhdFNoYWRpbmc6IDxib29sPlxuXHQgKiB9XG5cdCAqL1xuXG5cdGNsYXNzIE1lc2hNYXRjYXBNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcblx0XHRjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy5kZWZpbmVzID0ge1xuXHRcdFx0XHQnTUFUQ0FQJzogJydcblx0XHRcdH07XG5cdFx0XHR0aGlzLnR5cGUgPSAnTWVzaE1hdGNhcE1hdGVyaWFsJztcblx0XHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoMHhmZmZmZmYpOyAvLyBkaWZmdXNlXG5cblx0XHRcdHRoaXMubWF0Y2FwID0gbnVsbDtcblx0XHRcdHRoaXMubWFwID0gbnVsbDtcblx0XHRcdHRoaXMuYnVtcE1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmJ1bXBTY2FsZSA9IDE7XG5cdFx0XHR0aGlzLm5vcm1hbE1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBUYW5nZW50U3BhY2VOb3JtYWxNYXA7XG5cdFx0XHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoMSwgMSk7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG5cdFx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblx0XHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBmYWxzZTtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLmRlZmluZXMgPSB7XG5cdFx0XHRcdCdNQVRDQVAnOiAnJ1xuXHRcdFx0fTtcblx0XHRcdHRoaXMuY29sb3IuY29weShzb3VyY2UuY29sb3IpO1xuXHRcdFx0dGhpcy5tYXRjYXAgPSBzb3VyY2UubWF0Y2FwO1xuXHRcdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXHRcdFx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XG5cdFx0XHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XG5cdFx0XHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XG5cdFx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBzb3VyY2Uubm9ybWFsTWFwVHlwZTtcblx0XHRcdHRoaXMubm9ybWFsU2NhbGUuY29weShzb3VyY2Uubm9ybWFsU2NhbGUpO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuXHRcdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xuXHRcdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblx0XHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBzb3VyY2UuZmxhdFNoYWRpbmc7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdE1lc2hNYXRjYXBNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoTWF0Y2FwTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdC8qKlxuXHQgKiBwYXJhbWV0ZXJzID0ge1xuXHQgKlx0Y29sb3I6IDxoZXg+LFxuXHQgKlx0b3BhY2l0eTogPGZsb2F0Pixcblx0ICpcblx0ICpcdGxpbmV3aWR0aDogPGZsb2F0Pixcblx0ICpcblx0ICpcdHNjYWxlOiA8ZmxvYXQ+LFxuXHQgKlx0ZGFzaFNpemU6IDxmbG9hdD4sXG5cdCAqXHRnYXBTaXplOiA8ZmxvYXQ+XG5cdCAqIH1cblx0ICovXG5cblx0Y2xhc3MgTGluZURhc2hlZE1hdGVyaWFsIGV4dGVuZHMgTGluZUJhc2ljTWF0ZXJpYWwge1xuXHRcdGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnTGluZURhc2hlZE1hdGVyaWFsJztcblx0XHRcdHRoaXMuc2NhbGUgPSAxO1xuXHRcdFx0dGhpcy5kYXNoU2l6ZSA9IDM7XG5cdFx0XHR0aGlzLmdhcFNpemUgPSAxO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMocGFyYW1ldGVycyk7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdHRoaXMuc2NhbGUgPSBzb3VyY2Uuc2NhbGU7XG5cdFx0XHR0aGlzLmRhc2hTaXplID0gc291cmNlLmRhc2hTaXplO1xuXHRcdFx0dGhpcy5nYXBTaXplID0gc291cmNlLmdhcFNpemU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdExpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUuaXNMaW5lRGFzaGVkTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdHZhciBNYXRlcmlhbHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdFx0X19wcm90b19fOiBudWxsLFxuXHRcdFNoYWRvd01hdGVyaWFsOiBTaGFkb3dNYXRlcmlhbCxcblx0XHRTcHJpdGVNYXRlcmlhbDogU3ByaXRlTWF0ZXJpYWwsXG5cdFx0UmF3U2hhZGVyTWF0ZXJpYWw6IFJhd1NoYWRlck1hdGVyaWFsLFxuXHRcdFNoYWRlck1hdGVyaWFsOiBTaGFkZXJNYXRlcmlhbCxcblx0XHRQb2ludHNNYXRlcmlhbDogUG9pbnRzTWF0ZXJpYWwsXG5cdFx0TWVzaFBoeXNpY2FsTWF0ZXJpYWw6IE1lc2hQaHlzaWNhbE1hdGVyaWFsLFxuXHRcdE1lc2hTdGFuZGFyZE1hdGVyaWFsOiBNZXNoU3RhbmRhcmRNYXRlcmlhbCxcblx0XHRNZXNoUGhvbmdNYXRlcmlhbDogTWVzaFBob25nTWF0ZXJpYWwsXG5cdFx0TWVzaFRvb25NYXRlcmlhbDogTWVzaFRvb25NYXRlcmlhbCxcblx0XHRNZXNoTm9ybWFsTWF0ZXJpYWw6IE1lc2hOb3JtYWxNYXRlcmlhbCxcblx0XHRNZXNoTGFtYmVydE1hdGVyaWFsOiBNZXNoTGFtYmVydE1hdGVyaWFsLFxuXHRcdE1lc2hEZXB0aE1hdGVyaWFsOiBNZXNoRGVwdGhNYXRlcmlhbCxcblx0XHRNZXNoRGlzdGFuY2VNYXRlcmlhbDogTWVzaERpc3RhbmNlTWF0ZXJpYWwsXG5cdFx0TWVzaEJhc2ljTWF0ZXJpYWw6IE1lc2hCYXNpY01hdGVyaWFsLFxuXHRcdE1lc2hNYXRjYXBNYXRlcmlhbDogTWVzaE1hdGNhcE1hdGVyaWFsLFxuXHRcdExpbmVEYXNoZWRNYXRlcmlhbDogTGluZURhc2hlZE1hdGVyaWFsLFxuXHRcdExpbmVCYXNpY01hdGVyaWFsOiBMaW5lQmFzaWNNYXRlcmlhbCxcblx0XHRNYXRlcmlhbDogTWF0ZXJpYWxcblx0fSk7XG5cblx0Y29uc3QgQW5pbWF0aW9uVXRpbHMgPSB7XG5cdFx0Ly8gc2FtZSBhcyBBcnJheS5wcm90b3R5cGUuc2xpY2UsIGJ1dCBhbHNvIHdvcmtzIG9uIHR5cGVkIGFycmF5c1xuXHRcdGFycmF5U2xpY2U6IGZ1bmN0aW9uIChhcnJheSwgZnJvbSwgdG8pIHtcblx0XHRcdGlmIChBbmltYXRpb25VdGlscy5pc1R5cGVkQXJyYXkoYXJyYXkpKSB7XG5cdFx0XHRcdC8vIGluIGlvczkgYXJyYXkuc3ViYXJyYXkoZnJvbSwgdW5kZWZpbmVkKSB3aWxsIHJldHVybiBlbXB0eSBhcnJheVxuXHRcdFx0XHQvLyBidXQgYXJyYXkuc3ViYXJyYXkoZnJvbSkgb3IgYXJyYXkuc3ViYXJyYXkoZnJvbSwgbGVuKSBpcyBjb3JyZWN0XG5cdFx0XHRcdHJldHVybiBuZXcgYXJyYXkuY29uc3RydWN0b3IoYXJyYXkuc3ViYXJyYXkoZnJvbSwgdG8gIT09IHVuZGVmaW5lZCA/IHRvIDogYXJyYXkubGVuZ3RoKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhcnJheS5zbGljZShmcm9tLCB0byk7XG5cdFx0fSxcblx0XHQvLyBjb252ZXJ0cyBhbiBhcnJheSB0byBhIHNwZWNpZmljIHR5cGVcblx0XHRjb252ZXJ0QXJyYXk6IGZ1bmN0aW9uIChhcnJheSwgdHlwZSwgZm9yY2VDbG9uZSkge1xuXHRcdFx0aWYgKCFhcnJheSB8fCAvLyBsZXQgJ3VuZGVmaW5lZCcgYW5kICdudWxsJyBwYXNzXG5cdFx0XHQhZm9yY2VDbG9uZSAmJiBhcnJheS5jb25zdHJ1Y3RvciA9PT0gdHlwZSkgcmV0dXJuIGFycmF5O1xuXG5cdFx0XHRpZiAodHlwZW9mIHR5cGUuQllURVNfUEVSX0VMRU1FTlQgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgdHlwZShhcnJheSk7IC8vIGNyZWF0ZSB0eXBlZCBhcnJheVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXkpOyAvLyBjcmVhdGUgQXJyYXlcblx0XHR9LFxuXHRcdGlzVHlwZWRBcnJheTogZnVuY3Rpb24gKG9iamVjdCkge1xuXHRcdFx0cmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhvYmplY3QpICYmICEob2JqZWN0IGluc3RhbmNlb2YgRGF0YVZpZXcpO1xuXHRcdH0sXG5cdFx0Ly8gcmV0dXJucyBhbiBhcnJheSBieSB3aGljaCB0aW1lcyBhbmQgdmFsdWVzIGNhbiBiZSBzb3J0ZWRcblx0XHRnZXRLZXlmcmFtZU9yZGVyOiBmdW5jdGlvbiAodGltZXMpIHtcblx0XHRcdGZ1bmN0aW9uIGNvbXBhcmVUaW1lKGksIGopIHtcblx0XHRcdFx0cmV0dXJuIHRpbWVzW2ldIC0gdGltZXNbal07XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG4gPSB0aW1lcy5sZW5ndGg7XG5cdFx0XHRjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkobik7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpICE9PSBuOyArK2kpIHJlc3VsdFtpXSA9IGk7XG5cblx0XHRcdHJlc3VsdC5zb3J0KGNvbXBhcmVUaW1lKTtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSxcblx0XHQvLyB1c2VzIHRoZSBhcnJheSBwcmV2aW91c2x5IHJldHVybmVkIGJ5ICdnZXRLZXlmcmFtZU9yZGVyJyB0byBzb3J0IGRhdGFcblx0XHRzb3J0ZWRBcnJheTogZnVuY3Rpb24gKHZhbHVlcywgc3RyaWRlLCBvcmRlcikge1xuXHRcdFx0Y29uc3QgblZhbHVlcyA9IHZhbHVlcy5sZW5ndGg7XG5cdFx0XHRjb25zdCByZXN1bHQgPSBuZXcgdmFsdWVzLmNvbnN0cnVjdG9yKG5WYWx1ZXMpO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgZHN0T2Zmc2V0ID0gMDsgZHN0T2Zmc2V0ICE9PSBuVmFsdWVzOyArK2kpIHtcblx0XHRcdFx0Y29uc3Qgc3JjT2Zmc2V0ID0gb3JkZXJbaV0gKiBzdHJpZGU7XG5cblx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogIT09IHN0cmlkZTsgKytqKSB7XG5cdFx0XHRcdFx0cmVzdWx0W2RzdE9mZnNldCsrXSA9IHZhbHVlc1tzcmNPZmZzZXQgKyBqXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0sXG5cdFx0Ly8gZnVuY3Rpb24gZm9yIHBhcnNpbmcgQU9TIGtleWZyYW1lIGZvcm1hdHNcblx0XHRmbGF0dGVuSlNPTjogZnVuY3Rpb24gKGpzb25LZXlzLCB0aW1lcywgdmFsdWVzLCB2YWx1ZVByb3BlcnR5TmFtZSkge1xuXHRcdFx0bGV0IGkgPSAxLFxuXHRcdFx0XHRcdGtleSA9IGpzb25LZXlzWzBdO1xuXG5cdFx0XHR3aGlsZSAoa2V5ICE9PSB1bmRlZmluZWQgJiYga2V5W3ZhbHVlUHJvcGVydHlOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGtleSA9IGpzb25LZXlzW2krK107XG5cdFx0XHR9XG5cblx0XHRcdGlmIChrZXkgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAvLyBubyBkYXRhXG5cblx0XHRcdGxldCB2YWx1ZSA9IGtleVt2YWx1ZVByb3BlcnR5TmFtZV07XG5cdFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAvLyBubyBkYXRhXG5cblx0XHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0dmFsdWUgPSBrZXlbdmFsdWVQcm9wZXJ0eU5hbWVdO1xuXG5cdFx0XHRcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHRpbWVzLnB1c2goa2V5LnRpbWUpO1xuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2guYXBwbHkodmFsdWVzLCB2YWx1ZSk7IC8vIHB1c2ggYWxsIGVsZW1lbnRzXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0a2V5ID0ganNvbktleXNbaSsrXTtcblx0XHRcdFx0fSB3aGlsZSAoa2V5ICE9PSB1bmRlZmluZWQpO1xuXHRcdFx0fSBlbHNlIGlmICh2YWx1ZS50b0FycmF5ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Ly8gLi4uYXNzdW1lIFRIUkVFLk1hdGgtaXNoXG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGtleVt2YWx1ZVByb3BlcnR5TmFtZV07XG5cblx0XHRcdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0dGltZXMucHVzaChrZXkudGltZSk7XG5cdFx0XHRcdFx0XHR2YWx1ZS50b0FycmF5KHZhbHVlcywgdmFsdWVzLmxlbmd0aCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0a2V5ID0ganNvbktleXNbaSsrXTtcblx0XHRcdFx0fSB3aGlsZSAoa2V5ICE9PSB1bmRlZmluZWQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHB1c2ggYXMtaXNcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdHZhbHVlID0ga2V5W3ZhbHVlUHJvcGVydHlOYW1lXTtcblxuXHRcdFx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHR0aW1lcy5wdXNoKGtleS50aW1lKTtcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRrZXkgPSBqc29uS2V5c1tpKytdO1xuXHRcdFx0XHR9IHdoaWxlIChrZXkgIT09IHVuZGVmaW5lZCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzdWJjbGlwOiBmdW5jdGlvbiAoc291cmNlQ2xpcCwgbmFtZSwgc3RhcnRGcmFtZSwgZW5kRnJhbWUsIGZwcyA9IDMwKSB7XG5cdFx0XHRjb25zdCBjbGlwID0gc291cmNlQ2xpcC5jbG9uZSgpO1xuXHRcdFx0Y2xpcC5uYW1lID0gbmFtZTtcblx0XHRcdGNvbnN0IHRyYWNrcyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNsaXAudHJhY2tzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdGNvbnN0IHRyYWNrID0gY2xpcC50cmFja3NbaV07XG5cdFx0XHRcdGNvbnN0IHZhbHVlU2l6ZSA9IHRyYWNrLmdldFZhbHVlU2l6ZSgpO1xuXHRcdFx0XHRjb25zdCB0aW1lcyA9IFtdO1xuXHRcdFx0XHRjb25zdCB2YWx1ZXMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IHRyYWNrLnRpbWVzLmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdFx0Y29uc3QgZnJhbWUgPSB0cmFjay50aW1lc1tqXSAqIGZwcztcblx0XHRcdFx0XHRpZiAoZnJhbWUgPCBzdGFydEZyYW1lIHx8IGZyYW1lID49IGVuZEZyYW1lKSBjb250aW51ZTtcblx0XHRcdFx0XHR0aW1lcy5wdXNoKHRyYWNrLnRpbWVzW2pdKTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGsgPSAwOyBrIDwgdmFsdWVTaXplOyArK2spIHtcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKHRyYWNrLnZhbHVlc1tqICogdmFsdWVTaXplICsga10pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aW1lcy5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuXHRcdFx0XHR0cmFjay50aW1lcyA9IEFuaW1hdGlvblV0aWxzLmNvbnZlcnRBcnJheSh0aW1lcywgdHJhY2sudGltZXMuY29uc3RydWN0b3IpO1xuXHRcdFx0XHR0cmFjay52YWx1ZXMgPSBBbmltYXRpb25VdGlscy5jb252ZXJ0QXJyYXkodmFsdWVzLCB0cmFjay52YWx1ZXMuY29uc3RydWN0b3IpO1xuXHRcdFx0XHR0cmFja3MucHVzaCh0cmFjayk7XG5cdFx0XHR9XG5cblx0XHRcdGNsaXAudHJhY2tzID0gdHJhY2tzOyAvLyBmaW5kIG1pbmltdW0gLnRpbWVzIHZhbHVlIGFjcm9zcyBhbGwgdHJhY2tzIGluIHRoZSB0cmltbWVkIGNsaXBcblxuXHRcdFx0bGV0IG1pblN0YXJ0VGltZSA9IEluZmluaXR5O1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNsaXAudHJhY2tzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdGlmIChtaW5TdGFydFRpbWUgPiBjbGlwLnRyYWNrc1tpXS50aW1lc1swXSkge1xuXHRcdFx0XHRcdG1pblN0YXJ0VGltZSA9IGNsaXAudHJhY2tzW2ldLnRpbWVzWzBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9IC8vIHNoaWZ0IGFsbCB0cmFja3Mgc3VjaCB0aGF0IGNsaXAgYmVnaW5zIGF0IHQ9MFxuXG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY2xpcC50cmFja3MubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0Y2xpcC50cmFja3NbaV0uc2hpZnQoLTEgKiBtaW5TdGFydFRpbWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRjbGlwLnJlc2V0RHVyYXRpb24oKTtcblx0XHRcdHJldHVybiBjbGlwO1xuXHRcdH0sXG5cdFx0bWFrZUNsaXBBZGRpdGl2ZTogZnVuY3Rpb24gKHRhcmdldENsaXAsIHJlZmVyZW5jZUZyYW1lID0gMCwgcmVmZXJlbmNlQ2xpcCA9IHRhcmdldENsaXAsIGZwcyA9IDMwKSB7XG5cdFx0XHRpZiAoZnBzIDw9IDApIGZwcyA9IDMwO1xuXHRcdFx0Y29uc3QgbnVtVHJhY2tzID0gcmVmZXJlbmNlQ2xpcC50cmFja3MubGVuZ3RoO1xuXHRcdFx0Y29uc3QgcmVmZXJlbmNlVGltZSA9IHJlZmVyZW5jZUZyYW1lIC8gZnBzOyAvLyBNYWtlIGVhY2ggdHJhY2sncyB2YWx1ZXMgcmVsYXRpdmUgdG8gdGhlIHZhbHVlcyBhdCB0aGUgcmVmZXJlbmNlIGZyYW1lXG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVHJhY2tzOyArK2kpIHtcblx0XHRcdFx0Y29uc3QgcmVmZXJlbmNlVHJhY2sgPSByZWZlcmVuY2VDbGlwLnRyYWNrc1tpXTtcblx0XHRcdFx0Y29uc3QgcmVmZXJlbmNlVHJhY2tUeXBlID0gcmVmZXJlbmNlVHJhY2suVmFsdWVUeXBlTmFtZTsgLy8gU2tpcCB0aGlzIHRyYWNrIGlmIGl0J3Mgbm9uLW51bWVyaWNcblxuXHRcdFx0XHRpZiAocmVmZXJlbmNlVHJhY2tUeXBlID09PSAnYm9vbCcgfHwgcmVmZXJlbmNlVHJhY2tUeXBlID09PSAnc3RyaW5nJykgY29udGludWU7IC8vIEZpbmQgdGhlIHRyYWNrIGluIHRoZSB0YXJnZXQgY2xpcCB3aG9zZSBuYW1lIGFuZCB0eXBlIG1hdGNoZXMgdGhlIHJlZmVyZW5jZSB0cmFja1xuXG5cdFx0XHRcdGNvbnN0IHRhcmdldFRyYWNrID0gdGFyZ2V0Q2xpcC50cmFja3MuZmluZChmdW5jdGlvbiAodHJhY2spIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJhY2submFtZSA9PT0gcmVmZXJlbmNlVHJhY2submFtZSAmJiB0cmFjay5WYWx1ZVR5cGVOYW1lID09PSByZWZlcmVuY2VUcmFja1R5cGU7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZiAodGFyZ2V0VHJhY2sgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG5cdFx0XHRcdGxldCByZWZlcmVuY2VPZmZzZXQgPSAwO1xuXHRcdFx0XHRjb25zdCByZWZlcmVuY2VWYWx1ZVNpemUgPSByZWZlcmVuY2VUcmFjay5nZXRWYWx1ZVNpemUoKTtcblxuXHRcdFx0XHRpZiAocmVmZXJlbmNlVHJhY2suY3JlYXRlSW50ZXJwb2xhbnQuaXNJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUpIHtcblx0XHRcdFx0XHRyZWZlcmVuY2VPZmZzZXQgPSByZWZlcmVuY2VWYWx1ZVNpemUgLyAzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGV0IHRhcmdldE9mZnNldCA9IDA7XG5cdFx0XHRcdGNvbnN0IHRhcmdldFZhbHVlU2l6ZSA9IHRhcmdldFRyYWNrLmdldFZhbHVlU2l6ZSgpO1xuXG5cdFx0XHRcdGlmICh0YXJnZXRUcmFjay5jcmVhdGVJbnRlcnBvbGFudC5pc0ludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSkge1xuXHRcdFx0XHRcdHRhcmdldE9mZnNldCA9IHRhcmdldFZhbHVlU2l6ZSAvIDM7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBsYXN0SW5kZXggPSByZWZlcmVuY2VUcmFjay50aW1lcy5sZW5ndGggLSAxO1xuXHRcdFx0XHRsZXQgcmVmZXJlbmNlVmFsdWU7IC8vIEZpbmQgdGhlIHZhbHVlIHRvIHN1YnRyYWN0IG91dCBvZiB0aGUgdHJhY2tcblxuXHRcdFx0XHRpZiAocmVmZXJlbmNlVGltZSA8PSByZWZlcmVuY2VUcmFjay50aW1lc1swXSkge1xuXHRcdFx0XHRcdC8vIFJlZmVyZW5jZSBmcmFtZSBpcyBlYXJsaWVyIHRoYW4gdGhlIGZpcnN0IGtleWZyYW1lLCBzbyBqdXN0IHVzZSB0aGUgZmlyc3Qga2V5ZnJhbWVcblx0XHRcdFx0XHRjb25zdCBzdGFydEluZGV4ID0gcmVmZXJlbmNlT2Zmc2V0O1xuXHRcdFx0XHRcdGNvbnN0IGVuZEluZGV4ID0gcmVmZXJlbmNlVmFsdWVTaXplIC0gcmVmZXJlbmNlT2Zmc2V0O1xuXHRcdFx0XHRcdHJlZmVyZW5jZVZhbHVlID0gQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZShyZWZlcmVuY2VUcmFjay52YWx1ZXMsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcblx0XHRcdFx0fSBlbHNlIGlmIChyZWZlcmVuY2VUaW1lID49IHJlZmVyZW5jZVRyYWNrLnRpbWVzW2xhc3RJbmRleF0pIHtcblx0XHRcdFx0XHQvLyBSZWZlcmVuY2UgZnJhbWUgaXMgYWZ0ZXIgdGhlIGxhc3Qga2V5ZnJhbWUsIHNvIGp1c3QgdXNlIHRoZSBsYXN0IGtleWZyYW1lXG5cdFx0XHRcdFx0Y29uc3Qgc3RhcnRJbmRleCA9IGxhc3RJbmRleCAqIHJlZmVyZW5jZVZhbHVlU2l6ZSArIHJlZmVyZW5jZU9mZnNldDtcblx0XHRcdFx0XHRjb25zdCBlbmRJbmRleCA9IHN0YXJ0SW5kZXggKyByZWZlcmVuY2VWYWx1ZVNpemUgLSByZWZlcmVuY2VPZmZzZXQ7XG5cdFx0XHRcdFx0cmVmZXJlbmNlVmFsdWUgPSBBbmltYXRpb25VdGlscy5hcnJheVNsaWNlKHJlZmVyZW5jZVRyYWNrLnZhbHVlcywgc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEludGVycG9sYXRlIHRvIHRoZSByZWZlcmVuY2UgdmFsdWVcblx0XHRcdFx0XHRjb25zdCBpbnRlcnBvbGFudCA9IHJlZmVyZW5jZVRyYWNrLmNyZWF0ZUludGVycG9sYW50KCk7XG5cdFx0XHRcdFx0Y29uc3Qgc3RhcnRJbmRleCA9IHJlZmVyZW5jZU9mZnNldDtcblx0XHRcdFx0XHRjb25zdCBlbmRJbmRleCA9IHJlZmVyZW5jZVZhbHVlU2l6ZSAtIHJlZmVyZW5jZU9mZnNldDtcblx0XHRcdFx0XHRpbnRlcnBvbGFudC5ldmFsdWF0ZShyZWZlcmVuY2VUaW1lKTtcblx0XHRcdFx0XHRyZWZlcmVuY2VWYWx1ZSA9IEFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UoaW50ZXJwb2xhbnQucmVzdWx0QnVmZmVyLCBzdGFydEluZGV4LCBlbmRJbmRleCk7XG5cdFx0XHRcdH0gLy8gQ29uanVnYXRlIHRoZSBxdWF0ZXJuaW9uXG5cblxuXHRcdFx0XHRpZiAocmVmZXJlbmNlVHJhY2tUeXBlID09PSAncXVhdGVybmlvbicpIHtcblx0XHRcdFx0XHRjb25zdCByZWZlcmVuY2VRdWF0ID0gbmV3IFF1YXRlcm5pb24oKS5mcm9tQXJyYXkocmVmZXJlbmNlVmFsdWUpLm5vcm1hbGl6ZSgpLmNvbmp1Z2F0ZSgpO1xuXHRcdFx0XHRcdHJlZmVyZW5jZVF1YXQudG9BcnJheShyZWZlcmVuY2VWYWx1ZSk7XG5cdFx0XHRcdH0gLy8gU3VidHJhY3QgdGhlIHJlZmVyZW5jZSB2YWx1ZSBmcm9tIGFsbCBvZiB0aGUgdHJhY2sgdmFsdWVzXG5cblxuXHRcdFx0XHRjb25zdCBudW1UaW1lcyA9IHRhcmdldFRyYWNrLnRpbWVzLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IG51bVRpbWVzOyArK2opIHtcblx0XHRcdFx0XHRjb25zdCB2YWx1ZVN0YXJ0ID0gaiAqIHRhcmdldFZhbHVlU2l6ZSArIHRhcmdldE9mZnNldDtcblxuXHRcdFx0XHRcdGlmIChyZWZlcmVuY2VUcmFja1R5cGUgPT09ICdxdWF0ZXJuaW9uJykge1xuXHRcdFx0XHRcdFx0Ly8gTXVsdGlwbHkgdGhlIGNvbmp1Z2F0ZSBmb3IgcXVhdGVybmlvbiB0cmFjayB0eXBlc1xuXHRcdFx0XHRcdFx0UXVhdGVybmlvbi5tdWx0aXBseVF1YXRlcm5pb25zRmxhdCh0YXJnZXRUcmFjay52YWx1ZXMsIHZhbHVlU3RhcnQsIHJlZmVyZW5jZVZhbHVlLCAwLCB0YXJnZXRUcmFjay52YWx1ZXMsIHZhbHVlU3RhcnQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zdCB2YWx1ZUVuZCA9IHRhcmdldFZhbHVlU2l6ZSAtIHRhcmdldE9mZnNldCAqIDI7IC8vIFN1YnRyYWN0IGVhY2ggdmFsdWUgZm9yIGFsbCBvdGhlciBudW1lcmljIHRyYWNrIHR5cGVzXG5cblx0XHRcdFx0XHRcdGZvciAobGV0IGsgPSAwOyBrIDwgdmFsdWVFbmQ7ICsraykge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRUcmFjay52YWx1ZXNbdmFsdWVTdGFydCArIGtdIC09IHJlZmVyZW5jZVZhbHVlW2tdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0YXJnZXRDbGlwLmJsZW5kTW9kZSA9IEFkZGl0aXZlQW5pbWF0aW9uQmxlbmRNb2RlO1xuXHRcdFx0cmV0dXJuIHRhcmdldENsaXA7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBYnN0cmFjdCBiYXNlIGNsYXNzIG9mIGludGVycG9sYW50cyBvdmVyIHBhcmFtZXRyaWMgc2FtcGxlcy5cblx0ICpcblx0ICogVGhlIHBhcmFtZXRlciBkb21haW4gaXMgb25lIGRpbWVuc2lvbmFsLCB0eXBpY2FsbHkgdGhlIHRpbWUgb3IgYSBwYXRoXG5cdCAqIGFsb25nIGEgY3VydmUgZGVmaW5lZCBieSB0aGUgZGF0YS5cblx0ICpcblx0ICogVGhlIHNhbXBsZSB2YWx1ZXMgY2FuIGhhdmUgYW55IGRpbWVuc2lvbmFsaXR5IGFuZCBkZXJpdmVkIGNsYXNzZXMgbWF5XG5cdCAqIGFwcGx5IHNwZWNpYWwgaW50ZXJwcmV0YXRpb25zIHRvIHRoZSBkYXRhLlxuXHQgKlxuXHQgKiBUaGlzIGNsYXNzIHByb3ZpZGVzIHRoZSBpbnRlcnZhbCBzZWVrIGluIGEgVGVtcGxhdGUgTWV0aG9kLCBkZWZlcnJpbmdcblx0ICogdGhlIGFjdHVhbCBpbnRlcnBvbGF0aW9uIHRvIGRlcml2ZWQgY2xhc3Nlcy5cblx0ICpcblx0ICogVGltZSBjb21wbGV4aXR5IGlzIE8oMSkgZm9yIGxpbmVhciBhY2Nlc3MgY3Jvc3NpbmcgYXQgbW9zdCB0d28gcG9pbnRzXG5cdCAqIGFuZCBPKGxvZyBOKSBmb3IgcmFuZG9tIGFjY2Vzcywgd2hlcmUgTiBpcyB0aGUgbnVtYmVyIG9mIHBvc2l0aW9ucy5cblx0ICpcblx0ICogUmVmZXJlbmNlczpcblx0ICpcblx0ICogXHRcdGh0dHA6Ly93d3cub29kZXNpZ24uY29tL3RlbXBsYXRlLW1ldGhvZC1wYXR0ZXJuLmh0bWxcblx0ICpcblx0ICovXG5cdGNsYXNzIEludGVycG9sYW50IHtcblx0XHRjb25zdHJ1Y3RvcihwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyKSB7XG5cdFx0XHR0aGlzLnBhcmFtZXRlclBvc2l0aW9ucyA9IHBhcmFtZXRlclBvc2l0aW9ucztcblx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gMDtcblx0XHRcdHRoaXMucmVzdWx0QnVmZmVyID0gcmVzdWx0QnVmZmVyICE9PSB1bmRlZmluZWQgPyByZXN1bHRCdWZmZXIgOiBuZXcgc2FtcGxlVmFsdWVzLmNvbnN0cnVjdG9yKHNhbXBsZVNpemUpO1xuXHRcdFx0dGhpcy5zYW1wbGVWYWx1ZXMgPSBzYW1wbGVWYWx1ZXM7XG5cdFx0XHR0aGlzLnZhbHVlU2l6ZSA9IHNhbXBsZVNpemU7XG5cdFx0XHR0aGlzLnNldHRpbmdzID0gbnVsbDtcblx0XHRcdHRoaXMuRGVmYXVsdFNldHRpbmdzXyA9IHt9O1xuXHRcdH1cblxuXHRcdGV2YWx1YXRlKHQpIHtcblx0XHRcdGNvbnN0IHBwID0gdGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnM7XG5cdFx0XHRsZXQgaTEgPSB0aGlzLl9jYWNoZWRJbmRleCxcblx0XHRcdFx0XHR0MSA9IHBwW2kxXSxcblx0XHRcdFx0XHR0MCA9IHBwW2kxIC0gMV07XG5cblx0XHRcdHZhbGlkYXRlX2ludGVydmFsOiB7XG5cdFx0XHRcdHNlZWs6IHtcblx0XHRcdFx0XHRsZXQgcmlnaHQ7XG5cblx0XHRcdFx0XHRsaW5lYXJfc2Nhbjoge1xuXHRcdFx0XHRcdFx0Ly8tIFNlZSBodHRwOi8vanNwZXJmLmNvbS9jb21wYXJpc29uLXRvLXVuZGVmaW5lZC8zXG5cdFx0XHRcdFx0XHQvLy0gc2xvd2VyIGNvZGU6XG5cdFx0XHRcdFx0XHQvLy1cblx0XHRcdFx0XHRcdC8vLSBcdFx0XHRcdGlmICggdCA+PSB0MSB8fCB0MSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0Zm9yd2FyZF9zY2FuOiBpZiAoISh0IDwgdDEpKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAobGV0IGdpdmVVcEF0ID0gaTEgKyAyOzspIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAodDEgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHQgPCB0MCkgYnJlYWsgZm9yd2FyZF9zY2FuOyAvLyBhZnRlciBlbmRcblxuXHRcdFx0XHRcdFx0XHRcdFx0aTEgPSBwcC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IGkxO1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYWZ0ZXJFbmRfKGkxIC0gMSwgdCwgdDApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGlmIChpMSA9PT0gZ2l2ZVVwQXQpIGJyZWFrOyAvLyB0aGlzIGxvb3BcblxuXHRcdFx0XHRcdFx0XHRcdHQwID0gdDE7XG5cdFx0XHRcdFx0XHRcdFx0dDEgPSBwcFsrK2kxXTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICh0IDwgdDEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHdlIGhhdmUgYXJyaXZlZCBhdCB0aGUgc291Z2h0IGludGVydmFsXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhayBzZWVrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSAvLyBwcmVwYXJlIGJpbmFyeSBzZWFyY2ggb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGluZGV4XG5cblxuXHRcdFx0XHRcdFx0XHRyaWdodCA9IHBwLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0YnJlYWsgbGluZWFyX3NjYW47XG5cdFx0XHRcdFx0XHR9IC8vLSBzbG93ZXIgY29kZTpcblx0XHRcdFx0XHRcdC8vLVx0XHRcdFx0XHRpZiAoIHQgPCB0MCB8fCB0MCA9PT0gdW5kZWZpbmVkICkge1xuXG5cblx0XHRcdFx0XHRcdGlmICghKHQgPj0gdDApKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGxvb3Bpbmc/XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHQxZ2xvYmFsID0gcHBbMV07XG5cblx0XHRcdFx0XHRcdFx0aWYgKHQgPCB0MWdsb2JhbCkge1xuXHRcdFx0XHRcdFx0XHRcdGkxID0gMjsgLy8gKyAxLCB1c2luZyB0aGUgc2NhbiBmb3IgdGhlIGRldGFpbHNcblxuXHRcdFx0XHRcdFx0XHRcdHQwID0gdDFnbG9iYWw7XG5cdFx0XHRcdFx0XHRcdH0gLy8gbGluZWFyIHJldmVyc2Ugc2NhblxuXG5cblx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgZ2l2ZVVwQXQgPSBpMSAtIDI7Oykge1xuXHRcdFx0XHRcdFx0XHRcdGlmICh0MCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBiZWZvcmUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gMDtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmJlZm9yZVN0YXJ0XygwLCB0LCB0MSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGkxID09PSBnaXZlVXBBdCkgYnJlYWs7IC8vIHRoaXMgbG9vcFxuXG5cdFx0XHRcdFx0XHRcdFx0dDEgPSB0MDtcblx0XHRcdFx0XHRcdFx0XHR0MCA9IHBwWy0taTEgLSAxXTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICh0ID49IHQwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyB3ZSBoYXZlIGFycml2ZWQgYXQgdGhlIHNvdWdodCBpbnRlcnZhbFxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWsgc2Vlaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gLy8gcHJlcGFyZSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGluZGV4XG5cblxuXHRcdFx0XHRcdFx0XHRyaWdodCA9IGkxO1xuXHRcdFx0XHRcdFx0XHRpMSA9IDA7XG5cdFx0XHRcdFx0XHRcdGJyZWFrIGxpbmVhcl9zY2FuO1xuXHRcdFx0XHRcdFx0fSAvLyB0aGUgaW50ZXJ2YWwgaXMgdmFsaWRcblxuXG5cdFx0XHRcdFx0XHRicmVhayB2YWxpZGF0ZV9pbnRlcnZhbDtcblx0XHRcdFx0XHR9IC8vIGxpbmVhciBzY2FuXG5cdFx0XHRcdFx0Ly8gYmluYXJ5IHNlYXJjaFxuXG5cblx0XHRcdFx0XHR3aGlsZSAoaTEgPCByaWdodCkge1xuXHRcdFx0XHRcdFx0Y29uc3QgbWlkID0gaTEgKyByaWdodCA+Pj4gMTtcblxuXHRcdFx0XHRcdFx0aWYgKHQgPCBwcFttaWRdKSB7XG5cdFx0XHRcdFx0XHRcdHJpZ2h0ID0gbWlkO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aTEgPSBtaWQgKyAxO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHQxID0gcHBbaTFdO1xuXHRcdFx0XHRcdHQwID0gcHBbaTEgLSAxXTsgLy8gY2hlY2sgYm91bmRhcnkgY2FzZXMsIGFnYWluXG5cblx0XHRcdFx0XHRpZiAodDAgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fY2FjaGVkSW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYmVmb3JlU3RhcnRfKDAsIHQsIHQxKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAodDEgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0aTEgPSBwcC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IGkxO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYWZ0ZXJFbmRfKGkxIC0gMSwgdDAsIHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSAvLyBzZWVrXG5cblxuXHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IGkxO1xuXHRcdFx0XHR0aGlzLmludGVydmFsQ2hhbmdlZF8oaTEsIHQwLCB0MSk7XG5cdFx0XHR9IC8vIHZhbGlkYXRlX2ludGVydmFsXG5cblxuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJwb2xhdGVfKGkxLCB0MCwgdCwgdDEpO1xuXHRcdH1cblxuXHRcdGdldFNldHRpbmdzXygpIHtcblx0XHRcdHJldHVybiB0aGlzLnNldHRpbmdzIHx8IHRoaXMuRGVmYXVsdFNldHRpbmdzXztcblx0XHR9XG5cblx0XHRjb3B5U2FtcGxlVmFsdWVfKGluZGV4KSB7XG5cdFx0XHQvLyBjb3BpZXMgYSBzYW1wbGUgdmFsdWUgdG8gdGhlIHJlc3VsdCBidWZmZXJcblx0XHRcdGNvbnN0IHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxuXHRcdFx0XHRcdFx0dmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXG5cdFx0XHRcdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcblx0XHRcdFx0XHRcdG9mZnNldCA9IGluZGV4ICogc3RyaWRlO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSAhPT0gc3RyaWRlOyArK2kpIHtcblx0XHRcdFx0cmVzdWx0W2ldID0gdmFsdWVzW29mZnNldCArIGldO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0gLy8gVGVtcGxhdGUgbWV0aG9kcyBmb3IgZGVyaXZlZCBjbGFzc2VzOlxuXG5cblx0XHRpbnRlcnBvbGF0ZV8oKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2NhbGwgdG8gYWJzdHJhY3QgbWV0aG9kJyk7IC8vIGltcGxlbWVudGF0aW9ucyBzaGFsbCByZXR1cm4gdGhpcy5yZXN1bHRCdWZmZXJcblx0XHR9XG5cblx0XHRpbnRlcnZhbENoYW5nZWRfKCkgey8vIGVtcHR5XG5cdFx0fVxuXG5cdH0gLy8gQUxJQVMgREVGSU5JVElPTlNcblxuXG5cdEludGVycG9sYW50LnByb3RvdHlwZS5iZWZvcmVTdGFydF8gPSBJbnRlcnBvbGFudC5wcm90b3R5cGUuY29weVNhbXBsZVZhbHVlXztcblx0SW50ZXJwb2xhbnQucHJvdG90eXBlLmFmdGVyRW5kXyA9IEludGVycG9sYW50LnByb3RvdHlwZS5jb3B5U2FtcGxlVmFsdWVfO1xuXG5cdC8qKlxuXHQgKiBGYXN0IGFuZCBzaW1wbGUgY3ViaWMgc3BsaW5lIGludGVycG9sYW50LlxuXHQgKlxuXHQgKiBJdCB3YXMgZGVyaXZlZCBmcm9tIGEgSGVybWl0aWFuIGNvbnN0cnVjdGlvbiBzZXR0aW5nIHRoZSBmaXJzdCBkZXJpdmF0aXZlXG5cdCAqIGF0IGVhY2ggc2FtcGxlIHBvc2l0aW9uIHRvIHRoZSBsaW5lYXIgc2xvcGUgYmV0d2VlbiBuZWlnaGJvcmluZyBwb3NpdGlvbnNcblx0ICogb3ZlciB0aGVpciBwYXJhbWV0ZXIgaW50ZXJ2YWwuXG5cdCAqL1xuXG5cdGNsYXNzIEN1YmljSW50ZXJwb2xhbnQgZXh0ZW5kcyBJbnRlcnBvbGFudCB7XG5cdFx0Y29uc3RydWN0b3IocGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlcikge1xuXHRcdFx0c3VwZXIocGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlcik7XG5cdFx0XHR0aGlzLl93ZWlnaHRQcmV2ID0gLTA7XG5cdFx0XHR0aGlzLl9vZmZzZXRQcmV2ID0gLTA7XG5cdFx0XHR0aGlzLl93ZWlnaHROZXh0ID0gLTA7XG5cdFx0XHR0aGlzLl9vZmZzZXROZXh0ID0gLTA7XG5cdFx0XHR0aGlzLkRlZmF1bHRTZXR0aW5nc18gPSB7XG5cdFx0XHRcdGVuZGluZ1N0YXJ0OiBaZXJvQ3VydmF0dXJlRW5kaW5nLFxuXHRcdFx0XHRlbmRpbmdFbmQ6IFplcm9DdXJ2YXR1cmVFbmRpbmdcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0aW50ZXJ2YWxDaGFuZ2VkXyhpMSwgdDAsIHQxKSB7XG5cdFx0XHRjb25zdCBwcCA9IHRoaXMucGFyYW1ldGVyUG9zaXRpb25zO1xuXHRcdFx0bGV0IGlQcmV2ID0gaTEgLSAyLFxuXHRcdFx0XHRcdGlOZXh0ID0gaTEgKyAxLFxuXHRcdFx0XHRcdHRQcmV2ID0gcHBbaVByZXZdLFxuXHRcdFx0XHRcdHROZXh0ID0gcHBbaU5leHRdO1xuXG5cdFx0XHRpZiAodFByZXYgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRzd2l0Y2ggKHRoaXMuZ2V0U2V0dGluZ3NfKCkuZW5kaW5nU3RhcnQpIHtcblx0XHRcdFx0XHRjYXNlIFplcm9TbG9wZUVuZGluZzpcblx0XHRcdFx0XHRcdC8vIGYnKHQwKSA9IDBcblx0XHRcdFx0XHRcdGlQcmV2ID0gaTE7XG5cdFx0XHRcdFx0XHR0UHJldiA9IDIgKiB0MCAtIHQxO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFdyYXBBcm91bmRFbmRpbmc6XG5cdFx0XHRcdFx0XHQvLyB1c2UgdGhlIG90aGVyIGVuZCBvZiB0aGUgY3VydmVcblx0XHRcdFx0XHRcdGlQcmV2ID0gcHAubGVuZ3RoIC0gMjtcblx0XHRcdFx0XHRcdHRQcmV2ID0gdDAgKyBwcFtpUHJldl0gLSBwcFtpUHJldiArIDFdO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Ly8gWmVyb0N1cnZhdHVyZUVuZGluZ1xuXHRcdFx0XHRcdFx0Ly8gZicnKHQwKSA9IDAgYS5rLmEuIE5hdHVyYWwgU3BsaW5lXG5cdFx0XHRcdFx0XHRpUHJldiA9IGkxO1xuXHRcdFx0XHRcdFx0dFByZXYgPSB0MTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodE5leHQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRzd2l0Y2ggKHRoaXMuZ2V0U2V0dGluZ3NfKCkuZW5kaW5nRW5kKSB7XG5cdFx0XHRcdFx0Y2FzZSBaZXJvU2xvcGVFbmRpbmc6XG5cdFx0XHRcdFx0XHQvLyBmJyh0TikgPSAwXG5cdFx0XHRcdFx0XHRpTmV4dCA9IGkxO1xuXHRcdFx0XHRcdFx0dE5leHQgPSAyICogdDEgLSB0MDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBXcmFwQXJvdW5kRW5kaW5nOlxuXHRcdFx0XHRcdFx0Ly8gdXNlIHRoZSBvdGhlciBlbmQgb2YgdGhlIGN1cnZlXG5cdFx0XHRcdFx0XHRpTmV4dCA9IDE7XG5cdFx0XHRcdFx0XHR0TmV4dCA9IHQxICsgcHBbMV0gLSBwcFswXTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdC8vIFplcm9DdXJ2YXR1cmVFbmRpbmdcblx0XHRcdFx0XHRcdC8vIGYnJyh0TikgPSAwLCBhLmsuYS4gTmF0dXJhbCBTcGxpbmVcblx0XHRcdFx0XHRcdGlOZXh0ID0gaTEgLSAxO1xuXHRcdFx0XHRcdFx0dE5leHQgPSB0MDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBoYWxmRHQgPSAodDEgLSB0MCkgKiAwLjUsXG5cdFx0XHRcdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZTtcblx0XHRcdHRoaXMuX3dlaWdodFByZXYgPSBoYWxmRHQgLyAodDAgLSB0UHJldik7XG5cdFx0XHR0aGlzLl93ZWlnaHROZXh0ID0gaGFsZkR0IC8gKHROZXh0IC0gdDEpO1xuXHRcdFx0dGhpcy5fb2Zmc2V0UHJldiA9IGlQcmV2ICogc3RyaWRlO1xuXHRcdFx0dGhpcy5fb2Zmc2V0TmV4dCA9IGlOZXh0ICogc3RyaWRlO1xuXHRcdH1cblxuXHRcdGludGVycG9sYXRlXyhpMSwgdDAsIHQsIHQxKSB7XG5cdFx0XHRjb25zdCByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcblx0XHRcdFx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxuXHRcdFx0XHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cdFx0XHRcdFx0XHRvMSA9IGkxICogc3RyaWRlLFxuXHRcdFx0XHRcdFx0bzAgPSBvMSAtIHN0cmlkZSxcblx0XHRcdFx0XHRcdG9QID0gdGhpcy5fb2Zmc2V0UHJldixcblx0XHRcdFx0XHRcdG9OID0gdGhpcy5fb2Zmc2V0TmV4dCxcblx0XHRcdFx0XHRcdHdQID0gdGhpcy5fd2VpZ2h0UHJldixcblx0XHRcdFx0XHRcdHdOID0gdGhpcy5fd2VpZ2h0TmV4dCxcblx0XHRcdFx0XHRcdHAgPSAodCAtIHQwKSAvICh0MSAtIHQwKSxcblx0XHRcdFx0XHRcdHBwID0gcCAqIHAsXG5cdFx0XHRcdFx0XHRwcHAgPSBwcCAqIHA7IC8vIGV2YWx1YXRlIHBvbHlub21pYWxzXG5cblx0XHRcdGNvbnN0IHNQID0gLXdQICogcHBwICsgMiAqIHdQICogcHAgLSB3UCAqIHA7XG5cdFx0XHRjb25zdCBzMCA9ICgxICsgd1ApICogcHBwICsgKC0xLjUgLSAyICogd1ApICogcHAgKyAoLTAuNSArIHdQKSAqIHAgKyAxO1xuXHRcdFx0Y29uc3QgczEgPSAoLTEgLSB3TikgKiBwcHAgKyAoMS41ICsgd04pICogcHAgKyAwLjUgKiBwO1xuXHRcdFx0Y29uc3Qgc04gPSB3TiAqIHBwcCAtIHdOICogcHA7IC8vIGNvbWJpbmUgZGF0YSBsaW5lYXJseVxuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSAhPT0gc3RyaWRlOyArK2kpIHtcblx0XHRcdFx0cmVzdWx0W2ldID0gc1AgKiB2YWx1ZXNbb1AgKyBpXSArIHMwICogdmFsdWVzW28wICsgaV0gKyBzMSAqIHZhbHVlc1tvMSArIGldICsgc04gKiB2YWx1ZXNbb04gKyBpXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIExpbmVhckludGVycG9sYW50IGV4dGVuZHMgSW50ZXJwb2xhbnQge1xuXHRcdGNvbnN0cnVjdG9yKHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIpIHtcblx0XHRcdHN1cGVyKHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIpO1xuXHRcdH1cblxuXHRcdGludGVycG9sYXRlXyhpMSwgdDAsIHQsIHQxKSB7XG5cdFx0XHRjb25zdCByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcblx0XHRcdFx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxuXHRcdFx0XHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cdFx0XHRcdFx0XHRvZmZzZXQxID0gaTEgKiBzdHJpZGUsXG5cdFx0XHRcdFx0XHRvZmZzZXQwID0gb2Zmc2V0MSAtIHN0cmlkZSxcblx0XHRcdFx0XHRcdHdlaWdodDEgPSAodCAtIHQwKSAvICh0MSAtIHQwKSxcblx0XHRcdFx0XHRcdHdlaWdodDAgPSAxIC0gd2VpZ2h0MTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgIT09IHN0cmlkZTsgKytpKSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IHZhbHVlc1tvZmZzZXQwICsgaV0gKiB3ZWlnaHQwICsgdmFsdWVzW29mZnNldDEgKyBpXSAqIHdlaWdodDE7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICogSW50ZXJwb2xhbnQgdGhhdCBldmFsdWF0ZXMgdG8gdGhlIHNhbXBsZSB2YWx1ZSBhdCB0aGUgcG9zaXRpb24gcHJlY2VlZGluZ1xuXHQgKiB0aGUgcGFyYW1ldGVyLlxuXHQgKi9cblxuXHRjbGFzcyBEaXNjcmV0ZUludGVycG9sYW50IGV4dGVuZHMgSW50ZXJwb2xhbnQge1xuXHRcdGNvbnN0cnVjdG9yKHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIpIHtcblx0XHRcdHN1cGVyKHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIpO1xuXHRcdH1cblxuXHRcdGludGVycG9sYXRlXyhpMVxuXHRcdC8qLCB0MCwgdCwgdDEgKi9cblx0XHQpIHtcblx0XHRcdHJldHVybiB0aGlzLmNvcHlTYW1wbGVWYWx1ZV8oaTEgLSAxKTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIEtleWZyYW1lVHJhY2sge1xuXHRcdGNvbnN0cnVjdG9yKG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24pIHtcblx0XHRcdGlmIChuYW1lID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcignVEhSRUUuS2V5ZnJhbWVUcmFjazogdHJhY2sgbmFtZSBpcyB1bmRlZmluZWQnKTtcblx0XHRcdGlmICh0aW1lcyA9PT0gdW5kZWZpbmVkIHx8IHRpbWVzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdUSFJFRS5LZXlmcmFtZVRyYWNrOiBubyBrZXlmcmFtZXMgaW4gdHJhY2sgbmFtZWQgJyArIG5hbWUpO1xuXHRcdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0XHRcdHRoaXMudGltZXMgPSBBbmltYXRpb25VdGlscy5jb252ZXJ0QXJyYXkodGltZXMsIHRoaXMuVGltZUJ1ZmZlclR5cGUpO1xuXHRcdFx0dGhpcy52YWx1ZXMgPSBBbmltYXRpb25VdGlscy5jb252ZXJ0QXJyYXkodmFsdWVzLCB0aGlzLlZhbHVlQnVmZmVyVHlwZSk7XG5cdFx0XHR0aGlzLnNldEludGVycG9sYXRpb24oaW50ZXJwb2xhdGlvbiB8fCB0aGlzLkRlZmF1bHRJbnRlcnBvbGF0aW9uKTtcblx0XHR9IC8vIFNlcmlhbGl6YXRpb24gKGluIHN0YXRpYyBjb250ZXh0LCBiZWNhdXNlIG9mIGNvbnN0cnVjdG9yIGludm9jYXRpb25cblx0XHQvLyBhbmQgYXV0b21hdGljIGludm9jYXRpb24gb2YgLnRvSlNPTik6XG5cblxuXHRcdHN0YXRpYyB0b0pTT04odHJhY2spIHtcblx0XHRcdGNvbnN0IHRyYWNrVHlwZSA9IHRyYWNrLmNvbnN0cnVjdG9yO1xuXHRcdFx0bGV0IGpzb247IC8vIGRlcml2ZWQgY2xhc3NlcyBjYW4gZGVmaW5lIGEgc3RhdGljIHRvSlNPTiBtZXRob2RcblxuXHRcdFx0aWYgKHRyYWNrVHlwZS50b0pTT04gIT09IHRoaXMudG9KU09OKSB7XG5cdFx0XHRcdGpzb24gPSB0cmFja1R5cGUudG9KU09OKHRyYWNrKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGJ5IGRlZmF1bHQsIHdlIGFzc3VtZSB0aGUgZGF0YSBjYW4gYmUgc2VyaWFsaXplZCBhcy1pc1xuXHRcdFx0XHRqc29uID0ge1xuXHRcdFx0XHRcdCduYW1lJzogdHJhY2submFtZSxcblx0XHRcdFx0XHQndGltZXMnOiBBbmltYXRpb25VdGlscy5jb252ZXJ0QXJyYXkodHJhY2sudGltZXMsIEFycmF5KSxcblx0XHRcdFx0XHQndmFsdWVzJzogQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KHRyYWNrLnZhbHVlcywgQXJyYXkpXG5cdFx0XHRcdH07XG5cdFx0XHRcdGNvbnN0IGludGVycG9sYXRpb24gPSB0cmFjay5nZXRJbnRlcnBvbGF0aW9uKCk7XG5cblx0XHRcdFx0aWYgKGludGVycG9sYXRpb24gIT09IHRyYWNrLkRlZmF1bHRJbnRlcnBvbGF0aW9uKSB7XG5cdFx0XHRcdFx0anNvbi5pbnRlcnBvbGF0aW9uID0gaW50ZXJwb2xhdGlvbjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRqc29uLnR5cGUgPSB0cmFjay5WYWx1ZVR5cGVOYW1lOyAvLyBtYW5kYXRvcnlcblxuXHRcdFx0cmV0dXJuIGpzb247XG5cdFx0fVxuXG5cdFx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGUocmVzdWx0KSB7XG5cdFx0XHRyZXR1cm4gbmV3IERpc2NyZXRlSW50ZXJwb2xhbnQodGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCk7XG5cdFx0fVxuXG5cdFx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyKHJlc3VsdCkge1xuXHRcdFx0cmV0dXJuIG5ldyBMaW5lYXJJbnRlcnBvbGFudCh0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0KTtcblx0XHR9XG5cblx0XHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGgocmVzdWx0KSB7XG5cdFx0XHRyZXR1cm4gbmV3IEN1YmljSW50ZXJwb2xhbnQodGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCk7XG5cdFx0fVxuXG5cdFx0c2V0SW50ZXJwb2xhdGlvbihpbnRlcnBvbGF0aW9uKSB7XG5cdFx0XHRsZXQgZmFjdG9yeU1ldGhvZDtcblxuXHRcdFx0c3dpdGNoIChpbnRlcnBvbGF0aW9uKSB7XG5cdFx0XHRcdGNhc2UgSW50ZXJwb2xhdGVEaXNjcmV0ZTpcblx0XHRcdFx0XHRmYWN0b3J5TWV0aG9kID0gdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2REaXNjcmV0ZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIEludGVycG9sYXRlTGluZWFyOlxuXHRcdFx0XHRcdGZhY3RvcnlNZXRob2QgPSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIEludGVycG9sYXRlU21vb3RoOlxuXHRcdFx0XHRcdGZhY3RvcnlNZXRob2QgPSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0aWYgKGZhY3RvcnlNZXRob2QgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb25zdCBtZXNzYWdlID0gJ3Vuc3VwcG9ydGVkIGludGVycG9sYXRpb24gZm9yICcgKyB0aGlzLlZhbHVlVHlwZU5hbWUgKyAnIGtleWZyYW1lIHRyYWNrIG5hbWVkICcgKyB0aGlzLm5hbWU7XG5cblx0XHRcdFx0aWYgKHRoaXMuY3JlYXRlSW50ZXJwb2xhbnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdC8vIGZhbGwgYmFjayB0byBkZWZhdWx0LCB1bmxlc3MgdGhlIGRlZmF1bHQgaXRzZWxmIGlzIG1lc3NlZCB1cFxuXHRcdFx0XHRcdGlmIChpbnRlcnBvbGF0aW9uICE9PSB0aGlzLkRlZmF1bHRJbnRlcnBvbGF0aW9uKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNldEludGVycG9sYXRpb24odGhpcy5EZWZhdWx0SW50ZXJwb2xhdGlvbik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTsgLy8gZmF0YWwsIGluIHRoaXMgY2FzZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuS2V5ZnJhbWVUcmFjazonLCBtZXNzYWdlKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuY3JlYXRlSW50ZXJwb2xhbnQgPSBmYWN0b3J5TWV0aG9kO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Z2V0SW50ZXJwb2xhdGlvbigpIHtcblx0XHRcdHN3aXRjaCAodGhpcy5jcmVhdGVJbnRlcnBvbGFudCkge1xuXHRcdFx0XHRjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGU6XG5cdFx0XHRcdFx0cmV0dXJuIEludGVycG9sYXRlRGlzY3JldGU7XG5cblx0XHRcdFx0Y2FzZSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjpcblx0XHRcdFx0XHRyZXR1cm4gSW50ZXJwb2xhdGVMaW5lYXI7XG5cblx0XHRcdFx0Y2FzZSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDpcblx0XHRcdFx0XHRyZXR1cm4gSW50ZXJwb2xhdGVTbW9vdGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Z2V0VmFsdWVTaXplKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudmFsdWVzLmxlbmd0aCAvIHRoaXMudGltZXMubGVuZ3RoO1xuXHRcdH0gLy8gbW92ZSBhbGwga2V5ZnJhbWVzIGVpdGhlciBmb3J3YXJkcyBvciBiYWNrd2FyZHMgaW4gdGltZVxuXG5cblx0XHRzaGlmdCh0aW1lT2Zmc2V0KSB7XG5cdFx0XHRpZiAodGltZU9mZnNldCAhPT0gMC4wKSB7XG5cdFx0XHRcdGNvbnN0IHRpbWVzID0gdGhpcy50aW1lcztcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbiA9IHRpbWVzLmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRcdFx0dGltZXNbaV0gKz0gdGltZU9mZnNldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9IC8vIHNjYWxlIGFsbCBrZXlmcmFtZSB0aW1lcyBieSBhIGZhY3RvciAodXNlZnVsIGZvciBmcmFtZSA8LT4gc2Vjb25kcyBjb252ZXJzaW9ucylcblxuXG5cdFx0c2NhbGUodGltZVNjYWxlKSB7XG5cdFx0XHRpZiAodGltZVNjYWxlICE9PSAxLjApIHtcblx0XHRcdFx0Y29uc3QgdGltZXMgPSB0aGlzLnRpbWVzO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBuID0gdGltZXMubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdFx0XHR0aW1lc1tpXSAqPSB0aW1lU2NhbGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSAvLyByZW1vdmVzIGtleWZyYW1lcyBiZWZvcmUgYW5kIGFmdGVyIGFuaW1hdGlvbiB3aXRob3V0IGNoYW5naW5nIGFueSB2YWx1ZXMgd2l0aGluIHRoZSByYW5nZSBbc3RhcnRUaW1lLCBlbmRUaW1lXS5cblx0XHQvLyBJTVBPUlRBTlQ6IFdlIGRvIG5vdCBzaGlmdCBhcm91bmQga2V5cyB0byB0aGUgc3RhcnQgb2YgdGhlIHRyYWNrIHRpbWUsIGJlY2F1c2UgZm9yIGludGVycG9sYXRlZCBrZXlzIHRoaXMgd2lsbCBjaGFuZ2UgdGhlaXIgdmFsdWVzXG5cblxuXHRcdHRyaW0oc3RhcnRUaW1lLCBlbmRUaW1lKSB7XG5cdFx0XHRjb25zdCB0aW1lcyA9IHRoaXMudGltZXMsXG5cdFx0XHRcdFx0XHRuS2V5cyA9IHRpbWVzLmxlbmd0aDtcblx0XHRcdGxldCBmcm9tID0gMCxcblx0XHRcdFx0XHR0byA9IG5LZXlzIC0gMTtcblxuXHRcdFx0d2hpbGUgKGZyb20gIT09IG5LZXlzICYmIHRpbWVzW2Zyb21dIDwgc3RhcnRUaW1lKSB7XG5cdFx0XHRcdCsrZnJvbTtcblx0XHRcdH1cblxuXHRcdFx0d2hpbGUgKHRvICE9PSAtMSAmJiB0aW1lc1t0b10gPiBlbmRUaW1lKSB7XG5cdFx0XHRcdC0tdG87XG5cdFx0XHR9XG5cblx0XHRcdCsrdG87IC8vIGluY2x1c2l2ZSAtPiBleGNsdXNpdmUgYm91bmRcblxuXHRcdFx0aWYgKGZyb20gIT09IDAgfHwgdG8gIT09IG5LZXlzKSB7XG5cdFx0XHRcdC8vIGVtcHR5IHRyYWNrcyBhcmUgZm9yYmlkZGVuLCBzbyBrZWVwIGF0IGxlYXN0IG9uZSBrZXlmcmFtZVxuXHRcdFx0XHRpZiAoZnJvbSA+PSB0bykge1xuXHRcdFx0XHRcdHRvID0gTWF0aC5tYXgodG8sIDEpO1xuXHRcdFx0XHRcdGZyb20gPSB0byAtIDE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBzdHJpZGUgPSB0aGlzLmdldFZhbHVlU2l6ZSgpO1xuXHRcdFx0XHR0aGlzLnRpbWVzID0gQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSh0aW1lcywgZnJvbSwgdG8pO1xuXHRcdFx0XHR0aGlzLnZhbHVlcyA9IEFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UodGhpcy52YWx1ZXMsIGZyb20gKiBzdHJpZGUsIHRvICogc3RyaWRlKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSAvLyBlbnN1cmUgd2UgZG8gbm90IGdldCBhIEdhcmJhZ2VJbkdhcmJhZ2VPdXQgc2l0dWF0aW9uLCBtYWtlIHN1cmUgdHJhY2tzIGFyZSBhdCBsZWFzdCBtaW5pbWFsbHkgdmlhYmxlXG5cblxuXHRcdHZhbGlkYXRlKCkge1xuXHRcdFx0bGV0IHZhbGlkID0gdHJ1ZTtcblx0XHRcdGNvbnN0IHZhbHVlU2l6ZSA9IHRoaXMuZ2V0VmFsdWVTaXplKCk7XG5cblx0XHRcdGlmICh2YWx1ZVNpemUgLSBNYXRoLmZsb29yKHZhbHVlU2l6ZSkgIT09IDApIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuS2V5ZnJhbWVUcmFjazogSW52YWxpZCB2YWx1ZSBzaXplIGluIHRyYWNrLicsIHRoaXMpO1xuXHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0aW1lcyA9IHRoaXMudGltZXMsXG5cdFx0XHRcdFx0XHR2YWx1ZXMgPSB0aGlzLnZhbHVlcyxcblx0XHRcdFx0XHRcdG5LZXlzID0gdGltZXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAobktleXMgPT09IDApIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuS2V5ZnJhbWVUcmFjazogVHJhY2sgaXMgZW1wdHkuJywgdGhpcyk7XG5cdFx0XHRcdHZhbGlkID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBwcmV2VGltZSA9IG51bGw7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpICE9PSBuS2V5czsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGN1cnJUaW1lID0gdGltZXNbaV07XG5cblx0XHRcdFx0aWYgKHR5cGVvZiBjdXJyVGltZSA9PT0gJ251bWJlcicgJiYgaXNOYU4oY3VyclRpbWUpKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuS2V5ZnJhbWVUcmFjazogVGltZSBpcyBub3QgYSB2YWxpZCBudW1iZXIuJywgdGhpcywgaSwgY3VyclRpbWUpO1xuXHRcdFx0XHRcdHZhbGlkID0gZmFsc2U7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAocHJldlRpbWUgIT09IG51bGwgJiYgcHJldlRpbWUgPiBjdXJyVGltZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLktleWZyYW1lVHJhY2s6IE91dCBvZiBvcmRlciBrZXlzLicsIHRoaXMsIGksIGN1cnJUaW1lLCBwcmV2VGltZSk7XG5cdFx0XHRcdFx0dmFsaWQgPSBmYWxzZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHByZXZUaW1lID0gY3VyclRpbWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAoQW5pbWF0aW9uVXRpbHMuaXNUeXBlZEFycmF5KHZhbHVlcykpIHtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbiA9IHZhbHVlcy5sZW5ndGg7IGkgIT09IG47ICsraSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG5cblx0XHRcdFx0XHRcdGlmIChpc05hTih2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuS2V5ZnJhbWVUcmFjazogVmFsdWUgaXMgbm90IGEgdmFsaWQgbnVtYmVyLicsIHRoaXMsIGksIHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0dmFsaWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWxpZDtcblx0XHR9IC8vIHJlbW92ZXMgZXF1aXZhbGVudCBzZXF1ZW50aWFsIGtleXMgYXMgY29tbW9uIGluIG1vcnBoIHRhcmdldCBzZXF1ZW5jZXNcblx0XHQvLyAoMCwwLDAsMCwxLDEsMSwwLDAsMCwwLDAsMCwwKSAtLT4gKDAsMCwxLDEsMCwwKVxuXG5cblx0XHRvcHRpbWl6ZSgpIHtcblx0XHRcdC8vIHRpbWVzIG9yIHZhbHVlcyBtYXkgYmUgc2hhcmVkIHdpdGggb3RoZXIgdHJhY2tzLCBzbyBvdmVyd3JpdGluZyBpcyB1bnNhZmVcblx0XHRcdGNvbnN0IHRpbWVzID0gQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSh0aGlzLnRpbWVzKSxcblx0XHRcdFx0XHRcdHZhbHVlcyA9IEFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UodGhpcy52YWx1ZXMpLFxuXHRcdFx0XHRcdFx0c3RyaWRlID0gdGhpcy5nZXRWYWx1ZVNpemUoKSxcblx0XHRcdFx0XHRcdHNtb290aEludGVycG9sYXRpb24gPSB0aGlzLmdldEludGVycG9sYXRpb24oKSA9PT0gSW50ZXJwb2xhdGVTbW9vdGgsXG5cdFx0XHRcdFx0XHRsYXN0SW5kZXggPSB0aW1lcy5sZW5ndGggLSAxO1xuXHRcdFx0bGV0IHdyaXRlSW5kZXggPSAxO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IGxhc3RJbmRleDsgKytpKSB7XG5cdFx0XHRcdGxldCBrZWVwID0gZmFsc2U7XG5cdFx0XHRcdGNvbnN0IHRpbWUgPSB0aW1lc1tpXTtcblx0XHRcdFx0Y29uc3QgdGltZU5leHQgPSB0aW1lc1tpICsgMV07IC8vIHJlbW92ZSBhZGphY2VudCBrZXlmcmFtZXMgc2NoZWR1bGVkIGF0IHRoZSBzYW1lIHRpbWVcblxuXHRcdFx0XHRpZiAodGltZSAhPT0gdGltZU5leHQgJiYgKGkgIT09IDEgfHwgdGltZSAhPT0gdGltZXNbMF0pKSB7XG5cdFx0XHRcdFx0aWYgKCFzbW9vdGhJbnRlcnBvbGF0aW9uKSB7XG5cdFx0XHRcdFx0XHQvLyByZW1vdmUgdW5uZWNlc3Nhcnkga2V5ZnJhbWVzIHNhbWUgYXMgdGhlaXIgbmVpZ2hib3JzXG5cdFx0XHRcdFx0XHRjb25zdCBvZmZzZXQgPSBpICogc3RyaWRlLFxuXHRcdFx0XHRcdFx0XHRcdFx0b2Zmc2V0UCA9IG9mZnNldCAtIHN0cmlkZSxcblx0XHRcdFx0XHRcdFx0XHRcdG9mZnNldE4gPSBvZmZzZXQgKyBzdHJpZGU7XG5cblx0XHRcdFx0XHRcdGZvciAobGV0IGogPSAwOyBqICE9PSBzdHJpZGU7ICsraikge1xuXHRcdFx0XHRcdFx0XHRjb25zdCB2YWx1ZSA9IHZhbHVlc1tvZmZzZXQgKyBqXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgIT09IHZhbHVlc1tvZmZzZXRQICsgal0gfHwgdmFsdWUgIT09IHZhbHVlc1tvZmZzZXROICsgal0pIHtcblx0XHRcdFx0XHRcdFx0XHRrZWVwID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRrZWVwID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gLy8gaW4tcGxhY2UgY29tcGFjdGlvblxuXG5cblx0XHRcdFx0aWYgKGtlZXApIHtcblx0XHRcdFx0XHRpZiAoaSAhPT0gd3JpdGVJbmRleCkge1xuXHRcdFx0XHRcdFx0dGltZXNbd3JpdGVJbmRleF0gPSB0aW1lc1tpXTtcblx0XHRcdFx0XHRcdGNvbnN0IHJlYWRPZmZzZXQgPSBpICogc3RyaWRlLFxuXHRcdFx0XHRcdFx0XHRcdFx0d3JpdGVPZmZzZXQgPSB3cml0ZUluZGV4ICogc3RyaWRlO1xuXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiAhPT0gc3RyaWRlOyArK2opIHtcblx0XHRcdFx0XHRcdFx0dmFsdWVzW3dyaXRlT2Zmc2V0ICsgal0gPSB2YWx1ZXNbcmVhZE9mZnNldCArIGpdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCsrd3JpdGVJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fSAvLyBmbHVzaCBsYXN0IGtleWZyYW1lIChjb21wYWN0aW9uIGxvb2tzIGFoZWFkKVxuXG5cblx0XHRcdGlmIChsYXN0SW5kZXggPiAwKSB7XG5cdFx0XHRcdHRpbWVzW3dyaXRlSW5kZXhdID0gdGltZXNbbGFzdEluZGV4XTtcblxuXHRcdFx0XHRmb3IgKGxldCByZWFkT2Zmc2V0ID0gbGFzdEluZGV4ICogc3RyaWRlLCB3cml0ZU9mZnNldCA9IHdyaXRlSW5kZXggKiBzdHJpZGUsIGogPSAwOyBqICE9PSBzdHJpZGU7ICsraikge1xuXHRcdFx0XHRcdHZhbHVlc1t3cml0ZU9mZnNldCArIGpdID0gdmFsdWVzW3JlYWRPZmZzZXQgKyBqXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdCsrd3JpdGVJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHdyaXRlSW5kZXggIT09IHRpbWVzLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLnRpbWVzID0gQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSh0aW1lcywgMCwgd3JpdGVJbmRleCk7XG5cdFx0XHRcdHRoaXMudmFsdWVzID0gQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSh2YWx1ZXMsIDAsIHdyaXRlSW5kZXggKiBzdHJpZGUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy50aW1lcyA9IHRpbWVzO1xuXHRcdFx0XHR0aGlzLnZhbHVlcyA9IHZhbHVlcztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y2xvbmUoKSB7XG5cdFx0XHRjb25zdCB0aW1lcyA9IEFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UodGhpcy50aW1lcywgMCk7XG5cdFx0XHRjb25zdCB2YWx1ZXMgPSBBbmltYXRpb25VdGlscy5hcnJheVNsaWNlKHRoaXMudmFsdWVzLCAwKTtcblx0XHRcdGNvbnN0IFR5cGVkS2V5ZnJhbWVUcmFjayA9IHRoaXMuY29uc3RydWN0b3I7XG5cdFx0XHRjb25zdCB0cmFjayA9IG5ldyBUeXBlZEtleWZyYW1lVHJhY2sodGhpcy5uYW1lLCB0aW1lcywgdmFsdWVzKTsgLy8gSW50ZXJwb2xhbnQgYXJndW1lbnQgdG8gY29uc3RydWN0b3IgaXMgbm90IHNhdmVkLCBzbyBjb3B5IHRoZSBmYWN0b3J5IG1ldGhvZCBkaXJlY3RseS5cblxuXHRcdFx0dHJhY2suY3JlYXRlSW50ZXJwb2xhbnQgPSB0aGlzLmNyZWF0ZUludGVycG9sYW50O1xuXHRcdFx0cmV0dXJuIHRyYWNrO1xuXHRcdH1cblxuXHR9XG5cblx0S2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVGltZUJ1ZmZlclR5cGUgPSBGbG9hdDMyQXJyYXk7XG5cdEtleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlQnVmZmVyVHlwZSA9IEZsb2F0MzJBcnJheTtcblx0S2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuRGVmYXVsdEludGVycG9sYXRpb24gPSBJbnRlcnBvbGF0ZUxpbmVhcjtcblxuXHQvKipcblx0ICogQSBUcmFjayBvZiBCb29sZWFuIGtleWZyYW1lIHZhbHVlcy5cblx0ICovXG5cblx0Y2xhc3MgQm9vbGVhbktleWZyYW1lVHJhY2sgZXh0ZW5kcyBLZXlmcmFtZVRyYWNrIHt9XG5cblx0Qm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlVHlwZU5hbWUgPSAnYm9vbCc7XG5cdEJvb2xlYW5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5WYWx1ZUJ1ZmZlclR5cGUgPSBBcnJheTtcblx0Qm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlLkRlZmF1bHRJbnRlcnBvbGF0aW9uID0gSW50ZXJwb2xhdGVEaXNjcmV0ZTtcblx0Qm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhciA9IHVuZGVmaW5lZDtcblx0Qm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlLkludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aCA9IHVuZGVmaW5lZDsgLy8gTm90ZTogQWN0dWFsbHkgdGhpcyB0cmFjayBjb3VsZCBoYXZlIGEgb3B0aW1pemVkIC8gY29tcHJlc3NlZFxuXG5cdC8qKlxuXHQgKiBBIFRyYWNrIG9mIGtleWZyYW1lIHZhbHVlcyB0aGF0IHJlcHJlc2VudCBjb2xvci5cblx0ICovXG5cblx0Y2xhc3MgQ29sb3JLZXlmcmFtZVRyYWNrIGV4dGVuZHMgS2V5ZnJhbWVUcmFjayB7fVxuXG5cdENvbG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZSA9ICdjb2xvcic7IC8vIFZhbHVlQnVmZmVyVHlwZSBpcyBpbmhlcml0ZWRcblxuXHQvKipcblx0ICogQSBUcmFjayBvZiBudW1lcmljIGtleWZyYW1lIHZhbHVlcy5cblx0ICovXG5cblx0Y2xhc3MgTnVtYmVyS2V5ZnJhbWVUcmFjayBleHRlbmRzIEtleWZyYW1lVHJhY2sge31cblxuXHROdW1iZXJLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5WYWx1ZVR5cGVOYW1lID0gJ251bWJlcic7IC8vIFZhbHVlQnVmZmVyVHlwZSBpcyBpbmhlcml0ZWRcblxuXHQvKipcblx0ICogU3BoZXJpY2FsIGxpbmVhciB1bml0IHF1YXRlcm5pb24gaW50ZXJwb2xhbnQuXG5cdCAqL1xuXG5cdGNsYXNzIFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudCBleHRlbmRzIEludGVycG9sYW50IHtcblx0XHRjb25zdHJ1Y3RvcihwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyKSB7XG5cdFx0XHRzdXBlcihwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyKTtcblx0XHR9XG5cblx0XHRpbnRlcnBvbGF0ZV8oaTEsIHQwLCB0LCB0MSkge1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXG5cdFx0XHRcdFx0XHR2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcblx0XHRcdFx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXHRcdFx0XHRcdFx0YWxwaGEgPSAodCAtIHQwKSAvICh0MSAtIHQwKTtcblx0XHRcdGxldCBvZmZzZXQgPSBpMSAqIHN0cmlkZTtcblxuXHRcdFx0Zm9yIChsZXQgZW5kID0gb2Zmc2V0ICsgc3RyaWRlOyBvZmZzZXQgIT09IGVuZDsgb2Zmc2V0ICs9IDQpIHtcblx0XHRcdFx0UXVhdGVybmlvbi5zbGVycEZsYXQocmVzdWx0LCAwLCB2YWx1ZXMsIG9mZnNldCAtIHN0cmlkZSwgdmFsdWVzLCBvZmZzZXQsIGFscGhhKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBIFRyYWNrIG9mIHF1YXRlcm5pb24ga2V5ZnJhbWUgdmFsdWVzLlxuXHQgKi9cblxuXHRjbGFzcyBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayBleHRlbmRzIEtleWZyYW1lVHJhY2sge1xuXHRcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcihyZXN1bHQpIHtcblx0XHRcdHJldHVybiBuZXcgUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50KHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpLCByZXN1bHQpO1xuXHRcdH1cblxuXHR9XG5cblx0UXVhdGVybmlvbktleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlVHlwZU5hbWUgPSAncXVhdGVybmlvbic7IC8vIFZhbHVlQnVmZmVyVHlwZSBpcyBpbmhlcml0ZWRcblxuXHRRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuRGVmYXVsdEludGVycG9sYXRpb24gPSBJbnRlcnBvbGF0ZUxpbmVhcjtcblx0UXVhdGVybmlvbktleWZyYW1lVHJhY2sucHJvdG90eXBlLkludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aCA9IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogQSBUcmFjayB0aGF0IGludGVycG9sYXRlcyBTdHJpbmdzXG5cdCAqL1xuXG5cdGNsYXNzIFN0cmluZ0tleWZyYW1lVHJhY2sgZXh0ZW5kcyBLZXlmcmFtZVRyYWNrIHt9XG5cblx0U3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZSA9ICdzdHJpbmcnO1xuXHRTdHJpbmdLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5WYWx1ZUJ1ZmZlclR5cGUgPSBBcnJheTtcblx0U3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuRGVmYXVsdEludGVycG9sYXRpb24gPSBJbnRlcnBvbGF0ZURpc2NyZXRlO1xuXHRTdHJpbmdLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXIgPSB1bmRlZmluZWQ7XG5cdFN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlLkludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aCA9IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogQSBUcmFjayBvZiB2ZWN0b3JlZCBrZXlmcmFtZSB2YWx1ZXMuXG5cdCAqL1xuXG5cdGNsYXNzIFZlY3RvcktleWZyYW1lVHJhY2sgZXh0ZW5kcyBLZXlmcmFtZVRyYWNrIHt9XG5cblx0VmVjdG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZSA9ICd2ZWN0b3InOyAvLyBWYWx1ZUJ1ZmZlclR5cGUgaXMgaW5oZXJpdGVkXG5cblx0Y2xhc3MgQW5pbWF0aW9uQ2xpcCB7XG5cdFx0Y29uc3RydWN0b3IobmFtZSwgZHVyYXRpb24gPSAtMSwgdHJhY2tzLCBibGVuZE1vZGUgPSBOb3JtYWxBbmltYXRpb25CbGVuZE1vZGUpIHtcblx0XHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cdFx0XHR0aGlzLnRyYWNrcyA9IHRyYWNrcztcblx0XHRcdHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcblx0XHRcdHRoaXMuYmxlbmRNb2RlID0gYmxlbmRNb2RlO1xuXHRcdFx0dGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7IC8vIHRoaXMgbWVhbnMgaXQgc2hvdWxkIGZpZ3VyZSBvdXQgaXRzIGR1cmF0aW9uIGJ5IHNjYW5uaW5nIHRoZSB0cmFja3NcblxuXHRcdFx0aWYgKHRoaXMuZHVyYXRpb24gPCAwKSB7XG5cdFx0XHRcdHRoaXMucmVzZXREdXJhdGlvbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHN0YXRpYyBwYXJzZShqc29uKSB7XG5cdFx0XHRjb25zdCB0cmFja3MgPSBbXSxcblx0XHRcdFx0XHRcdGpzb25UcmFja3MgPSBqc29uLnRyYWNrcyxcblx0XHRcdFx0XHRcdGZyYW1lVGltZSA9IDEuMCAvIChqc29uLmZwcyB8fCAxLjApO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbiA9IGpzb25UcmFja3MubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdFx0dHJhY2tzLnB1c2gocGFyc2VLZXlmcmFtZVRyYWNrKGpzb25UcmFja3NbaV0pLnNjYWxlKGZyYW1lVGltZSkpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBjbGlwID0gbmV3IHRoaXMoanNvbi5uYW1lLCBqc29uLmR1cmF0aW9uLCB0cmFja3MsIGpzb24uYmxlbmRNb2RlKTtcblx0XHRcdGNsaXAudXVpZCA9IGpzb24udXVpZDtcblx0XHRcdHJldHVybiBjbGlwO1xuXHRcdH1cblxuXHRcdHN0YXRpYyB0b0pTT04oY2xpcCkge1xuXHRcdFx0Y29uc3QgdHJhY2tzID0gW10sXG5cdFx0XHRcdFx0XHRjbGlwVHJhY2tzID0gY2xpcC50cmFja3M7XG5cdFx0XHRjb25zdCBqc29uID0ge1xuXHRcdFx0XHQnbmFtZSc6IGNsaXAubmFtZSxcblx0XHRcdFx0J2R1cmF0aW9uJzogY2xpcC5kdXJhdGlvbixcblx0XHRcdFx0J3RyYWNrcyc6IHRyYWNrcyxcblx0XHRcdFx0J3V1aWQnOiBjbGlwLnV1aWQsXG5cdFx0XHRcdCdibGVuZE1vZGUnOiBjbGlwLmJsZW5kTW9kZVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBjbGlwVHJhY2tzLmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRcdHRyYWNrcy5wdXNoKEtleWZyYW1lVHJhY2sudG9KU09OKGNsaXBUcmFja3NbaV0pKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGpzb247XG5cdFx0fVxuXG5cdFx0c3RhdGljIENyZWF0ZUZyb21Nb3JwaFRhcmdldFNlcXVlbmNlKG5hbWUsIG1vcnBoVGFyZ2V0U2VxdWVuY2UsIGZwcywgbm9Mb29wKSB7XG5cdFx0XHRjb25zdCBudW1Nb3JwaFRhcmdldHMgPSBtb3JwaFRhcmdldFNlcXVlbmNlLmxlbmd0aDtcblx0XHRcdGNvbnN0IHRyYWNrcyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG51bU1vcnBoVGFyZ2V0czsgaSsrKSB7XG5cdFx0XHRcdGxldCB0aW1lcyA9IFtdO1xuXHRcdFx0XHRsZXQgdmFsdWVzID0gW107XG5cdFx0XHRcdHRpbWVzLnB1c2goKGkgKyBudW1Nb3JwaFRhcmdldHMgLSAxKSAlIG51bU1vcnBoVGFyZ2V0cywgaSwgKGkgKyAxKSAlIG51bU1vcnBoVGFyZ2V0cyk7XG5cdFx0XHRcdHZhbHVlcy5wdXNoKDAsIDEsIDApO1xuXHRcdFx0XHRjb25zdCBvcmRlciA9IEFuaW1hdGlvblV0aWxzLmdldEtleWZyYW1lT3JkZXIodGltZXMpO1xuXHRcdFx0XHR0aW1lcyA9IEFuaW1hdGlvblV0aWxzLnNvcnRlZEFycmF5KHRpbWVzLCAxLCBvcmRlcik7XG5cdFx0XHRcdHZhbHVlcyA9IEFuaW1hdGlvblV0aWxzLnNvcnRlZEFycmF5KHZhbHVlcywgMSwgb3JkZXIpOyAvLyBpZiB0aGVyZSBpcyBhIGtleSBhdCB0aGUgZmlyc3QgZnJhbWUsIGR1cGxpY2F0ZSBpdCBhcyB0aGVcblx0XHRcdFx0Ly8gbGFzdCBmcmFtZSBhcyB3ZWxsIGZvciBwZXJmZWN0IGxvb3AuXG5cblx0XHRcdFx0aWYgKCFub0xvb3AgJiYgdGltZXNbMF0gPT09IDApIHtcblx0XHRcdFx0XHR0aW1lcy5wdXNoKG51bU1vcnBoVGFyZ2V0cyk7XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2godmFsdWVzWzBdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyYWNrcy5wdXNoKG5ldyBOdW1iZXJLZXlmcmFtZVRyYWNrKCcubW9ycGhUYXJnZXRJbmZsdWVuY2VzWycgKyBtb3JwaFRhcmdldFNlcXVlbmNlW2ldLm5hbWUgKyAnXScsIHRpbWVzLCB2YWx1ZXMpLnNjYWxlKDEuMCAvIGZwcykpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMobmFtZSwgLTEsIHRyYWNrcyk7XG5cdFx0fVxuXG5cdFx0c3RhdGljIGZpbmRCeU5hbWUob2JqZWN0T3JDbGlwQXJyYXksIG5hbWUpIHtcblx0XHRcdGxldCBjbGlwQXJyYXkgPSBvYmplY3RPckNsaXBBcnJheTtcblxuXHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KG9iamVjdE9yQ2xpcEFycmF5KSkge1xuXHRcdFx0XHRjb25zdCBvID0gb2JqZWN0T3JDbGlwQXJyYXk7XG5cdFx0XHRcdGNsaXBBcnJheSA9IG8uZ2VvbWV0cnkgJiYgby5nZW9tZXRyeS5hbmltYXRpb25zIHx8IG8uYW5pbWF0aW9ucztcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjbGlwQXJyYXkubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGNsaXBBcnJheVtpXS5uYW1lID09PSBuYW1lKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNsaXBBcnJheVtpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRzdGF0aWMgQ3JlYXRlQ2xpcHNGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZXMobW9ycGhUYXJnZXRzLCBmcHMsIG5vTG9vcCkge1xuXHRcdFx0Y29uc3QgYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHMgPSB7fTsgLy8gdGVzdGVkIHdpdGggaHR0cHM6Ly9yZWdleDEwMS5jb20vIG9uIHRyaWNrIHNlcXVlbmNlc1xuXHRcdFx0Ly8gc3VjaCBmbGFtaW5nb19mbHlBXzAwMywgZmxhbWluZ29fcnVuMV8wMDMsIGNyZGVhdGgwMDU5XG5cblx0XHRcdGNvbnN0IHBhdHRlcm4gPSAvXihbXFx3LV0qPykoW1xcZF0rKSQvOyAvLyBzb3J0IG1vcnBoIHRhcmdldCBuYW1lcyBpbnRvIGFuaW1hdGlvbiBncm91cHMgYmFzZWRcblx0XHRcdC8vIHBhdHRlcm5zIGxpa2UgV2Fsa18wMDEsIFdhbGtfMDAyLCBSdW5fMDAxLCBSdW5fMDAyXG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzW2ldO1xuXHRcdFx0XHRjb25zdCBwYXJ0cyA9IG1vcnBoVGFyZ2V0Lm5hbWUubWF0Y2gocGF0dGVybik7XG5cblx0XHRcdFx0aWYgKHBhcnRzICYmIHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRjb25zdCBuYW1lID0gcGFydHNbMV07XG5cdFx0XHRcdFx0bGV0IGFuaW1hdGlvbk1vcnBoVGFyZ2V0cyA9IGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzW25hbWVdO1xuXG5cdFx0XHRcdFx0aWYgKCFhbmltYXRpb25Nb3JwaFRhcmdldHMpIHtcblx0XHRcdFx0XHRcdGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzW25hbWVdID0gYW5pbWF0aW9uTW9ycGhUYXJnZXRzID0gW107XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YW5pbWF0aW9uTW9ycGhUYXJnZXRzLnB1c2gobW9ycGhUYXJnZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGNsaXBzID0gW107XG5cblx0XHRcdGZvciAoY29uc3QgbmFtZSBpbiBhbmltYXRpb25Ub01vcnBoVGFyZ2V0cykge1xuXHRcdFx0XHRjbGlwcy5wdXNoKHRoaXMuQ3JlYXRlRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2UobmFtZSwgYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHNbbmFtZV0sIGZwcywgbm9Mb29wKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjbGlwcztcblx0XHR9IC8vIHBhcnNlIHRoZSBhbmltYXRpb24uaGllcmFyY2h5IGZvcm1hdFxuXG5cblx0XHRzdGF0aWMgcGFyc2VBbmltYXRpb24oYW5pbWF0aW9uLCBib25lcykge1xuXHRcdFx0aWYgKCFhbmltYXRpb24pIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuQW5pbWF0aW9uQ2xpcDogTm8gYW5pbWF0aW9uIGluIEpTT05Mb2FkZXIgZGF0YS4nKTtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGFkZE5vbmVtcHR5VHJhY2sgPSBmdW5jdGlvbiAodHJhY2tUeXBlLCB0cmFja05hbWUsIGFuaW1hdGlvbktleXMsIHByb3BlcnR5TmFtZSwgZGVzdFRyYWNrcykge1xuXHRcdFx0XHQvLyBvbmx5IHJldHVybiB0cmFjayBpZiB0aGVyZSBhcmUgYWN0dWFsbHkga2V5cy5cblx0XHRcdFx0aWYgKGFuaW1hdGlvbktleXMubGVuZ3RoICE9PSAwKSB7XG5cdFx0XHRcdFx0Y29uc3QgdGltZXMgPSBbXTtcblx0XHRcdFx0XHRjb25zdCB2YWx1ZXMgPSBbXTtcblx0XHRcdFx0XHRBbmltYXRpb25VdGlscy5mbGF0dGVuSlNPTihhbmltYXRpb25LZXlzLCB0aW1lcywgdmFsdWVzLCBwcm9wZXJ0eU5hbWUpOyAvLyBlbXB0eSBrZXlzIGFyZSBmaWx0ZXJlZCBvdXQsIHNvIGNoZWNrIGFnYWluXG5cblx0XHRcdFx0XHRpZiAodGltZXMubGVuZ3RoICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRkZXN0VHJhY2tzLnB1c2gobmV3IHRyYWNrVHlwZSh0cmFja05hbWUsIHRpbWVzLCB2YWx1ZXMpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdGNvbnN0IHRyYWNrcyA9IFtdO1xuXHRcdFx0Y29uc3QgY2xpcE5hbWUgPSBhbmltYXRpb24ubmFtZSB8fCAnZGVmYXVsdCc7XG5cdFx0XHRjb25zdCBmcHMgPSBhbmltYXRpb24uZnBzIHx8IDMwO1xuXHRcdFx0Y29uc3QgYmxlbmRNb2RlID0gYW5pbWF0aW9uLmJsZW5kTW9kZTsgLy8gYXV0b21hdGljIGxlbmd0aCBkZXRlcm1pbmF0aW9uIGluIEFuaW1hdGlvbkNsaXAuXG5cblx0XHRcdGxldCBkdXJhdGlvbiA9IGFuaW1hdGlvbi5sZW5ndGggfHwgLTE7XG5cdFx0XHRjb25zdCBoaWVyYXJjaHlUcmFja3MgPSBhbmltYXRpb24uaGllcmFyY2h5IHx8IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBoID0gMDsgaCA8IGhpZXJhcmNoeVRyYWNrcy5sZW5ndGg7IGgrKykge1xuXHRcdFx0XHRjb25zdCBhbmltYXRpb25LZXlzID0gaGllcmFyY2h5VHJhY2tzW2hdLmtleXM7IC8vIHNraXAgZW1wdHkgdHJhY2tzXG5cblx0XHRcdFx0aWYgKCFhbmltYXRpb25LZXlzIHx8IGFuaW1hdGlvbktleXMubGVuZ3RoID09PSAwKSBjb250aW51ZTsgLy8gcHJvY2VzcyBtb3JwaCB0YXJnZXRzXG5cblx0XHRcdFx0aWYgKGFuaW1hdGlvbktleXNbMF0ubW9ycGhUYXJnZXRzKSB7XG5cdFx0XHRcdFx0Ly8gZmlndXJlIG91dCBhbGwgbW9ycGggdGFyZ2V0cyB1c2VkIGluIHRoaXMgdHJhY2tcblx0XHRcdFx0XHRjb25zdCBtb3JwaFRhcmdldE5hbWVzID0ge307XG5cdFx0XHRcdFx0bGV0IGs7XG5cblx0XHRcdFx0XHRmb3IgKGsgPSAwOyBrIDwgYW5pbWF0aW9uS2V5cy5sZW5ndGg7IGsrKykge1xuXHRcdFx0XHRcdFx0aWYgKGFuaW1hdGlvbktleXNba10ubW9ycGhUYXJnZXRzKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAobGV0IG0gPSAwOyBtIDwgYW5pbWF0aW9uS2V5c1trXS5tb3JwaFRhcmdldHMubGVuZ3RoOyBtKyspIHtcblx0XHRcdFx0XHRcdFx0XHRtb3JwaFRhcmdldE5hbWVzW2FuaW1hdGlvbktleXNba10ubW9ycGhUYXJnZXRzW21dXSA9IC0xO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSAvLyBjcmVhdGUgYSB0cmFjayBmb3IgZWFjaCBtb3JwaCB0YXJnZXQgd2l0aCBhbGwgemVyb1xuXHRcdFx0XHRcdC8vIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBleGNlcHQgZm9yIHRoZSBrZXlzIGluIHdoaWNoXG5cdFx0XHRcdFx0Ly8gdGhlIG1vcnBoVGFyZ2V0IGlzIG5hbWVkLlxuXG5cblx0XHRcdFx0XHRmb3IgKGNvbnN0IG1vcnBoVGFyZ2V0TmFtZSBpbiBtb3JwaFRhcmdldE5hbWVzKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB0aW1lcyA9IFtdO1xuXHRcdFx0XHRcdFx0Y29uc3QgdmFsdWVzID0gW107XG5cblx0XHRcdFx0XHRcdGZvciAobGV0IG0gPSAwOyBtICE9PSBhbmltYXRpb25LZXlzW2tdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7ICsrbSkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBhbmltYXRpb25LZXkgPSBhbmltYXRpb25LZXlzW2tdO1xuXHRcdFx0XHRcdFx0XHR0aW1lcy5wdXNoKGFuaW1hdGlvbktleS50aW1lKTtcblx0XHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goYW5pbWF0aW9uS2V5Lm1vcnBoVGFyZ2V0ID09PSBtb3JwaFRhcmdldE5hbWUgPyAxIDogMCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRyYWNrcy5wdXNoKG5ldyBOdW1iZXJLZXlmcmFtZVRyYWNrKCcubW9ycGhUYXJnZXRJbmZsdWVuY2VbJyArIG1vcnBoVGFyZ2V0TmFtZSArICddJywgdGltZXMsIHZhbHVlcykpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGR1cmF0aW9uID0gbW9ycGhUYXJnZXROYW1lcy5sZW5ndGggKiAoZnBzIHx8IDEuMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gLi4uYXNzdW1lIHNrZWxldGFsIGFuaW1hdGlvblxuXHRcdFx0XHRcdGNvbnN0IGJvbmVOYW1lID0gJy5ib25lc1snICsgYm9uZXNbaF0ubmFtZSArICddJztcblx0XHRcdFx0XHRhZGROb25lbXB0eVRyYWNrKFZlY3RvcktleWZyYW1lVHJhY2ssIGJvbmVOYW1lICsgJy5wb3NpdGlvbicsIGFuaW1hdGlvbktleXMsICdwb3MnLCB0cmFja3MpO1xuXHRcdFx0XHRcdGFkZE5vbmVtcHR5VHJhY2soUXVhdGVybmlvbktleWZyYW1lVHJhY2ssIGJvbmVOYW1lICsgJy5xdWF0ZXJuaW9uJywgYW5pbWF0aW9uS2V5cywgJ3JvdCcsIHRyYWNrcyk7XG5cdFx0XHRcdFx0YWRkTm9uZW1wdHlUcmFjayhWZWN0b3JLZXlmcmFtZVRyYWNrLCBib25lTmFtZSArICcuc2NhbGUnLCBhbmltYXRpb25LZXlzLCAnc2NsJywgdHJhY2tzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHJhY2tzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgY2xpcCA9IG5ldyB0aGlzKGNsaXBOYW1lLCBkdXJhdGlvbiwgdHJhY2tzLCBibGVuZE1vZGUpO1xuXHRcdFx0cmV0dXJuIGNsaXA7XG5cdFx0fVxuXG5cdFx0cmVzZXREdXJhdGlvbigpIHtcblx0XHRcdGNvbnN0IHRyYWNrcyA9IHRoaXMudHJhY2tzO1xuXHRcdFx0bGV0IGR1cmF0aW9uID0gMDtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSB0cmFja3MubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdFx0Y29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrc1tpXTtcblx0XHRcdFx0ZHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgdHJhY2sudGltZXNbdHJhY2sudGltZXMubGVuZ3RoIC0gMV0pO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0cmltKCkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLnRyYWNrc1tpXS50cmltKDAsIHRoaXMuZHVyYXRpb24pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR2YWxpZGF0ZSgpIHtcblx0XHRcdGxldCB2YWxpZCA9IHRydWU7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50cmFja3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFsaWQgPSB2YWxpZCAmJiB0aGlzLnRyYWNrc1tpXS52YWxpZGF0ZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsaWQ7XG5cdFx0fVxuXG5cdFx0b3B0aW1pemUoKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMudHJhY2tzW2ldLm9wdGltaXplKCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNsb25lKCkge1xuXHRcdFx0Y29uc3QgdHJhY2tzID0gW107XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50cmFja3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dHJhY2tzLnB1c2godGhpcy50cmFja3NbaV0uY2xvbmUoKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLm5hbWUsIHRoaXMuZHVyYXRpb24sIHRyYWNrcywgdGhpcy5ibGVuZE1vZGUpO1xuXHRcdH1cblxuXHRcdHRvSlNPTigpIHtcblx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvSlNPTih0aGlzKTtcblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldFRyYWNrVHlwZUZvclZhbHVlVHlwZU5hbWUodHlwZU5hbWUpIHtcblx0XHRzd2l0Y2ggKHR5cGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcblx0XHRcdGNhc2UgJ3NjYWxhcic6XG5cdFx0XHRjYXNlICdkb3VibGUnOlxuXHRcdFx0Y2FzZSAnZmxvYXQnOlxuXHRcdFx0Y2FzZSAnbnVtYmVyJzpcblx0XHRcdGNhc2UgJ2ludGVnZXInOlxuXHRcdFx0XHRyZXR1cm4gTnVtYmVyS2V5ZnJhbWVUcmFjaztcblxuXHRcdFx0Y2FzZSAndmVjdG9yJzpcblx0XHRcdGNhc2UgJ3ZlY3RvcjInOlxuXHRcdFx0Y2FzZSAndmVjdG9yMyc6XG5cdFx0XHRjYXNlICd2ZWN0b3I0Jzpcblx0XHRcdFx0cmV0dXJuIFZlY3RvcktleWZyYW1lVHJhY2s7XG5cblx0XHRcdGNhc2UgJ2NvbG9yJzpcblx0XHRcdFx0cmV0dXJuIENvbG9yS2V5ZnJhbWVUcmFjaztcblxuXHRcdFx0Y2FzZSAncXVhdGVybmlvbic6XG5cdFx0XHRcdHJldHVybiBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaztcblxuXHRcdFx0Y2FzZSAnYm9vbCc6XG5cdFx0XHRjYXNlICdib29sZWFuJzpcblx0XHRcdFx0cmV0dXJuIEJvb2xlYW5LZXlmcmFtZVRyYWNrO1xuXG5cdFx0XHRjYXNlICdzdHJpbmcnOlxuXHRcdFx0XHRyZXR1cm4gU3RyaW5nS2V5ZnJhbWVUcmFjaztcblx0XHR9XG5cblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RIUkVFLktleWZyYW1lVHJhY2s6IFVuc3VwcG9ydGVkIHR5cGVOYW1lOiAnICsgdHlwZU5hbWUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcGFyc2VLZXlmcmFtZVRyYWNrKGpzb24pIHtcblx0XHRpZiAoanNvbi50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignVEhSRUUuS2V5ZnJhbWVUcmFjazogdHJhY2sgdHlwZSB1bmRlZmluZWQsIGNhbiBub3QgcGFyc2UnKTtcblx0XHR9XG5cblx0XHRjb25zdCB0cmFja1R5cGUgPSBnZXRUcmFja1R5cGVGb3JWYWx1ZVR5cGVOYW1lKGpzb24udHlwZSk7XG5cblx0XHRpZiAoanNvbi50aW1lcyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb25zdCB0aW1lcyA9IFtdLFxuXHRcdFx0XHRcdFx0dmFsdWVzID0gW107XG5cdFx0XHRBbmltYXRpb25VdGlscy5mbGF0dGVuSlNPTihqc29uLmtleXMsIHRpbWVzLCB2YWx1ZXMsICd2YWx1ZScpO1xuXHRcdFx0anNvbi50aW1lcyA9IHRpbWVzO1xuXHRcdFx0anNvbi52YWx1ZXMgPSB2YWx1ZXM7XG5cdFx0fSAvLyBkZXJpdmVkIGNsYXNzZXMgY2FuIGRlZmluZSBhIHN0YXRpYyBwYXJzZSBtZXRob2RcblxuXG5cdFx0aWYgKHRyYWNrVHlwZS5wYXJzZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gdHJhY2tUeXBlLnBhcnNlKGpzb24pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBieSBkZWZhdWx0LCB3ZSBhc3N1bWUgYSBjb25zdHJ1Y3RvciBjb21wYXRpYmxlIHdpdGggdGhlIGJhc2Vcblx0XHRcdHJldHVybiBuZXcgdHJhY2tUeXBlKGpzb24ubmFtZSwganNvbi50aW1lcywganNvbi52YWx1ZXMsIGpzb24uaW50ZXJwb2xhdGlvbik7XG5cdFx0fVxuXHR9XG5cblx0Y29uc3QgQ2FjaGUgPSB7XG5cdFx0ZW5hYmxlZDogZmFsc2UsXG5cdFx0ZmlsZXM6IHt9LFxuXHRcdGFkZDogZnVuY3Rpb24gKGtleSwgZmlsZSkge1xuXHRcdFx0aWYgKHRoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjsgLy8gY29uc29sZS5sb2coICdUSFJFRS5DYWNoZScsICdBZGRpbmcga2V5OicsIGtleSApO1xuXG5cdFx0XHR0aGlzLmZpbGVzW2tleV0gPSBmaWxlO1xuXHRcdH0sXG5cdFx0Z2V0OiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRpZiAodGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuOyAvLyBjb25zb2xlLmxvZyggJ1RIUkVFLkNhY2hlJywgJ0NoZWNraW5nIGtleTonLCBrZXkgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZmlsZXNba2V5XTtcblx0XHR9LFxuXHRcdHJlbW92ZTogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0ZGVsZXRlIHRoaXMuZmlsZXNba2V5XTtcblx0XHR9LFxuXHRcdGNsZWFyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLmZpbGVzID0ge307XG5cdFx0fVxuXHR9O1xuXG5cdGNsYXNzIExvYWRpbmdNYW5hZ2VyIHtcblx0XHRjb25zdHJ1Y3RvcihvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcblx0XHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblx0XHRcdGxldCBpc0xvYWRpbmcgPSBmYWxzZTtcblx0XHRcdGxldCBpdGVtc0xvYWRlZCA9IDA7XG5cdFx0XHRsZXQgaXRlbXNUb3RhbCA9IDA7XG5cdFx0XHRsZXQgdXJsTW9kaWZpZXIgPSB1bmRlZmluZWQ7XG5cdFx0XHRjb25zdCBoYW5kbGVycyA9IFtdOyAvLyBSZWZlciB0byAjNTY4OSBmb3IgdGhlIHJlYXNvbiB3aHkgd2UgZG9uJ3Qgc2V0IC5vblN0YXJ0XG5cdFx0XHQvLyBpbiB0aGUgY29uc3RydWN0b3JcblxuXHRcdFx0dGhpcy5vblN0YXJ0ID0gdW5kZWZpbmVkO1xuXHRcdFx0dGhpcy5vbkxvYWQgPSBvbkxvYWQ7XG5cdFx0XHR0aGlzLm9uUHJvZ3Jlc3MgPSBvblByb2dyZXNzO1xuXHRcdFx0dGhpcy5vbkVycm9yID0gb25FcnJvcjtcblxuXHRcdFx0dGhpcy5pdGVtU3RhcnQgPSBmdW5jdGlvbiAodXJsKSB7XG5cdFx0XHRcdGl0ZW1zVG90YWwrKztcblxuXHRcdFx0XHRpZiAoaXNMb2FkaW5nID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdGlmIChzY29wZS5vblN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHNjb3BlLm9uU3RhcnQodXJsLCBpdGVtc0xvYWRlZCwgaXRlbXNUb3RhbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aXNMb2FkaW5nID0gdHJ1ZTtcblx0XHRcdH07XG5cblx0XHRcdHRoaXMuaXRlbUVuZCA9IGZ1bmN0aW9uICh1cmwpIHtcblx0XHRcdFx0aXRlbXNMb2FkZWQrKztcblxuXHRcdFx0XHRpZiAoc2NvcGUub25Qcm9ncmVzcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0c2NvcGUub25Qcm9ncmVzcyh1cmwsIGl0ZW1zTG9hZGVkLCBpdGVtc1RvdGFsKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChpdGVtc0xvYWRlZCA9PT0gaXRlbXNUb3RhbCkge1xuXHRcdFx0XHRcdGlzTG9hZGluZyA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKHNjb3BlLm9uTG9hZCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRzY29wZS5vbkxvYWQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdHRoaXMuaXRlbUVycm9yID0gZnVuY3Rpb24gKHVybCkge1xuXHRcdFx0XHRpZiAoc2NvcGUub25FcnJvciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0c2NvcGUub25FcnJvcih1cmwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLnJlc29sdmVVUkwgPSBmdW5jdGlvbiAodXJsKSB7XG5cdFx0XHRcdGlmICh1cmxNb2RpZmllcikge1xuXHRcdFx0XHRcdHJldHVybiB1cmxNb2RpZmllcih1cmwpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHVybDtcblx0XHRcdH07XG5cblx0XHRcdHRoaXMuc2V0VVJMTW9kaWZpZXIgPSBmdW5jdGlvbiAodHJhbnNmb3JtKSB7XG5cdFx0XHRcdHVybE1vZGlmaWVyID0gdHJhbnNmb3JtO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdHRoaXMuYWRkSGFuZGxlciA9IGZ1bmN0aW9uIChyZWdleCwgbG9hZGVyKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2gocmVnZXgsIGxvYWRlcik7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5yZW1vdmVIYW5kbGVyID0gZnVuY3Rpb24gKHJlZ2V4KSB7XG5cdFx0XHRcdGNvbnN0IGluZGV4ID0gaGFuZGxlcnMuaW5kZXhPZihyZWdleCk7XG5cblx0XHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZShpbmRleCwgMik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdHRoaXMuZ2V0SGFuZGxlciA9IGZ1bmN0aW9uIChmaWxlKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSArPSAyKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVnZXggPSBoYW5kbGVyc1tpXTtcblx0XHRcdFx0XHRjb25zdCBsb2FkZXIgPSBoYW5kbGVyc1tpICsgMV07XG5cdFx0XHRcdFx0aWYgKHJlZ2V4Lmdsb2JhbCkgcmVnZXgubGFzdEluZGV4ID0gMDsgLy8gc2VlICMxNzkyMFxuXG5cdFx0XHRcdFx0aWYgKHJlZ2V4LnRlc3QoZmlsZSkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBsb2FkZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgRGVmYXVsdExvYWRpbmdNYW5hZ2VyID0gbmV3IExvYWRpbmdNYW5hZ2VyKCk7XG5cblx0Y2xhc3MgTG9hZGVyIHtcblx0XHRjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG5cdFx0XHR0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyICE9PSB1bmRlZmluZWQgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXHRcdFx0dGhpcy5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuXHRcdFx0dGhpcy53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcblx0XHRcdHRoaXMucGF0aCA9ICcnO1xuXHRcdFx0dGhpcy5yZXNvdXJjZVBhdGggPSAnJztcblx0XHRcdHRoaXMucmVxdWVzdEhlYWRlciA9IHt9O1xuXHRcdH1cblxuXHRcdGxvYWQoKSB7fVxuXG5cdFx0bG9hZEFzeW5jKHVybCwgb25Qcm9ncmVzcykge1xuXHRcdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdFx0c2NvcGUubG9hZCh1cmwsIHJlc29sdmUsIG9uUHJvZ3Jlc3MsIHJlamVjdCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRwYXJzZSgpIHt9XG5cblx0XHRzZXRDcm9zc09yaWdpbihjcm9zc09yaWdpbikge1xuXHRcdFx0dGhpcy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0V2l0aENyZWRlbnRpYWxzKHZhbHVlKSB7XG5cdFx0XHR0aGlzLndpdGhDcmVkZW50aWFscyA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0UGF0aChwYXRoKSB7XG5cdFx0XHR0aGlzLnBhdGggPSBwYXRoO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0UmVzb3VyY2VQYXRoKHJlc291cmNlUGF0aCkge1xuXHRcdFx0dGhpcy5yZXNvdXJjZVBhdGggPSByZXNvdXJjZVBhdGg7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRSZXF1ZXN0SGVhZGVyKHJlcXVlc3RIZWFkZXIpIHtcblx0XHRcdHRoaXMucmVxdWVzdEhlYWRlciA9IHJlcXVlc3RIZWFkZXI7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdGNvbnN0IGxvYWRpbmcgPSB7fTtcblxuXHRjbGFzcyBGaWxlTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblx0XHRjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG5cdFx0XHRzdXBlcihtYW5hZ2VyKTtcblx0XHR9XG5cblx0XHRsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG5cdFx0XHRpZiAodXJsID09PSB1bmRlZmluZWQpIHVybCA9ICcnO1xuXHRcdFx0aWYgKHRoaXMucGF0aCAhPT0gdW5kZWZpbmVkKSB1cmwgPSB0aGlzLnBhdGggKyB1cmw7XG5cdFx0XHR1cmwgPSB0aGlzLm1hbmFnZXIucmVzb2x2ZVVSTCh1cmwpO1xuXHRcdFx0Y29uc3QgY2FjaGVkID0gQ2FjaGUuZ2V0KHVybCk7XG5cblx0XHRcdGlmIChjYWNoZWQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KHVybCk7XG5cdFx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdGlmIChvbkxvYWQpIG9uTG9hZChjYWNoZWQpO1xuXHRcdFx0XHRcdHRoaXMubWFuYWdlci5pdGVtRW5kKHVybCk7XG5cdFx0XHRcdH0sIDApO1xuXHRcdFx0XHRyZXR1cm4gY2FjaGVkO1xuXHRcdFx0fSAvLyBDaGVjayBpZiByZXF1ZXN0IGlzIGR1cGxpY2F0ZVxuXG5cblx0XHRcdGlmIChsb2FkaW5nW3VybF0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRsb2FkaW5nW3VybF0ucHVzaCh7XG5cdFx0XHRcdFx0b25Mb2FkOiBvbkxvYWQsXG5cdFx0XHRcdFx0b25Qcm9ncmVzczogb25Qcm9ncmVzcyxcblx0XHRcdFx0XHRvbkVycm9yOiBvbkVycm9yXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IC8vIEluaXRpYWxpc2UgYXJyYXkgZm9yIGR1cGxpY2F0ZSByZXF1ZXN0c1xuXG5cblx0XHRcdGxvYWRpbmdbdXJsXSA9IFtdO1xuXHRcdFx0bG9hZGluZ1t1cmxdLnB1c2goe1xuXHRcdFx0XHRvbkxvYWQ6IG9uTG9hZCxcblx0XHRcdFx0b25Qcm9ncmVzczogb25Qcm9ncmVzcyxcblx0XHRcdFx0b25FcnJvcjogb25FcnJvclxuXHRcdFx0fSk7IC8vIGNyZWF0ZSByZXF1ZXN0XG5cblx0XHRcdGNvbnN0IHJlcSA9IG5ldyBSZXF1ZXN0KHVybCwge1xuXHRcdFx0XHRoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLnJlcXVlc3RIZWFkZXIpLFxuXHRcdFx0XHRjcmVkZW50aWFsczogdGhpcy53aXRoQ3JlZGVudGlhbHMgPyAnaW5jbHVkZScgOiAnc2FtZS1vcmlnaW4nIC8vIEFuIGFib3J0IGNvbnRyb2xsZXIgY291bGQgYmUgYWRkZWQgd2l0aGluIGEgZnV0dXJlIFBSXG5cblx0XHRcdH0pOyAvLyBzdGFydCB0aGUgZmV0Y2hcblxuXHRcdFx0ZmV0Y2gocmVxKS50aGVuKHJlc3BvbnNlID0+IHtcblx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMCkge1xuXHRcdFx0XHRcdC8vIFNvbWUgYnJvd3NlcnMgcmV0dXJuIEhUVFAgU3RhdHVzIDAgd2hlbiB1c2luZyBub24taHR0cCBwcm90b2NvbFxuXHRcdFx0XHRcdC8vIGUuZy4gJ2ZpbGU6Ly8nIG9yICdkYXRhOi8vJy4gSGFuZGxlIGFzIHN1Y2Nlc3MuXG5cdFx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMCkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5GaWxlTG9hZGVyOiBIVFRQIFN0YXR1cyAwIHJlY2VpdmVkLicpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IGNhbGxiYWNrcyA9IGxvYWRpbmdbdXJsXTtcblx0XHRcdFx0XHRjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuXHRcdFx0XHRcdGNvbnN0IGNvbnRlbnRMZW5ndGggPSByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1MZW5ndGgnKTtcblx0XHRcdFx0XHRjb25zdCB0b3RhbCA9IGNvbnRlbnRMZW5ndGggPyBwYXJzZUludChjb250ZW50TGVuZ3RoKSA6IDA7XG5cdFx0XHRcdFx0Y29uc3QgbGVuZ3RoQ29tcHV0YWJsZSA9IHRvdGFsICE9PSAwO1xuXHRcdFx0XHRcdGxldCBsb2FkZWQgPSAwOyAvLyBwZXJpb2RpY2FsbHkgcmVhZCBkYXRhIGludG8gdGhlIG5ldyBzdHJlYW0gdHJhY2tpbmcgd2hpbGUgZG93bmxvYWQgcHJvZ3Jlc3NcblxuXHRcdFx0XHRcdHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuXHRcdFx0XHRcdFx0c3RhcnQoY29udHJvbGxlcikge1xuXHRcdFx0XHRcdFx0XHRyZWFkRGF0YSgpO1xuXG5cdFx0XHRcdFx0XHRcdGZ1bmN0aW9uIHJlYWREYXRhKCkge1xuXHRcdFx0XHRcdFx0XHRcdHJlYWRlci5yZWFkKCkudGhlbigoe1xuXHRcdFx0XHRcdFx0XHRcdFx0ZG9uZSxcblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlXG5cdFx0XHRcdFx0XHRcdFx0fSkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGRvbmUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29udHJvbGxlci5jbG9zZSgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0bG9hZGVkICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IGV2ZW50ID0gbmV3IFByb2dyZXNzRXZlbnQoJ3Byb2dyZXNzJywge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGxlbmd0aENvbXB1dGFibGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bG9hZGVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRvdGFsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgY2FsbGJhY2sgPSBjYWxsYmFja3NbaV07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGNhbGxiYWNrLm9uUHJvZ3Jlc3MpIGNhbGxiYWNrLm9uUHJvZ3Jlc3MoZXZlbnQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVhZERhdGEoKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgRXJyb3IoYGZldGNoIGZvciBcIiR7cmVzcG9uc2UudXJsfVwiIHJlc3BvbmRlZCB3aXRoICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KS50aGVuKHN0cmVhbSA9PiB7XG5cdFx0XHRcdGNvbnN0IHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKHN0cmVhbSk7XG5cblx0XHRcdFx0c3dpdGNoICh0aGlzLnJlc3BvbnNlVHlwZSkge1xuXHRcdFx0XHRcdGNhc2UgJ2FycmF5YnVmZmVyJzpcblx0XHRcdFx0XHRcdHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuXG5cdFx0XHRcdFx0Y2FzZSAnYmxvYic6XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UuYmxvYigpO1xuXG5cdFx0XHRcdFx0Y2FzZSAnZG9jdW1lbnQnOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLnRleHQoKS50aGVuKHRleHQgPT4ge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHRleHQsIHRoaXMubWltZVR5cGUpO1xuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRjYXNlICdqc29uJzpcblx0XHRcdFx0XHRcdHJldHVybiByZXNwb25zZS5qc29uKCk7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSkudGhlbihkYXRhID0+IHtcblx0XHRcdFx0Ly8gQWRkIHRvIGNhY2hlIG9ubHkgb24gSFRUUCBzdWNjZXNzLCBzbyB0aGF0IHdlIGRvIG5vdCBjYWNoZVxuXHRcdFx0XHQvLyBlcnJvciByZXNwb25zZSBib2RpZXMgYXMgcHJvcGVyIHJlc3BvbnNlcyB0byByZXF1ZXN0cy5cblx0XHRcdFx0Q2FjaGUuYWRkKHVybCwgZGF0YSk7XG5cdFx0XHRcdGNvbnN0IGNhbGxiYWNrcyA9IGxvYWRpbmdbdXJsXTtcblx0XHRcdFx0ZGVsZXRlIGxvYWRpbmdbdXJsXTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IGNhbGxiYWNrID0gY2FsbGJhY2tzW2ldO1xuXHRcdFx0XHRcdGlmIChjYWxsYmFjay5vbkxvYWQpIGNhbGxiYWNrLm9uTG9hZChkYXRhKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMubWFuYWdlci5pdGVtRW5kKHVybCk7XG5cdFx0XHR9KS5jYXRjaChlcnIgPT4ge1xuXHRcdFx0XHQvLyBBYm9ydCBlcnJvcnMgYW5kIG90aGVyIGVycm9ycyBhcmUgaGFuZGxlZCB0aGUgc2FtZVxuXHRcdFx0XHRjb25zdCBjYWxsYmFja3MgPSBsb2FkaW5nW3VybF07XG5cdFx0XHRcdGRlbGV0ZSBsb2FkaW5nW3VybF07XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBjYWxsYmFjayA9IGNhbGxiYWNrc1tpXTtcblx0XHRcdFx0XHRpZiAoY2FsbGJhY2sub25FcnJvcikgY2FsbGJhY2sub25FcnJvcihlcnIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuXHRcdFx0XHR0aGlzLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KHVybCk7XG5cdFx0fVxuXG5cdFx0c2V0UmVzcG9uc2VUeXBlKHZhbHVlKSB7XG5cdFx0XHR0aGlzLnJlc3BvbnNlVHlwZSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0TWltZVR5cGUodmFsdWUpIHtcblx0XHRcdHRoaXMubWltZVR5cGUgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgQW5pbWF0aW9uTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblx0XHRjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG5cdFx0XHRzdXBlcihtYW5hZ2VyKTtcblx0XHR9XG5cblx0XHRsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG5cdFx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0XHRjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLm1hbmFnZXIpO1xuXHRcdFx0bG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcblx0XHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG5cdFx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcblx0XHRcdGxvYWRlci5sb2FkKHVybCwgZnVuY3Rpb24gKHRleHQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRvbkxvYWQoc2NvcGUucGFyc2UoSlNPTi5wYXJzZSh0ZXh0KSkpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0aWYgKG9uRXJyb3IpIHtcblx0XHRcdFx0XHRcdG9uRXJyb3IoZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IodXJsKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvcik7XG5cdFx0fVxuXG5cdFx0cGFyc2UoanNvbikge1xuXHRcdFx0Y29uc3QgYW5pbWF0aW9ucyA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGpzb24ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgY2xpcCA9IEFuaW1hdGlvbkNsaXAucGFyc2UoanNvbltpXSk7XG5cdFx0XHRcdGFuaW1hdGlvbnMucHVzaChjbGlwKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGFuaW1hdGlvbnM7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogQWJzdHJhY3QgQmFzZSBjbGFzcyB0byBibG9jayBiYXNlZCB0ZXh0dXJlcyBsb2FkZXIgKGRkcywgcHZyLCAuLi4pXG5cdCAqXG5cdCAqIFN1YiBjbGFzc2VzIGhhdmUgdG8gaW1wbGVtZW50IHRoZSBwYXJzZSgpIG1ldGhvZCB3aGljaCB3aWxsIGJlIHVzZWQgaW4gbG9hZCgpLlxuXHQgKi9cblxuXHRjbGFzcyBDb21wcmVzc2VkVGV4dHVyZUxvYWRlciBleHRlbmRzIExvYWRlciB7XG5cdFx0Y29uc3RydWN0b3IobWFuYWdlcikge1xuXHRcdFx0c3VwZXIobWFuYWdlcik7XG5cdFx0fVxuXG5cdFx0bG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuXHRcdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdFx0Y29uc3QgaW1hZ2VzID0gW107XG5cdFx0XHRjb25zdCB0ZXh0dXJlID0gbmV3IENvbXByZXNzZWRUZXh0dXJlKCk7XG5cdFx0XHRjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLm1hbmFnZXIpO1xuXHRcdFx0bG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcblx0XHRcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoJ2FycmF5YnVmZmVyJyk7XG5cdFx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuXHRcdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyhzY29wZS53aXRoQ3JlZGVudGlhbHMpO1xuXHRcdFx0bGV0IGxvYWRlZCA9IDA7XG5cblx0XHRcdGZ1bmN0aW9uIGxvYWRUZXh0dXJlKGkpIHtcblx0XHRcdFx0bG9hZGVyLmxvYWQodXJsW2ldLCBmdW5jdGlvbiAoYnVmZmVyKSB7XG5cdFx0XHRcdFx0Y29uc3QgdGV4RGF0YXMgPSBzY29wZS5wYXJzZShidWZmZXIsIHRydWUpO1xuXHRcdFx0XHRcdGltYWdlc1tpXSA9IHtcblx0XHRcdFx0XHRcdHdpZHRoOiB0ZXhEYXRhcy53aWR0aCxcblx0XHRcdFx0XHRcdGhlaWdodDogdGV4RGF0YXMuaGVpZ2h0LFxuXHRcdFx0XHRcdFx0Zm9ybWF0OiB0ZXhEYXRhcy5mb3JtYXQsXG5cdFx0XHRcdFx0XHRtaXBtYXBzOiB0ZXhEYXRhcy5taXBtYXBzXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRsb2FkZWQgKz0gMTtcblxuXHRcdFx0XHRcdGlmIChsb2FkZWQgPT09IDYpIHtcblx0XHRcdFx0XHRcdGlmICh0ZXhEYXRhcy5taXBtYXBDb3VudCA9PT0gMSkgdGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlID0gaW1hZ2VzO1xuXHRcdFx0XHRcdFx0dGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGlmIChvbkxvYWQpIG9uTG9hZCh0ZXh0dXJlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh1cmwpKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IHVybC5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG5cdFx0XHRcdFx0bG9hZFRleHR1cmUoaSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGNvbXByZXNzZWQgY3ViZW1hcCB0ZXh0dXJlIHN0b3JlZCBpbiBhIHNpbmdsZSBERFMgZmlsZVxuXHRcdFx0XHRsb2FkZXIubG9hZCh1cmwsIGZ1bmN0aW9uIChidWZmZXIpIHtcblx0XHRcdFx0XHRjb25zdCB0ZXhEYXRhcyA9IHNjb3BlLnBhcnNlKGJ1ZmZlciwgdHJ1ZSk7XG5cblx0XHRcdFx0XHRpZiAodGV4RGF0YXMuaXNDdWJlbWFwKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBmYWNlcyA9IHRleERhdGFzLm1pcG1hcHMubGVuZ3RoIC8gdGV4RGF0YXMubWlwbWFwQ291bnQ7XG5cblx0XHRcdFx0XHRcdGZvciAobGV0IGYgPSAwOyBmIDwgZmFjZXM7IGYrKykge1xuXHRcdFx0XHRcdFx0XHRpbWFnZXNbZl0gPSB7XG5cdFx0XHRcdFx0XHRcdFx0bWlwbWFwczogW11cblx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRleERhdGFzLm1pcG1hcENvdW50OyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRpbWFnZXNbZl0ubWlwbWFwcy5wdXNoKHRleERhdGFzLm1pcG1hcHNbZiAqIHRleERhdGFzLm1pcG1hcENvdW50ICsgaV0pO1xuXHRcdFx0XHRcdFx0XHRcdGltYWdlc1tmXS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XG5cdFx0XHRcdFx0XHRcdFx0aW1hZ2VzW2ZdLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XG5cdFx0XHRcdFx0XHRcdFx0aW1hZ2VzW2ZdLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlID0gaW1hZ2VzO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcblx0XHRcdFx0XHRcdHRleHR1cmUubWlwbWFwcyA9IHRleERhdGFzLm1pcG1hcHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHRleERhdGFzLm1pcG1hcENvdW50ID09PSAxKSB7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcblx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRpZiAob25Mb2FkKSBvbkxvYWQodGV4dHVyZSk7XG5cdFx0XHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGV4dHVyZTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIEltYWdlTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblx0XHRjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG5cdFx0XHRzdXBlcihtYW5hZ2VyKTtcblx0XHR9XG5cblx0XHRsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG5cdFx0XHRpZiAodGhpcy5wYXRoICE9PSB1bmRlZmluZWQpIHVybCA9IHRoaXMucGF0aCArIHVybDtcblx0XHRcdHVybCA9IHRoaXMubWFuYWdlci5yZXNvbHZlVVJMKHVybCk7XG5cdFx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0XHRjb25zdCBjYWNoZWQgPSBDYWNoZS5nZXQodXJsKTtcblxuXHRcdFx0aWYgKGNhY2hlZCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KHVybCk7XG5cdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGlmIChvbkxvYWQpIG9uTG9hZChjYWNoZWQpO1xuXHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuXHRcdFx0XHR9LCAwKTtcblx0XHRcdFx0cmV0dXJuIGNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgaW1hZ2UgPSBjcmVhdGVFbGVtZW50TlMoJ2ltZycpO1xuXG5cdFx0XHRmdW5jdGlvbiBvbkltYWdlTG9hZCgpIHtcblx0XHRcdFx0cmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcblx0XHRcdFx0Q2FjaGUuYWRkKHVybCwgdGhpcyk7XG5cdFx0XHRcdGlmIChvbkxvYWQpIG9uTG9hZCh0aGlzKTtcblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKHVybCk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIG9uSW1hZ2VFcnJvcihldmVudCkge1xuXHRcdFx0XHRyZW1vdmVFdmVudExpc3RlbmVycygpO1xuXHRcdFx0XHRpZiAob25FcnJvcikgb25FcnJvcihldmVudCk7XG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKHVybCk7XG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycygpIHtcblx0XHRcdFx0aW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uSW1hZ2VMb2FkLCBmYWxzZSk7XG5cdFx0XHRcdGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25JbWFnZUVycm9yLCBmYWxzZSk7XG5cdFx0XHR9XG5cblx0XHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkltYWdlTG9hZCwgZmFsc2UpO1xuXHRcdFx0aW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkltYWdlRXJyb3IsIGZhbHNlKTtcblxuXHRcdFx0aWYgKHVybC5zdWJzdHIoMCwgNSkgIT09ICdkYXRhOicpIHtcblx0XHRcdFx0aWYgKHRoaXMuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCkgaW1hZ2UuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuXHRcdFx0fVxuXG5cdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCh1cmwpO1xuXHRcdFx0aW1hZ2Uuc3JjID0gdXJsO1xuXHRcdFx0cmV0dXJuIGltYWdlO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgQ3ViZVRleHR1cmVMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXHRcdGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcblx0XHRcdHN1cGVyKG1hbmFnZXIpO1xuXHRcdH1cblxuXHRcdGxvYWQodXJscywgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG5cdFx0XHRjb25zdCB0ZXh0dXJlID0gbmV3IEN1YmVUZXh0dXJlKCk7XG5cdFx0XHRjb25zdCBsb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIodGhpcy5tYW5hZ2VyKTtcblx0XHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbih0aGlzLmNyb3NzT3JpZ2luKTtcblx0XHRcdGxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG5cdFx0XHRsZXQgbG9hZGVkID0gMDtcblxuXHRcdFx0ZnVuY3Rpb24gbG9hZFRleHR1cmUoaSkge1xuXHRcdFx0XHRsb2FkZXIubG9hZCh1cmxzW2ldLCBmdW5jdGlvbiAoaW1hZ2UpIHtcblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlc1tpXSA9IGltYWdlO1xuXHRcdFx0XHRcdGxvYWRlZCsrO1xuXG5cdFx0XHRcdFx0aWYgKGxvYWRlZCA9PT0gNikge1xuXHRcdFx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRpZiAob25Mb2FkKSBvbkxvYWQodGV4dHVyZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCB1bmRlZmluZWQsIG9uRXJyb3IpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0bG9hZFRleHR1cmUoaSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0ZXh0dXJlO1xuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIEFic3RyYWN0IEJhc2UgY2xhc3MgdG8gbG9hZCBnZW5lcmljIGJpbmFyeSB0ZXh0dXJlcyBmb3JtYXRzIChyZ2JlLCBoZHIsIC4uLilcblx0ICpcblx0ICogU3ViIGNsYXNzZXMgaGF2ZSB0byBpbXBsZW1lbnQgdGhlIHBhcnNlKCkgbWV0aG9kIHdoaWNoIHdpbGwgYmUgdXNlZCBpbiBsb2FkKCkuXG5cdCAqL1xuXG5cdGNsYXNzIERhdGFUZXh0dXJlTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblx0XHRjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG5cdFx0XHRzdXBlcihtYW5hZ2VyKTtcblx0XHR9XG5cblx0XHRsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG5cdFx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0XHRjb25zdCB0ZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKCk7XG5cdFx0XHRjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLm1hbmFnZXIpO1xuXHRcdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSgnYXJyYXlidWZmZXInKTtcblx0XHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG5cdFx0XHRsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuXHRcdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyhzY29wZS53aXRoQ3JlZGVudGlhbHMpO1xuXHRcdFx0bG9hZGVyLmxvYWQodXJsLCBmdW5jdGlvbiAoYnVmZmVyKSB7XG5cdFx0XHRcdGNvbnN0IHRleERhdGEgPSBzY29wZS5wYXJzZShidWZmZXIpO1xuXHRcdFx0XHRpZiAoIXRleERhdGEpIHJldHVybjtcblxuXHRcdFx0XHRpZiAodGV4RGF0YS5pbWFnZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGV4dHVyZS5pbWFnZSA9IHRleERhdGEuaW1hZ2U7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGV4RGF0YS5kYXRhICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLndpZHRoID0gdGV4RGF0YS53aWR0aDtcblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLmhlaWdodCA9IHRleERhdGEuaGVpZ2h0O1xuXHRcdFx0XHRcdHRleHR1cmUuaW1hZ2UuZGF0YSA9IHRleERhdGEuZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRleHR1cmUud3JhcFMgPSB0ZXhEYXRhLndyYXBTICE9PSB1bmRlZmluZWQgPyB0ZXhEYXRhLndyYXBTIDogQ2xhbXBUb0VkZ2VXcmFwcGluZztcblx0XHRcdFx0dGV4dHVyZS53cmFwVCA9IHRleERhdGEud3JhcFQgIT09IHVuZGVmaW5lZCA/IHRleERhdGEud3JhcFQgOiBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuXHRcdFx0XHR0ZXh0dXJlLm1hZ0ZpbHRlciA9IHRleERhdGEubWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyB0ZXhEYXRhLm1hZ0ZpbHRlciA6IExpbmVhckZpbHRlcjtcblx0XHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSB0ZXhEYXRhLm1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gdGV4RGF0YS5taW5GaWx0ZXIgOiBMaW5lYXJGaWx0ZXI7XG5cdFx0XHRcdHRleHR1cmUuYW5pc290cm9weSA9IHRleERhdGEuYW5pc290cm9weSAhPT0gdW5kZWZpbmVkID8gdGV4RGF0YS5hbmlzb3Ryb3B5IDogMTtcblxuXHRcdFx0XHRpZiAodGV4RGF0YS5lbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGV4dHVyZS5lbmNvZGluZyA9IHRleERhdGEuZW5jb2Rpbmc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGV4RGF0YS5mbGlwWSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGV4dHVyZS5mbGlwWSA9IHRleERhdGEuZmxpcFk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGV4RGF0YS5mb3JtYXQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YS5mb3JtYXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGV4RGF0YS50eXBlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0ZXh0dXJlLnR5cGUgPSB0ZXhEYXRhLnR5cGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGV4RGF0YS5taXBtYXBzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0ZXh0dXJlLm1pcG1hcHMgPSB0ZXhEYXRhLm1pcG1hcHM7XG5cdFx0XHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXI7IC8vIHByZXN1bWFibHkuLi5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0ZXhEYXRhLm1pcG1hcENvdW50ID09PSAxKSB7XG5cdFx0XHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGV4RGF0YS5nZW5lcmF0ZU1pcG1hcHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gdGV4RGF0YS5nZW5lcmF0ZU1pcG1hcHM7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0aWYgKG9uTG9hZCkgb25Mb2FkKHRleHR1cmUsIHRleERhdGEpO1xuXHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvcik7XG5cdFx0XHRyZXR1cm4gdGV4dHVyZTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIFRleHR1cmVMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXHRcdGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcblx0XHRcdHN1cGVyKG1hbmFnZXIpO1xuXHRcdH1cblxuXHRcdGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcblx0XHRcdGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZSgpO1xuXHRcdFx0Y29uc3QgbG9hZGVyID0gbmV3IEltYWdlTG9hZGVyKHRoaXMubWFuYWdlcik7XG5cdFx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4odGhpcy5jcm9zc09yaWdpbik7XG5cdFx0XHRsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuXHRcdFx0bG9hZGVyLmxvYWQodXJsLCBmdW5jdGlvbiAoaW1hZ2UpIHtcblx0XHRcdFx0dGV4dHVyZS5pbWFnZSA9IGltYWdlO1xuXHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRpZiAob25Mb2FkICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRvbkxvYWQodGV4dHVyZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpO1xuXHRcdFx0cmV0dXJuIHRleHR1cmU7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBMaWdodCBleHRlbmRzIE9iamVjdDNEIHtcblx0XHRjb25zdHJ1Y3Rvcihjb2xvciwgaW50ZW5zaXR5ID0gMSkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMudHlwZSA9ICdMaWdodCc7XG5cdFx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKGNvbG9yKTtcblx0XHRcdHRoaXMuaW50ZW5zaXR5ID0gaW50ZW5zaXR5O1xuXHRcdH1cblxuXHRcdGRpc3Bvc2UoKSB7Ly8gRW1wdHkgaGVyZSBpbiBiYXNlIGNsYXNzOyBzb21lIHN1YmNsYXNzZXMgb3ZlcnJpZGUuXG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdHRoaXMuY29sb3IuY29weShzb3VyY2UuY29sb3IpO1xuXHRcdFx0dGhpcy5pbnRlbnNpdHkgPSBzb3VyY2UuaW50ZW5zaXR5O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dG9KU09OKG1ldGEpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04obWV0YSk7XG5cdFx0XHRkYXRhLm9iamVjdC5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XG5cdFx0XHRkYXRhLm9iamVjdC5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcblx0XHRcdGlmICh0aGlzLmdyb3VuZENvbG9yICE9PSB1bmRlZmluZWQpIGRhdGEub2JqZWN0Lmdyb3VuZENvbG9yID0gdGhpcy5ncm91bmRDb2xvci5nZXRIZXgoKTtcblx0XHRcdGlmICh0aGlzLmRpc3RhbmNlICE9PSB1bmRlZmluZWQpIGRhdGEub2JqZWN0LmRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZTtcblx0XHRcdGlmICh0aGlzLmFuZ2xlICE9PSB1bmRlZmluZWQpIGRhdGEub2JqZWN0LmFuZ2xlID0gdGhpcy5hbmdsZTtcblx0XHRcdGlmICh0aGlzLmRlY2F5ICE9PSB1bmRlZmluZWQpIGRhdGEub2JqZWN0LmRlY2F5ID0gdGhpcy5kZWNheTtcblx0XHRcdGlmICh0aGlzLnBlbnVtYnJhICE9PSB1bmRlZmluZWQpIGRhdGEub2JqZWN0LnBlbnVtYnJhID0gdGhpcy5wZW51bWJyYTtcblx0XHRcdGlmICh0aGlzLnNoYWRvdyAhPT0gdW5kZWZpbmVkKSBkYXRhLm9iamVjdC5zaGFkb3cgPSB0aGlzLnNoYWRvdy50b0pTT04oKTtcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHR9XG5cblx0TGlnaHQucHJvdG90eXBlLmlzTGlnaHQgPSB0cnVlO1xuXG5cdGNsYXNzIEhlbWlzcGhlcmVMaWdodCBleHRlbmRzIExpZ2h0IHtcblx0XHRjb25zdHJ1Y3Rvcihza3lDb2xvciwgZ3JvdW5kQ29sb3IsIGludGVuc2l0eSkge1xuXHRcdFx0c3VwZXIoc2t5Q29sb3IsIGludGVuc2l0eSk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnSGVtaXNwaGVyZUxpZ2h0Jztcblx0XHRcdHRoaXMucG9zaXRpb24uY29weShPYmplY3QzRC5EZWZhdWx0VXApO1xuXHRcdFx0dGhpcy51cGRhdGVNYXRyaXgoKTtcblx0XHRcdHRoaXMuZ3JvdW5kQ29sb3IgPSBuZXcgQ29sb3IoZ3JvdW5kQ29sb3IpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRMaWdodC5wcm90b3R5cGUuY29weS5jYWxsKHRoaXMsIHNvdXJjZSk7XG5cdFx0XHR0aGlzLmdyb3VuZENvbG9yLmNvcHkoc291cmNlLmdyb3VuZENvbG9yKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0SGVtaXNwaGVyZUxpZ2h0LnByb3RvdHlwZS5pc0hlbWlzcGhlcmVMaWdodCA9IHRydWU7XG5cblx0Y29uc3QgX3Byb2pTY3JlZW5NYXRyaXgkMSA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuXG5cdGNvbnN0IF9saWdodFBvc2l0aW9uV29ybGQkMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9sb29rVGFyZ2V0JDEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjbGFzcyBMaWdodFNoYWRvdyB7XG5cdFx0Y29uc3RydWN0b3IoY2FtZXJhKSB7XG5cdFx0XHR0aGlzLmNhbWVyYSA9IGNhbWVyYTtcblx0XHRcdHRoaXMuYmlhcyA9IDA7XG5cdFx0XHR0aGlzLm5vcm1hbEJpYXMgPSAwO1xuXHRcdFx0dGhpcy5yYWRpdXMgPSAxO1xuXHRcdFx0dGhpcy5ibHVyU2FtcGxlcyA9IDg7XG5cdFx0XHR0aGlzLm1hcFNpemUgPSBuZXcgVmVjdG9yMig1MTIsIDUxMik7XG5cdFx0XHR0aGlzLm1hcCA9IG51bGw7XG5cdFx0XHR0aGlzLm1hcFBhc3MgPSBudWxsO1xuXHRcdFx0dGhpcy5tYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXHRcdFx0dGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTtcblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblx0XHRcdHRoaXMuX2ZydXN0dW0gPSBuZXcgRnJ1c3R1bSgpO1xuXHRcdFx0dGhpcy5fZnJhbWVFeHRlbnRzID0gbmV3IFZlY3RvcjIoMSwgMSk7XG5cdFx0XHR0aGlzLl92aWV3cG9ydENvdW50ID0gMTtcblx0XHRcdHRoaXMuX3ZpZXdwb3J0cyA9IFtuZXcgVmVjdG9yNCgwLCAwLCAxLCAxKV07XG5cdFx0fVxuXG5cdFx0Z2V0Vmlld3BvcnRDb3VudCgpIHtcblx0XHRcdHJldHVybiB0aGlzLl92aWV3cG9ydENvdW50O1xuXHRcdH1cblxuXHRcdGdldEZydXN0dW0oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZnJ1c3R1bTtcblx0XHR9XG5cblx0XHR1cGRhdGVNYXRyaWNlcyhsaWdodCkge1xuXHRcdFx0Y29uc3Qgc2hhZG93Q2FtZXJhID0gdGhpcy5jYW1lcmE7XG5cdFx0XHRjb25zdCBzaGFkb3dNYXRyaXggPSB0aGlzLm1hdHJpeDtcblxuXHRcdFx0X2xpZ2h0UG9zaXRpb25Xb3JsZCQxLnNldEZyb21NYXRyaXhQb3NpdGlvbihsaWdodC5tYXRyaXhXb3JsZCk7XG5cblx0XHRcdHNoYWRvd0NhbWVyYS5wb3NpdGlvbi5jb3B5KF9saWdodFBvc2l0aW9uV29ybGQkMSk7XG5cblx0XHRcdF9sb29rVGFyZ2V0JDEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCk7XG5cblx0XHRcdHNoYWRvd0NhbWVyYS5sb29rQXQoX2xvb2tUYXJnZXQkMSk7XG5cdFx0XHRzaGFkb3dDYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdFx0X3Byb2pTY3JlZW5NYXRyaXgkMS5tdWx0aXBseU1hdHJpY2VzKHNoYWRvd0NhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlKTtcblxuXHRcdFx0dGhpcy5fZnJ1c3R1bS5zZXRGcm9tUHJvamVjdGlvbk1hdHJpeChfcHJvalNjcmVlbk1hdHJpeCQxKTtcblxuXHRcdFx0c2hhZG93TWF0cml4LnNldCgwLjUsIDAuMCwgMC4wLCAwLjUsIDAuMCwgMC41LCAwLjAsIDAuNSwgMC4wLCAwLjAsIDAuNSwgMC41LCAwLjAsIDAuMCwgMC4wLCAxLjApO1xuXHRcdFx0c2hhZG93TWF0cml4Lm11bHRpcGx5KHNoYWRvd0NhbWVyYS5wcm9qZWN0aW9uTWF0cml4KTtcblx0XHRcdHNoYWRvd01hdHJpeC5tdWx0aXBseShzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlKTtcblx0XHR9XG5cblx0XHRnZXRWaWV3cG9ydCh2aWV3cG9ydEluZGV4KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdmlld3BvcnRzW3ZpZXdwb3J0SW5kZXhdO1xuXHRcdH1cblxuXHRcdGdldEZyYW1lRXh0ZW50cygpIHtcblx0XHRcdHJldHVybiB0aGlzLl9mcmFtZUV4dGVudHM7XG5cdFx0fVxuXG5cdFx0ZGlzcG9zZSgpIHtcblx0XHRcdGlmICh0aGlzLm1hcCkge1xuXHRcdFx0XHR0aGlzLm1hcC5kaXNwb3NlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLm1hcFBhc3MpIHtcblx0XHRcdFx0dGhpcy5tYXBQYXNzLmRpc3Bvc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0dGhpcy5jYW1lcmEgPSBzb3VyY2UuY2FtZXJhLmNsb25lKCk7XG5cdFx0XHR0aGlzLmJpYXMgPSBzb3VyY2UuYmlhcztcblx0XHRcdHRoaXMucmFkaXVzID0gc291cmNlLnJhZGl1cztcblx0XHRcdHRoaXMubWFwU2l6ZS5jb3B5KHNvdXJjZS5tYXBTaXplKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNsb25lKCkge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcblx0XHR9XG5cblx0XHR0b0pTT04oKSB7XG5cdFx0XHRjb25zdCBvYmplY3QgPSB7fTtcblx0XHRcdGlmICh0aGlzLmJpYXMgIT09IDApIG9iamVjdC5iaWFzID0gdGhpcy5iaWFzO1xuXHRcdFx0aWYgKHRoaXMubm9ybWFsQmlhcyAhPT0gMCkgb2JqZWN0Lm5vcm1hbEJpYXMgPSB0aGlzLm5vcm1hbEJpYXM7XG5cdFx0XHRpZiAodGhpcy5yYWRpdXMgIT09IDEpIG9iamVjdC5yYWRpdXMgPSB0aGlzLnJhZGl1cztcblx0XHRcdGlmICh0aGlzLm1hcFNpemUueCAhPT0gNTEyIHx8IHRoaXMubWFwU2l6ZS55ICE9PSA1MTIpIG9iamVjdC5tYXBTaXplID0gdGhpcy5tYXBTaXplLnRvQXJyYXkoKTtcblx0XHRcdG9iamVjdC5jYW1lcmEgPSB0aGlzLmNhbWVyYS50b0pTT04oZmFsc2UpLm9iamVjdDtcblx0XHRcdGRlbGV0ZSBvYmplY3QuY2FtZXJhLm1hdHJpeDtcblx0XHRcdHJldHVybiBvYmplY3Q7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBTcG90TGlnaHRTaGFkb3cgZXh0ZW5kcyBMaWdodFNoYWRvdyB7XG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cdFx0XHRzdXBlcihuZXcgUGVyc3BlY3RpdmVDYW1lcmEoNTAsIDEsIDAuNSwgNTAwKSk7XG5cdFx0XHR0aGlzLmZvY3VzID0gMTtcblx0XHR9XG5cblx0XHR1cGRhdGVNYXRyaWNlcyhsaWdodCkge1xuXHRcdFx0Y29uc3QgY2FtZXJhID0gdGhpcy5jYW1lcmE7XG5cdFx0XHRjb25zdCBmb3YgPSBSQUQyREVHICogMiAqIGxpZ2h0LmFuZ2xlICogdGhpcy5mb2N1cztcblx0XHRcdGNvbnN0IGFzcGVjdCA9IHRoaXMubWFwU2l6ZS53aWR0aCAvIHRoaXMubWFwU2l6ZS5oZWlnaHQ7XG5cdFx0XHRjb25zdCBmYXIgPSBsaWdodC5kaXN0YW5jZSB8fCBjYW1lcmEuZmFyO1xuXG5cdFx0XHRpZiAoZm92ICE9PSBjYW1lcmEuZm92IHx8IGFzcGVjdCAhPT0gY2FtZXJhLmFzcGVjdCB8fCBmYXIgIT09IGNhbWVyYS5mYXIpIHtcblx0XHRcdFx0Y2FtZXJhLmZvdiA9IGZvdjtcblx0XHRcdFx0Y2FtZXJhLmFzcGVjdCA9IGFzcGVjdDtcblx0XHRcdFx0Y2FtZXJhLmZhciA9IGZhcjtcblx0XHRcdFx0Y2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblx0XHRcdH1cblxuXHRcdFx0c3VwZXIudXBkYXRlTWF0cmljZXMobGlnaHQpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLmZvY3VzID0gc291cmNlLmZvY3VzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRTcG90TGlnaHRTaGFkb3cucHJvdG90eXBlLmlzU3BvdExpZ2h0U2hhZG93ID0gdHJ1ZTtcblxuXHRjbGFzcyBTcG90TGlnaHQgZXh0ZW5kcyBMaWdodCB7XG5cdFx0Y29uc3RydWN0b3IoY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UgPSAwLCBhbmdsZSA9IE1hdGguUEkgLyAzLCBwZW51bWJyYSA9IDAsIGRlY2F5ID0gMSkge1xuXHRcdFx0c3VwZXIoY29sb3IsIGludGVuc2l0eSk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnU3BvdExpZ2h0Jztcblx0XHRcdHRoaXMucG9zaXRpb24uY29weShPYmplY3QzRC5EZWZhdWx0VXApO1xuXHRcdFx0dGhpcy51cGRhdGVNYXRyaXgoKTtcblx0XHRcdHRoaXMudGFyZ2V0ID0gbmV3IE9iamVjdDNEKCk7XG5cdFx0XHR0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5cdFx0XHR0aGlzLmFuZ2xlID0gYW5nbGU7XG5cdFx0XHR0aGlzLnBlbnVtYnJhID0gcGVudW1icmE7XG5cdFx0XHR0aGlzLmRlY2F5ID0gZGVjYXk7IC8vIGZvciBwaHlzaWNhbGx5IGNvcnJlY3QgbGlnaHRzLCBzaG91bGQgYmUgMi5cblxuXHRcdFx0dGhpcy5zaGFkb3cgPSBuZXcgU3BvdExpZ2h0U2hhZG93KCk7XG5cdFx0fVxuXG5cdFx0Z2V0IHBvd2VyKCkge1xuXHRcdFx0Ly8gY29tcHV0ZSB0aGUgbGlnaHQncyBsdW1pbm91cyBwb3dlciAoaW4gbHVtZW5zKSBmcm9tIGl0cyBpbnRlbnNpdHkgKGluIGNhbmRlbGEpXG5cdFx0XHQvLyBieSBjb252ZW50aW9uIGZvciBhIHNwb3RsaWdodCwgbHVtaW5vdXMgcG93ZXIgKGxtKSA9IM+AICogbHVtaW5vdXMgaW50ZW5zaXR5IChjZClcblx0XHRcdHJldHVybiB0aGlzLmludGVuc2l0eSAqIE1hdGguUEk7XG5cdFx0fVxuXG5cdFx0c2V0IHBvd2VyKHBvd2VyKSB7XG5cdFx0XHQvLyBzZXQgdGhlIGxpZ2h0J3MgaW50ZW5zaXR5IChpbiBjYW5kZWxhKSBmcm9tIHRoZSBkZXNpcmVkIGx1bWlub3VzIHBvd2VyIChpbiBsdW1lbnMpXG5cdFx0XHR0aGlzLmludGVuc2l0eSA9IHBvd2VyIC8gTWF0aC5QSTtcblx0XHR9XG5cblx0XHRkaXNwb3NlKCkge1xuXHRcdFx0dGhpcy5zaGFkb3cuZGlzcG9zZSgpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLmRpc3RhbmNlID0gc291cmNlLmRpc3RhbmNlO1xuXHRcdFx0dGhpcy5hbmdsZSA9IHNvdXJjZS5hbmdsZTtcblx0XHRcdHRoaXMucGVudW1icmEgPSBzb3VyY2UucGVudW1icmE7XG5cdFx0XHR0aGlzLmRlY2F5ID0gc291cmNlLmRlY2F5O1xuXHRcdFx0dGhpcy50YXJnZXQgPSBzb3VyY2UudGFyZ2V0LmNsb25lKCk7XG5cdFx0XHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0U3BvdExpZ2h0LnByb3RvdHlwZS5pc1Nwb3RMaWdodCA9IHRydWU7XG5cblx0Y29uc3QgX3Byb2pTY3JlZW5NYXRyaXggPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDQoKTtcblxuXHRjb25zdCBfbGlnaHRQb3NpdGlvbldvcmxkID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX2xvb2tUYXJnZXQgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjbGFzcyBQb2ludExpZ2h0U2hhZG93IGV4dGVuZHMgTGlnaHRTaGFkb3cge1xuXHRcdGNvbnN0cnVjdG9yKCkge1xuXHRcdFx0c3VwZXIobmV3IFBlcnNwZWN0aXZlQ2FtZXJhKDkwLCAxLCAwLjUsIDUwMCkpO1xuXHRcdFx0dGhpcy5fZnJhbWVFeHRlbnRzID0gbmV3IFZlY3RvcjIoNCwgMik7XG5cdFx0XHR0aGlzLl92aWV3cG9ydENvdW50ID0gNjtcblx0XHRcdHRoaXMuX3ZpZXdwb3J0cyA9IFsvLyBUaGVzZSB2aWV3cG9ydHMgbWFwIGEgY3ViZS1tYXAgb250byBhIDJEIHRleHR1cmUgd2l0aCB0aGVcblx0XHRcdC8vIGZvbGxvd2luZyBvcmllbnRhdGlvbjpcblx0XHRcdC8vXG5cdFx0XHQvL1x0eHpYWlxuXHRcdFx0Ly9cdCB5IFlcblx0XHRcdC8vXG5cdFx0XHQvLyBYIC0gUG9zaXRpdmUgeCBkaXJlY3Rpb25cblx0XHRcdC8vIHggLSBOZWdhdGl2ZSB4IGRpcmVjdGlvblxuXHRcdFx0Ly8gWSAtIFBvc2l0aXZlIHkgZGlyZWN0aW9uXG5cdFx0XHQvLyB5IC0gTmVnYXRpdmUgeSBkaXJlY3Rpb25cblx0XHRcdC8vIFogLSBQb3NpdGl2ZSB6IGRpcmVjdGlvblxuXHRcdFx0Ly8geiAtIE5lZ2F0aXZlIHogZGlyZWN0aW9uXG5cdFx0XHQvLyBwb3NpdGl2ZSBYXG5cdFx0XHRuZXcgVmVjdG9yNCgyLCAxLCAxLCAxKSwgLy8gbmVnYXRpdmUgWFxuXHRcdFx0bmV3IFZlY3RvcjQoMCwgMSwgMSwgMSksIC8vIHBvc2l0aXZlIFpcblx0XHRcdG5ldyBWZWN0b3I0KDMsIDEsIDEsIDEpLCAvLyBuZWdhdGl2ZSBaXG5cdFx0XHRuZXcgVmVjdG9yNCgxLCAxLCAxLCAxKSwgLy8gcG9zaXRpdmUgWVxuXHRcdFx0bmV3IFZlY3RvcjQoMywgMCwgMSwgMSksIC8vIG5lZ2F0aXZlIFlcblx0XHRcdG5ldyBWZWN0b3I0KDEsIDAsIDEsIDEpXTtcblx0XHRcdHRoaXMuX2N1YmVEaXJlY3Rpb25zID0gW25ldyBWZWN0b3IzKDEsIDAsIDApLCBuZXcgVmVjdG9yMygtMSwgMCwgMCksIG5ldyBWZWN0b3IzKDAsIDAsIDEpLCBuZXcgVmVjdG9yMygwLCAwLCAtMSksIG5ldyBWZWN0b3IzKDAsIDEsIDApLCBuZXcgVmVjdG9yMygwLCAtMSwgMCldO1xuXHRcdFx0dGhpcy5fY3ViZVVwcyA9IFtuZXcgVmVjdG9yMygwLCAxLCAwKSwgbmV3IFZlY3RvcjMoMCwgMSwgMCksIG5ldyBWZWN0b3IzKDAsIDEsIDApLCBuZXcgVmVjdG9yMygwLCAxLCAwKSwgbmV3IFZlY3RvcjMoMCwgMCwgMSksIG5ldyBWZWN0b3IzKDAsIDAsIC0xKV07XG5cdFx0fVxuXG5cdFx0dXBkYXRlTWF0cmljZXMobGlnaHQsIHZpZXdwb3J0SW5kZXggPSAwKSB7XG5cdFx0XHRjb25zdCBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcblx0XHRcdGNvbnN0IHNoYWRvd01hdHJpeCA9IHRoaXMubWF0cml4O1xuXHRcdFx0Y29uc3QgZmFyID0gbGlnaHQuZGlzdGFuY2UgfHwgY2FtZXJhLmZhcjtcblxuXHRcdFx0aWYgKGZhciAhPT0gY2FtZXJhLmZhcikge1xuXHRcdFx0XHRjYW1lcmEuZmFyID0gZmFyO1xuXHRcdFx0XHRjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRfbGlnaHRQb3NpdGlvbldvcmxkLnNldEZyb21NYXRyaXhQb3NpdGlvbihsaWdodC5tYXRyaXhXb3JsZCk7XG5cblx0XHRcdGNhbWVyYS5wb3NpdGlvbi5jb3B5KF9saWdodFBvc2l0aW9uV29ybGQpO1xuXG5cdFx0XHRfbG9va1RhcmdldC5jb3B5KGNhbWVyYS5wb3NpdGlvbik7XG5cblx0XHRcdF9sb29rVGFyZ2V0LmFkZCh0aGlzLl9jdWJlRGlyZWN0aW9uc1t2aWV3cG9ydEluZGV4XSk7XG5cblx0XHRcdGNhbWVyYS51cC5jb3B5KHRoaXMuX2N1YmVVcHNbdmlld3BvcnRJbmRleF0pO1xuXHRcdFx0Y2FtZXJhLmxvb2tBdChfbG9va1RhcmdldCk7XG5cdFx0XHRjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcblx0XHRcdHNoYWRvd01hdHJpeC5tYWtlVHJhbnNsYXRpb24oLV9saWdodFBvc2l0aW9uV29ybGQueCwgLV9saWdodFBvc2l0aW9uV29ybGQueSwgLV9saWdodFBvc2l0aW9uV29ybGQueik7XG5cblx0XHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UpO1xuXG5cdFx0XHR0aGlzLl9mcnVzdHVtLnNldEZyb21Qcm9qZWN0aW9uTWF0cml4KF9wcm9qU2NyZWVuTWF0cml4KTtcblx0XHR9XG5cblx0fVxuXG5cdFBvaW50TGlnaHRTaGFkb3cucHJvdG90eXBlLmlzUG9pbnRMaWdodFNoYWRvdyA9IHRydWU7XG5cblx0Y2xhc3MgUG9pbnRMaWdodCBleHRlbmRzIExpZ2h0IHtcblx0XHRjb25zdHJ1Y3Rvcihjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSA9IDAsIGRlY2F5ID0gMSkge1xuXHRcdFx0c3VwZXIoY29sb3IsIGludGVuc2l0eSk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnUG9pbnRMaWdodCc7XG5cdFx0XHR0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5cdFx0XHR0aGlzLmRlY2F5ID0gZGVjYXk7IC8vIGZvciBwaHlzaWNhbGx5IGNvcnJlY3QgbGlnaHRzLCBzaG91bGQgYmUgMi5cblxuXHRcdFx0dGhpcy5zaGFkb3cgPSBuZXcgUG9pbnRMaWdodFNoYWRvdygpO1xuXHRcdH1cblxuXHRcdGdldCBwb3dlcigpIHtcblx0XHRcdC8vIGNvbXB1dGUgdGhlIGxpZ2h0J3MgbHVtaW5vdXMgcG93ZXIgKGluIGx1bWVucykgZnJvbSBpdHMgaW50ZW5zaXR5IChpbiBjYW5kZWxhKVxuXHRcdFx0Ly8gZm9yIGFuIGlzb3Ryb3BpYyBsaWdodCBzb3VyY2UsIGx1bWlub3VzIHBvd2VyIChsbSkgPSA0IM+AIGx1bWlub3VzIGludGVuc2l0eSAoY2QpXG5cdFx0XHRyZXR1cm4gdGhpcy5pbnRlbnNpdHkgKiA0ICogTWF0aC5QSTtcblx0XHR9XG5cblx0XHRzZXQgcG93ZXIocG93ZXIpIHtcblx0XHRcdC8vIHNldCB0aGUgbGlnaHQncyBpbnRlbnNpdHkgKGluIGNhbmRlbGEpIGZyb20gdGhlIGRlc2lyZWQgbHVtaW5vdXMgcG93ZXIgKGluIGx1bWVucylcblx0XHRcdHRoaXMuaW50ZW5zaXR5ID0gcG93ZXIgLyAoNCAqIE1hdGguUEkpO1xuXHRcdH1cblxuXHRcdGRpc3Bvc2UoKSB7XG5cdFx0XHR0aGlzLnNoYWRvdy5kaXNwb3NlKCk7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdHRoaXMuZGlzdGFuY2UgPSBzb3VyY2UuZGlzdGFuY2U7XG5cdFx0XHR0aGlzLmRlY2F5ID0gc291cmNlLmRlY2F5O1xuXHRcdFx0dGhpcy5zaGFkb3cgPSBzb3VyY2Uuc2hhZG93LmNsb25lKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0fVxuXG5cdFBvaW50TGlnaHQucHJvdG90eXBlLmlzUG9pbnRMaWdodCA9IHRydWU7XG5cblx0Y2xhc3MgRGlyZWN0aW9uYWxMaWdodFNoYWRvdyBleHRlbmRzIExpZ2h0U2hhZG93IHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHN1cGVyKG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoLTUsIDUsIDUsIC01LCAwLjUsIDUwMCkpO1xuXHRcdH1cblxuXHR9XG5cblx0RGlyZWN0aW9uYWxMaWdodFNoYWRvdy5wcm90b3R5cGUuaXNEaXJlY3Rpb25hbExpZ2h0U2hhZG93ID0gdHJ1ZTtcblxuXHRjbGFzcyBEaXJlY3Rpb25hbExpZ2h0IGV4dGVuZHMgTGlnaHQge1xuXHRcdGNvbnN0cnVjdG9yKGNvbG9yLCBpbnRlbnNpdHkpIHtcblx0XHRcdHN1cGVyKGNvbG9yLCBpbnRlbnNpdHkpO1xuXHRcdFx0dGhpcy50eXBlID0gJ0RpcmVjdGlvbmFsTGlnaHQnO1xuXHRcdFx0dGhpcy5wb3NpdGlvbi5jb3B5KE9iamVjdDNELkRlZmF1bHRVcCk7XG5cdFx0XHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXHRcdFx0dGhpcy50YXJnZXQgPSBuZXcgT2JqZWN0M0QoKTtcblx0XHRcdHRoaXMuc2hhZG93ID0gbmV3IERpcmVjdGlvbmFsTGlnaHRTaGFkb3coKTtcblx0XHR9XG5cblx0XHRkaXNwb3NlKCkge1xuXHRcdFx0dGhpcy5zaGFkb3cuZGlzcG9zZSgpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLnRhcmdldCA9IHNvdXJjZS50YXJnZXQuY2xvbmUoKTtcblx0XHRcdHRoaXMuc2hhZG93ID0gc291cmNlLnNoYWRvdy5jbG9uZSgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHREaXJlY3Rpb25hbExpZ2h0LnByb3RvdHlwZS5pc0RpcmVjdGlvbmFsTGlnaHQgPSB0cnVlO1xuXG5cdGNsYXNzIEFtYmllbnRMaWdodCBleHRlbmRzIExpZ2h0IHtcblx0XHRjb25zdHJ1Y3Rvcihjb2xvciwgaW50ZW5zaXR5KSB7XG5cdFx0XHRzdXBlcihjb2xvciwgaW50ZW5zaXR5KTtcblx0XHRcdHRoaXMudHlwZSA9ICdBbWJpZW50TGlnaHQnO1xuXHRcdH1cblxuXHR9XG5cblx0QW1iaWVudExpZ2h0LnByb3RvdHlwZS5pc0FtYmllbnRMaWdodCA9IHRydWU7XG5cblx0Y2xhc3MgUmVjdEFyZWFMaWdodCBleHRlbmRzIExpZ2h0IHtcblx0XHRjb25zdHJ1Y3Rvcihjb2xvciwgaW50ZW5zaXR5LCB3aWR0aCA9IDEwLCBoZWlnaHQgPSAxMCkge1xuXHRcdFx0c3VwZXIoY29sb3IsIGludGVuc2l0eSk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnUmVjdEFyZWFMaWdodCc7XG5cdFx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblx0XHR9XG5cblx0XHRnZXQgcG93ZXIoKSB7XG5cdFx0XHQvLyBjb21wdXRlIHRoZSBsaWdodCdzIGx1bWlub3VzIHBvd2VyIChpbiBsdW1lbnMpIGZyb20gaXRzIGludGVuc2l0eSAoaW4gbml0cylcblx0XHRcdHJldHVybiB0aGlzLmludGVuc2l0eSAqIHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCAqIE1hdGguUEk7XG5cdFx0fVxuXG5cdFx0c2V0IHBvd2VyKHBvd2VyKSB7XG5cdFx0XHQvLyBzZXQgdGhlIGxpZ2h0J3MgaW50ZW5zaXR5IChpbiBuaXRzKSBmcm9tIHRoZSBkZXNpcmVkIGx1bWlub3VzIHBvd2VyIChpbiBsdW1lbnMpXG5cdFx0XHR0aGlzLmludGVuc2l0eSA9IHBvd2VyIC8gKHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCAqIE1hdGguUEkpO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLndpZHRoID0gc291cmNlLndpZHRoO1xuXHRcdFx0dGhpcy5oZWlnaHQgPSBzb3VyY2UuaGVpZ2h0O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dG9KU09OKG1ldGEpIHtcblx0XHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04obWV0YSk7XG5cdFx0XHRkYXRhLm9iamVjdC53aWR0aCA9IHRoaXMud2lkdGg7XG5cdFx0XHRkYXRhLm9iamVjdC5oZWlnaHQgPSB0aGlzLmhlaWdodDtcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHR9XG5cblx0UmVjdEFyZWFMaWdodC5wcm90b3R5cGUuaXNSZWN0QXJlYUxpZ2h0ID0gdHJ1ZTtcblxuXHQvKipcblx0ICogUHJpbWFyeSByZWZlcmVuY2U6XG5cdCAqXHQgaHR0cHM6Ly9ncmFwaGljcy5zdGFuZm9yZC5lZHUvcGFwZXJzL2Vudm1hcC9lbnZtYXAucGRmXG5cdCAqXG5cdCAqIFNlY29uZGFyeSByZWZlcmVuY2U6XG5cdCAqXHQgaHR0cHM6Ly93d3cucHBzbG9hbi5vcmcvcHVibGljYXRpb25zL1N0dXBpZFNIMzYucGRmXG5cdCAqL1xuXHQvLyAzLWJhbmQgU0ggZGVmaW5lZCBieSA5IGNvZWZmaWNpZW50c1xuXG5cdGNsYXNzIFNwaGVyaWNhbEhhcm1vbmljczMge1xuXHRcdGNvbnN0cnVjdG9yKCkge1xuXHRcdFx0dGhpcy5jb2VmZmljaWVudHMgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcblx0XHRcdFx0dGhpcy5jb2VmZmljaWVudHMucHVzaChuZXcgVmVjdG9yMygpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzZXQoY29lZmZpY2llbnRzKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuXHRcdFx0XHR0aGlzLmNvZWZmaWNpZW50c1tpXS5jb3B5KGNvZWZmaWNpZW50c1tpXSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHplcm8oKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuXHRcdFx0XHR0aGlzLmNvZWZmaWNpZW50c1tpXS5zZXQoMCwgMCwgMCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0gLy8gZ2V0IHRoZSByYWRpYW5jZSBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBub3JtYWxcblx0XHQvLyB0YXJnZXQgaXMgYSBWZWN0b3IzXG5cblxuXHRcdGdldEF0KG5vcm1hbCwgdGFyZ2V0KSB7XG5cdFx0XHQvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aFxuXHRcdFx0Y29uc3QgeCA9IG5vcm1hbC54LFxuXHRcdFx0XHRcdFx0eSA9IG5vcm1hbC55LFxuXHRcdFx0XHRcdFx0eiA9IG5vcm1hbC56O1xuXHRcdFx0Y29uc3QgY29lZmYgPSB0aGlzLmNvZWZmaWNpZW50czsgLy8gYmFuZCAwXG5cblx0XHRcdHRhcmdldC5jb3B5KGNvZWZmWzBdKS5tdWx0aXBseVNjYWxhcigwLjI4MjA5NSk7IC8vIGJhbmQgMVxuXG5cdFx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKGNvZWZmWzFdLCAwLjQ4ODYwMyAqIHkpO1xuXHRcdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZlsyXSwgMC40ODg2MDMgKiB6KTtcblx0XHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoY29lZmZbM10sIDAuNDg4NjAzICogeCk7IC8vIGJhbmQgMlxuXG5cdFx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKGNvZWZmWzRdLCAxLjA5MjU0OCAqICh4ICogeSkpO1xuXHRcdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZls1XSwgMS4wOTI1NDggKiAoeSAqIHopKTtcblx0XHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoY29lZmZbNl0sIDAuMzE1MzkyICogKDMuMCAqIHogKiB6IC0gMS4wKSk7XG5cdFx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKGNvZWZmWzddLCAxLjA5MjU0OCAqICh4ICogeikpO1xuXHRcdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZls4XSwgMC41NDYyNzQgKiAoeCAqIHggLSB5ICogeSkpO1xuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9IC8vIGdldCB0aGUgaXJyYWRpYW5jZSAocmFkaWFuY2UgY29udm9sdmVkIHdpdGggY29zaW5lIGxvYmUpIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG5vcm1hbFxuXHRcdC8vIHRhcmdldCBpcyBhIFZlY3RvcjNcblx0XHQvLyBodHRwczovL2dyYXBoaWNzLnN0YW5mb3JkLmVkdS9wYXBlcnMvZW52bWFwL2Vudm1hcC5wZGZcblxuXG5cdFx0Z2V0SXJyYWRpYW5jZUF0KG5vcm1hbCwgdGFyZ2V0KSB7XG5cdFx0XHQvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aFxuXHRcdFx0Y29uc3QgeCA9IG5vcm1hbC54LFxuXHRcdFx0XHRcdFx0eSA9IG5vcm1hbC55LFxuXHRcdFx0XHRcdFx0eiA9IG5vcm1hbC56O1xuXHRcdFx0Y29uc3QgY29lZmYgPSB0aGlzLmNvZWZmaWNpZW50czsgLy8gYmFuZCAwXG5cblx0XHRcdHRhcmdldC5jb3B5KGNvZWZmWzBdKS5tdWx0aXBseVNjYWxhcigwLjg4NjIyNyk7IC8vIM+AICogMC4yODIwOTVcblx0XHRcdC8vIGJhbmQgMVxuXG5cdFx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKGNvZWZmWzFdLCAyLjAgKiAwLjUxMTY2NCAqIHkpOyAvLyAoIDIgKiDPgCAvIDMgKSAqIDAuNDg4NjAzXG5cblx0XHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoY29lZmZbMl0sIDIuMCAqIDAuNTExNjY0ICogeik7XG5cdFx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKGNvZWZmWzNdLCAyLjAgKiAwLjUxMTY2NCAqIHgpOyAvLyBiYW5kIDJcblxuXHRcdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZls0XSwgMi4wICogMC40MjkwNDMgKiB4ICogeSk7IC8vICggz4AgLyA0ICkgKiAxLjA5MjU0OFxuXG5cdFx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKGNvZWZmWzVdLCAyLjAgKiAwLjQyOTA0MyAqIHkgKiB6KTtcblx0XHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoY29lZmZbNl0sIDAuNzQzMTI1ICogeiAqIHogLSAwLjI0NzcwOCk7IC8vICggz4AgLyA0ICkgKiAwLjMxNTM5MiAqIDNcblxuXHRcdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZls3XSwgMi4wICogMC40MjkwNDMgKiB4ICogeik7XG5cdFx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKGNvZWZmWzhdLCAwLjQyOTA0MyAqICh4ICogeCAtIHkgKiB5KSk7IC8vICggz4AgLyA0ICkgKiAwLjU0NjI3NFxuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdH1cblxuXHRcdGFkZChzaCkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcblx0XHRcdFx0dGhpcy5jb2VmZmljaWVudHNbaV0uYWRkKHNoLmNvZWZmaWNpZW50c1tpXSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGFkZFNjYWxlZFNIKHNoLCBzKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuXHRcdFx0XHR0aGlzLmNvZWZmaWNpZW50c1tpXS5hZGRTY2FsZWRWZWN0b3Ioc2guY29lZmZpY2llbnRzW2ldLCBzKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2NhbGUocykge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcblx0XHRcdFx0dGhpcy5jb2VmZmljaWVudHNbaV0ubXVsdGlwbHlTY2FsYXIocyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGxlcnAoc2gsIGFscGhhKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuXHRcdFx0XHR0aGlzLmNvZWZmaWNpZW50c1tpXS5sZXJwKHNoLmNvZWZmaWNpZW50c1tpXSwgYWxwaGEpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRlcXVhbHMoc2gpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG5cdFx0XHRcdGlmICghdGhpcy5jb2VmZmljaWVudHNbaV0uZXF1YWxzKHNoLmNvZWZmaWNpZW50c1tpXSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Y29weShzaCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0KHNoLmNvZWZmaWNpZW50cyk7XG5cdFx0fVxuXG5cdFx0Y2xvbmUoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpO1xuXHRcdH1cblxuXHRcdGZyb21BcnJheShhcnJheSwgb2Zmc2V0ID0gMCkge1xuXHRcdFx0Y29uc3QgY29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG5cdFx0XHRcdGNvZWZmaWNpZW50c1tpXS5mcm9tQXJyYXkoYXJyYXksIG9mZnNldCArIGkgKiAzKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dG9BcnJheShhcnJheSA9IFtdLCBvZmZzZXQgPSAwKSB7XG5cdFx0XHRjb25zdCBjb2VmZmljaWVudHMgPSB0aGlzLmNvZWZmaWNpZW50cztcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcblx0XHRcdFx0Y29lZmZpY2llbnRzW2ldLnRvQXJyYXkoYXJyYXksIG9mZnNldCArIGkgKiAzKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGFycmF5O1xuXHRcdH0gLy8gZXZhbHVhdGUgdGhlIGJhc2lzIGZ1bmN0aW9uc1xuXHRcdC8vIHNoQmFzaXMgaXMgYW4gQXJyYXlbIDkgXVxuXG5cblx0XHRzdGF0aWMgZ2V0QmFzaXNBdChub3JtYWwsIHNoQmFzaXMpIHtcblx0XHRcdC8vIG5vcm1hbCBpcyBhc3N1bWVkIHRvIGJlIHVuaXQgbGVuZ3RoXG5cdFx0XHRjb25zdCB4ID0gbm9ybWFsLngsXG5cdFx0XHRcdFx0XHR5ID0gbm9ybWFsLnksXG5cdFx0XHRcdFx0XHR6ID0gbm9ybWFsLno7IC8vIGJhbmQgMFxuXG5cdFx0XHRzaEJhc2lzWzBdID0gMC4yODIwOTU7IC8vIGJhbmQgMVxuXG5cdFx0XHRzaEJhc2lzWzFdID0gMC40ODg2MDMgKiB5O1xuXHRcdFx0c2hCYXNpc1syXSA9IDAuNDg4NjAzICogejtcblx0XHRcdHNoQmFzaXNbM10gPSAwLjQ4ODYwMyAqIHg7IC8vIGJhbmQgMlxuXG5cdFx0XHRzaEJhc2lzWzRdID0gMS4wOTI1NDggKiB4ICogeTtcblx0XHRcdHNoQmFzaXNbNV0gPSAxLjA5MjU0OCAqIHkgKiB6O1xuXHRcdFx0c2hCYXNpc1s2XSA9IDAuMzE1MzkyICogKDMgKiB6ICogeiAtIDEpO1xuXHRcdFx0c2hCYXNpc1s3XSA9IDEuMDkyNTQ4ICogeCAqIHo7XG5cdFx0XHRzaEJhc2lzWzhdID0gMC41NDYyNzQgKiAoeCAqIHggLSB5ICogeSk7XG5cdFx0fVxuXG5cdH1cblxuXHRTcGhlcmljYWxIYXJtb25pY3MzLnByb3RvdHlwZS5pc1NwaGVyaWNhbEhhcm1vbmljczMgPSB0cnVlO1xuXG5cdGNsYXNzIExpZ2h0UHJvYmUgZXh0ZW5kcyBMaWdodCB7XG5cdFx0Y29uc3RydWN0b3Ioc2ggPSBuZXcgU3BoZXJpY2FsSGFybW9uaWNzMygpLCBpbnRlbnNpdHkgPSAxKSB7XG5cdFx0XHRzdXBlcih1bmRlZmluZWQsIGludGVuc2l0eSk7XG5cdFx0XHR0aGlzLnNoID0gc2g7XG5cdFx0fVxuXG5cdFx0Y29weShzb3VyY2UpIHtcblx0XHRcdHN1cGVyLmNvcHkoc291cmNlKTtcblx0XHRcdHRoaXMuc2guY29weShzb3VyY2Uuc2gpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZnJvbUpTT04oanNvbikge1xuXHRcdFx0dGhpcy5pbnRlbnNpdHkgPSBqc29uLmludGVuc2l0eTsgLy8gVE9ETzogTW92ZSB0aGlzIGJpdCB0byBMaWdodC5mcm9tSlNPTigpO1xuXG5cdFx0XHR0aGlzLnNoLmZyb21BcnJheShqc29uLnNoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRvSlNPTihtZXRhKSB7XG5cdFx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKG1ldGEpO1xuXHRcdFx0ZGF0YS5vYmplY3Quc2ggPSB0aGlzLnNoLnRvQXJyYXkoKTtcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHR9XG5cblx0TGlnaHRQcm9iZS5wcm90b3R5cGUuaXNMaWdodFByb2JlID0gdHJ1ZTtcblxuXHRjbGFzcyBNYXRlcmlhbExvYWRlciBleHRlbmRzIExvYWRlciB7XG5cdFx0Y29uc3RydWN0b3IobWFuYWdlcikge1xuXHRcdFx0c3VwZXIobWFuYWdlcik7XG5cdFx0XHR0aGlzLnRleHR1cmVzID0ge307XG5cdFx0fVxuXG5cdFx0bG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuXHRcdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoc2NvcGUubWFuYWdlcik7XG5cdFx0XHRsb2FkZXIuc2V0UGF0aChzY29wZS5wYXRoKTtcblx0XHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHNjb3BlLnJlcXVlc3RIZWFkZXIpO1xuXHRcdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyhzY29wZS53aXRoQ3JlZGVudGlhbHMpO1xuXHRcdFx0bG9hZGVyLmxvYWQodXJsLCBmdW5jdGlvbiAodGV4dCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdG9uTG9hZChzY29wZS5wYXJzZShKU09OLnBhcnNlKHRleHQpKSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRpZiAob25FcnJvcikge1xuXHRcdFx0XHRcdFx0b25FcnJvcihlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcihlKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yKTtcblx0XHR9XG5cblx0XHRwYXJzZShqc29uKSB7XG5cdFx0XHRjb25zdCB0ZXh0dXJlcyA9IHRoaXMudGV4dHVyZXM7XG5cblx0XHRcdGZ1bmN0aW9uIGdldFRleHR1cmUobmFtZSkge1xuXHRcdFx0XHRpZiAodGV4dHVyZXNbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuTWF0ZXJpYWxMb2FkZXI6IFVuZGVmaW5lZCB0ZXh0dXJlJywgbmFtZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGV4dHVyZXNbbmFtZV07XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IE1hdGVyaWFsc1tqc29uLnR5cGVdKCk7XG5cdFx0XHRpZiAoanNvbi51dWlkICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnV1aWQgPSBqc29uLnV1aWQ7XG5cdFx0XHRpZiAoanNvbi5uYW1lICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLm5hbWUgPSBqc29uLm5hbWU7XG5cdFx0XHRpZiAoanNvbi5jb2xvciAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsLmNvbG9yICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmNvbG9yLnNldEhleChqc29uLmNvbG9yKTtcblx0XHRcdGlmIChqc29uLnJvdWdobmVzcyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5yb3VnaG5lc3MgPSBqc29uLnJvdWdobmVzcztcblx0XHRcdGlmIChqc29uLm1ldGFsbmVzcyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5tZXRhbG5lc3MgPSBqc29uLm1ldGFsbmVzcztcblx0XHRcdGlmIChqc29uLnNoZWVuICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnNoZWVuID0ganNvbi5zaGVlbjtcblx0XHRcdGlmIChqc29uLnNoZWVuQ29sb3IgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc2hlZW5Db2xvciA9IG5ldyBDb2xvcigpLnNldEhleChqc29uLnNoZWVuQ29sb3IpO1xuXHRcdFx0aWYgKGpzb24uc2hlZW5Sb3VnaG5lc3MgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3MgPSBqc29uLnNoZWVuUm91Z2huZXNzO1xuXHRcdFx0aWYgKGpzb24uZW1pc3NpdmUgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbC5lbWlzc2l2ZSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5lbWlzc2l2ZS5zZXRIZXgoanNvbi5lbWlzc2l2ZSk7XG5cdFx0XHRpZiAoanNvbi5zcGVjdWxhciAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsLnNwZWN1bGFyICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnNwZWN1bGFyLnNldEhleChqc29uLnNwZWN1bGFyKTtcblx0XHRcdGlmIChqc29uLnNwZWN1bGFySW50ZW5zaXR5ICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnNwZWN1bGFySW50ZW5zaXR5ID0ganNvbi5zcGVjdWxhckludGVuc2l0eTtcblx0XHRcdGlmIChqc29uLnNwZWN1bGFyQ29sb3IgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbC5zcGVjdWxhckNvbG9yICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3Iuc2V0SGV4KGpzb24uc3BlY3VsYXJDb2xvcik7XG5cdFx0XHRpZiAoanNvbi5zaGluaW5lc3MgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc2hpbmluZXNzID0ganNvbi5zaGluaW5lc3M7XG5cdFx0XHRpZiAoanNvbi5jbGVhcmNvYXQgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuY2xlYXJjb2F0ID0ganNvbi5jbGVhcmNvYXQ7XG5cdFx0XHRpZiAoanNvbi5jbGVhcmNvYXRSb3VnaG5lc3MgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzID0ganNvbi5jbGVhcmNvYXRSb3VnaG5lc3M7XG5cdFx0XHRpZiAoanNvbi50cmFuc21pc3Npb24gIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwudHJhbnNtaXNzaW9uID0ganNvbi50cmFuc21pc3Npb247XG5cdFx0XHRpZiAoanNvbi50aGlja25lc3MgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwudGhpY2tuZXNzID0ganNvbi50aGlja25lc3M7XG5cdFx0XHRpZiAoanNvbi5hdHRlbnVhdGlvbkRpc3RhbmNlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmF0dGVudWF0aW9uRGlzdGFuY2UgPSBqc29uLmF0dGVudWF0aW9uRGlzdGFuY2U7XG5cdFx0XHRpZiAoanNvbi5hdHRlbnVhdGlvbkNvbG9yICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWwuYXR0ZW51YXRpb25Db2xvciAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5hdHRlbnVhdGlvbkNvbG9yLnNldEhleChqc29uLmF0dGVudWF0aW9uQ29sb3IpO1xuXHRcdFx0aWYgKGpzb24uZm9nICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmZvZyA9IGpzb24uZm9nO1xuXHRcdFx0aWYgKGpzb24uZmxhdFNoYWRpbmcgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuZmxhdFNoYWRpbmcgPSBqc29uLmZsYXRTaGFkaW5nO1xuXHRcdFx0aWYgKGpzb24uYmxlbmRpbmcgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuYmxlbmRpbmcgPSBqc29uLmJsZW5kaW5nO1xuXHRcdFx0aWYgKGpzb24uY29tYmluZSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5jb21iaW5lID0ganNvbi5jb21iaW5lO1xuXHRcdFx0aWYgKGpzb24uc2lkZSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5zaWRlID0ganNvbi5zaWRlO1xuXHRcdFx0aWYgKGpzb24uc2hhZG93U2lkZSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5zaGFkb3dTaWRlID0ganNvbi5zaGFkb3dTaWRlO1xuXHRcdFx0aWYgKGpzb24ub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5vcGFjaXR5ID0ganNvbi5vcGFjaXR5O1xuXHRcdFx0aWYgKGpzb24uZm9ybWF0ICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmZvcm1hdCA9IGpzb24uZm9ybWF0O1xuXHRcdFx0aWYgKGpzb24udHJhbnNwYXJlbnQgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwudHJhbnNwYXJlbnQgPSBqc29uLnRyYW5zcGFyZW50O1xuXHRcdFx0aWYgKGpzb24uYWxwaGFUZXN0ICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmFscGhhVGVzdCA9IGpzb24uYWxwaGFUZXN0O1xuXHRcdFx0aWYgKGpzb24uZGVwdGhUZXN0ICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmRlcHRoVGVzdCA9IGpzb24uZGVwdGhUZXN0O1xuXHRcdFx0aWYgKGpzb24uZGVwdGhXcml0ZSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5kZXB0aFdyaXRlID0ganNvbi5kZXB0aFdyaXRlO1xuXHRcdFx0aWYgKGpzb24uY29sb3JXcml0ZSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5jb2xvcldyaXRlID0ganNvbi5jb2xvcldyaXRlO1xuXHRcdFx0aWYgKGpzb24uc3RlbmNpbFdyaXRlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnN0ZW5jaWxXcml0ZSA9IGpzb24uc3RlbmNpbFdyaXRlO1xuXHRcdFx0aWYgKGpzb24uc3RlbmNpbFdyaXRlTWFzayAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5zdGVuY2lsV3JpdGVNYXNrID0ganNvbi5zdGVuY2lsV3JpdGVNYXNrO1xuXHRcdFx0aWYgKGpzb24uc3RlbmNpbEZ1bmMgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3RlbmNpbEZ1bmMgPSBqc29uLnN0ZW5jaWxGdW5jO1xuXHRcdFx0aWYgKGpzb24uc3RlbmNpbFJlZiAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5zdGVuY2lsUmVmID0ganNvbi5zdGVuY2lsUmVmO1xuXHRcdFx0aWYgKGpzb24uc3RlbmNpbEZ1bmNNYXNrICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnN0ZW5jaWxGdW5jTWFzayA9IGpzb24uc3RlbmNpbEZ1bmNNYXNrO1xuXHRcdFx0aWYgKGpzb24uc3RlbmNpbEZhaWwgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3RlbmNpbEZhaWwgPSBqc29uLnN0ZW5jaWxGYWlsO1xuXHRcdFx0aWYgKGpzb24uc3RlbmNpbFpGYWlsICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnN0ZW5jaWxaRmFpbCA9IGpzb24uc3RlbmNpbFpGYWlsO1xuXHRcdFx0aWYgKGpzb24uc3RlbmNpbFpQYXNzICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnN0ZW5jaWxaUGFzcyA9IGpzb24uc3RlbmNpbFpQYXNzO1xuXHRcdFx0aWYgKGpzb24ud2lyZWZyYW1lICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLndpcmVmcmFtZSA9IGpzb24ud2lyZWZyYW1lO1xuXHRcdFx0aWYgKGpzb24ud2lyZWZyYW1lTGluZXdpZHRoICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IGpzb24ud2lyZWZyYW1lTGluZXdpZHRoO1xuXHRcdFx0aWYgKGpzb24ud2lyZWZyYW1lTGluZWNhcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC53aXJlZnJhbWVMaW5lY2FwID0ganNvbi53aXJlZnJhbWVMaW5lY2FwO1xuXHRcdFx0aWYgKGpzb24ud2lyZWZyYW1lTGluZWpvaW4gIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gPSBqc29uLndpcmVmcmFtZUxpbmVqb2luO1xuXHRcdFx0aWYgKGpzb24ucm90YXRpb24gIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwucm90YXRpb24gPSBqc29uLnJvdGF0aW9uO1xuXHRcdFx0aWYgKGpzb24ubGluZXdpZHRoICE9PSAxKSBtYXRlcmlhbC5saW5ld2lkdGggPSBqc29uLmxpbmV3aWR0aDtcblx0XHRcdGlmIChqc29uLmRhc2hTaXplICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmRhc2hTaXplID0ganNvbi5kYXNoU2l6ZTtcblx0XHRcdGlmIChqc29uLmdhcFNpemUgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuZ2FwU2l6ZSA9IGpzb24uZ2FwU2l6ZTtcblx0XHRcdGlmIChqc29uLnNjYWxlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnNjYWxlID0ganNvbi5zY2FsZTtcblx0XHRcdGlmIChqc29uLnBvbHlnb25PZmZzZXQgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwucG9seWdvbk9mZnNldCA9IGpzb24ucG9seWdvbk9mZnNldDtcblx0XHRcdGlmIChqc29uLnBvbHlnb25PZmZzZXRGYWN0b3IgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwucG9seWdvbk9mZnNldEZhY3RvciA9IGpzb24ucG9seWdvbk9mZnNldEZhY3Rvcjtcblx0XHRcdGlmIChqc29uLnBvbHlnb25PZmZzZXRVbml0cyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgPSBqc29uLnBvbHlnb25PZmZzZXRVbml0cztcblx0XHRcdGlmIChqc29uLmRpdGhlcmluZyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5kaXRoZXJpbmcgPSBqc29uLmRpdGhlcmluZztcblx0XHRcdGlmIChqc29uLmFscGhhVG9Db3ZlcmFnZSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5hbHBoYVRvQ292ZXJhZ2UgPSBqc29uLmFscGhhVG9Db3ZlcmFnZTtcblx0XHRcdGlmIChqc29uLnByZW11bHRpcGxpZWRBbHBoYSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5wcmVtdWx0aXBsaWVkQWxwaGEgPSBqc29uLnByZW11bHRpcGxpZWRBbHBoYTtcblx0XHRcdGlmIChqc29uLnZpc2libGUgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwudmlzaWJsZSA9IGpzb24udmlzaWJsZTtcblx0XHRcdGlmIChqc29uLnRvbmVNYXBwZWQgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwudG9uZU1hcHBlZCA9IGpzb24udG9uZU1hcHBlZDtcblx0XHRcdGlmIChqc29uLnVzZXJEYXRhICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnVzZXJEYXRhID0ganNvbi51c2VyRGF0YTtcblxuXHRcdFx0aWYgKGpzb24udmVydGV4Q29sb3JzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBqc29uLnZlcnRleENvbG9ycyA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSBqc29uLnZlcnRleENvbG9ycyA+IDAgPyB0cnVlIDogZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0ganNvbi52ZXJ0ZXhDb2xvcnM7XG5cdFx0XHRcdH1cblx0XHRcdH0gLy8gU2hhZGVyIE1hdGVyaWFsXG5cblxuXHRcdFx0aWYgKGpzb24udW5pZm9ybXMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRmb3IgKGNvbnN0IG5hbWUgaW4ganNvbi51bmlmb3Jtcykge1xuXHRcdFx0XHRcdGNvbnN0IHVuaWZvcm0gPSBqc29uLnVuaWZvcm1zW25hbWVdO1xuXHRcdFx0XHRcdG1hdGVyaWFsLnVuaWZvcm1zW25hbWVdID0ge307XG5cblx0XHRcdFx0XHRzd2l0Y2ggKHVuaWZvcm0udHlwZSkge1xuXHRcdFx0XHRcdFx0Y2FzZSAndCc6XG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsLnVuaWZvcm1zW25hbWVdLnZhbHVlID0gZ2V0VGV4dHVyZSh1bmlmb3JtLnZhbHVlKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2MnOlxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbC51bmlmb3Jtc1tuYW1lXS52YWx1ZSA9IG5ldyBDb2xvcigpLnNldEhleCh1bmlmb3JtLnZhbHVlKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3YyJzpcblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbbmFtZV0udmFsdWUgPSBuZXcgVmVjdG9yMigpLmZyb21BcnJheSh1bmlmb3JtLnZhbHVlKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3YzJzpcblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbbmFtZV0udmFsdWUgPSBuZXcgVmVjdG9yMygpLmZyb21BcnJheSh1bmlmb3JtLnZhbHVlKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3Y0Jzpcblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbbmFtZV0udmFsdWUgPSBuZXcgVmVjdG9yNCgpLmZyb21BcnJheSh1bmlmb3JtLnZhbHVlKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ20zJzpcblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbbmFtZV0udmFsdWUgPSBuZXcgTWF0cml4MygpLmZyb21BcnJheSh1bmlmb3JtLnZhbHVlKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ200Jzpcblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbbmFtZV0udmFsdWUgPSBuZXcgTWF0cml4NCgpLmZyb21BcnJheSh1bmlmb3JtLnZhbHVlKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsLnVuaWZvcm1zW25hbWVdLnZhbHVlID0gdW5pZm9ybS52YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGpzb24uZGVmaW5lcyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5kZWZpbmVzID0ganNvbi5kZWZpbmVzO1xuXHRcdFx0aWYgKGpzb24udmVydGV4U2hhZGVyICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnZlcnRleFNoYWRlciA9IGpzb24udmVydGV4U2hhZGVyO1xuXHRcdFx0aWYgKGpzb24uZnJhZ21lbnRTaGFkZXIgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgPSBqc29uLmZyYWdtZW50U2hhZGVyO1xuXG5cdFx0XHRpZiAoanNvbi5leHRlbnNpb25zICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Zm9yIChjb25zdCBrZXkgaW4ganNvbi5leHRlbnNpb25zKSB7XG5cdFx0XHRcdFx0bWF0ZXJpYWwuZXh0ZW5zaW9uc1trZXldID0ganNvbi5leHRlbnNpb25zW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH0gLy8gRGVwcmVjYXRlZFxuXG5cblx0XHRcdGlmIChqc29uLnNoYWRpbmcgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuZmxhdFNoYWRpbmcgPSBqc29uLnNoYWRpbmcgPT09IDE7IC8vIFRIUkVFLkZsYXRTaGFkaW5nXG5cdFx0XHQvLyBmb3IgUG9pbnRzTWF0ZXJpYWxcblxuXHRcdFx0aWYgKGpzb24uc2l6ZSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5zaXplID0ganNvbi5zaXplO1xuXHRcdFx0aWYgKGpzb24uc2l6ZUF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9IGpzb24uc2l6ZUF0dGVudWF0aW9uOyAvLyBtYXBzXG5cblx0XHRcdGlmIChqc29uLm1hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5tYXAgPSBnZXRUZXh0dXJlKGpzb24ubWFwKTtcblx0XHRcdGlmIChqc29uLm1hdGNhcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5tYXRjYXAgPSBnZXRUZXh0dXJlKGpzb24ubWF0Y2FwKTtcblx0XHRcdGlmIChqc29uLmFscGhhTWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmFscGhhTWFwID0gZ2V0VGV4dHVyZShqc29uLmFscGhhTWFwKTtcblx0XHRcdGlmIChqc29uLmJ1bXBNYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuYnVtcE1hcCA9IGdldFRleHR1cmUoanNvbi5idW1wTWFwKTtcblx0XHRcdGlmIChqc29uLmJ1bXBTY2FsZSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5idW1wU2NhbGUgPSBqc29uLmJ1bXBTY2FsZTtcblx0XHRcdGlmIChqc29uLm5vcm1hbE1hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5ub3JtYWxNYXAgPSBnZXRUZXh0dXJlKGpzb24ubm9ybWFsTWFwKTtcblx0XHRcdGlmIChqc29uLm5vcm1hbE1hcFR5cGUgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwubm9ybWFsTWFwVHlwZSA9IGpzb24ubm9ybWFsTWFwVHlwZTtcblxuXHRcdFx0aWYgKGpzb24ubm9ybWFsU2NhbGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRsZXQgbm9ybWFsU2NhbGUgPSBqc29uLm5vcm1hbFNjYWxlO1xuXG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KG5vcm1hbFNjYWxlKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHQvLyBCbGVuZGVyIGV4cG9ydGVyIHVzZWQgdG8gZXhwb3J0IGEgc2NhbGFyLiBTZWUgIzc0NTlcblx0XHRcdFx0XHRub3JtYWxTY2FsZSA9IFtub3JtYWxTY2FsZSwgbm9ybWFsU2NhbGVdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWF0ZXJpYWwubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMigpLmZyb21BcnJheShub3JtYWxTY2FsZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChqc29uLmRpc3BsYWNlbWVudE1hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgPSBnZXRUZXh0dXJlKGpzb24uZGlzcGxhY2VtZW50TWFwKTtcblx0XHRcdGlmIChqc29uLmRpc3BsYWNlbWVudFNjYWxlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlID0ganNvbi5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRcdGlmIChqc29uLmRpc3BsYWNlbWVudEJpYXMgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcyA9IGpzb24uZGlzcGxhY2VtZW50Qmlhcztcblx0XHRcdGlmIChqc29uLnJvdWdobmVzc01hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5yb3VnaG5lc3NNYXAgPSBnZXRUZXh0dXJlKGpzb24ucm91Z2huZXNzTWFwKTtcblx0XHRcdGlmIChqc29uLm1ldGFsbmVzc01hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5tZXRhbG5lc3NNYXAgPSBnZXRUZXh0dXJlKGpzb24ubWV0YWxuZXNzTWFwKTtcblx0XHRcdGlmIChqc29uLmVtaXNzaXZlTWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmVtaXNzaXZlTWFwID0gZ2V0VGV4dHVyZShqc29uLmVtaXNzaXZlTWFwKTtcblx0XHRcdGlmIChqc29uLmVtaXNzaXZlSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmVtaXNzaXZlSW50ZW5zaXR5ID0ganNvbi5lbWlzc2l2ZUludGVuc2l0eTtcblx0XHRcdGlmIChqc29uLnNwZWN1bGFyTWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gZ2V0VGV4dHVyZShqc29uLnNwZWN1bGFyTWFwKTtcblx0XHRcdGlmIChqc29uLnNwZWN1bGFySW50ZW5zaXR5TWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnNwZWN1bGFySW50ZW5zaXR5TWFwID0gZ2V0VGV4dHVyZShqc29uLnNwZWN1bGFySW50ZW5zaXR5TWFwKTtcblx0XHRcdGlmIChqc29uLnNwZWN1bGFyQ29sb3JNYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvck1hcCA9IGdldFRleHR1cmUoanNvbi5zcGVjdWxhckNvbG9yTWFwKTtcblx0XHRcdGlmIChqc29uLmVudk1hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5lbnZNYXAgPSBnZXRUZXh0dXJlKGpzb24uZW52TWFwKTtcblx0XHRcdGlmIChqc29uLmVudk1hcEludGVuc2l0eSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5lbnZNYXBJbnRlbnNpdHkgPSBqc29uLmVudk1hcEludGVuc2l0eTtcblx0XHRcdGlmIChqc29uLnJlZmxlY3Rpdml0eSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5yZWZsZWN0aXZpdHkgPSBqc29uLnJlZmxlY3Rpdml0eTtcblx0XHRcdGlmIChqc29uLnJlZnJhY3Rpb25SYXRpbyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW8gPSBqc29uLnJlZnJhY3Rpb25SYXRpbztcblx0XHRcdGlmIChqc29uLmxpZ2h0TWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmxpZ2h0TWFwID0gZ2V0VGV4dHVyZShqc29uLmxpZ2h0TWFwKTtcblx0XHRcdGlmIChqc29uLmxpZ2h0TWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmxpZ2h0TWFwSW50ZW5zaXR5ID0ganNvbi5saWdodE1hcEludGVuc2l0eTtcblx0XHRcdGlmIChqc29uLmFvTWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmFvTWFwID0gZ2V0VGV4dHVyZShqc29uLmFvTWFwKTtcblx0XHRcdGlmIChqc29uLmFvTWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5ID0ganNvbi5hb01hcEludGVuc2l0eTtcblx0XHRcdGlmIChqc29uLmdyYWRpZW50TWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmdyYWRpZW50TWFwID0gZ2V0VGV4dHVyZShqc29uLmdyYWRpZW50TWFwKTtcblx0XHRcdGlmIChqc29uLmNsZWFyY29hdE1hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5jbGVhcmNvYXRNYXAgPSBnZXRUZXh0dXJlKGpzb24uY2xlYXJjb2F0TWFwKTtcblx0XHRcdGlmIChqc29uLmNsZWFyY29hdFJvdWdobmVzc01hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgPSBnZXRUZXh0dXJlKGpzb24uY2xlYXJjb2F0Um91Z2huZXNzTWFwKTtcblx0XHRcdGlmIChqc29uLmNsZWFyY29hdE5vcm1hbE1hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxNYXAgPSBnZXRUZXh0dXJlKGpzb24uY2xlYXJjb2F0Tm9ybWFsTWFwKTtcblx0XHRcdGlmIChqc29uLmNsZWFyY29hdE5vcm1hbFNjYWxlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoKS5mcm9tQXJyYXkoanNvbi5jbGVhcmNvYXROb3JtYWxTY2FsZSk7XG5cdFx0XHRpZiAoanNvbi50cmFuc21pc3Npb25NYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwudHJhbnNtaXNzaW9uTWFwID0gZ2V0VGV4dHVyZShqc29uLnRyYW5zbWlzc2lvbk1hcCk7XG5cdFx0XHRpZiAoanNvbi50aGlja25lc3NNYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwudGhpY2tuZXNzTWFwID0gZ2V0VGV4dHVyZShqc29uLnRoaWNrbmVzc01hcCk7XG5cdFx0XHRpZiAoanNvbi5zaGVlbkNvbG9yTWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnNoZWVuQ29sb3JNYXAgPSBnZXRUZXh0dXJlKGpzb24uc2hlZW5Db2xvck1hcCk7XG5cdFx0XHRpZiAoanNvbi5zaGVlblJvdWdobmVzc01hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5zaGVlblJvdWdobmVzc01hcCA9IGdldFRleHR1cmUoanNvbi5zaGVlblJvdWdobmVzc01hcCk7XG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWw7XG5cdFx0fVxuXG5cdFx0c2V0VGV4dHVyZXModmFsdWUpIHtcblx0XHRcdHRoaXMudGV4dHVyZXMgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgTG9hZGVyVXRpbHMge1xuXHRcdHN0YXRpYyBkZWNvZGVUZXh0KGFycmF5KSB7XG5cdFx0XHRpZiAodHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGFycmF5KTtcblx0XHRcdH0gLy8gQXZvaWQgdGhlIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkpIHNob3J0Y3V0LCB3aGljaFxuXHRcdFx0Ly8gdGhyb3dzIGEgXCJtYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiIGVycm9yIGZvciBsYXJnZSBhcnJheXMuXG5cblxuXHRcdFx0bGV0IHMgPSAnJztcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHQvLyBJbXBsaWNpdGx5IGFzc3VtZXMgbGl0dGxlLWVuZGlhbi5cblx0XHRcdFx0cyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFycmF5W2ldKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gbWVyZ2VzIG11bHRpLWJ5dGUgdXRmLTggY2hhcmFjdGVycy5cblx0XHRcdFx0cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUocykpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHQvLyBzZWUgIzE2MzU4XG5cdFx0XHRcdHJldHVybiBzO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHN0YXRpYyBleHRyYWN0VXJsQmFzZSh1cmwpIHtcblx0XHRcdGNvbnN0IGluZGV4ID0gdXJsLmxhc3RJbmRleE9mKCcvJyk7XG5cdFx0XHRpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gJy4vJztcblx0XHRcdHJldHVybiB1cmwuc3Vic3RyKDAsIGluZGV4ICsgMSk7XG5cdFx0fVxuXG5cdFx0c3RhdGljIHJlc29sdmVVUkwodXJsLCBwYXRoKSB7XG5cdFx0XHQvLyBJbnZhbGlkIFVSTFxuXHRcdFx0aWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnIHx8IHVybCA9PT0gJycpIHJldHVybiAnJzsgLy8gSG9zdCBSZWxhdGl2ZSBVUkxcblxuXHRcdFx0aWYgKC9eaHR0cHM/OlxcL1xcLy9pLnRlc3QocGF0aCkgJiYgL15cXC8vLnRlc3QodXJsKSkge1xuXHRcdFx0XHRwYXRoID0gcGF0aC5yZXBsYWNlKC8oXmh0dHBzPzpcXC9cXC9bXlxcL10rKS4qL2ksICckMScpO1xuXHRcdFx0fSAvLyBBYnNvbHV0ZSBVUkwgaHR0cDovLyxodHRwczovLywvL1xuXG5cblx0XHRcdGlmICgvXihodHRwcz86KT9cXC9cXC8vaS50ZXN0KHVybCkpIHJldHVybiB1cmw7IC8vIERhdGEgVVJJXG5cblx0XHRcdGlmICgvXmRhdGE6LiosLiokL2kudGVzdCh1cmwpKSByZXR1cm4gdXJsOyAvLyBCbG9iIFVSTFxuXG5cdFx0XHRpZiAoL15ibG9iOi4qJC9pLnRlc3QodXJsKSkgcmV0dXJuIHVybDsgLy8gUmVsYXRpdmUgVVJMXG5cblx0XHRcdHJldHVybiBwYXRoICsgdXJsO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy50eXBlID0gJ0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5Jztcblx0XHRcdHRoaXMuaW5zdGFuY2VDb3VudCA9IEluZmluaXR5O1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLmluc3RhbmNlQ291bnQgPSBzb3VyY2UuaW5zdGFuY2VDb3VudDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNsb25lKCkge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcblx0XHR9XG5cblx0XHR0b0pTT04oKSB7XG5cdFx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKHRoaXMpO1xuXHRcdFx0ZGF0YS5pbnN0YW5jZUNvdW50ID0gdGhpcy5pbnN0YW5jZUNvdW50O1xuXHRcdFx0ZGF0YS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ID0gdHJ1ZTtcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHR9XG5cblx0SW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgPSB0cnVlO1xuXG5cdGNsYXNzIEJ1ZmZlckdlb21ldHJ5TG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblx0XHRjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG5cdFx0XHRzdXBlcihtYW5hZ2VyKTtcblx0XHR9XG5cblx0XHRsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG5cdFx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0XHRjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcihzY29wZS5tYW5hZ2VyKTtcblx0XHRcdGxvYWRlci5zZXRQYXRoKHNjb3BlLnBhdGgpO1xuXHRcdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoc2NvcGUucmVxdWVzdEhlYWRlcik7XG5cdFx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHNjb3BlLndpdGhDcmVkZW50aWFscyk7XG5cdFx0XHRsb2FkZXIubG9hZCh1cmwsIGZ1bmN0aW9uICh0ZXh0KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0b25Mb2FkKHNjb3BlLnBhcnNlKEpTT04ucGFyc2UodGV4dCkpKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdGlmIChvbkVycm9yKSB7XG5cdFx0XHRcdFx0XHRvbkVycm9yKGUpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKGUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKHVybCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpO1xuXHRcdH1cblxuXHRcdHBhcnNlKGpzb24pIHtcblx0XHRcdGNvbnN0IGludGVybGVhdmVkQnVmZmVyTWFwID0ge307XG5cdFx0XHRjb25zdCBhcnJheUJ1ZmZlck1hcCA9IHt9O1xuXG5cdFx0XHRmdW5jdGlvbiBnZXRJbnRlcmxlYXZlZEJ1ZmZlcihqc29uLCB1dWlkKSB7XG5cdFx0XHRcdGlmIChpbnRlcmxlYXZlZEJ1ZmZlck1hcFt1dWlkXSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gaW50ZXJsZWF2ZWRCdWZmZXJNYXBbdXVpZF07XG5cdFx0XHRcdGNvbnN0IGludGVybGVhdmVkQnVmZmVycyA9IGpzb24uaW50ZXJsZWF2ZWRCdWZmZXJzO1xuXHRcdFx0XHRjb25zdCBpbnRlcmxlYXZlZEJ1ZmZlciA9IGludGVybGVhdmVkQnVmZmVyc1t1dWlkXTtcblx0XHRcdFx0Y29uc3QgYnVmZmVyID0gZ2V0QXJyYXlCdWZmZXIoanNvbiwgaW50ZXJsZWF2ZWRCdWZmZXIuYnVmZmVyKTtcblx0XHRcdFx0Y29uc3QgYXJyYXkgPSBnZXRUeXBlZEFycmF5KGludGVybGVhdmVkQnVmZmVyLnR5cGUsIGJ1ZmZlcik7XG5cdFx0XHRcdGNvbnN0IGliID0gbmV3IEludGVybGVhdmVkQnVmZmVyKGFycmF5LCBpbnRlcmxlYXZlZEJ1ZmZlci5zdHJpZGUpO1xuXHRcdFx0XHRpYi51dWlkID0gaW50ZXJsZWF2ZWRCdWZmZXIudXVpZDtcblx0XHRcdFx0aW50ZXJsZWF2ZWRCdWZmZXJNYXBbdXVpZF0gPSBpYjtcblx0XHRcdFx0cmV0dXJuIGliO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBnZXRBcnJheUJ1ZmZlcihqc29uLCB1dWlkKSB7XG5cdFx0XHRcdGlmIChhcnJheUJ1ZmZlck1hcFt1dWlkXSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gYXJyYXlCdWZmZXJNYXBbdXVpZF07XG5cdFx0XHRcdGNvbnN0IGFycmF5QnVmZmVycyA9IGpzb24uYXJyYXlCdWZmZXJzO1xuXHRcdFx0XHRjb25zdCBhcnJheUJ1ZmZlciA9IGFycmF5QnVmZmVyc1t1dWlkXTtcblx0XHRcdFx0Y29uc3QgYWIgPSBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWZmZXIpLmJ1ZmZlcjtcblx0XHRcdFx0YXJyYXlCdWZmZXJNYXBbdXVpZF0gPSBhYjtcblx0XHRcdFx0cmV0dXJuIGFiO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IGpzb24uaXNJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSA/IG5ldyBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSgpIDogbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHRjb25zdCBpbmRleCA9IGpzb24uZGF0YS5pbmRleDtcblxuXHRcdFx0aWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc3QgdHlwZWRBcnJheSA9IGdldFR5cGVkQXJyYXkoaW5kZXgudHlwZSwgaW5kZXguYXJyYXkpO1xuXHRcdFx0XHRnZW9tZXRyeS5zZXRJbmRleChuZXcgQnVmZmVyQXR0cmlidXRlKHR5cGVkQXJyYXksIDEpKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYXR0cmlidXRlcyA9IGpzb24uZGF0YS5hdHRyaWJ1dGVzO1xuXG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNba2V5XTtcblx0XHRcdFx0bGV0IGJ1ZmZlckF0dHJpYnV0ZTtcblxuXHRcdFx0XHRpZiAoYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUpIHtcblx0XHRcdFx0XHRjb25zdCBpbnRlcmxlYXZlZEJ1ZmZlciA9IGdldEludGVybGVhdmVkQnVmZmVyKGpzb24uZGF0YSwgYXR0cmlidXRlLmRhdGEpO1xuXHRcdFx0XHRcdGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZShpbnRlcmxlYXZlZEJ1ZmZlciwgYXR0cmlidXRlLml0ZW1TaXplLCBhdHRyaWJ1dGUub2Zmc2V0LCBhdHRyaWJ1dGUubm9ybWFsaXplZCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc3QgdHlwZWRBcnJheSA9IGdldFR5cGVkQXJyYXkoYXR0cmlidXRlLnR5cGUsIGF0dHJpYnV0ZS5hcnJheSk7XG5cdFx0XHRcdFx0Y29uc3QgYnVmZmVyQXR0cmlidXRlQ29uc3RyID0gYXR0cmlidXRlLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlID8gSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlIDogQnVmZmVyQXR0cmlidXRlO1xuXHRcdFx0XHRcdGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBidWZmZXJBdHRyaWJ1dGVDb25zdHIodHlwZWRBcnJheSwgYXR0cmlidXRlLml0ZW1TaXplLCBhdHRyaWJ1dGUubm9ybWFsaXplZCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYXR0cmlidXRlLm5hbWUgIT09IHVuZGVmaW5lZCkgYnVmZmVyQXR0cmlidXRlLm5hbWUgPSBhdHRyaWJ1dGUubmFtZTtcblx0XHRcdFx0aWYgKGF0dHJpYnV0ZS51c2FnZSAhPT0gdW5kZWZpbmVkKSBidWZmZXJBdHRyaWJ1dGUuc2V0VXNhZ2UoYXR0cmlidXRlLnVzYWdlKTtcblxuXHRcdFx0XHRpZiAoYXR0cmlidXRlLnVwZGF0ZVJhbmdlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRidWZmZXJBdHRyaWJ1dGUudXBkYXRlUmFuZ2Uub2Zmc2V0ID0gYXR0cmlidXRlLnVwZGF0ZVJhbmdlLm9mZnNldDtcblx0XHRcdFx0XHRidWZmZXJBdHRyaWJ1dGUudXBkYXRlUmFuZ2UuY291bnQgPSBhdHRyaWJ1dGUudXBkYXRlUmFuZ2UuY291bnQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoa2V5LCBidWZmZXJBdHRyaWJ1dGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSBqc29uLmRhdGEubW9ycGhBdHRyaWJ1dGVzO1xuXG5cdFx0XHRpZiAobW9ycGhBdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdGZvciAoY29uc3Qga2V5IGluIG1vcnBoQXR0cmlidXRlcykge1xuXHRcdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZUFycmF5ID0gbW9ycGhBdHRyaWJ1dGVzW2tleV07XG5cdFx0XHRcdFx0Y29uc3QgYXJyYXkgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGF0dHJpYnV0ZUFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZUFycmF5W2ldO1xuXHRcdFx0XHRcdFx0bGV0IGJ1ZmZlckF0dHJpYnV0ZTtcblxuXHRcdFx0XHRcdFx0aWYgKGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGludGVybGVhdmVkQnVmZmVyID0gZ2V0SW50ZXJsZWF2ZWRCdWZmZXIoanNvbi5kYXRhLCBhdHRyaWJ1dGUuZGF0YSk7XG5cdFx0XHRcdFx0XHRcdGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZShpbnRlcmxlYXZlZEJ1ZmZlciwgYXR0cmlidXRlLml0ZW1TaXplLCBhdHRyaWJ1dGUub2Zmc2V0LCBhdHRyaWJ1dGUubm9ybWFsaXplZCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjb25zdCB0eXBlZEFycmF5ID0gZ2V0VHlwZWRBcnJheShhdHRyaWJ1dGUudHlwZSwgYXR0cmlidXRlLmFycmF5KTtcblx0XHRcdFx0XHRcdFx0YnVmZmVyQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSh0eXBlZEFycmF5LCBhdHRyaWJ1dGUuaXRlbVNpemUsIGF0dHJpYnV0ZS5ub3JtYWxpemVkKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKGF0dHJpYnV0ZS5uYW1lICE9PSB1bmRlZmluZWQpIGJ1ZmZlckF0dHJpYnV0ZS5uYW1lID0gYXR0cmlidXRlLm5hbWU7XG5cdFx0XHRcdFx0XHRhcnJheS5wdXNoKGJ1ZmZlckF0dHJpYnV0ZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Z2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzW2tleV0gPSBhcnJheTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtb3JwaFRhcmdldHNSZWxhdGl2ZSA9IGpzb24uZGF0YS5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcblxuXHRcdFx0aWYgKG1vcnBoVGFyZ2V0c1JlbGF0aXZlKSB7XG5cdFx0XHRcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZ3JvdXBzID0ganNvbi5kYXRhLmdyb3VwcyB8fCBqc29uLmRhdGEuZHJhd2NhbGxzIHx8IGpzb24uZGF0YS5vZmZzZXRzO1xuXG5cdFx0XHRpZiAoZ3JvdXBzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBncm91cHMubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1tpXTtcblx0XHRcdFx0XHRnZW9tZXRyeS5hZGRHcm91cChncm91cC5zdGFydCwgZ3JvdXAuY291bnQsIGdyb3VwLm1hdGVyaWFsSW5kZXgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGJvdW5kaW5nU3BoZXJlID0ganNvbi5kYXRhLmJvdW5kaW5nU3BoZXJlO1xuXG5cdFx0XHRpZiAoYm91bmRpbmdTcGhlcmUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb25zdCBjZW50ZXIgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRcdGlmIChib3VuZGluZ1NwaGVyZS5jZW50ZXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNlbnRlci5mcm9tQXJyYXkoYm91bmRpbmdTcGhlcmUuY2VudGVyKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZShjZW50ZXIsIGJvdW5kaW5nU3BoZXJlLnJhZGl1cyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChqc29uLm5hbWUpIGdlb21ldHJ5Lm5hbWUgPSBqc29uLm5hbWU7XG5cdFx0XHRpZiAoanNvbi51c2VyRGF0YSkgZ2VvbWV0cnkudXNlckRhdGEgPSBqc29uLnVzZXJEYXRhO1xuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgT2JqZWN0TG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcblx0XHRjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG5cdFx0XHRzdXBlcihtYW5hZ2VyKTtcblx0XHR9XG5cblx0XHRsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG5cdFx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0XHRjb25zdCBwYXRoID0gdGhpcy5wYXRoID09PSAnJyA/IExvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKHVybCkgOiB0aGlzLnBhdGg7XG5cdFx0XHR0aGlzLnJlc291cmNlUGF0aCA9IHRoaXMucmVzb3VyY2VQYXRoIHx8IHBhdGg7XG5cdFx0XHRjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLm1hbmFnZXIpO1xuXHRcdFx0bG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcblx0XHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG5cdFx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcblx0XHRcdGxvYWRlci5sb2FkKHVybCwgZnVuY3Rpb24gKHRleHQpIHtcblx0XHRcdFx0bGV0IGpzb24gPSBudWxsO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0anNvbiA9IEpTT04ucGFyc2UodGV4dCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0aWYgKG9uRXJyb3IgIT09IHVuZGVmaW5lZCkgb25FcnJvcihlcnJvcik7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUU6T2JqZWN0TG9hZGVyOiBDYW5cXCd0IHBhcnNlICcgKyB1cmwgKyAnLicsIGVycm9yLm1lc3NhZ2UpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IG1ldGFkYXRhID0ganNvbi5tZXRhZGF0YTtcblxuXHRcdFx0XHRpZiAobWV0YWRhdGEgPT09IHVuZGVmaW5lZCB8fCBtZXRhZGF0YS50eXBlID09PSB1bmRlZmluZWQgfHwgbWV0YWRhdGEudHlwZS50b0xvd2VyQ2FzZSgpID09PSAnZ2VvbWV0cnknKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuT2JqZWN0TG9hZGVyOiBDYW5cXCd0IGxvYWQgJyArIHVybCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NvcGUucGFyc2UoanNvbiwgb25Mb2FkKTtcblx0XHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpO1xuXHRcdH1cblxuXHRcdGFzeW5jIGxvYWRBc3luYyh1cmwsIG9uUHJvZ3Jlc3MpIHtcblx0XHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblx0XHRcdGNvbnN0IHBhdGggPSB0aGlzLnBhdGggPT09ICcnID8gTG9hZGVyVXRpbHMuZXh0cmFjdFVybEJhc2UodXJsKSA6IHRoaXMucGF0aDtcblx0XHRcdHRoaXMucmVzb3VyY2VQYXRoID0gdGhpcy5yZXNvdXJjZVBhdGggfHwgcGF0aDtcblx0XHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMubWFuYWdlcik7XG5cdFx0XHRsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuXHRcdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcblx0XHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuXHRcdFx0Y29uc3QgdGV4dCA9IGF3YWl0IGxvYWRlci5sb2FkQXN5bmModXJsLCBvblByb2dyZXNzKTtcblx0XHRcdGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKHRleHQpO1xuXHRcdFx0Y29uc3QgbWV0YWRhdGEgPSBqc29uLm1ldGFkYXRhO1xuXG5cdFx0XHRpZiAobWV0YWRhdGEgPT09IHVuZGVmaW5lZCB8fCBtZXRhZGF0YS50eXBlID09PSB1bmRlZmluZWQgfHwgbWV0YWRhdGEudHlwZS50b0xvd2VyQ2FzZSgpID09PSAnZ2VvbWV0cnknKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVEhSRUUuT2JqZWN0TG9hZGVyOiBDYW5cXCd0IGxvYWQgJyArIHVybCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhd2FpdCBzY29wZS5wYXJzZUFzeW5jKGpzb24pO1xuXHRcdH1cblxuXHRcdHBhcnNlKGpzb24sIG9uTG9hZCkge1xuXHRcdFx0Y29uc3QgYW5pbWF0aW9ucyA9IHRoaXMucGFyc2VBbmltYXRpb25zKGpzb24uYW5pbWF0aW9ucyk7XG5cdFx0XHRjb25zdCBzaGFwZXMgPSB0aGlzLnBhcnNlU2hhcGVzKGpzb24uc2hhcGVzKTtcblx0XHRcdGNvbnN0IGdlb21ldHJpZXMgPSB0aGlzLnBhcnNlR2VvbWV0cmllcyhqc29uLmdlb21ldHJpZXMsIHNoYXBlcyk7XG5cdFx0XHRjb25zdCBpbWFnZXMgPSB0aGlzLnBhcnNlSW1hZ2VzKGpzb24uaW1hZ2VzLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmIChvbkxvYWQgIT09IHVuZGVmaW5lZCkgb25Mb2FkKG9iamVjdCk7XG5cdFx0XHR9KTtcblx0XHRcdGNvbnN0IHRleHR1cmVzID0gdGhpcy5wYXJzZVRleHR1cmVzKGpzb24udGV4dHVyZXMsIGltYWdlcyk7XG5cdFx0XHRjb25zdCBtYXRlcmlhbHMgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKGpzb24ubWF0ZXJpYWxzLCB0ZXh0dXJlcyk7XG5cdFx0XHRjb25zdCBvYmplY3QgPSB0aGlzLnBhcnNlT2JqZWN0KGpzb24ub2JqZWN0LCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMsIHRleHR1cmVzLCBhbmltYXRpb25zKTtcblx0XHRcdGNvbnN0IHNrZWxldG9ucyA9IHRoaXMucGFyc2VTa2VsZXRvbnMoanNvbi5za2VsZXRvbnMsIG9iamVjdCk7XG5cdFx0XHR0aGlzLmJpbmRTa2VsZXRvbnMob2JqZWN0LCBza2VsZXRvbnMpOyAvL1xuXG5cdFx0XHRpZiAob25Mb2FkICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0bGV0IGhhc0ltYWdlcyA9IGZhbHNlO1xuXG5cdFx0XHRcdGZvciAoY29uc3QgdXVpZCBpbiBpbWFnZXMpIHtcblx0XHRcdFx0XHRpZiAoaW1hZ2VzW3V1aWRdIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuXHRcdFx0XHRcdFx0aGFzSW1hZ2VzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChoYXNJbWFnZXMgPT09IGZhbHNlKSBvbkxvYWQob2JqZWN0KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9iamVjdDtcblx0XHR9XG5cblx0XHRhc3luYyBwYXJzZUFzeW5jKGpzb24pIHtcblx0XHRcdGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLnBhcnNlQW5pbWF0aW9ucyhqc29uLmFuaW1hdGlvbnMpO1xuXHRcdFx0Y29uc3Qgc2hhcGVzID0gdGhpcy5wYXJzZVNoYXBlcyhqc29uLnNoYXBlcyk7XG5cdFx0XHRjb25zdCBnZW9tZXRyaWVzID0gdGhpcy5wYXJzZUdlb21ldHJpZXMoanNvbi5nZW9tZXRyaWVzLCBzaGFwZXMpO1xuXHRcdFx0Y29uc3QgaW1hZ2VzID0gYXdhaXQgdGhpcy5wYXJzZUltYWdlc0FzeW5jKGpzb24uaW1hZ2VzKTtcblx0XHRcdGNvbnN0IHRleHR1cmVzID0gdGhpcy5wYXJzZVRleHR1cmVzKGpzb24udGV4dHVyZXMsIGltYWdlcyk7XG5cdFx0XHRjb25zdCBtYXRlcmlhbHMgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKGpzb24ubWF0ZXJpYWxzLCB0ZXh0dXJlcyk7XG5cdFx0XHRjb25zdCBvYmplY3QgPSB0aGlzLnBhcnNlT2JqZWN0KGpzb24ub2JqZWN0LCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMsIHRleHR1cmVzLCBhbmltYXRpb25zKTtcblx0XHRcdGNvbnN0IHNrZWxldG9ucyA9IHRoaXMucGFyc2VTa2VsZXRvbnMoanNvbi5za2VsZXRvbnMsIG9iamVjdCk7XG5cdFx0XHR0aGlzLmJpbmRTa2VsZXRvbnMob2JqZWN0LCBza2VsZXRvbnMpO1xuXHRcdFx0cmV0dXJuIG9iamVjdDtcblx0XHR9XG5cblx0XHRwYXJzZVNoYXBlcyhqc29uKSB7XG5cdFx0XHRjb25zdCBzaGFwZXMgPSB7fTtcblxuXHRcdFx0aWYgKGpzb24gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBuZXcgU2hhcGUoKS5mcm9tSlNPTihqc29uW2ldKTtcblx0XHRcdFx0XHRzaGFwZXNbc2hhcGUudXVpZF0gPSBzaGFwZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2hhcGVzO1xuXHRcdH1cblxuXHRcdHBhcnNlU2tlbGV0b25zKGpzb24sIG9iamVjdCkge1xuXHRcdFx0Y29uc3Qgc2tlbGV0b25zID0ge307XG5cdFx0XHRjb25zdCBib25lcyA9IHt9OyAvLyBnZW5lcmF0ZSBib25lIGxvb2t1cCB0YWJsZVxuXG5cdFx0XHRvYmplY3QudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XG5cdFx0XHRcdGlmIChjaGlsZC5pc0JvbmUpIGJvbmVzW2NoaWxkLnV1aWRdID0gY2hpbGQ7XG5cdFx0XHR9KTsgLy8gY3JlYXRlIHNrZWxldG9uc1xuXG5cdFx0XHRpZiAoanNvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBza2VsZXRvbiA9IG5ldyBTa2VsZXRvbigpLmZyb21KU09OKGpzb25baV0sIGJvbmVzKTtcblx0XHRcdFx0XHRza2VsZXRvbnNbc2tlbGV0b24udXVpZF0gPSBza2VsZXRvbjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2tlbGV0b25zO1xuXHRcdH1cblxuXHRcdHBhcnNlR2VvbWV0cmllcyhqc29uLCBzaGFwZXMpIHtcblx0XHRcdGNvbnN0IGdlb21ldHJpZXMgPSB7fTtcblxuXHRcdFx0aWYgKGpzb24gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb25zdCBidWZmZXJHZW9tZXRyeUxvYWRlciA9IG5ldyBCdWZmZXJHZW9tZXRyeUxvYWRlcigpO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRsZXQgZ2VvbWV0cnk7XG5cdFx0XHRcdFx0Y29uc3QgZGF0YSA9IGpzb25baV07XG5cblx0XHRcdFx0XHRzd2l0Y2ggKGRhdGEudHlwZSkge1xuXHRcdFx0XHRcdFx0Y2FzZSAnQnVmZmVyR2VvbWV0cnknOlxuXHRcdFx0XHRcdFx0Y2FzZSAnSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnknOlxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IGJ1ZmZlckdlb21ldHJ5TG9hZGVyLnBhcnNlKGRhdGEpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnR2VvbWV0cnknOlxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5PYmplY3RMb2FkZXI6IFRoZSBsZWdhY3kgR2VvbWV0cnkgdHlwZSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLicpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0aWYgKGRhdGEudHlwZSBpbiBHZW9tZXRyaWVzKSB7XG5cdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBHZW9tZXRyaWVzW2RhdGEudHlwZV0uZnJvbUpTT04oZGF0YSwgc2hhcGVzKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oYFRIUkVFLk9iamVjdExvYWRlcjogVW5zdXBwb3J0ZWQgZ2VvbWV0cnkgdHlwZSBcIiR7ZGF0YS50eXBlfVwiYCk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGdlb21ldHJ5LnV1aWQgPSBkYXRhLnV1aWQ7XG5cdFx0XHRcdFx0aWYgKGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkKSBnZW9tZXRyeS5uYW1lID0gZGF0YS5uYW1lO1xuXHRcdFx0XHRcdGlmIChnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ID09PSB0cnVlICYmIGRhdGEudXNlckRhdGEgIT09IHVuZGVmaW5lZCkgZ2VvbWV0cnkudXNlckRhdGEgPSBkYXRhLnVzZXJEYXRhO1xuXHRcdFx0XHRcdGdlb21ldHJpZXNbZGF0YS51dWlkXSA9IGdlb21ldHJ5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBnZW9tZXRyaWVzO1xuXHRcdH1cblxuXHRcdHBhcnNlTWF0ZXJpYWxzKGpzb24sIHRleHR1cmVzKSB7XG5cdFx0XHRjb25zdCBjYWNoZSA9IHt9OyAvLyBNdWx0aU1hdGVyaWFsXG5cblx0XHRcdGNvbnN0IG1hdGVyaWFscyA9IHt9O1xuXG5cdFx0XHRpZiAoanNvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnN0IGxvYWRlciA9IG5ldyBNYXRlcmlhbExvYWRlcigpO1xuXHRcdFx0XHRsb2FkZXIuc2V0VGV4dHVyZXModGV4dHVyZXMpO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBkYXRhID0ganNvbltpXTtcblxuXHRcdFx0XHRcdGlmIChkYXRhLnR5cGUgPT09ICdNdWx0aU1hdGVyaWFsJykge1xuXHRcdFx0XHRcdFx0Ly8gRGVwcmVjYXRlZFxuXHRcdFx0XHRcdFx0Y29uc3QgYXJyYXkgPSBbXTtcblxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBkYXRhLm1hdGVyaWFscy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBtYXRlcmlhbCA9IGRhdGEubWF0ZXJpYWxzW2pdO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChjYWNoZVttYXRlcmlhbC51dWlkXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGVbbWF0ZXJpYWwudXVpZF0gPSBsb2FkZXIucGFyc2UobWF0ZXJpYWwpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YXJyYXkucHVzaChjYWNoZVttYXRlcmlhbC51dWlkXSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG1hdGVyaWFsc1tkYXRhLnV1aWRdID0gYXJyYXk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChjYWNoZVtkYXRhLnV1aWRdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0Y2FjaGVbZGF0YS51dWlkXSA9IGxvYWRlci5wYXJzZShkYXRhKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0bWF0ZXJpYWxzW2RhdGEudXVpZF0gPSBjYWNoZVtkYXRhLnV1aWRdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWxzO1xuXHRcdH1cblxuXHRcdHBhcnNlQW5pbWF0aW9ucyhqc29uKSB7XG5cdFx0XHRjb25zdCBhbmltYXRpb25zID0ge307XG5cblx0XHRcdGlmIChqc29uICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgZGF0YSA9IGpzb25baV07XG5cdFx0XHRcdFx0Y29uc3QgY2xpcCA9IEFuaW1hdGlvbkNsaXAucGFyc2UoZGF0YSk7XG5cdFx0XHRcdFx0YW5pbWF0aW9uc1tjbGlwLnV1aWRdID0gY2xpcDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYW5pbWF0aW9ucztcblx0XHR9XG5cblx0XHRwYXJzZUltYWdlcyhqc29uLCBvbkxvYWQpIHtcblx0XHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblx0XHRcdGNvbnN0IGltYWdlcyA9IHt9O1xuXHRcdFx0bGV0IGxvYWRlcjtcblxuXHRcdFx0ZnVuY3Rpb24gbG9hZEltYWdlKHVybCkge1xuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCh1cmwpO1xuXHRcdFx0XHRyZXR1cm4gbG9hZGVyLmxvYWQodXJsLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKHVybCk7XG5cdFx0XHRcdH0sIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKHVybCk7XG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKHVybCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBkZXNlcmlhbGl6ZUltYWdlKGltYWdlKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgaW1hZ2UgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0Y29uc3QgdXJsID0gaW1hZ2U7XG5cdFx0XHRcdFx0Y29uc3QgcGF0aCA9IC9eKFxcL1xcLyl8KFthLXpdKzooXFwvXFwvKT8pL2kudGVzdCh1cmwpID8gdXJsIDogc2NvcGUucmVzb3VyY2VQYXRoICsgdXJsO1xuXHRcdFx0XHRcdHJldHVybiBsb2FkSW1hZ2UocGF0aCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKGltYWdlLmRhdGEpIHtcblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdGRhdGE6IGdldFR5cGVkQXJyYXkoaW1hZ2UudHlwZSwgaW1hZ2UuZGF0YSksXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiBpbWFnZS53aWR0aCxcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OiBpbWFnZS5oZWlnaHRcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoanNvbiAhPT0gdW5kZWZpbmVkICYmIGpzb24ubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRjb25zdCBtYW5hZ2VyID0gbmV3IExvYWRpbmdNYW5hZ2VyKG9uTG9hZCk7XG5cdFx0XHRcdGxvYWRlciA9IG5ldyBJbWFnZUxvYWRlcihtYW5hZ2VyKTtcblx0XHRcdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKHRoaXMuY3Jvc3NPcmlnaW4pO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBpbCA9IGpzb24ubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IGltYWdlID0ganNvbltpXTtcblx0XHRcdFx0XHRjb25zdCB1cmwgPSBpbWFnZS51cmw7XG5cblx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh1cmwpKSB7XG5cdFx0XHRcdFx0XHQvLyBsb2FkIGFycmF5IG9mIGltYWdlcyBlLmcgQ3ViZVRleHR1cmVcblx0XHRcdFx0XHRcdGltYWdlc1tpbWFnZS51dWlkXSA9IFtdO1xuXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBqID0gMCwgamwgPSB1cmwubGVuZ3RoOyBqIDwgamw7IGorKykge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBjdXJyZW50VXJsID0gdXJsW2pdO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBkZXNlcmlhbGl6ZWRJbWFnZSA9IGRlc2VyaWFsaXplSW1hZ2UoY3VycmVudFVybCk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKGRlc2VyaWFsaXplZEltYWdlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGRlc2VyaWFsaXplZEltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aW1hZ2VzW2ltYWdlLnV1aWRdLnB1c2goZGVzZXJpYWxpemVkSW1hZ2UpO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBzcGVjaWFsIGNhc2U6IGhhbmRsZSBhcnJheSBvZiBkYXRhIHRleHR1cmVzIGZvciBjdWJlIHRleHR1cmVzXG5cdFx0XHRcdFx0XHRcdFx0XHRpbWFnZXNbaW1hZ2UudXVpZF0ucHVzaChuZXcgRGF0YVRleHR1cmUoZGVzZXJpYWxpemVkSW1hZ2UuZGF0YSwgZGVzZXJpYWxpemVkSW1hZ2Uud2lkdGgsIGRlc2VyaWFsaXplZEltYWdlLmhlaWdodCkpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBsb2FkIHNpbmdsZSBpbWFnZVxuXHRcdFx0XHRcdFx0Y29uc3QgZGVzZXJpYWxpemVkSW1hZ2UgPSBkZXNlcmlhbGl6ZUltYWdlKGltYWdlLnVybCk7XG5cblx0XHRcdFx0XHRcdGlmIChkZXNlcmlhbGl6ZWRJbWFnZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRpbWFnZXNbaW1hZ2UudXVpZF0gPSBkZXNlcmlhbGl6ZWRJbWFnZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGltYWdlcztcblx0XHR9XG5cblx0XHRhc3luYyBwYXJzZUltYWdlc0FzeW5jKGpzb24pIHtcblx0XHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblx0XHRcdGNvbnN0IGltYWdlcyA9IHt9O1xuXHRcdFx0bGV0IGxvYWRlcjtcblxuXHRcdFx0YXN5bmMgZnVuY3Rpb24gZGVzZXJpYWxpemVJbWFnZShpbWFnZSkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGltYWdlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdGNvbnN0IHVybCA9IGltYWdlO1xuXHRcdFx0XHRcdGNvbnN0IHBhdGggPSAvXihcXC9cXC8pfChbYS16XSs6KFxcL1xcLyk/KS9pLnRlc3QodXJsKSA/IHVybCA6IHNjb3BlLnJlc291cmNlUGF0aCArIHVybDtcblx0XHRcdFx0XHRyZXR1cm4gYXdhaXQgbG9hZGVyLmxvYWRBc3luYyhwYXRoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoaW1hZ2UuZGF0YSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0ZGF0YTogZ2V0VHlwZWRBcnJheShpbWFnZS50eXBlLCBpbWFnZS5kYXRhKSxcblx0XHRcdFx0XHRcdFx0d2lkdGg6IGltYWdlLndpZHRoLFxuXHRcdFx0XHRcdFx0XHRoZWlnaHQ6IGltYWdlLmhlaWdodFxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChqc29uICE9PSB1bmRlZmluZWQgJiYganNvbi5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGxvYWRlciA9IG5ldyBJbWFnZUxvYWRlcih0aGlzLm1hbmFnZXIpO1xuXHRcdFx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4odGhpcy5jcm9zc09yaWdpbik7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGlsID0ganNvbi5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgaW1hZ2UgPSBqc29uW2ldO1xuXHRcdFx0XHRcdGNvbnN0IHVybCA9IGltYWdlLnVybDtcblxuXHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KHVybCkpIHtcblx0XHRcdFx0XHRcdC8vIGxvYWQgYXJyYXkgb2YgaW1hZ2VzIGUuZyBDdWJlVGV4dHVyZVxuXHRcdFx0XHRcdFx0aW1hZ2VzW2ltYWdlLnV1aWRdID0gW107XG5cblx0XHRcdFx0XHRcdGZvciAobGV0IGogPSAwLCBqbCA9IHVybC5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGN1cnJlbnRVcmwgPSB1cmxbal07XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGRlc2VyaWFsaXplZEltYWdlID0gYXdhaXQgZGVzZXJpYWxpemVJbWFnZShjdXJyZW50VXJsKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoZGVzZXJpYWxpemVkSW1hZ2UgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoZGVzZXJpYWxpemVkSW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpbWFnZXNbaW1hZ2UudXVpZF0ucHVzaChkZXNlcmlhbGl6ZWRJbWFnZSk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHNwZWNpYWwgY2FzZTogaGFuZGxlIGFycmF5IG9mIGRhdGEgdGV4dHVyZXMgZm9yIGN1YmUgdGV4dHVyZXNcblx0XHRcdFx0XHRcdFx0XHRcdGltYWdlc1tpbWFnZS51dWlkXS5wdXNoKG5ldyBEYXRhVGV4dHVyZShkZXNlcmlhbGl6ZWRJbWFnZS5kYXRhLCBkZXNlcmlhbGl6ZWRJbWFnZS53aWR0aCwgZGVzZXJpYWxpemVkSW1hZ2UuaGVpZ2h0KSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIGxvYWQgc2luZ2xlIGltYWdlXG5cdFx0XHRcdFx0XHRjb25zdCBkZXNlcmlhbGl6ZWRJbWFnZSA9IGF3YWl0IGRlc2VyaWFsaXplSW1hZ2UoaW1hZ2UudXJsKTtcblxuXHRcdFx0XHRcdFx0aWYgKGRlc2VyaWFsaXplZEltYWdlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdGltYWdlc1tpbWFnZS51dWlkXSA9IGRlc2VyaWFsaXplZEltYWdlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaW1hZ2VzO1xuXHRcdH1cblxuXHRcdHBhcnNlVGV4dHVyZXMoanNvbiwgaW1hZ2VzKSB7XG5cdFx0XHRmdW5jdGlvbiBwYXJzZUNvbnN0YW50KHZhbHVlLCB0eXBlKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSByZXR1cm4gdmFsdWU7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuT2JqZWN0TG9hZGVyLnBhcnNlVGV4dHVyZTogQ29uc3RhbnQgc2hvdWxkIGJlIGluIG51bWVyaWMgZm9ybS4nLCB2YWx1ZSk7XG5cdFx0XHRcdHJldHVybiB0eXBlW3ZhbHVlXTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdGV4dHVyZXMgPSB7fTtcblxuXHRcdFx0aWYgKGpzb24gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgZGF0YSA9IGpzb25baV07XG5cblx0XHRcdFx0XHRpZiAoZGF0YS5pbWFnZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk9iamVjdExvYWRlcjogTm8gXCJpbWFnZVwiIHNwZWNpZmllZCBmb3InLCBkYXRhLnV1aWQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChpbWFnZXNbZGF0YS5pbWFnZV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBpbWFnZScsIGRhdGEuaW1hZ2UpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxldCB0ZXh0dXJlO1xuXHRcdFx0XHRcdGNvbnN0IGltYWdlID0gaW1hZ2VzW2RhdGEuaW1hZ2VdO1xuXG5cdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoaW1hZ2UpKSB7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlID0gbmV3IEN1YmVUZXh0dXJlKGltYWdlKTtcblx0XHRcdFx0XHRcdGlmIChpbWFnZS5sZW5ndGggPT09IDYpIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoaW1hZ2UgJiYgaW1hZ2UuZGF0YSkge1xuXHRcdFx0XHRcdFx0XHR0ZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKGltYWdlLmRhdGEsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGV4dHVyZSA9IG5ldyBUZXh0dXJlKGltYWdlKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKGltYWdlKSB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTsgLy8gdGV4dHVyZXMgY2FuIGhhdmUgdW5kZWZpbmVkIGltYWdlIGRhdGFcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0ZXh0dXJlLnV1aWQgPSBkYXRhLnV1aWQ7XG5cdFx0XHRcdFx0aWYgKGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLm5hbWUgPSBkYXRhLm5hbWU7XG5cdFx0XHRcdFx0aWYgKGRhdGEubWFwcGluZyAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLm1hcHBpbmcgPSBwYXJzZUNvbnN0YW50KGRhdGEubWFwcGluZywgVEVYVFVSRV9NQVBQSU5HKTtcblx0XHRcdFx0XHRpZiAoZGF0YS5vZmZzZXQgIT09IHVuZGVmaW5lZCkgdGV4dHVyZS5vZmZzZXQuZnJvbUFycmF5KGRhdGEub2Zmc2V0KTtcblx0XHRcdFx0XHRpZiAoZGF0YS5yZXBlYXQgIT09IHVuZGVmaW5lZCkgdGV4dHVyZS5yZXBlYXQuZnJvbUFycmF5KGRhdGEucmVwZWF0KTtcblx0XHRcdFx0XHRpZiAoZGF0YS5jZW50ZXIgIT09IHVuZGVmaW5lZCkgdGV4dHVyZS5jZW50ZXIuZnJvbUFycmF5KGRhdGEuY2VudGVyKTtcblx0XHRcdFx0XHRpZiAoZGF0YS5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLnJvdGF0aW9uID0gZGF0YS5yb3RhdGlvbjtcblxuXHRcdFx0XHRcdGlmIChkYXRhLndyYXAgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0dGV4dHVyZS53cmFwUyA9IHBhcnNlQ29uc3RhbnQoZGF0YS53cmFwWzBdLCBURVhUVVJFX1dSQVBQSU5HKTtcblx0XHRcdFx0XHRcdHRleHR1cmUud3JhcFQgPSBwYXJzZUNvbnN0YW50KGRhdGEud3JhcFsxXSwgVEVYVFVSRV9XUkFQUElORyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGRhdGEuZm9ybWF0ICE9PSB1bmRlZmluZWQpIHRleHR1cmUuZm9ybWF0ID0gZGF0YS5mb3JtYXQ7XG5cdFx0XHRcdFx0aWYgKGRhdGEudHlwZSAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLnR5cGUgPSBkYXRhLnR5cGU7XG5cdFx0XHRcdFx0aWYgKGRhdGEuZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkgdGV4dHVyZS5lbmNvZGluZyA9IGRhdGEuZW5jb2Rpbmc7XG5cdFx0XHRcdFx0aWYgKGRhdGEubWluRmlsdGVyICE9PSB1bmRlZmluZWQpIHRleHR1cmUubWluRmlsdGVyID0gcGFyc2VDb25zdGFudChkYXRhLm1pbkZpbHRlciwgVEVYVFVSRV9GSUxURVIpO1xuXHRcdFx0XHRcdGlmIChkYXRhLm1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLm1hZ0ZpbHRlciA9IHBhcnNlQ29uc3RhbnQoZGF0YS5tYWdGaWx0ZXIsIFRFWFRVUkVfRklMVEVSKTtcblx0XHRcdFx0XHRpZiAoZGF0YS5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQpIHRleHR1cmUuYW5pc290cm9weSA9IGRhdGEuYW5pc290cm9weTtcblx0XHRcdFx0XHRpZiAoZGF0YS5mbGlwWSAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLmZsaXBZID0gZGF0YS5mbGlwWTtcblx0XHRcdFx0XHRpZiAoZGF0YS5wcmVtdWx0aXBseUFscGhhICE9PSB1bmRlZmluZWQpIHRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSA9IGRhdGEucHJlbXVsdGlwbHlBbHBoYTtcblx0XHRcdFx0XHRpZiAoZGF0YS51bnBhY2tBbGlnbm1lbnQgIT09IHVuZGVmaW5lZCkgdGV4dHVyZS51bnBhY2tBbGlnbm1lbnQgPSBkYXRhLnVucGFja0FsaWdubWVudDtcblx0XHRcdFx0XHRpZiAoZGF0YS51c2VyRGF0YSAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLnVzZXJEYXRhID0gZGF0YS51c2VyRGF0YTtcblx0XHRcdFx0XHR0ZXh0dXJlc1tkYXRhLnV1aWRdID0gdGV4dHVyZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGV4dHVyZXM7XG5cdFx0fVxuXG5cdFx0cGFyc2VPYmplY3QoZGF0YSwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLCB0ZXh0dXJlcywgYW5pbWF0aW9ucykge1xuXHRcdFx0bGV0IG9iamVjdDtcblxuXHRcdFx0ZnVuY3Rpb24gZ2V0R2VvbWV0cnkobmFtZSkge1xuXHRcdFx0XHRpZiAoZ2VvbWV0cmllc1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBnZW9tZXRyeScsIG5hbWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGdlb21ldHJpZXNbbmFtZV07XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGdldE1hdGVyaWFsKG5hbWUpIHtcblx0XHRcdFx0aWYgKG5hbWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuXHRcdFx0XHRcdGNvbnN0IGFycmF5ID0gW107XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IG5hbWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB1dWlkID0gbmFtZVtpXTtcblxuXHRcdFx0XHRcdFx0aWYgKG1hdGVyaWFsc1t1dWlkXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgbWF0ZXJpYWwnLCB1dWlkKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YXJyYXkucHVzaChtYXRlcmlhbHNbdXVpZF0pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBhcnJheTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChtYXRlcmlhbHNbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgbWF0ZXJpYWwnLCBuYW1lKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXRlcmlhbHNbbmFtZV07XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGdldFRleHR1cmUodXVpZCkge1xuXHRcdFx0XHRpZiAodGV4dHVyZXNbdXVpZF0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgdGV4dHVyZScsIHV1aWQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRleHR1cmVzW3V1aWRdO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgZ2VvbWV0cnksIG1hdGVyaWFsO1xuXG5cdFx0XHRzd2l0Y2ggKGRhdGEudHlwZSkge1xuXHRcdFx0XHRjYXNlICdTY2VuZSc6XG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFNjZW5lKCk7XG5cblx0XHRcdFx0XHRpZiAoZGF0YS5iYWNrZ3JvdW5kICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGlmIChOdW1iZXIuaXNJbnRlZ2VyKGRhdGEuYmFja2dyb3VuZCkpIHtcblx0XHRcdFx0XHRcdFx0b2JqZWN0LmJhY2tncm91bmQgPSBuZXcgQ29sb3IoZGF0YS5iYWNrZ3JvdW5kKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdG9iamVjdC5iYWNrZ3JvdW5kID0gZ2V0VGV4dHVyZShkYXRhLmJhY2tncm91bmQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChkYXRhLmVudmlyb25tZW50ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdG9iamVjdC5lbnZpcm9ubWVudCA9IGdldFRleHR1cmUoZGF0YS5lbnZpcm9ubWVudCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGRhdGEuZm9nICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGlmIChkYXRhLmZvZy50eXBlID09PSAnRm9nJykge1xuXHRcdFx0XHRcdFx0XHRvYmplY3QuZm9nID0gbmV3IEZvZyhkYXRhLmZvZy5jb2xvciwgZGF0YS5mb2cubmVhciwgZGF0YS5mb2cuZmFyKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoZGF0YS5mb2cudHlwZSA9PT0gJ0ZvZ0V4cDInKSB7XG5cdFx0XHRcdFx0XHRcdG9iamVjdC5mb2cgPSBuZXcgRm9nRXhwMihkYXRhLmZvZy5jb2xvciwgZGF0YS5mb2cuZGVuc2l0eSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnUGVyc3BlY3RpdmVDYW1lcmEnOlxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYShkYXRhLmZvdiwgZGF0YS5hc3BlY3QsIGRhdGEubmVhciwgZGF0YS5mYXIpO1xuXHRcdFx0XHRcdGlmIChkYXRhLmZvY3VzICE9PSB1bmRlZmluZWQpIG9iamVjdC5mb2N1cyA9IGRhdGEuZm9jdXM7XG5cdFx0XHRcdFx0aWYgKGRhdGEuem9vbSAhPT0gdW5kZWZpbmVkKSBvYmplY3Quem9vbSA9IGRhdGEuem9vbTtcblx0XHRcdFx0XHRpZiAoZGF0YS5maWxtR2F1Z2UgIT09IHVuZGVmaW5lZCkgb2JqZWN0LmZpbG1HYXVnZSA9IGRhdGEuZmlsbUdhdWdlO1xuXHRcdFx0XHRcdGlmIChkYXRhLmZpbG1PZmZzZXQgIT09IHVuZGVmaW5lZCkgb2JqZWN0LmZpbG1PZmZzZXQgPSBkYXRhLmZpbG1PZmZzZXQ7XG5cdFx0XHRcdFx0aWYgKGRhdGEudmlldyAhPT0gdW5kZWZpbmVkKSBvYmplY3QudmlldyA9IE9iamVjdC5hc3NpZ24oe30sIGRhdGEudmlldyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnT3J0aG9ncmFwaGljQ2FtZXJhJzpcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKGRhdGEubGVmdCwgZGF0YS5yaWdodCwgZGF0YS50b3AsIGRhdGEuYm90dG9tLCBkYXRhLm5lYXIsIGRhdGEuZmFyKTtcblx0XHRcdFx0XHRpZiAoZGF0YS56b29tICE9PSB1bmRlZmluZWQpIG9iamVjdC56b29tID0gZGF0YS56b29tO1xuXHRcdFx0XHRcdGlmIChkYXRhLnZpZXcgIT09IHVuZGVmaW5lZCkgb2JqZWN0LnZpZXcgPSBPYmplY3QuYXNzaWduKHt9LCBkYXRhLnZpZXcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0FtYmllbnRMaWdodCc6XG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IEFtYmllbnRMaWdodChkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnRGlyZWN0aW9uYWxMaWdodCc6XG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IERpcmVjdGlvbmFsTGlnaHQoZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHkpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1BvaW50TGlnaHQnOlxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBQb2ludExpZ2h0KGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmRlY2F5KTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdSZWN0QXJlYUxpZ2h0Jzpcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgUmVjdEFyZWFMaWdodChkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSwgZGF0YS53aWR0aCwgZGF0YS5oZWlnaHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1Nwb3RMaWdodCc6XG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFNwb3RMaWdodChkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSwgZGF0YS5kaXN0YW5jZSwgZGF0YS5hbmdsZSwgZGF0YS5wZW51bWJyYSwgZGF0YS5kZWNheSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnSGVtaXNwaGVyZUxpZ2h0Jzpcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgSGVtaXNwaGVyZUxpZ2h0KGRhdGEuY29sb3IsIGRhdGEuZ3JvdW5kQ29sb3IsIGRhdGEuaW50ZW5zaXR5KTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdMaWdodFByb2JlJzpcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgTGlnaHRQcm9iZSgpLmZyb21KU09OKGRhdGEpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1NraW5uZWRNZXNoJzpcblx0XHRcdFx0XHRnZW9tZXRyeSA9IGdldEdlb21ldHJ5KGRhdGEuZ2VvbWV0cnkpO1xuXHRcdFx0XHRcdG1hdGVyaWFsID0gZ2V0TWF0ZXJpYWwoZGF0YS5tYXRlcmlhbCk7XG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFNraW5uZWRNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG5cdFx0XHRcdFx0aWYgKGRhdGEuYmluZE1vZGUgIT09IHVuZGVmaW5lZCkgb2JqZWN0LmJpbmRNb2RlID0gZGF0YS5iaW5kTW9kZTtcblx0XHRcdFx0XHRpZiAoZGF0YS5iaW5kTWF0cml4ICE9PSB1bmRlZmluZWQpIG9iamVjdC5iaW5kTWF0cml4LmZyb21BcnJheShkYXRhLmJpbmRNYXRyaXgpO1xuXHRcdFx0XHRcdGlmIChkYXRhLnNrZWxldG9uICE9PSB1bmRlZmluZWQpIG9iamVjdC5za2VsZXRvbiA9IGRhdGEuc2tlbGV0b247XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnTWVzaCc6XG5cdFx0XHRcdFx0Z2VvbWV0cnkgPSBnZXRHZW9tZXRyeShkYXRhLmdlb21ldHJ5KTtcblx0XHRcdFx0XHRtYXRlcmlhbCA9IGdldE1hdGVyaWFsKGRhdGEubWF0ZXJpYWwpO1xuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnSW5zdGFuY2VkTWVzaCc6XG5cdFx0XHRcdFx0Z2VvbWV0cnkgPSBnZXRHZW9tZXRyeShkYXRhLmdlb21ldHJ5KTtcblx0XHRcdFx0XHRtYXRlcmlhbCA9IGdldE1hdGVyaWFsKGRhdGEubWF0ZXJpYWwpO1xuXHRcdFx0XHRcdGNvbnN0IGNvdW50ID0gZGF0YS5jb3VudDtcblx0XHRcdFx0XHRjb25zdCBpbnN0YW5jZU1hdHJpeCA9IGRhdGEuaW5zdGFuY2VNYXRyaXg7XG5cdFx0XHRcdFx0Y29uc3QgaW5zdGFuY2VDb2xvciA9IGRhdGEuaW5zdGFuY2VDb2xvcjtcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgSW5zdGFuY2VkTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwsIGNvdW50KTtcblx0XHRcdFx0XHRvYmplY3QuaW5zdGFuY2VNYXRyaXggPSBuZXcgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkoaW5zdGFuY2VNYXRyaXguYXJyYXkpLCAxNik7XG5cdFx0XHRcdFx0aWYgKGluc3RhbmNlQ29sb3IgIT09IHVuZGVmaW5lZCkgb2JqZWN0Lmluc3RhbmNlQ29sb3IgPSBuZXcgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkoaW5zdGFuY2VDb2xvci5hcnJheSksIGluc3RhbmNlQ29sb3IuaXRlbVNpemUpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0xPRCc6XG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IExPRCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0xpbmUnOlxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBMaW5lKGdldEdlb21ldHJ5KGRhdGEuZ2VvbWV0cnkpLCBnZXRNYXRlcmlhbChkYXRhLm1hdGVyaWFsKSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnTGluZUxvb3AnOlxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBMaW5lTG9vcChnZXRHZW9tZXRyeShkYXRhLmdlb21ldHJ5KSwgZ2V0TWF0ZXJpYWwoZGF0YS5tYXRlcmlhbCkpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0xpbmVTZWdtZW50cyc6XG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IExpbmVTZWdtZW50cyhnZXRHZW9tZXRyeShkYXRhLmdlb21ldHJ5KSwgZ2V0TWF0ZXJpYWwoZGF0YS5tYXRlcmlhbCkpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1BvaW50Q2xvdWQnOlxuXHRcdFx0XHRjYXNlICdQb2ludHMnOlxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBQb2ludHMoZ2V0R2VvbWV0cnkoZGF0YS5nZW9tZXRyeSksIGdldE1hdGVyaWFsKGRhdGEubWF0ZXJpYWwpKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdTcHJpdGUnOlxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBTcHJpdGUoZ2V0TWF0ZXJpYWwoZGF0YS5tYXRlcmlhbCkpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0dyb3VwJzpcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgR3JvdXAoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdCb25lJzpcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgQm9uZSgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IE9iamVjdDNEKCk7XG5cdFx0XHR9XG5cblx0XHRcdG9iamVjdC51dWlkID0gZGF0YS51dWlkO1xuXHRcdFx0aWYgKGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkKSBvYmplY3QubmFtZSA9IGRhdGEubmFtZTtcblxuXHRcdFx0aWYgKGRhdGEubWF0cml4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0b2JqZWN0Lm1hdHJpeC5mcm9tQXJyYXkoZGF0YS5tYXRyaXgpO1xuXHRcdFx0XHRpZiAoZGF0YS5tYXRyaXhBdXRvVXBkYXRlICE9PSB1bmRlZmluZWQpIG9iamVjdC5tYXRyaXhBdXRvVXBkYXRlID0gZGF0YS5tYXRyaXhBdXRvVXBkYXRlO1xuXHRcdFx0XHRpZiAob2JqZWN0Lm1hdHJpeEF1dG9VcGRhdGUpIG9iamVjdC5tYXRyaXguZGVjb21wb3NlKG9iamVjdC5wb3NpdGlvbiwgb2JqZWN0LnF1YXRlcm5pb24sIG9iamVjdC5zY2FsZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoZGF0YS5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkKSBvYmplY3QucG9zaXRpb24uZnJvbUFycmF5KGRhdGEucG9zaXRpb24pO1xuXHRcdFx0XHRpZiAoZGF0YS5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSBvYmplY3Qucm90YXRpb24uZnJvbUFycmF5KGRhdGEucm90YXRpb24pO1xuXHRcdFx0XHRpZiAoZGF0YS5xdWF0ZXJuaW9uICE9PSB1bmRlZmluZWQpIG9iamVjdC5xdWF0ZXJuaW9uLmZyb21BcnJheShkYXRhLnF1YXRlcm5pb24pO1xuXHRcdFx0XHRpZiAoZGF0YS5zY2FsZSAhPT0gdW5kZWZpbmVkKSBvYmplY3Quc2NhbGUuZnJvbUFycmF5KGRhdGEuc2NhbGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZGF0YS5jYXN0U2hhZG93ICE9PSB1bmRlZmluZWQpIG9iamVjdC5jYXN0U2hhZG93ID0gZGF0YS5jYXN0U2hhZG93O1xuXHRcdFx0aWYgKGRhdGEucmVjZWl2ZVNoYWRvdyAhPT0gdW5kZWZpbmVkKSBvYmplY3QucmVjZWl2ZVNoYWRvdyA9IGRhdGEucmVjZWl2ZVNoYWRvdztcblxuXHRcdFx0aWYgKGRhdGEuc2hhZG93KSB7XG5cdFx0XHRcdGlmIChkYXRhLnNoYWRvdy5iaWFzICE9PSB1bmRlZmluZWQpIG9iamVjdC5zaGFkb3cuYmlhcyA9IGRhdGEuc2hhZG93LmJpYXM7XG5cdFx0XHRcdGlmIChkYXRhLnNoYWRvdy5ub3JtYWxCaWFzICE9PSB1bmRlZmluZWQpIG9iamVjdC5zaGFkb3cubm9ybWFsQmlhcyA9IGRhdGEuc2hhZG93Lm5vcm1hbEJpYXM7XG5cdFx0XHRcdGlmIChkYXRhLnNoYWRvdy5yYWRpdXMgIT09IHVuZGVmaW5lZCkgb2JqZWN0LnNoYWRvdy5yYWRpdXMgPSBkYXRhLnNoYWRvdy5yYWRpdXM7XG5cdFx0XHRcdGlmIChkYXRhLnNoYWRvdy5tYXBTaXplICE9PSB1bmRlZmluZWQpIG9iamVjdC5zaGFkb3cubWFwU2l6ZS5mcm9tQXJyYXkoZGF0YS5zaGFkb3cubWFwU2l6ZSk7XG5cdFx0XHRcdGlmIChkYXRhLnNoYWRvdy5jYW1lcmEgIT09IHVuZGVmaW5lZCkgb2JqZWN0LnNoYWRvdy5jYW1lcmEgPSB0aGlzLnBhcnNlT2JqZWN0KGRhdGEuc2hhZG93LmNhbWVyYSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkYXRhLnZpc2libGUgIT09IHVuZGVmaW5lZCkgb2JqZWN0LnZpc2libGUgPSBkYXRhLnZpc2libGU7XG5cdFx0XHRpZiAoZGF0YS5mcnVzdHVtQ3VsbGVkICE9PSB1bmRlZmluZWQpIG9iamVjdC5mcnVzdHVtQ3VsbGVkID0gZGF0YS5mcnVzdHVtQ3VsbGVkO1xuXHRcdFx0aWYgKGRhdGEucmVuZGVyT3JkZXIgIT09IHVuZGVmaW5lZCkgb2JqZWN0LnJlbmRlck9yZGVyID0gZGF0YS5yZW5kZXJPcmRlcjtcblx0XHRcdGlmIChkYXRhLnVzZXJEYXRhICE9PSB1bmRlZmluZWQpIG9iamVjdC51c2VyRGF0YSA9IGRhdGEudXNlckRhdGE7XG5cdFx0XHRpZiAoZGF0YS5sYXllcnMgIT09IHVuZGVmaW5lZCkgb2JqZWN0LmxheWVycy5tYXNrID0gZGF0YS5sYXllcnM7XG5cblx0XHRcdGlmIChkYXRhLmNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc3QgY2hpbGRyZW4gPSBkYXRhLmNoaWxkcmVuO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRvYmplY3QuYWRkKHRoaXMucGFyc2VPYmplY3QoY2hpbGRyZW5baV0sIGdlb21ldHJpZXMsIG1hdGVyaWFscywgdGV4dHVyZXMsIGFuaW1hdGlvbnMpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZGF0YS5hbmltYXRpb25zICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29uc3Qgb2JqZWN0QW5pbWF0aW9ucyA9IGRhdGEuYW5pbWF0aW9ucztcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG9iamVjdEFuaW1hdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCB1dWlkID0gb2JqZWN0QW5pbWF0aW9uc1tpXTtcblx0XHRcdFx0XHRvYmplY3QuYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbnNbdXVpZF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkYXRhLnR5cGUgPT09ICdMT0QnKSB7XG5cdFx0XHRcdGlmIChkYXRhLmF1dG9VcGRhdGUgIT09IHVuZGVmaW5lZCkgb2JqZWN0LmF1dG9VcGRhdGUgPSBkYXRhLmF1dG9VcGRhdGU7XG5cdFx0XHRcdGNvbnN0IGxldmVscyA9IGRhdGEubGV2ZWxzO1xuXG5cdFx0XHRcdGZvciAobGV0IGwgPSAwOyBsIDwgbGV2ZWxzLmxlbmd0aDsgbCsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgbGV2ZWwgPSBsZXZlbHNbbF07XG5cdFx0XHRcdFx0Y29uc3QgY2hpbGQgPSBvYmplY3QuZ2V0T2JqZWN0QnlQcm9wZXJ0eSgndXVpZCcsIGxldmVsLm9iamVjdCk7XG5cblx0XHRcdFx0XHRpZiAoY2hpbGQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0b2JqZWN0LmFkZExldmVsKGNoaWxkLCBsZXZlbC5kaXN0YW5jZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvYmplY3Q7XG5cdFx0fVxuXG5cdFx0YmluZFNrZWxldG9ucyhvYmplY3QsIHNrZWxldG9ucykge1xuXHRcdFx0aWYgKE9iamVjdC5rZXlzKHNrZWxldG9ucykubGVuZ3RoID09PSAwKSByZXR1cm47XG5cdFx0XHRvYmplY3QudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XG5cdFx0XHRcdGlmIChjaGlsZC5pc1NraW5uZWRNZXNoID09PSB0cnVlICYmIGNoaWxkLnNrZWxldG9uICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRjb25zdCBza2VsZXRvbiA9IHNrZWxldG9uc1tjaGlsZC5za2VsZXRvbl07XG5cblx0XHRcdFx0XHRpZiAoc2tlbGV0b24gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5PYmplY3RMb2FkZXI6IE5vIHNrZWxldG9uIGZvdW5kIHdpdGggVVVJRDonLCBjaGlsZC5za2VsZXRvbik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNoaWxkLmJpbmQoc2tlbGV0b24sIGNoaWxkLmJpbmRNYXRyaXgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdC8qIERFUFJFQ0FURUQgKi9cblxuXG5cdFx0c2V0VGV4dHVyZVBhdGgodmFsdWUpIHtcblx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuT2JqZWN0TG9hZGVyOiAuc2V0VGV4dHVyZVBhdGgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRSZXNvdXJjZVBhdGgoKS4nKTtcblx0XHRcdHJldHVybiB0aGlzLnNldFJlc291cmNlUGF0aCh2YWx1ZSk7XG5cdFx0fVxuXG5cdH1cblxuXHRjb25zdCBURVhUVVJFX01BUFBJTkcgPSB7XG5cdFx0VVZNYXBwaW5nOiBVVk1hcHBpbmcsXG5cdFx0Q3ViZVJlZmxlY3Rpb25NYXBwaW5nOiBDdWJlUmVmbGVjdGlvbk1hcHBpbmcsXG5cdFx0Q3ViZVJlZnJhY3Rpb25NYXBwaW5nOiBDdWJlUmVmcmFjdGlvbk1hcHBpbmcsXG5cdFx0RXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmc6IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLFxuXHRcdEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nOiBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyxcblx0XHRDdWJlVVZSZWZsZWN0aW9uTWFwcGluZzogQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcsXG5cdFx0Q3ViZVVWUmVmcmFjdGlvbk1hcHBpbmc6IEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nXG5cdH07XG5cdGNvbnN0IFRFWFRVUkVfV1JBUFBJTkcgPSB7XG5cdFx0UmVwZWF0V3JhcHBpbmc6IFJlcGVhdFdyYXBwaW5nLFxuXHRcdENsYW1wVG9FZGdlV3JhcHBpbmc6IENsYW1wVG9FZGdlV3JhcHBpbmcsXG5cdFx0TWlycm9yZWRSZXBlYXRXcmFwcGluZzogTWlycm9yZWRSZXBlYXRXcmFwcGluZ1xuXHR9O1xuXHRjb25zdCBURVhUVVJFX0ZJTFRFUiA9IHtcblx0XHROZWFyZXN0RmlsdGVyOiBOZWFyZXN0RmlsdGVyLFxuXHRcdE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyOiBOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlcixcblx0XHROZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyOiBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyLFxuXHRcdExpbmVhckZpbHRlcjogTGluZWFyRmlsdGVyLFxuXHRcdExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXI6IExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIsXG5cdFx0TGluZWFyTWlwbWFwTGluZWFyRmlsdGVyOiBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXJcblx0fTtcblxuXHRjbGFzcyBJbWFnZUJpdG1hcExvYWRlciBleHRlbmRzIExvYWRlciB7XG5cdFx0Y29uc3RydWN0b3IobWFuYWdlcikge1xuXHRcdFx0c3VwZXIobWFuYWdlcik7XG5cblx0XHRcdGlmICh0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuSW1hZ2VCaXRtYXBMb2FkZXI6IGNyZWF0ZUltYWdlQml0bWFwKCkgbm90IHN1cHBvcnRlZC4nKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5JbWFnZUJpdG1hcExvYWRlcjogZmV0Y2goKSBub3Qgc3VwcG9ydGVkLicpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm9wdGlvbnMgPSB7XG5cdFx0XHRcdHByZW11bHRpcGx5QWxwaGE6ICdub25lJ1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRzZXRPcHRpb25zKG9wdGlvbnMpIHtcblx0XHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG5cdFx0XHRpZiAodXJsID09PSB1bmRlZmluZWQpIHVybCA9ICcnO1xuXHRcdFx0aWYgKHRoaXMucGF0aCAhPT0gdW5kZWZpbmVkKSB1cmwgPSB0aGlzLnBhdGggKyB1cmw7XG5cdFx0XHR1cmwgPSB0aGlzLm1hbmFnZXIucmVzb2x2ZVVSTCh1cmwpO1xuXHRcdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdFx0Y29uc3QgY2FjaGVkID0gQ2FjaGUuZ2V0KHVybCk7XG5cblx0XHRcdGlmIChjYWNoZWQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCh1cmwpO1xuXHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAob25Mb2FkKSBvbkxvYWQoY2FjaGVkKTtcblx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQodXJsKTtcblx0XHRcdFx0fSwgMCk7XG5cdFx0XHRcdHJldHVybiBjYWNoZWQ7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGZldGNoT3B0aW9ucyA9IHt9O1xuXHRcdFx0ZmV0Y2hPcHRpb25zLmNyZWRlbnRpYWxzID0gdGhpcy5jcm9zc09yaWdpbiA9PT0gJ2Fub255bW91cycgPyAnc2FtZS1vcmlnaW4nIDogJ2luY2x1ZGUnO1xuXHRcdFx0ZmV0Y2hPcHRpb25zLmhlYWRlcnMgPSB0aGlzLnJlcXVlc3RIZWFkZXI7XG5cdFx0XHRmZXRjaCh1cmwsIGZldGNoT3B0aW9ucykudGhlbihmdW5jdGlvbiAocmVzKSB7XG5cdFx0XHRcdHJldHVybiByZXMuYmxvYigpO1xuXHRcdFx0fSkudGhlbihmdW5jdGlvbiAoYmxvYikge1xuXHRcdFx0XHRyZXR1cm4gY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYiwgT2JqZWN0LmFzc2lnbihzY29wZS5vcHRpb25zLCB7XG5cdFx0XHRcdFx0Y29sb3JTcGFjZUNvbnZlcnNpb246ICdub25lJ1xuXHRcdFx0XHR9KSk7XG5cdFx0XHR9KS50aGVuKGZ1bmN0aW9uIChpbWFnZUJpdG1hcCkge1xuXHRcdFx0XHRDYWNoZS5hZGQodXJsLCBpbWFnZUJpdG1hcCk7XG5cdFx0XHRcdGlmIChvbkxvYWQpIG9uTG9hZChpbWFnZUJpdG1hcCk7XG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuXHRcdFx0fSkuY2F0Y2goZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0aWYgKG9uRXJyb3IpIG9uRXJyb3IoZSk7XG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKHVybCk7XG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuXHRcdFx0fSk7XG5cdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCh1cmwpO1xuXHRcdH1cblxuXHR9XG5cblx0SW1hZ2VCaXRtYXBMb2FkZXIucHJvdG90eXBlLmlzSW1hZ2VCaXRtYXBMb2FkZXIgPSB0cnVlO1xuXG5cdGxldCBfY29udGV4dDtcblxuXHRjb25zdCBBdWRpb0NvbnRleHQgPSB7XG5cdFx0Z2V0Q29udGV4dDogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKF9jb250ZXh0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0X2NvbnRleHQgPSBuZXcgKHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCkoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIF9jb250ZXh0O1xuXHRcdH0sXG5cdFx0c2V0Q29udGV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRfY29udGV4dCA9IHZhbHVlO1xuXHRcdH1cblx0fTtcblxuXHRjbGFzcyBBdWRpb0xvYWRlciBleHRlbmRzIExvYWRlciB7XG5cdFx0Y29uc3RydWN0b3IobWFuYWdlcikge1xuXHRcdFx0c3VwZXIobWFuYWdlcik7XG5cdFx0fVxuXG5cdFx0bG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuXHRcdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXHRcdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5tYW5hZ2VyKTtcblx0XHRcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoJ2FycmF5YnVmZmVyJyk7XG5cdFx0XHRsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuXHRcdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcblx0XHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuXHRcdFx0bG9hZGVyLmxvYWQodXJsLCBmdW5jdGlvbiAoYnVmZmVyKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gQ3JlYXRlIGEgY29weSBvZiB0aGUgYnVmZmVyLiBUaGUgYGRlY29kZUF1ZGlvRGF0YWAgbWV0aG9kXG5cdFx0XHRcdFx0Ly8gZGV0YWNoZXMgdGhlIGJ1ZmZlciB3aGVuIGNvbXBsZXRlLCBwcmV2ZW50aW5nIHJldXNlLlxuXHRcdFx0XHRcdGNvbnN0IGJ1ZmZlckNvcHkgPSBidWZmZXIuc2xpY2UoMCk7XG5cdFx0XHRcdFx0Y29uc3QgY29udGV4dCA9IEF1ZGlvQ29udGV4dC5nZXRDb250ZXh0KCk7XG5cdFx0XHRcdFx0Y29udGV4dC5kZWNvZGVBdWRpb0RhdGEoYnVmZmVyQ29weSwgZnVuY3Rpb24gKGF1ZGlvQnVmZmVyKSB7XG5cdFx0XHRcdFx0XHRvbkxvYWQoYXVkaW9CdWZmZXIpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0aWYgKG9uRXJyb3IpIHtcblx0XHRcdFx0XHRcdG9uRXJyb3IoZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IodXJsKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvcik7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBIZW1pc3BoZXJlTGlnaHRQcm9iZSBleHRlbmRzIExpZ2h0UHJvYmUge1xuXHRcdGNvbnN0cnVjdG9yKHNreUNvbG9yLCBncm91bmRDb2xvciwgaW50ZW5zaXR5ID0gMSkge1xuXHRcdFx0c3VwZXIodW5kZWZpbmVkLCBpbnRlbnNpdHkpO1xuXHRcdFx0Y29uc3QgY29sb3IxID0gbmV3IENvbG9yKCkuc2V0KHNreUNvbG9yKTtcblx0XHRcdGNvbnN0IGNvbG9yMiA9IG5ldyBDb2xvcigpLnNldChncm91bmRDb2xvcik7XG5cdFx0XHRjb25zdCBza3kgPSBuZXcgVmVjdG9yMyhjb2xvcjEuciwgY29sb3IxLmcsIGNvbG9yMS5iKTtcblx0XHRcdGNvbnN0IGdyb3VuZCA9IG5ldyBWZWN0b3IzKGNvbG9yMi5yLCBjb2xvcjIuZywgY29sb3IyLmIpOyAvLyB3aXRob3V0IGV4dHJhIGZhY3RvciBvZiBQSSBpbiB0aGUgc2hhZGVyLCBzaG91bGQgPSAxIC8gTWF0aC5zcXJ0KCBNYXRoLlBJICk7XG5cblx0XHRcdGNvbnN0IGMwID0gTWF0aC5zcXJ0KE1hdGguUEkpO1xuXHRcdFx0Y29uc3QgYzEgPSBjMCAqIE1hdGguc3FydCgwLjc1KTtcblx0XHRcdHRoaXMuc2guY29lZmZpY2llbnRzWzBdLmNvcHkoc2t5KS5hZGQoZ3JvdW5kKS5tdWx0aXBseVNjYWxhcihjMCk7XG5cdFx0XHR0aGlzLnNoLmNvZWZmaWNpZW50c1sxXS5jb3B5KHNreSkuc3ViKGdyb3VuZCkubXVsdGlwbHlTY2FsYXIoYzEpO1xuXHRcdH1cblxuXHR9XG5cblx0SGVtaXNwaGVyZUxpZ2h0UHJvYmUucHJvdG90eXBlLmlzSGVtaXNwaGVyZUxpZ2h0UHJvYmUgPSB0cnVlO1xuXG5cdGNsYXNzIEFtYmllbnRMaWdodFByb2JlIGV4dGVuZHMgTGlnaHRQcm9iZSB7XG5cdFx0Y29uc3RydWN0b3IoY29sb3IsIGludGVuc2l0eSA9IDEpIHtcblx0XHRcdHN1cGVyKHVuZGVmaW5lZCwgaW50ZW5zaXR5KTtcblx0XHRcdGNvbnN0IGNvbG9yMSA9IG5ldyBDb2xvcigpLnNldChjb2xvcik7IC8vIHdpdGhvdXQgZXh0cmEgZmFjdG9yIG9mIFBJIGluIHRoZSBzaGFkZXIsIHdvdWxkIGJlIDIgLyBNYXRoLnNxcnQoIE1hdGguUEkgKTtcblxuXHRcdFx0dGhpcy5zaC5jb2VmZmljaWVudHNbMF0uc2V0KGNvbG9yMS5yLCBjb2xvcjEuZywgY29sb3IxLmIpLm11bHRpcGx5U2NhbGFyKDIgKiBNYXRoLnNxcnQoTWF0aC5QSSkpO1xuXHRcdH1cblxuXHR9XG5cblx0QW1iaWVudExpZ2h0UHJvYmUucHJvdG90eXBlLmlzQW1iaWVudExpZ2h0UHJvYmUgPSB0cnVlO1xuXG5cdGNvbnN0IF9leWVSaWdodCA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuXG5cdGNvbnN0IF9leWVMZWZ0ID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5cblx0Y29uc3QgX3Byb2plY3Rpb25NYXRyaXggPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDQoKTtcblxuXHRjbGFzcyBTdGVyZW9DYW1lcmEge1xuXHRcdGNvbnN0cnVjdG9yKCkge1xuXHRcdFx0dGhpcy50eXBlID0gJ1N0ZXJlb0NhbWVyYSc7XG5cdFx0XHR0aGlzLmFzcGVjdCA9IDE7XG5cdFx0XHR0aGlzLmV5ZVNlcCA9IDAuMDY0O1xuXHRcdFx0dGhpcy5jYW1lcmFMID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCk7XG5cdFx0XHR0aGlzLmNhbWVyYUwubGF5ZXJzLmVuYWJsZSgxKTtcblx0XHRcdHRoaXMuY2FtZXJhTC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0XHR0aGlzLmNhbWVyYVIgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcblx0XHRcdHRoaXMuY2FtZXJhUi5sYXllcnMuZW5hYmxlKDIpO1xuXHRcdFx0dGhpcy5jYW1lcmFSLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHRcdHRoaXMuX2NhY2hlID0ge1xuXHRcdFx0XHRmb2N1czogbnVsbCxcblx0XHRcdFx0Zm92OiBudWxsLFxuXHRcdFx0XHRhc3BlY3Q6IG51bGwsXG5cdFx0XHRcdG5lYXI6IG51bGwsXG5cdFx0XHRcdGZhcjogbnVsbCxcblx0XHRcdFx0em9vbTogbnVsbCxcblx0XHRcdFx0ZXllU2VwOiBudWxsXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHVwZGF0ZShjYW1lcmEpIHtcblx0XHRcdGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGU7XG5cdFx0XHRjb25zdCBuZWVkc1VwZGF0ZSA9IGNhY2hlLmZvY3VzICE9PSBjYW1lcmEuZm9jdXMgfHwgY2FjaGUuZm92ICE9PSBjYW1lcmEuZm92IHx8IGNhY2hlLmFzcGVjdCAhPT0gY2FtZXJhLmFzcGVjdCAqIHRoaXMuYXNwZWN0IHx8IGNhY2hlLm5lYXIgIT09IGNhbWVyYS5uZWFyIHx8IGNhY2hlLmZhciAhPT0gY2FtZXJhLmZhciB8fCBjYWNoZS56b29tICE9PSBjYW1lcmEuem9vbSB8fCBjYWNoZS5leWVTZXAgIT09IHRoaXMuZXllU2VwO1xuXG5cdFx0XHRpZiAobmVlZHNVcGRhdGUpIHtcblx0XHRcdFx0Y2FjaGUuZm9jdXMgPSBjYW1lcmEuZm9jdXM7XG5cdFx0XHRcdGNhY2hlLmZvdiA9IGNhbWVyYS5mb3Y7XG5cdFx0XHRcdGNhY2hlLmFzcGVjdCA9IGNhbWVyYS5hc3BlY3QgKiB0aGlzLmFzcGVjdDtcblx0XHRcdFx0Y2FjaGUubmVhciA9IGNhbWVyYS5uZWFyO1xuXHRcdFx0XHRjYWNoZS5mYXIgPSBjYW1lcmEuZmFyO1xuXHRcdFx0XHRjYWNoZS56b29tID0gY2FtZXJhLnpvb207XG5cdFx0XHRcdGNhY2hlLmV5ZVNlcCA9IHRoaXMuZXllU2VwOyAvLyBPZmYtYXhpcyBzdGVyZW9zY29waWMgZWZmZWN0IGJhc2VkIG9uXG5cdFx0XHRcdC8vIGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9zdGVyZW9ncmFwaGljcy9zdGVyZW9yZW5kZXIvXG5cblx0XHRcdFx0X3Byb2plY3Rpb25NYXRyaXguY29weShjYW1lcmEucHJvamVjdGlvbk1hdHJpeCk7XG5cblx0XHRcdFx0Y29uc3QgZXllU2VwSGFsZiA9IGNhY2hlLmV5ZVNlcCAvIDI7XG5cdFx0XHRcdGNvbnN0IGV5ZVNlcE9uUHJvamVjdGlvbiA9IGV5ZVNlcEhhbGYgKiBjYWNoZS5uZWFyIC8gY2FjaGUuZm9jdXM7XG5cdFx0XHRcdGNvbnN0IHltYXggPSBjYWNoZS5uZWFyICogTWF0aC50YW4oREVHMlJBRCAqIGNhY2hlLmZvdiAqIDAuNSkgLyBjYWNoZS56b29tO1xuXHRcdFx0XHRsZXQgeG1pbiwgeG1heDsgLy8gdHJhbnNsYXRlIHhPZmZzZXRcblxuXHRcdFx0XHRfZXllTGVmdC5lbGVtZW50c1sxMl0gPSAtZXllU2VwSGFsZjtcblx0XHRcdFx0X2V5ZVJpZ2h0LmVsZW1lbnRzWzEyXSA9IGV5ZVNlcEhhbGY7IC8vIGZvciBsZWZ0IGV5ZVxuXG5cdFx0XHRcdHhtaW4gPSAteW1heCAqIGNhY2hlLmFzcGVjdCArIGV5ZVNlcE9uUHJvamVjdGlvbjtcblx0XHRcdFx0eG1heCA9IHltYXggKiBjYWNoZS5hc3BlY3QgKyBleWVTZXBPblByb2plY3Rpb247XG5cdFx0XHRcdF9wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWzBdID0gMiAqIGNhY2hlLm5lYXIgLyAoeG1heCAtIHhtaW4pO1xuXHRcdFx0XHRfcHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1s4XSA9ICh4bWF4ICsgeG1pbikgLyAoeG1heCAtIHhtaW4pO1xuXHRcdFx0XHR0aGlzLmNhbWVyYUwucHJvamVjdGlvbk1hdHJpeC5jb3B5KF9wcm9qZWN0aW9uTWF0cml4KTsgLy8gZm9yIHJpZ2h0IGV5ZVxuXG5cdFx0XHRcdHhtaW4gPSAteW1heCAqIGNhY2hlLmFzcGVjdCAtIGV5ZVNlcE9uUHJvamVjdGlvbjtcblx0XHRcdFx0eG1heCA9IHltYXggKiBjYWNoZS5hc3BlY3QgLSBleWVTZXBPblByb2plY3Rpb247XG5cdFx0XHRcdF9wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWzBdID0gMiAqIGNhY2hlLm5lYXIgLyAoeG1heCAtIHhtaW4pO1xuXHRcdFx0XHRfcHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1s4XSA9ICh4bWF4ICsgeG1pbikgLyAoeG1heCAtIHhtaW4pO1xuXHRcdFx0XHR0aGlzLmNhbWVyYVIucHJvamVjdGlvbk1hdHJpeC5jb3B5KF9wcm9qZWN0aW9uTWF0cml4KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5jYW1lcmFMLm1hdHJpeFdvcmxkLmNvcHkoY2FtZXJhLm1hdHJpeFdvcmxkKS5tdWx0aXBseShfZXllTGVmdCk7XG5cdFx0XHR0aGlzLmNhbWVyYVIubWF0cml4V29ybGQuY29weShjYW1lcmEubWF0cml4V29ybGQpLm11bHRpcGx5KF9leWVSaWdodCk7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBDbG9jayB7XG5cdFx0Y29uc3RydWN0b3IoYXV0b1N0YXJ0ID0gdHJ1ZSkge1xuXHRcdFx0dGhpcy5hdXRvU3RhcnQgPSBhdXRvU3RhcnQ7XG5cdFx0XHR0aGlzLnN0YXJ0VGltZSA9IDA7XG5cdFx0XHR0aGlzLm9sZFRpbWUgPSAwO1xuXHRcdFx0dGhpcy5lbGFwc2VkVGltZSA9IDA7XG5cdFx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRzdGFydCgpIHtcblx0XHRcdHRoaXMuc3RhcnRUaW1lID0gbm93KCk7XG5cdFx0XHR0aGlzLm9sZFRpbWUgPSB0aGlzLnN0YXJ0VGltZTtcblx0XHRcdHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuXHRcdFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRzdG9wKCkge1xuXHRcdFx0dGhpcy5nZXRFbGFwc2VkVGltZSgpO1xuXHRcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cdFx0XHR0aGlzLmF1dG9TdGFydCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGdldEVsYXBzZWRUaW1lKCkge1xuXHRcdFx0dGhpcy5nZXREZWx0YSgpO1xuXHRcdFx0cmV0dXJuIHRoaXMuZWxhcHNlZFRpbWU7XG5cdFx0fVxuXG5cdFx0Z2V0RGVsdGEoKSB7XG5cdFx0XHRsZXQgZGlmZiA9IDA7XG5cblx0XHRcdGlmICh0aGlzLmF1dG9TdGFydCAmJiAhdGhpcy5ydW5uaW5nKSB7XG5cdFx0XHRcdHRoaXMuc3RhcnQoKTtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLnJ1bm5pbmcpIHtcblx0XHRcdFx0Y29uc3QgbmV3VGltZSA9IG5vdygpO1xuXHRcdFx0XHRkaWZmID0gKG5ld1RpbWUgLSB0aGlzLm9sZFRpbWUpIC8gMTAwMDtcblx0XHRcdFx0dGhpcy5vbGRUaW1lID0gbmV3VGltZTtcblx0XHRcdFx0dGhpcy5lbGFwc2VkVGltZSArPSBkaWZmO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGlmZjtcblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG5vdygpIHtcblx0XHRyZXR1cm4gKHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ3VuZGVmaW5lZCcgPyBEYXRlIDogcGVyZm9ybWFuY2UpLm5vdygpOyAvLyBzZWUgIzEwNzMyXG5cdH1cblxuXHRjb25zdCBfcG9zaXRpb24kMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9xdWF0ZXJuaW9uJDEgPSAvKkBfX1BVUkVfXyovbmV3IFF1YXRlcm5pb24oKTtcblxuXHRjb25zdCBfc2NhbGUkMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9vcmllbnRhdGlvbiQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y2xhc3MgQXVkaW9MaXN0ZW5lciBleHRlbmRzIE9iamVjdDNEIHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnQXVkaW9MaXN0ZW5lcic7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSBBdWRpb0NvbnRleHQuZ2V0Q29udGV4dCgpO1xuXHRcdFx0dGhpcy5nYWluID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblx0XHRcdHRoaXMuZ2Fpbi5jb25uZWN0KHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbik7XG5cdFx0XHR0aGlzLmZpbHRlciA9IG51bGw7XG5cdFx0XHR0aGlzLnRpbWVEZWx0YSA9IDA7IC8vIHByaXZhdGVcblxuXHRcdFx0dGhpcy5fY2xvY2sgPSBuZXcgQ2xvY2soKTtcblx0XHR9XG5cblx0XHRnZXRJbnB1dCgpIHtcblx0XHRcdHJldHVybiB0aGlzLmdhaW47XG5cdFx0fVxuXG5cdFx0cmVtb3ZlRmlsdGVyKCkge1xuXHRcdFx0aWYgKHRoaXMuZmlsdGVyICE9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuZ2Fpbi5kaXNjb25uZWN0KHRoaXMuZmlsdGVyKTtcblx0XHRcdFx0dGhpcy5maWx0ZXIuZGlzY29ubmVjdCh0aGlzLmNvbnRleHQuZGVzdGluYXRpb24pO1xuXHRcdFx0XHR0aGlzLmdhaW4uY29ubmVjdCh0aGlzLmNvbnRleHQuZGVzdGluYXRpb24pO1xuXHRcdFx0XHR0aGlzLmZpbHRlciA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGdldEZpbHRlcigpIHtcblx0XHRcdHJldHVybiB0aGlzLmZpbHRlcjtcblx0XHR9XG5cblx0XHRzZXRGaWx0ZXIodmFsdWUpIHtcblx0XHRcdGlmICh0aGlzLmZpbHRlciAhPT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLmdhaW4uZGlzY29ubmVjdCh0aGlzLmZpbHRlcik7XG5cdFx0XHRcdHRoaXMuZmlsdGVyLmRpc2Nvbm5lY3QodGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZ2Fpbi5kaXNjb25uZWN0KHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbik7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZmlsdGVyID0gdmFsdWU7XG5cdFx0XHR0aGlzLmdhaW4uY29ubmVjdCh0aGlzLmZpbHRlcik7XG5cdFx0XHR0aGlzLmZpbHRlci5jb25uZWN0KHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRnZXRNYXN0ZXJWb2x1bWUoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nYWluLmdhaW4udmFsdWU7XG5cdFx0fVxuXG5cdFx0c2V0TWFzdGVyVm9sdW1lKHZhbHVlKSB7XG5cdFx0XHR0aGlzLmdhaW4uZ2Fpbi5zZXRUYXJnZXRBdFRpbWUodmFsdWUsIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSwgMC4wMSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR1cGRhdGVNYXRyaXhXb3JsZChmb3JjZSkge1xuXHRcdFx0c3VwZXIudXBkYXRlTWF0cml4V29ybGQoZm9yY2UpO1xuXHRcdFx0Y29uc3QgbGlzdGVuZXIgPSB0aGlzLmNvbnRleHQubGlzdGVuZXI7XG5cdFx0XHRjb25zdCB1cCA9IHRoaXMudXA7XG5cdFx0XHR0aGlzLnRpbWVEZWx0YSA9IHRoaXMuX2Nsb2NrLmdldERlbHRhKCk7XG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZShfcG9zaXRpb24kMSwgX3F1YXRlcm5pb24kMSwgX3NjYWxlJDEpO1xuXG5cdFx0XHRfb3JpZW50YXRpb24kMS5zZXQoMCwgMCwgLTEpLmFwcGx5UXVhdGVybmlvbihfcXVhdGVybmlvbiQxKTtcblxuXHRcdFx0aWYgKGxpc3RlbmVyLnBvc2l0aW9uWCkge1xuXHRcdFx0XHQvLyBjb2RlIHBhdGggZm9yIENocm9tZSAoc2VlICMxNDM5Mylcblx0XHRcdFx0Y29uc3QgZW5kVGltZSA9IHRoaXMuY29udGV4dC5jdXJyZW50VGltZSArIHRoaXMudGltZURlbHRhO1xuXHRcdFx0XHRsaXN0ZW5lci5wb3NpdGlvblgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoX3Bvc2l0aW9uJDEueCwgZW5kVGltZSk7XG5cdFx0XHRcdGxpc3RlbmVyLnBvc2l0aW9uWS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShfcG9zaXRpb24kMS55LCBlbmRUaW1lKTtcblx0XHRcdFx0bGlzdGVuZXIucG9zaXRpb25aLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKF9wb3NpdGlvbiQxLnosIGVuZFRpbWUpO1xuXHRcdFx0XHRsaXN0ZW5lci5mb3J3YXJkWC5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShfb3JpZW50YXRpb24kMS54LCBlbmRUaW1lKTtcblx0XHRcdFx0bGlzdGVuZXIuZm9yd2FyZFkubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoX29yaWVudGF0aW9uJDEueSwgZW5kVGltZSk7XG5cdFx0XHRcdGxpc3RlbmVyLmZvcndhcmRaLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKF9vcmllbnRhdGlvbiQxLnosIGVuZFRpbWUpO1xuXHRcdFx0XHRsaXN0ZW5lci51cFgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodXAueCwgZW5kVGltZSk7XG5cdFx0XHRcdGxpc3RlbmVyLnVwWS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh1cC55LCBlbmRUaW1lKTtcblx0XHRcdFx0bGlzdGVuZXIudXBaLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHVwLnosIGVuZFRpbWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGlzdGVuZXIuc2V0UG9zaXRpb24oX3Bvc2l0aW9uJDEueCwgX3Bvc2l0aW9uJDEueSwgX3Bvc2l0aW9uJDEueik7XG5cdFx0XHRcdGxpc3RlbmVyLnNldE9yaWVudGF0aW9uKF9vcmllbnRhdGlvbiQxLngsIF9vcmllbnRhdGlvbiQxLnksIF9vcmllbnRhdGlvbiQxLnosIHVwLngsIHVwLnksIHVwLnopO1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgQXVkaW8gZXh0ZW5kcyBPYmplY3QzRCB7XG5cdFx0Y29uc3RydWN0b3IobGlzdGVuZXIpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnQXVkaW8nO1xuXHRcdFx0dGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gbGlzdGVuZXIuY29udGV4dDtcblx0XHRcdHRoaXMuZ2FpbiA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XG5cdFx0XHR0aGlzLmdhaW4uY29ubmVjdChsaXN0ZW5lci5nZXRJbnB1dCgpKTtcblx0XHRcdHRoaXMuYXV0b3BsYXkgPSBmYWxzZTtcblx0XHRcdHRoaXMuYnVmZmVyID0gbnVsbDtcblx0XHRcdHRoaXMuZGV0dW5lID0gMDtcblx0XHRcdHRoaXMubG9vcCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5sb29wU3RhcnQgPSAwO1xuXHRcdFx0dGhpcy5sb29wRW5kID0gMDtcblx0XHRcdHRoaXMub2Zmc2V0ID0gMDtcblx0XHRcdHRoaXMuZHVyYXRpb24gPSB1bmRlZmluZWQ7XG5cdFx0XHR0aGlzLnBsYXliYWNrUmF0ZSA9IDE7XG5cdFx0XHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPSB0cnVlO1xuXHRcdFx0dGhpcy5zb3VyY2UgPSBudWxsO1xuXHRcdFx0dGhpcy5zb3VyY2VUeXBlID0gJ2VtcHR5Jztcblx0XHRcdHRoaXMuX3N0YXJ0ZWRBdCA9IDA7XG5cdFx0XHR0aGlzLl9wcm9ncmVzcyA9IDA7XG5cdFx0XHR0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMuZmlsdGVycyA9IFtdO1xuXHRcdH1cblxuXHRcdGdldE91dHB1dCgpIHtcblx0XHRcdHJldHVybiB0aGlzLmdhaW47XG5cdFx0fVxuXG5cdFx0c2V0Tm9kZVNvdXJjZShhdWRpb05vZGUpIHtcblx0XHRcdHRoaXMuaGFzUGxheWJhY2tDb250cm9sID0gZmFsc2U7XG5cdFx0XHR0aGlzLnNvdXJjZVR5cGUgPSAnYXVkaW9Ob2RlJztcblx0XHRcdHRoaXMuc291cmNlID0gYXVkaW9Ob2RlO1xuXHRcdFx0dGhpcy5jb25uZWN0KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRNZWRpYUVsZW1lbnRTb3VyY2UobWVkaWFFbGVtZW50KSB7XG5cdFx0XHR0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5zb3VyY2VUeXBlID0gJ21lZGlhTm9kZSc7XG5cdFx0XHR0aGlzLnNvdXJjZSA9IHRoaXMuY29udGV4dC5jcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2UobWVkaWFFbGVtZW50KTtcblx0XHRcdHRoaXMuY29ubmVjdCgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0TWVkaWFTdHJlYW1Tb3VyY2UobWVkaWFTdHJlYW0pIHtcblx0XHRcdHRoaXMuaGFzUGxheWJhY2tDb250cm9sID0gZmFsc2U7XG5cdFx0XHR0aGlzLnNvdXJjZVR5cGUgPSAnbWVkaWFTdHJlYW1Ob2RlJztcblx0XHRcdHRoaXMuc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKG1lZGlhU3RyZWFtKTtcblx0XHRcdHRoaXMuY29ubmVjdCgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0QnVmZmVyKGF1ZGlvQnVmZmVyKSB7XG5cdFx0XHR0aGlzLmJ1ZmZlciA9IGF1ZGlvQnVmZmVyO1xuXHRcdFx0dGhpcy5zb3VyY2VUeXBlID0gJ2J1ZmZlcic7XG5cdFx0XHRpZiAodGhpcy5hdXRvcGxheSkgdGhpcy5wbGF5KCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRwbGF5KGRlbGF5ID0gMCkge1xuXHRcdFx0aWYgKHRoaXMuaXNQbGF5aW5nID09PSB0cnVlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQXVkaW86IEF1ZGlvIGlzIGFscmVhZHkgcGxheWluZy4nKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc3RhcnRlZEF0ID0gdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICsgZGVsYXk7XG5cdFx0XHRjb25zdCBzb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cdFx0XHRzb3VyY2UuYnVmZmVyID0gdGhpcy5idWZmZXI7XG5cdFx0XHRzb3VyY2UubG9vcCA9IHRoaXMubG9vcDtcblx0XHRcdHNvdXJjZS5sb29wU3RhcnQgPSB0aGlzLmxvb3BTdGFydDtcblx0XHRcdHNvdXJjZS5sb29wRW5kID0gdGhpcy5sb29wRW5kO1xuXHRcdFx0c291cmNlLm9uZW5kZWQgPSB0aGlzLm9uRW5kZWQuYmluZCh0aGlzKTtcblx0XHRcdHNvdXJjZS5zdGFydCh0aGlzLl9zdGFydGVkQXQsIHRoaXMuX3Byb2dyZXNzICsgdGhpcy5vZmZzZXQsIHRoaXMuZHVyYXRpb24pO1xuXHRcdFx0dGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuXHRcdFx0dGhpcy5zb3VyY2UgPSBzb3VyY2U7XG5cdFx0XHR0aGlzLnNldERldHVuZSh0aGlzLmRldHVuZSk7XG5cdFx0XHR0aGlzLnNldFBsYXliYWNrUmF0ZSh0aGlzLnBsYXliYWNrUmF0ZSk7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb25uZWN0KCk7XG5cdFx0fVxuXG5cdFx0cGF1c2UoKSB7XG5cdFx0XHRpZiAodGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuaXNQbGF5aW5nID09PSB0cnVlKSB7XG5cdFx0XHRcdC8vIHVwZGF0ZSBjdXJyZW50IHByb2dyZXNzXG5cdFx0XHRcdHRoaXMuX3Byb2dyZXNzICs9IE1hdGgubWF4KHRoaXMuY29udGV4dC5jdXJyZW50VGltZSAtIHRoaXMuX3N0YXJ0ZWRBdCwgMCkgKiB0aGlzLnBsYXliYWNrUmF0ZTtcblxuXHRcdFx0XHRpZiAodGhpcy5sb29wID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0Ly8gZW5zdXJlIF9wcm9ncmVzcyBkb2VzIG5vdCBleGNlZWQgZHVyYXRpb24gd2l0aCBsb29wZWQgYXVkaW9zXG5cdFx0XHRcdFx0dGhpcy5fcHJvZ3Jlc3MgPSB0aGlzLl9wcm9ncmVzcyAlICh0aGlzLmR1cmF0aW9uIHx8IHRoaXMuYnVmZmVyLmR1cmF0aW9uKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuc291cmNlLnN0b3AoKTtcblx0XHRcdFx0dGhpcy5zb3VyY2Uub25lbmRlZCA9IG51bGw7XG5cdFx0XHRcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHN0b3AoKSB7XG5cdFx0XHRpZiAodGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fcHJvZ3Jlc3MgPSAwO1xuXHRcdFx0dGhpcy5zb3VyY2Uuc3RvcCgpO1xuXHRcdFx0dGhpcy5zb3VyY2Uub25lbmRlZCA9IG51bGw7XG5cdFx0XHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29ubmVjdCgpIHtcblx0XHRcdGlmICh0aGlzLmZpbHRlcnMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHR0aGlzLnNvdXJjZS5jb25uZWN0KHRoaXMuZmlsdGVyc1swXSk7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDEsIGwgPSB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5maWx0ZXJzW2kgLSAxXS5jb25uZWN0KHRoaXMuZmlsdGVyc1tpXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmZpbHRlcnNbdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDFdLmNvbm5lY3QodGhpcy5nZXRPdXRwdXQoKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNvdXJjZS5jb25uZWN0KHRoaXMuZ2V0T3V0cHV0KCkpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZGlzY29ubmVjdCgpIHtcblx0XHRcdGlmICh0aGlzLmZpbHRlcnMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHR0aGlzLnNvdXJjZS5kaXNjb25uZWN0KHRoaXMuZmlsdGVyc1swXSk7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDEsIGwgPSB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5maWx0ZXJzW2kgLSAxXS5kaXNjb25uZWN0KHRoaXMuZmlsdGVyc1tpXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmZpbHRlcnNbdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDFdLmRpc2Nvbm5lY3QodGhpcy5nZXRPdXRwdXQoKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNvdXJjZS5kaXNjb25uZWN0KHRoaXMuZ2V0T3V0cHV0KCkpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGdldEZpbHRlcnMoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5maWx0ZXJzO1xuXHRcdH1cblxuXHRcdHNldEZpbHRlcnModmFsdWUpIHtcblx0XHRcdGlmICghdmFsdWUpIHZhbHVlID0gW107XG5cblx0XHRcdGlmICh0aGlzLl9jb25uZWN0ZWQgPT09IHRydWUpIHtcblx0XHRcdFx0dGhpcy5kaXNjb25uZWN0KCk7XG5cdFx0XHRcdHRoaXMuZmlsdGVycyA9IHZhbHVlLnNsaWNlKCk7XG5cdFx0XHRcdHRoaXMuY29ubmVjdCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5maWx0ZXJzID0gdmFsdWUuc2xpY2UoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0RGV0dW5lKHZhbHVlKSB7XG5cdFx0XHR0aGlzLmRldHVuZSA9IHZhbHVlO1xuXHRcdFx0aWYgKHRoaXMuc291cmNlLmRldHVuZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIG9ubHkgc2V0IGRldHVuZSB3aGVuIGF2YWlsYWJsZVxuXG5cdFx0XHRpZiAodGhpcy5pc1BsYXlpbmcgPT09IHRydWUpIHtcblx0XHRcdFx0dGhpcy5zb3VyY2UuZGV0dW5lLnNldFRhcmdldEF0VGltZSh0aGlzLmRldHVuZSwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lLCAwLjAxKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Z2V0RGV0dW5lKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGV0dW5lO1xuXHRcdH1cblxuXHRcdGdldEZpbHRlcigpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldEZpbHRlcnMoKVswXTtcblx0XHR9XG5cblx0XHRzZXRGaWx0ZXIoZmlsdGVyKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRGaWx0ZXJzKGZpbHRlciA/IFtmaWx0ZXJdIDogW10pO1xuXHRcdH1cblxuXHRcdHNldFBsYXliYWNrUmF0ZSh2YWx1ZSkge1xuXHRcdFx0aWYgKHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMucGxheWJhY2tSYXRlID0gdmFsdWU7XG5cblx0XHRcdGlmICh0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSkge1xuXHRcdFx0XHR0aGlzLnNvdXJjZS5wbGF5YmFja1JhdGUuc2V0VGFyZ2V0QXRUaW1lKHRoaXMucGxheWJhY2tSYXRlLCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUsIDAuMDEpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRnZXRQbGF5YmFja1JhdGUoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wbGF5YmFja1JhdGU7XG5cdFx0fVxuXG5cdFx0b25FbmRlZCgpIHtcblx0XHRcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Z2V0TG9vcCgpIHtcblx0XHRcdGlmICh0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5sb29wO1xuXHRcdH1cblxuXHRcdHNldExvb3AodmFsdWUpIHtcblx0XHRcdGlmICh0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmxvb3AgPSB2YWx1ZTtcblxuXHRcdFx0aWYgKHRoaXMuaXNQbGF5aW5nID09PSB0cnVlKSB7XG5cdFx0XHRcdHRoaXMuc291cmNlLmxvb3AgPSB0aGlzLmxvb3A7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldExvb3BTdGFydCh2YWx1ZSkge1xuXHRcdFx0dGhpcy5sb29wU3RhcnQgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldExvb3BFbmQodmFsdWUpIHtcblx0XHRcdHRoaXMubG9vcEVuZCA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Z2V0Vm9sdW1lKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2Fpbi5nYWluLnZhbHVlO1xuXHRcdH1cblxuXHRcdHNldFZvbHVtZSh2YWx1ZSkge1xuXHRcdFx0dGhpcy5nYWluLmdhaW4uc2V0VGFyZ2V0QXRUaW1lKHZhbHVlLCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUsIDAuMDEpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRjb25zdCBfcG9zaXRpb24gPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuXHRjb25zdCBfcXVhdGVybmlvbiA9IC8qQF9fUFVSRV9fKi9uZXcgUXVhdGVybmlvbigpO1xuXG5cdGNvbnN0IF9zY2FsZSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9vcmllbnRhdGlvbiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNsYXNzIFBvc2l0aW9uYWxBdWRpbyBleHRlbmRzIEF1ZGlvIHtcblx0XHRjb25zdHJ1Y3RvcihsaXN0ZW5lcikge1xuXHRcdFx0c3VwZXIobGlzdGVuZXIpO1xuXHRcdFx0dGhpcy5wYW5uZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlUGFubmVyKCk7XG5cdFx0XHR0aGlzLnBhbm5lci5wYW5uaW5nTW9kZWwgPSAnSFJURic7XG5cdFx0XHR0aGlzLnBhbm5lci5jb25uZWN0KHRoaXMuZ2Fpbik7XG5cdFx0fVxuXG5cdFx0Z2V0T3V0cHV0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucGFubmVyO1xuXHRcdH1cblxuXHRcdGdldFJlZkRpc3RhbmNlKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucGFubmVyLnJlZkRpc3RhbmNlO1xuXHRcdH1cblxuXHRcdHNldFJlZkRpc3RhbmNlKHZhbHVlKSB7XG5cdFx0XHR0aGlzLnBhbm5lci5yZWZEaXN0YW5jZSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Z2V0Um9sbG9mZkZhY3RvcigpIHtcblx0XHRcdHJldHVybiB0aGlzLnBhbm5lci5yb2xsb2ZmRmFjdG9yO1xuXHRcdH1cblxuXHRcdHNldFJvbGxvZmZGYWN0b3IodmFsdWUpIHtcblx0XHRcdHRoaXMucGFubmVyLnJvbGxvZmZGYWN0b3IgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGdldERpc3RhbmNlTW9kZWwoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYW5uZXIuZGlzdGFuY2VNb2RlbDtcblx0XHR9XG5cblx0XHRzZXREaXN0YW5jZU1vZGVsKHZhbHVlKSB7XG5cdFx0XHR0aGlzLnBhbm5lci5kaXN0YW5jZU1vZGVsID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRnZXRNYXhEaXN0YW5jZSgpIHtcblx0XHRcdHJldHVybiB0aGlzLnBhbm5lci5tYXhEaXN0YW5jZTtcblx0XHR9XG5cblx0XHRzZXRNYXhEaXN0YW5jZSh2YWx1ZSkge1xuXHRcdFx0dGhpcy5wYW5uZXIubWF4RGlzdGFuY2UgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldERpcmVjdGlvbmFsQ29uZShjb25lSW5uZXJBbmdsZSwgY29uZU91dGVyQW5nbGUsIGNvbmVPdXRlckdhaW4pIHtcblx0XHRcdHRoaXMucGFubmVyLmNvbmVJbm5lckFuZ2xlID0gY29uZUlubmVyQW5nbGU7XG5cdFx0XHR0aGlzLnBhbm5lci5jb25lT3V0ZXJBbmdsZSA9IGNvbmVPdXRlckFuZ2xlO1xuXHRcdFx0dGhpcy5wYW5uZXIuY29uZU91dGVyR2FpbiA9IGNvbmVPdXRlckdhaW47XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR1cGRhdGVNYXRyaXhXb3JsZChmb3JjZSkge1xuXHRcdFx0c3VwZXIudXBkYXRlTWF0cml4V29ybGQoZm9yY2UpO1xuXHRcdFx0aWYgKHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSB0cnVlICYmIHRoaXMuaXNQbGF5aW5nID09PSBmYWxzZSkgcmV0dXJuO1xuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoX3Bvc2l0aW9uLCBfcXVhdGVybmlvbiwgX3NjYWxlKTtcblxuXHRcdFx0X29yaWVudGF0aW9uLnNldCgwLCAwLCAxKS5hcHBseVF1YXRlcm5pb24oX3F1YXRlcm5pb24pO1xuXG5cdFx0XHRjb25zdCBwYW5uZXIgPSB0aGlzLnBhbm5lcjtcblxuXHRcdFx0aWYgKHBhbm5lci5wb3NpdGlvblgpIHtcblx0XHRcdFx0Ly8gY29kZSBwYXRoIGZvciBDaHJvbWUgYW5kIEZpcmVmb3ggKHNlZSAjMTQzOTMpXG5cdFx0XHRcdGNvbnN0IGVuZFRpbWUgPSB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLmxpc3RlbmVyLnRpbWVEZWx0YTtcblx0XHRcdFx0cGFubmVyLnBvc2l0aW9uWC5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShfcG9zaXRpb24ueCwgZW5kVGltZSk7XG5cdFx0XHRcdHBhbm5lci5wb3NpdGlvblkubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoX3Bvc2l0aW9uLnksIGVuZFRpbWUpO1xuXHRcdFx0XHRwYW5uZXIucG9zaXRpb25aLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKF9wb3NpdGlvbi56LCBlbmRUaW1lKTtcblx0XHRcdFx0cGFubmVyLm9yaWVudGF0aW9uWC5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShfb3JpZW50YXRpb24ueCwgZW5kVGltZSk7XG5cdFx0XHRcdHBhbm5lci5vcmllbnRhdGlvblkubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoX29yaWVudGF0aW9uLnksIGVuZFRpbWUpO1xuXHRcdFx0XHRwYW5uZXIub3JpZW50YXRpb25aLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKF9vcmllbnRhdGlvbi56LCBlbmRUaW1lKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhbm5lci5zZXRQb3NpdGlvbihfcG9zaXRpb24ueCwgX3Bvc2l0aW9uLnksIF9wb3NpdGlvbi56KTtcblx0XHRcdFx0cGFubmVyLnNldE9yaWVudGF0aW9uKF9vcmllbnRhdGlvbi54LCBfb3JpZW50YXRpb24ueSwgX29yaWVudGF0aW9uLnopO1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgQXVkaW9BbmFseXNlciB7XG5cdFx0Y29uc3RydWN0b3IoYXVkaW8sIGZmdFNpemUgPSAyMDQ4KSB7XG5cdFx0XHR0aGlzLmFuYWx5c2VyID0gYXVkaW8uY29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuXHRcdFx0dGhpcy5hbmFseXNlci5mZnRTaXplID0gZmZ0U2l6ZTtcblx0XHRcdHRoaXMuZGF0YSA9IG5ldyBVaW50OEFycmF5KHRoaXMuYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQpO1xuXHRcdFx0YXVkaW8uZ2V0T3V0cHV0KCkuY29ubmVjdCh0aGlzLmFuYWx5c2VyKTtcblx0XHR9XG5cblx0XHRnZXRGcmVxdWVuY3lEYXRhKCkge1xuXHRcdFx0dGhpcy5hbmFseXNlci5nZXRCeXRlRnJlcXVlbmN5RGF0YSh0aGlzLmRhdGEpO1xuXHRcdFx0cmV0dXJuIHRoaXMuZGF0YTtcblx0XHR9XG5cblx0XHRnZXRBdmVyYWdlRnJlcXVlbmN5KCkge1xuXHRcdFx0bGV0IHZhbHVlID0gMDtcblx0XHRcdGNvbnN0IGRhdGEgPSB0aGlzLmdldEZyZXF1ZW5jeURhdGEoKTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhbHVlICs9IGRhdGFbaV07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAvIGRhdGEubGVuZ3RoO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgUHJvcGVydHlNaXhlciB7XG5cdFx0Y29uc3RydWN0b3IoYmluZGluZywgdHlwZU5hbWUsIHZhbHVlU2l6ZSkge1xuXHRcdFx0dGhpcy5iaW5kaW5nID0gYmluZGluZztcblx0XHRcdHRoaXMudmFsdWVTaXplID0gdmFsdWVTaXplO1xuXHRcdFx0bGV0IG1peEZ1bmN0aW9uLCBtaXhGdW5jdGlvbkFkZGl0aXZlLCBzZXRJZGVudGl0eTsgLy8gYnVmZmVyIGxheW91dDogWyBpbmNvbWluZyB8IGFjY3UwIHwgYWNjdTEgfCBvcmlnIHwgYWRkQWNjdSB8IChvcHRpb25hbCB3b3JrKSBdXG5cdFx0XHQvL1xuXHRcdFx0Ly8gaW50ZXJwb2xhdG9ycyBjYW4gdXNlIC5idWZmZXIgYXMgdGhlaXIgLnJlc3VsdFxuXHRcdFx0Ly8gdGhlIGRhdGEgdGhlbiBnb2VzIHRvICdpbmNvbWluZydcblx0XHRcdC8vXG5cdFx0XHQvLyAnYWNjdTAnIGFuZCAnYWNjdTEnIGFyZSB1c2VkIGZyYW1lLWludGVybGVhdmVkIGZvclxuXHRcdFx0Ly8gdGhlIGN1bXVsYXRpdmUgcmVzdWx0IGFuZCBhcmUgY29tcGFyZWQgdG8gZGV0ZWN0XG5cdFx0XHQvLyBjaGFuZ2VzXG5cdFx0XHQvL1xuXHRcdFx0Ly8gJ29yaWcnIHN0b3JlcyB0aGUgb3JpZ2luYWwgc3RhdGUgb2YgdGhlIHByb3BlcnR5XG5cdFx0XHQvL1xuXHRcdFx0Ly8gJ2FkZCcgaXMgdXNlZCBmb3IgYWRkaXRpdmUgY3VtdWxhdGl2ZSByZXN1bHRzXG5cdFx0XHQvL1xuXHRcdFx0Ly8gJ3dvcmsnIGlzIG9wdGlvbmFsIGFuZCBpcyBvbmx5IHByZXNlbnQgZm9yIHF1YXRlcm5pb24gdHlwZXMuIEl0IGlzIHVzZWRcblx0XHRcdC8vIHRvIHN0b3JlIGludGVybWVkaWF0ZSBxdWF0ZXJuaW9uIG11bHRpcGxpY2F0aW9uIHJlc3VsdHNcblxuXHRcdFx0c3dpdGNoICh0eXBlTmFtZSkge1xuXHRcdFx0XHRjYXNlICdxdWF0ZXJuaW9uJzpcblx0XHRcdFx0XHRtaXhGdW5jdGlvbiA9IHRoaXMuX3NsZXJwO1xuXHRcdFx0XHRcdG1peEZ1bmN0aW9uQWRkaXRpdmUgPSB0aGlzLl9zbGVycEFkZGl0aXZlO1xuXHRcdFx0XHRcdHNldElkZW50aXR5ID0gdGhpcy5fc2V0QWRkaXRpdmVJZGVudGl0eVF1YXRlcm5pb247XG5cdFx0XHRcdFx0dGhpcy5idWZmZXIgPSBuZXcgRmxvYXQ2NEFycmF5KHZhbHVlU2l6ZSAqIDYpO1xuXHRcdFx0XHRcdHRoaXMuX3dvcmtJbmRleCA9IDU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnc3RyaW5nJzpcblx0XHRcdFx0Y2FzZSAnYm9vbCc6XG5cdFx0XHRcdFx0bWl4RnVuY3Rpb24gPSB0aGlzLl9zZWxlY3Q7IC8vIFVzZSB0aGUgcmVndWxhciBtaXggZnVuY3Rpb24gYW5kIGZvciBhZGRpdGl2ZSBvbiB0aGVzZSB0eXBlcyxcblx0XHRcdFx0XHQvLyBhZGRpdGl2ZSBpcyBub3QgcmVsZXZhbnQgZm9yIG5vbi1udW1lcmljIHR5cGVzXG5cblx0XHRcdFx0XHRtaXhGdW5jdGlvbkFkZGl0aXZlID0gdGhpcy5fc2VsZWN0O1xuXHRcdFx0XHRcdHNldElkZW50aXR5ID0gdGhpcy5fc2V0QWRkaXRpdmVJZGVudGl0eU90aGVyO1xuXHRcdFx0XHRcdHRoaXMuYnVmZmVyID0gbmV3IEFycmF5KHZhbHVlU2l6ZSAqIDUpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0bWl4RnVuY3Rpb24gPSB0aGlzLl9sZXJwO1xuXHRcdFx0XHRcdG1peEZ1bmN0aW9uQWRkaXRpdmUgPSB0aGlzLl9sZXJwQWRkaXRpdmU7XG5cdFx0XHRcdFx0c2V0SWRlbnRpdHkgPSB0aGlzLl9zZXRBZGRpdGl2ZUlkZW50aXR5TnVtZXJpYztcblx0XHRcdFx0XHR0aGlzLmJ1ZmZlciA9IG5ldyBGbG9hdDY0QXJyYXkodmFsdWVTaXplICogNSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbiA9IG1peEZ1bmN0aW9uO1xuXHRcdFx0dGhpcy5fbWl4QnVmZmVyUmVnaW9uQWRkaXRpdmUgPSBtaXhGdW5jdGlvbkFkZGl0aXZlO1xuXHRcdFx0dGhpcy5fc2V0SWRlbnRpdHkgPSBzZXRJZGVudGl0eTtcblx0XHRcdHRoaXMuX29yaWdJbmRleCA9IDM7XG5cdFx0XHR0aGlzLl9hZGRJbmRleCA9IDQ7XG5cdFx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSAwO1xuXHRcdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0QWRkaXRpdmUgPSAwO1xuXHRcdFx0dGhpcy51c2VDb3VudCA9IDA7XG5cdFx0XHR0aGlzLnJlZmVyZW5jZUNvdW50ID0gMDtcblx0XHR9IC8vIGFjY3VtdWxhdGUgZGF0YSBpbiB0aGUgJ2luY29taW5nJyByZWdpb24gaW50byAnYWNjdTxpPidcblxuXG5cdFx0YWNjdW11bGF0ZShhY2N1SW5kZXgsIHdlaWdodCkge1xuXHRcdFx0Ly8gbm90ZTogaGFwcGlseSBhY2N1bXVsYXRpbmcgbm90aGluZyB3aGVuIHdlaWdodCA9IDAsIHRoZSBjYWxsZXIga25vd3Ncblx0XHRcdC8vIHRoZSB3ZWlnaHQgYW5kIHNob3VsZG4ndCBoYXZlIG1hZGUgdGhlIGNhbGwgaW4gdGhlIGZpcnN0IHBsYWNlXG5cdFx0XHRjb25zdCBidWZmZXIgPSB0aGlzLmJ1ZmZlcixcblx0XHRcdFx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXHRcdFx0XHRcdFx0b2Zmc2V0ID0gYWNjdUluZGV4ICogc3RyaWRlICsgc3RyaWRlO1xuXHRcdFx0bGV0IGN1cnJlbnRXZWlnaHQgPSB0aGlzLmN1bXVsYXRpdmVXZWlnaHQ7XG5cblx0XHRcdGlmIChjdXJyZW50V2VpZ2h0ID09PSAwKSB7XG5cdFx0XHRcdC8vIGFjY3VOIDo9IGluY29taW5nICogd2VpZ2h0XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7ICsraSkge1xuXHRcdFx0XHRcdGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGJ1ZmZlcltpXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGN1cnJlbnRXZWlnaHQgPSB3ZWlnaHQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBhY2N1TiA6PSBhY2N1TiArIGluY29taW5nICogd2VpZ2h0XG5cdFx0XHRcdGN1cnJlbnRXZWlnaHQgKz0gd2VpZ2h0O1xuXHRcdFx0XHRjb25zdCBtaXggPSB3ZWlnaHQgLyBjdXJyZW50V2VpZ2h0O1xuXG5cdFx0XHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbihidWZmZXIsIG9mZnNldCwgMCwgbWl4LCBzdHJpZGUpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSBjdXJyZW50V2VpZ2h0O1xuXHRcdH0gLy8gYWNjdW11bGF0ZSBkYXRhIGluIHRoZSAnaW5jb21pbmcnIHJlZ2lvbiBpbnRvICdhZGQnXG5cblxuXHRcdGFjY3VtdWxhdGVBZGRpdGl2ZSh3ZWlnaHQpIHtcblx0XHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXMuYnVmZmVyLFxuXHRcdFx0XHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cdFx0XHRcdFx0XHRvZmZzZXQgPSBzdHJpZGUgKiB0aGlzLl9hZGRJbmRleDtcblxuXHRcdFx0aWYgKHRoaXMuY3VtdWxhdGl2ZVdlaWdodEFkZGl0aXZlID09PSAwKSB7XG5cdFx0XHRcdC8vIGFkZCA9IGlkZW50aXR5XG5cdFx0XHRcdHRoaXMuX3NldElkZW50aXR5KCk7XG5cdFx0XHR9IC8vIGFkZCA6PSBhZGQgKyBpbmNvbWluZyAqIHdlaWdodFxuXG5cblx0XHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbkFkZGl0aXZlKGJ1ZmZlciwgb2Zmc2V0LCAwLCB3ZWlnaHQsIHN0cmlkZSk7XG5cblx0XHRcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodEFkZGl0aXZlICs9IHdlaWdodDtcblx0XHR9IC8vIGFwcGx5IHRoZSBzdGF0ZSBvZiAnYWNjdTxpPicgdG8gdGhlIGJpbmRpbmcgd2hlbiBhY2N1cyBkaWZmZXJcblxuXG5cdFx0YXBwbHkoYWNjdUluZGV4KSB7XG5cdFx0XHRjb25zdCBzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcblx0XHRcdFx0XHRcdGJ1ZmZlciA9IHRoaXMuYnVmZmVyLFxuXHRcdFx0XHRcdFx0b2Zmc2V0ID0gYWNjdUluZGV4ICogc3RyaWRlICsgc3RyaWRlLFxuXHRcdFx0XHRcdFx0d2VpZ2h0ID0gdGhpcy5jdW11bGF0aXZlV2VpZ2h0LFxuXHRcdFx0XHRcdFx0d2VpZ2h0QWRkaXRpdmUgPSB0aGlzLmN1bXVsYXRpdmVXZWlnaHRBZGRpdGl2ZSxcblx0XHRcdFx0XHRcdGJpbmRpbmcgPSB0aGlzLmJpbmRpbmc7XG5cdFx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSAwO1xuXHRcdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0QWRkaXRpdmUgPSAwO1xuXG5cdFx0XHRpZiAod2VpZ2h0IDwgMSkge1xuXHRcdFx0XHQvLyBhY2N1TiA6PSBhY2N1TiArIG9yaWdpbmFsICogKCAxIC0gY3VtdWxhdGl2ZVdlaWdodCApXG5cdFx0XHRcdGNvbnN0IG9yaWdpbmFsVmFsdWVPZmZzZXQgPSBzdHJpZGUgKiB0aGlzLl9vcmlnSW5kZXg7XG5cblx0XHRcdFx0dGhpcy5fbWl4QnVmZmVyUmVnaW9uKGJ1ZmZlciwgb2Zmc2V0LCBvcmlnaW5hbFZhbHVlT2Zmc2V0LCAxIC0gd2VpZ2h0LCBzdHJpZGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAod2VpZ2h0QWRkaXRpdmUgPiAwKSB7XG5cdFx0XHRcdC8vIGFjY3VOIDo9IGFjY3VOICsgYWRkaXRpdmUgYWNjdU5cblx0XHRcdFx0dGhpcy5fbWl4QnVmZmVyUmVnaW9uQWRkaXRpdmUoYnVmZmVyLCBvZmZzZXQsIHRoaXMuX2FkZEluZGV4ICogc3RyaWRlLCAxLCBzdHJpZGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGxldCBpID0gc3RyaWRlLCBlID0gc3RyaWRlICsgc3RyaWRlOyBpICE9PSBlOyArK2kpIHtcblx0XHRcdFx0aWYgKGJ1ZmZlcltpXSAhPT0gYnVmZmVyW2kgKyBzdHJpZGVdKSB7XG5cdFx0XHRcdFx0Ly8gdmFsdWUgaGFzIGNoYW5nZWQgLT4gdXBkYXRlIHNjZW5lIGdyYXBoXG5cdFx0XHRcdFx0YmluZGluZy5zZXRWYWx1ZShidWZmZXIsIG9mZnNldCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IC8vIHJlbWVtYmVyIHRoZSBzdGF0ZSBvZiB0aGUgYm91bmQgcHJvcGVydHkgYW5kIGNvcHkgaXQgdG8gYm90aCBhY2N1c1xuXG5cblx0XHRzYXZlT3JpZ2luYWxTdGF0ZSgpIHtcblx0XHRcdGNvbnN0IGJpbmRpbmcgPSB0aGlzLmJpbmRpbmc7XG5cdFx0XHRjb25zdCBidWZmZXIgPSB0aGlzLmJ1ZmZlcixcblx0XHRcdFx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXHRcdFx0XHRcdFx0b3JpZ2luYWxWYWx1ZU9mZnNldCA9IHN0cmlkZSAqIHRoaXMuX29yaWdJbmRleDtcblx0XHRcdGJpbmRpbmcuZ2V0VmFsdWUoYnVmZmVyLCBvcmlnaW5hbFZhbHVlT2Zmc2V0KTsgLy8gYWNjdVswLi4xXSA6PSBvcmlnIC0tIGluaXRpYWxseSBkZXRlY3QgY2hhbmdlcyBhZ2FpbnN0IHRoZSBvcmlnaW5hbFxuXG5cdFx0XHRmb3IgKGxldCBpID0gc3RyaWRlLCBlID0gb3JpZ2luYWxWYWx1ZU9mZnNldDsgaSAhPT0gZTsgKytpKSB7XG5cdFx0XHRcdGJ1ZmZlcltpXSA9IGJ1ZmZlcltvcmlnaW5hbFZhbHVlT2Zmc2V0ICsgaSAlIHN0cmlkZV07XG5cdFx0XHR9IC8vIEFkZCB0byBpZGVudGl0eSBmb3IgYWRkaXRpdmVcblxuXG5cdFx0XHR0aGlzLl9zZXRJZGVudGl0eSgpO1xuXG5cdFx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSAwO1xuXHRcdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0QWRkaXRpdmUgPSAwO1xuXHRcdH0gLy8gYXBwbHkgdGhlIHN0YXRlIHByZXZpb3VzbHkgdGFrZW4gdmlhICdzYXZlT3JpZ2luYWxTdGF0ZScgdG8gdGhlIGJpbmRpbmdcblxuXG5cdFx0cmVzdG9yZU9yaWdpbmFsU3RhdGUoKSB7XG5cdFx0XHRjb25zdCBvcmlnaW5hbFZhbHVlT2Zmc2V0ID0gdGhpcy52YWx1ZVNpemUgKiAzO1xuXHRcdFx0dGhpcy5iaW5kaW5nLnNldFZhbHVlKHRoaXMuYnVmZmVyLCBvcmlnaW5hbFZhbHVlT2Zmc2V0KTtcblx0XHR9XG5cblx0XHRfc2V0QWRkaXRpdmVJZGVudGl0eU51bWVyaWMoKSB7XG5cdFx0XHRjb25zdCBzdGFydEluZGV4ID0gdGhpcy5fYWRkSW5kZXggKiB0aGlzLnZhbHVlU2l6ZTtcblx0XHRcdGNvbnN0IGVuZEluZGV4ID0gc3RhcnRJbmRleCArIHRoaXMudmFsdWVTaXplO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcblx0XHRcdFx0dGhpcy5idWZmZXJbaV0gPSAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdF9zZXRBZGRpdGl2ZUlkZW50aXR5UXVhdGVybmlvbigpIHtcblx0XHRcdHRoaXMuX3NldEFkZGl0aXZlSWRlbnRpdHlOdW1lcmljKCk7XG5cblx0XHRcdHRoaXMuYnVmZmVyW3RoaXMuX2FkZEluZGV4ICogdGhpcy52YWx1ZVNpemUgKyAzXSA9IDE7XG5cdFx0fVxuXG5cdFx0X3NldEFkZGl0aXZlSWRlbnRpdHlPdGhlcigpIHtcblx0XHRcdGNvbnN0IHN0YXJ0SW5kZXggPSB0aGlzLl9vcmlnSW5kZXggKiB0aGlzLnZhbHVlU2l6ZTtcblx0XHRcdGNvbnN0IHRhcmdldEluZGV4ID0gdGhpcy5fYWRkSW5kZXggKiB0aGlzLnZhbHVlU2l6ZTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZhbHVlU2l6ZTsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuYnVmZmVyW3RhcmdldEluZGV4ICsgaV0gPSB0aGlzLmJ1ZmZlcltzdGFydEluZGV4ICsgaV07XG5cdFx0XHR9XG5cdFx0fSAvLyBtaXggZnVuY3Rpb25zXG5cblxuXHRcdF9zZWxlY3QoYnVmZmVyLCBkc3RPZmZzZXQsIHNyY09mZnNldCwgdCwgc3RyaWRlKSB7XG5cdFx0XHRpZiAodCA+PSAwLjUpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgIT09IHN0cmlkZTsgKytpKSB7XG5cdFx0XHRcdFx0YnVmZmVyW2RzdE9mZnNldCArIGldID0gYnVmZmVyW3NyY09mZnNldCArIGldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0X3NsZXJwKGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQpIHtcblx0XHRcdFF1YXRlcm5pb24uc2xlcnBGbGF0KGJ1ZmZlciwgZHN0T2Zmc2V0LCBidWZmZXIsIGRzdE9mZnNldCwgYnVmZmVyLCBzcmNPZmZzZXQsIHQpO1xuXHRcdH1cblxuXHRcdF9zbGVycEFkZGl0aXZlKGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQsIHN0cmlkZSkge1xuXHRcdFx0Y29uc3Qgd29ya09mZnNldCA9IHRoaXMuX3dvcmtJbmRleCAqIHN0cmlkZTsgLy8gU3RvcmUgcmVzdWx0IGluIGludGVybWVkaWF0ZSBidWZmZXIgb2Zmc2V0XG5cblx0XHRcdFF1YXRlcm5pb24ubXVsdGlwbHlRdWF0ZXJuaW9uc0ZsYXQoYnVmZmVyLCB3b3JrT2Zmc2V0LCBidWZmZXIsIGRzdE9mZnNldCwgYnVmZmVyLCBzcmNPZmZzZXQpOyAvLyBTbGVycCB0byB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdFxuXG5cdFx0XHRRdWF0ZXJuaW9uLnNsZXJwRmxhdChidWZmZXIsIGRzdE9mZnNldCwgYnVmZmVyLCBkc3RPZmZzZXQsIGJ1ZmZlciwgd29ya09mZnNldCwgdCk7XG5cdFx0fVxuXG5cdFx0X2xlcnAoYnVmZmVyLCBkc3RPZmZzZXQsIHNyY09mZnNldCwgdCwgc3RyaWRlKSB7XG5cdFx0XHRjb25zdCBzID0gMSAtIHQ7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7ICsraSkge1xuXHRcdFx0XHRjb25zdCBqID0gZHN0T2Zmc2V0ICsgaTtcblx0XHRcdFx0YnVmZmVyW2pdID0gYnVmZmVyW2pdICogcyArIGJ1ZmZlcltzcmNPZmZzZXQgKyBpXSAqIHQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0X2xlcnBBZGRpdGl2ZShidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0LCBzdHJpZGUpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7ICsraSkge1xuXHRcdFx0XHRjb25zdCBqID0gZHN0T2Zmc2V0ICsgaTtcblx0XHRcdFx0YnVmZmVyW2pdID0gYnVmZmVyW2pdICsgYnVmZmVyW3NyY09mZnNldCArIGldICogdDtcblx0XHRcdH1cblx0XHR9XG5cblx0fVxuXG5cdC8vIENoYXJhY3RlcnMgW10uOi8gYXJlIHJlc2VydmVkIGZvciB0cmFjayBiaW5kaW5nIHN5bnRheC5cblx0Y29uc3QgX1JFU0VSVkVEX0NIQVJTX1JFID0gJ1xcXFxbXFxcXF1cXFxcLjpcXFxcLyc7XG5cblx0Y29uc3QgX3Jlc2VydmVkUmUgPSBuZXcgUmVnRXhwKCdbJyArIF9SRVNFUlZFRF9DSEFSU19SRSArICddJywgJ2cnKTsgLy8gQXR0ZW1wdHMgdG8gYWxsb3cgbm9kZSBuYW1lcyBmcm9tIGFueSBsYW5ndWFnZS4gRVM1J3MgYFxcd2AgcmVnZXhwIG1hdGNoZXNcblx0Ly8gb25seSBsYXRpbiBjaGFyYWN0ZXJzLCBhbmQgdGhlIHVuaWNvZGUgXFxwe0x9IGlzIG5vdCB5ZXQgc3VwcG9ydGVkLiBTb1xuXHQvLyBpbnN0ZWFkLCB3ZSBleGNsdWRlIHJlc2VydmVkIGNoYXJhY3RlcnMgYW5kIG1hdGNoIGV2ZXJ5dGhpbmcgZWxzZS5cblxuXG5cdGNvbnN0IF93b3JkQ2hhciA9ICdbXicgKyBfUkVTRVJWRURfQ0hBUlNfUkUgKyAnXSc7XG5cblx0Y29uc3QgX3dvcmRDaGFyT3JEb3QgPSAnW14nICsgX1JFU0VSVkVEX0NIQVJTX1JFLnJlcGxhY2UoJ1xcXFwuJywgJycpICsgJ10nOyAvLyBQYXJlbnQgZGlyZWN0b3JpZXMsIGRlbGltaXRlZCBieSAnLycgb3IgJzonLiBDdXJyZW50bHkgdW51c2VkLCBidXQgbXVzdFxuXHQvLyBiZSBtYXRjaGVkIHRvIHBhcnNlIHRoZSByZXN0IG9mIHRoZSB0cmFjayBuYW1lLlxuXG5cblx0Y29uc3QgX2RpcmVjdG9yeVJlID0gLygoPzpXQytbXFwvOl0pKikvLnNvdXJjZS5yZXBsYWNlKCdXQycsIF93b3JkQ2hhcik7IC8vIFRhcmdldCBub2RlLiBNYXkgY29udGFpbiB3b3JkIGNoYXJhY3RlcnMgKGEtekEtWjAtOV8pIGFuZCAnLicgb3IgJy0nLlxuXG5cblx0Y29uc3QgX25vZGVSZSA9IC8oV0NPRCspPy8uc291cmNlLnJlcGxhY2UoJ1dDT0QnLCBfd29yZENoYXJPckRvdCk7IC8vIE9iamVjdCBvbiB0YXJnZXQgbm9kZSwgYW5kIGFjY2Vzc29yLiBNYXkgbm90IGNvbnRhaW4gcmVzZXJ2ZWRcblx0Ly8gY2hhcmFjdGVycy4gQWNjZXNzb3IgbWF5IGNvbnRhaW4gYW55IGNoYXJhY3RlciBleGNlcHQgY2xvc2luZyBicmFja2V0LlxuXG5cblx0Y29uc3QgX29iamVjdFJlID0gLyg/OlxcLihXQyspKD86XFxbKC4rKVxcXSk/KT8vLnNvdXJjZS5yZXBsYWNlKCdXQycsIF93b3JkQ2hhcik7IC8vIFByb3BlcnR5IGFuZCBhY2Nlc3Nvci4gTWF5IG5vdCBjb250YWluIHJlc2VydmVkIGNoYXJhY3RlcnMuIEFjY2Vzc29yIG1heVxuXHQvLyBjb250YWluIGFueSBub24tYnJhY2tldCBjaGFyYWN0ZXJzLlxuXG5cblx0Y29uc3QgX3Byb3BlcnR5UmUgPSAvXFwuKFdDKykoPzpcXFsoLispXFxdKT8vLnNvdXJjZS5yZXBsYWNlKCdXQycsIF93b3JkQ2hhcik7XG5cblx0Y29uc3QgX3RyYWNrUmUgPSBuZXcgUmVnRXhwKCcnICsgJ14nICsgX2RpcmVjdG9yeVJlICsgX25vZGVSZSArIF9vYmplY3RSZSArIF9wcm9wZXJ0eVJlICsgJyQnKTtcblxuXHRjb25zdCBfc3VwcG9ydGVkT2JqZWN0TmFtZXMgPSBbJ21hdGVyaWFsJywgJ21hdGVyaWFscycsICdib25lcyddO1xuXG5cdGNsYXNzIENvbXBvc2l0ZSB7XG5cdFx0Y29uc3RydWN0b3IodGFyZ2V0R3JvdXAsIHBhdGgsIG9wdGlvbmFsUGFyc2VkUGF0aCkge1xuXHRcdFx0Y29uc3QgcGFyc2VkUGF0aCA9IG9wdGlvbmFsUGFyc2VkUGF0aCB8fCBQcm9wZXJ0eUJpbmRpbmcucGFyc2VUcmFja05hbWUocGF0aCk7XG5cdFx0XHR0aGlzLl90YXJnZXRHcm91cCA9IHRhcmdldEdyb3VwO1xuXHRcdFx0dGhpcy5fYmluZGluZ3MgPSB0YXJnZXRHcm91cC5zdWJzY3JpYmVfKHBhdGgsIHBhcnNlZFBhdGgpO1xuXHRcdH1cblxuXHRcdGdldFZhbHVlKGFycmF5LCBvZmZzZXQpIHtcblx0XHRcdHRoaXMuYmluZCgpOyAvLyBiaW5kIGFsbCBiaW5kaW5nXG5cblx0XHRcdGNvbnN0IGZpcnN0VmFsaWRJbmRleCA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXyxcblx0XHRcdFx0XHRcdGJpbmRpbmcgPSB0aGlzLl9iaW5kaW5nc1tmaXJzdFZhbGlkSW5kZXhdOyAvLyBhbmQgb25seSBjYWxsIC5nZXRWYWx1ZSBvbiB0aGUgZmlyc3RcblxuXHRcdFx0aWYgKGJpbmRpbmcgIT09IHVuZGVmaW5lZCkgYmluZGluZy5nZXRWYWx1ZShhcnJheSwgb2Zmc2V0KTtcblx0XHR9XG5cblx0XHRzZXRWYWx1ZShhcnJheSwgb2Zmc2V0KSB7XG5cdFx0XHRjb25zdCBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gdGhpcy5fdGFyZ2V0R3JvdXAubkNhY2hlZE9iamVjdHNfLCBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdFx0YmluZGluZ3NbaV0uc2V0VmFsdWUoYXJyYXksIG9mZnNldCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YmluZCgpIHtcblx0XHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XG5cblx0XHRcdGZvciAobGV0IGkgPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsraSkge1xuXHRcdFx0XHRiaW5kaW5nc1tpXS5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dW5iaW5kKCkge1xuXHRcdFx0Y29uc3QgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcblxuXHRcdFx0Zm9yIChsZXQgaSA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXywgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRcdGJpbmRpbmdzW2ldLnVuYmluZCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9IC8vIE5vdGU6IFRoaXMgY2xhc3MgdXNlcyBhIFN0YXRlIHBhdHRlcm4gb24gYSBwZXItbWV0aG9kIGJhc2lzOlxuXHQvLyAnYmluZCcgc2V0cyAndGhpcy5nZXRWYWx1ZScgLyAnc2V0VmFsdWUnIGFuZCBzaGFkb3dzIHRoZVxuXHQvLyBwcm90b3R5cGUgdmVyc2lvbiBvZiB0aGVzZSBtZXRob2RzIHdpdGggb25lIHRoYXQgcmVwcmVzZW50c1xuXHQvLyB0aGUgYm91bmQgc3RhdGUuIFdoZW4gdGhlIHByb3BlcnR5IGlzIG5vdCBmb3VuZCwgdGhlIG1ldGhvZHNcblx0Ly8gYmVjb21lIG5vLW9wcy5cblxuXG5cdGNsYXNzIFByb3BlcnR5QmluZGluZyB7XG5cdFx0Y29uc3RydWN0b3Iocm9vdE5vZGUsIHBhdGgsIHBhcnNlZFBhdGgpIHtcblx0XHRcdHRoaXMucGF0aCA9IHBhdGg7XG5cdFx0XHR0aGlzLnBhcnNlZFBhdGggPSBwYXJzZWRQYXRoIHx8IFByb3BlcnR5QmluZGluZy5wYXJzZVRyYWNrTmFtZShwYXRoKTtcblx0XHRcdHRoaXMubm9kZSA9IFByb3BlcnR5QmluZGluZy5maW5kTm9kZShyb290Tm9kZSwgdGhpcy5wYXJzZWRQYXRoLm5vZGVOYW1lKSB8fCByb290Tm9kZTtcblx0XHRcdHRoaXMucm9vdE5vZGUgPSByb290Tm9kZTsgLy8gaW5pdGlhbCBzdGF0ZSBvZiB0aGVzZSBtZXRob2RzIHRoYXQgY2FsbHMgJ2JpbmQnXG5cblx0XHRcdHRoaXMuZ2V0VmFsdWUgPSB0aGlzLl9nZXRWYWx1ZV91bmJvdW5kO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZSA9IHRoaXMuX3NldFZhbHVlX3VuYm91bmQ7XG5cdFx0fVxuXG5cdFx0c3RhdGljIGNyZWF0ZShyb290LCBwYXRoLCBwYXJzZWRQYXRoKSB7XG5cdFx0XHRpZiAoIShyb290ICYmIHJvb3QuaXNBbmltYXRpb25PYmplY3RHcm91cCkpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBQcm9wZXJ0eUJpbmRpbmcocm9vdCwgcGF0aCwgcGFyc2VkUGF0aCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFByb3BlcnR5QmluZGluZy5Db21wb3NpdGUocm9vdCwgcGF0aCwgcGFyc2VkUGF0aCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8qKlxuXHRcdCAqIFJlcGxhY2VzIHNwYWNlcyB3aXRoIHVuZGVyc2NvcmVzIGFuZCByZW1vdmVzIHVuc3VwcG9ydGVkIGNoYXJhY3RlcnMgZnJvbVxuXHRcdCAqIG5vZGUgbmFtZXMsIHRvIGVuc3VyZSBjb21wYXRpYmlsaXR5IHdpdGggcGFyc2VUcmFja05hbWUoKS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5vZGUgbmFtZSB0byBiZSBzYW5pdGl6ZWQuXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfVxuXHRcdCAqL1xuXG5cblx0XHRzdGF0aWMgc2FuaXRpemVOb2RlTmFtZShuYW1lKSB7XG5cdFx0XHRyZXR1cm4gbmFtZS5yZXBsYWNlKC9cXHMvZywgJ18nKS5yZXBsYWNlKF9yZXNlcnZlZFJlLCAnJyk7XG5cdFx0fVxuXG5cdFx0c3RhdGljIHBhcnNlVHJhY2tOYW1lKHRyYWNrTmFtZSkge1xuXHRcdFx0Y29uc3QgbWF0Y2hlcyA9IF90cmFja1JlLmV4ZWModHJhY2tOYW1lKTtcblxuXHRcdFx0aWYgKCFtYXRjaGVzKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignUHJvcGVydHlCaW5kaW5nOiBDYW5ub3QgcGFyc2UgdHJhY2tOYW1lOiAnICsgdHJhY2tOYW1lKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcmVzdWx0cyA9IHtcblx0XHRcdFx0Ly8gZGlyZWN0b3J5TmFtZTogbWF0Y2hlc1sgMSBdLCAvLyAodHNjaHcpIGN1cnJlbnRseSB1bnVzZWRcblx0XHRcdFx0bm9kZU5hbWU6IG1hdGNoZXNbMl0sXG5cdFx0XHRcdG9iamVjdE5hbWU6IG1hdGNoZXNbM10sXG5cdFx0XHRcdG9iamVjdEluZGV4OiBtYXRjaGVzWzRdLFxuXHRcdFx0XHRwcm9wZXJ0eU5hbWU6IG1hdGNoZXNbNV0sXG5cdFx0XHRcdC8vIHJlcXVpcmVkXG5cdFx0XHRcdHByb3BlcnR5SW5kZXg6IG1hdGNoZXNbNl1cblx0XHRcdH07XG5cdFx0XHRjb25zdCBsYXN0RG90ID0gcmVzdWx0cy5ub2RlTmFtZSAmJiByZXN1bHRzLm5vZGVOYW1lLmxhc3RJbmRleE9mKCcuJyk7XG5cblx0XHRcdGlmIChsYXN0RG90ICE9PSB1bmRlZmluZWQgJiYgbGFzdERvdCAhPT0gLTEpIHtcblx0XHRcdFx0Y29uc3Qgb2JqZWN0TmFtZSA9IHJlc3VsdHMubm9kZU5hbWUuc3Vic3RyaW5nKGxhc3REb3QgKyAxKTsgLy8gT2JqZWN0IG5hbWVzIG11c3QgYmUgY2hlY2tlZCBhZ2FpbnN0IGFuIGFsbG93bGlzdC4gT3RoZXJ3aXNlLCB0aGVyZVxuXHRcdFx0XHQvLyBpcyBubyB3YXkgdG8gcGFyc2UgJ2Zvby5iYXIuYmF6JzogJ2JheicgbXVzdCBiZSBhIHByb3BlcnR5LCBidXRcblx0XHRcdFx0Ly8gJ2JhcicgY291bGQgYmUgdGhlIG9iamVjdE5hbWUsIG9yIHBhcnQgb2YgYSBub2RlTmFtZSAod2hpY2ggY2FuXG5cdFx0XHRcdC8vIGluY2x1ZGUgJy4nIGNoYXJhY3RlcnMpLlxuXG5cdFx0XHRcdGlmIChfc3VwcG9ydGVkT2JqZWN0TmFtZXMuaW5kZXhPZihvYmplY3ROYW1lKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRyZXN1bHRzLm5vZGVOYW1lID0gcmVzdWx0cy5ub2RlTmFtZS5zdWJzdHJpbmcoMCwgbGFzdERvdCk7XG5cdFx0XHRcdFx0cmVzdWx0cy5vYmplY3ROYW1lID0gb2JqZWN0TmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAocmVzdWx0cy5wcm9wZXJ0eU5hbWUgPT09IG51bGwgfHwgcmVzdWx0cy5wcm9wZXJ0eU5hbWUubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignUHJvcGVydHlCaW5kaW5nOiBjYW4gbm90IHBhcnNlIHByb3BlcnR5TmFtZSBmcm9tIHRyYWNrTmFtZTogJyArIHRyYWNrTmFtZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH1cblxuXHRcdHN0YXRpYyBmaW5kTm9kZShyb290LCBub2RlTmFtZSkge1xuXHRcdFx0aWYgKCFub2RlTmFtZSB8fCBub2RlTmFtZSA9PT0gJycgfHwgbm9kZU5hbWUgPT09ICcuJyB8fCBub2RlTmFtZSA9PT0gLTEgfHwgbm9kZU5hbWUgPT09IHJvb3QubmFtZSB8fCBub2RlTmFtZSA9PT0gcm9vdC51dWlkKSB7XG5cdFx0XHRcdHJldHVybiByb290O1xuXHRcdFx0fSAvLyBzZWFyY2ggaW50byBza2VsZXRvbiBib25lcy5cblxuXG5cdFx0XHRpZiAocm9vdC5za2VsZXRvbikge1xuXHRcdFx0XHRjb25zdCBib25lID0gcm9vdC5za2VsZXRvbi5nZXRCb25lQnlOYW1lKG5vZGVOYW1lKTtcblxuXHRcdFx0XHRpZiAoYm9uZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJvbmU7XG5cdFx0XHRcdH1cblx0XHRcdH0gLy8gc2VhcmNoIGludG8gbm9kZSBzdWJ0cmVlLlxuXG5cblx0XHRcdGlmIChyb290LmNoaWxkcmVuKSB7XG5cdFx0XHRcdGNvbnN0IHNlYXJjaE5vZGVTdWJ0cmVlID0gZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgY2hpbGROb2RlID0gY2hpbGRyZW5baV07XG5cblx0XHRcdFx0XHRcdGlmIChjaGlsZE5vZGUubmFtZSA9PT0gbm9kZU5hbWUgfHwgY2hpbGROb2RlLnV1aWQgPT09IG5vZGVOYW1lKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBjaGlsZE5vZGU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNvbnN0IHJlc3VsdCA9IHNlYXJjaE5vZGVTdWJ0cmVlKGNoaWxkTm9kZS5jaGlsZHJlbik7XG5cdFx0XHRcdFx0XHRpZiAocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGNvbnN0IHN1YlRyZWVOb2RlID0gc2VhcmNoTm9kZVN1YnRyZWUocm9vdC5jaGlsZHJlbik7XG5cblx0XHRcdFx0aWYgKHN1YlRyZWVOb2RlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN1YlRyZWVOb2RlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0gLy8gdGhlc2UgYXJlIHVzZWQgdG8gXCJiaW5kXCIgYSBub25leGlzdGVudCBwcm9wZXJ0eVxuXG5cblx0XHRfZ2V0VmFsdWVfdW5hdmFpbGFibGUoKSB7fVxuXG5cdFx0X3NldFZhbHVlX3VuYXZhaWxhYmxlKCkge30gLy8gR2V0dGVyc1xuXG5cblx0XHRfZ2V0VmFsdWVfZGlyZWN0KGJ1ZmZlciwgb2Zmc2V0KSB7XG5cdFx0XHRidWZmZXJbb2Zmc2V0XSA9IHRoaXMudGFyZ2V0T2JqZWN0W3RoaXMucHJvcGVydHlOYW1lXTtcblx0XHR9XG5cblx0XHRfZ2V0VmFsdWVfYXJyYXkoYnVmZmVyLCBvZmZzZXQpIHtcblx0XHRcdGNvbnN0IHNvdXJjZSA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBzb3VyY2UubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdFx0YnVmZmVyW29mZnNldCsrXSA9IHNvdXJjZVtpXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRfZ2V0VmFsdWVfYXJyYXlFbGVtZW50KGJ1ZmZlciwgb2Zmc2V0KSB7XG5cdFx0XHRidWZmZXJbb2Zmc2V0XSA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eVt0aGlzLnByb3BlcnR5SW5kZXhdO1xuXHRcdH1cblxuXHRcdF9nZXRWYWx1ZV90b0FycmF5KGJ1ZmZlciwgb2Zmc2V0KSB7XG5cdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkudG9BcnJheShidWZmZXIsIG9mZnNldCk7XG5cdFx0fSAvLyBEaXJlY3RcblxuXG5cdFx0X3NldFZhbHVlX2RpcmVjdChidWZmZXIsIG9mZnNldCkge1xuXHRcdFx0dGhpcy50YXJnZXRPYmplY3RbdGhpcy5wcm9wZXJ0eU5hbWVdID0gYnVmZmVyW29mZnNldF07XG5cdFx0fVxuXG5cdFx0X3NldFZhbHVlX2RpcmVjdF9zZXROZWVkc1VwZGF0ZShidWZmZXIsIG9mZnNldCkge1xuXHRcdFx0dGhpcy50YXJnZXRPYmplY3RbdGhpcy5wcm9wZXJ0eU5hbWVdID0gYnVmZmVyW29mZnNldF07XG5cdFx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0X3NldFZhbHVlX2RpcmVjdF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKGJ1ZmZlciwgb2Zmc2V0KSB7XG5cdFx0XHR0aGlzLnRhcmdldE9iamVjdFt0aGlzLnByb3BlcnR5TmFtZV0gPSBidWZmZXJbb2Zmc2V0XTtcblx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdH0gLy8gRW50aXJlQXJyYXlcblxuXG5cdFx0X3NldFZhbHVlX2FycmF5KGJ1ZmZlciwgb2Zmc2V0KSB7XG5cdFx0XHRjb25zdCBkZXN0ID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbiA9IGRlc3QubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdFx0ZGVzdFtpXSA9IGJ1ZmZlcltvZmZzZXQrK107XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0X3NldFZhbHVlX2FycmF5X3NldE5lZWRzVXBkYXRlKGJ1ZmZlciwgb2Zmc2V0KSB7XG5cdFx0XHRjb25zdCBkZXN0ID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbiA9IGRlc3QubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdFx0ZGVzdFtpXSA9IGJ1ZmZlcltvZmZzZXQrK107XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRfc2V0VmFsdWVfYXJyYXlfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZShidWZmZXIsIG9mZnNldCkge1xuXHRcdFx0Y29uc3QgZGVzdCA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBkZXN0Lmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRcdGRlc3RbaV0gPSBidWZmZXJbb2Zmc2V0KytdO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHR9IC8vIEFycmF5RWxlbWVudFxuXG5cblx0XHRfc2V0VmFsdWVfYXJyYXlFbGVtZW50KGJ1ZmZlciwgb2Zmc2V0KSB7XG5cdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHlbdGhpcy5wcm9wZXJ0eUluZGV4XSA9IGJ1ZmZlcltvZmZzZXRdO1xuXHRcdH1cblxuXHRcdF9zZXRWYWx1ZV9hcnJheUVsZW1lbnRfc2V0TmVlZHNVcGRhdGUoYnVmZmVyLCBvZmZzZXQpIHtcblx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eVt0aGlzLnByb3BlcnR5SW5kZXhdID0gYnVmZmVyW29mZnNldF07XG5cdFx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0X3NldFZhbHVlX2FycmF5RWxlbWVudF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKGJ1ZmZlciwgb2Zmc2V0KSB7XG5cdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHlbdGhpcy5wcm9wZXJ0eUluZGV4XSA9IGJ1ZmZlcltvZmZzZXRdO1xuXHRcdFx0dGhpcy50YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0fSAvLyBIYXNUb0Zyb21BcnJheVxuXG5cblx0XHRfc2V0VmFsdWVfZnJvbUFycmF5KGJ1ZmZlciwgb2Zmc2V0KSB7XG5cdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkuZnJvbUFycmF5KGJ1ZmZlciwgb2Zmc2V0KTtcblx0XHR9XG5cblx0XHRfc2V0VmFsdWVfZnJvbUFycmF5X3NldE5lZWRzVXBkYXRlKGJ1ZmZlciwgb2Zmc2V0KSB7XG5cdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkuZnJvbUFycmF5KGJ1ZmZlciwgb2Zmc2V0KTtcblx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRfc2V0VmFsdWVfZnJvbUFycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoYnVmZmVyLCBvZmZzZXQpIHtcblx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eS5mcm9tQXJyYXkoYnVmZmVyLCBvZmZzZXQpO1xuXHRcdFx0dGhpcy50YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0X2dldFZhbHVlX3VuYm91bmQodGFyZ2V0QXJyYXksIG9mZnNldCkge1xuXHRcdFx0dGhpcy5iaW5kKCk7XG5cdFx0XHR0aGlzLmdldFZhbHVlKHRhcmdldEFycmF5LCBvZmZzZXQpO1xuXHRcdH1cblxuXHRcdF9zZXRWYWx1ZV91bmJvdW5kKHNvdXJjZUFycmF5LCBvZmZzZXQpIHtcblx0XHRcdHRoaXMuYmluZCgpO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZShzb3VyY2VBcnJheSwgb2Zmc2V0KTtcblx0XHR9IC8vIGNyZWF0ZSBnZXR0ZXIgLyBzZXR0ZXIgcGFpciBmb3IgYSBwcm9wZXJ0eSBpbiB0aGUgc2NlbmUgZ3JhcGhcblxuXG5cdFx0YmluZCgpIHtcblx0XHRcdGxldCB0YXJnZXRPYmplY3QgPSB0aGlzLm5vZGU7XG5cdFx0XHRjb25zdCBwYXJzZWRQYXRoID0gdGhpcy5wYXJzZWRQYXRoO1xuXHRcdFx0Y29uc3Qgb2JqZWN0TmFtZSA9IHBhcnNlZFBhdGgub2JqZWN0TmFtZTtcblx0XHRcdGNvbnN0IHByb3BlcnR5TmFtZSA9IHBhcnNlZFBhdGgucHJvcGVydHlOYW1lO1xuXHRcdFx0bGV0IHByb3BlcnR5SW5kZXggPSBwYXJzZWRQYXRoLnByb3BlcnR5SW5kZXg7XG5cblx0XHRcdGlmICghdGFyZ2V0T2JqZWN0KSB7XG5cdFx0XHRcdHRhcmdldE9iamVjdCA9IFByb3BlcnR5QmluZGluZy5maW5kTm9kZSh0aGlzLnJvb3ROb2RlLCBwYXJzZWRQYXRoLm5vZGVOYW1lKSB8fCB0aGlzLnJvb3ROb2RlO1xuXHRcdFx0XHR0aGlzLm5vZGUgPSB0YXJnZXRPYmplY3Q7XG5cdFx0XHR9IC8vIHNldCBmYWlsIHN0YXRlIHNvIHdlIGNhbiBqdXN0ICdyZXR1cm4nIG9uIGVycm9yXG5cblxuXHRcdFx0dGhpcy5nZXRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlX3VuYXZhaWxhYmxlO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZSA9IHRoaXMuX3NldFZhbHVlX3VuYXZhaWxhYmxlOyAvLyBlbnN1cmUgdGhlcmUgaXMgYSB2YWx1ZSBub2RlXG5cblx0XHRcdGlmICghdGFyZ2V0T2JqZWN0KSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlByb3BlcnR5QmluZGluZzogVHJ5aW5nIHRvIHVwZGF0ZSBub2RlIGZvciB0cmFjazogJyArIHRoaXMucGF0aCArICcgYnV0IGl0IHdhc25cXCd0IGZvdW5kLicpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvYmplY3ROYW1lKSB7XG5cdFx0XHRcdGxldCBvYmplY3RJbmRleCA9IHBhcnNlZFBhdGgub2JqZWN0SW5kZXg7IC8vIHNwZWNpYWwgY2FzZXMgd2VyZSB3ZSBuZWVkIHRvIHJlYWNoIGRlZXBlciBpbnRvIHRoZSBoaWVyYXJjaHkgdG8gZ2V0IHRoZSBmYWNlIG1hdGVyaWFscy4uLi5cblxuXHRcdFx0XHRzd2l0Y2ggKG9iamVjdE5hbWUpIHtcblx0XHRcdFx0XHRjYXNlICdtYXRlcmlhbHMnOlxuXHRcdFx0XHRcdFx0aWYgKCF0YXJnZXRPYmplY3QubWF0ZXJpYWwpIHtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbWF0ZXJpYWwgYXMgbm9kZSBkb2VzIG5vdCBoYXZlIGEgbWF0ZXJpYWwuJywgdGhpcyk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCF0YXJnZXRPYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG1hdGVyaWFsLm1hdGVyaWFscyBhcyBub2RlLm1hdGVyaWFsIGRvZXMgbm90IGhhdmUgYSBtYXRlcmlhbHMgYXJyYXkuJywgdGhpcyk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsLm1hdGVyaWFscztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnYm9uZXMnOlxuXHRcdFx0XHRcdFx0aWYgKCF0YXJnZXRPYmplY3Quc2tlbGV0b24pIHtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gYm9uZXMgYXMgbm9kZSBkb2VzIG5vdCBoYXZlIGEgc2tlbGV0b24uJywgdGhpcyk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH0gLy8gcG90ZW50aWFsIGZ1dHVyZSBvcHRpbWl6YXRpb246IHNraXAgdGhpcyBpZiBwcm9wZXJ0eUluZGV4IGlzIGFscmVhZHkgYW4gaW50ZWdlclxuXHRcdFx0XHRcdFx0Ly8gYW5kIGNvbnZlcnQgdGhlIGludGVnZXIgc3RyaW5nIHRvIGEgdHJ1ZSBpbnRlZ2VyLlxuXG5cblx0XHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdC5za2VsZXRvbi5ib25lczsgLy8gc3VwcG9ydCByZXNvbHZpbmcgbW9ycGhUYXJnZXQgbmFtZXMgaW50byBpbmRpY2VzLlxuXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldE9iamVjdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRpZiAodGFyZ2V0T2JqZWN0W2ldLm5hbWUgPT09IG9iamVjdEluZGV4KSB7XG5cdFx0XHRcdFx0XHRcdFx0b2JqZWN0SW5kZXggPSBpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGlmICh0YXJnZXRPYmplY3Rbb2JqZWN0TmFtZV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBvYmplY3ROYW1lIG9mIG5vZGUgdW5kZWZpbmVkLicsIHRoaXMpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdFtvYmplY3ROYW1lXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChvYmplY3RJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0aWYgKHRhcmdldE9iamVjdFtvYmplY3RJbmRleF0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBUcnlpbmcgdG8gYmluZCB0byBvYmplY3RJbmRleCBvZiBvYmplY3ROYW1lLCBidXQgaXMgdW5kZWZpbmVkLicsIHRoaXMsIHRhcmdldE9iamVjdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0W29iamVjdEluZGV4XTtcblx0XHRcdFx0fVxuXHRcdFx0fSAvLyByZXNvbHZlIHByb3BlcnR5XG5cblxuXHRcdFx0Y29uc3Qgbm9kZVByb3BlcnR5ID0gdGFyZ2V0T2JqZWN0W3Byb3BlcnR5TmFtZV07XG5cblx0XHRcdGlmIChub2RlUHJvcGVydHkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb25zdCBub2RlTmFtZSA9IHBhcnNlZFBhdGgubm9kZU5hbWU7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlByb3BlcnR5QmluZGluZzogVHJ5aW5nIHRvIHVwZGF0ZSBwcm9wZXJ0eSBmb3IgdHJhY2s6ICcgKyBub2RlTmFtZSArICcuJyArIHByb3BlcnR5TmFtZSArICcgYnV0IGl0IHdhc25cXCd0IGZvdW5kLicsIHRhcmdldE9iamVjdCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gLy8gZGV0ZXJtaW5lIHZlcnNpb25pbmcgc2NoZW1lXG5cblxuXHRcdFx0bGV0IHZlcnNpb25pbmcgPSB0aGlzLlZlcnNpb25pbmcuTm9uZTtcblx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0O1xuXG5cdFx0XHRpZiAodGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Ly8gbWF0ZXJpYWxcblx0XHRcdFx0dmVyc2lvbmluZyA9IHRoaXMuVmVyc2lvbmluZy5OZWVkc1VwZGF0ZTtcblx0XHRcdH0gZWxzZSBpZiAodGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQvLyBub2RlIHRyYW5zZm9ybVxuXHRcdFx0XHR2ZXJzaW9uaW5nID0gdGhpcy5WZXJzaW9uaW5nLk1hdHJpeFdvcmxkTmVlZHNVcGRhdGU7XG5cdFx0XHR9IC8vIGRldGVybWluZSBob3cgdGhlIHByb3BlcnR5IGdldHMgYm91bmRcblxuXG5cdFx0XHRsZXQgYmluZGluZ1R5cGUgPSB0aGlzLkJpbmRpbmdUeXBlLkRpcmVjdDtcblxuXHRcdFx0aWYgKHByb3BlcnR5SW5kZXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQvLyBhY2Nlc3MgYSBzdWIgZWxlbWVudCBvZiB0aGUgcHJvcGVydHkgYXJyYXkgKG9ubHkgcHJpbWl0aXZlcyBhcmUgc3VwcG9ydGVkIHJpZ2h0IG5vdylcblx0XHRcdFx0aWYgKHByb3BlcnR5TmFtZSA9PT0gJ21vcnBoVGFyZ2V0SW5mbHVlbmNlcycpIHtcblx0XHRcdFx0XHQvLyBwb3RlbnRpYWwgb3B0aW1pemF0aW9uLCBza2lwIHRoaXMgaWYgcHJvcGVydHlJbmRleCBpcyBhbHJlYWR5IGFuIGludGVnZXIsIGFuZCBjb252ZXJ0IHRoZSBpbnRlZ2VyIHN0cmluZyB0byBhIHRydWUgaW50ZWdlci5cblx0XHRcdFx0XHQvLyBzdXBwb3J0IHJlc29sdmluZyBtb3JwaFRhcmdldCBuYW1lcyBpbnRvIGluZGljZXMuXG5cdFx0XHRcdFx0aWYgKCF0YXJnZXRPYmplY3QuZ2VvbWV0cnkpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBiZWNhdXNlIG5vZGUgZG9lcyBub3QgaGF2ZSBhIGdlb21ldHJ5LicsIHRoaXMpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0YXJnZXRPYmplY3QuZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSkge1xuXHRcdFx0XHRcdFx0aWYgKCF0YXJnZXRPYmplY3QuZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBiZWNhdXNlIG5vZGUgZG9lcyBub3QgaGF2ZSBhIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy4nLCB0aGlzKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAodGFyZ2V0T2JqZWN0Lm1vcnBoVGFyZ2V0RGljdGlvbmFyeVtwcm9wZXJ0eUluZGV4XSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5SW5kZXggPSB0YXJnZXRPYmplY3QubW9ycGhUYXJnZXREaWN0aW9uYXJ5W3Byb3BlcnR5SW5kZXhdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtb3JwaFRhcmdldEluZmx1ZW5jZXMgb24gVEhSRUUuR2VvbWV0cnkuIFVzZSBUSFJFRS5CdWZmZXJHZW9tZXRyeSBpbnN0ZWFkLicsIHRoaXMpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5BcnJheUVsZW1lbnQ7XG5cdFx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcblx0XHRcdFx0dGhpcy5wcm9wZXJ0eUluZGV4ID0gcHJvcGVydHlJbmRleDtcblx0XHRcdH0gZWxzZSBpZiAobm9kZVByb3BlcnR5LmZyb21BcnJheSAhPT0gdW5kZWZpbmVkICYmIG5vZGVQcm9wZXJ0eS50b0FycmF5ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Ly8gbXVzdCB1c2UgY29weSBmb3IgT2JqZWN0M0QuRXVsZXIvUXVhdGVybmlvblxuXHRcdFx0XHRiaW5kaW5nVHlwZSA9IHRoaXMuQmluZGluZ1R5cGUuSGFzRnJvbVRvQXJyYXk7XG5cdFx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShub2RlUHJvcGVydHkpKSB7XG5cdFx0XHRcdGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5FbnRpcmVBcnJheTtcblx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5ID0gbm9kZVByb3BlcnR5O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG5cdFx0XHR9IC8vIHNlbGVjdCBnZXR0ZXIgLyBzZXR0ZXJcblxuXG5cdFx0XHR0aGlzLmdldFZhbHVlID0gdGhpcy5HZXR0ZXJCeUJpbmRpbmdUeXBlW2JpbmRpbmdUeXBlXTtcblx0XHRcdHRoaXMuc2V0VmFsdWUgPSB0aGlzLlNldHRlckJ5QmluZGluZ1R5cGVBbmRWZXJzaW9uaW5nW2JpbmRpbmdUeXBlXVt2ZXJzaW9uaW5nXTtcblx0XHR9XG5cblx0XHR1bmJpbmQoKSB7XG5cdFx0XHR0aGlzLm5vZGUgPSBudWxsOyAvLyBiYWNrIHRvIHRoZSBwcm90b3R5cGUgdmVyc2lvbiBvZiBnZXRWYWx1ZSAvIHNldFZhbHVlXG5cdFx0XHQvLyBub3RlOiBhdm9pZGluZyB0byBtdXRhdGUgdGhlIHNoYXBlIG9mICd0aGlzJyB2aWEgJ2RlbGV0ZSdcblxuXHRcdFx0dGhpcy5nZXRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlX3VuYm91bmQ7XG5cdFx0XHR0aGlzLnNldFZhbHVlID0gdGhpcy5fc2V0VmFsdWVfdW5ib3VuZDtcblx0XHR9XG5cblx0fVxuXG5cdFByb3BlcnR5QmluZGluZy5Db21wb3NpdGUgPSBDb21wb3NpdGU7XG5cdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuQmluZGluZ1R5cGUgPSB7XG5cdFx0RGlyZWN0OiAwLFxuXHRcdEVudGlyZUFycmF5OiAxLFxuXHRcdEFycmF5RWxlbWVudDogMixcblx0XHRIYXNGcm9tVG9BcnJheTogM1xuXHR9O1xuXHRQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLlZlcnNpb25pbmcgPSB7XG5cdFx0Tm9uZTogMCxcblx0XHROZWVkc1VwZGF0ZTogMSxcblx0XHRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlOiAyXG5cdH07XG5cdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuR2V0dGVyQnlCaW5kaW5nVHlwZSA9IFtQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9nZXRWYWx1ZV9kaXJlY3QsIFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX2dldFZhbHVlX2FycmF5LCBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9nZXRWYWx1ZV9hcnJheUVsZW1lbnQsIFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX2dldFZhbHVlX3RvQXJyYXldO1xuXHRQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLlNldHRlckJ5QmluZGluZ1R5cGVBbmRWZXJzaW9uaW5nID0gW1svLyBEaXJlY3Rcblx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfZGlyZWN0LCBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9kaXJlY3Rfc2V0TmVlZHNVcGRhdGUsIFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2RpcmVjdF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlXSwgWy8vIEVudGlyZUFycmF5XG5cdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2FycmF5LCBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9hcnJheV9zZXROZWVkc1VwZGF0ZSwgUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfYXJyYXlfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZV0sIFsvLyBBcnJheUVsZW1lbnRcblx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfYXJyYXlFbGVtZW50LCBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9hcnJheUVsZW1lbnRfc2V0TmVlZHNVcGRhdGUsIFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2FycmF5RWxlbWVudF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlXSwgWy8vIEhhc1RvRnJvbUFycmF5XG5cdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2Zyb21BcnJheSwgUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfZnJvbUFycmF5X3NldE5lZWRzVXBkYXRlLCBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9mcm9tQXJyYXlfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZV1dO1xuXG5cdC8qKlxuXHQgKlxuXHQgKiBBIGdyb3VwIG9mIG9iamVjdHMgdGhhdCByZWNlaXZlcyBhIHNoYXJlZCBhbmltYXRpb24gc3RhdGUuXG5cdCAqXG5cdCAqIFVzYWdlOlxuXHQgKlxuXHQgKlx0LSBBZGQgb2JqZWN0cyB5b3Ugd291bGQgb3RoZXJ3aXNlIHBhc3MgYXMgJ3Jvb3QnIHRvIHRoZVxuXHQgKlx0XHRjb25zdHJ1Y3RvciBvciB0aGUgLmNsaXBBY3Rpb24gbWV0aG9kIG9mIEFuaW1hdGlvbk1peGVyLlxuXHQgKlxuXHQgKlx0LSBJbnN0ZWFkIHBhc3MgdGhpcyBvYmplY3QgYXMgJ3Jvb3QnLlxuXHQgKlxuXHQgKlx0LSBZb3UgY2FuIGFsc28gYWRkIGFuZCByZW1vdmUgb2JqZWN0cyBsYXRlciB3aGVuIHRoZSBtaXhlclxuXHQgKlx0XHRpcyBydW5uaW5nLlxuXHQgKlxuXHQgKiBOb3RlOlxuXHQgKlxuXHQgKlx0XHRPYmplY3RzIG9mIHRoaXMgY2xhc3MgYXBwZWFyIGFzIG9uZSBvYmplY3QgdG8gdGhlIG1peGVyLFxuXHQgKlx0XHRzbyBjYWNoZSBjb250cm9sIG9mIHRoZSBpbmRpdmlkdWFsIG9iamVjdHMgbXVzdCBiZSBkb25lXG5cdCAqXHRcdG9uIHRoZSBncm91cC5cblx0ICpcblx0ICogTGltaXRhdGlvbjpcblx0ICpcblx0ICpcdC0gVGhlIGFuaW1hdGVkIHByb3BlcnRpZXMgbXVzdCBiZSBjb21wYXRpYmxlIGFtb25nIHRoZVxuXHQgKlx0XHRhbGwgb2JqZWN0cyBpbiB0aGUgZ3JvdXAuXG5cdCAqXG5cdCAqXHQtIEEgc2luZ2xlIHByb3BlcnR5IGNhbiBlaXRoZXIgYmUgY29udHJvbGxlZCB0aHJvdWdoIGFcblx0ICpcdFx0dGFyZ2V0IGdyb3VwIG9yIGRpcmVjdGx5LCBidXQgbm90IGJvdGguXG5cdCAqL1xuXG5cdGNsYXNzIEFuaW1hdGlvbk9iamVjdEdyb3VwIHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHRoaXMudXVpZCA9IGdlbmVyYXRlVVVJRCgpOyAvLyBjYWNoZWQgb2JqZWN0cyBmb2xsb3dlZCBieSB0aGUgYWN0aXZlIG9uZXNcblxuXHRcdFx0dGhpcy5fb2JqZWN0cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLm5DYWNoZWRPYmplY3RzXyA9IDA7IC8vIHRocmVzaG9sZFxuXHRcdFx0Ly8gbm90ZTogcmVhZCBieSBQcm9wZXJ0eUJpbmRpbmcuQ29tcG9zaXRlXG5cblx0XHRcdGNvbnN0IGluZGljZXMgPSB7fTtcblx0XHRcdHRoaXMuX2luZGljZXNCeVVVSUQgPSBpbmRpY2VzOyAvLyBmb3IgYm9va2tlZXBpbmdcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdFx0aW5kaWNlc1thcmd1bWVudHNbaV0udXVpZF0gPSBpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9wYXRocyA9IFtdOyAvLyBpbnNpZGU6IHN0cmluZ1xuXG5cdFx0XHR0aGlzLl9wYXJzZWRQYXRocyA9IFtdOyAvLyBpbnNpZGU6IHsgd2UgZG9uJ3QgY2FyZSwgaGVyZSB9XG5cblx0XHRcdHRoaXMuX2JpbmRpbmdzID0gW107IC8vIGluc2lkZTogQXJyYXk8IFByb3BlcnR5QmluZGluZyA+XG5cblx0XHRcdHRoaXMuX2JpbmRpbmdzSW5kaWNlc0J5UGF0aCA9IHt9OyAvLyBpbnNpZGU6IGluZGljZXMgaW4gdGhlc2UgYXJyYXlzXG5cblx0XHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblx0XHRcdHRoaXMuc3RhdHMgPSB7XG5cdFx0XHRcdG9iamVjdHM6IHtcblx0XHRcdFx0XHRnZXQgdG90YWwoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX29iamVjdHMubGVuZ3RoO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRnZXQgaW5Vc2UoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy50b3RhbCAtIHNjb3BlLm5DYWNoZWRPYmplY3RzXztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRnZXQgYmluZGluZ3NQZXJPYmplY3QoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNjb3BlLl9iaW5kaW5ncy5sZW5ndGg7XG5cdFx0XHRcdH1cblxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRhZGQoKSB7XG5cdFx0XHRjb25zdCBvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcblx0XHRcdFx0XHRcdGluZGljZXNCeVVVSUQgPSB0aGlzLl9pbmRpY2VzQnlVVUlELFxuXHRcdFx0XHRcdFx0cGF0aHMgPSB0aGlzLl9wYXRocyxcblx0XHRcdFx0XHRcdHBhcnNlZFBhdGhzID0gdGhpcy5fcGFyc2VkUGF0aHMsXG5cdFx0XHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0XHRcdFx0bkJpbmRpbmdzID0gYmluZGluZ3MubGVuZ3RoO1xuXHRcdFx0bGV0IGtub3duT2JqZWN0ID0gdW5kZWZpbmVkLFxuXHRcdFx0XHRcdG5PYmplY3RzID0gb2JqZWN0cy5sZW5ndGgsXG5cdFx0XHRcdFx0bkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXztcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdFx0Y29uc3Qgb2JqZWN0ID0gYXJndW1lbnRzW2ldLFxuXHRcdFx0XHRcdFx0XHR1dWlkID0gb2JqZWN0LnV1aWQ7XG5cdFx0XHRcdGxldCBpbmRleCA9IGluZGljZXNCeVVVSURbdXVpZF07XG5cblx0XHRcdFx0aWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHQvLyB1bmtub3duIG9iamVjdCAtPiBhZGQgaXQgdG8gdGhlIEFDVElWRSByZWdpb25cblx0XHRcdFx0XHRpbmRleCA9IG5PYmplY3RzKys7XG5cdFx0XHRcdFx0aW5kaWNlc0J5VVVJRFt1dWlkXSA9IGluZGV4O1xuXHRcdFx0XHRcdG9iamVjdHMucHVzaChvYmplY3QpOyAvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXG5cblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKytqKSB7XG5cdFx0XHRcdFx0XHRiaW5kaW5nc1tqXS5wdXNoKG5ldyBQcm9wZXJ0eUJpbmRpbmcob2JqZWN0LCBwYXRoc1tqXSwgcGFyc2VkUGF0aHNbal0pKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoaW5kZXggPCBuQ2FjaGVkT2JqZWN0cykge1xuXHRcdFx0XHRcdGtub3duT2JqZWN0ID0gb2JqZWN0c1tpbmRleF07IC8vIG1vdmUgZXhpc3Rpbmcgb2JqZWN0IHRvIHRoZSBBQ1RJVkUgcmVnaW9uXG5cblx0XHRcdFx0XHRjb25zdCBmaXJzdEFjdGl2ZUluZGV4ID0gLS1uQ2FjaGVkT2JqZWN0cyxcblx0XHRcdFx0XHRcdFx0XHRsYXN0Q2FjaGVkT2JqZWN0ID0gb2JqZWN0c1tmaXJzdEFjdGl2ZUluZGV4XTtcblx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEW2xhc3RDYWNoZWRPYmplY3QudXVpZF0gPSBpbmRleDtcblx0XHRcdFx0XHRvYmplY3RzW2luZGV4XSA9IGxhc3RDYWNoZWRPYmplY3Q7XG5cdFx0XHRcdFx0aW5kaWNlc0J5VVVJRFt1dWlkXSA9IGZpcnN0QWN0aXZlSW5kZXg7XG5cdFx0XHRcdFx0b2JqZWN0c1tmaXJzdEFjdGl2ZUluZGV4XSA9IG9iamVjdDsgLy8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsraikge1xuXHRcdFx0XHRcdFx0Y29uc3QgYmluZGluZ3NGb3JQYXRoID0gYmluZGluZ3Nbal0sXG5cdFx0XHRcdFx0XHRcdFx0XHRsYXN0Q2FjaGVkID0gYmluZGluZ3NGb3JQYXRoW2ZpcnN0QWN0aXZlSW5kZXhdO1xuXHRcdFx0XHRcdFx0bGV0IGJpbmRpbmcgPSBiaW5kaW5nc0ZvclBhdGhbaW5kZXhdO1xuXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoW2luZGV4XSA9IGxhc3RDYWNoZWQ7XG5cblx0XHRcdFx0XHRcdGlmIChiaW5kaW5nID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0Ly8gc2luY2Ugd2UgZG8gbm90IGJvdGhlciB0byBjcmVhdGUgbmV3IGJpbmRpbmdzXG5cdFx0XHRcdFx0XHRcdC8vIGZvciBvYmplY3RzIHRoYXQgYXJlIGNhY2hlZCwgdGhlIGJpbmRpbmcgbWF5XG5cdFx0XHRcdFx0XHRcdC8vIG9yIG1heSBub3QgZXhpc3Rcblx0XHRcdFx0XHRcdFx0YmluZGluZyA9IG5ldyBQcm9wZXJ0eUJpbmRpbmcob2JqZWN0LCBwYXRoc1tqXSwgcGFyc2VkUGF0aHNbal0pO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbZmlyc3RBY3RpdmVJbmRleF0gPSBiaW5kaW5nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChvYmplY3RzW2luZGV4XSAhPT0ga25vd25PYmplY3QpIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5BbmltYXRpb25PYmplY3RHcm91cDogRGlmZmVyZW50IG9iamVjdHMgd2l0aCB0aGUgc2FtZSBVVUlEICcgKyAnZGV0ZWN0ZWQuIENsZWFuIHRoZSBjYWNoZXMgb3IgcmVjcmVhdGUgeW91ciBpbmZyYXN0cnVjdHVyZSB3aGVuIHJlbG9hZGluZyBzY2VuZXMuJyk7XG5cdFx0XHRcdH0gLy8gZWxzZSB0aGUgb2JqZWN0IGlzIGFscmVhZHkgd2hlcmUgd2Ugd2FudCBpdCB0byBiZVxuXG5cdFx0XHR9IC8vIGZvciBhcmd1bWVudHNcblxuXG5cdFx0XHR0aGlzLm5DYWNoZWRPYmplY3RzXyA9IG5DYWNoZWRPYmplY3RzO1xuXHRcdH1cblxuXHRcdHJlbW92ZSgpIHtcblx0XHRcdGNvbnN0IG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxuXHRcdFx0XHRcdFx0aW5kaWNlc0J5VVVJRCA9IHRoaXMuX2luZGljZXNCeVVVSUQsXG5cdFx0XHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0XHRcdFx0bkJpbmRpbmdzID0gYmluZGluZ3MubGVuZ3RoO1xuXHRcdFx0bGV0IG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c187XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRcdGNvbnN0IG9iamVjdCA9IGFyZ3VtZW50c1tpXSxcblx0XHRcdFx0XHRcdFx0dXVpZCA9IG9iamVjdC51dWlkLFxuXHRcdFx0XHRcdFx0XHRpbmRleCA9IGluZGljZXNCeVVVSURbdXVpZF07XG5cblx0XHRcdFx0aWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaW5kZXggPj0gbkNhY2hlZE9iamVjdHMpIHtcblx0XHRcdFx0XHQvLyBtb3ZlIGV4aXN0aW5nIG9iamVjdCBpbnRvIHRoZSBDQUNIRUQgcmVnaW9uXG5cdFx0XHRcdFx0Y29uc3QgbGFzdENhY2hlZEluZGV4ID0gbkNhY2hlZE9iamVjdHMrKyxcblx0XHRcdFx0XHRcdFx0XHRmaXJzdEFjdGl2ZU9iamVjdCA9IG9iamVjdHNbbGFzdENhY2hlZEluZGV4XTtcblx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEW2ZpcnN0QWN0aXZlT2JqZWN0LnV1aWRdID0gaW5kZXg7XG5cdFx0XHRcdFx0b2JqZWN0c1tpbmRleF0gPSBmaXJzdEFjdGl2ZU9iamVjdDtcblx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEW3V1aWRdID0gbGFzdENhY2hlZEluZGV4O1xuXHRcdFx0XHRcdG9iamVjdHNbbGFzdENhY2hlZEluZGV4XSA9IG9iamVjdDsgLy8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsraikge1xuXHRcdFx0XHRcdFx0Y29uc3QgYmluZGluZ3NGb3JQYXRoID0gYmluZGluZ3Nbal0sXG5cdFx0XHRcdFx0XHRcdFx0XHRmaXJzdEFjdGl2ZSA9IGJpbmRpbmdzRm9yUGF0aFtsYXN0Q2FjaGVkSW5kZXhdLFxuXHRcdFx0XHRcdFx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzRm9yUGF0aFtpbmRleF07XG5cdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbaW5kZXhdID0gZmlyc3RBY3RpdmU7XG5cdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbbGFzdENhY2hlZEluZGV4XSA9IGJpbmRpbmc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IC8vIGZvciBhcmd1bWVudHNcblxuXG5cdFx0XHR0aGlzLm5DYWNoZWRPYmplY3RzXyA9IG5DYWNoZWRPYmplY3RzO1xuXHRcdH0gLy8gcmVtb3ZlICYgZm9yZ2V0XG5cblxuXHRcdHVuY2FjaGUoKSB7XG5cdFx0XHRjb25zdCBvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcblx0XHRcdFx0XHRcdGluZGljZXNCeVVVSUQgPSB0aGlzLl9pbmRpY2VzQnlVVUlELFxuXHRcdFx0XHRcdFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcblx0XHRcdFx0XHRcdG5CaW5kaW5ncyA9IGJpbmRpbmdzLmxlbmd0aDtcblx0XHRcdGxldCBuQ2FjaGVkT2JqZWN0cyA9IHRoaXMubkNhY2hlZE9iamVjdHNfLFxuXHRcdFx0XHRcdG5PYmplY3RzID0gb2JqZWN0cy5sZW5ndGg7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRcdGNvbnN0IG9iamVjdCA9IGFyZ3VtZW50c1tpXSxcblx0XHRcdFx0XHRcdFx0dXVpZCA9IG9iamVjdC51dWlkLFxuXHRcdFx0XHRcdFx0XHRpbmRleCA9IGluZGljZXNCeVVVSURbdXVpZF07XG5cblx0XHRcdFx0aWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRkZWxldGUgaW5kaWNlc0J5VVVJRFt1dWlkXTtcblxuXHRcdFx0XHRcdGlmIChpbmRleCA8IG5DYWNoZWRPYmplY3RzKSB7XG5cdFx0XHRcdFx0XHQvLyBvYmplY3QgaXMgY2FjaGVkLCBzaHJpbmsgdGhlIENBQ0hFRCByZWdpb25cblx0XHRcdFx0XHRcdGNvbnN0IGZpcnN0QWN0aXZlSW5kZXggPSAtLW5DYWNoZWRPYmplY3RzLFxuXHRcdFx0XHRcdFx0XHRcdFx0bGFzdENhY2hlZE9iamVjdCA9IG9iamVjdHNbZmlyc3RBY3RpdmVJbmRleF0sXG5cdFx0XHRcdFx0XHRcdFx0XHRsYXN0SW5kZXggPSAtLW5PYmplY3RzLFxuXHRcdFx0XHRcdFx0XHRcdFx0bGFzdE9iamVjdCA9IG9iamVjdHNbbGFzdEluZGV4XTsgLy8gbGFzdCBjYWNoZWQgb2JqZWN0IHRha2VzIHRoaXMgb2JqZWN0J3MgcGxhY2VcblxuXHRcdFx0XHRcdFx0aW5kaWNlc0J5VVVJRFtsYXN0Q2FjaGVkT2JqZWN0LnV1aWRdID0gaW5kZXg7XG5cdFx0XHRcdFx0XHRvYmplY3RzW2luZGV4XSA9IGxhc3RDYWNoZWRPYmplY3Q7IC8vIGxhc3Qgb2JqZWN0IGdvZXMgdG8gdGhlIGFjdGl2YXRlZCBzbG90IGFuZCBwb3BcblxuXHRcdFx0XHRcdFx0aW5kaWNlc0J5VVVJRFtsYXN0T2JqZWN0LnV1aWRdID0gZmlyc3RBY3RpdmVJbmRleDtcblx0XHRcdFx0XHRcdG9iamVjdHNbZmlyc3RBY3RpdmVJbmRleF0gPSBsYXN0T2JqZWN0O1xuXHRcdFx0XHRcdFx0b2JqZWN0cy5wb3AoKTsgLy8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKytqKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzW2pdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRsYXN0Q2FjaGVkID0gYmluZGluZ3NGb3JQYXRoW2ZpcnN0QWN0aXZlSW5kZXhdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRsYXN0ID0gYmluZGluZ3NGb3JQYXRoW2xhc3RJbmRleF07XG5cdFx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFtpbmRleF0gPSBsYXN0Q2FjaGVkO1xuXHRcdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbZmlyc3RBY3RpdmVJbmRleF0gPSBsYXN0O1xuXHRcdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGgucG9wKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIG9iamVjdCBpcyBhY3RpdmUsIGp1c3Qgc3dhcCB3aXRoIHRoZSBsYXN0IGFuZCBwb3Bcblx0XHRcdFx0XHRcdGNvbnN0IGxhc3RJbmRleCA9IC0tbk9iamVjdHMsXG5cdFx0XHRcdFx0XHRcdFx0XHRsYXN0T2JqZWN0ID0gb2JqZWN0c1tsYXN0SW5kZXhdO1xuXG5cdFx0XHRcdFx0XHRpZiAobGFzdEluZGV4ID4gMCkge1xuXHRcdFx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEW2xhc3RPYmplY3QudXVpZF0gPSBpbmRleDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0b2JqZWN0c1tpbmRleF0gPSBsYXN0T2JqZWN0O1xuXHRcdFx0XHRcdFx0b2JqZWN0cy5wb3AoKTsgLy8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKytqKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzW2pdO1xuXHRcdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbaW5kZXhdID0gYmluZGluZ3NGb3JQYXRoW2xhc3RJbmRleF07XG5cdFx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aC5wb3AoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IC8vIGNhY2hlZCBvciBhY3RpdmVcblxuXHRcdFx0XHR9IC8vIGlmIG9iamVjdCBpcyBrbm93blxuXG5cdFx0XHR9IC8vIGZvciBhcmd1bWVudHNcblxuXG5cdFx0XHR0aGlzLm5DYWNoZWRPYmplY3RzXyA9IG5DYWNoZWRPYmplY3RzO1xuXHRcdH0gLy8gSW50ZXJuYWwgaW50ZXJmYWNlIHVzZWQgYnkgYmVmcmllbmRlZCBQcm9wZXJ0eUJpbmRpbmcuQ29tcG9zaXRlOlxuXG5cblx0XHRzdWJzY3JpYmVfKHBhdGgsIHBhcnNlZFBhdGgpIHtcblx0XHRcdC8vIHJldHVybnMgYW4gYXJyYXkgb2YgYmluZGluZ3MgZm9yIHRoZSBnaXZlbiBwYXRoIHRoYXQgaXMgY2hhbmdlZFxuXHRcdFx0Ly8gYWNjb3JkaW5nIHRvIHRoZSBjb250YWluZWQgb2JqZWN0cyBpbiB0aGUgZ3JvdXBcblx0XHRcdGNvbnN0IGluZGljZXNCeVBhdGggPSB0aGlzLl9iaW5kaW5nc0luZGljZXNCeVBhdGg7XG5cdFx0XHRsZXQgaW5kZXggPSBpbmRpY2VzQnlQYXRoW3BhdGhdO1xuXHRcdFx0Y29uc3QgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcblx0XHRcdGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gYmluZGluZ3NbaW5kZXhdO1xuXHRcdFx0Y29uc3QgcGF0aHMgPSB0aGlzLl9wYXRocyxcblx0XHRcdFx0XHRcdHBhcnNlZFBhdGhzID0gdGhpcy5fcGFyc2VkUGF0aHMsXG5cdFx0XHRcdFx0XHRvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcblx0XHRcdFx0XHRcdG5PYmplY3RzID0gb2JqZWN0cy5sZW5ndGgsXG5cdFx0XHRcdFx0XHRuQ2FjaGVkT2JqZWN0cyA9IHRoaXMubkNhY2hlZE9iamVjdHNfLFxuXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoID0gbmV3IEFycmF5KG5PYmplY3RzKTtcblx0XHRcdGluZGV4ID0gYmluZGluZ3MubGVuZ3RoO1xuXHRcdFx0aW5kaWNlc0J5UGF0aFtwYXRoXSA9IGluZGV4O1xuXHRcdFx0cGF0aHMucHVzaChwYXRoKTtcblx0XHRcdHBhcnNlZFBhdGhzLnB1c2gocGFyc2VkUGF0aCk7XG5cdFx0XHRiaW5kaW5ncy5wdXNoKGJpbmRpbmdzRm9yUGF0aCk7XG5cblx0XHRcdGZvciAobGV0IGkgPSBuQ2FjaGVkT2JqZWN0cywgbiA9IG9iamVjdHMubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdFx0Y29uc3Qgb2JqZWN0ID0gb2JqZWN0c1tpXTtcblx0XHRcdFx0YmluZGluZ3NGb3JQYXRoW2ldID0gbmV3IFByb3BlcnR5QmluZGluZyhvYmplY3QsIHBhdGgsIHBhcnNlZFBhdGgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYmluZGluZ3NGb3JQYXRoO1xuXHRcdH1cblxuXHRcdHVuc3Vic2NyaWJlXyhwYXRoKSB7XG5cdFx0XHQvLyB0ZWxscyB0aGUgZ3JvdXAgdG8gZm9yZ2V0IGFib3V0IGEgcHJvcGVydHkgcGF0aCBhbmQgbm8gbG9uZ2VyXG5cdFx0XHQvLyB1cGRhdGUgdGhlIGFycmF5IHByZXZpb3VzbHkgb2J0YWluZWQgd2l0aCAnc3Vic2NyaWJlXydcblx0XHRcdGNvbnN0IGluZGljZXNCeVBhdGggPSB0aGlzLl9iaW5kaW5nc0luZGljZXNCeVBhdGgsXG5cdFx0XHRcdFx0XHRpbmRleCA9IGluZGljZXNCeVBhdGhbcGF0aF07XG5cblx0XHRcdGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnN0IHBhdGhzID0gdGhpcy5fcGF0aHMsXG5cdFx0XHRcdFx0XHRcdHBhcnNlZFBhdGhzID0gdGhpcy5fcGFyc2VkUGF0aHMsXG5cdFx0XHRcdFx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRcdFx0XHRcdGxhc3RCaW5kaW5nc0luZGV4ID0gYmluZGluZ3MubGVuZ3RoIC0gMSxcblx0XHRcdFx0XHRcdFx0bGFzdEJpbmRpbmdzID0gYmluZGluZ3NbbGFzdEJpbmRpbmdzSW5kZXhdLFxuXHRcdFx0XHRcdFx0XHRsYXN0QmluZGluZ3NQYXRoID0gcGF0aFtsYXN0QmluZGluZ3NJbmRleF07XG5cdFx0XHRcdGluZGljZXNCeVBhdGhbbGFzdEJpbmRpbmdzUGF0aF0gPSBpbmRleDtcblx0XHRcdFx0YmluZGluZ3NbaW5kZXhdID0gbGFzdEJpbmRpbmdzO1xuXHRcdFx0XHRiaW5kaW5ncy5wb3AoKTtcblx0XHRcdFx0cGFyc2VkUGF0aHNbaW5kZXhdID0gcGFyc2VkUGF0aHNbbGFzdEJpbmRpbmdzSW5kZXhdO1xuXHRcdFx0XHRwYXJzZWRQYXRocy5wb3AoKTtcblx0XHRcdFx0cGF0aHNbaW5kZXhdID0gcGF0aHNbbGFzdEJpbmRpbmdzSW5kZXhdO1xuXHRcdFx0XHRwYXRocy5wb3AoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0fVxuXG5cdEFuaW1hdGlvbk9iamVjdEdyb3VwLnByb3RvdHlwZS5pc0FuaW1hdGlvbk9iamVjdEdyb3VwID0gdHJ1ZTtcblxuXHRjbGFzcyBBbmltYXRpb25BY3Rpb24ge1xuXHRcdGNvbnN0cnVjdG9yKG1peGVyLCBjbGlwLCBsb2NhbFJvb3QgPSBudWxsLCBibGVuZE1vZGUgPSBjbGlwLmJsZW5kTW9kZSkge1xuXHRcdFx0dGhpcy5fbWl4ZXIgPSBtaXhlcjtcblx0XHRcdHRoaXMuX2NsaXAgPSBjbGlwO1xuXHRcdFx0dGhpcy5fbG9jYWxSb290ID0gbG9jYWxSb290O1xuXHRcdFx0dGhpcy5ibGVuZE1vZGUgPSBibGVuZE1vZGU7XG5cdFx0XHRjb25zdCB0cmFja3MgPSBjbGlwLnRyYWNrcyxcblx0XHRcdFx0XHRcdG5UcmFja3MgPSB0cmFja3MubGVuZ3RoLFxuXHRcdFx0XHRcdFx0aW50ZXJwb2xhbnRzID0gbmV3IEFycmF5KG5UcmFja3MpO1xuXHRcdFx0Y29uc3QgaW50ZXJwb2xhbnRTZXR0aW5ncyA9IHtcblx0XHRcdFx0ZW5kaW5nU3RhcnQ6IFplcm9DdXJ2YXR1cmVFbmRpbmcsXG5cdFx0XHRcdGVuZGluZ0VuZDogWmVyb0N1cnZhdHVyZUVuZGluZ1xuXHRcdFx0fTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgIT09IG5UcmFja3M7ICsraSkge1xuXHRcdFx0XHRjb25zdCBpbnRlcnBvbGFudCA9IHRyYWNrc1tpXS5jcmVhdGVJbnRlcnBvbGFudChudWxsKTtcblx0XHRcdFx0aW50ZXJwb2xhbnRzW2ldID0gaW50ZXJwb2xhbnQ7XG5cdFx0XHRcdGludGVycG9sYW50LnNldHRpbmdzID0gaW50ZXJwb2xhbnRTZXR0aW5ncztcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5faW50ZXJwb2xhbnRTZXR0aW5ncyA9IGludGVycG9sYW50U2V0dGluZ3M7XG5cdFx0XHR0aGlzLl9pbnRlcnBvbGFudHMgPSBpbnRlcnBvbGFudHM7IC8vIGJvdW5kIGJ5IHRoZSBtaXhlclxuXHRcdFx0Ly8gaW5zaWRlOiBQcm9wZXJ0eU1peGVyIChtYW5hZ2VkIGJ5IHRoZSBtaXhlcilcblxuXHRcdFx0dGhpcy5fcHJvcGVydHlCaW5kaW5ncyA9IG5ldyBBcnJheShuVHJhY2tzKTtcblx0XHRcdHRoaXMuX2NhY2hlSW5kZXggPSBudWxsOyAvLyBmb3IgdGhlIG1lbW9yeSBtYW5hZ2VyXG5cblx0XHRcdHRoaXMuX2J5Q2xpcENhY2hlSW5kZXggPSBudWxsOyAvLyBmb3IgdGhlIG1lbW9yeSBtYW5hZ2VyXG5cblx0XHRcdHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50ID0gbnVsbDtcblx0XHRcdHRoaXMuX3dlaWdodEludGVycG9sYW50ID0gbnVsbDtcblx0XHRcdHRoaXMubG9vcCA9IExvb3BSZXBlYXQ7XG5cdFx0XHR0aGlzLl9sb29wQ291bnQgPSAtMTsgLy8gZ2xvYmFsIG1peGVyIHRpbWUgd2hlbiB0aGUgYWN0aW9uIGlzIHRvIGJlIHN0YXJ0ZWRcblx0XHRcdC8vIGl0J3Mgc2V0IGJhY2sgdG8gJ251bGwnIHVwb24gc3RhcnQgb2YgdGhlIGFjdGlvblxuXG5cdFx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsOyAvLyBzY2FsZWQgbG9jYWwgdGltZSBvZiB0aGUgYWN0aW9uXG5cdFx0XHQvLyBnZXRzIGNsYW1wZWQgb3Igd3JhcHBlZCB0byAwLi5jbGlwLmR1cmF0aW9uIGFjY29yZGluZyB0byBsb29wXG5cblx0XHRcdHRoaXMudGltZSA9IDA7XG5cdFx0XHR0aGlzLnRpbWVTY2FsZSA9IDE7XG5cdFx0XHR0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUgPSAxO1xuXHRcdFx0dGhpcy53ZWlnaHQgPSAxO1xuXHRcdFx0dGhpcy5fZWZmZWN0aXZlV2VpZ2h0ID0gMTtcblx0XHRcdHRoaXMucmVwZXRpdGlvbnMgPSBJbmZpbml0eTsgLy8gbm8uIG9mIHJlcGV0aXRpb25zIHdoZW4gbG9vcGluZ1xuXG5cdFx0XHR0aGlzLnBhdXNlZCA9IGZhbHNlOyAvLyB0cnVlIC0+IHplcm8gZWZmZWN0aXZlIHRpbWUgc2NhbGVcblxuXHRcdFx0dGhpcy5lbmFibGVkID0gdHJ1ZTsgLy8gZmFsc2UgLT4gemVybyBlZmZlY3RpdmUgd2VpZ2h0XG5cblx0XHRcdHRoaXMuY2xhbXBXaGVuRmluaXNoZWQgPSBmYWxzZTsgLy8ga2VlcCBmZWVkaW5nIHRoZSBsYXN0IGZyYW1lP1xuXG5cdFx0XHR0aGlzLnplcm9TbG9wZUF0U3RhcnQgPSB0cnVlOyAvLyBmb3Igc21vb3RoIGludGVycG9sYXRpb24gdy9vIHNlcGFyYXRlXG5cblx0XHRcdHRoaXMuemVyb1Nsb3BlQXRFbmQgPSB0cnVlOyAvLyBjbGlwcyBmb3Igc3RhcnQsIGxvb3AgYW5kIGVuZFxuXHRcdH0gLy8gU3RhdGUgJiBTY2hlZHVsaW5nXG5cblxuXHRcdHBsYXkoKSB7XG5cdFx0XHR0aGlzLl9taXhlci5fYWN0aXZhdGVBY3Rpb24odGhpcyk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHN0b3AoKSB7XG5cdFx0XHR0aGlzLl9taXhlci5fZGVhY3RpdmF0ZUFjdGlvbih0aGlzKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMucmVzZXQoKTtcblx0XHR9XG5cblx0XHRyZXNldCgpIHtcblx0XHRcdHRoaXMucGF1c2VkID0gZmFsc2U7XG5cdFx0XHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy50aW1lID0gMDsgLy8gcmVzdGFydCBjbGlwXG5cblx0XHRcdHRoaXMuX2xvb3BDb3VudCA9IC0xOyAvLyBmb3JnZXQgcHJldmlvdXMgbG9vcHNcblxuXHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDsgLy8gZm9yZ2V0IHNjaGVkdWxpbmdcblxuXHRcdFx0cmV0dXJuIHRoaXMuc3RvcEZhZGluZygpLnN0b3BXYXJwaW5nKCk7XG5cdFx0fVxuXG5cdFx0aXNSdW5uaW5nKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZW5hYmxlZCAmJiAhdGhpcy5wYXVzZWQgJiYgdGhpcy50aW1lU2NhbGUgIT09IDAgJiYgdGhpcy5fc3RhcnRUaW1lID09PSBudWxsICYmIHRoaXMuX21peGVyLl9pc0FjdGl2ZUFjdGlvbih0aGlzKTtcblx0XHR9IC8vIHJldHVybiB0cnVlIHdoZW4gcGxheSBoYXMgYmVlbiBjYWxsZWRcblxuXG5cdFx0aXNTY2hlZHVsZWQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbWl4ZXIuX2lzQWN0aXZlQWN0aW9uKHRoaXMpO1xuXHRcdH1cblxuXHRcdHN0YXJ0QXQodGltZSkge1xuXHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gdGltZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldExvb3AobW9kZSwgcmVwZXRpdGlvbnMpIHtcblx0XHRcdHRoaXMubG9vcCA9IG1vZGU7XG5cdFx0XHR0aGlzLnJlcGV0aXRpb25zID0gcmVwZXRpdGlvbnM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9IC8vIFdlaWdodFxuXHRcdC8vIHNldCB0aGUgd2VpZ2h0IHN0b3BwaW5nIGFueSBzY2hlZHVsZWQgZmFkaW5nXG5cdFx0Ly8gYWx0aG91Z2ggLmVuYWJsZWQgPSBmYWxzZSB5aWVsZHMgYW4gZWZmZWN0aXZlIHdlaWdodCBvZiB6ZXJvLCB0aGlzXG5cdFx0Ly8gbWV0aG9kIGRvZXMgKm5vdCogY2hhbmdlIC5lbmFibGVkLCBiZWNhdXNlIGl0IHdvdWxkIGJlIGNvbmZ1c2luZ1xuXG5cblx0XHRzZXRFZmZlY3RpdmVXZWlnaHQod2VpZ2h0KSB7XG5cdFx0XHR0aGlzLndlaWdodCA9IHdlaWdodDsgLy8gbm90ZTogc2FtZSBsb2dpYyBhcyB3aGVuIHVwZGF0ZWQgYXQgcnVudGltZVxuXG5cdFx0XHR0aGlzLl9lZmZlY3RpdmVXZWlnaHQgPSB0aGlzLmVuYWJsZWQgPyB3ZWlnaHQgOiAwO1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RvcEZhZGluZygpO1xuXHRcdH0gLy8gcmV0dXJuIHRoZSB3ZWlnaHQgY29uc2lkZXJpbmcgZmFkaW5nIGFuZCAuZW5hYmxlZFxuXG5cblx0XHRnZXRFZmZlY3RpdmVXZWlnaHQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZWZmZWN0aXZlV2VpZ2h0O1xuXHRcdH1cblxuXHRcdGZhZGVJbihkdXJhdGlvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3NjaGVkdWxlRmFkaW5nKGR1cmF0aW9uLCAwLCAxKTtcblx0XHR9XG5cblx0XHRmYWRlT3V0KGR1cmF0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc2NoZWR1bGVGYWRpbmcoZHVyYXRpb24sIDEsIDApO1xuXHRcdH1cblxuXHRcdGNyb3NzRmFkZUZyb20oZmFkZU91dEFjdGlvbiwgZHVyYXRpb24sIHdhcnApIHtcblx0XHRcdGZhZGVPdXRBY3Rpb24uZmFkZU91dChkdXJhdGlvbik7XG5cdFx0XHR0aGlzLmZhZGVJbihkdXJhdGlvbik7XG5cblx0XHRcdGlmICh3YXJwKSB7XG5cdFx0XHRcdGNvbnN0IGZhZGVJbkR1cmF0aW9uID0gdGhpcy5fY2xpcC5kdXJhdGlvbixcblx0XHRcdFx0XHRcdFx0ZmFkZU91dER1cmF0aW9uID0gZmFkZU91dEFjdGlvbi5fY2xpcC5kdXJhdGlvbixcblx0XHRcdFx0XHRcdFx0c3RhcnRFbmRSYXRpbyA9IGZhZGVPdXREdXJhdGlvbiAvIGZhZGVJbkR1cmF0aW9uLFxuXHRcdFx0XHRcdFx0XHRlbmRTdGFydFJhdGlvID0gZmFkZUluRHVyYXRpb24gLyBmYWRlT3V0RHVyYXRpb247XG5cdFx0XHRcdGZhZGVPdXRBY3Rpb24ud2FycCgxLjAsIHN0YXJ0RW5kUmF0aW8sIGR1cmF0aW9uKTtcblx0XHRcdFx0dGhpcy53YXJwKGVuZFN0YXJ0UmF0aW8sIDEuMCwgZHVyYXRpb24pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjcm9zc0ZhZGVUbyhmYWRlSW5BY3Rpb24sIGR1cmF0aW9uLCB3YXJwKSB7XG5cdFx0XHRyZXR1cm4gZmFkZUluQWN0aW9uLmNyb3NzRmFkZUZyb20odGhpcywgZHVyYXRpb24sIHdhcnApO1xuXHRcdH1cblxuXHRcdHN0b3BGYWRpbmcoKSB7XG5cdFx0XHRjb25zdCB3ZWlnaHRJbnRlcnBvbGFudCA9IHRoaXMuX3dlaWdodEludGVycG9sYW50O1xuXG5cdFx0XHRpZiAod2VpZ2h0SW50ZXJwb2xhbnQgIT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQgPSBudWxsO1xuXG5cdFx0XHRcdHRoaXMuX21peGVyLl90YWtlQmFja0NvbnRyb2xJbnRlcnBvbGFudCh3ZWlnaHRJbnRlcnBvbGFudCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0gLy8gVGltZSBTY2FsZSBDb250cm9sXG5cdFx0Ly8gc2V0IHRoZSB0aW1lIHNjYWxlIHN0b3BwaW5nIGFueSBzY2hlZHVsZWQgd2FycGluZ1xuXHRcdC8vIGFsdGhvdWdoIC5wYXVzZWQgPSB0cnVlIHlpZWxkcyBhbiBlZmZlY3RpdmUgdGltZSBzY2FsZSBvZiB6ZXJvLCB0aGlzXG5cdFx0Ly8gbWV0aG9kIGRvZXMgKm5vdCogY2hhbmdlIC5wYXVzZWQsIGJlY2F1c2UgaXQgd291bGQgYmUgY29uZnVzaW5nXG5cblxuXHRcdHNldEVmZmVjdGl2ZVRpbWVTY2FsZSh0aW1lU2NhbGUpIHtcblx0XHRcdHRoaXMudGltZVNjYWxlID0gdGltZVNjYWxlO1xuXHRcdFx0dGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlID0gdGhpcy5wYXVzZWQgPyAwIDogdGltZVNjYWxlO1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RvcFdhcnBpbmcoKTtcblx0XHR9IC8vIHJldHVybiB0aGUgdGltZSBzY2FsZSBjb25zaWRlcmluZyB3YXJwaW5nIGFuZCAucGF1c2VkXG5cblxuXHRcdGdldEVmZmVjdGl2ZVRpbWVTY2FsZSgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGU7XG5cdFx0fVxuXG5cdFx0c2V0RHVyYXRpb24oZHVyYXRpb24pIHtcblx0XHRcdHRoaXMudGltZVNjYWxlID0gdGhpcy5fY2xpcC5kdXJhdGlvbiAvIGR1cmF0aW9uO1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RvcFdhcnBpbmcoKTtcblx0XHR9XG5cblx0XHRzeW5jV2l0aChhY3Rpb24pIHtcblx0XHRcdHRoaXMudGltZSA9IGFjdGlvbi50aW1lO1xuXHRcdFx0dGhpcy50aW1lU2NhbGUgPSBhY3Rpb24udGltZVNjYWxlO1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RvcFdhcnBpbmcoKTtcblx0XHR9XG5cblx0XHRoYWx0KGR1cmF0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy53YXJwKHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZSwgMCwgZHVyYXRpb24pO1xuXHRcdH1cblxuXHRcdHdhcnAoc3RhcnRUaW1lU2NhbGUsIGVuZFRpbWVTY2FsZSwgZHVyYXRpb24pIHtcblx0XHRcdGNvbnN0IG1peGVyID0gdGhpcy5fbWl4ZXIsXG5cdFx0XHRcdFx0XHRub3cgPSBtaXhlci50aW1lLFxuXHRcdFx0XHRcdFx0dGltZVNjYWxlID0gdGhpcy50aW1lU2NhbGU7XG5cdFx0XHRsZXQgaW50ZXJwb2xhbnQgPSB0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudDtcblxuXHRcdFx0aWYgKGludGVycG9sYW50ID09PSBudWxsKSB7XG5cdFx0XHRcdGludGVycG9sYW50ID0gbWl4ZXIuX2xlbmRDb250cm9sSW50ZXJwb2xhbnQoKTtcblx0XHRcdFx0dGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQgPSBpbnRlcnBvbGFudDtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdGltZXMgPSBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnMsXG5cdFx0XHRcdFx0XHR2YWx1ZXMgPSBpbnRlcnBvbGFudC5zYW1wbGVWYWx1ZXM7XG5cdFx0XHR0aW1lc1swXSA9IG5vdztcblx0XHRcdHRpbWVzWzFdID0gbm93ICsgZHVyYXRpb247XG5cdFx0XHR2YWx1ZXNbMF0gPSBzdGFydFRpbWVTY2FsZSAvIHRpbWVTY2FsZTtcblx0XHRcdHZhbHVlc1sxXSA9IGVuZFRpbWVTY2FsZSAvIHRpbWVTY2FsZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHN0b3BXYXJwaW5nKCkge1xuXHRcdFx0Y29uc3QgdGltZVNjYWxlSW50ZXJwb2xhbnQgPSB0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudDtcblxuXHRcdFx0aWYgKHRpbWVTY2FsZUludGVycG9sYW50ICE9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50ID0gbnVsbDtcblxuXHRcdFx0XHR0aGlzLl9taXhlci5fdGFrZUJhY2tDb250cm9sSW50ZXJwb2xhbnQodGltZVNjYWxlSW50ZXJwb2xhbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9IC8vIE9iamVjdCBBY2Nlc3NvcnNcblxuXG5cdFx0Z2V0TWl4ZXIoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbWl4ZXI7XG5cdFx0fVxuXG5cdFx0Z2V0Q2xpcCgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jbGlwO1xuXHRcdH1cblxuXHRcdGdldFJvb3QoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbG9jYWxSb290IHx8IHRoaXMuX21peGVyLl9yb290O1xuXHRcdH0gLy8gSW50ZXJuYVxuXG5cblx0XHRfdXBkYXRlKHRpbWUsIGRlbHRhVGltZSwgdGltZURpcmVjdGlvbiwgYWNjdUluZGV4KSB7XG5cdFx0XHQvLyBjYWxsZWQgYnkgdGhlIG1peGVyXG5cdFx0XHRpZiAoIXRoaXMuZW5hYmxlZCkge1xuXHRcdFx0XHQvLyBjYWxsIC5fdXBkYXRlV2VpZ2h0KCkgdG8gdXBkYXRlIC5fZWZmZWN0aXZlV2VpZ2h0XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZVdlaWdodCh0aW1lKTtcblxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHN0YXJ0VGltZSA9IHRoaXMuX3N0YXJ0VGltZTtcblxuXHRcdFx0aWYgKHN0YXJ0VGltZSAhPT0gbnVsbCkge1xuXHRcdFx0XHQvLyBjaGVjayBmb3Igc2NoZWR1bGVkIHN0YXJ0IG9mIGFjdGlvblxuXHRcdFx0XHRjb25zdCB0aW1lUnVubmluZyA9ICh0aW1lIC0gc3RhcnRUaW1lKSAqIHRpbWVEaXJlY3Rpb247XG5cblx0XHRcdFx0aWYgKHRpbWVSdW5uaW5nIDwgMCB8fCB0aW1lRGlyZWN0aW9uID09PSAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuOyAvLyB5ZXQgdG8gY29tZSAvIGRvbid0IGRlY2lkZSB3aGVuIGRlbHRhID0gMFxuXHRcdFx0XHR9IC8vIHN0YXJ0XG5cblxuXHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsOyAvLyB1bnNjaGVkdWxlXG5cblx0XHRcdFx0ZGVsdGFUaW1lID0gdGltZURpcmVjdGlvbiAqIHRpbWVSdW5uaW5nO1xuXHRcdFx0fSAvLyBhcHBseSB0aW1lIHNjYWxlIGFuZCBhZHZhbmNlIHRpbWVcblxuXG5cdFx0XHRkZWx0YVRpbWUgKj0gdGhpcy5fdXBkYXRlVGltZVNjYWxlKHRpbWUpO1xuXG5cdFx0XHRjb25zdCBjbGlwVGltZSA9IHRoaXMuX3VwZGF0ZVRpbWUoZGVsdGFUaW1lKTsgLy8gbm90ZTogX3VwZGF0ZVRpbWUgbWF5IGRpc2FibGUgdGhlIGFjdGlvbiByZXN1bHRpbmcgaW5cblx0XHRcdC8vIGFuIGVmZmVjdGl2ZSB3ZWlnaHQgb2YgMFxuXG5cblx0XHRcdGNvbnN0IHdlaWdodCA9IHRoaXMuX3VwZGF0ZVdlaWdodCh0aW1lKTtcblxuXHRcdFx0aWYgKHdlaWdodCA+IDApIHtcblx0XHRcdFx0Y29uc3QgaW50ZXJwb2xhbnRzID0gdGhpcy5faW50ZXJwb2xhbnRzO1xuXHRcdFx0XHRjb25zdCBwcm9wZXJ0eU1peGVycyA9IHRoaXMuX3Byb3BlcnR5QmluZGluZ3M7XG5cblx0XHRcdFx0c3dpdGNoICh0aGlzLmJsZW5kTW9kZSkge1xuXHRcdFx0XHRcdGNhc2UgQWRkaXRpdmVBbmltYXRpb25CbGVuZE1vZGU6XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBqID0gMCwgbSA9IGludGVycG9sYW50cy5sZW5ndGg7IGogIT09IG07ICsraikge1xuXHRcdFx0XHRcdFx0XHRpbnRlcnBvbGFudHNbal0uZXZhbHVhdGUoY2xpcFRpbWUpO1xuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eU1peGVyc1tqXS5hY2N1bXVsYXRlQWRkaXRpdmUod2VpZ2h0KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIE5vcm1hbEFuaW1hdGlvbkJsZW5kTW9kZTpcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDAsIG0gPSBpbnRlcnBvbGFudHMubGVuZ3RoOyBqICE9PSBtOyArK2opIHtcblx0XHRcdFx0XHRcdFx0aW50ZXJwb2xhbnRzW2pdLmV2YWx1YXRlKGNsaXBUaW1lKTtcblx0XHRcdFx0XHRcdFx0cHJvcGVydHlNaXhlcnNbal0uYWNjdW11bGF0ZShhY2N1SW5kZXgsIHdlaWdodCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdF91cGRhdGVXZWlnaHQodGltZSkge1xuXHRcdFx0bGV0IHdlaWdodCA9IDA7XG5cblx0XHRcdGlmICh0aGlzLmVuYWJsZWQpIHtcblx0XHRcdFx0d2VpZ2h0ID0gdGhpcy53ZWlnaHQ7XG5cdFx0XHRcdGNvbnN0IGludGVycG9sYW50ID0gdGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQ7XG5cblx0XHRcdFx0aWYgKGludGVycG9sYW50ICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0Y29uc3QgaW50ZXJwb2xhbnRWYWx1ZSA9IGludGVycG9sYW50LmV2YWx1YXRlKHRpbWUpWzBdO1xuXHRcdFx0XHRcdHdlaWdodCAqPSBpbnRlcnBvbGFudFZhbHVlO1xuXG5cdFx0XHRcdFx0aWYgKHRpbWUgPiBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnNbMV0pIHtcblx0XHRcdFx0XHRcdHRoaXMuc3RvcEZhZGluZygpO1xuXG5cdFx0XHRcdFx0XHRpZiAoaW50ZXJwb2xhbnRWYWx1ZSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHQvLyBmYWRlZCBvdXQsIGRpc2FibGVcblx0XHRcdFx0XHRcdFx0dGhpcy5lbmFibGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IHdlaWdodDtcblx0XHRcdHJldHVybiB3ZWlnaHQ7XG5cdFx0fVxuXG5cdFx0X3VwZGF0ZVRpbWVTY2FsZSh0aW1lKSB7XG5cdFx0XHRsZXQgdGltZVNjYWxlID0gMDtcblxuXHRcdFx0aWYgKCF0aGlzLnBhdXNlZCkge1xuXHRcdFx0XHR0aW1lU2NhbGUgPSB0aGlzLnRpbWVTY2FsZTtcblx0XHRcdFx0Y29uc3QgaW50ZXJwb2xhbnQgPSB0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudDtcblxuXHRcdFx0XHRpZiAoaW50ZXJwb2xhbnQgIT09IG51bGwpIHtcblx0XHRcdFx0XHRjb25zdCBpbnRlcnBvbGFudFZhbHVlID0gaW50ZXJwb2xhbnQuZXZhbHVhdGUodGltZSlbMF07XG5cdFx0XHRcdFx0dGltZVNjYWxlICo9IGludGVycG9sYW50VmFsdWU7XG5cblx0XHRcdFx0XHRpZiAodGltZSA+IGludGVycG9sYW50LnBhcmFtZXRlclBvc2l0aW9uc1sxXSkge1xuXHRcdFx0XHRcdFx0dGhpcy5zdG9wV2FycGluZygpO1xuXG5cdFx0XHRcdFx0XHRpZiAodGltZVNjYWxlID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdC8vIG1vdGlvbiBoYXMgaGFsdGVkLCBwYXVzZVxuXHRcdFx0XHRcdFx0XHR0aGlzLnBhdXNlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyB3YXJwIGRvbmUgLSBhcHBseSBmaW5hbCB0aW1lIHNjYWxlXG5cdFx0XHRcdFx0XHRcdHRoaXMudGltZVNjYWxlID0gdGltZVNjYWxlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUgPSB0aW1lU2NhbGU7XG5cdFx0XHRyZXR1cm4gdGltZVNjYWxlO1xuXHRcdH1cblxuXHRcdF91cGRhdGVUaW1lKGRlbHRhVGltZSkge1xuXHRcdFx0Y29uc3QgZHVyYXRpb24gPSB0aGlzLl9jbGlwLmR1cmF0aW9uO1xuXHRcdFx0Y29uc3QgbG9vcCA9IHRoaXMubG9vcDtcblx0XHRcdGxldCB0aW1lID0gdGhpcy50aW1lICsgZGVsdGFUaW1lO1xuXHRcdFx0bGV0IGxvb3BDb3VudCA9IHRoaXMuX2xvb3BDb3VudDtcblx0XHRcdGNvbnN0IHBpbmdQb25nID0gbG9vcCA9PT0gTG9vcFBpbmdQb25nO1xuXG5cdFx0XHRpZiAoZGVsdGFUaW1lID09PSAwKSB7XG5cdFx0XHRcdGlmIChsb29wQ291bnQgPT09IC0xKSByZXR1cm4gdGltZTtcblx0XHRcdFx0cmV0dXJuIHBpbmdQb25nICYmIChsb29wQ291bnQgJiAxKSA9PT0gMSA/IGR1cmF0aW9uIC0gdGltZSA6IHRpbWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChsb29wID09PSBMb29wT25jZSkge1xuXHRcdFx0XHRpZiAobG9vcENvdW50ID09PSAtMSkge1xuXHRcdFx0XHRcdC8vIGp1c3Qgc3RhcnRlZFxuXHRcdFx0XHRcdHRoaXMuX2xvb3BDb3VudCA9IDA7XG5cblx0XHRcdFx0XHR0aGlzLl9zZXRFbmRpbmdzKHRydWUsIHRydWUsIGZhbHNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGhhbmRsZV9zdG9wOiB7XG5cdFx0XHRcdFx0aWYgKHRpbWUgPj0gZHVyYXRpb24pIHtcblx0XHRcdFx0XHRcdHRpbWUgPSBkdXJhdGlvbjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRpbWUgPCAwKSB7XG5cdFx0XHRcdFx0XHR0aW1lID0gMDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy50aW1lID0gdGltZTtcblx0XHRcdFx0XHRcdGJyZWFrIGhhbmRsZV9zdG9wO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0aGlzLmNsYW1wV2hlbkZpbmlzaGVkKSB0aGlzLnBhdXNlZCA9IHRydWU7ZWxzZSB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblx0XHRcdFx0XHR0aGlzLnRpbWUgPSB0aW1lO1xuXG5cdFx0XHRcdFx0dGhpcy5fbWl4ZXIuZGlzcGF0Y2hFdmVudCh7XG5cdFx0XHRcdFx0XHR0eXBlOiAnZmluaXNoZWQnLFxuXHRcdFx0XHRcdFx0YWN0aW9uOiB0aGlzLFxuXHRcdFx0XHRcdFx0ZGlyZWN0aW9uOiBkZWx0YVRpbWUgPCAwID8gLTEgOiAxXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHJlcGV0aXRpdmUgUmVwZWF0IG9yIFBpbmdQb25nXG5cdFx0XHRcdGlmIChsb29wQ291bnQgPT09IC0xKSB7XG5cdFx0XHRcdFx0Ly8ganVzdCBzdGFydGVkXG5cdFx0XHRcdFx0aWYgKGRlbHRhVGltZSA+PSAwKSB7XG5cdFx0XHRcdFx0XHRsb29wQ291bnQgPSAwO1xuXG5cdFx0XHRcdFx0XHR0aGlzLl9zZXRFbmRpbmdzKHRydWUsIHRoaXMucmVwZXRpdGlvbnMgPT09IDAsIHBpbmdQb25nKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gd2hlbiBsb29waW5nIGluIHJldmVyc2UgZGlyZWN0aW9uLCB0aGUgaW5pdGlhbFxuXHRcdFx0XHRcdFx0Ly8gdHJhbnNpdGlvbiB0aHJvdWdoIHplcm8gY291bnRzIGFzIGEgcmVwZXRpdGlvbixcblx0XHRcdFx0XHRcdC8vIHNvIGxlYXZlIGxvb3BDb3VudCBhdCAtMVxuXHRcdFx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyh0aGlzLnJlcGV0aXRpb25zID09PSAwLCB0cnVlLCBwaW5nUG9uZyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRpbWUgPj0gZHVyYXRpb24gfHwgdGltZSA8IDApIHtcblx0XHRcdFx0XHQvLyB3cmFwIGFyb3VuZFxuXHRcdFx0XHRcdGNvbnN0IGxvb3BEZWx0YSA9IE1hdGguZmxvb3IodGltZSAvIGR1cmF0aW9uKTsgLy8gc2lnbmVkXG5cblx0XHRcdFx0XHR0aW1lIC09IGR1cmF0aW9uICogbG9vcERlbHRhO1xuXHRcdFx0XHRcdGxvb3BDb3VudCArPSBNYXRoLmFicyhsb29wRGVsdGEpO1xuXHRcdFx0XHRcdGNvbnN0IHBlbmRpbmcgPSB0aGlzLnJlcGV0aXRpb25zIC0gbG9vcENvdW50O1xuXG5cdFx0XHRcdFx0aWYgKHBlbmRpbmcgPD0gMCkge1xuXHRcdFx0XHRcdFx0Ly8gaGF2ZSB0byBzdG9wIChzd2l0Y2ggc3RhdGUsIGNsYW1wIHRpbWUsIGZpcmUgZXZlbnQpXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5jbGFtcFdoZW5GaW5pc2hlZCkgdGhpcy5wYXVzZWQgPSB0cnVlO2Vsc2UgdGhpcy5lbmFibGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR0aW1lID0gZGVsdGFUaW1lID4gMCA/IGR1cmF0aW9uIDogMDtcblx0XHRcdFx0XHRcdHRoaXMudGltZSA9IHRpbWU7XG5cblx0XHRcdFx0XHRcdHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoe1xuXHRcdFx0XHRcdFx0XHR0eXBlOiAnZmluaXNoZWQnLFxuXHRcdFx0XHRcdFx0XHRhY3Rpb246IHRoaXMsXG5cdFx0XHRcdFx0XHRcdGRpcmVjdGlvbjogZGVsdGFUaW1lID4gMCA/IDEgOiAtMVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIGtlZXAgcnVubmluZ1xuXHRcdFx0XHRcdFx0aWYgKHBlbmRpbmcgPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0Ly8gZW50ZXJpbmcgdGhlIGxhc3Qgcm91bmRcblx0XHRcdFx0XHRcdFx0Y29uc3QgYXRTdGFydCA9IGRlbHRhVGltZSA8IDA7XG5cblx0XHRcdFx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyhhdFN0YXJ0LCAhYXRTdGFydCwgcGluZ1BvbmcpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyhmYWxzZSwgZmFsc2UsIHBpbmdQb25nKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dGhpcy5fbG9vcENvdW50ID0gbG9vcENvdW50O1xuXHRcdFx0XHRcdFx0dGhpcy50aW1lID0gdGltZTtcblxuXHRcdFx0XHRcdFx0dGhpcy5fbWl4ZXIuZGlzcGF0Y2hFdmVudCh7XG5cdFx0XHRcdFx0XHRcdHR5cGU6ICdsb29wJyxcblx0XHRcdFx0XHRcdFx0YWN0aW9uOiB0aGlzLFxuXHRcdFx0XHRcdFx0XHRsb29wRGVsdGE6IGxvb3BEZWx0YVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMudGltZSA9IHRpbWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAocGluZ1BvbmcgJiYgKGxvb3BDb3VudCAmIDEpID09PSAxKSB7XG5cdFx0XHRcdFx0Ly8gaW52ZXJ0IHRpbWUgZm9yIHRoZSBcInBvbmcgcm91bmRcIlxuXHRcdFx0XHRcdHJldHVybiBkdXJhdGlvbiAtIHRpbWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRpbWU7XG5cdFx0fVxuXG5cdFx0X3NldEVuZGluZ3MoYXRTdGFydCwgYXRFbmQsIHBpbmdQb25nKSB7XG5cdFx0XHRjb25zdCBzZXR0aW5ncyA9IHRoaXMuX2ludGVycG9sYW50U2V0dGluZ3M7XG5cblx0XHRcdGlmIChwaW5nUG9uZykge1xuXHRcdFx0XHRzZXR0aW5ncy5lbmRpbmdTdGFydCA9IFplcm9TbG9wZUVuZGluZztcblx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nRW5kID0gWmVyb1Nsb3BlRW5kaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gYXNzdW1pbmcgZm9yIExvb3BPbmNlIGF0U3RhcnQgPT0gYXRFbmQgPT0gdHJ1ZVxuXHRcdFx0XHRpZiAoYXRTdGFydCkge1xuXHRcdFx0XHRcdHNldHRpbmdzLmVuZGluZ1N0YXJ0ID0gdGhpcy56ZXJvU2xvcGVBdFN0YXJ0ID8gWmVyb1Nsb3BlRW5kaW5nIDogWmVyb0N1cnZhdHVyZUVuZGluZztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZXR0aW5ncy5lbmRpbmdTdGFydCA9IFdyYXBBcm91bmRFbmRpbmc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYXRFbmQpIHtcblx0XHRcdFx0XHRzZXR0aW5ncy5lbmRpbmdFbmQgPSB0aGlzLnplcm9TbG9wZUF0RW5kID8gWmVyb1Nsb3BlRW5kaW5nIDogWmVyb0N1cnZhdHVyZUVuZGluZztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZXR0aW5ncy5lbmRpbmdFbmQgPSBXcmFwQXJvdW5kRW5kaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0X3NjaGVkdWxlRmFkaW5nKGR1cmF0aW9uLCB3ZWlnaHROb3csIHdlaWdodFRoZW4pIHtcblx0XHRcdGNvbnN0IG1peGVyID0gdGhpcy5fbWl4ZXIsXG5cdFx0XHRcdFx0XHRub3cgPSBtaXhlci50aW1lO1xuXHRcdFx0bGV0IGludGVycG9sYW50ID0gdGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQ7XG5cblx0XHRcdGlmIChpbnRlcnBvbGFudCA9PT0gbnVsbCkge1xuXHRcdFx0XHRpbnRlcnBvbGFudCA9IG1peGVyLl9sZW5kQ29udHJvbEludGVycG9sYW50KCk7XG5cdFx0XHRcdHRoaXMuX3dlaWdodEludGVycG9sYW50ID0gaW50ZXJwb2xhbnQ7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHRpbWVzID0gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zLFxuXHRcdFx0XHRcdFx0dmFsdWVzID0gaW50ZXJwb2xhbnQuc2FtcGxlVmFsdWVzO1xuXHRcdFx0dGltZXNbMF0gPSBub3c7XG5cdFx0XHR2YWx1ZXNbMF0gPSB3ZWlnaHROb3c7XG5cdFx0XHR0aW1lc1sxXSA9IG5vdyArIGR1cmF0aW9uO1xuXHRcdFx0dmFsdWVzWzFdID0gd2VpZ2h0VGhlbjtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgQW5pbWF0aW9uTWl4ZXIgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuXHRcdGNvbnN0cnVjdG9yKHJvb3QpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLl9yb290ID0gcm9vdDtcblxuXHRcdFx0dGhpcy5faW5pdE1lbW9yeU1hbmFnZXIoKTtcblxuXHRcdFx0dGhpcy5fYWNjdUluZGV4ID0gMDtcblx0XHRcdHRoaXMudGltZSA9IDA7XG5cdFx0XHR0aGlzLnRpbWVTY2FsZSA9IDEuMDtcblx0XHR9XG5cblx0XHRfYmluZEFjdGlvbihhY3Rpb24sIHByb3RvdHlwZUFjdGlvbikge1xuXHRcdFx0Y29uc3Qgcm9vdCA9IGFjdGlvbi5fbG9jYWxSb290IHx8IHRoaXMuX3Jvb3QsXG5cdFx0XHRcdFx0XHR0cmFja3MgPSBhY3Rpb24uX2NsaXAudHJhY2tzLFxuXHRcdFx0XHRcdFx0blRyYWNrcyA9IHRyYWNrcy5sZW5ndGgsXG5cdFx0XHRcdFx0XHRiaW5kaW5ncyA9IGFjdGlvbi5fcHJvcGVydHlCaW5kaW5ncyxcblx0XHRcdFx0XHRcdGludGVycG9sYW50cyA9IGFjdGlvbi5faW50ZXJwb2xhbnRzLFxuXHRcdFx0XHRcdFx0cm9vdFV1aWQgPSByb290LnV1aWQsXG5cdFx0XHRcdFx0XHRiaW5kaW5nc0J5Um9vdCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZTtcblx0XHRcdGxldCBiaW5kaW5nc0J5TmFtZSA9IGJpbmRpbmdzQnlSb290W3Jvb3RVdWlkXTtcblxuXHRcdFx0aWYgKGJpbmRpbmdzQnlOYW1lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0YmluZGluZ3NCeU5hbWUgPSB7fTtcblx0XHRcdFx0YmluZGluZ3NCeVJvb3Rbcm9vdFV1aWRdID0gYmluZGluZ3NCeU5hbWU7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpICE9PSBuVHJhY2tzOyArK2kpIHtcblx0XHRcdFx0Y29uc3QgdHJhY2sgPSB0cmFja3NbaV0sXG5cdFx0XHRcdFx0XHRcdHRyYWNrTmFtZSA9IHRyYWNrLm5hbWU7XG5cdFx0XHRcdGxldCBiaW5kaW5nID0gYmluZGluZ3NCeU5hbWVbdHJhY2tOYW1lXTtcblxuXHRcdFx0XHRpZiAoYmluZGluZyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0YmluZGluZ3NbaV0gPSBiaW5kaW5nO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcblxuXHRcdFx0XHRcdGlmIChiaW5kaW5nICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdC8vIGV4aXN0aW5nIGJpbmRpbmcsIG1ha2Ugc3VyZSB0aGUgY2FjaGUga25vd3Ncblx0XHRcdFx0XHRcdGlmIChiaW5kaW5nLl9jYWNoZUluZGV4ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdCsrYmluZGluZy5yZWZlcmVuY2VDb3VudDtcblxuXHRcdFx0XHRcdFx0XHR0aGlzLl9hZGRJbmFjdGl2ZUJpbmRpbmcoYmluZGluZywgcm9vdFV1aWQsIHRyYWNrTmFtZSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IHBhdGggPSBwcm90b3R5cGVBY3Rpb24gJiYgcHJvdG90eXBlQWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzW2ldLmJpbmRpbmcucGFyc2VkUGF0aDtcblx0XHRcdFx0XHRiaW5kaW5nID0gbmV3IFByb3BlcnR5TWl4ZXIoUHJvcGVydHlCaW5kaW5nLmNyZWF0ZShyb290LCB0cmFja05hbWUsIHBhdGgpLCB0cmFjay5WYWx1ZVR5cGVOYW1lLCB0cmFjay5nZXRWYWx1ZVNpemUoKSk7XG5cdFx0XHRcdFx0KytiaW5kaW5nLnJlZmVyZW5jZUNvdW50O1xuXG5cdFx0XHRcdFx0dGhpcy5fYWRkSW5hY3RpdmVCaW5kaW5nKGJpbmRpbmcsIHJvb3RVdWlkLCB0cmFja05hbWUpO1xuXG5cdFx0XHRcdFx0YmluZGluZ3NbaV0gPSBiaW5kaW5nO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aW50ZXJwb2xhbnRzW2ldLnJlc3VsdEJ1ZmZlciA9IGJpbmRpbmcuYnVmZmVyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdF9hY3RpdmF0ZUFjdGlvbihhY3Rpb24pIHtcblx0XHRcdGlmICghdGhpcy5faXNBY3RpdmVBY3Rpb24oYWN0aW9uKSkge1xuXHRcdFx0XHRpZiAoYWN0aW9uLl9jYWNoZUluZGV4ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0Ly8gdGhpcyBhY3Rpb24gaGFzIGJlZW4gZm9yZ290dGVuIGJ5IHRoZSBjYWNoZSwgYnV0IHRoZSB1c2VyXG5cdFx0XHRcdFx0Ly8gYXBwZWFycyB0byBiZSBzdGlsbCB1c2luZyBpdCAtPiByZWJpbmRcblx0XHRcdFx0XHRjb25zdCByb290VXVpZCA9IChhY3Rpb24uX2xvY2FsUm9vdCB8fCB0aGlzLl9yb290KS51dWlkLFxuXHRcdFx0XHRcdFx0XHRcdGNsaXBVdWlkID0gYWN0aW9uLl9jbGlwLnV1aWQsXG5cdFx0XHRcdFx0XHRcdFx0YWN0aW9uc0ZvckNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwW2NsaXBVdWlkXTtcblxuXHRcdFx0XHRcdHRoaXMuX2JpbmRBY3Rpb24oYWN0aW9uLCBhY3Rpb25zRm9yQ2xpcCAmJiBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnNbMF0pO1xuXG5cdFx0XHRcdFx0dGhpcy5fYWRkSW5hY3RpdmVBY3Rpb24oYWN0aW9uLCBjbGlwVXVpZCwgcm9vdFV1aWQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgYmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3M7IC8vIGluY3JlbWVudCByZWZlcmVuY2UgY291bnRzIC8gc29ydCBvdXQgc3RhdGVcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKytpKSB7XG5cdFx0XHRcdFx0Y29uc3QgYmluZGluZyA9IGJpbmRpbmdzW2ldO1xuXG5cdFx0XHRcdFx0aWYgKGJpbmRpbmcudXNlQ291bnQrKyA9PT0gMCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fbGVuZEJpbmRpbmcoYmluZGluZyk7XG5cblx0XHRcdFx0XHRcdGJpbmRpbmcuc2F2ZU9yaWdpbmFsU3RhdGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9sZW5kQWN0aW9uKGFjdGlvbik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0X2RlYWN0aXZhdGVBY3Rpb24oYWN0aW9uKSB7XG5cdFx0XHRpZiAodGhpcy5faXNBY3RpdmVBY3Rpb24oYWN0aW9uKSkge1xuXHRcdFx0XHRjb25zdCBiaW5kaW5ncyA9IGFjdGlvbi5fcHJvcGVydHlCaW5kaW5nczsgLy8gZGVjcmVtZW50IHJlZmVyZW5jZSBjb3VudHMgLyBzb3J0IG91dCBzdGF0ZVxuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArK2kpIHtcblx0XHRcdFx0XHRjb25zdCBiaW5kaW5nID0gYmluZGluZ3NbaV07XG5cblx0XHRcdFx0XHRpZiAoLS1iaW5kaW5nLnVzZUNvdW50ID09PSAwKSB7XG5cdFx0XHRcdFx0XHRiaW5kaW5nLnJlc3RvcmVPcmlnaW5hbFN0YXRlKCk7XG5cblx0XHRcdFx0XHRcdHRoaXMuX3Rha2VCYWNrQmluZGluZyhiaW5kaW5nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl90YWtlQmFja0FjdGlvbihhY3Rpb24pO1xuXHRcdFx0fVxuXHRcdH0gLy8gTWVtb3J5IG1hbmFnZXJcblxuXG5cdFx0X2luaXRNZW1vcnlNYW5hZ2VyKCkge1xuXHRcdFx0dGhpcy5fYWN0aW9ucyA9IFtdOyAvLyAnbkFjdGl2ZUFjdGlvbnMnIGZvbGxvd2VkIGJ5IGluYWN0aXZlIG9uZXNcblxuXHRcdFx0dGhpcy5fbkFjdGl2ZUFjdGlvbnMgPSAwO1xuXHRcdFx0dGhpcy5fYWN0aW9uc0J5Q2xpcCA9IHt9OyAvLyBpbnNpZGU6XG5cdFx0XHQvLyB7XG5cdFx0XHQvLyBcdGtub3duQWN0aW9uczogQXJyYXk8IEFuaW1hdGlvbkFjdGlvbiA+IC0gdXNlZCBhcyBwcm90b3R5cGVzXG5cdFx0XHQvLyBcdGFjdGlvbkJ5Um9vdDogQW5pbWF0aW9uQWN0aW9uIC0gbG9va3VwXG5cdFx0XHQvLyB9XG5cblx0XHRcdHRoaXMuX2JpbmRpbmdzID0gW107IC8vICduQWN0aXZlQmluZGluZ3MnIGZvbGxvd2VkIGJ5IGluYWN0aXZlIG9uZXNcblxuXHRcdFx0dGhpcy5fbkFjdGl2ZUJpbmRpbmdzID0gMDtcblx0XHRcdHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSA9IHt9OyAvLyBpbnNpZGU6IE1hcDwgbmFtZSwgUHJvcGVydHlNaXhlciA+XG5cblx0XHRcdHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMgPSBbXTsgLy8gc2FtZSBnYW1lIGFzIGFib3ZlXG5cblx0XHRcdHRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzID0gMDtcblx0XHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblx0XHRcdHRoaXMuc3RhdHMgPSB7XG5cdFx0XHRcdGFjdGlvbnM6IHtcblx0XHRcdFx0XHRnZXQgdG90YWwoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX2FjdGlvbnMubGVuZ3RoO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRnZXQgaW5Vc2UoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX25BY3RpdmVBY3Rpb25zO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9LFxuXHRcdFx0XHRiaW5kaW5nczoge1xuXHRcdFx0XHRcdGdldCB0b3RhbCgpIHtcblx0XHRcdFx0XHRcdHJldHVybiBzY29wZS5fYmluZGluZ3MubGVuZ3RoO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRnZXQgaW5Vc2UoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX25BY3RpdmVCaW5kaW5ncztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSxcblx0XHRcdFx0Y29udHJvbEludGVycG9sYW50czoge1xuXHRcdFx0XHRcdGdldCB0b3RhbCgpIHtcblx0XHRcdFx0XHRcdHJldHVybiBzY29wZS5fY29udHJvbEludGVycG9sYW50cy5sZW5ndGg7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdGdldCBpblVzZSgpIHtcblx0XHRcdFx0XHRcdHJldHVybiBzY29wZS5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSAvLyBNZW1vcnkgbWFuYWdlbWVudCBmb3IgQW5pbWF0aW9uQWN0aW9uIG9iamVjdHNcblxuXG5cdFx0X2lzQWN0aXZlQWN0aW9uKGFjdGlvbikge1xuXHRcdFx0Y29uc3QgaW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXg7XG5cdFx0XHRyZXR1cm4gaW5kZXggIT09IG51bGwgJiYgaW5kZXggPCB0aGlzLl9uQWN0aXZlQWN0aW9ucztcblx0XHR9XG5cblx0XHRfYWRkSW5hY3RpdmVBY3Rpb24oYWN0aW9uLCBjbGlwVXVpZCwgcm9vdFV1aWQpIHtcblx0XHRcdGNvbnN0IGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0XHRcdFx0YWN0aW9uc0J5Q2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXA7XG5cdFx0XHRsZXQgYWN0aW9uc0ZvckNsaXAgPSBhY3Rpb25zQnlDbGlwW2NsaXBVdWlkXTtcblxuXHRcdFx0aWYgKGFjdGlvbnNGb3JDbGlwID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0YWN0aW9uc0ZvckNsaXAgPSB7XG5cdFx0XHRcdFx0a25vd25BY3Rpb25zOiBbYWN0aW9uXSxcblx0XHRcdFx0XHRhY3Rpb25CeVJvb3Q6IHt9XG5cdFx0XHRcdH07XG5cdFx0XHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IDA7XG5cdFx0XHRcdGFjdGlvbnNCeUNsaXBbY2xpcFV1aWRdID0gYWN0aW9uc0ZvckNsaXA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBrbm93bkFjdGlvbnMgPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnM7XG5cdFx0XHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IGtub3duQWN0aW9ucy5sZW5ndGg7XG5cdFx0XHRcdGtub3duQWN0aW9ucy5wdXNoKGFjdGlvbik7XG5cdFx0XHR9XG5cblx0XHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IGFjdGlvbnMubGVuZ3RoO1xuXHRcdFx0YWN0aW9ucy5wdXNoKGFjdGlvbik7XG5cdFx0XHRhY3Rpb25zRm9yQ2xpcC5hY3Rpb25CeVJvb3Rbcm9vdFV1aWRdID0gYWN0aW9uO1xuXHRcdH1cblxuXHRcdF9yZW1vdmVJbmFjdGl2ZUFjdGlvbihhY3Rpb24pIHtcblx0XHRcdGNvbnN0IGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0XHRcdFx0bGFzdEluYWN0aXZlQWN0aW9uID0gYWN0aW9uc1thY3Rpb25zLmxlbmd0aCAtIDFdLFxuXHRcdFx0XHRcdFx0Y2FjaGVJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleDtcblx0XHRcdGxhc3RJbmFjdGl2ZUFjdGlvbi5fY2FjaGVJbmRleCA9IGNhY2hlSW5kZXg7XG5cdFx0XHRhY3Rpb25zW2NhY2hlSW5kZXhdID0gbGFzdEluYWN0aXZlQWN0aW9uO1xuXHRcdFx0YWN0aW9ucy5wb3AoKTtcblx0XHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IG51bGw7XG5cdFx0XHRjb25zdCBjbGlwVXVpZCA9IGFjdGlvbi5fY2xpcC51dWlkLFxuXHRcdFx0XHRcdFx0YWN0aW9uc0J5Q2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXAsXG5cdFx0XHRcdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNCeUNsaXBbY2xpcFV1aWRdLFxuXHRcdFx0XHRcdFx0a25vd25BY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9ucyxcblx0XHRcdFx0XHRcdGxhc3RLbm93bkFjdGlvbiA9IGtub3duQWN0aW9uc0ZvckNsaXBba25vd25BY3Rpb25zRm9yQ2xpcC5sZW5ndGggLSAxXSxcblx0XHRcdFx0XHRcdGJ5Q2xpcENhY2hlSW5kZXggPSBhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXg7XG5cdFx0XHRsYXN0S25vd25BY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSBieUNsaXBDYWNoZUluZGV4O1xuXHRcdFx0a25vd25BY3Rpb25zRm9yQ2xpcFtieUNsaXBDYWNoZUluZGV4XSA9IGxhc3RLbm93bkFjdGlvbjtcblx0XHRcdGtub3duQWN0aW9uc0ZvckNsaXAucG9wKCk7XG5cdFx0XHRhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSBudWxsO1xuXHRcdFx0Y29uc3QgYWN0aW9uQnlSb290ID0gYWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290LFxuXHRcdFx0XHRcdFx0cm9vdFV1aWQgPSAoYWN0aW9uLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCkudXVpZDtcblx0XHRcdGRlbGV0ZSBhY3Rpb25CeVJvb3Rbcm9vdFV1aWRdO1xuXG5cdFx0XHRpZiAoa25vd25BY3Rpb25zRm9yQ2xpcC5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0ZGVsZXRlIGFjdGlvbnNCeUNsaXBbY2xpcFV1aWRdO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmdzRm9yQWN0aW9uKGFjdGlvbik7XG5cdFx0fVxuXG5cdFx0X3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb24oYWN0aW9uKSB7XG5cdFx0XHRjb25zdCBiaW5kaW5ncyA9IGFjdGlvbi5fcHJvcGVydHlCaW5kaW5ncztcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsraSkge1xuXHRcdFx0XHRjb25zdCBiaW5kaW5nID0gYmluZGluZ3NbaV07XG5cblx0XHRcdFx0aWYgKC0tYmluZGluZy5yZWZlcmVuY2VDb3VudCA9PT0gMCkge1xuXHRcdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZyhiaW5kaW5nKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdF9sZW5kQWN0aW9uKGFjdGlvbikge1xuXHRcdFx0Ly8gWyBhY3RpdmUgYWN0aW9ucyB8XHRpbmFjdGl2ZSBhY3Rpb25zXHRdXG5cdFx0XHQvLyBbXHRhY3RpdmUgYWN0aW9ucyA+fCBpbmFjdGl2ZSBhY3Rpb25zIF1cblx0XHRcdC8vXHRcdFx0XHRcdFx0XHRcdCBzXHRcdFx0XHRhXG5cdFx0XHQvL1x0XHRcdFx0XHRcdFx0XHRcdDwtc3dhcC0+XG5cdFx0XHQvL1x0XHRcdFx0XHRcdFx0XHQgYVx0XHRcdFx0c1xuXHRcdFx0Y29uc3QgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXG5cdFx0XHRcdFx0XHRwcmV2SW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXgsXG5cdFx0XHRcdFx0XHRsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9uQWN0aXZlQWN0aW9ucysrLFxuXHRcdFx0XHRcdFx0Zmlyc3RJbmFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbbGFzdEFjdGl2ZUluZGV4XTtcblx0XHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IGxhc3RBY3RpdmVJbmRleDtcblx0XHRcdGFjdGlvbnNbbGFzdEFjdGl2ZUluZGV4XSA9IGFjdGlvbjtcblx0XHRcdGZpcnN0SW5hY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XG5cdFx0XHRhY3Rpb25zW3ByZXZJbmRleF0gPSBmaXJzdEluYWN0aXZlQWN0aW9uO1xuXHRcdH1cblxuXHRcdF90YWtlQmFja0FjdGlvbihhY3Rpb24pIHtcblx0XHRcdC8vIFtcdGFjdGl2ZSBhY3Rpb25zXHR8IGluYWN0aXZlIGFjdGlvbnMgXVxuXHRcdFx0Ly8gWyBhY3RpdmUgYWN0aW9ucyB8PCBpbmFjdGl2ZSBhY3Rpb25zXHRdXG5cdFx0XHQvL1x0XHRcdFx0YVx0XHRcdFx0c1xuXHRcdFx0Ly9cdFx0XHRcdCA8LXN3YXAtPlxuXHRcdFx0Ly9cdFx0XHRcdHNcdFx0XHRcdGFcblx0XHRcdGNvbnN0IGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0XHRcdFx0cHJldkluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4LFxuXHRcdFx0XHRcdFx0Zmlyc3RJbmFjdGl2ZUluZGV4ID0gLS10aGlzLl9uQWN0aXZlQWN0aW9ucyxcblx0XHRcdFx0XHRcdGxhc3RBY3RpdmVBY3Rpb24gPSBhY3Rpb25zW2ZpcnN0SW5hY3RpdmVJbmRleF07XG5cdFx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBmaXJzdEluYWN0aXZlSW5kZXg7XG5cdFx0XHRhY3Rpb25zW2ZpcnN0SW5hY3RpdmVJbmRleF0gPSBhY3Rpb247XG5cdFx0XHRsYXN0QWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gcHJldkluZGV4O1xuXHRcdFx0YWN0aW9uc1twcmV2SW5kZXhdID0gbGFzdEFjdGl2ZUFjdGlvbjtcblx0XHR9IC8vIE1lbW9yeSBtYW5hZ2VtZW50IGZvciBQcm9wZXJ0eU1peGVyIG9iamVjdHNcblxuXG5cdFx0X2FkZEluYWN0aXZlQmluZGluZyhiaW5kaW5nLCByb290VXVpZCwgdHJhY2tOYW1lKSB7XG5cdFx0XHRjb25zdCBiaW5kaW5nc0J5Um9vdCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSxcblx0XHRcdFx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XG5cdFx0XHRsZXQgYmluZGluZ0J5TmFtZSA9IGJpbmRpbmdzQnlSb290W3Jvb3RVdWlkXTtcblxuXHRcdFx0aWYgKGJpbmRpbmdCeU5hbWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRiaW5kaW5nQnlOYW1lID0ge307XG5cdFx0XHRcdGJpbmRpbmdzQnlSb290W3Jvb3RVdWlkXSA9IGJpbmRpbmdCeU5hbWU7XG5cdFx0XHR9XG5cblx0XHRcdGJpbmRpbmdCeU5hbWVbdHJhY2tOYW1lXSA9IGJpbmRpbmc7XG5cdFx0XHRiaW5kaW5nLl9jYWNoZUluZGV4ID0gYmluZGluZ3MubGVuZ3RoO1xuXHRcdFx0YmluZGluZ3MucHVzaChiaW5kaW5nKTtcblx0XHR9XG5cblx0XHRfcmVtb3ZlSW5hY3RpdmVCaW5kaW5nKGJpbmRpbmcpIHtcblx0XHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRcdFx0XHRwcm9wQmluZGluZyA9IGJpbmRpbmcuYmluZGluZyxcblx0XHRcdFx0XHRcdHJvb3RVdWlkID0gcHJvcEJpbmRpbmcucm9vdE5vZGUudXVpZCxcblx0XHRcdFx0XHRcdHRyYWNrTmFtZSA9IHByb3BCaW5kaW5nLnBhdGgsXG5cdFx0XHRcdFx0XHRiaW5kaW5nc0J5Um9vdCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSxcblx0XHRcdFx0XHRcdGJpbmRpbmdCeU5hbWUgPSBiaW5kaW5nc0J5Um9vdFtyb290VXVpZF0sXG5cdFx0XHRcdFx0XHRsYXN0SW5hY3RpdmVCaW5kaW5nID0gYmluZGluZ3NbYmluZGluZ3MubGVuZ3RoIC0gMV0sXG5cdFx0XHRcdFx0XHRjYWNoZUluZGV4ID0gYmluZGluZy5fY2FjaGVJbmRleDtcblx0XHRcdGxhc3RJbmFjdGl2ZUJpbmRpbmcuX2NhY2hlSW5kZXggPSBjYWNoZUluZGV4O1xuXHRcdFx0YmluZGluZ3NbY2FjaGVJbmRleF0gPSBsYXN0SW5hY3RpdmVCaW5kaW5nO1xuXHRcdFx0YmluZGluZ3MucG9wKCk7XG5cdFx0XHRkZWxldGUgYmluZGluZ0J5TmFtZVt0cmFja05hbWVdO1xuXG5cdFx0XHRpZiAoT2JqZWN0LmtleXMoYmluZGluZ0J5TmFtZSkubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdGRlbGV0ZSBiaW5kaW5nc0J5Um9vdFtyb290VXVpZF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0X2xlbmRCaW5kaW5nKGJpbmRpbmcpIHtcblx0XHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRcdFx0XHRwcmV2SW5kZXggPSBiaW5kaW5nLl9jYWNoZUluZGV4LFxuXHRcdFx0XHRcdFx0bGFzdEFjdGl2ZUluZGV4ID0gdGhpcy5fbkFjdGl2ZUJpbmRpbmdzKyssXG5cdFx0XHRcdFx0XHRmaXJzdEluYWN0aXZlQmluZGluZyA9IGJpbmRpbmdzW2xhc3RBY3RpdmVJbmRleF07XG5cdFx0XHRiaW5kaW5nLl9jYWNoZUluZGV4ID0gbGFzdEFjdGl2ZUluZGV4O1xuXHRcdFx0YmluZGluZ3NbbGFzdEFjdGl2ZUluZGV4XSA9IGJpbmRpbmc7XG5cdFx0XHRmaXJzdEluYWN0aXZlQmluZGluZy5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcblx0XHRcdGJpbmRpbmdzW3ByZXZJbmRleF0gPSBmaXJzdEluYWN0aXZlQmluZGluZztcblx0XHR9XG5cblx0XHRfdGFrZUJhY2tCaW5kaW5nKGJpbmRpbmcpIHtcblx0XHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRcdFx0XHRwcmV2SW5kZXggPSBiaW5kaW5nLl9jYWNoZUluZGV4LFxuXHRcdFx0XHRcdFx0Zmlyc3RJbmFjdGl2ZUluZGV4ID0gLS10aGlzLl9uQWN0aXZlQmluZGluZ3MsXG5cdFx0XHRcdFx0XHRsYXN0QWN0aXZlQmluZGluZyA9IGJpbmRpbmdzW2ZpcnN0SW5hY3RpdmVJbmRleF07XG5cdFx0XHRiaW5kaW5nLl9jYWNoZUluZGV4ID0gZmlyc3RJbmFjdGl2ZUluZGV4O1xuXHRcdFx0YmluZGluZ3NbZmlyc3RJbmFjdGl2ZUluZGV4XSA9IGJpbmRpbmc7XG5cdFx0XHRsYXN0QWN0aXZlQmluZGluZy5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcblx0XHRcdGJpbmRpbmdzW3ByZXZJbmRleF0gPSBsYXN0QWN0aXZlQmluZGluZztcblx0XHR9IC8vIE1lbW9yeSBtYW5hZ2VtZW50IG9mIEludGVycG9sYW50cyBmb3Igd2VpZ2h0IGFuZCB0aW1lIHNjYWxlXG5cblxuXHRcdF9sZW5kQ29udHJvbEludGVycG9sYW50KCkge1xuXHRcdFx0Y29uc3QgaW50ZXJwb2xhbnRzID0gdGhpcy5fY29udHJvbEludGVycG9sYW50cyxcblx0XHRcdFx0XHRcdGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzKys7XG5cdFx0XHRsZXQgaW50ZXJwb2xhbnQgPSBpbnRlcnBvbGFudHNbbGFzdEFjdGl2ZUluZGV4XTtcblxuXHRcdFx0aWYgKGludGVycG9sYW50ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aW50ZXJwb2xhbnQgPSBuZXcgTGluZWFySW50ZXJwb2xhbnQobmV3IEZsb2F0MzJBcnJheSgyKSwgbmV3IEZsb2F0MzJBcnJheSgyKSwgMSwgdGhpcy5fY29udHJvbEludGVycG9sYW50c1Jlc3VsdEJ1ZmZlcik7XG5cdFx0XHRcdGludGVycG9sYW50Ll9fY2FjaGVJbmRleCA9IGxhc3RBY3RpdmVJbmRleDtcblx0XHRcdFx0aW50ZXJwb2xhbnRzW2xhc3RBY3RpdmVJbmRleF0gPSBpbnRlcnBvbGFudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGludGVycG9sYW50O1xuXHRcdH1cblxuXHRcdF90YWtlQmFja0NvbnRyb2xJbnRlcnBvbGFudChpbnRlcnBvbGFudCkge1xuXHRcdFx0Y29uc3QgaW50ZXJwb2xhbnRzID0gdGhpcy5fY29udHJvbEludGVycG9sYW50cyxcblx0XHRcdFx0XHRcdHByZXZJbmRleCA9IGludGVycG9sYW50Ll9fY2FjaGVJbmRleCxcblx0XHRcdFx0XHRcdGZpcnN0SW5hY3RpdmVJbmRleCA9IC0tdGhpcy5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHMsXG5cdFx0XHRcdFx0XHRsYXN0QWN0aXZlSW50ZXJwb2xhbnQgPSBpbnRlcnBvbGFudHNbZmlyc3RJbmFjdGl2ZUluZGV4XTtcblx0XHRcdGludGVycG9sYW50Ll9fY2FjaGVJbmRleCA9IGZpcnN0SW5hY3RpdmVJbmRleDtcblx0XHRcdGludGVycG9sYW50c1tmaXJzdEluYWN0aXZlSW5kZXhdID0gaW50ZXJwb2xhbnQ7XG5cdFx0XHRsYXN0QWN0aXZlSW50ZXJwb2xhbnQuX19jYWNoZUluZGV4ID0gcHJldkluZGV4O1xuXHRcdFx0aW50ZXJwb2xhbnRzW3ByZXZJbmRleF0gPSBsYXN0QWN0aXZlSW50ZXJwb2xhbnQ7XG5cdFx0fSAvLyByZXR1cm4gYW4gYWN0aW9uIGZvciBhIGNsaXAgb3B0aW9uYWxseSB1c2luZyBhIGN1c3RvbSByb290IHRhcmdldFxuXHRcdC8vIG9iamVjdCAodGhpcyBtZXRob2QgYWxsb2NhdGVzIGEgbG90IG9mIGR5bmFtaWMgbWVtb3J5IGluIGNhc2UgYVxuXHRcdC8vIHByZXZpb3VzbHkgdW5rbm93biBjbGlwL3Jvb3QgY29tYmluYXRpb24gaXMgc3BlY2lmaWVkKVxuXG5cblx0XHRjbGlwQWN0aW9uKGNsaXAsIG9wdGlvbmFsUm9vdCwgYmxlbmRNb2RlKSB7XG5cdFx0XHRjb25zdCByb290ID0gb3B0aW9uYWxSb290IHx8IHRoaXMuX3Jvb3QsXG5cdFx0XHRcdFx0XHRyb290VXVpZCA9IHJvb3QudXVpZDtcblx0XHRcdGxldCBjbGlwT2JqZWN0ID0gdHlwZW9mIGNsaXAgPT09ICdzdHJpbmcnID8gQW5pbWF0aW9uQ2xpcC5maW5kQnlOYW1lKHJvb3QsIGNsaXApIDogY2xpcDtcblx0XHRcdGNvbnN0IGNsaXBVdWlkID0gY2xpcE9iamVjdCAhPT0gbnVsbCA/IGNsaXBPYmplY3QudXVpZCA6IGNsaXA7XG5cdFx0XHRjb25zdCBhY3Rpb25zRm9yQ2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXBbY2xpcFV1aWRdO1xuXHRcdFx0bGV0IHByb3RvdHlwZUFjdGlvbiA9IG51bGw7XG5cblx0XHRcdGlmIChibGVuZE1vZGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAoY2xpcE9iamVjdCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdGJsZW5kTW9kZSA9IGNsaXBPYmplY3QuYmxlbmRNb2RlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJsZW5kTW9kZSA9IE5vcm1hbEFuaW1hdGlvbkJsZW5kTW9kZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYWN0aW9uc0ZvckNsaXAgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb25zdCBleGlzdGluZ0FjdGlvbiA9IGFjdGlvbnNGb3JDbGlwLmFjdGlvbkJ5Um9vdFtyb290VXVpZF07XG5cblx0XHRcdFx0aWYgKGV4aXN0aW5nQWN0aW9uICE9PSB1bmRlZmluZWQgJiYgZXhpc3RpbmdBY3Rpb24uYmxlbmRNb2RlID09PSBibGVuZE1vZGUpIHtcblx0XHRcdFx0XHRyZXR1cm4gZXhpc3RpbmdBY3Rpb247XG5cdFx0XHRcdH0gLy8gd2Uga25vdyB0aGUgY2xpcCwgc28gd2UgZG9uJ3QgaGF2ZSB0byBwYXJzZSBhbGxcblx0XHRcdFx0Ly8gdGhlIGJpbmRpbmdzIGFnYWluIGJ1dCBjYW4ganVzdCBjb3B5XG5cblxuXHRcdFx0XHRwcm90b3R5cGVBY3Rpb24gPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnNbMF07IC8vIGFsc28sIHRha2UgdGhlIGNsaXAgZnJvbSB0aGUgcHJvdG90eXBlIGFjdGlvblxuXG5cdFx0XHRcdGlmIChjbGlwT2JqZWN0ID09PSBudWxsKSBjbGlwT2JqZWN0ID0gcHJvdG90eXBlQWN0aW9uLl9jbGlwO1xuXHRcdFx0fSAvLyBjbGlwIG11c3QgYmUga25vd24gd2hlbiBzcGVjaWZpZWQgdmlhIHN0cmluZ1xuXG5cblx0XHRcdGlmIChjbGlwT2JqZWN0ID09PSBudWxsKSByZXR1cm4gbnVsbDsgLy8gYWxsb2NhdGUgYWxsIHJlc291cmNlcyByZXF1aXJlZCB0byBydW4gaXRcblxuXHRcdFx0Y29uc3QgbmV3QWN0aW9uID0gbmV3IEFuaW1hdGlvbkFjdGlvbih0aGlzLCBjbGlwT2JqZWN0LCBvcHRpb25hbFJvb3QsIGJsZW5kTW9kZSk7XG5cblx0XHRcdHRoaXMuX2JpbmRBY3Rpb24obmV3QWN0aW9uLCBwcm90b3R5cGVBY3Rpb24pOyAvLyBhbmQgbWFrZSB0aGUgYWN0aW9uIGtub3duIHRvIHRoZSBtZW1vcnkgbWFuYWdlclxuXG5cblx0XHRcdHRoaXMuX2FkZEluYWN0aXZlQWN0aW9uKG5ld0FjdGlvbiwgY2xpcFV1aWQsIHJvb3RVdWlkKTtcblxuXHRcdFx0cmV0dXJuIG5ld0FjdGlvbjtcblx0XHR9IC8vIGdldCBhbiBleGlzdGluZyBhY3Rpb25cblxuXG5cdFx0ZXhpc3RpbmdBY3Rpb24oY2xpcCwgb3B0aW9uYWxSb290KSB7XG5cdFx0XHRjb25zdCByb290ID0gb3B0aW9uYWxSb290IHx8IHRoaXMuX3Jvb3QsXG5cdFx0XHRcdFx0XHRyb290VXVpZCA9IHJvb3QudXVpZCxcblx0XHRcdFx0XHRcdGNsaXBPYmplY3QgPSB0eXBlb2YgY2xpcCA9PT0gJ3N0cmluZycgPyBBbmltYXRpb25DbGlwLmZpbmRCeU5hbWUocm9vdCwgY2xpcCkgOiBjbGlwLFxuXHRcdFx0XHRcdFx0Y2xpcFV1aWQgPSBjbGlwT2JqZWN0ID8gY2xpcE9iamVjdC51dWlkIDogY2xpcCxcblx0XHRcdFx0XHRcdGFjdGlvbnNGb3JDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcFtjbGlwVXVpZF07XG5cblx0XHRcdGlmIChhY3Rpb25zRm9yQ2xpcCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiBhY3Rpb25zRm9yQ2xpcC5hY3Rpb25CeVJvb3Rbcm9vdFV1aWRdIHx8IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0gLy8gZGVhY3RpdmF0ZXMgYWxsIHByZXZpb3VzbHkgc2NoZWR1bGVkIGFjdGlvbnNcblxuXG5cdFx0c3RvcEFsbEFjdGlvbigpIHtcblx0XHRcdGNvbnN0IGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0XHRcdFx0bkFjdGlvbnMgPSB0aGlzLl9uQWN0aXZlQWN0aW9ucztcblxuXHRcdFx0Zm9yIChsZXQgaSA9IG5BY3Rpb25zIC0gMTsgaSA+PSAwOyAtLWkpIHtcblx0XHRcdFx0YWN0aW9uc1tpXS5zdG9wKCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0gLy8gYWR2YW5jZSB0aGUgdGltZSBhbmQgdXBkYXRlIGFwcGx5IHRoZSBhbmltYXRpb25cblxuXG5cdFx0dXBkYXRlKGRlbHRhVGltZSkge1xuXHRcdFx0ZGVsdGFUaW1lICo9IHRoaXMudGltZVNjYWxlO1xuXHRcdFx0Y29uc3QgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXG5cdFx0XHRcdFx0XHRuQWN0aW9ucyA9IHRoaXMuX25BY3RpdmVBY3Rpb25zLFxuXHRcdFx0XHRcdFx0dGltZSA9IHRoaXMudGltZSArPSBkZWx0YVRpbWUsXG5cdFx0XHRcdFx0XHR0aW1lRGlyZWN0aW9uID0gTWF0aC5zaWduKGRlbHRhVGltZSksXG5cdFx0XHRcdFx0XHRhY2N1SW5kZXggPSB0aGlzLl9hY2N1SW5kZXggXj0gMTsgLy8gcnVuIGFjdGl2ZSBhY3Rpb25zXG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpICE9PSBuQWN0aW9uczsgKytpKSB7XG5cdFx0XHRcdGNvbnN0IGFjdGlvbiA9IGFjdGlvbnNbaV07XG5cblx0XHRcdFx0YWN0aW9uLl91cGRhdGUodGltZSwgZGVsdGFUaW1lLCB0aW1lRGlyZWN0aW9uLCBhY2N1SW5kZXgpO1xuXHRcdFx0fSAvLyB1cGRhdGUgc2NlbmUgZ3JhcGhcblxuXG5cdFx0XHRjb25zdCBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0XHRcdFx0bkJpbmRpbmdzID0gdGhpcy5fbkFjdGl2ZUJpbmRpbmdzO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSAhPT0gbkJpbmRpbmdzOyArK2kpIHtcblx0XHRcdFx0YmluZGluZ3NbaV0uYXBwbHkoYWNjdUluZGV4KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSAvLyBBbGxvd3MgeW91IHRvIHNlZWsgdG8gYSBzcGVjaWZpYyB0aW1lIGluIGFuIGFuaW1hdGlvbi5cblxuXG5cdFx0c2V0VGltZSh0aW1lSW5TZWNvbmRzKSB7XG5cdFx0XHR0aGlzLnRpbWUgPSAwOyAvLyBaZXJvIG91dCB0aW1lIGF0dHJpYnV0ZSBmb3IgQW5pbWF0aW9uTWl4ZXIgb2JqZWN0O1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2FjdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fYWN0aW9uc1tpXS50aW1lID0gMDsgLy8gWmVybyBvdXQgdGltZSBhdHRyaWJ1dGUgZm9yIGFsbCBhc3NvY2lhdGVkIEFuaW1hdGlvbkFjdGlvbiBvYmplY3RzLlxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy51cGRhdGUodGltZUluU2Vjb25kcyk7IC8vIFVwZGF0ZSB1c2VkIHRvIHNldCBleGFjdCB0aW1lLiBSZXR1cm5zIFwidGhpc1wiIEFuaW1hdGlvbk1peGVyIG9iamVjdC5cblx0XHR9IC8vIHJldHVybiB0aGlzIG1peGVyJ3Mgcm9vdCB0YXJnZXQgb2JqZWN0XG5cblxuXHRcdGdldFJvb3QoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcm9vdDtcblx0XHR9IC8vIGZyZWUgYWxsIHJlc291cmNlcyBzcGVjaWZpYyB0byBhIHBhcnRpY3VsYXIgY2xpcFxuXG5cblx0XHR1bmNhY2hlQ2xpcChjbGlwKSB7XG5cdFx0XHRjb25zdCBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcblx0XHRcdFx0XHRcdGNsaXBVdWlkID0gY2xpcC51dWlkLFxuXHRcdFx0XHRcdFx0YWN0aW9uc0J5Q2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXAsXG5cdFx0XHRcdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNCeUNsaXBbY2xpcFV1aWRdO1xuXG5cdFx0XHRpZiAoYWN0aW9uc0ZvckNsaXAgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQvLyBub3RlOiBqdXN0IGNhbGxpbmcgX3JlbW92ZUluYWN0aXZlQWN0aW9uIHdvdWxkIG1lc3MgdXAgdGhlXG5cdFx0XHRcdC8vIGl0ZXJhdGlvbiBzdGF0ZSBhbmQgYWxzbyByZXF1aXJlIHVwZGF0aW5nIHRoZSBzdGF0ZSB3ZSBjYW5cblx0XHRcdFx0Ly8ganVzdCB0aHJvdyBhd2F5XG5cdFx0XHRcdGNvbnN0IGFjdGlvbnNUb1JlbW92ZSA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9ucztcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbiA9IGFjdGlvbnNUb1JlbW92ZS5sZW5ndGg7IGkgIT09IG47ICsraSkge1xuXHRcdFx0XHRcdGNvbnN0IGFjdGlvbiA9IGFjdGlvbnNUb1JlbW92ZVtpXTtcblxuXHRcdFx0XHRcdHRoaXMuX2RlYWN0aXZhdGVBY3Rpb24oYWN0aW9uKTtcblxuXHRcdFx0XHRcdGNvbnN0IGNhY2hlSW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXgsXG5cdFx0XHRcdFx0XHRcdFx0bGFzdEluYWN0aXZlQWN0aW9uID0gYWN0aW9uc1thY3Rpb25zLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IG51bGw7XG5cdFx0XHRcdFx0YWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gbnVsbDtcblx0XHRcdFx0XHRsYXN0SW5hY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBjYWNoZUluZGV4O1xuXHRcdFx0XHRcdGFjdGlvbnNbY2FjaGVJbmRleF0gPSBsYXN0SW5hY3RpdmVBY3Rpb247XG5cdFx0XHRcdFx0YWN0aW9ucy5wb3AoKTtcblxuXHRcdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb24oYWN0aW9uKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBhY3Rpb25zQnlDbGlwW2NsaXBVdWlkXTtcblx0XHRcdH1cblx0XHR9IC8vIGZyZWUgYWxsIHJlc291cmNlcyBzcGVjaWZpYyB0byBhIHBhcnRpY3VsYXIgcm9vdCB0YXJnZXQgb2JqZWN0XG5cblxuXHRcdHVuY2FjaGVSb290KHJvb3QpIHtcblx0XHRcdGNvbnN0IHJvb3RVdWlkID0gcm9vdC51dWlkLFxuXHRcdFx0XHRcdFx0YWN0aW9uc0J5Q2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXA7XG5cblx0XHRcdGZvciAoY29uc3QgY2xpcFV1aWQgaW4gYWN0aW9uc0J5Q2xpcCkge1xuXHRcdFx0XHRjb25zdCBhY3Rpb25CeVJvb3QgPSBhY3Rpb25zQnlDbGlwW2NsaXBVdWlkXS5hY3Rpb25CeVJvb3QsXG5cdFx0XHRcdFx0XHRcdGFjdGlvbiA9IGFjdGlvbkJ5Um9vdFtyb290VXVpZF07XG5cblx0XHRcdFx0aWYgKGFjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGhpcy5fZGVhY3RpdmF0ZUFjdGlvbihhY3Rpb24pO1xuXG5cdFx0XHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVBY3Rpb24oYWN0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBiaW5kaW5nc0J5Um9vdCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSxcblx0XHRcdFx0XHRcdGJpbmRpbmdCeU5hbWUgPSBiaW5kaW5nc0J5Um9vdFtyb290VXVpZF07XG5cblx0XHRcdGlmIChiaW5kaW5nQnlOYW1lICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Zm9yIChjb25zdCB0cmFja05hbWUgaW4gYmluZGluZ0J5TmFtZSkge1xuXHRcdFx0XHRcdGNvbnN0IGJpbmRpbmcgPSBiaW5kaW5nQnlOYW1lW3RyYWNrTmFtZV07XG5cdFx0XHRcdFx0YmluZGluZy5yZXN0b3JlT3JpZ2luYWxTdGF0ZSgpO1xuXG5cdFx0XHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nKGJpbmRpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSAvLyByZW1vdmUgYSB0YXJnZXRlZCBjbGlwIGZyb20gdGhlIGNhY2hlXG5cblxuXHRcdHVuY2FjaGVBY3Rpb24oY2xpcCwgb3B0aW9uYWxSb290KSB7XG5cdFx0XHRjb25zdCBhY3Rpb24gPSB0aGlzLmV4aXN0aW5nQWN0aW9uKGNsaXAsIG9wdGlvbmFsUm9vdCk7XG5cblx0XHRcdGlmIChhY3Rpb24gIT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5fZGVhY3RpdmF0ZUFjdGlvbihhY3Rpb24pO1xuXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQWN0aW9uKGFjdGlvbik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH1cblxuXHRBbmltYXRpb25NaXhlci5wcm90b3R5cGUuX2NvbnRyb2xJbnRlcnBvbGFudHNSZXN1bHRCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KDEpO1xuXG5cdGNsYXNzIFVuaWZvcm0ge1xuXHRcdGNvbnN0cnVjdG9yKHZhbHVlKSB7XG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlVuaWZvcm06IFR5cGUgcGFyYW1ldGVyIGlzIG5vIGxvbmdlciBuZWVkZWQuJyk7XG5cdFx0XHRcdHZhbHVlID0gYXJndW1lbnRzWzFdO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0Y2xvbmUoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFVuaWZvcm0odGhpcy52YWx1ZS5jbG9uZSA9PT0gdW5kZWZpbmVkID8gdGhpcy52YWx1ZSA6IHRoaXMudmFsdWUuY2xvbmUoKSk7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciBleHRlbmRzIEludGVybGVhdmVkQnVmZmVyIHtcblx0XHRjb25zdHJ1Y3RvcihhcnJheSwgc3RyaWRlLCBtZXNoUGVyQXR0cmlidXRlID0gMSkge1xuXHRcdFx0c3VwZXIoYXJyYXksIHN0cmlkZSk7XG5cdFx0XHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBtZXNoUGVyQXR0cmlidXRlO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRzdXBlci5jb3B5KHNvdXJjZSk7XG5cdFx0XHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBzb3VyY2UubWVzaFBlckF0dHJpYnV0ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNsb25lKGRhdGEpIHtcblx0XHRcdGNvbnN0IGliID0gc3VwZXIuY2xvbmUoZGF0YSk7XG5cdFx0XHRpYi5tZXNoUGVyQXR0cmlidXRlID0gdGhpcy5tZXNoUGVyQXR0cmlidXRlO1xuXHRcdFx0cmV0dXJuIGliO1xuXHRcdH1cblxuXHRcdHRvSlNPTihkYXRhKSB7XG5cdFx0XHRjb25zdCBqc29uID0gc3VwZXIudG9KU09OKGRhdGEpO1xuXHRcdFx0anNvbi5pc0luc3RhbmNlZEludGVybGVhdmVkQnVmZmVyID0gdHJ1ZTtcblx0XHRcdGpzb24ubWVzaFBlckF0dHJpYnV0ZSA9IHRoaXMubWVzaFBlckF0dHJpYnV0ZTtcblx0XHRcdHJldHVybiBqc29uO1xuXHRcdH1cblxuXHR9XG5cblx0SW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlLmlzSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgPSB0cnVlO1xuXG5cdGNsYXNzIEdMQnVmZmVyQXR0cmlidXRlIHtcblx0XHRjb25zdHJ1Y3RvcihidWZmZXIsIHR5cGUsIGl0ZW1TaXplLCBlbGVtZW50U2l6ZSwgY291bnQpIHtcblx0XHRcdHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHRcdHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcblx0XHRcdHRoaXMuZWxlbWVudFNpemUgPSBlbGVtZW50U2l6ZTtcblx0XHRcdHRoaXMuY291bnQgPSBjb3VudDtcblx0XHRcdHRoaXMudmVyc2lvbiA9IDA7XG5cdFx0fVxuXG5cdFx0c2V0IG5lZWRzVXBkYXRlKHZhbHVlKSB7XG5cdFx0XHRpZiAodmFsdWUgPT09IHRydWUpIHRoaXMudmVyc2lvbisrO1xuXHRcdH1cblxuXHRcdHNldEJ1ZmZlcihidWZmZXIpIHtcblx0XHRcdHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0VHlwZSh0eXBlLCBlbGVtZW50U2l6ZSkge1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHRcdHRoaXMuZWxlbWVudFNpemUgPSBlbGVtZW50U2l6ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldEl0ZW1TaXplKGl0ZW1TaXplKSB7XG5cdFx0XHR0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRDb3VudChjb3VudCkge1xuXHRcdFx0dGhpcy5jb3VudCA9IGNvdW50O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRHTEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuaXNHTEJ1ZmZlckF0dHJpYnV0ZSA9IHRydWU7XG5cblx0Y2xhc3MgUmF5Y2FzdGVyIHtcblx0XHRjb25zdHJ1Y3RvcihvcmlnaW4sIGRpcmVjdGlvbiwgbmVhciA9IDAsIGZhciA9IEluZmluaXR5KSB7XG5cdFx0XHR0aGlzLnJheSA9IG5ldyBSYXkob3JpZ2luLCBkaXJlY3Rpb24pOyAvLyBkaXJlY3Rpb24gaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkIChmb3IgYWNjdXJhdGUgZGlzdGFuY2UgY2FsY3VsYXRpb25zKVxuXG5cdFx0XHR0aGlzLm5lYXIgPSBuZWFyO1xuXHRcdFx0dGhpcy5mYXIgPSBmYXI7XG5cdFx0XHR0aGlzLmNhbWVyYSA9IG51bGw7XG5cdFx0XHR0aGlzLmxheWVycyA9IG5ldyBMYXllcnMoKTtcblx0XHRcdHRoaXMucGFyYW1zID0ge1xuXHRcdFx0XHRNZXNoOiB7fSxcblx0XHRcdFx0TGluZToge1xuXHRcdFx0XHRcdHRocmVzaG9sZDogMVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRMT0Q6IHt9LFxuXHRcdFx0XHRQb2ludHM6IHtcblx0XHRcdFx0XHR0aHJlc2hvbGQ6IDFcblx0XHRcdFx0fSxcblx0XHRcdFx0U3ByaXRlOiB7fVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRzZXQob3JpZ2luLCBkaXJlY3Rpb24pIHtcblx0XHRcdC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXG5cdFx0XHR0aGlzLnJheS5zZXQob3JpZ2luLCBkaXJlY3Rpb24pO1xuXHRcdH1cblxuXHRcdHNldEZyb21DYW1lcmEoY29vcmRzLCBjYW1lcmEpIHtcblx0XHRcdGlmIChjYW1lcmEgJiYgY2FtZXJhLmlzUGVyc3BlY3RpdmVDYW1lcmEpIHtcblx0XHRcdFx0dGhpcy5yYXkub3JpZ2luLnNldEZyb21NYXRyaXhQb3NpdGlvbihjYW1lcmEubWF0cml4V29ybGQpO1xuXHRcdFx0XHR0aGlzLnJheS5kaXJlY3Rpb24uc2V0KGNvb3Jkcy54LCBjb29yZHMueSwgMC41KS51bnByb2plY3QoY2FtZXJhKS5zdWIodGhpcy5yYXkub3JpZ2luKS5ub3JtYWxpemUoKTtcblx0XHRcdFx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XG5cdFx0XHR9IGVsc2UgaWYgKGNhbWVyYSAmJiBjYW1lcmEuaXNPcnRob2dyYXBoaWNDYW1lcmEpIHtcblx0XHRcdFx0dGhpcy5yYXkub3JpZ2luLnNldChjb29yZHMueCwgY29vcmRzLnksIChjYW1lcmEubmVhciArIGNhbWVyYS5mYXIpIC8gKGNhbWVyYS5uZWFyIC0gY2FtZXJhLmZhcikpLnVucHJvamVjdChjYW1lcmEpOyAvLyBzZXQgb3JpZ2luIGluIHBsYW5lIG9mIGNhbWVyYVxuXG5cdFx0XHRcdHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoMCwgMCwgLTEpLnRyYW5zZm9ybURpcmVjdGlvbihjYW1lcmEubWF0cml4V29ybGQpO1xuXHRcdFx0XHR0aGlzLmNhbWVyYSA9IGNhbWVyYTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlJheWNhc3RlcjogVW5zdXBwb3J0ZWQgY2FtZXJhIHR5cGU6ICcgKyBjYW1lcmEudHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aW50ZXJzZWN0T2JqZWN0KG9iamVjdCwgcmVjdXJzaXZlID0gdHJ1ZSwgaW50ZXJzZWN0cyA9IFtdKSB7XG5cdFx0XHRpbnRlcnNlY3RPYmplY3Qob2JqZWN0LCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUpO1xuXHRcdFx0aW50ZXJzZWN0cy5zb3J0KGFzY1NvcnQpO1xuXHRcdFx0cmV0dXJuIGludGVyc2VjdHM7XG5cdFx0fVxuXG5cdFx0aW50ZXJzZWN0T2JqZWN0cyhvYmplY3RzLCByZWN1cnNpdmUgPSB0cnVlLCBpbnRlcnNlY3RzID0gW10pIHtcblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aW50ZXJzZWN0T2JqZWN0KG9iamVjdHNbaV0sIHRoaXMsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGludGVyc2VjdHMuc29ydChhc2NTb3J0KTtcblx0XHRcdHJldHVybiBpbnRlcnNlY3RzO1xuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gYXNjU29ydChhLCBiKSB7XG5cdFx0cmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW50ZXJzZWN0T2JqZWN0KG9iamVjdCwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUpIHtcblx0XHRpZiAob2JqZWN0LmxheWVycy50ZXN0KHJheWNhc3Rlci5sYXllcnMpKSB7XG5cdFx0XHRvYmplY3QucmF5Y2FzdChyYXljYXN0ZXIsIGludGVyc2VjdHMpO1xuXHRcdH1cblxuXHRcdGlmIChyZWN1cnNpdmUgPT09IHRydWUpIHtcblx0XHRcdGNvbnN0IGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpbnRlcnNlY3RPYmplY3QoY2hpbGRyZW5baV0sIHJheWNhc3RlciwgaW50ZXJzZWN0cywgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlZjogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BoZXJpY2FsX2Nvb3JkaW5hdGVfc3lzdGVtXG5cdCAqXG5cdCAqIFRoZSBwb2xhciBhbmdsZSAocGhpKSBpcyBtZWFzdXJlZCBmcm9tIHRoZSBwb3NpdGl2ZSB5LWF4aXMuIFRoZSBwb3NpdGl2ZSB5LWF4aXMgaXMgdXAuXG5cdCAqIFRoZSBhemltdXRoYWwgYW5nbGUgKHRoZXRhKSBpcyBtZWFzdXJlZCBmcm9tIHRoZSBwb3NpdGl2ZSB6LWF4aXMuXG5cdCAqL1xuXG5cdGNsYXNzIFNwaGVyaWNhbCB7XG5cdFx0Y29uc3RydWN0b3IocmFkaXVzID0gMSwgcGhpID0gMCwgdGhldGEgPSAwKSB7XG5cdFx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblx0XHRcdHRoaXMucGhpID0gcGhpOyAvLyBwb2xhciBhbmdsZVxuXG5cdFx0XHR0aGlzLnRoZXRhID0gdGhldGE7IC8vIGF6aW11dGhhbCBhbmdsZVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXQocmFkaXVzLCBwaGksIHRoZXRhKSB7XG5cdFx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblx0XHRcdHRoaXMucGhpID0gcGhpO1xuXHRcdFx0dGhpcy50aGV0YSA9IHRoZXRhO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29weShvdGhlcikge1xuXHRcdFx0dGhpcy5yYWRpdXMgPSBvdGhlci5yYWRpdXM7XG5cdFx0XHR0aGlzLnBoaSA9IG90aGVyLnBoaTtcblx0XHRcdHRoaXMudGhldGEgPSBvdGhlci50aGV0YTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0gLy8gcmVzdHJpY3QgcGhpIHRvIGJlIGJldHdlZSBFUFMgYW5kIFBJLUVQU1xuXG5cblx0XHRtYWtlU2FmZSgpIHtcblx0XHRcdGNvbnN0IEVQUyA9IDAuMDAwMDAxO1xuXHRcdFx0dGhpcy5waGkgPSBNYXRoLm1heChFUFMsIE1hdGgubWluKE1hdGguUEkgLSBFUFMsIHRoaXMucGhpKSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRGcm9tVmVjdG9yMyh2KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tQ2FydGVzaWFuQ29vcmRzKHYueCwgdi55LCB2LnopO1xuXHRcdH1cblxuXHRcdHNldEZyb21DYXJ0ZXNpYW5Db29yZHMoeCwgeSwgeikge1xuXHRcdFx0dGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcblxuXHRcdFx0aWYgKHRoaXMucmFkaXVzID09PSAwKSB7XG5cdFx0XHRcdHRoaXMudGhldGEgPSAwO1xuXHRcdFx0XHR0aGlzLnBoaSA9IDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnRoZXRhID0gTWF0aC5hdGFuMih4LCB6KTtcblx0XHRcdFx0dGhpcy5waGkgPSBNYXRoLmFjb3MoY2xhbXAoeSAvIHRoaXMucmFkaXVzLCAtMSwgMSkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogUmVmOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DeWxpbmRyaWNhbF9jb29yZGluYXRlX3N5c3RlbVxuXHQgKi9cblx0Y2xhc3MgQ3lsaW5kcmljYWwge1xuXHRcdGNvbnN0cnVjdG9yKHJhZGl1cyA9IDEsIHRoZXRhID0gMCwgeSA9IDApIHtcblx0XHRcdHRoaXMucmFkaXVzID0gcmFkaXVzOyAvLyBkaXN0YW5jZSBmcm9tIHRoZSBvcmlnaW4gdG8gYSBwb2ludCBpbiB0aGUgeC16IHBsYW5lXG5cblx0XHRcdHRoaXMudGhldGEgPSB0aGV0YTsgLy8gY291bnRlcmNsb2Nrd2lzZSBhbmdsZSBpbiB0aGUgeC16IHBsYW5lIG1lYXN1cmVkIGluIHJhZGlhbnMgZnJvbSB0aGUgcG9zaXRpdmUgei1heGlzXG5cblx0XHRcdHRoaXMueSA9IHk7IC8vIGhlaWdodCBhYm92ZSB0aGUgeC16IHBsYW5lXG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldChyYWRpdXMsIHRoZXRhLCB5KSB7XG5cdFx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblx0XHRcdHRoaXMudGhldGEgPSB0aGV0YTtcblx0XHRcdHRoaXMueSA9IHk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb3B5KG90aGVyKSB7XG5cdFx0XHR0aGlzLnJhZGl1cyA9IG90aGVyLnJhZGl1cztcblx0XHRcdHRoaXMudGhldGEgPSBvdGhlci50aGV0YTtcblx0XHRcdHRoaXMueSA9IG90aGVyLnk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRzZXRGcm9tVmVjdG9yMyh2KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tQ2FydGVzaWFuQ29vcmRzKHYueCwgdi55LCB2LnopO1xuXHRcdH1cblxuXHRcdHNldEZyb21DYXJ0ZXNpYW5Db29yZHMoeCwgeSwgeikge1xuXHRcdFx0dGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoeCAqIHggKyB6ICogeik7XG5cdFx0XHR0aGlzLnRoZXRhID0gTWF0aC5hdGFuMih4LCB6KTtcblx0XHRcdHRoaXMueSA9IHk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG5cdFx0fVxuXG5cdH1cblxuXHRjb25zdCBfdmVjdG9yJDQgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjIoKTtcblxuXHRjbGFzcyBCb3gyIHtcblx0XHRjb25zdHJ1Y3RvcihtaW4gPSBuZXcgVmVjdG9yMigrSW5maW5pdHksICtJbmZpbml0eSksIG1heCA9IG5ldyBWZWN0b3IyKC1JbmZpbml0eSwgLUluZmluaXR5KSkge1xuXHRcdFx0dGhpcy5taW4gPSBtaW47XG5cdFx0XHR0aGlzLm1heCA9IG1heDtcblx0XHR9XG5cblx0XHRzZXQobWluLCBtYXgpIHtcblx0XHRcdHRoaXMubWluLmNvcHkobWluKTtcblx0XHRcdHRoaXMubWF4LmNvcHkobWF4KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNldEZyb21Qb2ludHMocG9pbnRzKSB7XG5cdFx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQocG9pbnRzW2ldKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0c2V0RnJvbUNlbnRlckFuZFNpemUoY2VudGVyLCBzaXplKSB7XG5cdFx0XHRjb25zdCBoYWxmU2l6ZSA9IF92ZWN0b3IkNC5jb3B5KHNpemUpLm11bHRpcGx5U2NhbGFyKDAuNSk7XG5cblx0XHRcdHRoaXMubWluLmNvcHkoY2VudGVyKS5zdWIoaGFsZlNpemUpO1xuXHRcdFx0dGhpcy5tYXguY29weShjZW50ZXIpLmFkZChoYWxmU2l6ZSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjbG9uZSgpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG5cdFx0fVxuXG5cdFx0Y29weShib3gpIHtcblx0XHRcdHRoaXMubWluLmNvcHkoYm94Lm1pbik7XG5cdFx0XHR0aGlzLm1heC5jb3B5KGJveC5tYXgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0bWFrZUVtcHR5KCkge1xuXHRcdFx0dGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSArSW5maW5pdHk7XG5cdFx0XHR0aGlzLm1heC54ID0gdGhpcy5tYXgueSA9IC1JbmZpbml0eTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlzRW1wdHkoKSB7XG5cdFx0XHQvLyB0aGlzIGlzIGEgbW9yZSByb2J1c3QgY2hlY2sgZm9yIGVtcHR5IHRoYW4gKCB2b2x1bWUgPD0gMCApIGJlY2F1c2Ugdm9sdW1lIGNhbiBnZXQgcG9zaXRpdmUgd2l0aCB0d28gbmVnYXRpdmUgYXhlc1xuXHRcdFx0cmV0dXJuIHRoaXMubWF4LnggPCB0aGlzLm1pbi54IHx8IHRoaXMubWF4LnkgPCB0aGlzLm1pbi55O1xuXHRcdH1cblxuXHRcdGdldENlbnRlcih0YXJnZXQpIHtcblx0XHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHRhcmdldC5zZXQoMCwgMCkgOiB0YXJnZXQuYWRkVmVjdG9ycyh0aGlzLm1pbiwgdGhpcy5tYXgpLm11bHRpcGx5U2NhbGFyKDAuNSk7XG5cdFx0fVxuXG5cdFx0Z2V0U2l6ZSh0YXJnZXQpIHtcblx0XHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHRhcmdldC5zZXQoMCwgMCkgOiB0YXJnZXQuc3ViVmVjdG9ycyh0aGlzLm1heCwgdGhpcy5taW4pO1xuXHRcdH1cblxuXHRcdGV4cGFuZEJ5UG9pbnQocG9pbnQpIHtcblx0XHRcdHRoaXMubWluLm1pbihwb2ludCk7XG5cdFx0XHR0aGlzLm1heC5tYXgocG9pbnQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZXhwYW5kQnlWZWN0b3IodmVjdG9yKSB7XG5cdFx0XHR0aGlzLm1pbi5zdWIodmVjdG9yKTtcblx0XHRcdHRoaXMubWF4LmFkZCh2ZWN0b3IpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0ZXhwYW5kQnlTY2FsYXIoc2NhbGFyKSB7XG5cdFx0XHR0aGlzLm1pbi5hZGRTY2FsYXIoLXNjYWxhcik7XG5cdFx0XHR0aGlzLm1heC5hZGRTY2FsYXIoc2NhbGFyKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcblx0XHRcdHJldHVybiBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fCBwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSA/IGZhbHNlIDogdHJ1ZTtcblx0XHR9XG5cblx0XHRjb250YWluc0JveChib3gpIHtcblx0XHRcdHJldHVybiB0aGlzLm1pbi54IDw9IGJveC5taW4ueCAmJiBib3gubWF4LnggPD0gdGhpcy5tYXgueCAmJiB0aGlzLm1pbi55IDw9IGJveC5taW4ueSAmJiBib3gubWF4LnkgPD0gdGhpcy5tYXgueTtcblx0XHR9XG5cblx0XHRnZXRQYXJhbWV0ZXIocG9pbnQsIHRhcmdldCkge1xuXHRcdFx0Ly8gVGhpcyBjYW4gcG90ZW50aWFsbHkgaGF2ZSBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBib3hcblx0XHRcdC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LnNldCgocG9pbnQueCAtIHRoaXMubWluLngpIC8gKHRoaXMubWF4LnggLSB0aGlzLm1pbi54KSwgKHBvaW50LnkgLSB0aGlzLm1pbi55KSAvICh0aGlzLm1heC55IC0gdGhpcy5taW4ueSkpO1xuXHRcdH1cblxuXHRcdGludGVyc2VjdHNCb3goYm94KSB7XG5cdFx0XHQvLyB1c2luZyA0IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9uc1xuXHRcdFx0cmV0dXJuIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fCBib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgPyBmYWxzZSA6IHRydWU7XG5cdFx0fVxuXG5cdFx0Y2xhbXBQb2ludChwb2ludCwgdGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkocG9pbnQpLmNsYW1wKHRoaXMubWluLCB0aGlzLm1heCk7XG5cdFx0fVxuXG5cdFx0ZGlzdGFuY2VUb1BvaW50KHBvaW50KSB7XG5cdFx0XHRjb25zdCBjbGFtcGVkUG9pbnQgPSBfdmVjdG9yJDQuY29weShwb2ludCkuY2xhbXAodGhpcy5taW4sIHRoaXMubWF4KTtcblxuXHRcdFx0cmV0dXJuIGNsYW1wZWRQb2ludC5zdWIocG9pbnQpLmxlbmd0aCgpO1xuXHRcdH1cblxuXHRcdGludGVyc2VjdChib3gpIHtcblx0XHRcdHRoaXMubWluLm1heChib3gubWluKTtcblx0XHRcdHRoaXMubWF4Lm1pbihib3gubWF4KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHVuaW9uKGJveCkge1xuXHRcdFx0dGhpcy5taW4ubWluKGJveC5taW4pO1xuXHRcdFx0dGhpcy5tYXgubWF4KGJveC5tYXgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dHJhbnNsYXRlKG9mZnNldCkge1xuXHRcdFx0dGhpcy5taW4uYWRkKG9mZnNldCk7XG5cdFx0XHR0aGlzLm1heC5hZGQob2Zmc2V0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGVxdWFscyhib3gpIHtcblx0XHRcdHJldHVybiBib3gubWluLmVxdWFscyh0aGlzLm1pbikgJiYgYm94Lm1heC5lcXVhbHModGhpcy5tYXgpO1xuXHRcdH1cblxuXHR9XG5cblx0Qm94Mi5wcm90b3R5cGUuaXNCb3gyID0gdHJ1ZTtcblxuXHRjb25zdCBfc3RhcnRQID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX3N0YXJ0RW5kID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y2xhc3MgTGluZTMge1xuXHRcdGNvbnN0cnVjdG9yKHN0YXJ0ID0gbmV3IFZlY3RvcjMoKSwgZW5kID0gbmV3IFZlY3RvcjMoKSkge1xuXHRcdFx0dGhpcy5zdGFydCA9IHN0YXJ0O1xuXHRcdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0fVxuXG5cdFx0c2V0KHN0YXJ0LCBlbmQpIHtcblx0XHRcdHRoaXMuc3RhcnQuY29weShzdGFydCk7XG5cdFx0XHR0aGlzLmVuZC5jb3B5KGVuZCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb3B5KGxpbmUpIHtcblx0XHRcdHRoaXMuc3RhcnQuY29weShsaW5lLnN0YXJ0KTtcblx0XHRcdHRoaXMuZW5kLmNvcHkobGluZS5lbmQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Z2V0Q2VudGVyKHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldC5hZGRWZWN0b3JzKHRoaXMuc3RhcnQsIHRoaXMuZW5kKS5tdWx0aXBseVNjYWxhcigwLjUpO1xuXHRcdH1cblxuXHRcdGRlbHRhKHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldC5zdWJWZWN0b3JzKHRoaXMuZW5kLCB0aGlzLnN0YXJ0KTtcblx0XHR9XG5cblx0XHRkaXN0YW5jZVNxKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUb1NxdWFyZWQodGhpcy5lbmQpO1xuXHRcdH1cblxuXHRcdGRpc3RhbmNlKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUbyh0aGlzLmVuZCk7XG5cdFx0fVxuXG5cdFx0YXQodCwgdGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kZWx0YSh0YXJnZXQpLm11bHRpcGx5U2NhbGFyKHQpLmFkZCh0aGlzLnN0YXJ0KTtcblx0XHR9XG5cblx0XHRjbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyKHBvaW50LCBjbGFtcFRvTGluZSkge1xuXHRcdFx0X3N0YXJ0UC5zdWJWZWN0b3JzKHBvaW50LCB0aGlzLnN0YXJ0KTtcblxuXHRcdFx0X3N0YXJ0RW5kLnN1YlZlY3RvcnModGhpcy5lbmQsIHRoaXMuc3RhcnQpO1xuXG5cdFx0XHRjb25zdCBzdGFydEVuZDIgPSBfc3RhcnRFbmQuZG90KF9zdGFydEVuZCk7XG5cblx0XHRcdGNvbnN0IHN0YXJ0RW5kX3N0YXJ0UCA9IF9zdGFydEVuZC5kb3QoX3N0YXJ0UCk7XG5cblx0XHRcdGxldCB0ID0gc3RhcnRFbmRfc3RhcnRQIC8gc3RhcnRFbmQyO1xuXG5cdFx0XHRpZiAoY2xhbXBUb0xpbmUpIHtcblx0XHRcdFx0dCA9IGNsYW1wKHQsIDAsIDEpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdDtcblx0XHR9XG5cblx0XHRjbG9zZXN0UG9pbnRUb1BvaW50KHBvaW50LCBjbGFtcFRvTGluZSwgdGFyZ2V0KSB7XG5cdFx0XHRjb25zdCB0ID0gdGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyKHBvaW50LCBjbGFtcFRvTGluZSk7XG5cdFx0XHRyZXR1cm4gdGhpcy5kZWx0YSh0YXJnZXQpLm11bHRpcGx5U2NhbGFyKHQpLmFkZCh0aGlzLnN0YXJ0KTtcblx0XHR9XG5cblx0XHRhcHBseU1hdHJpeDQobWF0cml4KSB7XG5cdFx0XHR0aGlzLnN0YXJ0LmFwcGx5TWF0cml4NChtYXRyaXgpO1xuXHRcdFx0dGhpcy5lbmQuYXBwbHlNYXRyaXg0KG1hdHJpeCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRlcXVhbHMobGluZSkge1xuXHRcdFx0cmV0dXJuIGxpbmUuc3RhcnQuZXF1YWxzKHRoaXMuc3RhcnQpICYmIGxpbmUuZW5kLmVxdWFscyh0aGlzLmVuZCk7XG5cdFx0fVxuXG5cdFx0Y2xvbmUoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpO1xuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgX3ZlY3RvciQzID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y2xhc3MgU3BvdExpZ2h0SGVscGVyIGV4dGVuZHMgT2JqZWN0M0Qge1xuXHRcdGNvbnN0cnVjdG9yKGxpZ2h0LCBjb2xvcikge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMubGlnaHQgPSBsaWdodDtcblx0XHRcdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblx0XHRcdHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XG5cdFx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHRcdHRoaXMuY29sb3IgPSBjb2xvcjtcblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHRjb25zdCBwb3NpdGlvbnMgPSBbMCwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMSwgMCwgMSwgMCwgMCwgMCwgLTEsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDEsIDAsIDAsIDAsIDAsIC0xLCAxXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGogPSAxLCBsID0gMzI7IGkgPCBsOyBpKyssIGorKykge1xuXHRcdFx0XHRjb25zdCBwMSA9IGkgLyBsICogTWF0aC5QSSAqIDI7XG5cdFx0XHRcdGNvbnN0IHAyID0gaiAvIGwgKiBNYXRoLlBJICogMjtcblx0XHRcdFx0cG9zaXRpb25zLnB1c2goTWF0aC5jb3MocDEpLCBNYXRoLnNpbihwMSksIDEsIE1hdGguY29zKHAyKSwgTWF0aC5zaW4ocDIpLCAxKTtcblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9ucywgMykpO1xuXHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0XHRmb2c6IGZhbHNlLFxuXHRcdFx0XHR0b25lTWFwcGVkOiBmYWxzZVxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmNvbmUgPSBuZXcgTGluZVNlZ21lbnRzKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG5cdFx0XHR0aGlzLmFkZCh0aGlzLmNvbmUpO1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9XG5cblx0XHRkaXNwb3NlKCkge1xuXHRcdFx0dGhpcy5jb25lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHRcdHRoaXMuY29uZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cdFx0fVxuXG5cdFx0dXBkYXRlKCkge1xuXHRcdFx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXHRcdFx0Y29uc3QgY29uZUxlbmd0aCA9IHRoaXMubGlnaHQuZGlzdGFuY2UgPyB0aGlzLmxpZ2h0LmRpc3RhbmNlIDogMTAwMDtcblx0XHRcdGNvbnN0IGNvbmVXaWR0aCA9IGNvbmVMZW5ndGggKiBNYXRoLnRhbih0aGlzLmxpZ2h0LmFuZ2xlKTtcblx0XHRcdHRoaXMuY29uZS5zY2FsZS5zZXQoY29uZVdpZHRoLCBjb25lV2lkdGgsIGNvbmVMZW5ndGgpO1xuXG5cdFx0XHRfdmVjdG9yJDMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkKTtcblxuXHRcdFx0dGhpcy5jb25lLmxvb2tBdChfdmVjdG9yJDMpO1xuXG5cdFx0XHRpZiAodGhpcy5jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5zZXQodGhpcy5jb2xvcik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3IuY29weSh0aGlzLmxpZ2h0LmNvbG9yKTtcblx0XHRcdH1cblx0XHR9XG5cblx0fVxuXG5cdGNvbnN0IF92ZWN0b3IkMiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9ib25lTWF0cml4ID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5cblx0Y29uc3QgX21hdHJpeFdvcmxkSW52ID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5cblx0Y2xhc3MgU2tlbGV0b25IZWxwZXIgZXh0ZW5kcyBMaW5lU2VnbWVudHMge1xuXHRcdGNvbnN0cnVjdG9yKG9iamVjdCkge1xuXHRcdFx0Y29uc3QgYm9uZXMgPSBnZXRCb25lTGlzdChvYmplY3QpO1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0XHRjb25zdCBjb2xvcnMgPSBbXTtcblx0XHRcdGNvbnN0IGNvbG9yMSA9IG5ldyBDb2xvcigwLCAwLCAxKTtcblx0XHRcdGNvbnN0IGNvbG9yMiA9IG5ldyBDb2xvcigwLCAxLCAwKTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBib25lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBib25lID0gYm9uZXNbaV07XG5cblx0XHRcdFx0aWYgKGJvbmUucGFyZW50ICYmIGJvbmUucGFyZW50LmlzQm9uZSkge1xuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goMCwgMCwgMCk7XG5cdFx0XHRcdFx0dmVydGljZXMucHVzaCgwLCAwLCAwKTtcblx0XHRcdFx0XHRjb2xvcnMucHVzaChjb2xvcjEuciwgY29sb3IxLmcsIGNvbG9yMS5iKTtcblx0XHRcdFx0XHRjb2xvcnMucHVzaChjb2xvcjIuciwgY29sb3IyLmcsIGNvbG9yMi5iKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShjb2xvcnMsIDMpKTtcblx0XHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKHtcblx0XHRcdFx0dmVydGV4Q29sb3JzOiB0cnVlLFxuXHRcdFx0XHRkZXB0aFRlc3Q6IGZhbHNlLFxuXHRcdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcblx0XHRcdFx0dG9uZU1hcHBlZDogZmFsc2UsXG5cdFx0XHRcdHRyYW5zcGFyZW50OiB0cnVlXG5cdFx0XHR9KTtcblx0XHRcdHN1cGVyKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnU2tlbGV0b25IZWxwZXInO1xuXHRcdFx0dGhpcy5pc1NrZWxldG9uSGVscGVyID0gdHJ1ZTtcblx0XHRcdHRoaXMucm9vdCA9IG9iamVjdDtcblx0XHRcdHRoaXMuYm9uZXMgPSBib25lcztcblx0XHRcdHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuXHRcdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dXBkYXRlTWF0cml4V29ybGQoZm9yY2UpIHtcblx0XHRcdGNvbnN0IGJvbmVzID0gdGhpcy5ib25lcztcblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuXG5cdFx0XHRfbWF0cml4V29ybGRJbnYuY29weSh0aGlzLnJvb3QubWF0cml4V29ybGQpLmludmVydCgpO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBib25lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBib25lID0gYm9uZXNbaV07XG5cblx0XHRcdFx0aWYgKGJvbmUucGFyZW50ICYmIGJvbmUucGFyZW50LmlzQm9uZSkge1xuXHRcdFx0XHRcdF9ib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoX21hdHJpeFdvcmxkSW52LCBib25lLm1hdHJpeFdvcmxkKTtcblxuXHRcdFx0XHRcdF92ZWN0b3IkMi5zZXRGcm9tTWF0cml4UG9zaXRpb24oX2JvbmVNYXRyaXgpO1xuXG5cdFx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKGosIF92ZWN0b3IkMi54LCBfdmVjdG9yJDIueSwgX3ZlY3RvciQyLnopO1xuXG5cdFx0XHRcdFx0X2JvbmVNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhfbWF0cml4V29ybGRJbnYsIGJvbmUucGFyZW50Lm1hdHJpeFdvcmxkKTtcblxuXHRcdFx0XHRcdF92ZWN0b3IkMi5zZXRGcm9tTWF0cml4UG9zaXRpb24oX2JvbmVNYXRyaXgpO1xuXG5cdFx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKGogKyAxLCBfdmVjdG9yJDIueCwgX3ZlY3RvciQyLnksIF92ZWN0b3IkMi56KTtcblx0XHRcdFx0XHRqICs9IDI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdHN1cGVyLnVwZGF0ZU1hdHJpeFdvcmxkKGZvcmNlKTtcblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldEJvbmVMaXN0KG9iamVjdCkge1xuXHRcdGNvbnN0IGJvbmVMaXN0ID0gW107XG5cblx0XHRpZiAob2JqZWN0ICYmIG9iamVjdC5pc0JvbmUpIHtcblx0XHRcdGJvbmVMaXN0LnB1c2gob2JqZWN0KTtcblx0XHR9XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG9iamVjdC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0Ym9uZUxpc3QucHVzaC5hcHBseShib25lTGlzdCwgZ2V0Qm9uZUxpc3Qob2JqZWN0LmNoaWxkcmVuW2ldKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJvbmVMaXN0O1xuXHR9XG5cblx0Y2xhc3MgUG9pbnRMaWdodEhlbHBlciBleHRlbmRzIE1lc2gge1xuXHRcdGNvbnN0cnVjdG9yKGxpZ2h0LCBzcGhlcmVTaXplLCBjb2xvcikge1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgU3BoZXJlR2VvbWV0cnkoc3BoZXJlU2l6ZSwgNCwgMik7XG5cdFx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7XG5cdFx0XHRcdHdpcmVmcmFtZTogdHJ1ZSxcblx0XHRcdFx0Zm9nOiBmYWxzZSxcblx0XHRcdFx0dG9uZU1hcHBlZDogZmFsc2Vcblx0XHRcdH0pO1xuXHRcdFx0c3VwZXIoZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHRcdHRoaXMubGlnaHQgPSBsaWdodDtcblx0XHRcdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblx0XHRcdHRoaXMuY29sb3IgPSBjb2xvcjtcblx0XHRcdHRoaXMudHlwZSA9ICdQb2ludExpZ2h0SGVscGVyJztcblx0XHRcdHRoaXMubWF0cml4ID0gdGhpcy5saWdodC5tYXRyaXhXb3JsZDtcblx0XHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdC8qXG5cdFx0XHQvLyBUT0RPOiBkZWxldGUgdGhpcyBjb21tZW50P1xuXHRcdFx0Y29uc3QgZGlzdGFuY2VHZW9tZXRyeSA9IG5ldyBUSFJFRS5JY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5KCAxLCAyICk7XG5cdFx0XHRjb25zdCBkaXN0YW5jZU1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBoZXhDb2xvciwgZm9nOiBmYWxzZSwgd2lyZWZyYW1lOiB0cnVlLCBvcGFjaXR5OiAwLjEsIHRyYW5zcGFyZW50OiB0cnVlIH0gKTtcblx0XHRcdHRoaXMubGlnaHRTcGhlcmUgPSBuZXcgVEhSRUUuTWVzaCggYnVsYkdlb21ldHJ5LCBidWxiTWF0ZXJpYWwgKTtcblx0XHRcdHRoaXMubGlnaHREaXN0YW5jZSA9IG5ldyBUSFJFRS5NZXNoKCBkaXN0YW5jZUdlb21ldHJ5LCBkaXN0YW5jZU1hdGVyaWFsICk7XG5cdFx0XHRjb25zdCBkID0gbGlnaHQuZGlzdGFuY2U7XG5cdFx0XHRpZiAoIGQgPT09IDAuMCApIHtcblx0XHRcdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubGlnaHREaXN0YW5jZS5zY2FsZS5zZXQoIGQsIGQsIGQgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuYWRkKCB0aGlzLmxpZ2h0RGlzdGFuY2UgKTtcblx0XHRcdCovXG5cdFx0fVxuXG5cdFx0ZGlzcG9zZSgpIHtcblx0XHRcdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdFx0dGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cdFx0fVxuXG5cdFx0dXBkYXRlKCkge1xuXHRcdFx0aWYgKHRoaXMuY29sb3IgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLm1hdGVyaWFsLmNvbG9yLnNldCh0aGlzLmNvbG9yKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubWF0ZXJpYWwuY29sb3IuY29weSh0aGlzLmxpZ2h0LmNvbG9yKTtcblx0XHRcdH1cblx0XHRcdC8qXG5cdFx0XHRjb25zdCBkID0gdGhpcy5saWdodC5kaXN0YW5jZTtcblx0XHRcdFx0aWYgKCBkID09PSAwLjAgKSB7XG5cdFx0XHRcdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IHRydWU7XG5cdFx0XHRcdHRoaXMubGlnaHREaXN0YW5jZS5zY2FsZS5zZXQoIGQsIGQsIGQgKTtcblx0XHRcdFx0fVxuXHRcdFx0Ki9cblxuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgX3ZlY3RvciQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX2NvbG9yMSA9IC8qQF9fUFVSRV9fKi9uZXcgQ29sb3IoKTtcblxuXHRjb25zdCBfY29sb3IyID0gLypAX19QVVJFX18qL25ldyBDb2xvcigpO1xuXG5cdGNsYXNzIEhlbWlzcGhlcmVMaWdodEhlbHBlciBleHRlbmRzIE9iamVjdDNEIHtcblx0XHRjb25zdHJ1Y3RvcihsaWdodCwgc2l6ZSwgY29sb3IpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XG5cdFx0XHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cdFx0XHR0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xuXHRcdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0XHR0aGlzLmNvbG9yID0gY29sb3I7XG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBPY3RhaGVkcm9uR2VvbWV0cnkoc2l6ZSk7XG5cdFx0XHRnZW9tZXRyeS5yb3RhdGVZKE1hdGguUEkgKiAwLjUpO1xuXHRcdFx0dGhpcy5tYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7XG5cdFx0XHRcdHdpcmVmcmFtZTogdHJ1ZSxcblx0XHRcdFx0Zm9nOiBmYWxzZSxcblx0XHRcdFx0dG9uZU1hcHBlZDogZmFsc2Vcblx0XHRcdH0pO1xuXHRcdFx0aWYgKHRoaXMuY29sb3IgPT09IHVuZGVmaW5lZCkgdGhpcy5tYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0cnVlO1xuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XG5cdFx0XHRjb25zdCBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9uLmNvdW50ICogMyk7XG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZShjb2xvcnMsIDMpKTtcblx0XHRcdHRoaXMuYWRkKG5ldyBNZXNoKGdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsKSk7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdH1cblxuXHRcdGRpc3Bvc2UoKSB7XG5cdFx0XHR0aGlzLmNoaWxkcmVuWzBdLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHRcdHRoaXMuY2hpbGRyZW5bMF0ubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHRcdH1cblxuXHRcdHVwZGF0ZSgpIHtcblx0XHRcdGNvbnN0IG1lc2ggPSB0aGlzLmNoaWxkcmVuWzBdO1xuXG5cdFx0XHRpZiAodGhpcy5jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMubWF0ZXJpYWwuY29sb3Iuc2V0KHRoaXMuY29sb3IpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgY29sb3JzID0gbWVzaC5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ2NvbG9yJyk7XG5cblx0XHRcdFx0X2NvbG9yMS5jb3B5KHRoaXMubGlnaHQuY29sb3IpO1xuXG5cdFx0XHRcdF9jb2xvcjIuY29weSh0aGlzLmxpZ2h0Lmdyb3VuZENvbG9yKTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGNvbG9ycy5jb3VudDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IGNvbG9yID0gaSA8IGwgLyAyID8gX2NvbG9yMSA6IF9jb2xvcjI7XG5cdFx0XHRcdFx0Y29sb3JzLnNldFhZWihpLCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbG9ycy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdG1lc2gubG9va0F0KF92ZWN0b3IkMS5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5saWdodC5tYXRyaXhXb3JsZCkubmVnYXRlKCkpO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgR3JpZEhlbHBlciBleHRlbmRzIExpbmVTZWdtZW50cyB7XG5cdFx0Y29uc3RydWN0b3Ioc2l6ZSA9IDEwLCBkaXZpc2lvbnMgPSAxMCwgY29sb3IxID0gMHg0NDQ0NDQsIGNvbG9yMiA9IDB4ODg4ODg4KSB7XG5cdFx0XHRjb2xvcjEgPSBuZXcgQ29sb3IoY29sb3IxKTtcblx0XHRcdGNvbG9yMiA9IG5ldyBDb2xvcihjb2xvcjIpO1xuXHRcdFx0Y29uc3QgY2VudGVyID0gZGl2aXNpb25zIC8gMjtcblx0XHRcdGNvbnN0IHN0ZXAgPSBzaXplIC8gZGl2aXNpb25zO1xuXHRcdFx0Y29uc3QgaGFsZlNpemUgPSBzaXplIC8gMjtcblx0XHRcdGNvbnN0IHZlcnRpY2VzID0gW10sXG5cdFx0XHRcdFx0XHRjb2xvcnMgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGogPSAwLCBrID0gLWhhbGZTaXplOyBpIDw9IGRpdmlzaW9uczsgaSsrLCBrICs9IHN0ZXApIHtcblx0XHRcdFx0dmVydGljZXMucHVzaCgtaGFsZlNpemUsIDAsIGssIGhhbGZTaXplLCAwLCBrKTtcblx0XHRcdFx0dmVydGljZXMucHVzaChrLCAwLCAtaGFsZlNpemUsIGssIDAsIGhhbGZTaXplKTtcblx0XHRcdFx0Y29uc3QgY29sb3IgPSBpID09PSBjZW50ZXIgPyBjb2xvcjEgOiBjb2xvcjI7XG5cdFx0XHRcdGNvbG9yLnRvQXJyYXkoY29sb3JzLCBqKTtcblx0XHRcdFx0aiArPSAzO1xuXHRcdFx0XHRjb2xvci50b0FycmF5KGNvbG9ycywgaik7XG5cdFx0XHRcdGogKz0gMztcblx0XHRcdFx0Y29sb3IudG9BcnJheShjb2xvcnMsIGopO1xuXHRcdFx0XHRqICs9IDM7XG5cdFx0XHRcdGNvbG9yLnRvQXJyYXkoY29sb3JzLCBqKTtcblx0XHRcdFx0aiArPSAzO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoY29sb3JzLCAzKSk7XG5cdFx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCh7XG5cdFx0XHRcdHZlcnRleENvbG9yczogdHJ1ZSxcblx0XHRcdFx0dG9uZU1hcHBlZDogZmFsc2Vcblx0XHRcdH0pO1xuXHRcdFx0c3VwZXIoZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHRcdHRoaXMudHlwZSA9ICdHcmlkSGVscGVyJztcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIFBvbGFyR3JpZEhlbHBlciBleHRlbmRzIExpbmVTZWdtZW50cyB7XG5cdFx0Y29uc3RydWN0b3IocmFkaXVzID0gMTAsIHJhZGlhbHMgPSAxNiwgY2lyY2xlcyA9IDgsIGRpdmlzaW9ucyA9IDY0LCBjb2xvcjEgPSAweDQ0NDQ0NCwgY29sb3IyID0gMHg4ODg4ODgpIHtcblx0XHRcdGNvbG9yMSA9IG5ldyBDb2xvcihjb2xvcjEpO1xuXHRcdFx0Y29sb3IyID0gbmV3IENvbG9yKGNvbG9yMik7XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0Y29uc3QgY29sb3JzID0gW107IC8vIGNyZWF0ZSB0aGUgcmFkaWFsc1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8PSByYWRpYWxzOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgdiA9IGkgLyByYWRpYWxzICogKE1hdGguUEkgKiAyKTtcblx0XHRcdFx0Y29uc3QgeCA9IE1hdGguc2luKHYpICogcmFkaXVzO1xuXHRcdFx0XHRjb25zdCB6ID0gTWF0aC5jb3ModikgKiByYWRpdXM7XG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goMCwgMCwgMCk7XG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goeCwgMCwgeik7XG5cdFx0XHRcdGNvbnN0IGNvbG9yID0gaSAmIDEgPyBjb2xvcjEgOiBjb2xvcjI7XG5cdFx0XHRcdGNvbG9ycy5wdXNoKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuXHRcdFx0XHRjb2xvcnMucHVzaChjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcblx0XHRcdH0gLy8gY3JlYXRlIHRoZSBjaXJjbGVzXG5cblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPD0gY2lyY2xlczsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGNvbG9yID0gaSAmIDEgPyBjb2xvcjEgOiBjb2xvcjI7XG5cdFx0XHRcdGNvbnN0IHIgPSByYWRpdXMgLSByYWRpdXMgLyBjaXJjbGVzICogaTtcblxuXHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGRpdmlzaW9uczsgaisrKSB7XG5cdFx0XHRcdFx0Ly8gZmlyc3QgdmVydGV4XG5cdFx0XHRcdFx0bGV0IHYgPSBqIC8gZGl2aXNpb25zICogKE1hdGguUEkgKiAyKTtcblx0XHRcdFx0XHRsZXQgeCA9IE1hdGguc2luKHYpICogcjtcblx0XHRcdFx0XHRsZXQgeiA9IE1hdGguY29zKHYpICogcjtcblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKHgsIDAsIHopO1xuXHRcdFx0XHRcdGNvbG9ycy5wdXNoKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpOyAvLyBzZWNvbmQgdmVydGV4XG5cblx0XHRcdFx0XHR2ID0gKGogKyAxKSAvIGRpdmlzaW9ucyAqIChNYXRoLlBJICogMik7XG5cdFx0XHRcdFx0eCA9IE1hdGguc2luKHYpICogcjtcblx0XHRcdFx0XHR6ID0gTWF0aC5jb3ModikgKiByO1xuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goeCwgMCwgeik7XG5cdFx0XHRcdFx0Y29sb3JzLnB1c2goY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0aWNlcywgMykpO1xuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKGNvbG9ycywgMykpO1xuXHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0XHR2ZXJ0ZXhDb2xvcnM6IHRydWUsXG5cdFx0XHRcdHRvbmVNYXBwZWQ6IGZhbHNlXG5cdFx0XHR9KTtcblx0XHRcdHN1cGVyKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnUG9sYXJHcmlkSGVscGVyJztcblx0XHR9XG5cblx0fVxuXG5cdGNvbnN0IF92MSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF92MiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF92MyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNsYXNzIERpcmVjdGlvbmFsTGlnaHRIZWxwZXIgZXh0ZW5kcyBPYmplY3QzRCB7XG5cdFx0Y29uc3RydWN0b3IobGlnaHQsIHNpemUsIGNvbG9yKSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy5saWdodCA9IGxpZ2h0O1xuXHRcdFx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXHRcdFx0dGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcblx0XHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5jb2xvciA9IGNvbG9yO1xuXHRcdFx0aWYgKHNpemUgPT09IHVuZGVmaW5lZCkgc2l6ZSA9IDE7XG5cdFx0XHRsZXQgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShbLXNpemUsIHNpemUsIDAsIHNpemUsIHNpemUsIDAsIHNpemUsIC1zaXplLCAwLCAtc2l6ZSwgLXNpemUsIDAsIC1zaXplLCBzaXplLCAwXSwgMykpO1xuXHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0XHRmb2c6IGZhbHNlLFxuXHRcdFx0XHR0b25lTWFwcGVkOiBmYWxzZVxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmxpZ2h0UGxhbmUgPSBuZXcgTGluZShnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuXHRcdFx0dGhpcy5hZGQodGhpcy5saWdodFBsYW5lKTtcblx0XHRcdGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoWzAsIDAsIDAsIDAsIDAsIDFdLCAzKSk7XG5cdFx0XHR0aGlzLnRhcmdldExpbmUgPSBuZXcgTGluZShnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuXHRcdFx0dGhpcy5hZGQodGhpcy50YXJnZXRMaW5lKTtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0fVxuXG5cdFx0ZGlzcG9zZSgpIHtcblx0XHRcdHRoaXMubGlnaHRQbGFuZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0XHR0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHRcdFx0dGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHRcdHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cdFx0fVxuXG5cdFx0dXBkYXRlKCkge1xuXHRcdFx0X3YxLnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkKTtcblxuXHRcdFx0X3YyLnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLmxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCk7XG5cblx0XHRcdF92My5zdWJWZWN0b3JzKF92MiwgX3YxKTtcblxuXHRcdFx0dGhpcy5saWdodFBsYW5lLmxvb2tBdChfdjIpO1xuXG5cdFx0XHRpZiAodGhpcy5jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5jb2xvci5zZXQodGhpcy5jb2xvcik7XG5cdFx0XHRcdHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5jb2xvci5zZXQodGhpcy5jb2xvcik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3IuY29weSh0aGlzLmxpZ2h0LmNvbG9yKTtcblx0XHRcdFx0dGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkodGhpcy5saWdodC5jb2xvcik7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudGFyZ2V0TGluZS5sb29rQXQoX3YyKTtcblx0XHRcdHRoaXMudGFyZ2V0TGluZS5zY2FsZS56ID0gX3YzLmxlbmd0aCgpO1xuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgX3ZlY3RvciA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF9jYW1lcmEgPSAvKkBfX1BVUkVfXyovbmV3IENhbWVyYSgpO1xuXHQvKipcblx0ICpcdC0gc2hvd3MgZnJ1c3R1bSwgbGluZSBvZiBzaWdodCBhbmQgdXAgb2YgdGhlIGNhbWVyYVxuXHQgKlx0LSBzdWl0YWJsZSBmb3IgZmFzdCB1cGRhdGVzXG5cdCAqIFx0LSBiYXNlZCBvbiBmcnVzdHVtIHZpc3VhbGl6YXRpb24gaW4gbGlnaHRnbC5qcyBzaGFkb3dtYXAgZXhhbXBsZVxuXHQgKlx0XHRodHRwOi8vZXZhbncuZ2l0aHViLmNvbS9saWdodGdsLmpzL3Rlc3RzL3NoYWRvd21hcC5odG1sXG5cdCAqL1xuXG5cblx0Y2xhc3MgQ2FtZXJhSGVscGVyIGV4dGVuZHMgTGluZVNlZ21lbnRzIHtcblx0XHRjb25zdHJ1Y3RvcihjYW1lcmEpIHtcblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCh7XG5cdFx0XHRcdGNvbG9yOiAweGZmZmZmZixcblx0XHRcdFx0dmVydGV4Q29sb3JzOiB0cnVlLFxuXHRcdFx0XHR0b25lTWFwcGVkOiBmYWxzZVxuXHRcdFx0fSk7XG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0Y29uc3QgY29sb3JzID0gW107XG5cdFx0XHRjb25zdCBwb2ludE1hcCA9IHt9OyAvLyBjb2xvcnNcblxuXHRcdFx0Y29uc3QgY29sb3JGcnVzdHVtID0gbmV3IENvbG9yKDB4ZmZhYTAwKTtcblx0XHRcdGNvbnN0IGNvbG9yQ29uZSA9IG5ldyBDb2xvcigweGZmMDAwMCk7XG5cdFx0XHRjb25zdCBjb2xvclVwID0gbmV3IENvbG9yKDB4MDBhYWZmKTtcblx0XHRcdGNvbnN0IGNvbG9yVGFyZ2V0ID0gbmV3IENvbG9yKDB4ZmZmZmZmKTtcblx0XHRcdGNvbnN0IGNvbG9yQ3Jvc3MgPSBuZXcgQ29sb3IoMHgzMzMzMzMpOyAvLyBuZWFyXG5cblx0XHRcdGFkZExpbmUoJ24xJywgJ24yJywgY29sb3JGcnVzdHVtKTtcblx0XHRcdGFkZExpbmUoJ24yJywgJ240JywgY29sb3JGcnVzdHVtKTtcblx0XHRcdGFkZExpbmUoJ240JywgJ24zJywgY29sb3JGcnVzdHVtKTtcblx0XHRcdGFkZExpbmUoJ24zJywgJ24xJywgY29sb3JGcnVzdHVtKTsgLy8gZmFyXG5cblx0XHRcdGFkZExpbmUoJ2YxJywgJ2YyJywgY29sb3JGcnVzdHVtKTtcblx0XHRcdGFkZExpbmUoJ2YyJywgJ2Y0JywgY29sb3JGcnVzdHVtKTtcblx0XHRcdGFkZExpbmUoJ2Y0JywgJ2YzJywgY29sb3JGcnVzdHVtKTtcblx0XHRcdGFkZExpbmUoJ2YzJywgJ2YxJywgY29sb3JGcnVzdHVtKTsgLy8gc2lkZXNcblxuXHRcdFx0YWRkTGluZSgnbjEnLCAnZjEnLCBjb2xvckZydXN0dW0pO1xuXHRcdFx0YWRkTGluZSgnbjInLCAnZjInLCBjb2xvckZydXN0dW0pO1xuXHRcdFx0YWRkTGluZSgnbjMnLCAnZjMnLCBjb2xvckZydXN0dW0pO1xuXHRcdFx0YWRkTGluZSgnbjQnLCAnZjQnLCBjb2xvckZydXN0dW0pOyAvLyBjb25lXG5cblx0XHRcdGFkZExpbmUoJ3AnLCAnbjEnLCBjb2xvckNvbmUpO1xuXHRcdFx0YWRkTGluZSgncCcsICduMicsIGNvbG9yQ29uZSk7XG5cdFx0XHRhZGRMaW5lKCdwJywgJ24zJywgY29sb3JDb25lKTtcblx0XHRcdGFkZExpbmUoJ3AnLCAnbjQnLCBjb2xvckNvbmUpOyAvLyB1cFxuXG5cdFx0XHRhZGRMaW5lKCd1MScsICd1MicsIGNvbG9yVXApO1xuXHRcdFx0YWRkTGluZSgndTInLCAndTMnLCBjb2xvclVwKTtcblx0XHRcdGFkZExpbmUoJ3UzJywgJ3UxJywgY29sb3JVcCk7IC8vIHRhcmdldFxuXG5cdFx0XHRhZGRMaW5lKCdjJywgJ3QnLCBjb2xvclRhcmdldCk7XG5cdFx0XHRhZGRMaW5lKCdwJywgJ2MnLCBjb2xvckNyb3NzKTsgLy8gY3Jvc3NcblxuXHRcdFx0YWRkTGluZSgnY24xJywgJ2NuMicsIGNvbG9yQ3Jvc3MpO1xuXHRcdFx0YWRkTGluZSgnY24zJywgJ2NuNCcsIGNvbG9yQ3Jvc3MpO1xuXHRcdFx0YWRkTGluZSgnY2YxJywgJ2NmMicsIGNvbG9yQ3Jvc3MpO1xuXHRcdFx0YWRkTGluZSgnY2YzJywgJ2NmNCcsIGNvbG9yQ3Jvc3MpO1xuXG5cdFx0XHRmdW5jdGlvbiBhZGRMaW5lKGEsIGIsIGNvbG9yKSB7XG5cdFx0XHRcdGFkZFBvaW50KGEsIGNvbG9yKTtcblx0XHRcdFx0YWRkUG9pbnQoYiwgY29sb3IpO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBhZGRQb2ludChpZCwgY29sb3IpIHtcblx0XHRcdFx0dmVydGljZXMucHVzaCgwLCAwLCAwKTtcblx0XHRcdFx0Y29sb3JzLnB1c2goY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG5cblx0XHRcdFx0aWYgKHBvaW50TWFwW2lkXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cG9pbnRNYXBbaWRdID0gW107XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwb2ludE1hcFtpZF0ucHVzaCh2ZXJ0aWNlcy5sZW5ndGggLyAzIC0gMSk7XG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0aWNlcywgMykpO1xuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKGNvbG9ycywgMykpO1xuXHRcdFx0c3VwZXIoZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHRcdHRoaXMudHlwZSA9ICdDYW1lcmFIZWxwZXInO1xuXHRcdFx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XG5cdFx0XHRpZiAodGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCkgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXHRcdFx0dGhpcy5tYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGQ7XG5cdFx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHRcdHRoaXMucG9pbnRNYXAgPSBwb2ludE1hcDtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0fVxuXG5cdFx0dXBkYXRlKCkge1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdFx0Y29uc3QgcG9pbnRNYXAgPSB0aGlzLnBvaW50TWFwO1xuXHRcdFx0Y29uc3QgdyA9IDEsXG5cdFx0XHRcdFx0XHRoID0gMTsgLy8gd2UgbmVlZCBqdXN0IGNhbWVyYSBwcm9qZWN0aW9uIG1hdHJpeCBpbnZlcnNlXG5cdFx0XHQvLyB3b3JsZCBtYXRyaXggbXVzdCBiZSBpZGVudGl0eVxuXG5cdFx0XHRfY2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlLmNvcHkodGhpcy5jYW1lcmEucHJvamVjdGlvbk1hdHJpeEludmVyc2UpOyAvLyBjZW50ZXIgLyB0YXJnZXRcblxuXG5cdFx0XHRzZXRQb2ludCgnYycsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgMCwgLTEpO1xuXHRcdFx0c2V0UG9pbnQoJ3QnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIDAsIDAsIDEpOyAvLyBuZWFyXG5cblx0XHRcdHNldFBvaW50KCduMScsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgLXcsIC1oLCAtMSk7XG5cdFx0XHRzZXRQb2ludCgnbjInLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIHcsIC1oLCAtMSk7XG5cdFx0XHRzZXRQb2ludCgnbjMnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIC13LCBoLCAtMSk7XG5cdFx0XHRzZXRQb2ludCgnbjQnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIHcsIGgsIC0xKTsgLy8gZmFyXG5cblx0XHRcdHNldFBvaW50KCdmMScsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgLXcsIC1oLCAxKTtcblx0XHRcdHNldFBvaW50KCdmMicsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgdywgLWgsIDEpO1xuXHRcdFx0c2V0UG9pbnQoJ2YzJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAtdywgaCwgMSk7XG5cdFx0XHRzZXRQb2ludCgnZjQnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIHcsIGgsIDEpOyAvLyB1cFxuXG5cdFx0XHRzZXRQb2ludCgndTEnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIHcgKiAwLjcsIGggKiAxLjEsIC0xKTtcblx0XHRcdHNldFBvaW50KCd1MicsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgLXcgKiAwLjcsIGggKiAxLjEsIC0xKTtcblx0XHRcdHNldFBvaW50KCd1MycsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgaCAqIDIsIC0xKTsgLy8gY3Jvc3NcblxuXHRcdFx0c2V0UG9pbnQoJ2NmMScsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgLXcsIDAsIDEpO1xuXHRcdFx0c2V0UG9pbnQoJ2NmMicsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgdywgMCwgMSk7XG5cdFx0XHRzZXRQb2ludCgnY2YzJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAwLCAtaCwgMSk7XG5cdFx0XHRzZXRQb2ludCgnY2Y0JywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAwLCBoLCAxKTtcblx0XHRcdHNldFBvaW50KCdjbjEnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIC13LCAwLCAtMSk7XG5cdFx0XHRzZXRQb2ludCgnY24yJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCB3LCAwLCAtMSk7XG5cdFx0XHRzZXRQb2ludCgnY24zJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAwLCAtaCwgLTEpO1xuXHRcdFx0c2V0UG9pbnQoJ2NuNCcsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgaCwgLTEpO1xuXHRcdFx0Z2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRkaXNwb3NlKCkge1xuXHRcdFx0dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0XHR0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldFBvaW50KHBvaW50LCBwb2ludE1hcCwgZ2VvbWV0cnksIGNhbWVyYSwgeCwgeSwgeikge1xuXHRcdF92ZWN0b3Iuc2V0KHgsIHksIHopLnVucHJvamVjdChjYW1lcmEpO1xuXG5cdFx0Y29uc3QgcG9pbnRzID0gcG9pbnRNYXBbcG9pbnRdO1xuXG5cdFx0aWYgKHBvaW50cyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHBvc2l0aW9uLnNldFhZWihwb2ludHNbaV0sIF92ZWN0b3IueCwgX3ZlY3Rvci55LCBfdmVjdG9yLnopO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGNvbnN0IF9ib3ggPSAvKkBfX1BVUkVfXyovbmV3IEJveDMoKTtcblxuXHRjbGFzcyBCb3hIZWxwZXIgZXh0ZW5kcyBMaW5lU2VnbWVudHMge1xuXHRcdGNvbnN0cnVjdG9yKG9iamVjdCwgY29sb3IgPSAweGZmZmYwMCkge1xuXHRcdFx0Y29uc3QgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShbMCwgMSwgMSwgMiwgMiwgMywgMywgMCwgNCwgNSwgNSwgNiwgNiwgNywgNywgNCwgMCwgNCwgMSwgNSwgMiwgNiwgMywgN10pO1xuXHRcdFx0Y29uc3QgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSg4ICogMyk7XG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0Z2VvbWV0cnkuc2V0SW5kZXgobmV3IEJ1ZmZlckF0dHJpYnV0ZShpbmRpY2VzLCAxKSk7XG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbnMsIDMpKTtcblx0XHRcdHN1cGVyKGdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0XHRjb2xvcjogY29sb3IsXG5cdFx0XHRcdHRvbmVNYXBwZWQ6IGZhbHNlXG5cdFx0XHR9KSk7XG5cdFx0XHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblx0XHRcdHRoaXMudHlwZSA9ICdCb3hIZWxwZXInO1xuXHRcdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdH1cblxuXHRcdHVwZGF0ZShvYmplY3QpIHtcblx0XHRcdGlmIChvYmplY3QgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJveEhlbHBlcjogLnVwZGF0ZSgpIGhhcyBubyBsb25nZXIgYXJndW1lbnRzLicpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5vYmplY3QgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRfYm94LnNldEZyb21PYmplY3QodGhpcy5vYmplY3QpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoX2JveC5pc0VtcHR5KCkpIHJldHVybjtcblx0XHRcdGNvbnN0IG1pbiA9IF9ib3gubWluO1xuXHRcdFx0Y29uc3QgbWF4ID0gX2JveC5tYXg7XG5cdFx0XHQvKlxuXHRcdFx0XHQ1X19fXzRcblx0XHRcdDEvX19fMC98XG5cdFx0XHR8IDZfX3xfN1xuXHRcdFx0Mi9fX18zL1xuXHRcdFx0XHQwOiBtYXgueCwgbWF4LnksIG1heC56XG5cdFx0XHQxOiBtaW4ueCwgbWF4LnksIG1heC56XG5cdFx0XHQyOiBtaW4ueCwgbWluLnksIG1heC56XG5cdFx0XHQzOiBtYXgueCwgbWluLnksIG1heC56XG5cdFx0XHQ0OiBtYXgueCwgbWF4LnksIG1pbi56XG5cdFx0XHQ1OiBtaW4ueCwgbWF4LnksIG1pbi56XG5cdFx0XHQ2OiBtaW4ueCwgbWluLnksIG1pbi56XG5cdFx0XHQ3OiBtYXgueCwgbWluLnksIG1pbi56XG5cdFx0XHQqL1xuXG5cdFx0XHRjb25zdCBwb3NpdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdGNvbnN0IGFycmF5ID0gcG9zaXRpb24uYXJyYXk7XG5cdFx0XHRhcnJheVswXSA9IG1heC54O1xuXHRcdFx0YXJyYXlbMV0gPSBtYXgueTtcblx0XHRcdGFycmF5WzJdID0gbWF4Lno7XG5cdFx0XHRhcnJheVszXSA9IG1pbi54O1xuXHRcdFx0YXJyYXlbNF0gPSBtYXgueTtcblx0XHRcdGFycmF5WzVdID0gbWF4Lno7XG5cdFx0XHRhcnJheVs2XSA9IG1pbi54O1xuXHRcdFx0YXJyYXlbN10gPSBtaW4ueTtcblx0XHRcdGFycmF5WzhdID0gbWF4Lno7XG5cdFx0XHRhcnJheVs5XSA9IG1heC54O1xuXHRcdFx0YXJyYXlbMTBdID0gbWluLnk7XG5cdFx0XHRhcnJheVsxMV0gPSBtYXguejtcblx0XHRcdGFycmF5WzEyXSA9IG1heC54O1xuXHRcdFx0YXJyYXlbMTNdID0gbWF4Lnk7XG5cdFx0XHRhcnJheVsxNF0gPSBtaW4uejtcblx0XHRcdGFycmF5WzE1XSA9IG1pbi54O1xuXHRcdFx0YXJyYXlbMTZdID0gbWF4Lnk7XG5cdFx0XHRhcnJheVsxN10gPSBtaW4uejtcblx0XHRcdGFycmF5WzE4XSA9IG1pbi54O1xuXHRcdFx0YXJyYXlbMTldID0gbWluLnk7XG5cdFx0XHRhcnJheVsyMF0gPSBtaW4uejtcblx0XHRcdGFycmF5WzIxXSA9IG1heC54O1xuXHRcdFx0YXJyYXlbMjJdID0gbWluLnk7XG5cdFx0XHRhcnJheVsyM10gPSBtaW4uejtcblx0XHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdHRoaXMuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cdFx0fVxuXG5cdFx0c2V0RnJvbU9iamVjdChvYmplY3QpIHtcblx0XHRcdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNvcHkoc291cmNlKSB7XG5cdFx0XHRMaW5lU2VnbWVudHMucHJvdG90eXBlLmNvcHkuY2FsbCh0aGlzLCBzb3VyY2UpO1xuXHRcdFx0dGhpcy5vYmplY3QgPSBzb3VyY2Uub2JqZWN0O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBCb3gzSGVscGVyIGV4dGVuZHMgTGluZVNlZ21lbnRzIHtcblx0XHRjb25zdHJ1Y3Rvcihib3gsIGNvbG9yID0gMHhmZmZmMDApIHtcblx0XHRcdGNvbnN0IGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDEsIDEsIDIsIDIsIDMsIDMsIDAsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDQsIDAsIDQsIDEsIDUsIDIsIDYsIDMsIDddKTtcblx0XHRcdGNvbnN0IHBvc2l0aW9ucyA9IFsxLCAxLCAxLCAtMSwgMSwgMSwgLTEsIC0xLCAxLCAxLCAtMSwgMSwgMSwgMSwgLTEsIC0xLCAxLCAtMSwgLTEsIC0xLCAtMSwgMSwgLTEsIC0xXTtcblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHRnZW9tZXRyeS5zZXRJbmRleChuZXcgQnVmZmVyQXR0cmlidXRlKGluZGljZXMsIDEpKTtcblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbnMsIDMpKTtcblx0XHRcdHN1cGVyKGdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0XHRjb2xvcjogY29sb3IsXG5cdFx0XHRcdHRvbmVNYXBwZWQ6IGZhbHNlXG5cdFx0XHR9KSk7XG5cdFx0XHR0aGlzLmJveCA9IGJveDtcblx0XHRcdHRoaXMudHlwZSA9ICdCb3gzSGVscGVyJztcblx0XHRcdHRoaXMuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cdFx0fVxuXG5cdFx0dXBkYXRlTWF0cml4V29ybGQoZm9yY2UpIHtcblx0XHRcdGNvbnN0IGJveCA9IHRoaXMuYm94O1xuXHRcdFx0aWYgKGJveC5pc0VtcHR5KCkpIHJldHVybjtcblx0XHRcdGJveC5nZXRDZW50ZXIodGhpcy5wb3NpdGlvbik7XG5cdFx0XHRib3guZ2V0U2l6ZSh0aGlzLnNjYWxlKTtcblx0XHRcdHRoaXMuc2NhbGUubXVsdGlwbHlTY2FsYXIoMC41KTtcblx0XHRcdHN1cGVyLnVwZGF0ZU1hdHJpeFdvcmxkKGZvcmNlKTtcblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIFBsYW5lSGVscGVyIGV4dGVuZHMgTGluZSB7XG5cdFx0Y29uc3RydWN0b3IocGxhbmUsIHNpemUgPSAxLCBoZXggPSAweGZmZmYwMCkge1xuXHRcdFx0Y29uc3QgY29sb3IgPSBoZXg7XG5cdFx0XHRjb25zdCBwb3NpdGlvbnMgPSBbMSwgLTEsIDEsIC0xLCAxLCAxLCAtMSwgLTEsIDEsIDEsIDEsIDEsIC0xLCAxLCAxLCAtMSwgLTEsIDEsIDEsIC0xLCAxLCAxLCAxLCAxLCAwLCAwLCAxLCAwLCAwLCAwXTtcblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25zLCAzKSk7XG5cdFx0XHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblx0XHRcdHN1cGVyKGdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0XHRjb2xvcjogY29sb3IsXG5cdFx0XHRcdHRvbmVNYXBwZWQ6IGZhbHNlXG5cdFx0XHR9KSk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnUGxhbmVIZWxwZXInO1xuXHRcdFx0dGhpcy5wbGFuZSA9IHBsYW5lO1xuXHRcdFx0dGhpcy5zaXplID0gc2l6ZTtcblx0XHRcdGNvbnN0IHBvc2l0aW9uczIgPSBbMSwgMSwgMSwgLTEsIDEsIDEsIC0xLCAtMSwgMSwgMSwgMSwgMSwgLTEsIC0xLCAxLCAxLCAtMSwgMV07XG5cdFx0XHRjb25zdCBnZW9tZXRyeTIgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRcdGdlb21ldHJ5Mi5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25zMiwgMykpO1xuXHRcdFx0Z2VvbWV0cnkyLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXHRcdFx0dGhpcy5hZGQobmV3IE1lc2goZ2VvbWV0cnkyLCBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0XHRjb2xvcjogY29sb3IsXG5cdFx0XHRcdG9wYWNpdHk6IDAuMixcblx0XHRcdFx0dHJhbnNwYXJlbnQ6IHRydWUsXG5cdFx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlLFxuXHRcdFx0XHR0b25lTWFwcGVkOiBmYWxzZVxuXHRcdFx0fSkpKTtcblx0XHR9XG5cblx0XHR1cGRhdGVNYXRyaXhXb3JsZChmb3JjZSkge1xuXHRcdFx0bGV0IHNjYWxlID0gLXRoaXMucGxhbmUuY29uc3RhbnQ7XG5cdFx0XHRpZiAoTWF0aC5hYnMoc2NhbGUpIDwgMWUtOCkgc2NhbGUgPSAxZS04OyAvLyBzaWduIGRvZXMgbm90IG1hdHRlclxuXG5cdFx0XHR0aGlzLnNjYWxlLnNldCgwLjUgKiB0aGlzLnNpemUsIDAuNSAqIHRoaXMuc2l6ZSwgc2NhbGUpO1xuXHRcdFx0dGhpcy5jaGlsZHJlblswXS5tYXRlcmlhbC5zaWRlID0gc2NhbGUgPCAwID8gQmFja1NpZGUgOiBGcm9udFNpZGU7IC8vIHJlbmRlcmVyIGZsaXBzIHNpZGUgd2hlbiBkZXRlcm1pbmFudCA8IDA7IGZsaXBwaW5nIG5vdCB3YW50ZWQgaGVyZVxuXG5cdFx0XHR0aGlzLmxvb2tBdCh0aGlzLnBsYW5lLm5vcm1hbCk7XG5cdFx0XHRzdXBlci51cGRhdGVNYXRyaXhXb3JsZChmb3JjZSk7XG5cdFx0fVxuXG5cdH1cblxuXHRjb25zdCBfYXhpcyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG5cdGxldCBfbGluZUdlb21ldHJ5LCBfY29uZUdlb21ldHJ5O1xuXG5cdGNsYXNzIEFycm93SGVscGVyIGV4dGVuZHMgT2JqZWN0M0Qge1xuXHRcdC8vIGRpciBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblx0XHRjb25zdHJ1Y3RvcihkaXIgPSBuZXcgVmVjdG9yMygwLCAwLCAxKSwgb3JpZ2luID0gbmV3IFZlY3RvcjMoMCwgMCwgMCksIGxlbmd0aCA9IDEsIGNvbG9yID0gMHhmZmZmMDAsIGhlYWRMZW5ndGggPSBsZW5ndGggKiAwLjIsIGhlYWRXaWR0aCA9IGhlYWRMZW5ndGggKiAwLjIpIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnQXJyb3dIZWxwZXInO1xuXG5cdFx0XHRpZiAoX2xpbmVHZW9tZXRyeSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdF9saW5lR2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdFx0XHRfbGluZUdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShbMCwgMCwgMCwgMCwgMSwgMF0sIDMpKTtcblxuXHRcdFx0XHRfY29uZUdlb21ldHJ5ID0gbmV3IEN5bGluZGVyR2VvbWV0cnkoMCwgMC41LCAxLCA1LCAxKTtcblxuXHRcdFx0XHRfY29uZUdlb21ldHJ5LnRyYW5zbGF0ZSgwLCAtMC41LCAwKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5wb3NpdGlvbi5jb3B5KG9yaWdpbik7XG5cdFx0XHR0aGlzLmxpbmUgPSBuZXcgTGluZShfbGluZUdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0XHRjb2xvcjogY29sb3IsXG5cdFx0XHRcdHRvbmVNYXBwZWQ6IGZhbHNlXG5cdFx0XHR9KSk7XG5cdFx0XHR0aGlzLmxpbmUubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5hZGQodGhpcy5saW5lKTtcblx0XHRcdHRoaXMuY29uZSA9IG5ldyBNZXNoKF9jb25lR2VvbWV0cnksIG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7XG5cdFx0XHRcdGNvbG9yOiBjb2xvcixcblx0XHRcdFx0dG9uZU1hcHBlZDogZmFsc2Vcblx0XHRcdH0pKTtcblx0XHRcdHRoaXMuY29uZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0XHR0aGlzLmFkZCh0aGlzLmNvbmUpO1xuXHRcdFx0dGhpcy5zZXREaXJlY3Rpb24oZGlyKTtcblx0XHRcdHRoaXMuc2V0TGVuZ3RoKGxlbmd0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoKTtcblx0XHR9XG5cblx0XHRzZXREaXJlY3Rpb24oZGlyKSB7XG5cdFx0XHQvLyBkaXIgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cdFx0XHRpZiAoZGlyLnkgPiAwLjk5OTk5KSB7XG5cdFx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXQoMCwgMCwgMCwgMSk7XG5cdFx0XHR9IGVsc2UgaWYgKGRpci55IDwgLTAuOTk5OTkpIHtcblx0XHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldCgxLCAwLCAwLCAwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF9heGlzLnNldChkaXIueiwgMCwgLWRpci54KS5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHRjb25zdCByYWRpYW5zID0gTWF0aC5hY29zKGRpci55KTtcblx0XHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoX2F4aXMsIHJhZGlhbnMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNldExlbmd0aChsZW5ndGgsIGhlYWRMZW5ndGggPSBsZW5ndGggKiAwLjIsIGhlYWRXaWR0aCA9IGhlYWRMZW5ndGggKiAwLjIpIHtcblx0XHRcdHRoaXMubGluZS5zY2FsZS5zZXQoMSwgTWF0aC5tYXgoMC4wMDAxLCBsZW5ndGggLSBoZWFkTGVuZ3RoKSwgMSk7IC8vIHNlZSAjMTc0NThcblxuXHRcdFx0dGhpcy5saW5lLnVwZGF0ZU1hdHJpeCgpO1xuXHRcdFx0dGhpcy5jb25lLnNjYWxlLnNldChoZWFkV2lkdGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCk7XG5cdFx0XHR0aGlzLmNvbmUucG9zaXRpb24ueSA9IGxlbmd0aDtcblx0XHRcdHRoaXMuY29uZS51cGRhdGVNYXRyaXgoKTtcblx0XHR9XG5cblx0XHRzZXRDb2xvcihjb2xvcikge1xuXHRcdFx0dGhpcy5saW5lLm1hdGVyaWFsLmNvbG9yLnNldChjb2xvcik7XG5cdFx0XHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3Iuc2V0KGNvbG9yKTtcblx0XHR9XG5cblx0XHRjb3B5KHNvdXJjZSkge1xuXHRcdFx0c3VwZXIuY29weShzb3VyY2UsIGZhbHNlKTtcblx0XHRcdHRoaXMubGluZS5jb3B5KHNvdXJjZS5saW5lKTtcblx0XHRcdHRoaXMuY29uZS5jb3B5KHNvdXJjZS5jb25lKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgQXhlc0hlbHBlciBleHRlbmRzIExpbmVTZWdtZW50cyB7XG5cdFx0Y29uc3RydWN0b3Ioc2l6ZSA9IDEpIHtcblx0XHRcdGNvbnN0IHZlcnRpY2VzID0gWzAsIDAsIDAsIHNpemUsIDAsIDAsIDAsIDAsIDAsIDAsIHNpemUsIDAsIDAsIDAsIDAsIDAsIDAsIHNpemVdO1xuXHRcdFx0Y29uc3QgY29sb3JzID0gWzEsIDAsIDAsIDEsIDAuNiwgMCwgMCwgMSwgMCwgMC42LCAxLCAwLCAwLCAwLCAxLCAwLCAwLjYsIDFdO1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0aWNlcywgMykpO1xuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKGNvbG9ycywgMykpO1xuXHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0XHR2ZXJ0ZXhDb2xvcnM6IHRydWUsXG5cdFx0XHRcdHRvbmVNYXBwZWQ6IGZhbHNlXG5cdFx0XHR9KTtcblx0XHRcdHN1cGVyKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG5cdFx0XHR0aGlzLnR5cGUgPSAnQXhlc0hlbHBlcic7XG5cdFx0fVxuXG5cdFx0c2V0Q29sb3JzKHhBeGlzQ29sb3IsIHlBeGlzQ29sb3IsIHpBeGlzQ29sb3IpIHtcblx0XHRcdGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKCk7XG5cdFx0XHRjb25zdCBhcnJheSA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5hcnJheTtcblx0XHRcdGNvbG9yLnNldCh4QXhpc0NvbG9yKTtcblx0XHRcdGNvbG9yLnRvQXJyYXkoYXJyYXksIDApO1xuXHRcdFx0Y29sb3IudG9BcnJheShhcnJheSwgMyk7XG5cdFx0XHRjb2xvci5zZXQoeUF4aXNDb2xvcik7XG5cdFx0XHRjb2xvci50b0FycmF5KGFycmF5LCA2KTtcblx0XHRcdGNvbG9yLnRvQXJyYXkoYXJyYXksIDkpO1xuXHRcdFx0Y29sb3Iuc2V0KHpBeGlzQ29sb3IpO1xuXHRcdFx0Y29sb3IudG9BcnJheShhcnJheSwgMTIpO1xuXHRcdFx0Y29sb3IudG9BcnJheShhcnJheSwgMTUpO1xuXHRcdFx0dGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGRpc3Bvc2UoKSB7XG5cdFx0XHR0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgU2hhcGVQYXRoIHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHRoaXMudHlwZSA9ICdTaGFwZVBhdGgnO1xuXHRcdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvcigpO1xuXHRcdFx0dGhpcy5zdWJQYXRocyA9IFtdO1xuXHRcdFx0dGhpcy5jdXJyZW50UGF0aCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0bW92ZVRvKHgsIHkpIHtcblx0XHRcdHRoaXMuY3VycmVudFBhdGggPSBuZXcgUGF0aCgpO1xuXHRcdFx0dGhpcy5zdWJQYXRocy5wdXNoKHRoaXMuY3VycmVudFBhdGgpO1xuXHRcdFx0dGhpcy5jdXJyZW50UGF0aC5tb3ZlVG8oeCwgeSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRsaW5lVG8oeCwgeSkge1xuXHRcdFx0dGhpcy5jdXJyZW50UGF0aC5saW5lVG8oeCwgeSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRxdWFkcmF0aWNDdXJ2ZVRvKGFDUHgsIGFDUHksIGFYLCBhWSkge1xuXHRcdFx0dGhpcy5jdXJyZW50UGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKGFDUHgsIGFDUHksIGFYLCBhWSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRiZXppZXJDdXJ2ZVRvKGFDUDF4LCBhQ1AxeSwgYUNQMngsIGFDUDJ5LCBhWCwgYVkpIHtcblx0XHRcdHRoaXMuY3VycmVudFBhdGguYmV6aWVyQ3VydmVUbyhhQ1AxeCwgYUNQMXksIGFDUDJ4LCBhQ1AyeSwgYVgsIGFZKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHNwbGluZVRocnUocHRzKSB7XG5cdFx0XHR0aGlzLmN1cnJlbnRQYXRoLnNwbGluZVRocnUocHRzKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRvU2hhcGVzKGlzQ0NXLCBub0hvbGVzKSB7XG5cdFx0XHRmdW5jdGlvbiB0b1NoYXBlc05vSG9sZXMoaW5TdWJwYXRocykge1xuXHRcdFx0XHRjb25zdCBzaGFwZXMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGluU3VicGF0aHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgdG1wUGF0aCA9IGluU3VicGF0aHNbaV07XG5cdFx0XHRcdFx0Y29uc3QgdG1wU2hhcGUgPSBuZXcgU2hhcGUoKTtcblx0XHRcdFx0XHR0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcblx0XHRcdFx0XHRzaGFwZXMucHVzaCh0bXBTaGFwZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gc2hhcGVzO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBpc1BvaW50SW5zaWRlUG9seWdvbihpblB0LCBpblBvbHlnb24pIHtcblx0XHRcdFx0Y29uc3QgcG9seUxlbiA9IGluUG9seWdvbi5sZW5ndGg7IC8vIGluUHQgb24gcG9seWdvbiBjb250b3VyID0+IGltbWVkaWF0ZSBzdWNjZXNzXHRcdG9yXG5cdFx0XHRcdC8vIHRvZ2dsaW5nIG9mIGluc2lkZS9vdXRzaWRlIGF0IGV2ZXJ5IHNpbmdsZSEgaW50ZXJzZWN0aW9uIHBvaW50IG9mIGFuIGVkZ2Vcblx0XHRcdFx0Ly9cdHdpdGggdGhlIGhvcml6b250YWwgbGluZSB0aHJvdWdoIGluUHQsIGxlZnQgb2YgaW5QdFxuXHRcdFx0XHQvL1x0bm90IGNvdW50aW5nIGxvd2VyWSBlbmRwb2ludHMgb2YgZWRnZXMgYW5kIHdob2xlIGVkZ2VzIG9uIHRoYXQgbGluZVxuXG5cdFx0XHRcdGxldCBpbnNpZGUgPSBmYWxzZTtcblxuXHRcdFx0XHRmb3IgKGxldCBwID0gcG9seUxlbiAtIDEsIHEgPSAwOyBxIDwgcG9seUxlbjsgcCA9IHErKykge1xuXHRcdFx0XHRcdGxldCBlZGdlTG93UHQgPSBpblBvbHlnb25bcF07XG5cdFx0XHRcdFx0bGV0IGVkZ2VIaWdoUHQgPSBpblBvbHlnb25bcV07XG5cdFx0XHRcdFx0bGV0IGVkZ2VEeCA9IGVkZ2VIaWdoUHQueCAtIGVkZ2VMb3dQdC54O1xuXHRcdFx0XHRcdGxldCBlZGdlRHkgPSBlZGdlSGlnaFB0LnkgLSBlZGdlTG93UHQueTtcblxuXHRcdFx0XHRcdGlmIChNYXRoLmFicyhlZGdlRHkpID4gTnVtYmVyLkVQU0lMT04pIHtcblx0XHRcdFx0XHRcdC8vIG5vdCBwYXJhbGxlbFxuXHRcdFx0XHRcdFx0aWYgKGVkZ2VEeSA8IDApIHtcblx0XHRcdFx0XHRcdFx0ZWRnZUxvd1B0ID0gaW5Qb2x5Z29uW3FdO1xuXHRcdFx0XHRcdFx0XHRlZGdlRHggPSAtZWRnZUR4O1xuXHRcdFx0XHRcdFx0XHRlZGdlSGlnaFB0ID0gaW5Qb2x5Z29uW3BdO1xuXHRcdFx0XHRcdFx0XHRlZGdlRHkgPSAtZWRnZUR5O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoaW5QdC55IDwgZWRnZUxvd1B0LnkgfHwgaW5QdC55ID4gZWRnZUhpZ2hQdC55KSBjb250aW51ZTtcblxuXHRcdFx0XHRcdFx0aWYgKGluUHQueSA9PT0gZWRnZUxvd1B0LnkpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGluUHQueCA9PT0gZWRnZUxvd1B0LngpIHJldHVybiB0cnVlOyAvLyBpblB0IGlzIG9uIGNvbnRvdXIgP1xuXHRcdFx0XHRcdFx0XHQvLyBjb250aW51ZTtcdFx0XHRcdC8vIG5vIGludGVyc2VjdGlvbiBvciBlZGdlTG93UHQgPT4gZG9lc24ndCBjb3VudCAhISFcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHBlcnBFZGdlID0gZWRnZUR5ICogKGluUHQueCAtIGVkZ2VMb3dQdC54KSAtIGVkZ2VEeCAqIChpblB0LnkgLSBlZGdlTG93UHQueSk7XG5cdFx0XHRcdFx0XHRcdGlmIChwZXJwRWRnZSA9PT0gMCkgcmV0dXJuIHRydWU7IC8vIGluUHQgaXMgb24gY29udG91ciA/XG5cblx0XHRcdFx0XHRcdFx0aWYgKHBlcnBFZGdlIDwgMCkgY29udGludWU7XG5cdFx0XHRcdFx0XHRcdGluc2lkZSA9ICFpbnNpZGU7IC8vIHRydWUgaW50ZXJzZWN0aW9uIGxlZnQgb2YgaW5QdFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBwYXJhbGxlbCBvciBjb2xsaW5lYXJcblx0XHRcdFx0XHRcdGlmIChpblB0LnkgIT09IGVkZ2VMb3dQdC55KSBjb250aW51ZTsgLy8gcGFyYWxsZWxcblx0XHRcdFx0XHRcdC8vIGVkZ2UgbGllcyBvbiB0aGUgc2FtZSBob3Jpem9udGFsIGxpbmUgYXMgaW5QdFxuXG5cdFx0XHRcdFx0XHRpZiAoZWRnZUhpZ2hQdC54IDw9IGluUHQueCAmJiBpblB0LnggPD0gZWRnZUxvd1B0LnggfHwgZWRnZUxvd1B0LnggPD0gaW5QdC54ICYmIGluUHQueCA8PSBlZGdlSGlnaFB0LngpIHJldHVybiB0cnVlOyAvLyBpblB0OiBQb2ludCBvbiBjb250b3VyICFcblx0XHRcdFx0XHRcdC8vIGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBpbnNpZGU7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGlzQ2xvY2tXaXNlID0gU2hhcGVVdGlscy5pc0Nsb2NrV2lzZTtcblx0XHRcdGNvbnN0IHN1YlBhdGhzID0gdGhpcy5zdWJQYXRocztcblx0XHRcdGlmIChzdWJQYXRocy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcblx0XHRcdGlmIChub0hvbGVzID09PSB0cnVlKSByZXR1cm4gdG9TaGFwZXNOb0hvbGVzKHN1YlBhdGhzKTtcblx0XHRcdGxldCBzb2xpZCwgdG1wUGF0aCwgdG1wU2hhcGU7XG5cdFx0XHRjb25zdCBzaGFwZXMgPSBbXTtcblxuXHRcdFx0aWYgKHN1YlBhdGhzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHR0bXBQYXRoID0gc3ViUGF0aHNbMF07XG5cdFx0XHRcdHRtcFNoYXBlID0gbmV3IFNoYXBlKCk7XG5cdFx0XHRcdHRtcFNoYXBlLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xuXHRcdFx0XHRzaGFwZXMucHVzaCh0bXBTaGFwZSk7XG5cdFx0XHRcdHJldHVybiBzaGFwZXM7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBob2xlc0ZpcnN0ID0gIWlzQ2xvY2tXaXNlKHN1YlBhdGhzWzBdLmdldFBvaW50cygpKTtcblx0XHRcdGhvbGVzRmlyc3QgPSBpc0NDVyA/ICFob2xlc0ZpcnN0IDogaG9sZXNGaXJzdDsgLy8gY29uc29sZS5sb2coXCJIb2xlcyBmaXJzdFwiLCBob2xlc0ZpcnN0KTtcblxuXHRcdFx0Y29uc3QgYmV0dGVyU2hhcGVIb2xlcyA9IFtdO1xuXHRcdFx0Y29uc3QgbmV3U2hhcGVzID0gW107XG5cdFx0XHRsZXQgbmV3U2hhcGVIb2xlcyA9IFtdO1xuXHRcdFx0bGV0IG1haW5JZHggPSAwO1xuXHRcdFx0bGV0IHRtcFBvaW50cztcblx0XHRcdG5ld1NoYXBlc1ttYWluSWR4XSA9IHVuZGVmaW5lZDtcblx0XHRcdG5ld1NoYXBlSG9sZXNbbWFpbklkeF0gPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBzdWJQYXRocy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dG1wUGF0aCA9IHN1YlBhdGhzW2ldO1xuXHRcdFx0XHR0bXBQb2ludHMgPSB0bXBQYXRoLmdldFBvaW50cygpO1xuXHRcdFx0XHRzb2xpZCA9IGlzQ2xvY2tXaXNlKHRtcFBvaW50cyk7XG5cdFx0XHRcdHNvbGlkID0gaXNDQ1cgPyAhc29saWQgOiBzb2xpZDtcblxuXHRcdFx0XHRpZiAoc29saWQpIHtcblx0XHRcdFx0XHRpZiAoIWhvbGVzRmlyc3QgJiYgbmV3U2hhcGVzW21haW5JZHhdKSBtYWluSWR4Kys7XG5cdFx0XHRcdFx0bmV3U2hhcGVzW21haW5JZHhdID0ge1xuXHRcdFx0XHRcdFx0czogbmV3IFNoYXBlKCksXG5cdFx0XHRcdFx0XHRwOiB0bXBQb2ludHNcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdG5ld1NoYXBlc1ttYWluSWR4XS5zLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xuXHRcdFx0XHRcdGlmIChob2xlc0ZpcnN0KSBtYWluSWR4Kys7XG5cdFx0XHRcdFx0bmV3U2hhcGVIb2xlc1ttYWluSWR4XSA9IFtdOyAvL2NvbnNvbGUubG9nKCdjdycsIGkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5ld1NoYXBlSG9sZXNbbWFpbklkeF0ucHVzaCh7XG5cdFx0XHRcdFx0XHRoOiB0bXBQYXRoLFxuXHRcdFx0XHRcdFx0cDogdG1wUG9pbnRzWzBdXG5cdFx0XHRcdFx0fSk7IC8vY29uc29sZS5sb2coJ2NjdycsIGkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IC8vIG9ubHkgSG9sZXM/IC0+IHByb2JhYmx5IGFsbCBTaGFwZXMgd2l0aCB3cm9uZyBvcmllbnRhdGlvblxuXG5cblx0XHRcdGlmICghbmV3U2hhcGVzWzBdKSByZXR1cm4gdG9TaGFwZXNOb0hvbGVzKHN1YlBhdGhzKTtcblxuXHRcdFx0aWYgKG5ld1NoYXBlcy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdGxldCBhbWJpZ3VvdXMgPSBmYWxzZTtcblx0XHRcdFx0Y29uc3QgdG9DaGFuZ2UgPSBbXTtcblxuXHRcdFx0XHRmb3IgKGxldCBzSWR4ID0gMCwgc0xlbiA9IG5ld1NoYXBlcy5sZW5ndGg7IHNJZHggPCBzTGVuOyBzSWR4KyspIHtcblx0XHRcdFx0XHRiZXR0ZXJTaGFwZUhvbGVzW3NJZHhdID0gW107XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKGxldCBzSWR4ID0gMCwgc0xlbiA9IG5ld1NoYXBlcy5sZW5ndGg7IHNJZHggPCBzTGVuOyBzSWR4KyspIHtcblx0XHRcdFx0XHRjb25zdCBzaG8gPSBuZXdTaGFwZUhvbGVzW3NJZHhdO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaElkeCA9IDA7IGhJZHggPCBzaG8ubGVuZ3RoOyBoSWR4KyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IGhvID0gc2hvW2hJZHhdO1xuXHRcdFx0XHRcdFx0bGV0IGhvbGVfdW5hc3NpZ25lZCA9IHRydWU7XG5cblx0XHRcdFx0XHRcdGZvciAobGV0IHMySWR4ID0gMDsgczJJZHggPCBuZXdTaGFwZXMubGVuZ3RoOyBzMklkeCsrKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChpc1BvaW50SW5zaWRlUG9seWdvbihoby5wLCBuZXdTaGFwZXNbczJJZHhdLnApKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHNJZHggIT09IHMySWR4KSB0b0NoYW5nZS5wdXNoKHtcblx0XHRcdFx0XHRcdFx0XHRcdGZyb21zOiBzSWR4LFxuXHRcdFx0XHRcdFx0XHRcdFx0dG9zOiBzMklkeCxcblx0XHRcdFx0XHRcdFx0XHRcdGhvbGU6IGhJZHhcblx0XHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChob2xlX3VuYXNzaWduZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGhvbGVfdW5hc3NpZ25lZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0YmV0dGVyU2hhcGVIb2xlc1tzMklkeF0ucHVzaChobyk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGFtYmlndW91cyA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChob2xlX3VuYXNzaWduZWQpIHtcblx0XHRcdFx0XHRcdFx0YmV0dGVyU2hhcGVIb2xlc1tzSWR4XS5wdXNoKGhvKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gLy8gY29uc29sZS5sb2coXCJhbWJpZ3VvdXM6IFwiLCBhbWJpZ3VvdXMpO1xuXG5cblx0XHRcdFx0aWYgKHRvQ2hhbmdlLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcInRvIGNoYW5nZTogXCIsIHRvQ2hhbmdlKTtcblx0XHRcdFx0XHRpZiAoIWFtYmlndW91cykgbmV3U2hhcGVIb2xlcyA9IGJldHRlclNoYXBlSG9sZXM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bGV0IHRtcEhvbGVzO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgaWwgPSBuZXdTaGFwZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuXHRcdFx0XHR0bXBTaGFwZSA9IG5ld1NoYXBlc1tpXS5zO1xuXHRcdFx0XHRzaGFwZXMucHVzaCh0bXBTaGFwZSk7XG5cdFx0XHRcdHRtcEhvbGVzID0gbmV3U2hhcGVIb2xlc1tpXTtcblxuXHRcdFx0XHRmb3IgKGxldCBqID0gMCwgamwgPSB0bXBIb2xlcy5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG5cdFx0XHRcdFx0dG1wU2hhcGUuaG9sZXMucHVzaCh0bXBIb2xlc1tqXS5oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSAvL2NvbnNvbGUubG9nKFwic2hhcGVcIiwgc2hhcGVzKTtcblxuXG5cdFx0XHRyZXR1cm4gc2hhcGVzO1xuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgX2Zsb2F0VmlldyA9IG5ldyBGbG9hdDMyQXJyYXkoMSk7XG5cblx0Y29uc3QgX2ludDMyVmlldyA9IG5ldyBJbnQzMkFycmF5KF9mbG9hdFZpZXcuYnVmZmVyKTtcblxuXHRjbGFzcyBEYXRhVXRpbHMge1xuXHRcdC8vIENvbnZlcnRzIGZsb2F0MzIgdG8gZmxvYXQxNiAoc3RvcmVkIGFzIHVpbnQxNiB2YWx1ZSkuXG5cdFx0c3RhdGljIHRvSGFsZkZsb2F0KHZhbCkge1xuXHRcdFx0aWYgKHZhbCA+IDY1NTA0KSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuRGF0YVV0aWxzLnRvSGFsZkZsb2F0KCk6IHZhbHVlIGV4Y2VlZHMgNjU1MDQuJyk7XG5cdFx0XHRcdHZhbCA9IDY1NTA0OyAvLyBtYXhpbXVtIHJlcHJlc2VudGFibGUgdmFsdWUgaW4gZmxvYXQxNlxuXHRcdFx0fSAvLyBTb3VyY2U6IGh0dHA6Ly9nYW1lZGV2LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8xNzMyNi9jb252ZXJzaW9uLW9mLWEtbnVtYmVyLWZyb20tc2luZ2xlLXByZWNpc2lvbi1mbG9hdGluZy1wb2ludC1yZXByZXNlbnRhdGlvbi10by1hLzE3NDEwIzE3NDEwXG5cblx0XHRcdC8qIFRoaXMgbWV0aG9kIGlzIGZhc3RlciB0aGFuIHRoZSBPcGVuRVhSIGltcGxlbWVudGF0aW9uICh2ZXJ5IG9mdGVuXG5cdFx0XHQqIHVzZWQsIGVnLiBpbiBPZ3JlKSwgd2l0aCB0aGUgYWRkaXRpb25hbCBiZW5lZml0IG9mIHJvdW5kaW5nLCBpbnNwaXJlZFxuXHRcdFx0KiBieSBKYW1lcyBUdXJzYT9zIGhhbGYtcHJlY2lzaW9uIGNvZGUuICovXG5cblxuXHRcdFx0X2Zsb2F0Vmlld1swXSA9IHZhbDtcblx0XHRcdGNvbnN0IHggPSBfaW50MzJWaWV3WzBdO1xuXHRcdFx0bGV0IGJpdHMgPSB4ID4+IDE2ICYgMHg4MDAwO1xuXHRcdFx0LyogR2V0IHRoZSBzaWduICovXG5cblx0XHRcdGxldCBtID0geCA+PiAxMiAmIDB4MDdmZjtcblx0XHRcdC8qIEtlZXAgb25lIGV4dHJhIGJpdCBmb3Igcm91bmRpbmcgKi9cblxuXHRcdFx0Y29uc3QgZSA9IHggPj4gMjMgJiAweGZmO1xuXHRcdFx0LyogVXNpbmcgaW50IGlzIGZhc3RlciBoZXJlICovXG5cblx0XHRcdC8qIElmIHplcm8sIG9yIGRlbm9ybWFsLCBvciBleHBvbmVudCB1bmRlcmZsb3dzIHRvbyBtdWNoIGZvciBhIGRlbm9ybWFsXG5cdFx0XHRcdCogaGFsZiwgcmV0dXJuIHNpZ25lZCB6ZXJvLiAqL1xuXG5cdFx0XHRpZiAoZSA8IDEwMykgcmV0dXJuIGJpdHM7XG5cdFx0XHQvKiBJZiBOYU4sIHJldHVybiBOYU4uIElmIEluZiBvciBleHBvbmVudCBvdmVyZmxvdywgcmV0dXJuIEluZi4gKi9cblxuXHRcdFx0aWYgKGUgPiAxNDIpIHtcblx0XHRcdFx0Yml0cyB8PSAweDdjMDA7XG5cdFx0XHRcdC8qIElmIGV4cG9uZW50IHdhcyAweGZmIGFuZCBvbmUgbWFudGlzc2EgYml0IHdhcyBzZXQsIGl0IG1lYW5zIE5hTixcblx0XHRcdFx0XHRcdFx0KiBub3QgSW5mLCBzbyBtYWtlIHN1cmUgd2Ugc2V0IG9uZSBtYW50aXNzYSBiaXQgdG9vLiAqL1xuXG5cdFx0XHRcdGJpdHMgfD0gKGUgPT0gMjU1ID8gMCA6IDEpICYmIHggJiAweDAwN2ZmZmZmO1xuXHRcdFx0XHRyZXR1cm4gYml0cztcblx0XHRcdH1cblx0XHRcdC8qIElmIGV4cG9uZW50IHVuZGVyZmxvd3MgYnV0IG5vdCB0b28gbXVjaCwgcmV0dXJuIGEgZGVub3JtYWwgKi9cblxuXG5cdFx0XHRpZiAoZSA8IDExMykge1xuXHRcdFx0XHRtIHw9IDB4MDgwMDtcblx0XHRcdFx0LyogRXh0cmEgcm91bmRpbmcgbWF5IG92ZXJmbG93IGFuZCBzZXQgbWFudGlzc2EgdG8gMCBhbmQgZXhwb25lbnRcblx0XHRcdFx0XHQqIHRvIDEsIHdoaWNoIGlzIE9LLiAqL1xuXG5cdFx0XHRcdGJpdHMgfD0gKG0gPj4gMTE0IC0gZSkgKyAobSA+PiAxMTMgLSBlICYgMSk7XG5cdFx0XHRcdHJldHVybiBiaXRzO1xuXHRcdFx0fVxuXG5cdFx0XHRiaXRzIHw9IGUgLSAxMTIgPDwgMTAgfCBtID4+IDE7XG5cdFx0XHQvKiBFeHRyYSByb3VuZGluZy4gQW4gb3ZlcmZsb3cgd2lsbCBzZXQgbWFudGlzc2EgdG8gMCBhbmQgaW5jcmVtZW50XG5cdFx0XHRcdCogdGhlIGV4cG9uZW50LCB3aGljaCBpcyBPSy4gKi9cblxuXHRcdFx0Yml0cyArPSBtICYgMTtcblx0XHRcdHJldHVybiBiaXRzO1xuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgTGluZVN0cmlwID0gMDtcblx0Y29uc3QgTGluZVBpZWNlcyA9IDE7XG5cdGNvbnN0IE5vQ29sb3JzID0gMDtcblx0Y29uc3QgRmFjZUNvbG9ycyA9IDE7XG5cdGNvbnN0IFZlcnRleENvbG9ycyA9IDI7XG5cdGZ1bmN0aW9uIE1lc2hGYWNlTWF0ZXJpYWwobWF0ZXJpYWxzKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5NZXNoRmFjZU1hdGVyaWFsIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBhbiBBcnJheSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiBtYXRlcmlhbHM7XG5cdH1cblx0ZnVuY3Rpb24gTXVsdGlNYXRlcmlhbChtYXRlcmlhbHMgPSBbXSkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuTXVsdGlNYXRlcmlhbCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgYW4gQXJyYXkgaW5zdGVhZC4nKTtcblx0XHRtYXRlcmlhbHMuaXNNdWx0aU1hdGVyaWFsID0gdHJ1ZTtcblx0XHRtYXRlcmlhbHMubWF0ZXJpYWxzID0gbWF0ZXJpYWxzO1xuXG5cdFx0bWF0ZXJpYWxzLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIG1hdGVyaWFscy5zbGljZSgpO1xuXHRcdH07XG5cblx0XHRyZXR1cm4gbWF0ZXJpYWxzO1xuXHR9XG5cdGZ1bmN0aW9uIFBvaW50Q2xvdWQoZ2VvbWV0cnksIG1hdGVyaWFsKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5Qb2ludENsb3VkIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzLicpO1xuXHRcdHJldHVybiBuZXcgUG9pbnRzKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG5cdH1cblx0ZnVuY3Rpb24gUGFydGljbGUobWF0ZXJpYWwpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlBhcnRpY2xlIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuU3ByaXRlLicpO1xuXHRcdHJldHVybiBuZXcgU3ByaXRlKG1hdGVyaWFsKTtcblx0fVxuXHRmdW5jdGlvbiBQYXJ0aWNsZVN5c3RlbShnZW9tZXRyeSwgbWF0ZXJpYWwpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlBhcnRpY2xlU3lzdGVtIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzLicpO1xuXHRcdHJldHVybiBuZXcgUG9pbnRzKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG5cdH1cblx0ZnVuY3Rpb24gUG9pbnRDbG91ZE1hdGVyaWFsKHBhcmFtZXRlcnMpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50c01hdGVyaWFsLicpO1xuXHRcdHJldHVybiBuZXcgUG9pbnRzTWF0ZXJpYWwocGFyYW1ldGVycyk7XG5cdH1cblx0ZnVuY3Rpb24gUGFydGljbGVCYXNpY01hdGVyaWFsKHBhcmFtZXRlcnMpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50c01hdGVyaWFsLicpO1xuXHRcdHJldHVybiBuZXcgUG9pbnRzTWF0ZXJpYWwocGFyYW1ldGVycyk7XG5cdH1cblx0ZnVuY3Rpb24gUGFydGljbGVTeXN0ZW1NYXRlcmlhbChwYXJhbWV0ZXJzKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzTWF0ZXJpYWwuJyk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludHNNYXRlcmlhbChwYXJhbWV0ZXJzKTtcblx0fVxuXHRmdW5jdGlvbiBWZXJ0ZXgoeCwgeSwgeikge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuVmVydGV4IGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5WZWN0b3IzIGluc3RlYWQuJyk7XG5cdFx0cmV0dXJuIG5ldyBWZWN0b3IzKHgsIHksIHopO1xuXHR9IC8vXG5cblx0ZnVuY3Rpb24gRHluYW1pY0J1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoKS5zZXRVc2FnZSggVEhSRUUuRHluYW1pY0RyYXdVc2FnZSApIGluc3RlYWQuJyk7XG5cdFx0cmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplKS5zZXRVc2FnZShEeW5hbWljRHJhd1VzYWdlKTtcblx0fVxuXHRmdW5jdGlvbiBJbnQ4QXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuSW50OEF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkludDhCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiBuZXcgSW50OEJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUpO1xuXHR9XG5cdGZ1bmN0aW9uIFVpbnQ4QXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuVWludDhBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5VaW50OEJ1ZmZlckF0dHJpYnV0ZSgpIGluc3RlYWQuJyk7XG5cdFx0cmV0dXJuIG5ldyBVaW50OEJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUpO1xuXHR9XG5cdGZ1bmN0aW9uIFVpbnQ4Q2xhbXBlZEF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlVpbnQ4Q2xhbXBlZEF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLlVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZSgpIGluc3RlYWQuJyk7XG5cdFx0cmV0dXJuIG5ldyBVaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplKTtcblx0fVxuXHRmdW5jdGlvbiBJbnQxNkF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkludDE2QXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuSW50MTZCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiBuZXcgSW50MTZCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplKTtcblx0fVxuXHRmdW5jdGlvbiBVaW50MTZBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5VaW50MTZBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5VaW50MTZCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiBuZXcgVWludDE2QnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSk7XG5cdH1cblx0ZnVuY3Rpb24gSW50MzJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5JbnQzMkF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkludDMyQnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC4nKTtcblx0XHRyZXR1cm4gbmV3IEludDMyQnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSk7XG5cdH1cblx0ZnVuY3Rpb24gVWludDMyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuVWludDMyQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuVWludDMyQnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC4nKTtcblx0XHRyZXR1cm4gbmV3IFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUpO1xuXHR9XG5cdGZ1bmN0aW9uIEZsb2F0MzJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5GbG9hdDMyQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSgpIGluc3RlYWQuJyk7XG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSk7XG5cdH1cblx0ZnVuY3Rpb24gRmxvYXQ2NEF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkZsb2F0NjRBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5GbG9hdDY0QnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC4nKTtcblx0XHRyZXR1cm4gbmV3IEZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplKTtcblx0fSAvL1xuXG5cdEN1cnZlLmNyZWF0ZSA9IGZ1bmN0aW9uIChjb25zdHJ1Y3QsIGdldFBvaW50KSB7XG5cdFx0Y29uc29sZS5sb2coJ1RIUkVFLkN1cnZlLmNyZWF0ZSgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQnKTtcblx0XHRjb25zdHJ1Y3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDdXJ2ZS5wcm90b3R5cGUpO1xuXHRcdGNvbnN0cnVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3Q7XG5cdFx0Y29uc3RydWN0LnByb3RvdHlwZS5nZXRQb2ludCA9IGdldFBvaW50O1xuXHRcdHJldHVybiBjb25zdHJ1Y3Q7XG5cdH07IC8vXG5cblxuXHRQYXRoLnByb3RvdHlwZS5mcm9tUG9pbnRzID0gZnVuY3Rpb24gKHBvaW50cykge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuUGF0aDogLmZyb21Qb2ludHMoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tUG9pbnRzKCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbVBvaW50cyhwb2ludHMpO1xuXHR9OyAvL1xuXG5cblx0ZnVuY3Rpb24gQXhpc0hlbHBlcihzaXplKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5BeGlzSGVscGVyIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuQXhlc0hlbHBlci4nKTtcblx0XHRyZXR1cm4gbmV3IEF4ZXNIZWxwZXIoc2l6ZSk7XG5cdH1cblx0ZnVuY3Rpb24gQm91bmRpbmdCb3hIZWxwZXIob2JqZWN0LCBjb2xvcikge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuQm91bmRpbmdCb3hIZWxwZXIgaGFzIGJlZW4gZGVwcmVjYXRlZC4gQ3JlYXRpbmcgYSBUSFJFRS5Cb3hIZWxwZXIgaW5zdGVhZC4nKTtcblx0XHRyZXR1cm4gbmV3IEJveEhlbHBlcihvYmplY3QsIGNvbG9yKTtcblx0fVxuXHRmdW5jdGlvbiBFZGdlc0hlbHBlcihvYmplY3QsIGhleCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuRWRnZXNIZWxwZXIgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkVkZ2VzR2VvbWV0cnkgaW5zdGVhZC4nKTtcblx0XHRyZXR1cm4gbmV3IExpbmVTZWdtZW50cyhuZXcgRWRnZXNHZW9tZXRyeShvYmplY3QuZ2VvbWV0cnkpLCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoe1xuXHRcdFx0Y29sb3I6IGhleCAhPT0gdW5kZWZpbmVkID8gaGV4IDogMHhmZmZmZmZcblx0XHR9KSk7XG5cdH1cblxuXHRHcmlkSGVscGVyLnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS5lcnJvcignVEhSRUUuR3JpZEhlbHBlcjogc2V0Q29sb3JzKCkgaGFzIGJlZW4gZGVwcmVjYXRlZCwgcGFzcyB0aGVtIGluIHRoZSBjb25zdHJ1Y3RvciBpbnN0ZWFkLicpO1xuXHR9O1xuXG5cdFNrZWxldG9uSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS5lcnJvcignVEhSRUUuU2tlbGV0b25IZWxwZXI6IHVwZGF0ZSgpIG5vIGxvbmdlciBuZWVkcyB0byBiZSBjYWxsZWQuJyk7XG5cdH07XG5cblx0ZnVuY3Rpb24gV2lyZWZyYW1lSGVscGVyKG9iamVjdCwgaGV4KSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XaXJlZnJhbWVIZWxwZXIgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLldpcmVmcmFtZUdlb21ldHJ5IGluc3RlYWQuJyk7XG5cdFx0cmV0dXJuIG5ldyBMaW5lU2VnbWVudHMobmV3IFdpcmVmcmFtZUdlb21ldHJ5KG9iamVjdC5nZW9tZXRyeSksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCh7XG5cdFx0XHRjb2xvcjogaGV4ICE9PSB1bmRlZmluZWQgPyBoZXggOiAweGZmZmZmZlxuXHRcdH0pKTtcblx0fSAvL1xuXG5cdExvYWRlci5wcm90b3R5cGUuZXh0cmFjdFVybEJhc2UgPSBmdW5jdGlvbiAodXJsKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5Mb2FkZXI6IC5leHRyYWN0VXJsQmFzZSgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBUSFJFRS5Mb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSgpIGluc3RlYWQuJyk7XG5cdFx0cmV0dXJuIExvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKHVybCk7XG5cdH07XG5cblx0TG9hZGVyLkhhbmRsZXJzID0ge1xuXHRcdGFkZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuTG9hZGVyOiBIYW5kbGVycy5hZGQoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgTG9hZGluZ01hbmFnZXIuYWRkSGFuZGxlcigpIGluc3RlYWQuJyk7XG5cdFx0fSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkxvYWRlcjogSGFuZGxlcnMuZ2V0KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIExvYWRpbmdNYW5hZ2VyLmdldEhhbmRsZXIoKSBpbnN0ZWFkLicpO1xuXHRcdH1cblx0fTtcblx0ZnVuY3Rpb24gWEhSTG9hZGVyKG1hbmFnZXIpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlhIUkxvYWRlciBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLkZpbGVMb2FkZXIuJyk7XG5cdFx0cmV0dXJuIG5ldyBGaWxlTG9hZGVyKG1hbmFnZXIpO1xuXHR9XG5cdGZ1bmN0aW9uIEJpbmFyeVRleHR1cmVMb2FkZXIobWFuYWdlcikge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuQmluYXJ5VGV4dHVyZUxvYWRlciBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLkRhdGFUZXh0dXJlTG9hZGVyLicpO1xuXHRcdHJldHVybiBuZXcgRGF0YVRleHR1cmVMb2FkZXIobWFuYWdlcik7XG5cdH0gLy9cblxuXHRCb3gyLnByb3RvdHlwZS5jZW50ZXIgPSBmdW5jdGlvbiAob3B0aW9uYWxUYXJnZXQpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJveDI6IC5jZW50ZXIoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRDZW50ZXIoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRDZW50ZXIob3B0aW9uYWxUYXJnZXQpO1xuXHR9O1xuXG5cdEJveDIucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuQm94MjogLmVtcHR5KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaXNFbXB0eSgpLicpO1xuXHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKTtcblx0fTtcblxuXHRCb3gyLnByb3RvdHlwZS5pc0ludGVyc2VjdGlvbkJveCA9IGZ1bmN0aW9uIChib3gpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJveDI6IC5pc0ludGVyc2VjdGlvbkJveCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNCb3goKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzQm94KGJveCk7XG5cdH07XG5cblx0Qm94Mi5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIChvcHRpb25hbFRhcmdldCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuQm94MjogLnNpemUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRTaXplKCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U2l6ZShvcHRpb25hbFRhcmdldCk7XG5cdH07IC8vXG5cblxuXHRCb3gzLnByb3RvdHlwZS5jZW50ZXIgPSBmdW5jdGlvbiAob3B0aW9uYWxUYXJnZXQpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJveDM6IC5jZW50ZXIoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRDZW50ZXIoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRDZW50ZXIob3B0aW9uYWxUYXJnZXQpO1xuXHR9O1xuXG5cdEJveDMucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuQm94MzogLmVtcHR5KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaXNFbXB0eSgpLicpO1xuXHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKTtcblx0fTtcblxuXHRCb3gzLnByb3RvdHlwZS5pc0ludGVyc2VjdGlvbkJveCA9IGZ1bmN0aW9uIChib3gpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJveDM6IC5pc0ludGVyc2VjdGlvbkJveCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNCb3goKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzQm94KGJveCk7XG5cdH07XG5cblx0Qm94My5wcm90b3R5cGUuaXNJbnRlcnNlY3Rpb25TcGhlcmUgPSBmdW5jdGlvbiAoc3BoZXJlKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5Cb3gzOiAuaXNJbnRlcnNlY3Rpb25TcGhlcmUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzU3BoZXJlKCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZShzcGhlcmUpO1xuXHR9O1xuXG5cdEJveDMucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAob3B0aW9uYWxUYXJnZXQpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJveDM6IC5zaXplKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0U2l6ZSgpLicpO1xuXHRcdHJldHVybiB0aGlzLmdldFNpemUob3B0aW9uYWxUYXJnZXQpO1xuXHR9OyAvL1xuXG5cblx0U3BoZXJlLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlNwaGVyZTogLmVtcHR5KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaXNFbXB0eSgpLicpO1xuXHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKTtcblx0fTsgLy9cblxuXG5cdEZydXN0dW0ucHJvdG90eXBlLnNldEZyb21NYXRyaXggPSBmdW5jdGlvbiAobSkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuRnJ1c3R1bTogLnNldEZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tUHJvamVjdGlvbk1hdHJpeCgpLicpO1xuXHRcdHJldHVybiB0aGlzLnNldEZyb21Qcm9qZWN0aW9uTWF0cml4KG0pO1xuXHR9OyAvL1xuXG5cblx0TGluZTMucHJvdG90eXBlLmNlbnRlciA9IGZ1bmN0aW9uIChvcHRpb25hbFRhcmdldCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuTGluZTM6IC5jZW50ZXIoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRDZW50ZXIoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRDZW50ZXIob3B0aW9uYWxUYXJnZXQpO1xuXHR9OyAvL1xuXG5cblx0TWF0cml4My5wcm90b3R5cGUuZmxhdHRlblRvQXJyYXlPZmZzZXQgPSBmdW5jdGlvbiAoYXJyYXksIG9mZnNldCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuTWF0cml4MzogLmZsYXR0ZW5Ub0FycmF5T2Zmc2V0KCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC50b0FycmF5KCkgaW5zdGVhZC4nKTtcblx0XHRyZXR1cm4gdGhpcy50b0FycmF5KGFycmF5LCBvZmZzZXQpO1xuXHR9O1xuXG5cdE1hdHJpeDMucHJvdG90eXBlLm11bHRpcGx5VmVjdG9yMyA9IGZ1bmN0aW9uICh2ZWN0b3IpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk1hdHJpeDM6IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4MyggbWF0cml4ICkgaW5zdGVhZC4nKTtcblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4Myh0aGlzKTtcblx0fTtcblxuXHRNYXRyaXgzLnByb3RvdHlwZS5tdWx0aXBseVZlY3RvcjNBcnJheSA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5NYXRyaXgzOiAubXVsdGlwbHlWZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHR9O1xuXG5cdE1hdHJpeDMucHJvdG90eXBlLmFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5NYXRyaXgzOiAuYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBhdHRyaWJ1dGUuYXBwbHlNYXRyaXgzKCBtYXRyaXggKSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiBhdHRyaWJ1dGUuYXBwbHlNYXRyaXgzKHRoaXMpO1xuXHR9O1xuXG5cdE1hdHJpeDMucHJvdG90eXBlLmFwcGx5VG9WZWN0b3IzQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS5lcnJvcignVEhSRUUuTWF0cml4MzogLmFwcGx5VG9WZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHR9O1xuXG5cdE1hdHJpeDMucHJvdG90eXBlLmdldEludmVyc2UgPSBmdW5jdGlvbiAobWF0cml4KSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5NYXRyaXgzOiAuZ2V0SW52ZXJzZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBtYXRyaXhJbnYuY29weSggbWF0cml4ICkuaW52ZXJ0KCk7IGluc3RlYWQuJyk7XG5cdFx0cmV0dXJuIHRoaXMuY29weShtYXRyaXgpLmludmVydCgpO1xuXHR9OyAvL1xuXG5cblx0TWF0cml4NC5wcm90b3R5cGUuZXh0cmFjdFBvc2l0aW9uID0gZnVuY3Rpb24gKG0pIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk1hdHJpeDQ6IC5leHRyYWN0UG9zaXRpb24oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5jb3B5UG9zaXRpb24oKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5jb3B5UG9zaXRpb24obSk7XG5cdH07XG5cblx0TWF0cml4NC5wcm90b3R5cGUuZmxhdHRlblRvQXJyYXlPZmZzZXQgPSBmdW5jdGlvbiAoYXJyYXksIG9mZnNldCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuTWF0cml4NDogLmZsYXR0ZW5Ub0FycmF5T2Zmc2V0KCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC50b0FycmF5KCkgaW5zdGVhZC4nKTtcblx0XHRyZXR1cm4gdGhpcy50b0FycmF5KGFycmF5LCBvZmZzZXQpO1xuXHR9O1xuXG5cdE1hdHJpeDQucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuTWF0cml4NDogLmdldFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiBuZXcgVmVjdG9yMygpLnNldEZyb21NYXRyaXhDb2x1bW4odGhpcywgMyk7XG5cdH07XG5cblx0TWF0cml4NC5wcm90b3R5cGUuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbiA9IGZ1bmN0aW9uIChxKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5NYXRyaXg0OiAuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24ocSk7XG5cdH07XG5cblx0TWF0cml4NC5wcm90b3R5cGUubXVsdGlwbHlUb0FycmF5ID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VG9BcnJheSgpIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdH07XG5cblx0TWF0cml4NC5wcm90b3R5cGUubXVsdGlwbHlWZWN0b3IzID0gZnVuY3Rpb24gKHZlY3Rvcikge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KHRoaXMpO1xuXHR9O1xuXG5cdE1hdHJpeDQucHJvdG90eXBlLm11bHRpcGx5VmVjdG9yNCA9IGZ1bmN0aW9uICh2ZWN0b3IpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjQoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC4nKTtcblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCh0aGlzKTtcblx0fTtcblxuXHRNYXRyaXg0LnByb3RvdHlwZS5tdWx0aXBseVZlY3RvcjNBcnJheSA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHR9O1xuXG5cdE1hdHJpeDQucHJvdG90eXBlLnJvdGF0ZUF4aXMgPSBmdW5jdGlvbiAodikge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuTWF0cml4NDogLnJvdGF0ZUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVmVjdG9yMy50cmFuc2Zvcm1EaXJlY3Rpb24oIG1hdHJpeCApIGluc3RlYWQuJyk7XG5cdFx0di50cmFuc2Zvcm1EaXJlY3Rpb24odGhpcyk7XG5cdH07XG5cblx0TWF0cml4NC5wcm90b3R5cGUuY3Jvc3NWZWN0b3IgPSBmdW5jdGlvbiAodmVjdG9yKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5NYXRyaXg0OiAuY3Jvc3NWZWN0b3IoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC4nKTtcblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCh0aGlzKTtcblx0fTtcblxuXHRNYXRyaXg0LnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS5lcnJvcignVEhSRUUuTWF0cml4NDogLnRyYW5zbGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdH07XG5cblx0TWF0cml4NC5wcm90b3R5cGUucm90YXRlWCA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5NYXRyaXg0OiAucm90YXRlWCgpIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdH07XG5cblx0TWF0cml4NC5wcm90b3R5cGUucm90YXRlWSA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5NYXRyaXg0OiAucm90YXRlWSgpIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdH07XG5cblx0TWF0cml4NC5wcm90b3R5cGUucm90YXRlWiA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5NYXRyaXg0OiAucm90YXRlWigpIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdH07XG5cblx0TWF0cml4NC5wcm90b3R5cGUucm90YXRlQnlBeGlzID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVCeUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHR9O1xuXG5cdE1hdHJpeDQucHJvdG90eXBlLmFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5NYXRyaXg0OiAuYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBhdHRyaWJ1dGUuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiBhdHRyaWJ1dGUuYXBwbHlNYXRyaXg0KHRoaXMpO1xuXHR9O1xuXG5cdE1hdHJpeDQucHJvdG90eXBlLmFwcGx5VG9WZWN0b3IzQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS5lcnJvcignVEhSRUUuTWF0cml4NDogLmFwcGx5VG9WZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHR9O1xuXG5cdE1hdHJpeDQucHJvdG90eXBlLm1ha2VGcnVzdHVtID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5NYXRyaXg0OiAubWFrZUZydXN0dW0oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLm1ha2VQZXJzcGVjdGl2ZSggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiB0aGlzLm1ha2VQZXJzcGVjdGl2ZShsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhcik7XG5cdH07XG5cblx0TWF0cml4NC5wcm90b3R5cGUuZ2V0SW52ZXJzZSA9IGZ1bmN0aW9uIChtYXRyaXgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk1hdHJpeDQ6IC5nZXRJbnZlcnNlKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG1hdHJpeEludi5jb3B5KCBtYXRyaXggKS5pbnZlcnQoKTsgaW5zdGVhZC4nKTtcblx0XHRyZXR1cm4gdGhpcy5jb3B5KG1hdHJpeCkuaW52ZXJ0KCk7XG5cdH07IC8vXG5cblxuXHRQbGFuZS5wcm90b3R5cGUuaXNJbnRlcnNlY3Rpb25MaW5lID0gZnVuY3Rpb24gKGxpbmUpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlBsYW5lOiAuaXNJbnRlcnNlY3Rpb25MaW5lKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0xpbmUoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzTGluZShsaW5lKTtcblx0fTsgLy9cblxuXG5cdFF1YXRlcm5pb24ucHJvdG90eXBlLm11bHRpcGx5VmVjdG9yMyA9IGZ1bmN0aW9uICh2ZWN0b3IpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgaXMgbm93IHZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlRdWF0ZXJuaW9uKHRoaXMpO1xuXHR9O1xuXG5cdFF1YXRlcm5pb24ucHJvdG90eXBlLmludmVyc2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5RdWF0ZXJuaW9uOiAuaW52ZXJzZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gaW52ZXJ0KCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuaW52ZXJ0KCk7XG5cdH07IC8vXG5cblxuXHRSYXkucHJvdG90eXBlLmlzSW50ZXJzZWN0aW9uQm94ID0gZnVuY3Rpb24gKGJveCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuUmF5OiAuaXNJbnRlcnNlY3Rpb25Cb3goKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzQm94KCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c0JveChib3gpO1xuXHR9O1xuXG5cdFJheS5wcm90b3R5cGUuaXNJbnRlcnNlY3Rpb25QbGFuZSA9IGZ1bmN0aW9uIChwbGFuZSkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuUmF5OiAuaXNJbnRlcnNlY3Rpb25QbGFuZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNQbGFuZSgpLicpO1xuXHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNQbGFuZShwbGFuZSk7XG5cdH07XG5cblx0UmF5LnByb3RvdHlwZS5pc0ludGVyc2VjdGlvblNwaGVyZSA9IGZ1bmN0aW9uIChzcGhlcmUpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlJheTogLmlzSW50ZXJzZWN0aW9uU3BoZXJlKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c1NwaGVyZSgpLicpO1xuXHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoc3BoZXJlKTtcblx0fTsgLy9cblxuXG5cdFRyaWFuZ2xlLnByb3RvdHlwZS5hcmVhID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuVHJpYW5nbGU6IC5hcmVhKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0QXJlYSgpLicpO1xuXHRcdHJldHVybiB0aGlzLmdldEFyZWEoKTtcblx0fTtcblxuXHRUcmlhbmdsZS5wcm90b3R5cGUuYmFyeWNvb3JkRnJvbVBvaW50ID0gZnVuY3Rpb24gKHBvaW50LCB0YXJnZXQpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlRyaWFuZ2xlOiAuYmFyeWNvb3JkRnJvbVBvaW50KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0QmFyeWNvb3JkKCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0QmFyeWNvb3JkKHBvaW50LCB0YXJnZXQpO1xuXHR9O1xuXG5cdFRyaWFuZ2xlLnByb3RvdHlwZS5taWRwb2ludCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlRyaWFuZ2xlOiAubWlkcG9pbnQoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRNaWRwb2ludCgpLicpO1xuXHRcdHJldHVybiB0aGlzLmdldE1pZHBvaW50KHRhcmdldCk7XG5cdH07XG5cblx0VHJpYW5nbGUucHJvdG90eXBlbm9ybWFsID0gZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuVHJpYW5nbGU6IC5ub3JtYWwoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXROb3JtYWwoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5nZXROb3JtYWwodGFyZ2V0KTtcblx0fTtcblxuXHRUcmlhbmdsZS5wcm90b3R5cGUucGxhbmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5UcmlhbmdsZTogLnBsYW5lKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0UGxhbmUoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRQbGFuZSh0YXJnZXQpO1xuXHR9O1xuXG5cdFRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCA9IGZ1bmN0aW9uIChwb2ludCwgYSwgYiwgYywgdGFyZ2V0KSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5UcmlhbmdsZTogLmJhcnljb29yZEZyb21Qb2ludCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldEJhcnljb29yZCgpLicpO1xuXHRcdHJldHVybiBUcmlhbmdsZS5nZXRCYXJ5Y29vcmQocG9pbnQsIGEsIGIsIGMsIHRhcmdldCk7XG5cdH07XG5cblx0VHJpYW5nbGUubm9ybWFsID0gZnVuY3Rpb24gKGEsIGIsIGMsIHRhcmdldCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuVHJpYW5nbGU6IC5ub3JtYWwoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXROb3JtYWwoKS4nKTtcblx0XHRyZXR1cm4gVHJpYW5nbGUuZ2V0Tm9ybWFsKGEsIGIsIGMsIHRhcmdldCk7XG5cdH07IC8vXG5cblxuXHRTaGFwZS5wcm90b3R5cGUuZXh0cmFjdEFsbFBvaW50cyA9IGZ1bmN0aW9uIChkaXZpc2lvbnMpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlNoYXBlOiAuZXh0cmFjdEFsbFBvaW50cygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAuZXh0cmFjdFBvaW50cygpIGluc3RlYWQuJyk7XG5cdFx0cmV0dXJuIHRoaXMuZXh0cmFjdFBvaW50cyhkaXZpc2lvbnMpO1xuXHR9O1xuXG5cdFNoYXBlLnByb3RvdHlwZS5leHRydWRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlNoYXBlOiAuZXh0cnVkZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFeHRydWRlR2VvbWV0cnkoKSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiBuZXcgRXh0cnVkZUdlb21ldHJ5KHRoaXMsIG9wdGlvbnMpO1xuXHR9O1xuXG5cdFNoYXBlLnByb3RvdHlwZS5tYWtlR2VvbWV0cnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuU2hhcGU6IC5tYWtlR2VvbWV0cnkoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgU2hhcGVHZW9tZXRyeSgpIGluc3RlYWQuJyk7XG5cdFx0cmV0dXJuIG5ldyBTaGFwZUdlb21ldHJ5KHRoaXMsIG9wdGlvbnMpO1xuXHR9OyAvL1xuXG5cblx0VmVjdG9yMi5wcm90b3R5cGUuZnJvbUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlZlY3RvcjI6IC5mcm9tQXR0cmlidXRlKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicpO1xuXHRcdHJldHVybiB0aGlzLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0KTtcblx0fTtcblxuXHRWZWN0b3IyLnByb3RvdHlwZS5kaXN0YW5jZVRvTWFuaGF0dGFuID0gZnVuY3Rpb24gKHYpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlZlY3RvcjI6IC5kaXN0YW5jZVRvTWFuaGF0dGFuKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAubWFuaGF0dGFuRGlzdGFuY2VUbygpLicpO1xuXHRcdHJldHVybiB0aGlzLm1hbmhhdHRhbkRpc3RhbmNlVG8odik7XG5cdH07XG5cblx0VmVjdG9yMi5wcm90b3R5cGUubGVuZ3RoTWFuaGF0dGFuID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuVmVjdG9yMjogLmxlbmd0aE1hbmhhdHRhbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1hbmhhdHRhbkxlbmd0aCgpLicpO1xuXHRcdHJldHVybiB0aGlzLm1hbmhhdHRhbkxlbmd0aCgpO1xuXHR9OyAvL1xuXG5cblx0VmVjdG9yMy5wcm90b3R5cGUuc2V0RXVsZXJGcm9tUm90YXRpb25NYXRyaXggPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS5lcnJvcignVEhSRUUuVmVjdG9yMzogLnNldEV1bGVyRnJvbVJvdGF0aW9uTWF0cml4KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIEV1bGVyLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGluc3RlYWQuJyk7XG5cdH07XG5cblx0VmVjdG9yMy5wcm90b3R5cGUuc2V0RXVsZXJGcm9tUXVhdGVybmlvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5WZWN0b3IzOiAuc2V0RXVsZXJGcm9tUXVhdGVybmlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUXVhdGVybmlvbigpIGluc3RlYWQuJyk7XG5cdH07XG5cblx0VmVjdG9yMy5wcm90b3R5cGUuZ2V0UG9zaXRpb25Gcm9tTWF0cml4ID0gZnVuY3Rpb24gKG0pIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlZlY3RvcjM6IC5nZXRQb3NpdGlvbkZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4UG9zaXRpb24oKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4UG9zaXRpb24obSk7XG5cdH07XG5cblx0VmVjdG9yMy5wcm90b3R5cGUuZ2V0U2NhbGVGcm9tTWF0cml4ID0gZnVuY3Rpb24gKG0pIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlZlY3RvcjM6IC5nZXRTY2FsZUZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4U2NhbGUoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4U2NhbGUobSk7XG5cdH07XG5cblx0VmVjdG9yMy5wcm90b3R5cGUuZ2V0Q29sdW1uRnJvbU1hdHJpeCA9IGZ1bmN0aW9uIChpbmRleCwgbWF0cml4KSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5WZWN0b3IzOiAuZ2V0Q29sdW1uRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhDb2x1bW4oKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKG1hdHJpeCwgaW5kZXgpO1xuXHR9O1xuXG5cdFZlY3RvcjMucHJvdG90eXBlLmFwcGx5UHJvamVjdGlvbiA9IGZ1bmN0aW9uIChtKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5WZWN0b3IzOiAuYXBwbHlQcm9qZWN0aW9uKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC5hcHBseU1hdHJpeDQoIG0gKSBpbnN0ZWFkLicpO1xuXHRcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4NChtKTtcblx0fTtcblxuXHRWZWN0b3IzLnByb3RvdHlwZS5mcm9tQXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuVmVjdG9yMzogLmZyb21BdHRyaWJ1dGUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5mcm9tQnVmZmVyQXR0cmlidXRlKCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQpO1xuXHR9O1xuXG5cdFZlY3RvcjMucHJvdG90eXBlLmRpc3RhbmNlVG9NYW5oYXR0YW4gPSBmdW5jdGlvbiAodikge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuVmVjdG9yMzogLmRpc3RhbmNlVG9NYW5oYXR0YW4oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5tYW5oYXR0YW5EaXN0YW5jZVRvKCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMubWFuaGF0dGFuRGlzdGFuY2VUbyh2KTtcblx0fTtcblxuXHRWZWN0b3IzLnByb3RvdHlwZS5sZW5ndGhNYW5oYXR0YW4gPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5WZWN0b3IzOiAubGVuZ3RoTWFuaGF0dGFuKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAubWFuaGF0dGFuTGVuZ3RoKCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMubWFuaGF0dGFuTGVuZ3RoKCk7XG5cdH07IC8vXG5cblxuXHRWZWN0b3I0LnByb3RvdHlwZS5mcm9tQXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuVmVjdG9yNDogLmZyb21BdHRyaWJ1dGUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5mcm9tQnVmZmVyQXR0cmlidXRlKCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQpO1xuXHR9O1xuXG5cdFZlY3RvcjQucHJvdG90eXBlLmxlbmd0aE1hbmhhdHRhbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlZlY3RvcjQ6IC5sZW5ndGhNYW5oYXR0YW4oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5tYW5oYXR0YW5MZW5ndGgoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5tYW5oYXR0YW5MZW5ndGgoKTtcblx0fTsgLy9cblxuXG5cdE9iamVjdDNELnByb3RvdHlwZS5nZXRDaGlsZEJ5TmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5PYmplY3QzRDogLmdldENoaWxkQnlOYW1lKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0T2JqZWN0QnlOYW1lKCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlOYW1lKG5hbWUpO1xuXHR9O1xuXG5cdE9iamVjdDNELnByb3RvdHlwZS5yZW5kZXJEZXB0aCA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk9iamVjdDNEOiAucmVuZGVyRGVwdGggaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC5yZW5kZXJPcmRlciwgaW5zdGVhZC4nKTtcblx0fTtcblxuXHRPYmplY3QzRC5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24gKGRpc3RhbmNlLCBheGlzKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5PYmplY3QzRDogLnRyYW5zbGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAudHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApIGluc3RlYWQuJyk7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKGF4aXMsIGRpc3RhbmNlKTtcblx0fTtcblxuXHRPYmplY3QzRC5wcm90b3R5cGUuZ2V0V29ybGRSb3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5PYmplY3QzRDogLmdldFdvcmxkUm90YXRpb24oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuT2JqZWN0M0QuZ2V0V29ybGRRdWF0ZXJuaW9uKCB0YXJnZXQgKSBpbnN0ZWFkLicpO1xuXHR9O1xuXG5cdE9iamVjdDNELnByb3RvdHlwZS5hcHBseU1hdHJpeCA9IGZ1bmN0aW9uIChtYXRyaXgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk9iamVjdDNEOiAuYXBwbHlNYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5hcHBseU1hdHJpeDQoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQobWF0cml4KTtcblx0fTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPYmplY3QzRC5wcm90b3R5cGUsIHtcblx0XHRldWxlck9yZGVyOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5PYmplY3QzRDogLmV1bGVyT3JkZXIgaXMgbm93IC5yb3RhdGlvbi5vcmRlci4nKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMucm90YXRpb24ub3JkZXI7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5PYmplY3QzRDogLmV1bGVyT3JkZXIgaXMgbm93IC5yb3RhdGlvbi5vcmRlci4nKTtcblx0XHRcdFx0dGhpcy5yb3RhdGlvbi5vcmRlciA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dXNlUXVhdGVybmlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuT2JqZWN0M0Q6IC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuJyk7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuT2JqZWN0M0Q6IC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuJyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRNZXNoLnByb3RvdHlwZS5zZXREcmF3TW9kZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5NZXNoOiAuc2V0RHJhd01vZGUoKSBoYXMgYmVlbiByZW1vdmVkLiBUaGUgcmVuZGVyZXIgbm93IGFsd2F5cyBhc3N1bWVzIFRIUkVFLlRyaWFuZ2xlc0RyYXdNb2RlLiBUcmFuc2Zvcm0geW91ciBnZW9tZXRyeSB2aWEgQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCkgaWYgbmVjZXNzYXJ5LicpO1xuXHR9O1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE1lc2gucHJvdG90eXBlLCB7XG5cdFx0ZHJhd01vZGU6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5NZXNoOiAuZHJhd01vZGUgaGFzIGJlZW4gcmVtb3ZlZC4gVGhlIHJlbmRlcmVyIG5vdyBhbHdheXMgYXNzdW1lcyBUSFJFRS5UcmlhbmdsZXNEcmF3TW9kZS4nKTtcblx0XHRcdFx0cmV0dXJuIFRyaWFuZ2xlc0RyYXdNb2RlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5NZXNoOiAuZHJhd01vZGUgaGFzIGJlZW4gcmVtb3ZlZC4gVGhlIHJlbmRlcmVyIG5vdyBhbHdheXMgYXNzdW1lcyBUSFJFRS5UcmlhbmdsZXNEcmF3TW9kZS4gVHJhbnNmb3JtIHlvdXIgZ2VvbWV0cnkgdmlhIEJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpIGlmIG5lY2Vzc2FyeS4nKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdFNraW5uZWRNZXNoLnByb3RvdHlwZS5pbml0Qm9uZXMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS5lcnJvcignVEhSRUUuU2tpbm5lZE1lc2g6IGluaXRCb25lcygpIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdH07IC8vXG5cblxuXHRQZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuc2V0TGVucyA9IGZ1bmN0aW9uIChmb2NhbExlbmd0aCwgZmlsbUdhdWdlKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5zZXRMZW5zIGlzIGRlcHJlY2F0ZWQuICcgKyAnVXNlIC5zZXRGb2NhbExlbmd0aCBhbmQgLmZpbG1HYXVnZSBmb3IgYSBwaG90b2dyYXBoaWMgc2V0dXAuJyk7XG5cdFx0aWYgKGZpbG1HYXVnZSAhPT0gdW5kZWZpbmVkKSB0aGlzLmZpbG1HYXVnZSA9IGZpbG1HYXVnZTtcblx0XHR0aGlzLnNldEZvY2FsTGVuZ3RoKGZvY2FsTGVuZ3RoKTtcblx0fTsgLy9cblxuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKExpZ2h0LnByb3RvdHlwZSwge1xuXHRcdG9ubHlTaGFkb3c6IHtcblx0XHRcdHNldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkxpZ2h0OiAub25seVNoYWRvdyBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hhZG93Q2FtZXJhRm92OiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhRm92IGlzIG5vdyAuc2hhZG93LmNhbWVyYS5mb3YuJyk7XG5cdFx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS5mb3YgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNoYWRvd0NhbWVyYUxlZnQ6IHtcblx0XHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFMZWZ0IGlzIG5vdyAuc2hhZG93LmNhbWVyYS5sZWZ0LicpO1xuXHRcdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEubGVmdCA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hhZG93Q2FtZXJhUmlnaHQ6IHtcblx0XHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFSaWdodCBpcyBub3cgLnNoYWRvdy5jYW1lcmEucmlnaHQuJyk7XG5cdFx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS5yaWdodCA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hhZG93Q2FtZXJhVG9wOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhVG9wIGlzIG5vdyAuc2hhZG93LmNhbWVyYS50b3AuJyk7XG5cdFx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS50b3AgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNoYWRvd0NhbWVyYUJvdHRvbToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYUJvdHRvbSBpcyBub3cgLnNoYWRvdy5jYW1lcmEuYm90dG9tLicpO1xuXHRcdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEuYm90dG9tID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzaGFkb3dDYW1lcmFOZWFyOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhTmVhciBpcyBub3cgLnNoYWRvdy5jYW1lcmEubmVhci4nKTtcblx0XHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLm5lYXIgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNoYWRvd0NhbWVyYUZhcjoge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYUZhciBpcyBub3cgLnNoYWRvdy5jYW1lcmEuZmFyLicpO1xuXHRcdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEuZmFyID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzaGFkb3dDYW1lcmFWaXNpYmxlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYVZpc2libGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5DYW1lcmFIZWxwZXIoIGxpZ2h0LnNoYWRvdy5jYW1lcmEgKSBpbnN0ZWFkLicpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hhZG93Qmlhczoge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5MaWdodDogLnNoYWRvd0JpYXMgaXMgbm93IC5zaGFkb3cuYmlhcy4nKTtcblx0XHRcdFx0dGhpcy5zaGFkb3cuYmlhcyA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hhZG93RGFya25lc3M6IHtcblx0XHRcdHNldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkxpZ2h0OiAuc2hhZG93RGFya25lc3MgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNoYWRvd01hcFdpZHRoOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkxpZ2h0OiAuc2hhZG93TWFwV2lkdGggaXMgbm93IC5zaGFkb3cubWFwU2l6ZS53aWR0aC4nKTtcblx0XHRcdFx0dGhpcy5zaGFkb3cubWFwU2l6ZS53aWR0aCA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hhZG93TWFwSGVpZ2h0OiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkxpZ2h0OiAuc2hhZG93TWFwSGVpZ2h0IGlzIG5vdyAuc2hhZG93Lm1hcFNpemUuaGVpZ2h0LicpO1xuXHRcdFx0XHR0aGlzLnNoYWRvdy5tYXBTaXplLmhlaWdodCA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7IC8vXG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSwge1xuXHRcdGxlbmd0aDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQnVmZmVyQXR0cmlidXRlOiAubGVuZ3RoIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuY291bnQgaW5zdGVhZC4nKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZHluYW1pYzoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQnVmZmVyQXR0cmlidXRlOiAuZHluYW1pYyBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLnVzYWdlIGluc3RlYWQuJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnVzYWdlID09PSBEeW5hbWljRHJhd1VzYWdlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogLmR5bmFtaWMgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC51c2FnZSBpbnN0ZWFkLicpO1xuXHRcdFx0XHR0aGlzLnNldFVzYWdlKER5bmFtaWNEcmF3VXNhZ2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5zZXREeW5hbWljID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IC5zZXREeW5hbWljKCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5zZXRVc2FnZSgpIGluc3RlYWQuJyk7XG5cdFx0dGhpcy5zZXRVc2FnZSh2YWx1ZSA9PT0gdHJ1ZSA/IER5bmFtaWNEcmF3VXNhZ2UgOiBTdGF0aWNEcmF3VXNhZ2UpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29weUluZGljZXNBcnJheSA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IC5jb3B5SW5kaWNlc0FycmF5KCkgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcblx0fSwgQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5zZXRBcnJheSA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IC5zZXRBcnJheSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgQnVmZmVyR2VvbWV0cnkgLnNldEF0dHJpYnV0ZSB0byByZXBsYWNlL3Jlc2l6ZSBhdHRyaWJ1dGUgYnVmZmVycycpO1xuXHR9OyAvL1xuXG5cdEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5hZGRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGRJbmRleCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEluZGV4KCkuJyk7XG5cdFx0dGhpcy5zZXRJbmRleChpbmRleCk7XG5cdH07XG5cblx0QnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmFkZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lLCBhdHRyaWJ1dGUpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkQXR0cmlidXRlKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0QXR0cmlidXRlKCkuJyk7XG5cblx0XHRpZiAoIShhdHRyaWJ1dGUgJiYgYXR0cmlidXRlLmlzQnVmZmVyQXR0cmlidXRlKSAmJiAhKGF0dHJpYnV0ZSAmJiBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSkpIHtcblx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGRBdHRyaWJ1dGUoKSBub3cgZXhwZWN0cyAoIG5hbWUsIGF0dHJpYnV0ZSApLicpO1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pKTtcblx0XHR9XG5cblx0XHRpZiAobmFtZSA9PT0gJ2luZGV4Jykge1xuXHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5CdWZmZXJHZW9tZXRyeS5hZGRBdHRyaWJ1dGU6IFVzZSAuc2V0SW5kZXgoKSBmb3IgaW5kZXggYXR0cmlidXRlLicpO1xuXHRcdFx0dGhpcy5zZXRJbmRleChhdHRyaWJ1dGUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJpYnV0ZSk7XG5cdH07XG5cblx0QnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmFkZERyYXdDYWxsID0gZnVuY3Rpb24gKHN0YXJ0LCBjb3VudCwgaW5kZXhPZmZzZXQpIHtcblx0XHRpZiAoaW5kZXhPZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZERyYXdDYWxsKCkgbm8gbG9uZ2VyIHN1cHBvcnRzIGluZGV4T2Zmc2V0LicpO1xuXHRcdH1cblxuXHRcdGNvbnNvbGUud2FybignVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGREcmF3Q2FsbCgpIGlzIG5vdyAuYWRkR3JvdXAoKS4nKTtcblx0XHR0aGlzLmFkZEdyb3VwKHN0YXJ0LCBjb3VudCk7XG5cdH07XG5cblx0QnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNsZWFyRHJhd0NhbGxzID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jbGVhckRyYXdDYWxscygpIGlzIG5vdyAuY2xlYXJHcm91cHMoKS4nKTtcblx0XHR0aGlzLmNsZWFyR3JvdXBzKCk7XG5cdH07XG5cblx0QnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbXB1dGVPZmZzZXRzID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlT2Zmc2V0cygpIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdH07XG5cblx0QnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLnJlbW92ZUF0dHJpYnV0ZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmRlbGV0ZUF0dHJpYnV0ZSgpLicpO1xuXHRcdHJldHVybiB0aGlzLmRlbGV0ZUF0dHJpYnV0ZShuYW1lKTtcblx0fTtcblxuXHRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuYXBwbHlNYXRyaXggPSBmdW5jdGlvbiAobWF0cml4KSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFwcGx5TWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuYXBwbHlNYXRyaXg0KCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KG1hdHJpeCk7XG5cdH07XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLCB7XG5cdFx0ZHJhd2NhbGxzOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5kcmF3Y2FsbHMgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ3JvdXBzLicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5ncm91cHM7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvZmZzZXRzOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLm9mZnNldHMgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ3JvdXBzLicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5ncm91cHM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUuc2V0RHluYW1pYyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXI6IC5zZXREeW5hbWljKCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5zZXRVc2FnZSgpIGluc3RlYWQuJyk7XG5cdFx0dGhpcy5zZXRVc2FnZSh2YWx1ZSA9PT0gdHJ1ZSA/IER5bmFtaWNEcmF3VXNhZ2UgOiBTdGF0aWNEcmF3VXNhZ2UpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5zZXRBcnJheSA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlcjogLnNldEFycmF5IGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBCdWZmZXJHZW9tZXRyeSAuc2V0QXR0cmlidXRlIHRvIHJlcGxhY2UvcmVzaXplIGF0dHJpYnV0ZSBidWZmZXJzJyk7XG5cdH07IC8vXG5cblxuXHRFeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmdldEFycmF5cyA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5FeHRydWRlR2VvbWV0cnk6IC5nZXRBcnJheXMoKSBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHR9O1xuXG5cdEV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGVMaXN0ID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkV4dHJ1ZGVHZW9tZXRyeTogLmFkZFNoYXBlTGlzdCgpIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdH07XG5cblx0RXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5FeHRydWRlR2VvbWV0cnk6IC5hZGRTaGFwZSgpIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdH07IC8vXG5cblxuXHRTY2VuZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5TY2VuZTogLmRpc3Bvc2UoKSBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHR9OyAvL1xuXG5cblx0VW5pZm9ybS5wcm90b3R5cGUub25VcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5Vbmlmb3JtOiAub25VcGRhdGUoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2Ugb2JqZWN0Lm9uQmVmb3JlUmVuZGVyKCkgaW5zdGVhZC4nKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTsgLy9cblxuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE1hdGVyaWFsLnByb3RvdHlwZSwge1xuXHRcdHdyYXBBcm91bmQ6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk1hdGVyaWFsOiAud3JhcEFyb3VuZCBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk1hdGVyaWFsOiAud3JhcEFyb3VuZCBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0b3ZlcmRyYXc6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLk1hdGVyaWFsOiAub3ZlcmRyYXcgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5NYXRlcmlhbDogLm92ZXJkcmF3IGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR3cmFwUkdCOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5NYXRlcmlhbDogLndyYXBSR0IgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcblx0XHRcdFx0cmV0dXJuIG5ldyBDb2xvcigpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hhZGluZzoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAuc2hhZGluZyBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdGhlIGJvb2xlYW4gLmZsYXRTaGFkaW5nIGluc3RlYWQuJyk7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS4nICsgdGhpcy50eXBlICsgJzogLnNoYWRpbmcgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHRoZSBib29sZWFuIC5mbGF0U2hhZGluZyBpbnN0ZWFkLicpO1xuXHRcdFx0XHR0aGlzLmZsYXRTaGFkaW5nID0gdmFsdWUgPT09IEZsYXRTaGFkaW5nO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c3RlbmNpbE1hc2s6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAuc3RlbmNpbE1hc2sgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC5zdGVuY2lsRnVuY01hc2sgaW5zdGVhZC4nKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3RlbmNpbEZ1bmNNYXNrO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuJyArIHRoaXMudHlwZSArICc6IC5zdGVuY2lsTWFzayBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLnN0ZW5jaWxGdW5jTWFzayBpbnN0ZWFkLicpO1xuXHRcdFx0XHR0aGlzLnN0ZW5jaWxGdW5jTWFzayA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dmVydGV4VGFuZ2VudHM6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAudmVydGV4VGFuZ2VudHMgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS4nICsgdGhpcy50eXBlICsgJzogLnZlcnRleFRhbmdlbnRzIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLCB7XG5cdFx0ZGVyaXZhdGl2ZXM6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLlNoYWRlck1hdGVyaWFsOiAuZGVyaXZhdGl2ZXMgaGFzIGJlZW4gbW92ZWQgdG8gLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXMuJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXM7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS4gU2hhZGVyTWF0ZXJpYWw6IC5kZXJpdmF0aXZlcyBoYXMgYmVlbiBtb3ZlZCB0byAuZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcy4nKTtcblx0XHRcdFx0dGhpcy5leHRlbnNpb25zLmRlcml2YXRpdmVzID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTsgLy9cblxuXHRXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5jbGVhclRhcmdldCA9IGZ1bmN0aW9uIChyZW5kZXJUYXJnZXQsIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLmNsZWFyVGFyZ2V0KCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5zZXRSZW5kZXJUYXJnZXQoKSBhbmQgLmNsZWFyKCkgaW5zdGVhZC4nKTtcblx0XHR0aGlzLnNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpO1xuXHRcdHRoaXMuY2xlYXIoY29sb3IsIGRlcHRoLCBzdGVuY2lsKTtcblx0fTtcblxuXHRXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5hbmltYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuYW5pbWF0ZSgpIGlzIG5vdyAuc2V0QW5pbWF0aW9uTG9vcCgpLicpO1xuXHRcdHRoaXMuc2V0QW5pbWF0aW9uTG9vcChjYWxsYmFjayk7XG5cdH07XG5cblx0V2ViR0xSZW5kZXJlci5wcm90b3R5cGUuZ2V0Q3VycmVudFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5nZXRDdXJyZW50UmVuZGVyVGFyZ2V0KCkgaXMgbm93IC5nZXRSZW5kZXJUYXJnZXQoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRSZW5kZXJUYXJnZXQoKTtcblx0fTtcblxuXHRXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5nZXRNYXhBbmlzb3Ryb3B5ID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLmdldE1heEFuaXNvdHJvcHkoKSBpcyBub3cgLmNhcGFiaWxpdGllcy5nZXRNYXhBbmlzb3Ryb3B5KCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMuY2FwYWJpbGl0aWVzLmdldE1heEFuaXNvdHJvcHkoKTtcblx0fTtcblxuXHRXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5nZXRQcmVjaXNpb24gPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuZ2V0UHJlY2lzaW9uKCkgaXMgbm93IC5jYXBhYmlsaXRpZXMucHJlY2lzaW9uLicpO1xuXHRcdHJldHVybiB0aGlzLmNhcGFiaWxpdGllcy5wcmVjaXNpb247XG5cdH07XG5cblx0V2ViR0xSZW5kZXJlci5wcm90b3R5cGUucmVzZXRHTFN0YXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLnJlc2V0R0xTdGF0ZSgpIGlzIG5vdyAuc3RhdGUucmVzZXQoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZS5yZXNldCgpO1xuXHR9O1xuXG5cdFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLnN1cHBvcnRzRmxvYXRUZXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0Zsb2F0VGV4dHVyZXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdPRVNfdGV4dHVyZV9mbG9hdFxcJyApLicpO1xuXHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCdPRVNfdGV4dHVyZV9mbG9hdCcpO1xuXHR9O1xuXG5cdFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLnN1cHBvcnRzSGFsZkZsb2F0VGV4dHVyZXMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNIYWxmRmxvYXRUZXh0dXJlcygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ09FU190ZXh0dXJlX2hhbGZfZmxvYXRcXCcgKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCgnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcpO1xuXHR9O1xuXG5cdFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLnN1cHBvcnRzU3RhbmRhcmREZXJpdmF0aXZlcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c1N0YW5kYXJkRGVyaXZhdGl2ZXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcXCcgKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCgnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyk7XG5cdH07XG5cblx0V2ViR0xSZW5kZXJlci5wcm90b3R5cGUuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVMzVEMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVMzVEMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1xcJyApLicpO1xuXHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycpO1xuXHR9O1xuXG5cdFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLnN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVQVlJUQyA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUFZSVEMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcXCcgKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCgnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyk7XG5cdH07XG5cblx0V2ViR0xSZW5kZXJlci5wcm90b3R5cGUuc3VwcG9ydHNCbGVuZE1pbk1heCA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0JsZW5kTWluTWF4KCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnRVhUX2JsZW5kX21pbm1heFxcJyApLicpO1xuXHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCdFWFRfYmxlbmRfbWlubWF4Jyk7XG5cdH07XG5cblx0V2ViR0xSZW5kZXJlci5wcm90b3R5cGUuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c1ZlcnRleFRleHR1cmVzKCkgaXMgbm93IC5jYXBhYmlsaXRpZXMudmVydGV4VGV4dHVyZXMuJyk7XG5cdFx0cmV0dXJuIHRoaXMuY2FwYWJpbGl0aWVzLnZlcnRleFRleHR1cmVzO1xuXHR9O1xuXG5cdFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLnN1cHBvcnRzSW5zdGFuY2VkQXJyYXlzID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzSW5zdGFuY2VkQXJyYXlzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnQU5HTEVfaW5zdGFuY2VkX2FycmF5c1xcJyApLicpO1xuXHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyk7XG5cdH07XG5cblx0V2ViR0xSZW5kZXJlci5wcm90b3R5cGUuZW5hYmxlU2Npc3NvclRlc3QgPSBmdW5jdGlvbiAoYm9vbGVhbikge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLmVuYWJsZVNjaXNzb3JUZXN0KCkgaXMgbm93IC5zZXRTY2lzc29yVGVzdCgpLicpO1xuXHRcdHRoaXMuc2V0U2Npc3NvclRlc3QoYm9vbGVhbik7XG5cdH07XG5cblx0V2ViR0xSZW5kZXJlci5wcm90b3R5cGUuaW5pdE1hdGVyaWFsID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLmluaXRNYXRlcmlhbCgpIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdH07XG5cblx0V2ViR0xSZW5kZXJlci5wcm90b3R5cGUuYWRkUHJlUGx1Z2luID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLmFkZFByZVBsdWdpbigpIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdH07XG5cblx0V2ViR0xSZW5kZXJlci5wcm90b3R5cGUuYWRkUG9zdFBsdWdpbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5hZGRQb3N0UGx1Z2luKCkgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcblx0fTtcblxuXHRXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVTaGFkb3dNYXAgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAudXBkYXRlU2hhZG93TWFwKCkgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcblx0fTtcblxuXHRXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5zZXRGYWNlQ3VsbGluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zZXRGYWNlQ3VsbGluZygpIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdH07XG5cblx0V2ViR0xSZW5kZXJlci5wcm90b3R5cGUuYWxsb2NUZXh0dXJlVW5pdCA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5hbGxvY1RleHR1cmVVbml0KCkgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcblx0fTtcblxuXHRXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5zZXRUZXh0dXJlID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNldFRleHR1cmUoKSBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHR9O1xuXG5cdFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLnNldFRleHR1cmUyRCA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zZXRUZXh0dXJlMkQoKSBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHR9O1xuXG5cdFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLnNldFRleHR1cmVDdWJlID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNldFRleHR1cmVDdWJlKCkgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcblx0fTtcblxuXHRXZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5nZXRBY3RpdmVNaXBNYXBMZXZlbCA9IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5nZXRBY3RpdmVNaXBNYXBMZXZlbCgpIGlzIG5vdyAuZ2V0QWN0aXZlTWlwbWFwTGV2ZWwoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRBY3RpdmVNaXBtYXBMZXZlbCgpO1xuXHR9O1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLCB7XG5cdFx0c2hhZG93TWFwRW5hYmxlZDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnNoYWRvd01hcC5lbmFibGVkO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcEVuYWJsZWQgaXMgbm93IC5zaGFkb3dNYXAuZW5hYmxlZC4nKTtcblx0XHRcdFx0dGhpcy5zaGFkb3dNYXAuZW5hYmxlZCA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hhZG93TWFwVHlwZToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnNoYWRvd01hcC50eXBlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcFR5cGUgaXMgbm93IC5zaGFkb3dNYXAudHlwZS4nKTtcblx0XHRcdFx0dGhpcy5zaGFkb3dNYXAudHlwZSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hhZG93TWFwQ3VsbEZhY2U6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBDdWxsRmFjZSBoYXMgYmVlbiByZW1vdmVkLiBTZXQgTWF0ZXJpYWwuc2hhZG93U2lkZSBpbnN0ZWFkLicpO1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBDdWxsRmFjZSBoYXMgYmVlbiByZW1vdmVkLiBTZXQgTWF0ZXJpYWwuc2hhZG93U2lkZSBpbnN0ZWFkLicpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Y29udGV4dDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLmNvbnRleHQgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC5nZXRDb250ZXh0KCkgaW5zdGVhZC4nKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0Q29udGV4dCgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dnI6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC52ciBoYXMgYmVlbiByZW5hbWVkIHRvIC54cicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy54cjtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGdhbW1hSW5wdXQ6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5nYW1tYUlucHV0IGhhcyBiZWVuIHJlbW92ZWQuIFNldCB0aGUgZW5jb2RpbmcgZm9yIHRleHR1cmVzIHZpYSBUZXh0dXJlLmVuY29kaW5nIGluc3RlYWQuJyk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuZ2FtbWFJbnB1dCBoYXMgYmVlbiByZW1vdmVkLiBTZXQgdGhlIGVuY29kaW5nIGZvciB0ZXh0dXJlcyB2aWEgVGV4dHVyZS5lbmNvZGluZyBpbnN0ZWFkLicpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Z2FtbWFPdXRwdXQ6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5nYW1tYU91dHB1dCBoYXMgYmVlbiByZW1vdmVkLiBTZXQgV2ViR0xSZW5kZXJlci5vdXRwdXRFbmNvZGluZyBpbnN0ZWFkLicpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuZ2FtbWFPdXRwdXQgaGFzIGJlZW4gcmVtb3ZlZC4gU2V0IFdlYkdMUmVuZGVyZXIub3V0cHV0RW5jb2RpbmcgaW5zdGVhZC4nKTtcblx0XHRcdFx0dGhpcy5vdXRwdXRFbmNvZGluZyA9IHZhbHVlID09PSB0cnVlID8gc1JHQkVuY29kaW5nIDogTGluZWFyRW5jb2Rpbmc7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR0b25lTWFwcGluZ1doaXRlUG9pbnQ6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC50b25lTWFwcGluZ1doaXRlUG9pbnQgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcblx0XHRcdFx0cmV0dXJuIDEuMDtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAudG9uZU1hcHBpbmdXaGl0ZVBvaW50IGhhcyBiZWVuIHJlbW92ZWQuJyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV2ViR0xTaGFkb3dNYXAucHJvdG90eXBlLCB7XG5cdFx0Y3VsbEZhY2U6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXAuY3VsbEZhY2UgaGFzIGJlZW4gcmVtb3ZlZC4gU2V0IE1hdGVyaWFsLnNoYWRvd1NpZGUgaW5zdGVhZC4nKTtcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwLmN1bGxGYWNlIGhhcyBiZWVuIHJlbW92ZWQuIFNldCBNYXRlcmlhbC5zaGFkb3dTaWRlIGluc3RlYWQuJyk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZW5kZXJSZXZlcnNlU2lkZWQ6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXAucmVuZGVyUmV2ZXJzZVNpZGVkIGhhcyBiZWVuIHJlbW92ZWQuIFNldCBNYXRlcmlhbC5zaGFkb3dTaWRlIGluc3RlYWQuJyk7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcC5yZW5kZXJSZXZlcnNlU2lkZWQgaGFzIGJlZW4gcmVtb3ZlZC4gU2V0IE1hdGVyaWFsLnNoYWRvd1NpZGUgaW5zdGVhZC4nKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlbmRlclNpbmdsZVNpZGVkOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwLnJlbmRlclNpbmdsZVNpZGVkIGhhcyBiZWVuIHJlbW92ZWQuIFNldCBNYXRlcmlhbC5zaGFkb3dTaWRlIGluc3RlYWQuJyk7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcC5yZW5kZXJTaW5nbGVTaWRlZCBoYXMgYmVlbiByZW1vdmVkLiBTZXQgTWF0ZXJpYWwuc2hhZG93U2lkZSBpbnN0ZWFkLicpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cdGZ1bmN0aW9uIFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZSh3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKSBpcyBub3cgV2ViR0xDdWJlUmVuZGVyVGFyZ2V0KCBzaXplLCBvcHRpb25zICkuJyk7XG5cdFx0cmV0dXJuIG5ldyBXZWJHTEN1YmVSZW5kZXJUYXJnZXQod2lkdGgsIG9wdGlvbnMpO1xuXHR9IC8vXG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlLCB7XG5cdFx0d3JhcFM6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFMgaXMgbm93IC50ZXh0dXJlLndyYXBTLicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLndyYXBTO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC53cmFwUyBpcyBub3cgLnRleHR1cmUud3JhcFMuJyk7XG5cdFx0XHRcdHRoaXMudGV4dHVyZS53cmFwUyA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0d3JhcFQ6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFQgaXMgbm93IC50ZXh0dXJlLndyYXBULicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLndyYXBUO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC53cmFwVCBpcyBub3cgLnRleHR1cmUud3JhcFQuJyk7XG5cdFx0XHRcdHRoaXMudGV4dHVyZS53cmFwVCA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bWFnRmlsdGVyOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1hZ0ZpbHRlciBpcyBub3cgLnRleHR1cmUubWFnRmlsdGVyLicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLm1hZ0ZpbHRlcjtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAubWFnRmlsdGVyIGlzIG5vdyAudGV4dHVyZS5tYWdGaWx0ZXIuJyk7XG5cdFx0XHRcdHRoaXMudGV4dHVyZS5tYWdGaWx0ZXIgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG1pbkZpbHRlcjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5taW5GaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1pbkZpbHRlci4nKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5taW5GaWx0ZXI7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1pbkZpbHRlciBpcyBub3cgLnRleHR1cmUubWluRmlsdGVyLicpO1xuXHRcdFx0XHR0aGlzLnRleHR1cmUubWluRmlsdGVyID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhbmlzb3Ryb3B5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmFuaXNvdHJvcHkgaXMgbm93IC50ZXh0dXJlLmFuaXNvdHJvcHkuJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUuYW5pc290cm9weTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuYW5pc290cm9weSBpcyBub3cgLnRleHR1cmUuYW5pc290cm9weS4nKTtcblx0XHRcdFx0dGhpcy50ZXh0dXJlLmFuaXNvdHJvcHkgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9mZnNldDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5vZmZzZXQgaXMgbm93IC50ZXh0dXJlLm9mZnNldC4nKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5vZmZzZXQ7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm9mZnNldCBpcyBub3cgLnRleHR1cmUub2Zmc2V0LicpO1xuXHRcdFx0XHR0aGlzLnRleHR1cmUub2Zmc2V0ID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZXBlYXQ6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAucmVwZWF0IGlzIG5vdyAudGV4dHVyZS5yZXBlYXQuJyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUucmVwZWF0O1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5yZXBlYXQgaXMgbm93IC50ZXh0dXJlLnJlcGVhdC4nKTtcblx0XHRcdFx0dGhpcy50ZXh0dXJlLnJlcGVhdCA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Zm9ybWF0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmZvcm1hdCBpcyBub3cgLnRleHR1cmUuZm9ybWF0LicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLmZvcm1hdDtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuZm9ybWF0IGlzIG5vdyAudGV4dHVyZS5mb3JtYXQuJyk7XG5cdFx0XHRcdHRoaXMudGV4dHVyZS5mb3JtYXQgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHR5cGU6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAudHlwZSBpcyBub3cgLnRleHR1cmUudHlwZS4nKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS50eXBlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC50eXBlIGlzIG5vdyAudGV4dHVyZS50eXBlLicpO1xuXHRcdFx0XHR0aGlzLnRleHR1cmUudHlwZSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Z2VuZXJhdGVNaXBtYXBzOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmdlbmVyYXRlTWlwbWFwcyBpcyBub3cgLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzLicpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcztcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuZ2VuZXJhdGVNaXBtYXBzIGlzIG5vdyAudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMuJyk7XG5cdFx0XHRcdHRoaXMudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0pOyAvL1xuXG5cdEF1ZGlvLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGZpbGUpIHtcblx0XHRjb25zb2xlLndhcm4oJ1RIUkVFLkF1ZGlvOiAubG9hZCBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgVEhSRUUuQXVkaW9Mb2FkZXIgaW5zdGVhZC4nKTtcblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cdFx0Y29uc3QgYXVkaW9Mb2FkZXIgPSBuZXcgQXVkaW9Mb2FkZXIoKTtcblx0XHRhdWRpb0xvYWRlci5sb2FkKGZpbGUsIGZ1bmN0aW9uIChidWZmZXIpIHtcblx0XHRcdHNjb3BlLnNldEJ1ZmZlcihidWZmZXIpO1xuXHRcdH0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdEF1ZGlvQW5hbHlzZXIucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5BdWRpb0FuYWx5c2VyOiAuZ2V0RGF0YSgpIGlzIG5vdyAuZ2V0RnJlcXVlbmN5RGF0YSgpLicpO1xuXHRcdHJldHVybiB0aGlzLmdldEZyZXF1ZW5jeURhdGEoKTtcblx0fTsgLy9cblxuXG5cdEN1YmVDYW1lcmEucHJvdG90eXBlLnVwZGF0ZUN1YmVNYXAgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHNjZW5lKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5DdWJlQ2FtZXJhOiAudXBkYXRlQ3ViZU1hcCgpIGlzIG5vdyAudXBkYXRlKCkuJyk7XG5cdFx0cmV0dXJuIHRoaXMudXBkYXRlKHJlbmRlcmVyLCBzY2VuZSk7XG5cdH07XG5cblx0Q3ViZUNhbWVyYS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCkge1xuXHRcdGNvbnNvbGUud2FybignVEhSRUUuQ3ViZUNhbWVyYTogLmNsZWFyKCkgaXMgbm93IC5yZW5kZXJUYXJnZXQuY2xlYXIoKS4nKTtcblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXQuY2xlYXIocmVuZGVyZXIsIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCk7XG5cdH07XG5cblx0SW1hZ2VVdGlscy5jcm9zc09yaWdpbiA9IHVuZGVmaW5lZDtcblxuXHRJbWFnZVV0aWxzLmxvYWRUZXh0dXJlID0gZnVuY3Rpb24gKHVybCwgbWFwcGluZywgb25Mb2FkLCBvbkVycm9yKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBUSFJFRS5UZXh0dXJlTG9hZGVyKCkgaW5zdGVhZC4nKTtcblx0XHRjb25zdCBsb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlcigpO1xuXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbih0aGlzLmNyb3NzT3JpZ2luKTtcblx0XHRjb25zdCB0ZXh0dXJlID0gbG9hZGVyLmxvYWQodXJsLCBvbkxvYWQsIHVuZGVmaW5lZCwgb25FcnJvcik7XG5cdFx0aWYgKG1hcHBpbmcpIHRleHR1cmUubWFwcGluZyA9IG1hcHBpbmc7XG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cdH07XG5cblx0SW1hZ2VVdGlscy5sb2FkVGV4dHVyZUN1YmUgPSBmdW5jdGlvbiAodXJscywgbWFwcGluZywgb25Mb2FkLCBvbkVycm9yKSB7XG5cdFx0Y29uc29sZS53YXJuKCdUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlQ3ViZSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgVEhSRUUuQ3ViZVRleHR1cmVMb2FkZXIoKSBpbnN0ZWFkLicpO1xuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBDdWJlVGV4dHVyZUxvYWRlcigpO1xuXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbih0aGlzLmNyb3NzT3JpZ2luKTtcblx0XHRjb25zdCB0ZXh0dXJlID0gbG9hZGVyLmxvYWQodXJscywgb25Mb2FkLCB1bmRlZmluZWQsIG9uRXJyb3IpO1xuXHRcdGlmIChtYXBwaW5nKSB0ZXh0dXJlLm1hcHBpbmcgPSBtYXBwaW5nO1xuXHRcdHJldHVybiB0ZXh0dXJlO1xuXHR9O1xuXG5cdEltYWdlVXRpbHMubG9hZENvbXByZXNzZWRUZXh0dXJlID0gZnVuY3Rpb24gKCkge1xuXHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkltYWdlVXRpbHMubG9hZENvbXByZXNzZWRUZXh0dXJlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5ERFNMb2FkZXIgaW5zdGVhZC4nKTtcblx0fTtcblxuXHRJbWFnZVV0aWxzLmxvYWRDb21wcmVzc2VkVGV4dHVyZUN1YmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS5lcnJvcignVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmVDdWJlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5ERFNMb2FkZXIgaW5zdGVhZC4nKTtcblx0fTsgLy9cblxuXG5cdGZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKCkge1xuXHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkNhbnZhc1JlbmRlcmVyIGhhcyBiZWVuIHJlbW92ZWQnKTtcblx0fSAvL1xuXG5cdGZ1bmN0aW9uIEpTT05Mb2FkZXIoKSB7XG5cdFx0Y29uc29sZS5lcnJvcignVEhSRUUuSlNPTkxvYWRlciBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHR9IC8vXG5cblx0Y29uc3QgU2NlbmVVdGlscyA9IHtcblx0XHRjcmVhdGVNdWx0aU1hdGVyaWFsT2JqZWN0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5TY2VuZVV0aWxzIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qc20vdXRpbHMvU2NlbmVVdGlscy5qcycpO1xuXHRcdH0sXG5cdFx0ZGV0YWNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5TY2VuZVV0aWxzIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qc20vdXRpbHMvU2NlbmVVdGlscy5qcycpO1xuXHRcdH0sXG5cdFx0YXR0YWNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5TY2VuZVV0aWxzIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qc20vdXRpbHMvU2NlbmVVdGlscy5qcycpO1xuXHRcdH1cblx0fTsgLy9cblxuXHRmdW5jdGlvbiBMZW5zRmxhcmUoKSB7XG5cdFx0Y29uc29sZS5lcnJvcignVEhSRUUuTGVuc0ZsYXJlIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qc20vb2JqZWN0cy9MZW5zZmxhcmUuanMnKTtcblx0fSAvL1xuXG5cdGZ1bmN0aW9uIFBhcmFtZXRyaWNHZW9tZXRyeSgpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5QYXJhbWV0cmljR2VvbWV0cnkgaGFzIGJlZW4gbW92ZWQgdG8gL2V4YW1wbGVzL2pzbS9nZW9tZXRyaWVzL1BhcmFtZXRyaWNHZW9tZXRyeS5qcycpO1xuXHRcdHJldHVybiBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0fVxuXHRmdW5jdGlvbiBUZXh0R2VvbWV0cnkoKSB7XG5cdFx0Y29uc29sZS5lcnJvcignVEhSRUUuVGV4dEdlb21ldHJ5IGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qc20vZ2VvbWV0cmllcy9UZXh0R2VvbWV0cnkuanMnKTtcblx0XHRyZXR1cm4gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdH1cblx0ZnVuY3Rpb24gRm9udExvYWRlcigpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5Gb250TG9hZGVyIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qc20vbG9hZGVycy9Gb250TG9hZGVyLmpzJyk7XG5cdH1cblx0ZnVuY3Rpb24gRm9udCgpIHtcblx0XHRjb25zb2xlLmVycm9yKCdUSFJFRS5Gb250IGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qc20vbG9hZGVycy9Gb250TG9hZGVyLmpzJyk7XG5cdH1cblx0ZnVuY3Rpb24gSW1tZWRpYXRlUmVuZGVyT2JqZWN0KCkge1xuXHRcdGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdCBoYXMgYmVlbiByZW1vdmVkLicpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBfX1RIUkVFX0RFVlRPT0xTX18gIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0LyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cblx0XHRfX1RIUkVFX0RFVlRPT0xTX18uZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3JlZ2lzdGVyJywge1xuXHRcdFx0ZGV0YWlsOiB7XG5cdFx0XHRcdHJldmlzaW9uOiBSRVZJU0lPTlxuXHRcdFx0fVxuXHRcdH0pKTtcblx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZGVmICovXG5cblx0fVxuXG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuXHRcdGlmICh3aW5kb3cuX19USFJFRV9fKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1dBUk5JTkc6IE11bHRpcGxlIGluc3RhbmNlcyBvZiBUaHJlZS5qcyBiZWluZyBpbXBvcnRlZC4nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93Ll9fVEhSRUVfXyA9IFJFVklTSU9OO1xuXHRcdH1cblx0fVxuXG5cdGV4cG9ydHMuQUNFU0ZpbG1pY1RvbmVNYXBwaW5nID0gQUNFU0ZpbG1pY1RvbmVNYXBwaW5nO1xuXHRleHBvcnRzLkFkZEVxdWF0aW9uID0gQWRkRXF1YXRpb247XG5cdGV4cG9ydHMuQWRkT3BlcmF0aW9uID0gQWRkT3BlcmF0aW9uO1xuXHRleHBvcnRzLkFkZGl0aXZlQW5pbWF0aW9uQmxlbmRNb2RlID0gQWRkaXRpdmVBbmltYXRpb25CbGVuZE1vZGU7XG5cdGV4cG9ydHMuQWRkaXRpdmVCbGVuZGluZyA9IEFkZGl0aXZlQmxlbmRpbmc7XG5cdGV4cG9ydHMuQWxwaGFGb3JtYXQgPSBBbHBoYUZvcm1hdDtcblx0ZXhwb3J0cy5BbHdheXNEZXB0aCA9IEFsd2F5c0RlcHRoO1xuXHRleHBvcnRzLkFsd2F5c1N0ZW5jaWxGdW5jID0gQWx3YXlzU3RlbmNpbEZ1bmM7XG5cdGV4cG9ydHMuQW1iaWVudExpZ2h0ID0gQW1iaWVudExpZ2h0O1xuXHRleHBvcnRzLkFtYmllbnRMaWdodFByb2JlID0gQW1iaWVudExpZ2h0UHJvYmU7XG5cdGV4cG9ydHMuQW5pbWF0aW9uQ2xpcCA9IEFuaW1hdGlvbkNsaXA7XG5cdGV4cG9ydHMuQW5pbWF0aW9uTG9hZGVyID0gQW5pbWF0aW9uTG9hZGVyO1xuXHRleHBvcnRzLkFuaW1hdGlvbk1peGVyID0gQW5pbWF0aW9uTWl4ZXI7XG5cdGV4cG9ydHMuQW5pbWF0aW9uT2JqZWN0R3JvdXAgPSBBbmltYXRpb25PYmplY3RHcm91cDtcblx0ZXhwb3J0cy5BbmltYXRpb25VdGlscyA9IEFuaW1hdGlvblV0aWxzO1xuXHRleHBvcnRzLkFyY0N1cnZlID0gQXJjQ3VydmU7XG5cdGV4cG9ydHMuQXJyYXlDYW1lcmEgPSBBcnJheUNhbWVyYTtcblx0ZXhwb3J0cy5BcnJvd0hlbHBlciA9IEFycm93SGVscGVyO1xuXHRleHBvcnRzLkF1ZGlvID0gQXVkaW87XG5cdGV4cG9ydHMuQXVkaW9BbmFseXNlciA9IEF1ZGlvQW5hbHlzZXI7XG5cdGV4cG9ydHMuQXVkaW9Db250ZXh0ID0gQXVkaW9Db250ZXh0O1xuXHRleHBvcnRzLkF1ZGlvTGlzdGVuZXIgPSBBdWRpb0xpc3RlbmVyO1xuXHRleHBvcnRzLkF1ZGlvTG9hZGVyID0gQXVkaW9Mb2FkZXI7XG5cdGV4cG9ydHMuQXhlc0hlbHBlciA9IEF4ZXNIZWxwZXI7XG5cdGV4cG9ydHMuQXhpc0hlbHBlciA9IEF4aXNIZWxwZXI7XG5cdGV4cG9ydHMuQmFja1NpZGUgPSBCYWNrU2lkZTtcblx0ZXhwb3J0cy5CYXNpY0RlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nO1xuXHRleHBvcnRzLkJhc2ljU2hhZG93TWFwID0gQmFzaWNTaGFkb3dNYXA7XG5cdGV4cG9ydHMuQmluYXJ5VGV4dHVyZUxvYWRlciA9IEJpbmFyeVRleHR1cmVMb2FkZXI7XG5cdGV4cG9ydHMuQm9uZSA9IEJvbmU7XG5cdGV4cG9ydHMuQm9vbGVhbktleWZyYW1lVHJhY2sgPSBCb29sZWFuS2V5ZnJhbWVUcmFjaztcblx0ZXhwb3J0cy5Cb3VuZGluZ0JveEhlbHBlciA9IEJvdW5kaW5nQm94SGVscGVyO1xuXHRleHBvcnRzLkJveDIgPSBCb3gyO1xuXHRleHBvcnRzLkJveDMgPSBCb3gzO1xuXHRleHBvcnRzLkJveDNIZWxwZXIgPSBCb3gzSGVscGVyO1xuXHRleHBvcnRzLkJveEJ1ZmZlckdlb21ldHJ5ID0gQm94R2VvbWV0cnk7XG5cdGV4cG9ydHMuQm94R2VvbWV0cnkgPSBCb3hHZW9tZXRyeTtcblx0ZXhwb3J0cy5Cb3hIZWxwZXIgPSBCb3hIZWxwZXI7XG5cdGV4cG9ydHMuQnVmZmVyQXR0cmlidXRlID0gQnVmZmVyQXR0cmlidXRlO1xuXHRleHBvcnRzLkJ1ZmZlckdlb21ldHJ5ID0gQnVmZmVyR2VvbWV0cnk7XG5cdGV4cG9ydHMuQnVmZmVyR2VvbWV0cnlMb2FkZXIgPSBCdWZmZXJHZW9tZXRyeUxvYWRlcjtcblx0ZXhwb3J0cy5CeXRlVHlwZSA9IEJ5dGVUeXBlO1xuXHRleHBvcnRzLkNhY2hlID0gQ2FjaGU7XG5cdGV4cG9ydHMuQ2FtZXJhID0gQ2FtZXJhO1xuXHRleHBvcnRzLkNhbWVyYUhlbHBlciA9IENhbWVyYUhlbHBlcjtcblx0ZXhwb3J0cy5DYW52YXNSZW5kZXJlciA9IENhbnZhc1JlbmRlcmVyO1xuXHRleHBvcnRzLkNhbnZhc1RleHR1cmUgPSBDYW52YXNUZXh0dXJlO1xuXHRleHBvcnRzLkNhdG11bGxSb21DdXJ2ZTMgPSBDYXRtdWxsUm9tQ3VydmUzO1xuXHRleHBvcnRzLkNpbmVvblRvbmVNYXBwaW5nID0gQ2luZW9uVG9uZU1hcHBpbmc7XG5cdGV4cG9ydHMuQ2lyY2xlQnVmZmVyR2VvbWV0cnkgPSBDaXJjbGVHZW9tZXRyeTtcblx0ZXhwb3J0cy5DaXJjbGVHZW9tZXRyeSA9IENpcmNsZUdlb21ldHJ5O1xuXHRleHBvcnRzLkNsYW1wVG9FZGdlV3JhcHBpbmcgPSBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuXHRleHBvcnRzLkNsb2NrID0gQ2xvY2s7XG5cdGV4cG9ydHMuQ29sb3IgPSBDb2xvcjtcblx0ZXhwb3J0cy5Db2xvcktleWZyYW1lVHJhY2sgPSBDb2xvcktleWZyYW1lVHJhY2s7XG5cdGV4cG9ydHMuQ29tcHJlc3NlZFRleHR1cmUgPSBDb21wcmVzc2VkVGV4dHVyZTtcblx0ZXhwb3J0cy5Db21wcmVzc2VkVGV4dHVyZUxvYWRlciA9IENvbXByZXNzZWRUZXh0dXJlTG9hZGVyO1xuXHRleHBvcnRzLkNvbmVCdWZmZXJHZW9tZXRyeSA9IENvbmVHZW9tZXRyeTtcblx0ZXhwb3J0cy5Db25lR2VvbWV0cnkgPSBDb25lR2VvbWV0cnk7XG5cdGV4cG9ydHMuQ3ViZUNhbWVyYSA9IEN1YmVDYW1lcmE7XG5cdGV4cG9ydHMuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nID0gQ3ViZVJlZmxlY3Rpb25NYXBwaW5nO1xuXHRleHBvcnRzLkN1YmVSZWZyYWN0aW9uTWFwcGluZyA9IEN1YmVSZWZyYWN0aW9uTWFwcGluZztcblx0ZXhwb3J0cy5DdWJlVGV4dHVyZSA9IEN1YmVUZXh0dXJlO1xuXHRleHBvcnRzLkN1YmVUZXh0dXJlTG9hZGVyID0gQ3ViZVRleHR1cmVMb2FkZXI7XG5cdGV4cG9ydHMuQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcgPSBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZztcblx0ZXhwb3J0cy5DdWJlVVZSZWZyYWN0aW9uTWFwcGluZyA9IEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nO1xuXHRleHBvcnRzLkN1YmljQmV6aWVyQ3VydmUgPSBDdWJpY0JlemllckN1cnZlO1xuXHRleHBvcnRzLkN1YmljQmV6aWVyQ3VydmUzID0gQ3ViaWNCZXppZXJDdXJ2ZTM7XG5cdGV4cG9ydHMuQ3ViaWNJbnRlcnBvbGFudCA9IEN1YmljSW50ZXJwb2xhbnQ7XG5cdGV4cG9ydHMuQ3VsbEZhY2VCYWNrID0gQ3VsbEZhY2VCYWNrO1xuXHRleHBvcnRzLkN1bGxGYWNlRnJvbnQgPSBDdWxsRmFjZUZyb250O1xuXHRleHBvcnRzLkN1bGxGYWNlRnJvbnRCYWNrID0gQ3VsbEZhY2VGcm9udEJhY2s7XG5cdGV4cG9ydHMuQ3VsbEZhY2VOb25lID0gQ3VsbEZhY2VOb25lO1xuXHRleHBvcnRzLkN1cnZlID0gQ3VydmU7XG5cdGV4cG9ydHMuQ3VydmVQYXRoID0gQ3VydmVQYXRoO1xuXHRleHBvcnRzLkN1c3RvbUJsZW5kaW5nID0gQ3VzdG9tQmxlbmRpbmc7XG5cdGV4cG9ydHMuQ3VzdG9tVG9uZU1hcHBpbmcgPSBDdXN0b21Ub25lTWFwcGluZztcblx0ZXhwb3J0cy5DeWxpbmRlckJ1ZmZlckdlb21ldHJ5ID0gQ3lsaW5kZXJHZW9tZXRyeTtcblx0ZXhwb3J0cy5DeWxpbmRlckdlb21ldHJ5ID0gQ3lsaW5kZXJHZW9tZXRyeTtcblx0ZXhwb3J0cy5DeWxpbmRyaWNhbCA9IEN5bGluZHJpY2FsO1xuXHRleHBvcnRzLkRhdGFUZXh0dXJlID0gRGF0YVRleHR1cmU7XG5cdGV4cG9ydHMuRGF0YVRleHR1cmUyREFycmF5ID0gRGF0YVRleHR1cmUyREFycmF5O1xuXHRleHBvcnRzLkRhdGFUZXh0dXJlM0QgPSBEYXRhVGV4dHVyZTNEO1xuXHRleHBvcnRzLkRhdGFUZXh0dXJlTG9hZGVyID0gRGF0YVRleHR1cmVMb2FkZXI7XG5cdGV4cG9ydHMuRGF0YVV0aWxzID0gRGF0YVV0aWxzO1xuXHRleHBvcnRzLkRlY3JlbWVudFN0ZW5jaWxPcCA9IERlY3JlbWVudFN0ZW5jaWxPcDtcblx0ZXhwb3J0cy5EZWNyZW1lbnRXcmFwU3RlbmNpbE9wID0gRGVjcmVtZW50V3JhcFN0ZW5jaWxPcDtcblx0ZXhwb3J0cy5EZWZhdWx0TG9hZGluZ01hbmFnZXIgPSBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cdGV4cG9ydHMuRGVwdGhGb3JtYXQgPSBEZXB0aEZvcm1hdDtcblx0ZXhwb3J0cy5EZXB0aFN0ZW5jaWxGb3JtYXQgPSBEZXB0aFN0ZW5jaWxGb3JtYXQ7XG5cdGV4cG9ydHMuRGVwdGhUZXh0dXJlID0gRGVwdGhUZXh0dXJlO1xuXHRleHBvcnRzLkRpcmVjdGlvbmFsTGlnaHQgPSBEaXJlY3Rpb25hbExpZ2h0O1xuXHRleHBvcnRzLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIgPSBEaXJlY3Rpb25hbExpZ2h0SGVscGVyO1xuXHRleHBvcnRzLkRpc2NyZXRlSW50ZXJwb2xhbnQgPSBEaXNjcmV0ZUludGVycG9sYW50O1xuXHRleHBvcnRzLkRvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gRG9kZWNhaGVkcm9uR2VvbWV0cnk7XG5cdGV4cG9ydHMuRG9kZWNhaGVkcm9uR2VvbWV0cnkgPSBEb2RlY2FoZWRyb25HZW9tZXRyeTtcblx0ZXhwb3J0cy5Eb3VibGVTaWRlID0gRG91YmxlU2lkZTtcblx0ZXhwb3J0cy5Ec3RBbHBoYUZhY3RvciA9IERzdEFscGhhRmFjdG9yO1xuXHRleHBvcnRzLkRzdENvbG9yRmFjdG9yID0gRHN0Q29sb3JGYWN0b3I7XG5cdGV4cG9ydHMuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZSA9IER5bmFtaWNCdWZmZXJBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuRHluYW1pY0NvcHlVc2FnZSA9IER5bmFtaWNDb3B5VXNhZ2U7XG5cdGV4cG9ydHMuRHluYW1pY0RyYXdVc2FnZSA9IER5bmFtaWNEcmF3VXNhZ2U7XG5cdGV4cG9ydHMuRHluYW1pY1JlYWRVc2FnZSA9IER5bmFtaWNSZWFkVXNhZ2U7XG5cdGV4cG9ydHMuRWRnZXNHZW9tZXRyeSA9IEVkZ2VzR2VvbWV0cnk7XG5cdGV4cG9ydHMuRWRnZXNIZWxwZXIgPSBFZGdlc0hlbHBlcjtcblx0ZXhwb3J0cy5FbGxpcHNlQ3VydmUgPSBFbGxpcHNlQ3VydmU7XG5cdGV4cG9ydHMuRXF1YWxEZXB0aCA9IEVxdWFsRGVwdGg7XG5cdGV4cG9ydHMuRXF1YWxTdGVuY2lsRnVuYyA9IEVxdWFsU3RlbmNpbEZ1bmM7XG5cdGV4cG9ydHMuRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgPSBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZztcblx0ZXhwb3J0cy5FcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyA9IEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nO1xuXHRleHBvcnRzLkV1bGVyID0gRXVsZXI7XG5cdGV4cG9ydHMuRXZlbnREaXNwYXRjaGVyID0gRXZlbnREaXNwYXRjaGVyO1xuXHRleHBvcnRzLkV4dHJ1ZGVCdWZmZXJHZW9tZXRyeSA9IEV4dHJ1ZGVHZW9tZXRyeTtcblx0ZXhwb3J0cy5FeHRydWRlR2VvbWV0cnkgPSBFeHRydWRlR2VvbWV0cnk7XG5cdGV4cG9ydHMuRmFjZUNvbG9ycyA9IEZhY2VDb2xvcnM7XG5cdGV4cG9ydHMuRmlsZUxvYWRlciA9IEZpbGVMb2FkZXI7XG5cdGV4cG9ydHMuRmxhdFNoYWRpbmcgPSBGbGF0U2hhZGluZztcblx0ZXhwb3J0cy5GbG9hdDE2QnVmZmVyQXR0cmlidXRlID0gRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5GbG9hdDMyQXR0cmlidXRlID0gRmxvYXQzMkF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5GbG9hdDMyQnVmZmVyQXR0cmlidXRlID0gRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5GbG9hdDY0QXR0cmlidXRlID0gRmxvYXQ2NEF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5GbG9hdDY0QnVmZmVyQXR0cmlidXRlID0gRmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5GbG9hdFR5cGUgPSBGbG9hdFR5cGU7XG5cdGV4cG9ydHMuRm9nID0gRm9nO1xuXHRleHBvcnRzLkZvZ0V4cDIgPSBGb2dFeHAyO1xuXHRleHBvcnRzLkZvbnQgPSBGb250O1xuXHRleHBvcnRzLkZvbnRMb2FkZXIgPSBGb250TG9hZGVyO1xuXHRleHBvcnRzLkZyb250U2lkZSA9IEZyb250U2lkZTtcblx0ZXhwb3J0cy5GcnVzdHVtID0gRnJ1c3R1bTtcblx0ZXhwb3J0cy5HTEJ1ZmZlckF0dHJpYnV0ZSA9IEdMQnVmZmVyQXR0cmlidXRlO1xuXHRleHBvcnRzLkdMU0wxID0gR0xTTDE7XG5cdGV4cG9ydHMuR0xTTDMgPSBHTFNMMztcblx0ZXhwb3J0cy5HYW1tYUVuY29kaW5nID0gR2FtbWFFbmNvZGluZztcblx0ZXhwb3J0cy5HcmVhdGVyRGVwdGggPSBHcmVhdGVyRGVwdGg7XG5cdGV4cG9ydHMuR3JlYXRlckVxdWFsRGVwdGggPSBHcmVhdGVyRXF1YWxEZXB0aDtcblx0ZXhwb3J0cy5HcmVhdGVyRXF1YWxTdGVuY2lsRnVuYyA9IEdyZWF0ZXJFcXVhbFN0ZW5jaWxGdW5jO1xuXHRleHBvcnRzLkdyZWF0ZXJTdGVuY2lsRnVuYyA9IEdyZWF0ZXJTdGVuY2lsRnVuYztcblx0ZXhwb3J0cy5HcmlkSGVscGVyID0gR3JpZEhlbHBlcjtcblx0ZXhwb3J0cy5Hcm91cCA9IEdyb3VwO1xuXHRleHBvcnRzLkhhbGZGbG9hdFR5cGUgPSBIYWxmRmxvYXRUeXBlO1xuXHRleHBvcnRzLkhlbWlzcGhlcmVMaWdodCA9IEhlbWlzcGhlcmVMaWdodDtcblx0ZXhwb3J0cy5IZW1pc3BoZXJlTGlnaHRIZWxwZXIgPSBIZW1pc3BoZXJlTGlnaHRIZWxwZXI7XG5cdGV4cG9ydHMuSGVtaXNwaGVyZUxpZ2h0UHJvYmUgPSBIZW1pc3BoZXJlTGlnaHRQcm9iZTtcblx0ZXhwb3J0cy5JY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gSWNvc2FoZWRyb25HZW9tZXRyeTtcblx0ZXhwb3J0cy5JY29zYWhlZHJvbkdlb21ldHJ5ID0gSWNvc2FoZWRyb25HZW9tZXRyeTtcblx0ZXhwb3J0cy5JbWFnZUJpdG1hcExvYWRlciA9IEltYWdlQml0bWFwTG9hZGVyO1xuXHRleHBvcnRzLkltYWdlTG9hZGVyID0gSW1hZ2VMb2FkZXI7XG5cdGV4cG9ydHMuSW1hZ2VVdGlscyA9IEltYWdlVXRpbHM7XG5cdGV4cG9ydHMuSW1tZWRpYXRlUmVuZGVyT2JqZWN0ID0gSW1tZWRpYXRlUmVuZGVyT2JqZWN0O1xuXHRleHBvcnRzLkluY3JlbWVudFN0ZW5jaWxPcCA9IEluY3JlbWVudFN0ZW5jaWxPcDtcblx0ZXhwb3J0cy5JbmNyZW1lbnRXcmFwU3RlbmNpbE9wID0gSW5jcmVtZW50V3JhcFN0ZW5jaWxPcDtcblx0ZXhwb3J0cy5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPSBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgPSBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeTtcblx0ZXhwb3J0cy5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciA9IEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyO1xuXHRleHBvcnRzLkluc3RhbmNlZE1lc2ggPSBJbnN0YW5jZWRNZXNoO1xuXHRleHBvcnRzLkludDE2QXR0cmlidXRlID0gSW50MTZBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuSW50MTZCdWZmZXJBdHRyaWJ1dGUgPSBJbnQxNkJ1ZmZlckF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5JbnQzMkF0dHJpYnV0ZSA9IEludDMyQXR0cmlidXRlO1xuXHRleHBvcnRzLkludDMyQnVmZmVyQXR0cmlidXRlID0gSW50MzJCdWZmZXJBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuSW50OEF0dHJpYnV0ZSA9IEludDhBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuSW50OEJ1ZmZlckF0dHJpYnV0ZSA9IEludDhCdWZmZXJBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuSW50VHlwZSA9IEludFR5cGU7XG5cdGV4cG9ydHMuSW50ZXJsZWF2ZWRCdWZmZXIgPSBJbnRlcmxlYXZlZEJ1ZmZlcjtcblx0ZXhwb3J0cy5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA9IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlO1xuXHRleHBvcnRzLkludGVycG9sYW50ID0gSW50ZXJwb2xhbnQ7XG5cdGV4cG9ydHMuSW50ZXJwb2xhdGVEaXNjcmV0ZSA9IEludGVycG9sYXRlRGlzY3JldGU7XG5cdGV4cG9ydHMuSW50ZXJwb2xhdGVMaW5lYXIgPSBJbnRlcnBvbGF0ZUxpbmVhcjtcblx0ZXhwb3J0cy5JbnRlcnBvbGF0ZVNtb290aCA9IEludGVycG9sYXRlU21vb3RoO1xuXHRleHBvcnRzLkludmVydFN0ZW5jaWxPcCA9IEludmVydFN0ZW5jaWxPcDtcblx0ZXhwb3J0cy5KU09OTG9hZGVyID0gSlNPTkxvYWRlcjtcblx0ZXhwb3J0cy5LZWVwU3RlbmNpbE9wID0gS2VlcFN0ZW5jaWxPcDtcblx0ZXhwb3J0cy5LZXlmcmFtZVRyYWNrID0gS2V5ZnJhbWVUcmFjaztcblx0ZXhwb3J0cy5MT0QgPSBMT0Q7XG5cdGV4cG9ydHMuTGF0aGVCdWZmZXJHZW9tZXRyeSA9IExhdGhlR2VvbWV0cnk7XG5cdGV4cG9ydHMuTGF0aGVHZW9tZXRyeSA9IExhdGhlR2VvbWV0cnk7XG5cdGV4cG9ydHMuTGF5ZXJzID0gTGF5ZXJzO1xuXHRleHBvcnRzLkxlbnNGbGFyZSA9IExlbnNGbGFyZTtcblx0ZXhwb3J0cy5MZXNzRGVwdGggPSBMZXNzRGVwdGg7XG5cdGV4cG9ydHMuTGVzc0VxdWFsRGVwdGggPSBMZXNzRXF1YWxEZXB0aDtcblx0ZXhwb3J0cy5MZXNzRXF1YWxTdGVuY2lsRnVuYyA9IExlc3NFcXVhbFN0ZW5jaWxGdW5jO1xuXHRleHBvcnRzLkxlc3NTdGVuY2lsRnVuYyA9IExlc3NTdGVuY2lsRnVuYztcblx0ZXhwb3J0cy5MaWdodCA9IExpZ2h0O1xuXHRleHBvcnRzLkxpZ2h0UHJvYmUgPSBMaWdodFByb2JlO1xuXHRleHBvcnRzLkxpbmUgPSBMaW5lO1xuXHRleHBvcnRzLkxpbmUzID0gTGluZTM7XG5cdGV4cG9ydHMuTGluZUJhc2ljTWF0ZXJpYWwgPSBMaW5lQmFzaWNNYXRlcmlhbDtcblx0ZXhwb3J0cy5MaW5lQ3VydmUgPSBMaW5lQ3VydmU7XG5cdGV4cG9ydHMuTGluZUN1cnZlMyA9IExpbmVDdXJ2ZTM7XG5cdGV4cG9ydHMuTGluZURhc2hlZE1hdGVyaWFsID0gTGluZURhc2hlZE1hdGVyaWFsO1xuXHRleHBvcnRzLkxpbmVMb29wID0gTGluZUxvb3A7XG5cdGV4cG9ydHMuTGluZVBpZWNlcyA9IExpbmVQaWVjZXM7XG5cdGV4cG9ydHMuTGluZVNlZ21lbnRzID0gTGluZVNlZ21lbnRzO1xuXHRleHBvcnRzLkxpbmVTdHJpcCA9IExpbmVTdHJpcDtcblx0ZXhwb3J0cy5MaW5lYXJFbmNvZGluZyA9IExpbmVhckVuY29kaW5nO1xuXHRleHBvcnRzLkxpbmVhckZpbHRlciA9IExpbmVhckZpbHRlcjtcblx0ZXhwb3J0cy5MaW5lYXJJbnRlcnBvbGFudCA9IExpbmVhckludGVycG9sYW50O1xuXHRleHBvcnRzLkxpbmVhck1pcE1hcExpbmVhckZpbHRlciA9IExpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcblx0ZXhwb3J0cy5MaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyID0gTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlcjtcblx0ZXhwb3J0cy5MaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIgPSBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXI7XG5cdGV4cG9ydHMuTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciA9IExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXI7XG5cdGV4cG9ydHMuTGluZWFyVG9uZU1hcHBpbmcgPSBMaW5lYXJUb25lTWFwcGluZztcblx0ZXhwb3J0cy5Mb2FkZXIgPSBMb2FkZXI7XG5cdGV4cG9ydHMuTG9hZGVyVXRpbHMgPSBMb2FkZXJVdGlscztcblx0ZXhwb3J0cy5Mb2FkaW5nTWFuYWdlciA9IExvYWRpbmdNYW5hZ2VyO1xuXHRleHBvcnRzLkxvb3BPbmNlID0gTG9vcE9uY2U7XG5cdGV4cG9ydHMuTG9vcFBpbmdQb25nID0gTG9vcFBpbmdQb25nO1xuXHRleHBvcnRzLkxvb3BSZXBlYXQgPSBMb29wUmVwZWF0O1xuXHRleHBvcnRzLkx1bWluYW5jZUFscGhhRm9ybWF0ID0gTHVtaW5hbmNlQWxwaGFGb3JtYXQ7XG5cdGV4cG9ydHMuTHVtaW5hbmNlRm9ybWF0ID0gTHVtaW5hbmNlRm9ybWF0O1xuXHRleHBvcnRzLk1PVVNFID0gTU9VU0U7XG5cdGV4cG9ydHMuTWF0ZXJpYWwgPSBNYXRlcmlhbDtcblx0ZXhwb3J0cy5NYXRlcmlhbExvYWRlciA9IE1hdGVyaWFsTG9hZGVyO1xuXHRleHBvcnRzLk1hdGggPSBNYXRoVXRpbHM7XG5cdGV4cG9ydHMuTWF0aFV0aWxzID0gTWF0aFV0aWxzO1xuXHRleHBvcnRzLk1hdHJpeDMgPSBNYXRyaXgzO1xuXHRleHBvcnRzLk1hdHJpeDQgPSBNYXRyaXg0O1xuXHRleHBvcnRzLk1heEVxdWF0aW9uID0gTWF4RXF1YXRpb247XG5cdGV4cG9ydHMuTWVzaCA9IE1lc2g7XG5cdGV4cG9ydHMuTWVzaEJhc2ljTWF0ZXJpYWwgPSBNZXNoQmFzaWNNYXRlcmlhbDtcblx0ZXhwb3J0cy5NZXNoRGVwdGhNYXRlcmlhbCA9IE1lc2hEZXB0aE1hdGVyaWFsO1xuXHRleHBvcnRzLk1lc2hEaXN0YW5jZU1hdGVyaWFsID0gTWVzaERpc3RhbmNlTWF0ZXJpYWw7XG5cdGV4cG9ydHMuTWVzaEZhY2VNYXRlcmlhbCA9IE1lc2hGYWNlTWF0ZXJpYWw7XG5cdGV4cG9ydHMuTWVzaExhbWJlcnRNYXRlcmlhbCA9IE1lc2hMYW1iZXJ0TWF0ZXJpYWw7XG5cdGV4cG9ydHMuTWVzaE1hdGNhcE1hdGVyaWFsID0gTWVzaE1hdGNhcE1hdGVyaWFsO1xuXHRleHBvcnRzLk1lc2hOb3JtYWxNYXRlcmlhbCA9IE1lc2hOb3JtYWxNYXRlcmlhbDtcblx0ZXhwb3J0cy5NZXNoUGhvbmdNYXRlcmlhbCA9IE1lc2hQaG9uZ01hdGVyaWFsO1xuXHRleHBvcnRzLk1lc2hQaHlzaWNhbE1hdGVyaWFsID0gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG5cdGV4cG9ydHMuTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPSBNZXNoU3RhbmRhcmRNYXRlcmlhbDtcblx0ZXhwb3J0cy5NZXNoVG9vbk1hdGVyaWFsID0gTWVzaFRvb25NYXRlcmlhbDtcblx0ZXhwb3J0cy5NaW5FcXVhdGlvbiA9IE1pbkVxdWF0aW9uO1xuXHRleHBvcnRzLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgPSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nO1xuXHRleHBvcnRzLk1peE9wZXJhdGlvbiA9IE1peE9wZXJhdGlvbjtcblx0ZXhwb3J0cy5NdWx0aU1hdGVyaWFsID0gTXVsdGlNYXRlcmlhbDtcblx0ZXhwb3J0cy5NdWx0aXBseUJsZW5kaW5nID0gTXVsdGlwbHlCbGVuZGluZztcblx0ZXhwb3J0cy5NdWx0aXBseU9wZXJhdGlvbiA9IE11bHRpcGx5T3BlcmF0aW9uO1xuXHRleHBvcnRzLk5lYXJlc3RGaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xuXHRleHBvcnRzLk5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgPSBOZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyO1xuXHRleHBvcnRzLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyID0gTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXI7XG5cdGV4cG9ydHMuTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlciA9IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXI7XG5cdGV4cG9ydHMuTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIgPSBOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlcjtcblx0ZXhwb3J0cy5OZXZlckRlcHRoID0gTmV2ZXJEZXB0aDtcblx0ZXhwb3J0cy5OZXZlclN0ZW5jaWxGdW5jID0gTmV2ZXJTdGVuY2lsRnVuYztcblx0ZXhwb3J0cy5Ob0JsZW5kaW5nID0gTm9CbGVuZGluZztcblx0ZXhwb3J0cy5Ob0NvbG9ycyA9IE5vQ29sb3JzO1xuXHRleHBvcnRzLk5vVG9uZU1hcHBpbmcgPSBOb1RvbmVNYXBwaW5nO1xuXHRleHBvcnRzLk5vcm1hbEFuaW1hdGlvbkJsZW5kTW9kZSA9IE5vcm1hbEFuaW1hdGlvbkJsZW5kTW9kZTtcblx0ZXhwb3J0cy5Ob3JtYWxCbGVuZGluZyA9IE5vcm1hbEJsZW5kaW5nO1xuXHRleHBvcnRzLk5vdEVxdWFsRGVwdGggPSBOb3RFcXVhbERlcHRoO1xuXHRleHBvcnRzLk5vdEVxdWFsU3RlbmNpbEZ1bmMgPSBOb3RFcXVhbFN0ZW5jaWxGdW5jO1xuXHRleHBvcnRzLk51bWJlcktleWZyYW1lVHJhY2sgPSBOdW1iZXJLZXlmcmFtZVRyYWNrO1xuXHRleHBvcnRzLk9iamVjdDNEID0gT2JqZWN0M0Q7XG5cdGV4cG9ydHMuT2JqZWN0TG9hZGVyID0gT2JqZWN0TG9hZGVyO1xuXHRleHBvcnRzLk9iamVjdFNwYWNlTm9ybWFsTWFwID0gT2JqZWN0U3BhY2VOb3JtYWxNYXA7XG5cdGV4cG9ydHMuT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gT2N0YWhlZHJvbkdlb21ldHJ5O1xuXHRleHBvcnRzLk9jdGFoZWRyb25HZW9tZXRyeSA9IE9jdGFoZWRyb25HZW9tZXRyeTtcblx0ZXhwb3J0cy5PbmVGYWN0b3IgPSBPbmVGYWN0b3I7XG5cdGV4cG9ydHMuT25lTWludXNEc3RBbHBoYUZhY3RvciA9IE9uZU1pbnVzRHN0QWxwaGFGYWN0b3I7XG5cdGV4cG9ydHMuT25lTWludXNEc3RDb2xvckZhY3RvciA9IE9uZU1pbnVzRHN0Q29sb3JGYWN0b3I7XG5cdGV4cG9ydHMuT25lTWludXNTcmNBbHBoYUZhY3RvciA9IE9uZU1pbnVzU3JjQWxwaGFGYWN0b3I7XG5cdGV4cG9ydHMuT25lTWludXNTcmNDb2xvckZhY3RvciA9IE9uZU1pbnVzU3JjQ29sb3JGYWN0b3I7XG5cdGV4cG9ydHMuT3J0aG9ncmFwaGljQ2FtZXJhID0gT3J0aG9ncmFwaGljQ2FtZXJhO1xuXHRleHBvcnRzLlBDRlNoYWRvd01hcCA9IFBDRlNoYWRvd01hcDtcblx0ZXhwb3J0cy5QQ0ZTb2Z0U2hhZG93TWFwID0gUENGU29mdFNoYWRvd01hcDtcblx0ZXhwb3J0cy5QTVJFTUdlbmVyYXRvciA9IFBNUkVNR2VuZXJhdG9yO1xuXHRleHBvcnRzLlBhcmFtZXRyaWNHZW9tZXRyeSA9IFBhcmFtZXRyaWNHZW9tZXRyeTtcblx0ZXhwb3J0cy5QYXJ0aWNsZSA9IFBhcnRpY2xlO1xuXHRleHBvcnRzLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCA9IFBhcnRpY2xlQmFzaWNNYXRlcmlhbDtcblx0ZXhwb3J0cy5QYXJ0aWNsZVN5c3RlbSA9IFBhcnRpY2xlU3lzdGVtO1xuXHRleHBvcnRzLlBhcnRpY2xlU3lzdGVtTWF0ZXJpYWwgPSBQYXJ0aWNsZVN5c3RlbU1hdGVyaWFsO1xuXHRleHBvcnRzLlBhdGggPSBQYXRoO1xuXHRleHBvcnRzLlBlcnNwZWN0aXZlQ2FtZXJhID0gUGVyc3BlY3RpdmVDYW1lcmE7XG5cdGV4cG9ydHMuUGxhbmUgPSBQbGFuZTtcblx0ZXhwb3J0cy5QbGFuZUJ1ZmZlckdlb21ldHJ5ID0gUGxhbmVHZW9tZXRyeTtcblx0ZXhwb3J0cy5QbGFuZUdlb21ldHJ5ID0gUGxhbmVHZW9tZXRyeTtcblx0ZXhwb3J0cy5QbGFuZUhlbHBlciA9IFBsYW5lSGVscGVyO1xuXHRleHBvcnRzLlBvaW50Q2xvdWQgPSBQb2ludENsb3VkO1xuXHRleHBvcnRzLlBvaW50Q2xvdWRNYXRlcmlhbCA9IFBvaW50Q2xvdWRNYXRlcmlhbDtcblx0ZXhwb3J0cy5Qb2ludExpZ2h0ID0gUG9pbnRMaWdodDtcblx0ZXhwb3J0cy5Qb2ludExpZ2h0SGVscGVyID0gUG9pbnRMaWdodEhlbHBlcjtcblx0ZXhwb3J0cy5Qb2ludHMgPSBQb2ludHM7XG5cdGV4cG9ydHMuUG9pbnRzTWF0ZXJpYWwgPSBQb2ludHNNYXRlcmlhbDtcblx0ZXhwb3J0cy5Qb2xhckdyaWRIZWxwZXIgPSBQb2xhckdyaWRIZWxwZXI7XG5cdGV4cG9ydHMuUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gUG9seWhlZHJvbkdlb21ldHJ5O1xuXHRleHBvcnRzLlBvbHloZWRyb25HZW9tZXRyeSA9IFBvbHloZWRyb25HZW9tZXRyeTtcblx0ZXhwb3J0cy5Qb3NpdGlvbmFsQXVkaW8gPSBQb3NpdGlvbmFsQXVkaW87XG5cdGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nID0gUHJvcGVydHlCaW5kaW5nO1xuXHRleHBvcnRzLlByb3BlcnR5TWl4ZXIgPSBQcm9wZXJ0eU1peGVyO1xuXHRleHBvcnRzLlF1YWRyYXRpY0JlemllckN1cnZlID0gUXVhZHJhdGljQmV6aWVyQ3VydmU7XG5cdGV4cG9ydHMuUXVhZHJhdGljQmV6aWVyQ3VydmUzID0gUXVhZHJhdGljQmV6aWVyQ3VydmUzO1xuXHRleHBvcnRzLlF1YXRlcm5pb24gPSBRdWF0ZXJuaW9uO1xuXHRleHBvcnRzLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrID0gUXVhdGVybmlvbktleWZyYW1lVHJhY2s7XG5cdGV4cG9ydHMuUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50ID0gUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50O1xuXHRleHBvcnRzLlJFVklTSU9OID0gUkVWSVNJT047XG5cdGV4cG9ydHMuUkdCQURlcHRoUGFja2luZyA9IFJHQkFEZXB0aFBhY2tpbmc7XG5cdGV4cG9ydHMuUkdCQUZvcm1hdCA9IFJHQkFGb3JtYXQ7XG5cdGV4cG9ydHMuUkdCQUludGVnZXJGb3JtYXQgPSBSR0JBSW50ZWdlckZvcm1hdDtcblx0ZXhwb3J0cy5SR0JBX0FTVENfMTB4MTBfRm9ybWF0ID0gUkdCQV9BU1RDXzEweDEwX0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JBX0FTVENfMTB4NV9Gb3JtYXQgPSBSR0JBX0FTVENfMTB4NV9Gb3JtYXQ7XG5cdGV4cG9ydHMuUkdCQV9BU1RDXzEweDZfRm9ybWF0ID0gUkdCQV9BU1RDXzEweDZfRm9ybWF0O1xuXHRleHBvcnRzLlJHQkFfQVNUQ18xMHg4X0Zvcm1hdCA9IFJHQkFfQVNUQ18xMHg4X0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JBX0FTVENfMTJ4MTBfRm9ybWF0ID0gUkdCQV9BU1RDXzEyeDEwX0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JBX0FTVENfMTJ4MTJfRm9ybWF0ID0gUkdCQV9BU1RDXzEyeDEyX0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JBX0FTVENfNHg0X0Zvcm1hdCA9IFJHQkFfQVNUQ180eDRfRm9ybWF0O1xuXHRleHBvcnRzLlJHQkFfQVNUQ181eDRfRm9ybWF0ID0gUkdCQV9BU1RDXzV4NF9Gb3JtYXQ7XG5cdGV4cG9ydHMuUkdCQV9BU1RDXzV4NV9Gb3JtYXQgPSBSR0JBX0FTVENfNXg1X0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JBX0FTVENfNng1X0Zvcm1hdCA9IFJHQkFfQVNUQ182eDVfRm9ybWF0O1xuXHRleHBvcnRzLlJHQkFfQVNUQ182eDZfRm9ybWF0ID0gUkdCQV9BU1RDXzZ4Nl9Gb3JtYXQ7XG5cdGV4cG9ydHMuUkdCQV9BU1RDXzh4NV9Gb3JtYXQgPSBSR0JBX0FTVENfOHg1X0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JBX0FTVENfOHg2X0Zvcm1hdCA9IFJHQkFfQVNUQ184eDZfRm9ybWF0O1xuXHRleHBvcnRzLlJHQkFfQVNUQ184eDhfRm9ybWF0ID0gUkdCQV9BU1RDXzh4OF9Gb3JtYXQ7XG5cdGV4cG9ydHMuUkdCQV9CUFRDX0Zvcm1hdCA9IFJHQkFfQlBUQ19Gb3JtYXQ7XG5cdGV4cG9ydHMuUkdCQV9FVEMyX0VBQ19Gb3JtYXQgPSBSR0JBX0VUQzJfRUFDX0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSBSR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQ7XG5cdGV4cG9ydHMuUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ID0gUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0O1xuXHRleHBvcnRzLlJHQkFfUzNUQ19EWFQxX0Zvcm1hdCA9IFJHQkFfUzNUQ19EWFQxX0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JBX1MzVENfRFhUM19Gb3JtYXQgPSBSR0JBX1MzVENfRFhUM19Gb3JtYXQ7XG5cdGV4cG9ydHMuUkdCQV9TM1RDX0RYVDVfRm9ybWF0ID0gUkdCQV9TM1RDX0RYVDVfRm9ybWF0O1xuXHRleHBvcnRzLlJHQkRFbmNvZGluZyA9IFJHQkRFbmNvZGluZztcblx0ZXhwb3J0cy5SR0JFRW5jb2RpbmcgPSBSR0JFRW5jb2Rpbmc7XG5cdGV4cG9ydHMuUkdCRUZvcm1hdCA9IFJHQkVGb3JtYXQ7XG5cdGV4cG9ydHMuUkdCRm9ybWF0ID0gUkdCRm9ybWF0O1xuXHRleHBvcnRzLlJHQkludGVnZXJGb3JtYXQgPSBSR0JJbnRlZ2VyRm9ybWF0O1xuXHRleHBvcnRzLlJHQk0xNkVuY29kaW5nID0gUkdCTTE2RW5jb2Rpbmc7XG5cdGV4cG9ydHMuUkdCTTdFbmNvZGluZyA9IFJHQk03RW5jb2Rpbmc7XG5cdGV4cG9ydHMuUkdCX0VUQzFfRm9ybWF0ID0gUkdCX0VUQzFfRm9ybWF0O1xuXHRleHBvcnRzLlJHQl9FVEMyX0Zvcm1hdCA9IFJHQl9FVEMyX0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0O1xuXHRleHBvcnRzLlJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ID0gUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQ7XG5cdGV4cG9ydHMuUkdCX1MzVENfRFhUMV9Gb3JtYXQgPSBSR0JfUzNUQ19EWFQxX0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0Zvcm1hdCA9IFJHRm9ybWF0O1xuXHRleHBvcnRzLlJHSW50ZWdlckZvcm1hdCA9IFJHSW50ZWdlckZvcm1hdDtcblx0ZXhwb3J0cy5SYXdTaGFkZXJNYXRlcmlhbCA9IFJhd1NoYWRlck1hdGVyaWFsO1xuXHRleHBvcnRzLlJheSA9IFJheTtcblx0ZXhwb3J0cy5SYXljYXN0ZXIgPSBSYXljYXN0ZXI7XG5cdGV4cG9ydHMuUmVjdEFyZWFMaWdodCA9IFJlY3RBcmVhTGlnaHQ7XG5cdGV4cG9ydHMuUmVkRm9ybWF0ID0gUmVkRm9ybWF0O1xuXHRleHBvcnRzLlJlZEludGVnZXJGb3JtYXQgPSBSZWRJbnRlZ2VyRm9ybWF0O1xuXHRleHBvcnRzLlJlaW5oYXJkVG9uZU1hcHBpbmcgPSBSZWluaGFyZFRvbmVNYXBwaW5nO1xuXHRleHBvcnRzLlJlcGVhdFdyYXBwaW5nID0gUmVwZWF0V3JhcHBpbmc7XG5cdGV4cG9ydHMuUmVwbGFjZVN0ZW5jaWxPcCA9IFJlcGxhY2VTdGVuY2lsT3A7XG5cdGV4cG9ydHMuUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gPSBSZXZlcnNlU3VidHJhY3RFcXVhdGlvbjtcblx0ZXhwb3J0cy5SaW5nQnVmZmVyR2VvbWV0cnkgPSBSaW5nR2VvbWV0cnk7XG5cdGV4cG9ydHMuUmluZ0dlb21ldHJ5ID0gUmluZ0dlb21ldHJ5O1xuXHRleHBvcnRzLlNSR0I4X0FMUEhBOF9BU1RDXzEweDEwX0Zvcm1hdCA9IFNSR0I4X0FMUEhBOF9BU1RDXzEweDEwX0Zvcm1hdDtcblx0ZXhwb3J0cy5TUkdCOF9BTFBIQThfQVNUQ18xMHg1X0Zvcm1hdCA9IFNSR0I4X0FMUEhBOF9BU1RDXzEweDVfRm9ybWF0O1xuXHRleHBvcnRzLlNSR0I4X0FMUEhBOF9BU1RDXzEweDZfRm9ybWF0ID0gU1JHQjhfQUxQSEE4X0FTVENfMTB4Nl9Gb3JtYXQ7XG5cdGV4cG9ydHMuU1JHQjhfQUxQSEE4X0FTVENfMTB4OF9Gb3JtYXQgPSBTUkdCOF9BTFBIQThfQVNUQ18xMHg4X0Zvcm1hdDtcblx0ZXhwb3J0cy5TUkdCOF9BTFBIQThfQVNUQ18xMngxMF9Gb3JtYXQgPSBTUkdCOF9BTFBIQThfQVNUQ18xMngxMF9Gb3JtYXQ7XG5cdGV4cG9ydHMuU1JHQjhfQUxQSEE4X0FTVENfMTJ4MTJfRm9ybWF0ID0gU1JHQjhfQUxQSEE4X0FTVENfMTJ4MTJfRm9ybWF0O1xuXHRleHBvcnRzLlNSR0I4X0FMUEhBOF9BU1RDXzR4NF9Gb3JtYXQgPSBTUkdCOF9BTFBIQThfQVNUQ180eDRfRm9ybWF0O1xuXHRleHBvcnRzLlNSR0I4X0FMUEhBOF9BU1RDXzV4NF9Gb3JtYXQgPSBTUkdCOF9BTFBIQThfQVNUQ181eDRfRm9ybWF0O1xuXHRleHBvcnRzLlNSR0I4X0FMUEhBOF9BU1RDXzV4NV9Gb3JtYXQgPSBTUkdCOF9BTFBIQThfQVNUQ181eDVfRm9ybWF0O1xuXHRleHBvcnRzLlNSR0I4X0FMUEhBOF9BU1RDXzZ4NV9Gb3JtYXQgPSBTUkdCOF9BTFBIQThfQVNUQ182eDVfRm9ybWF0O1xuXHRleHBvcnRzLlNSR0I4X0FMUEhBOF9BU1RDXzZ4Nl9Gb3JtYXQgPSBTUkdCOF9BTFBIQThfQVNUQ182eDZfRm9ybWF0O1xuXHRleHBvcnRzLlNSR0I4X0FMUEhBOF9BU1RDXzh4NV9Gb3JtYXQgPSBTUkdCOF9BTFBIQThfQVNUQ184eDVfRm9ybWF0O1xuXHRleHBvcnRzLlNSR0I4X0FMUEhBOF9BU1RDXzh4Nl9Gb3JtYXQgPSBTUkdCOF9BTFBIQThfQVNUQ184eDZfRm9ybWF0O1xuXHRleHBvcnRzLlNSR0I4X0FMUEhBOF9BU1RDXzh4OF9Gb3JtYXQgPSBTUkdCOF9BTFBIQThfQVNUQ184eDhfRm9ybWF0O1xuXHRleHBvcnRzLlNjZW5lID0gU2NlbmU7XG5cdGV4cG9ydHMuU2NlbmVVdGlscyA9IFNjZW5lVXRpbHM7XG5cdGV4cG9ydHMuU2hhZGVyQ2h1bmsgPSBTaGFkZXJDaHVuaztcblx0ZXhwb3J0cy5TaGFkZXJMaWIgPSBTaGFkZXJMaWI7XG5cdGV4cG9ydHMuU2hhZGVyTWF0ZXJpYWwgPSBTaGFkZXJNYXRlcmlhbDtcblx0ZXhwb3J0cy5TaGFkb3dNYXRlcmlhbCA9IFNoYWRvd01hdGVyaWFsO1xuXHRleHBvcnRzLlNoYXBlID0gU2hhcGU7XG5cdGV4cG9ydHMuU2hhcGVCdWZmZXJHZW9tZXRyeSA9IFNoYXBlR2VvbWV0cnk7XG5cdGV4cG9ydHMuU2hhcGVHZW9tZXRyeSA9IFNoYXBlR2VvbWV0cnk7XG5cdGV4cG9ydHMuU2hhcGVQYXRoID0gU2hhcGVQYXRoO1xuXHRleHBvcnRzLlNoYXBlVXRpbHMgPSBTaGFwZVV0aWxzO1xuXHRleHBvcnRzLlNob3J0VHlwZSA9IFNob3J0VHlwZTtcblx0ZXhwb3J0cy5Ta2VsZXRvbiA9IFNrZWxldG9uO1xuXHRleHBvcnRzLlNrZWxldG9uSGVscGVyID0gU2tlbGV0b25IZWxwZXI7XG5cdGV4cG9ydHMuU2tpbm5lZE1lc2ggPSBTa2lubmVkTWVzaDtcblx0ZXhwb3J0cy5TbW9vdGhTaGFkaW5nID0gU21vb3RoU2hhZGluZztcblx0ZXhwb3J0cy5TcGhlcmUgPSBTcGhlcmU7XG5cdGV4cG9ydHMuU3BoZXJlQnVmZmVyR2VvbWV0cnkgPSBTcGhlcmVHZW9tZXRyeTtcblx0ZXhwb3J0cy5TcGhlcmVHZW9tZXRyeSA9IFNwaGVyZUdlb21ldHJ5O1xuXHRleHBvcnRzLlNwaGVyaWNhbCA9IFNwaGVyaWNhbDtcblx0ZXhwb3J0cy5TcGhlcmljYWxIYXJtb25pY3MzID0gU3BoZXJpY2FsSGFybW9uaWNzMztcblx0ZXhwb3J0cy5TcGxpbmVDdXJ2ZSA9IFNwbGluZUN1cnZlO1xuXHRleHBvcnRzLlNwb3RMaWdodCA9IFNwb3RMaWdodDtcblx0ZXhwb3J0cy5TcG90TGlnaHRIZWxwZXIgPSBTcG90TGlnaHRIZWxwZXI7XG5cdGV4cG9ydHMuU3ByaXRlID0gU3ByaXRlO1xuXHRleHBvcnRzLlNwcml0ZU1hdGVyaWFsID0gU3ByaXRlTWF0ZXJpYWw7XG5cdGV4cG9ydHMuU3JjQWxwaGFGYWN0b3IgPSBTcmNBbHBoYUZhY3Rvcjtcblx0ZXhwb3J0cy5TcmNBbHBoYVNhdHVyYXRlRmFjdG9yID0gU3JjQWxwaGFTYXR1cmF0ZUZhY3Rvcjtcblx0ZXhwb3J0cy5TcmNDb2xvckZhY3RvciA9IFNyY0NvbG9yRmFjdG9yO1xuXHRleHBvcnRzLlN0YXRpY0NvcHlVc2FnZSA9IFN0YXRpY0NvcHlVc2FnZTtcblx0ZXhwb3J0cy5TdGF0aWNEcmF3VXNhZ2UgPSBTdGF0aWNEcmF3VXNhZ2U7XG5cdGV4cG9ydHMuU3RhdGljUmVhZFVzYWdlID0gU3RhdGljUmVhZFVzYWdlO1xuXHRleHBvcnRzLlN0ZXJlb0NhbWVyYSA9IFN0ZXJlb0NhbWVyYTtcblx0ZXhwb3J0cy5TdHJlYW1Db3B5VXNhZ2UgPSBTdHJlYW1Db3B5VXNhZ2U7XG5cdGV4cG9ydHMuU3RyZWFtRHJhd1VzYWdlID0gU3RyZWFtRHJhd1VzYWdlO1xuXHRleHBvcnRzLlN0cmVhbVJlYWRVc2FnZSA9IFN0cmVhbVJlYWRVc2FnZTtcblx0ZXhwb3J0cy5TdHJpbmdLZXlmcmFtZVRyYWNrID0gU3RyaW5nS2V5ZnJhbWVUcmFjaztcblx0ZXhwb3J0cy5TdWJ0cmFjdEVxdWF0aW9uID0gU3VidHJhY3RFcXVhdGlvbjtcblx0ZXhwb3J0cy5TdWJ0cmFjdGl2ZUJsZW5kaW5nID0gU3VidHJhY3RpdmVCbGVuZGluZztcblx0ZXhwb3J0cy5UT1VDSCA9IFRPVUNIO1xuXHRleHBvcnRzLlRhbmdlbnRTcGFjZU5vcm1hbE1hcCA9IFRhbmdlbnRTcGFjZU5vcm1hbE1hcDtcblx0ZXhwb3J0cy5UZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gVGV0cmFoZWRyb25HZW9tZXRyeTtcblx0ZXhwb3J0cy5UZXRyYWhlZHJvbkdlb21ldHJ5ID0gVGV0cmFoZWRyb25HZW9tZXRyeTtcblx0ZXhwb3J0cy5UZXh0R2VvbWV0cnkgPSBUZXh0R2VvbWV0cnk7XG5cdGV4cG9ydHMuVGV4dHVyZSA9IFRleHR1cmU7XG5cdGV4cG9ydHMuVGV4dHVyZUxvYWRlciA9IFRleHR1cmVMb2FkZXI7XG5cdGV4cG9ydHMuVG9ydXNCdWZmZXJHZW9tZXRyeSA9IFRvcnVzR2VvbWV0cnk7XG5cdGV4cG9ydHMuVG9ydXNHZW9tZXRyeSA9IFRvcnVzR2VvbWV0cnk7XG5cdGV4cG9ydHMuVG9ydXNLbm90QnVmZmVyR2VvbWV0cnkgPSBUb3J1c0tub3RHZW9tZXRyeTtcblx0ZXhwb3J0cy5Ub3J1c0tub3RHZW9tZXRyeSA9IFRvcnVzS25vdEdlb21ldHJ5O1xuXHRleHBvcnRzLlRyaWFuZ2xlID0gVHJpYW5nbGU7XG5cdGV4cG9ydHMuVHJpYW5nbGVGYW5EcmF3TW9kZSA9IFRyaWFuZ2xlRmFuRHJhd01vZGU7XG5cdGV4cG9ydHMuVHJpYW5nbGVTdHJpcERyYXdNb2RlID0gVHJpYW5nbGVTdHJpcERyYXdNb2RlO1xuXHRleHBvcnRzLlRyaWFuZ2xlc0RyYXdNb2RlID0gVHJpYW5nbGVzRHJhd01vZGU7XG5cdGV4cG9ydHMuVHViZUJ1ZmZlckdlb21ldHJ5ID0gVHViZUdlb21ldHJ5O1xuXHRleHBvcnRzLlR1YmVHZW9tZXRyeSA9IFR1YmVHZW9tZXRyeTtcblx0ZXhwb3J0cy5VVk1hcHBpbmcgPSBVVk1hcHBpbmc7XG5cdGV4cG9ydHMuVWludDE2QXR0cmlidXRlID0gVWludDE2QXR0cmlidXRlO1xuXHRleHBvcnRzLlVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSA9IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5VaW50MzJBdHRyaWJ1dGUgPSBVaW50MzJBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuVWludDMyQnVmZmVyQXR0cmlidXRlID0gVWludDMyQnVmZmVyQXR0cmlidXRlO1xuXHRleHBvcnRzLlVpbnQ4QXR0cmlidXRlID0gVWludDhBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuVWludDhCdWZmZXJBdHRyaWJ1dGUgPSBVaW50OEJ1ZmZlckF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5VaW50OENsYW1wZWRBdHRyaWJ1dGUgPSBVaW50OENsYW1wZWRBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlID0gVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlO1xuXHRleHBvcnRzLlVuaWZvcm0gPSBVbmlmb3JtO1xuXHRleHBvcnRzLlVuaWZvcm1zTGliID0gVW5pZm9ybXNMaWI7XG5cdGV4cG9ydHMuVW5pZm9ybXNVdGlscyA9IFVuaWZvcm1zVXRpbHM7XG5cdGV4cG9ydHMuVW5zaWduZWRCeXRlVHlwZSA9IFVuc2lnbmVkQnl0ZVR5cGU7XG5cdGV4cG9ydHMuVW5zaWduZWRJbnQyNDhUeXBlID0gVW5zaWduZWRJbnQyNDhUeXBlO1xuXHRleHBvcnRzLlVuc2lnbmVkSW50VHlwZSA9IFVuc2lnbmVkSW50VHlwZTtcblx0ZXhwb3J0cy5VbnNpZ25lZFNob3J0NDQ0NFR5cGUgPSBVbnNpZ25lZFNob3J0NDQ0NFR5cGU7XG5cdGV4cG9ydHMuVW5zaWduZWRTaG9ydDU1NTFUeXBlID0gVW5zaWduZWRTaG9ydDU1NTFUeXBlO1xuXHRleHBvcnRzLlVuc2lnbmVkU2hvcnQ1NjVUeXBlID0gVW5zaWduZWRTaG9ydDU2NVR5cGU7XG5cdGV4cG9ydHMuVW5zaWduZWRTaG9ydFR5cGUgPSBVbnNpZ25lZFNob3J0VHlwZTtcblx0ZXhwb3J0cy5WU01TaGFkb3dNYXAgPSBWU01TaGFkb3dNYXA7XG5cdGV4cG9ydHMuVmVjdG9yMiA9IFZlY3RvcjI7XG5cdGV4cG9ydHMuVmVjdG9yMyA9IFZlY3RvcjM7XG5cdGV4cG9ydHMuVmVjdG9yNCA9IFZlY3RvcjQ7XG5cdGV4cG9ydHMuVmVjdG9yS2V5ZnJhbWVUcmFjayA9IFZlY3RvcktleWZyYW1lVHJhY2s7XG5cdGV4cG9ydHMuVmVydGV4ID0gVmVydGV4O1xuXHRleHBvcnRzLlZlcnRleENvbG9ycyA9IFZlcnRleENvbG9ycztcblx0ZXhwb3J0cy5WaWRlb1RleHR1cmUgPSBWaWRlb1RleHR1cmU7XG5cdGV4cG9ydHMuV2ViR0wxUmVuZGVyZXIgPSBXZWJHTDFSZW5kZXJlcjtcblx0ZXhwb3J0cy5XZWJHTEN1YmVSZW5kZXJUYXJnZXQgPSBXZWJHTEN1YmVSZW5kZXJUYXJnZXQ7XG5cdGV4cG9ydHMuV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMgPSBXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cztcblx0ZXhwb3J0cy5XZWJHTE11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0ID0gV2ViR0xNdWx0aXNhbXBsZVJlbmRlclRhcmdldDtcblx0ZXhwb3J0cy5XZWJHTFJlbmRlclRhcmdldCA9IFdlYkdMUmVuZGVyVGFyZ2V0O1xuXHRleHBvcnRzLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSA9IFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZTtcblx0ZXhwb3J0cy5XZWJHTFJlbmRlcmVyID0gV2ViR0xSZW5kZXJlcjtcblx0ZXhwb3J0cy5XZWJHTFV0aWxzID0gV2ViR0xVdGlscztcblx0ZXhwb3J0cy5XaXJlZnJhbWVHZW9tZXRyeSA9IFdpcmVmcmFtZUdlb21ldHJ5O1xuXHRleHBvcnRzLldpcmVmcmFtZUhlbHBlciA9IFdpcmVmcmFtZUhlbHBlcjtcblx0ZXhwb3J0cy5XcmFwQXJvdW5kRW5kaW5nID0gV3JhcEFyb3VuZEVuZGluZztcblx0ZXhwb3J0cy5YSFJMb2FkZXIgPSBYSFJMb2FkZXI7XG5cdGV4cG9ydHMuWmVyb0N1cnZhdHVyZUVuZGluZyA9IFplcm9DdXJ2YXR1cmVFbmRpbmc7XG5cdGV4cG9ydHMuWmVyb0ZhY3RvciA9IFplcm9GYWN0b3I7XG5cdGV4cG9ydHMuWmVyb1Nsb3BlRW5kaW5nID0gWmVyb1Nsb3BlRW5kaW5nO1xuXHRleHBvcnRzLlplcm9TdGVuY2lsT3AgPSBaZXJvU3RlbmNpbE9wO1xuXHRleHBvcnRzLnNSR0JFbmNvZGluZyA9IHNSR0JFbmNvZGluZztcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCJpbXBvcnQge1xuXHRCdWZmZXJBdHRyaWJ1dGUsXG5cdEJ1ZmZlckdlb21ldHJ5LFxuXHRGaWxlTG9hZGVyLFxuXHRMb2FkZXJcbn0gZnJvbSAndGhyZWUnO1xuXG5jb25zdCBfdGFza0NhY2hlID0gbmV3IFdlYWtNYXAoKTtcblxuY2xhc3MgRFJBQ09Mb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBtYW5hZ2VyICkge1xuXG5cdFx0c3VwZXIoIG1hbmFnZXIgKTtcblxuXHRcdHRoaXMuZGVjb2RlclBhdGggPSAnJztcblx0XHR0aGlzLmRlY29kZXJDb25maWcgPSB7fTtcblx0XHR0aGlzLmRlY29kZXJCaW5hcnkgPSBudWxsO1xuXHRcdHRoaXMuZGVjb2RlclBlbmRpbmcgPSBudWxsO1xuXG5cdFx0dGhpcy53b3JrZXJMaW1pdCA9IDQ7XG5cdFx0dGhpcy53b3JrZXJQb29sID0gW107XG5cdFx0dGhpcy53b3JrZXJOZXh0VGFza0lEID0gMTtcblx0XHR0aGlzLndvcmtlclNvdXJjZVVSTCA9ICcnO1xuXG5cdFx0dGhpcy5kZWZhdWx0QXR0cmlidXRlSURzID0ge1xuXHRcdFx0cG9zaXRpb246ICdQT1NJVElPTicsXG5cdFx0XHRub3JtYWw6ICdOT1JNQUwnLFxuXHRcdFx0Y29sb3I6ICdDT0xPUicsXG5cdFx0XHR1djogJ1RFWF9DT09SRCdcblx0XHR9O1xuXHRcdHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVR5cGVzID0ge1xuXHRcdFx0cG9zaXRpb246ICdGbG9hdDMyQXJyYXknLFxuXHRcdFx0bm9ybWFsOiAnRmxvYXQzMkFycmF5Jyxcblx0XHRcdGNvbG9yOiAnRmxvYXQzMkFycmF5Jyxcblx0XHRcdHV2OiAnRmxvYXQzMkFycmF5J1xuXHRcdH07XG5cblx0fVxuXG5cdHNldERlY29kZXJQYXRoKCBwYXRoICkge1xuXG5cdFx0dGhpcy5kZWNvZGVyUGF0aCA9IHBhdGg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RGVjb2RlckNvbmZpZyggY29uZmlnICkge1xuXG5cdFx0dGhpcy5kZWNvZGVyQ29uZmlnID0gY29uZmlnO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFdvcmtlckxpbWl0KCB3b3JrZXJMaW1pdCApIHtcblxuXHRcdHRoaXMud29ya2VyTGltaXQgPSB3b3JrZXJMaW1pdDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRsb2FkKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblxuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHRoaXMucmVxdWVzdEhlYWRlciApO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XG5cblx0XHRsb2FkZXIubG9hZCggdXJsLCAoIGJ1ZmZlciApID0+IHtcblxuXHRcdFx0Y29uc3QgdGFza0NvbmZpZyA9IHtcblx0XHRcdFx0YXR0cmlidXRlSURzOiB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVJRHMsXG5cdFx0XHRcdGF0dHJpYnV0ZVR5cGVzOiB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVUeXBlcyxcblx0XHRcdFx0dXNlVW5pcXVlSURzOiBmYWxzZVxuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5kZWNvZGVHZW9tZXRyeSggYnVmZmVyLCB0YXNrQ29uZmlnIClcblx0XHRcdFx0LnRoZW4oIG9uTG9hZCApXG5cdFx0XHRcdC5jYXRjaCggb25FcnJvciApO1xuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH1cblxuXHQvKiogQGRlcHJlY2F0ZWQgS2VwdCBmb3IgYmFja3dhcmQtY29tcGF0aWJpbGl0eSB3aXRoIHByZXZpb3VzIERSQUNPTG9hZGVyIHZlcnNpb25zLiAqL1xuXHRkZWNvZGVEcmFjb0ZpbGUoIGJ1ZmZlciwgY2FsbGJhY2ssIGF0dHJpYnV0ZUlEcywgYXR0cmlidXRlVHlwZXMgKSB7XG5cblx0XHRjb25zdCB0YXNrQ29uZmlnID0ge1xuXHRcdFx0YXR0cmlidXRlSURzOiBhdHRyaWJ1dGVJRHMgfHwgdGhpcy5kZWZhdWx0QXR0cmlidXRlSURzLFxuXHRcdFx0YXR0cmlidXRlVHlwZXM6IGF0dHJpYnV0ZVR5cGVzIHx8IHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVR5cGVzLFxuXHRcdFx0dXNlVW5pcXVlSURzOiAhISBhdHRyaWJ1dGVJRHNcblx0XHR9O1xuXG5cdFx0dGhpcy5kZWNvZGVHZW9tZXRyeSggYnVmZmVyLCB0YXNrQ29uZmlnICkudGhlbiggY2FsbGJhY2sgKTtcblxuXHR9XG5cblx0ZGVjb2RlR2VvbWV0cnkoIGJ1ZmZlciwgdGFza0NvbmZpZyApIHtcblxuXHRcdC8vIFRPRE86IEZvciBiYWNrd2FyZC1jb21wYXRpYmlsaXR5LCBzdXBwb3J0ICdhdHRyaWJ1dGVUeXBlcycgb2JqZWN0cyBjb250YWluaW5nXG5cdFx0Ly8gcmVmZXJlbmNlcyAocmF0aGVyIHRoYW4gbmFtZXMpIHRvIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9ycy4gVGhlc2UgbXVzdCBiZVxuXHRcdC8vIHNlcmlhbGl6ZWQgYmVmb3JlIHNlbmRpbmcgdGhlbSB0byB0aGUgd29ya2VyLlxuXHRcdGZvciAoIGNvbnN0IGF0dHJpYnV0ZSBpbiB0YXNrQ29uZmlnLmF0dHJpYnV0ZVR5cGVzICkge1xuXG5cdFx0XHRjb25zdCB0eXBlID0gdGFza0NvbmZpZy5hdHRyaWJ1dGVUeXBlc1sgYXR0cmlidXRlIF07XG5cblx0XHRcdGlmICggdHlwZS5CWVRFU19QRVJfRUxFTUVOVCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRhc2tDb25maWcuYXR0cmlidXRlVHlwZXNbIGF0dHJpYnV0ZSBdID0gdHlwZS5uYW1lO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgdGFza0tleSA9IEpTT04uc3RyaW5naWZ5KCB0YXNrQ29uZmlnICk7XG5cblx0XHQvLyBDaGVjayBmb3IgYW4gZXhpc3RpbmcgdGFzayB1c2luZyB0aGlzIGJ1ZmZlci4gQSB0cmFuc2ZlcnJlZCBidWZmZXIgY2Fubm90IGJlIHRyYW5zZmVycmVkXG5cdFx0Ly8gYWdhaW4gZnJvbSB0aGlzIHRocmVhZC5cblx0XHRpZiAoIF90YXNrQ2FjaGUuaGFzKCBidWZmZXIgKSApIHtcblxuXHRcdFx0Y29uc3QgY2FjaGVkVGFzayA9IF90YXNrQ2FjaGUuZ2V0KCBidWZmZXIgKTtcblxuXHRcdFx0aWYgKCBjYWNoZWRUYXNrLmtleSA9PT0gdGFza0tleSApIHtcblxuXHRcdFx0XHRyZXR1cm4gY2FjaGVkVGFzay5wcm9taXNlO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBidWZmZXIuYnl0ZUxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHQvLyBUZWNobmljYWxseSwgaXQgd291bGQgYmUgcG9zc2libGUgdG8gd2FpdCBmb3IgdGhlIHByZXZpb3VzIHRhc2sgdG8gY29tcGxldGUsXG5cdFx0XHRcdC8vIHRyYW5zZmVyIHRoZSBidWZmZXIgYmFjaywgYW5kIGRlY29kZSBhZ2FpbiB3aXRoIHRoZSBzZWNvbmQgY29uZmlndXJhdGlvbi4gVGhhdFxuXHRcdFx0XHQvLyBpcyBjb21wbGV4LCBhbmQgSSBkb24ndCBrbm93IG9mIGFueSByZWFzb24gdG8gZGVjb2RlIGEgRHJhY28gYnVmZmVyIHR3aWNlIGluXG5cdFx0XHRcdC8vIGRpZmZlcmVudCB3YXlzLCBzbyB0aGlzIGlzIGxlZnQgdW5pbXBsZW1lbnRlZC5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXG5cdFx0XHRcdFx0J1RIUkVFLkRSQUNPTG9hZGVyOiBVbmFibGUgdG8gcmUtZGVjb2RlIGEgYnVmZmVyIHdpdGggZGlmZmVyZW50ICcgK1xuXHRcdFx0XHRcdCdzZXR0aW5ncy4gQnVmZmVyIGhhcyBhbHJlYWR5IGJlZW4gdHJhbnNmZXJyZWQuJ1xuXG5cdFx0XHRcdCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRsZXQgd29ya2VyO1xuXHRcdGNvbnN0IHRhc2tJRCA9IHRoaXMud29ya2VyTmV4dFRhc2tJRCArKztcblx0XHRjb25zdCB0YXNrQ29zdCA9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuXG5cdFx0Ly8gT2J0YWluIGEgd29ya2VyIGFuZCBhc3NpZ24gYSB0YXNrLCBhbmQgY29uc3RydWN0IGEgZ2VvbWV0cnkgaW5zdGFuY2Vcblx0XHQvLyB3aGVuIHRoZSB0YXNrIGNvbXBsZXRlcy5cblx0XHRjb25zdCBnZW9tZXRyeVBlbmRpbmcgPSB0aGlzLl9nZXRXb3JrZXIoIHRhc2tJRCwgdGFza0Nvc3QgKVxuXHRcdFx0LnRoZW4oICggX3dvcmtlciApID0+IHtcblxuXHRcdFx0XHR3b3JrZXIgPSBfd29ya2VyO1xuXG5cdFx0XHRcdHJldHVybiBuZXcgUHJvbWlzZSggKCByZXNvbHZlLCByZWplY3QgKSA9PiB7XG5cblx0XHRcdFx0XHR3b3JrZXIuX2NhbGxiYWNrc1sgdGFza0lEIF0gPSB7IHJlc29sdmUsIHJlamVjdCB9O1xuXG5cdFx0XHRcdFx0d29ya2VyLnBvc3RNZXNzYWdlKCB7IHR5cGU6ICdkZWNvZGUnLCBpZDogdGFza0lELCB0YXNrQ29uZmlnLCBidWZmZXIgfSwgWyBidWZmZXIgXSApO1xuXG5cdFx0XHRcdFx0Ly8gdGhpcy5kZWJ1ZygpO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fSApXG5cdFx0XHQudGhlbiggKCBtZXNzYWdlICkgPT4gdGhpcy5fY3JlYXRlR2VvbWV0cnkoIG1lc3NhZ2UuZ2VvbWV0cnkgKSApO1xuXG5cdFx0Ly8gUmVtb3ZlIHRhc2sgZnJvbSB0aGUgdGFzayBsaXN0LlxuXHRcdC8vIE5vdGU6IHJlcGxhY2VkICcuZmluYWxseSgpJyB3aXRoICcuY2F0Y2goKS50aGVuKCknIGJsb2NrIC0gaU9TIDExIHN1cHBvcnQgKCMxOTQxNilcblx0XHRnZW9tZXRyeVBlbmRpbmdcblx0XHRcdC5jYXRjaCggKCkgPT4gdHJ1ZSApXG5cdFx0XHQudGhlbiggKCkgPT4ge1xuXG5cdFx0XHRcdGlmICggd29ya2VyICYmIHRhc2tJRCApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3JlbGVhc2VUYXNrKCB3b3JrZXIsIHRhc2tJRCApO1xuXG5cdFx0XHRcdFx0Ly8gdGhpcy5kZWJ1ZygpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIHRhc2sgcmVzdWx0LlxuXHRcdF90YXNrQ2FjaGUuc2V0KCBidWZmZXIsIHtcblxuXHRcdFx0a2V5OiB0YXNrS2V5LFxuXHRcdFx0cHJvbWlzZTogZ2VvbWV0cnlQZW5kaW5nXG5cblx0XHR9ICk7XG5cblx0XHRyZXR1cm4gZ2VvbWV0cnlQZW5kaW5nO1xuXG5cdH1cblxuXHRfY3JlYXRlR2VvbWV0cnkoIGdlb21ldHJ5RGF0YSApIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRpZiAoIGdlb21ldHJ5RGF0YS5pbmRleCApIHtcblxuXHRcdFx0Z2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5RGF0YS5pbmRleC5hcnJheSwgMSApICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBnZW9tZXRyeURhdGEuYXR0cmlidXRlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5RGF0YS5hdHRyaWJ1dGVzWyBpIF07XG5cdFx0XHRjb25zdCBuYW1lID0gYXR0cmlidXRlLm5hbWU7XG5cdFx0XHRjb25zdCBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcblx0XHRcdGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuXG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0fVxuXG5cdF9sb2FkTGlicmFyeSggdXJsLCByZXNwb25zZVR5cGUgKSB7XG5cblx0XHRjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMuZGVjb2RlclBhdGggKTtcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCByZXNwb25zZVR5cGUgKTtcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCB0aGlzLndpdGhDcmVkZW50aWFscyApO1xuXG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKCAoIHJlc29sdmUsIHJlamVjdCApID0+IHtcblxuXHRcdFx0bG9hZGVyLmxvYWQoIHVybCwgcmVzb2x2ZSwgdW5kZWZpbmVkLCByZWplY3QgKTtcblxuXHRcdH0gKTtcblxuXHR9XG5cblx0cHJlbG9hZCgpIHtcblxuXHRcdHRoaXMuX2luaXREZWNvZGVyKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0X2luaXREZWNvZGVyKCkge1xuXG5cdFx0aWYgKCB0aGlzLmRlY29kZXJQZW5kaW5nICkgcmV0dXJuIHRoaXMuZGVjb2RlclBlbmRpbmc7XG5cblx0XHRjb25zdCB1c2VKUyA9IHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gJ29iamVjdCcgfHwgdGhpcy5kZWNvZGVyQ29uZmlnLnR5cGUgPT09ICdqcyc7XG5cdFx0Y29uc3QgbGlicmFyaWVzUGVuZGluZyA9IFtdO1xuXG5cdFx0aWYgKCB1c2VKUyApIHtcblxuXHRcdFx0bGlicmFyaWVzUGVuZGluZy5wdXNoKCB0aGlzLl9sb2FkTGlicmFyeSggJ2RyYWNvX2RlY29kZXIuanMnLCAndGV4dCcgKSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bGlicmFyaWVzUGVuZGluZy5wdXNoKCB0aGlzLl9sb2FkTGlicmFyeSggJ2RyYWNvX3dhc21fd3JhcHBlci5qcycsICd0ZXh0JyApICk7XG5cdFx0XHRsaWJyYXJpZXNQZW5kaW5nLnB1c2goIHRoaXMuX2xvYWRMaWJyYXJ5KCAnZHJhY29fZGVjb2Rlci53YXNtJywgJ2FycmF5YnVmZmVyJyApICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmRlY29kZXJQZW5kaW5nID0gUHJvbWlzZS5hbGwoIGxpYnJhcmllc1BlbmRpbmcgKVxuXHRcdFx0LnRoZW4oICggbGlicmFyaWVzICkgPT4ge1xuXG5cdFx0XHRcdGNvbnN0IGpzQ29udGVudCA9IGxpYnJhcmllc1sgMCBdO1xuXG5cdFx0XHRcdGlmICggISB1c2VKUyApIHtcblxuXHRcdFx0XHRcdHRoaXMuZGVjb2RlckNvbmZpZy53YXNtQmluYXJ5ID0gbGlicmFyaWVzWyAxIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGZuID0gRFJBQ09Xb3JrZXIudG9TdHJpbmcoKTtcblxuXHRcdFx0XHRjb25zdCBib2R5ID0gW1xuXHRcdFx0XHRcdCcvKiBkcmFjbyBkZWNvZGVyICovJyxcblx0XHRcdFx0XHRqc0NvbnRlbnQsXG5cdFx0XHRcdFx0JycsXG5cdFx0XHRcdFx0Jy8qIHdvcmtlciAqLycsXG5cdFx0XHRcdFx0Zm4uc3Vic3RyaW5nKCBmbi5pbmRleE9mKCAneycgKSArIDEsIGZuLmxhc3RJbmRleE9mKCAnfScgKSApXG5cdFx0XHRcdF0uam9pbiggJ1xcbicgKTtcblxuXHRcdFx0XHR0aGlzLndvcmtlclNvdXJjZVVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoIG5ldyBCbG9iKCBbIGJvZHkgXSApICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdHJldHVybiB0aGlzLmRlY29kZXJQZW5kaW5nO1xuXG5cdH1cblxuXHRfZ2V0V29ya2VyKCB0YXNrSUQsIHRhc2tDb3N0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2luaXREZWNvZGVyKCkudGhlbiggKCkgPT4ge1xuXG5cdFx0XHRpZiAoIHRoaXMud29ya2VyUG9vbC5sZW5ndGggPCB0aGlzLndvcmtlckxpbWl0ICkge1xuXG5cdFx0XHRcdGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIoIHRoaXMud29ya2VyU291cmNlVVJMICk7XG5cblx0XHRcdFx0d29ya2VyLl9jYWxsYmFja3MgPSB7fTtcblx0XHRcdFx0d29ya2VyLl90YXNrQ29zdHMgPSB7fTtcblx0XHRcdFx0d29ya2VyLl90YXNrTG9hZCA9IDA7XG5cblx0XHRcdFx0d29ya2VyLnBvc3RNZXNzYWdlKCB7IHR5cGU6ICdpbml0JywgZGVjb2RlckNvbmZpZzogdGhpcy5kZWNvZGVyQ29uZmlnIH0gKTtcblxuXHRcdFx0XHR3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24gKCBlICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbWVzc2FnZSA9IGUuZGF0YTtcblxuXHRcdFx0XHRcdHN3aXRjaCAoIG1lc3NhZ2UudHlwZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnZGVjb2RlJzpcblx0XHRcdFx0XHRcdFx0d29ya2VyLl9jYWxsYmFja3NbIG1lc3NhZ2UuaWQgXS5yZXNvbHZlKCBtZXNzYWdlICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdlcnJvcic6XG5cdFx0XHRcdFx0XHRcdHdvcmtlci5fY2FsbGJhY2tzWyBtZXNzYWdlLmlkIF0ucmVqZWN0KCBtZXNzYWdlICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuRFJBQ09Mb2FkZXI6IFVuZXhwZWN0ZWQgbWVzc2FnZSwgXCInICsgbWVzc2FnZS50eXBlICsgJ1wiJyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dGhpcy53b3JrZXJQb29sLnB1c2goIHdvcmtlciApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMud29ya2VyUG9vbC5zb3J0KCBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gYS5fdGFza0xvYWQgPiBiLl90YXNrTG9hZCA/IC0gMSA6IDE7XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHdvcmtlciA9IHRoaXMud29ya2VyUG9vbFsgdGhpcy53b3JrZXJQb29sLmxlbmd0aCAtIDEgXTtcblx0XHRcdHdvcmtlci5fdGFza0Nvc3RzWyB0YXNrSUQgXSA9IHRhc2tDb3N0O1xuXHRcdFx0d29ya2VyLl90YXNrTG9hZCArPSB0YXNrQ29zdDtcblx0XHRcdHJldHVybiB3b3JrZXI7XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdF9yZWxlYXNlVGFzayggd29ya2VyLCB0YXNrSUQgKSB7XG5cblx0XHR3b3JrZXIuX3Rhc2tMb2FkIC09IHdvcmtlci5fdGFza0Nvc3RzWyB0YXNrSUQgXTtcblx0XHRkZWxldGUgd29ya2VyLl9jYWxsYmFja3NbIHRhc2tJRCBdO1xuXHRcdGRlbGV0ZSB3b3JrZXIuX3Rhc2tDb3N0c1sgdGFza0lEIF07XG5cblx0fVxuXG5cdGRlYnVnKCkge1xuXG5cdFx0Y29uc29sZS5sb2coICdUYXNrIGxvYWQ6ICcsIHRoaXMud29ya2VyUG9vbC5tYXAoICggd29ya2VyICkgPT4gd29ya2VyLl90YXNrTG9hZCApICk7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLndvcmtlclBvb2wubGVuZ3RoOyArKyBpICkge1xuXG5cdFx0XHR0aGlzLndvcmtlclBvb2xbIGkgXS50ZXJtaW5hdGUoKTtcblxuXHRcdH1cblxuXHRcdHRoaXMud29ya2VyUG9vbC5sZW5ndGggPSAwO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbi8qIFdFQiBXT1JLRVIgKi9cblxuZnVuY3Rpb24gRFJBQ09Xb3JrZXIoKSB7XG5cblx0bGV0IGRlY29kZXJDb25maWc7XG5cdGxldCBkZWNvZGVyUGVuZGluZztcblxuXHRvbm1lc3NhZ2UgPSBmdW5jdGlvbiAoIGUgKSB7XG5cblx0XHRjb25zdCBtZXNzYWdlID0gZS5kYXRhO1xuXG5cdFx0c3dpdGNoICggbWVzc2FnZS50eXBlICkge1xuXG5cdFx0XHRjYXNlICdpbml0Jzpcblx0XHRcdFx0ZGVjb2RlckNvbmZpZyA9IG1lc3NhZ2UuZGVjb2RlckNvbmZpZztcblx0XHRcdFx0ZGVjb2RlclBlbmRpbmcgPSBuZXcgUHJvbWlzZSggZnVuY3Rpb24gKCByZXNvbHZlLyosIHJlamVjdCovICkge1xuXG5cdFx0XHRcdFx0ZGVjb2RlckNvbmZpZy5vbk1vZHVsZUxvYWRlZCA9IGZ1bmN0aW9uICggZHJhY28gKSB7XG5cblx0XHRcdFx0XHRcdC8vIE1vZHVsZSBpcyBQcm9taXNlLWxpa2UuIFdyYXAgYmVmb3JlIHJlc29sdmluZyB0byBhdm9pZCBsb29wLlxuXHRcdFx0XHRcdFx0cmVzb2x2ZSggeyBkcmFjbzogZHJhY28gfSApO1xuXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdERyYWNvRGVjb2Rlck1vZHVsZSggZGVjb2RlckNvbmZpZyApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnZGVjb2RlJzpcblx0XHRcdFx0Y29uc3QgYnVmZmVyID0gbWVzc2FnZS5idWZmZXI7XG5cdFx0XHRcdGNvbnN0IHRhc2tDb25maWcgPSBtZXNzYWdlLnRhc2tDb25maWc7XG5cdFx0XHRcdGRlY29kZXJQZW5kaW5nLnRoZW4oICggbW9kdWxlICkgPT4ge1xuXG5cdFx0XHRcdFx0Y29uc3QgZHJhY28gPSBtb2R1bGUuZHJhY287XG5cdFx0XHRcdFx0Y29uc3QgZGVjb2RlciA9IG5ldyBkcmFjby5EZWNvZGVyKCk7XG5cdFx0XHRcdFx0Y29uc3QgZGVjb2RlckJ1ZmZlciA9IG5ldyBkcmFjby5EZWNvZGVyQnVmZmVyKCk7XG5cdFx0XHRcdFx0ZGVjb2RlckJ1ZmZlci5Jbml0KCBuZXcgSW50OEFycmF5KCBidWZmZXIgKSwgYnVmZmVyLmJ5dGVMZW5ndGggKTtcblxuXHRcdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gZGVjb2RlR2VvbWV0cnkoIGRyYWNvLCBkZWNvZGVyLCBkZWNvZGVyQnVmZmVyLCB0YXNrQ29uZmlnICk7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGJ1ZmZlcnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLm1hcCggKCBhdHRyICkgPT4gYXR0ci5hcnJheS5idWZmZXIgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5pbmRleCApIGJ1ZmZlcnMucHVzaCggZ2VvbWV0cnkuaW5kZXguYXJyYXkuYnVmZmVyICk7XG5cblx0XHRcdFx0XHRcdHNlbGYucG9zdE1lc3NhZ2UoIHsgdHlwZTogJ2RlY29kZScsIGlkOiBtZXNzYWdlLmlkLCBnZW9tZXRyeSB9LCBidWZmZXJzICk7XG5cblx0XHRcdFx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGVycm9yICk7XG5cblx0XHRcdFx0XHRcdHNlbGYucG9zdE1lc3NhZ2UoIHsgdHlwZTogJ2Vycm9yJywgaWQ6IG1lc3NhZ2UuaWQsIGVycm9yOiBlcnJvci5tZXNzYWdlIH0gKTtcblxuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cblx0XHRcdFx0XHRcdGRyYWNvLmRlc3Ryb3koIGRlY29kZXJCdWZmZXIgKTtcblx0XHRcdFx0XHRcdGRyYWNvLmRlc3Ryb3koIGRlY29kZXIgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gZGVjb2RlR2VvbWV0cnkoIGRyYWNvLCBkZWNvZGVyLCBkZWNvZGVyQnVmZmVyLCB0YXNrQ29uZmlnICkge1xuXG5cdFx0Y29uc3QgYXR0cmlidXRlSURzID0gdGFza0NvbmZpZy5hdHRyaWJ1dGVJRHM7XG5cdFx0Y29uc3QgYXR0cmlidXRlVHlwZXMgPSB0YXNrQ29uZmlnLmF0dHJpYnV0ZVR5cGVzO1xuXG5cdFx0bGV0IGRyYWNvR2VvbWV0cnk7XG5cdFx0bGV0IGRlY29kaW5nU3RhdHVzO1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnlUeXBlID0gZGVjb2Rlci5HZXRFbmNvZGVkR2VvbWV0cnlUeXBlKCBkZWNvZGVyQnVmZmVyICk7XG5cblx0XHRpZiAoIGdlb21ldHJ5VHlwZSA9PT0gZHJhY28uVFJJQU5HVUxBUl9NRVNIICkge1xuXG5cdFx0XHRkcmFjb0dlb21ldHJ5ID0gbmV3IGRyYWNvLk1lc2goKTtcblx0XHRcdGRlY29kaW5nU3RhdHVzID0gZGVjb2Rlci5EZWNvZGVCdWZmZXJUb01lc2goIGRlY29kZXJCdWZmZXIsIGRyYWNvR2VvbWV0cnkgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5VHlwZSA9PT0gZHJhY28uUE9JTlRfQ0xPVUQgKSB7XG5cblx0XHRcdGRyYWNvR2VvbWV0cnkgPSBuZXcgZHJhY28uUG9pbnRDbG91ZCgpO1xuXHRcdFx0ZGVjb2RpbmdTdGF0dXMgPSBkZWNvZGVyLkRlY29kZUJ1ZmZlclRvUG9pbnRDbG91ZCggZGVjb2RlckJ1ZmZlciwgZHJhY29HZW9tZXRyeSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuRFJBQ09Mb2FkZXI6IFVuZXhwZWN0ZWQgZ2VvbWV0cnkgdHlwZS4nICk7XG5cblx0XHR9XG5cblx0XHRpZiAoICEgZGVjb2RpbmdTdGF0dXMub2soKSB8fCBkcmFjb0dlb21ldHJ5LnB0ciA9PT0gMCApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuRFJBQ09Mb2FkZXI6IERlY29kaW5nIGZhaWxlZDogJyArIGRlY29kaW5nU3RhdHVzLmVycm9yX21zZygpICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IHsgaW5kZXg6IG51bGwsIGF0dHJpYnV0ZXM6IFtdIH07XG5cblx0XHQvLyBHYXRoZXIgYWxsIHZlcnRleCBhdHRyaWJ1dGVzLlxuXHRcdGZvciAoIGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlSURzICkge1xuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGVUeXBlID0gc2VsZlsgYXR0cmlidXRlVHlwZXNbIGF0dHJpYnV0ZU5hbWUgXSBdO1xuXG5cdFx0XHRsZXQgYXR0cmlidXRlO1xuXHRcdFx0bGV0IGF0dHJpYnV0ZUlEO1xuXG5cdFx0XHQvLyBBIERyYWNvIGZpbGUgbWF5IGJlIGNyZWF0ZWQgd2l0aCBkZWZhdWx0IHZlcnRleCBhdHRyaWJ1dGVzLCB3aG9zZSBhdHRyaWJ1dGUgSURzXG5cdFx0XHQvLyBhcmUgbWFwcGVkIDE6MSBmcm9tIHRoZWlyIHNlbWFudGljIG5hbWUgKFBPU0lUSU9OLCBOT1JNQUwsIC4uLikuIEFsdGVybmF0aXZlbHksXG5cdFx0XHQvLyBhIERyYWNvIGZpbGUgbWF5IGNvbnRhaW4gYSBjdXN0b20gc2V0IG9mIGF0dHJpYnV0ZXMsIGlkZW50aWZpZWQgYnkga25vd24gdW5pcXVlXG5cdFx0XHQvLyBJRHMuIGdsVEYgZmlsZXMgYWx3YXlzIGRvIHRoZSBsYXR0ZXIsIGFuZCBgLmRyY2AgZmlsZXMgdHlwaWNhbGx5IGRvIHRoZSBmb3JtZXIuXG5cdFx0XHRpZiAoIHRhc2tDb25maWcudXNlVW5pcXVlSURzICkge1xuXG5cdFx0XHRcdGF0dHJpYnV0ZUlEID0gYXR0cmlidXRlSURzWyBhdHRyaWJ1dGVOYW1lIF07XG5cdFx0XHRcdGF0dHJpYnV0ZSA9IGRlY29kZXIuR2V0QXR0cmlidXRlQnlVbmlxdWVJZCggZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlSUQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRhdHRyaWJ1dGVJRCA9IGRlY29kZXIuR2V0QXR0cmlidXRlSWQoIGRyYWNvR2VvbWV0cnksIGRyYWNvWyBhdHRyaWJ1dGVJRHNbIGF0dHJpYnV0ZU5hbWUgXSBdICk7XG5cblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVJRCA9PT0gLSAxICkgY29udGludWU7XG5cblx0XHRcdFx0YXR0cmlidXRlID0gZGVjb2Rlci5HZXRBdHRyaWJ1dGUoIGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZUlEICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuYXR0cmlidXRlcy5wdXNoKCBkZWNvZGVBdHRyaWJ1dGUoIGRyYWNvLCBkZWNvZGVyLCBkcmFjb0dlb21ldHJ5LCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVUeXBlLCBhdHRyaWJ1dGUgKSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gQWRkIGluZGV4LlxuXHRcdGlmICggZ2VvbWV0cnlUeXBlID09PSBkcmFjby5UUklBTkdVTEFSX01FU0ggKSB7XG5cblx0XHRcdGdlb21ldHJ5LmluZGV4ID0gZGVjb2RlSW5kZXgoIGRyYWNvLCBkZWNvZGVyLCBkcmFjb0dlb21ldHJ5ICk7XG5cblx0XHR9XG5cblx0XHRkcmFjby5kZXN0cm95KCBkcmFjb0dlb21ldHJ5ICk7XG5cblx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGRlY29kZUluZGV4KCBkcmFjbywgZGVjb2RlciwgZHJhY29HZW9tZXRyeSApIHtcblxuXHRcdGNvbnN0IG51bUZhY2VzID0gZHJhY29HZW9tZXRyeS5udW1fZmFjZXMoKTtcblx0XHRjb25zdCBudW1JbmRpY2VzID0gbnVtRmFjZXMgKiAzO1xuXHRcdGNvbnN0IGJ5dGVMZW5ndGggPSBudW1JbmRpY2VzICogNDtcblxuXHRcdGNvbnN0IHB0ciA9IGRyYWNvLl9tYWxsb2MoIGJ5dGVMZW5ndGggKTtcblx0XHRkZWNvZGVyLkdldFRyaWFuZ2xlc1VJbnQzMkFycmF5KCBkcmFjb0dlb21ldHJ5LCBieXRlTGVuZ3RoLCBwdHIgKTtcblx0XHRjb25zdCBpbmRleCA9IG5ldyBVaW50MzJBcnJheSggZHJhY28uSEVBUEYzMi5idWZmZXIsIHB0ciwgbnVtSW5kaWNlcyApLnNsaWNlKCk7XG5cdFx0ZHJhY28uX2ZyZWUoIHB0ciApO1xuXG5cdFx0cmV0dXJuIHsgYXJyYXk6IGluZGV4LCBpdGVtU2l6ZTogMSB9O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBkZWNvZGVBdHRyaWJ1dGUoIGRyYWNvLCBkZWNvZGVyLCBkcmFjb0dlb21ldHJ5LCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVUeXBlLCBhdHRyaWJ1dGUgKSB7XG5cblx0XHRjb25zdCBudW1Db21wb25lbnRzID0gYXR0cmlidXRlLm51bV9jb21wb25lbnRzKCk7XG5cdFx0Y29uc3QgbnVtUG9pbnRzID0gZHJhY29HZW9tZXRyeS5udW1fcG9pbnRzKCk7XG5cdFx0Y29uc3QgbnVtVmFsdWVzID0gbnVtUG9pbnRzICogbnVtQ29tcG9uZW50cztcblx0XHRjb25zdCBieXRlTGVuZ3RoID0gbnVtVmFsdWVzICogYXR0cmlidXRlVHlwZS5CWVRFU19QRVJfRUxFTUVOVDtcblx0XHRjb25zdCBkYXRhVHlwZSA9IGdldERyYWNvRGF0YVR5cGUoIGRyYWNvLCBhdHRyaWJ1dGVUeXBlICk7XG5cblx0XHRjb25zdCBwdHIgPSBkcmFjby5fbWFsbG9jKCBieXRlTGVuZ3RoICk7XG5cdFx0ZGVjb2Rlci5HZXRBdHRyaWJ1dGVEYXRhQXJyYXlGb3JBbGxQb2ludHMoIGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZSwgZGF0YVR5cGUsIGJ5dGVMZW5ndGgsIHB0ciApO1xuXHRcdGNvbnN0IGFycmF5ID0gbmV3IGF0dHJpYnV0ZVR5cGUoIGRyYWNvLkhFQVBGMzIuYnVmZmVyLCBwdHIsIG51bVZhbHVlcyApLnNsaWNlKCk7XG5cdFx0ZHJhY28uX2ZyZWUoIHB0ciApO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdG5hbWU6IGF0dHJpYnV0ZU5hbWUsXG5cdFx0XHRhcnJheTogYXJyYXksXG5cdFx0XHRpdGVtU2l6ZTogbnVtQ29tcG9uZW50c1xuXHRcdH07XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldERyYWNvRGF0YVR5cGUoIGRyYWNvLCBhdHRyaWJ1dGVUeXBlICkge1xuXG5cdFx0c3dpdGNoICggYXR0cmlidXRlVHlwZSApIHtcblxuXHRcdFx0Y2FzZSBGbG9hdDMyQXJyYXk6IHJldHVybiBkcmFjby5EVF9GTE9BVDMyO1xuXHRcdFx0Y2FzZSBJbnQ4QXJyYXk6IHJldHVybiBkcmFjby5EVF9JTlQ4O1xuXHRcdFx0Y2FzZSBJbnQxNkFycmF5OiByZXR1cm4gZHJhY28uRFRfSU5UMTY7XG5cdFx0XHRjYXNlIEludDMyQXJyYXk6IHJldHVybiBkcmFjby5EVF9JTlQzMjtcblx0XHRcdGNhc2UgVWludDhBcnJheTogcmV0dXJuIGRyYWNvLkRUX1VJTlQ4O1xuXHRcdFx0Y2FzZSBVaW50MTZBcnJheTogcmV0dXJuIGRyYWNvLkRUX1VJTlQxNjtcblx0XHRcdGNhc2UgVWludDMyQXJyYXk6IHJldHVybiBkcmFjby5EVF9VSU5UMzI7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IERSQUNPTG9hZGVyIH07XG4iLCJpbXBvcnQge1xuXHRBbmltYXRpb25DbGlwLFxuXHRCb25lLFxuXHRCb3gzLFxuXHRCdWZmZXJBdHRyaWJ1dGUsXG5cdEJ1ZmZlckdlb21ldHJ5LFxuXHRDbGFtcFRvRWRnZVdyYXBwaW5nLFxuXHRDb2xvcixcblx0RGlyZWN0aW9uYWxMaWdodCxcblx0RG91YmxlU2lkZSxcblx0RmlsZUxvYWRlcixcblx0RnJvbnRTaWRlLFxuXHRHcm91cCxcblx0SW1hZ2VCaXRtYXBMb2FkZXIsXG5cdEludGVybGVhdmVkQnVmZmVyLFxuXHRJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSxcblx0SW50ZXJwb2xhbnQsXG5cdEludGVycG9sYXRlRGlzY3JldGUsXG5cdEludGVycG9sYXRlTGluZWFyLFxuXHRMaW5lLFxuXHRMaW5lQmFzaWNNYXRlcmlhbCxcblx0TGluZUxvb3AsXG5cdExpbmVTZWdtZW50cyxcblx0TGluZWFyRmlsdGVyLFxuXHRMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIsXG5cdExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIsXG5cdExvYWRlcixcblx0TG9hZGVyVXRpbHMsXG5cdE1hdGVyaWFsLFxuXHRNYXRoVXRpbHMsXG5cdE1hdHJpeDQsXG5cdE1lc2gsXG5cdE1lc2hCYXNpY01hdGVyaWFsLFxuXHRNZXNoUGh5c2ljYWxNYXRlcmlhbCxcblx0TWVzaFN0YW5kYXJkTWF0ZXJpYWwsXG5cdE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcsXG5cdE5lYXJlc3RGaWx0ZXIsXG5cdE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsXG5cdE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyLFxuXHROdW1iZXJLZXlmcmFtZVRyYWNrLFxuXHRPYmplY3QzRCxcblx0T3J0aG9ncmFwaGljQ2FtZXJhLFxuXHRQZXJzcGVjdGl2ZUNhbWVyYSxcblx0UG9pbnRMaWdodCxcblx0UG9pbnRzLFxuXHRQb2ludHNNYXRlcmlhbCxcblx0UHJvcGVydHlCaW5kaW5nLFxuXHRRdWF0ZXJuaW9uLFxuXHRRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayxcblx0UkdCRm9ybWF0LFxuXHRSZXBlYXRXcmFwcGluZyxcblx0U2tlbGV0b24sXG5cdFNraW5uZWRNZXNoLFxuXHRTcGhlcmUsXG5cdFNwb3RMaWdodCxcblx0VGFuZ2VudFNwYWNlTm9ybWFsTWFwLFxuXHRUZXh0dXJlLFxuXHRUZXh0dXJlTG9hZGVyLFxuXHRUcmlhbmdsZUZhbkRyYXdNb2RlLFxuXHRUcmlhbmdsZVN0cmlwRHJhd01vZGUsXG5cdFZlY3RvcjIsXG5cdFZlY3RvcjMsXG5cdFZlY3RvcktleWZyYW1lVHJhY2ssXG5cdHNSR0JFbmNvZGluZ1xufSBmcm9tICd0aHJlZSc7XG5cbmNsYXNzIEdMVEZMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuXG5cdGNvbnN0cnVjdG9yKCBtYW5hZ2VyICkge1xuXG5cdFx0c3VwZXIoIG1hbmFnZXIgKTtcblxuXHRcdHRoaXMuZHJhY29Mb2FkZXIgPSBudWxsO1xuXHRcdHRoaXMua3R4MkxvYWRlciA9IG51bGw7XG5cdFx0dGhpcy5tZXNob3B0RGVjb2RlciA9IG51bGw7XG5cblx0XHR0aGlzLnBsdWdpbkNhbGxiYWNrcyA9IFtdO1xuXG5cdFx0dGhpcy5yZWdpc3RlciggZnVuY3Rpb24gKCBwYXJzZXIgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgR0xURk1hdGVyaWFsc0NsZWFyY29hdEV4dGVuc2lvbiggcGFyc2VyICk7XG5cblx0XHR9ICk7XG5cblx0XHR0aGlzLnJlZ2lzdGVyKCBmdW5jdGlvbiAoIHBhcnNlciApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBHTFRGVGV4dHVyZUJhc2lzVUV4dGVuc2lvbiggcGFyc2VyICk7XG5cblx0XHR9ICk7XG5cblx0XHR0aGlzLnJlZ2lzdGVyKCBmdW5jdGlvbiAoIHBhcnNlciApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBHTFRGVGV4dHVyZVdlYlBFeHRlbnNpb24oIHBhcnNlciApO1xuXG5cdFx0fSApO1xuXG5cdFx0dGhpcy5yZWdpc3RlciggZnVuY3Rpb24gKCBwYXJzZXIgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgR0xURk1hdGVyaWFsc1NoZWVuRXh0ZW5zaW9uKCBwYXJzZXIgKTtcblxuXHRcdH0gKTtcblxuXHRcdHRoaXMucmVnaXN0ZXIoIGZ1bmN0aW9uICggcGFyc2VyICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNUcmFuc21pc3Npb25FeHRlbnNpb24oIHBhcnNlciApO1xuXG5cdFx0fSApO1xuXG5cdFx0dGhpcy5yZWdpc3RlciggZnVuY3Rpb24gKCBwYXJzZXIgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgR0xURk1hdGVyaWFsc1ZvbHVtZUV4dGVuc2lvbiggcGFyc2VyICk7XG5cblx0XHR9ICk7XG5cblx0XHR0aGlzLnJlZ2lzdGVyKCBmdW5jdGlvbiAoIHBhcnNlciApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzSW9yRXh0ZW5zaW9uKCBwYXJzZXIgKTtcblxuXHRcdH0gKTtcblxuXHRcdHRoaXMucmVnaXN0ZXIoIGZ1bmN0aW9uICggcGFyc2VyICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNTcGVjdWxhckV4dGVuc2lvbiggcGFyc2VyICk7XG5cblx0XHR9ICk7XG5cblx0XHR0aGlzLnJlZ2lzdGVyKCBmdW5jdGlvbiAoIHBhcnNlciApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBHTFRGTGlnaHRzRXh0ZW5zaW9uKCBwYXJzZXIgKTtcblxuXHRcdH0gKTtcblxuXHRcdHRoaXMucmVnaXN0ZXIoIGZ1bmN0aW9uICggcGFyc2VyICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IEdMVEZNZXNob3B0Q29tcHJlc3Npb24oIHBhcnNlciApO1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHRsb2FkKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdGxldCByZXNvdXJjZVBhdGg7XG5cblx0XHRpZiAoIHRoaXMucmVzb3VyY2VQYXRoICE9PSAnJyApIHtcblxuXHRcdFx0cmVzb3VyY2VQYXRoID0gdGhpcy5yZXNvdXJjZVBhdGg7XG5cblx0XHR9IGVsc2UgaWYgKCB0aGlzLnBhdGggIT09ICcnICkge1xuXG5cdFx0XHRyZXNvdXJjZVBhdGggPSB0aGlzLnBhdGg7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXNvdXJjZVBhdGggPSBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSggdXJsICk7XG5cblx0XHR9XG5cblx0XHQvLyBUZWxscyB0aGUgTG9hZGluZ01hbmFnZXIgdG8gdHJhY2sgYW4gZXh0cmEgaXRlbSwgd2hpY2ggcmVzb2x2ZXMgYWZ0ZXJcblx0XHQvLyB0aGUgbW9kZWwgaXMgZnVsbHkgbG9hZGVkLiBUaGlzIG1lYW5zIHRoZSBjb3VudCBvZiBpdGVtcyBsb2FkZWQgd2lsbFxuXHRcdC8vIGJlIGluY29ycmVjdCwgYnV0IGVuc3VyZXMgbWFuYWdlci5vbkxvYWQoKSBkb2VzIG5vdCBmaXJlIGVhcmx5LlxuXHRcdHRoaXMubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG5cdFx0Y29uc3QgX29uRXJyb3IgPSBmdW5jdGlvbiAoIGUgKSB7XG5cblx0XHRcdGlmICggb25FcnJvciApIHtcblxuXHRcdFx0XHRvbkVycm9yKCBlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHR9O1xuXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXG5cdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xuXHRcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcblxuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggZGF0YSApIHtcblxuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRzY29wZS5wYXJzZSggZGF0YSwgcmVzb3VyY2VQYXRoLCBmdW5jdGlvbiAoIGdsdGYgKSB7XG5cblx0XHRcdFx0XHRvbkxvYWQoIGdsdGYgKTtcblxuXHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHRcdFx0fSwgX29uRXJyb3IgKTtcblxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0X29uRXJyb3IoIGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSwgb25Qcm9ncmVzcywgX29uRXJyb3IgKTtcblxuXHR9XG5cblx0c2V0RFJBQ09Mb2FkZXIoIGRyYWNvTG9hZGVyICkge1xuXG5cdFx0dGhpcy5kcmFjb0xvYWRlciA9IGRyYWNvTG9hZGVyO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRERFNMb2FkZXIoKSB7XG5cblx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cblx0XHRcdCdUSFJFRS5HTFRGTG9hZGVyOiBcIk1TRlRfdGV4dHVyZV9kZHNcIiBubyBsb25nZXIgc3VwcG9ydGVkLiBQbGVhc2UgdXBkYXRlIHRvIFwiS0hSX3RleHR1cmVfYmFzaXN1XCIuJ1xuXG5cdFx0KTtcblxuXHR9XG5cblx0c2V0S1RYMkxvYWRlcigga3R4MkxvYWRlciApIHtcblxuXHRcdHRoaXMua3R4MkxvYWRlciA9IGt0eDJMb2FkZXI7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldE1lc2hvcHREZWNvZGVyKCBtZXNob3B0RGVjb2RlciApIHtcblxuXHRcdHRoaXMubWVzaG9wdERlY29kZXIgPSBtZXNob3B0RGVjb2Rlcjtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmVnaXN0ZXIoIGNhbGxiYWNrICkge1xuXG5cdFx0aWYgKCB0aGlzLnBsdWdpbkNhbGxiYWNrcy5pbmRleE9mKCBjYWxsYmFjayApID09PSAtIDEgKSB7XG5cblx0XHRcdHRoaXMucGx1Z2luQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dW5yZWdpc3RlciggY2FsbGJhY2sgKSB7XG5cblx0XHRpZiAoIHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YoIGNhbGxiYWNrICkgIT09IC0gMSApIHtcblxuXHRcdFx0dGhpcy5wbHVnaW5DYWxsYmFja3Muc3BsaWNlKCB0aGlzLnBsdWdpbkNhbGxiYWNrcy5pbmRleE9mKCBjYWxsYmFjayApLCAxICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cGFyc2UoIGRhdGEsIHBhdGgsIG9uTG9hZCwgb25FcnJvciApIHtcblxuXHRcdGxldCBjb250ZW50O1xuXHRcdGNvbnN0IGV4dGVuc2lvbnMgPSB7fTtcblx0XHRjb25zdCBwbHVnaW5zID0ge307XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyApIHtcblxuXHRcdFx0Y29udGVudCA9IGRhdGE7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBtYWdpYyA9IExvYWRlclV0aWxzLmRlY29kZVRleHQoIG5ldyBVaW50OEFycmF5KCBkYXRhLCAwLCA0ICkgKTtcblxuXHRcdFx0aWYgKCBtYWdpYyA9PT0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTUFHSUMgKSB7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdGV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX0JJTkFSWV9HTFRGIF0gPSBuZXcgR0xURkJpbmFyeUV4dGVuc2lvbiggZGF0YSApO1xuXG5cdFx0XHRcdH0gY2F0Y2ggKCBlcnJvciApIHtcblxuXHRcdFx0XHRcdGlmICggb25FcnJvciApIG9uRXJyb3IoIGVycm9yICk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb250ZW50ID0gZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEYgXS5jb250ZW50O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnRlbnQgPSBMb2FkZXJVdGlscy5kZWNvZGVUZXh0KCBuZXcgVWludDhBcnJheSggZGF0YSApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKCBjb250ZW50ICk7XG5cblx0XHRpZiAoIGpzb24uYXNzZXQgPT09IHVuZGVmaW5lZCB8fCBqc29uLmFzc2V0LnZlcnNpb25bIDAgXSA8IDIgKSB7XG5cblx0XHRcdGlmICggb25FcnJvciApIG9uRXJyb3IoIG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIGFzc2V0LiBnbFRGIHZlcnNpb25zID49Mi4wIGFyZSBzdXBwb3J0ZWQuJyApICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRjb25zdCBwYXJzZXIgPSBuZXcgR0xURlBhcnNlcigganNvbiwge1xuXG5cdFx0XHRwYXRoOiBwYXRoIHx8IHRoaXMucmVzb3VyY2VQYXRoIHx8ICcnLFxuXHRcdFx0Y3Jvc3NPcmlnaW46IHRoaXMuY3Jvc3NPcmlnaW4sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyOiB0aGlzLnJlcXVlc3RIZWFkZXIsXG5cdFx0XHRtYW5hZ2VyOiB0aGlzLm1hbmFnZXIsXG5cdFx0XHRrdHgyTG9hZGVyOiB0aGlzLmt0eDJMb2FkZXIsXG5cdFx0XHRtZXNob3B0RGVjb2RlcjogdGhpcy5tZXNob3B0RGVjb2RlclxuXG5cdFx0fSApO1xuXG5cdFx0cGFyc2VyLmZpbGVMb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5yZXF1ZXN0SGVhZGVyICk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLnBsdWdpbkNhbGxiYWNrcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHBsdWdpbiA9IHRoaXMucGx1Z2luQ2FsbGJhY2tzWyBpIF0oIHBhcnNlciApO1xuXHRcdFx0cGx1Z2luc1sgcGx1Z2luLm5hbWUgXSA9IHBsdWdpbjtcblxuXHRcdFx0Ly8gV29ya2Fyb3VuZCB0byBhdm9pZCBkZXRlcm1pbmluZyBhcyB1bmtub3duIGV4dGVuc2lvblxuXHRcdFx0Ly8gaW4gYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKCkuXG5cdFx0XHQvLyBSZW1vdmUgdGhpcyB3b3JrYXJvdW5kIGlmIHdlIG1vdmUgYWxsIHRoZSBleGlzdGluZ1xuXHRcdFx0Ly8gZXh0ZW5zaW9uIGhhbmRsZXJzIHRvIHBsdWdpbiBzeXN0ZW1cblx0XHRcdGV4dGVuc2lvbnNbIHBsdWdpbi5uYW1lIF0gPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBqc29uLmV4dGVuc2lvbnNVc2VkICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBqc29uLmV4dGVuc2lvbnNVc2VkLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0XHRjb25zdCBleHRlbnNpb25OYW1lID0ganNvbi5leHRlbnNpb25zVXNlZFsgaSBdO1xuXHRcdFx0XHRjb25zdCBleHRlbnNpb25zUmVxdWlyZWQgPSBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCB8fCBbXTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBleHRlbnNpb25OYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVQ6XG5cdFx0XHRcdFx0XHRleHRlbnNpb25zWyBleHRlbnNpb25OYW1lIF0gPSBuZXcgR0xURk1hdGVyaWFsc1VubGl0RXh0ZW5zaW9uKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1BCUl9TUEVDVUxBUl9HTE9TU0lORVNTOlxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uc1sgZXh0ZW5zaW9uTmFtZSBdID0gbmV3IEdMVEZNYXRlcmlhbHNQYnJTcGVjdWxhckdsb3NzaW5lc3NFeHRlbnNpb24oKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OOlxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uc1sgZXh0ZW5zaW9uTmFtZSBdID0gbmV3IEdMVEZEcmFjb01lc2hDb21wcmVzc2lvbkV4dGVuc2lvbigganNvbiwgdGhpcy5kcmFjb0xvYWRlciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIEVYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNOlxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uc1sgZXh0ZW5zaW9uTmFtZSBdID0gbmV3IEdMVEZUZXh0dXJlVHJhbnNmb3JtRXh0ZW5zaW9uKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgRVhURU5TSU9OUy5LSFJfTUVTSF9RVUFOVElaQVRJT046XG5cdFx0XHRcdFx0XHRleHRlbnNpb25zWyBleHRlbnNpb25OYW1lIF0gPSBuZXcgR0xURk1lc2hRdWFudGl6YXRpb25FeHRlbnNpb24oKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdFx0aWYgKCBleHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZiggZXh0ZW5zaW9uTmFtZSApID49IDAgJiYgcGx1Z2luc1sgZXh0ZW5zaW9uTmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogVW5rbm93biBleHRlbnNpb24gXCInICsgZXh0ZW5zaW9uTmFtZSArICdcIi4nICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHBhcnNlci5zZXRFeHRlbnNpb25zKCBleHRlbnNpb25zICk7XG5cdFx0cGFyc2VyLnNldFBsdWdpbnMoIHBsdWdpbnMgKTtcblx0XHRwYXJzZXIucGFyc2UoIG9uTG9hZCwgb25FcnJvciApO1xuXG5cdH1cblxuXHRwYXJzZUFzeW5jKCBkYXRhLCBwYXRoICkge1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKCBmdW5jdGlvbiAoIHJlc29sdmUsIHJlamVjdCApIHtcblxuXHRcdFx0c2NvcGUucGFyc2UoIGRhdGEsIHBhdGgsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0fSApO1xuXG5cdH1cblxufVxuXG4vKiBHTFRGUkVHSVNUUlkgKi9cblxuZnVuY3Rpb24gR0xURlJlZ2lzdHJ5KCkge1xuXG5cdGxldCBvYmplY3RzID0ge307XG5cblx0cmV0dXJuXHR7XG5cblx0XHRnZXQ6IGZ1bmN0aW9uICgga2V5ICkge1xuXG5cdFx0XHRyZXR1cm4gb2JqZWN0c1sga2V5IF07XG5cblx0XHR9LFxuXG5cdFx0YWRkOiBmdW5jdGlvbiAoIGtleSwgb2JqZWN0ICkge1xuXG5cdFx0XHRvYmplY3RzWyBrZXkgXSA9IG9iamVjdDtcblxuXHRcdH0sXG5cblx0XHRyZW1vdmU6IGZ1bmN0aW9uICgga2V5ICkge1xuXG5cdFx0XHRkZWxldGUgb2JqZWN0c1sga2V5IF07XG5cblx0XHR9LFxuXG5cdFx0cmVtb3ZlQWxsOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdG9iamVjdHMgPSB7fTtcblxuXHRcdH1cblxuXHR9O1xuXG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqKioqKiBFWFRFTlNJT05TICoqKioqKioqKioqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuY29uc3QgRVhURU5TSU9OUyA9IHtcblx0S0hSX0JJTkFSWV9HTFRGOiAnS0hSX2JpbmFyeV9nbFRGJyxcblx0S0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT046ICdLSFJfZHJhY29fbWVzaF9jb21wcmVzc2lvbicsXG5cdEtIUl9MSUdIVFNfUFVOQ1RVQUw6ICdLSFJfbGlnaHRzX3B1bmN0dWFsJyxcblx0S0hSX01BVEVSSUFMU19DTEVBUkNPQVQ6ICdLSFJfbWF0ZXJpYWxzX2NsZWFyY29hdCcsXG5cdEtIUl9NQVRFUklBTFNfSU9SOiAnS0hSX21hdGVyaWFsc19pb3InLFxuXHRLSFJfTUFURVJJQUxTX1BCUl9TUEVDVUxBUl9HTE9TU0lORVNTOiAnS0hSX21hdGVyaWFsc19wYnJTcGVjdWxhckdsb3NzaW5lc3MnLFxuXHRLSFJfTUFURVJJQUxTX1NIRUVOOiAnS0hSX21hdGVyaWFsc19zaGVlbicsXG5cdEtIUl9NQVRFUklBTFNfU1BFQ1VMQVI6ICdLSFJfbWF0ZXJpYWxzX3NwZWN1bGFyJyxcblx0S0hSX01BVEVSSUFMU19UUkFOU01JU1NJT046ICdLSFJfbWF0ZXJpYWxzX3RyYW5zbWlzc2lvbicsXG5cdEtIUl9NQVRFUklBTFNfVU5MSVQ6ICdLSFJfbWF0ZXJpYWxzX3VubGl0Jyxcblx0S0hSX01BVEVSSUFMU19WT0xVTUU6ICdLSFJfbWF0ZXJpYWxzX3ZvbHVtZScsXG5cdEtIUl9URVhUVVJFX0JBU0lTVTogJ0tIUl90ZXh0dXJlX2Jhc2lzdScsXG5cdEtIUl9URVhUVVJFX1RSQU5TRk9STTogJ0tIUl90ZXh0dXJlX3RyYW5zZm9ybScsXG5cdEtIUl9NRVNIX1FVQU5USVpBVElPTjogJ0tIUl9tZXNoX3F1YW50aXphdGlvbicsXG5cdEVYVF9URVhUVVJFX1dFQlA6ICdFWFRfdGV4dHVyZV93ZWJwJyxcblx0RVhUX01FU0hPUFRfQ09NUFJFU1NJT046ICdFWFRfbWVzaG9wdF9jb21wcmVzc2lvbidcbn07XG5cbi8qKlxuICogUHVuY3R1YWwgTGlnaHRzIEV4dGVuc2lvblxuICpcbiAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl9saWdodHNfcHVuY3R1YWxcbiAqL1xuY2xhc3MgR0xURkxpZ2h0c0V4dGVuc2lvbiB7XG5cblx0Y29uc3RydWN0b3IoIHBhcnNlciApIHtcblxuXHRcdHRoaXMucGFyc2VyID0gcGFyc2VyO1xuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX0xJR0hUU19QVU5DVFVBTDtcblxuXHRcdC8vIE9iamVjdDNEIGluc3RhbmNlIGNhY2hlc1xuXHRcdHRoaXMuY2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuXG5cdH1cblxuXHRfbWFya0RlZnMoKSB7XG5cblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcblx0XHRjb25zdCBub2RlRGVmcyA9IHRoaXMucGFyc2VyLmpzb24ubm9kZXMgfHwgW107XG5cblx0XHRmb3IgKCBsZXQgbm9kZUluZGV4ID0gMCwgbm9kZUxlbmd0aCA9IG5vZGVEZWZzLmxlbmd0aDsgbm9kZUluZGV4IDwgbm9kZUxlbmd0aDsgbm9kZUluZGV4ICsrICkge1xuXG5cdFx0XHRjb25zdCBub2RlRGVmID0gbm9kZURlZnNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRpZiAoIG5vZGVEZWYuZXh0ZW5zaW9uc1xuXHRcdFx0XHRcdCYmIG5vZGVEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF1cblx0XHRcdFx0XHQmJiBub2RlRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdLmxpZ2h0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cGFyc2VyLl9hZGROb2RlUmVmKCB0aGlzLmNhY2hlLCBub2RlRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdLmxpZ2h0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0X2xvYWRMaWdodCggbGlnaHRJbmRleCApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IGNhY2hlS2V5ID0gJ2xpZ2h0OicgKyBsaWdodEluZGV4O1xuXHRcdGxldCBkZXBlbmRlbmN5ID0gcGFyc2VyLmNhY2hlLmdldCggY2FjaGVLZXkgKTtcblxuXHRcdGlmICggZGVwZW5kZW5jeSApIHJldHVybiBkZXBlbmRlbmN5O1xuXG5cdFx0Y29uc3QganNvbiA9IHBhcnNlci5qc29uO1xuXHRcdGNvbnN0IGV4dGVuc2lvbnMgPSAoIGpzb24uZXh0ZW5zaW9ucyAmJiBqc29uLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkgfHwge307XG5cdFx0Y29uc3QgbGlnaHREZWZzID0gZXh0ZW5zaW9ucy5saWdodHMgfHwgW107XG5cdFx0Y29uc3QgbGlnaHREZWYgPSBsaWdodERlZnNbIGxpZ2h0SW5kZXggXTtcblx0XHRsZXQgbGlnaHROb2RlO1xuXG5cdFx0Y29uc3QgY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7XG5cblx0XHRpZiAoIGxpZ2h0RGVmLmNvbG9yICE9PSB1bmRlZmluZWQgKSBjb2xvci5mcm9tQXJyYXkoIGxpZ2h0RGVmLmNvbG9yICk7XG5cblx0XHRjb25zdCByYW5nZSA9IGxpZ2h0RGVmLnJhbmdlICE9PSB1bmRlZmluZWQgPyBsaWdodERlZi5yYW5nZSA6IDA7XG5cblx0XHRzd2l0Y2ggKCBsaWdodERlZi50eXBlICkge1xuXG5cdFx0XHRjYXNlICdkaXJlY3Rpb25hbCc6XG5cdFx0XHRcdGxpZ2h0Tm9kZSA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0KCBjb2xvciApO1xuXHRcdFx0XHRsaWdodE5vZGUudGFyZ2V0LnBvc2l0aW9uLnNldCggMCwgMCwgLSAxICk7XG5cdFx0XHRcdGxpZ2h0Tm9kZS5hZGQoIGxpZ2h0Tm9kZS50YXJnZXQgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ3BvaW50Jzpcblx0XHRcdFx0bGlnaHROb2RlID0gbmV3IFBvaW50TGlnaHQoIGNvbG9yICk7XG5cdFx0XHRcdGxpZ2h0Tm9kZS5kaXN0YW5jZSA9IHJhbmdlO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnc3BvdCc6XG5cdFx0XHRcdGxpZ2h0Tm9kZSA9IG5ldyBTcG90TGlnaHQoIGNvbG9yICk7XG5cdFx0XHRcdGxpZ2h0Tm9kZS5kaXN0YW5jZSA9IHJhbmdlO1xuXHRcdFx0XHQvLyBIYW5kbGUgc3BvdGxpZ2h0IHByb3BlcnRpZXMuXG5cdFx0XHRcdGxpZ2h0RGVmLnNwb3QgPSBsaWdodERlZi5zcG90IHx8IHt9O1xuXHRcdFx0XHRsaWdodERlZi5zcG90LmlubmVyQ29uZUFuZ2xlID0gbGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSAhPT0gdW5kZWZpbmVkID8gbGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSA6IDA7XG5cdFx0XHRcdGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGUgPSBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlICE9PSB1bmRlZmluZWQgPyBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlIDogTWF0aC5QSSAvIDQuMDtcblx0XHRcdFx0bGlnaHROb2RlLmFuZ2xlID0gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZTtcblx0XHRcdFx0bGlnaHROb2RlLnBlbnVtYnJhID0gMS4wIC0gbGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSAvIGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGU7XG5cdFx0XHRcdGxpZ2h0Tm9kZS50YXJnZXQucG9zaXRpb24uc2V0KCAwLCAwLCAtIDEgKTtcblx0XHRcdFx0bGlnaHROb2RlLmFkZCggbGlnaHROb2RlLnRhcmdldCApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogVW5leHBlY3RlZCBsaWdodCB0eXBlOiAnICsgbGlnaHREZWYudHlwZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gU29tZSBsaWdodHMgKGUuZy4gc3BvdCkgZGVmYXVsdCB0byBhIHBvc2l0aW9uIG90aGVyIHRoYW4gdGhlIG9yaWdpbi4gUmVzZXQgdGhlIHBvc2l0aW9uXG5cdFx0Ly8gaGVyZSwgYmVjYXVzZSBub2RlLWxldmVsIHBhcnNpbmcgd2lsbCBvbmx5IG92ZXJyaWRlIHBvc2l0aW9uIGlmIGV4cGxpY2l0bHkgc3BlY2lmaWVkLlxuXHRcdGxpZ2h0Tm9kZS5wb3NpdGlvbi5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdGxpZ2h0Tm9kZS5kZWNheSA9IDI7XG5cblx0XHRpZiAoIGxpZ2h0RGVmLmludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgbGlnaHROb2RlLmludGVuc2l0eSA9IGxpZ2h0RGVmLmludGVuc2l0eTtcblxuXHRcdGxpZ2h0Tm9kZS5uYW1lID0gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUoIGxpZ2h0RGVmLm5hbWUgfHwgKCAnbGlnaHRfJyArIGxpZ2h0SW5kZXggKSApO1xuXG5cdFx0ZGVwZW5kZW5jeSA9IFByb21pc2UucmVzb2x2ZSggbGlnaHROb2RlICk7XG5cblx0XHRwYXJzZXIuY2FjaGUuYWRkKCBjYWNoZUtleSwgZGVwZW5kZW5jeSApO1xuXG5cdFx0cmV0dXJuIGRlcGVuZGVuY3k7XG5cblx0fVxuXG5cdGNyZWF0ZU5vZGVBdHRhY2htZW50KCBub2RlSW5kZXggKSB7XG5cblx0XHRjb25zdCBzZWxmID0gdGhpcztcblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcblx0XHRjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG5cdFx0Y29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbIG5vZGVJbmRleCBdO1xuXHRcdGNvbnN0IGxpZ2h0RGVmID0gKCBub2RlRGVmLmV4dGVuc2lvbnMgJiYgbm9kZURlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXSApIHx8IHt9O1xuXHRcdGNvbnN0IGxpZ2h0SW5kZXggPSBsaWdodERlZi5saWdodDtcblxuXHRcdGlmICggbGlnaHRJbmRleCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIG51bGw7XG5cblx0XHRyZXR1cm4gdGhpcy5fbG9hZExpZ2h0KCBsaWdodEluZGV4ICkudGhlbiggZnVuY3Rpb24gKCBsaWdodCApIHtcblxuXHRcdFx0cmV0dXJuIHBhcnNlci5fZ2V0Tm9kZVJlZiggc2VsZi5jYWNoZSwgbGlnaHRJbmRleCwgbGlnaHQgKTtcblxuXHRcdH0gKTtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBVbmxpdCBNYXRlcmlhbHMgRXh0ZW5zaW9uXG4gKlxuICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX21hdGVyaWFsc191bmxpdFxuICovXG5jbGFzcyBHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24ge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUO1xuXG5cdH1cblxuXHRnZXRNYXRlcmlhbFR5cGUoKSB7XG5cblx0XHRyZXR1cm4gTWVzaEJhc2ljTWF0ZXJpYWw7XG5cblx0fVxuXG5cdGV4dGVuZFBhcmFtcyggbWF0ZXJpYWxQYXJhbXMsIG1hdGVyaWFsRGVmLCBwYXJzZXIgKSB7XG5cblx0XHRjb25zdCBwZW5kaW5nID0gW107XG5cblx0XHRtYXRlcmlhbFBhcmFtcy5jb2xvciA9IG5ldyBDb2xvciggMS4wLCAxLjAsIDEuMCApO1xuXHRcdG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSAxLjA7XG5cblx0XHRjb25zdCBtZXRhbGxpY1JvdWdobmVzcyA9IG1hdGVyaWFsRGVmLnBick1ldGFsbGljUm91Z2huZXNzO1xuXG5cdFx0aWYgKCBtZXRhbGxpY1JvdWdobmVzcyApIHtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3IgKSApIHtcblxuXHRcdFx0XHRjb25zdCBhcnJheSA9IG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvcjtcblxuXHRcdFx0XHRtYXRlcmlhbFBhcmFtcy5jb2xvci5mcm9tQXJyYXkoIGFycmF5ICk7XG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSBhcnJheVsgMyBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnbWFwJywgbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIENsZWFyY29hdCBNYXRlcmlhbHMgRXh0ZW5zaW9uXG4gKlxuICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX21hdGVyaWFsc19jbGVhcmNvYXRcbiAqL1xuY2xhc3MgR0xURk1hdGVyaWFsc0NsZWFyY29hdEV4dGVuc2lvbiB7XG5cblx0Y29uc3RydWN0b3IoIHBhcnNlciApIHtcblxuXHRcdHRoaXMucGFyc2VyID0gcGFyc2VyO1xuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19DTEVBUkNPQVQ7XG5cblx0fVxuXG5cdGdldE1hdGVyaWFsVHlwZSggbWF0ZXJpYWxJbmRleCApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRpZiAoICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkgcmV0dXJuIG51bGw7XG5cblx0XHRyZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG5cblx0fVxuXG5cdGV4dGVuZE1hdGVyaWFsUGFyYW1zKCBtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcyApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRpZiAoICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkge1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwZW5kaW5nID0gW107XG5cblx0XHRjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXTtcblxuXHRcdGlmICggZXh0ZW5zaW9uLmNsZWFyY29hdEZhY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5jbGVhcmNvYXQgPSBleHRlbnNpb24uY2xlYXJjb2F0RmFjdG9yO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBleHRlbnNpb24uY2xlYXJjb2F0VGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ2NsZWFyY29hdE1hcCcsIGV4dGVuc2lvbi5jbGVhcmNvYXRUZXh0dXJlICkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggZXh0ZW5zaW9uLmNsZWFyY29hdFJvdWdobmVzc0ZhY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5jbGVhcmNvYXRSb3VnaG5lc3MgPSBleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ2NsZWFyY29hdFJvdWdobmVzc01hcCcsIGV4dGVuc2lvbi5jbGVhcmNvYXRSb3VnaG5lc3NUZXh0dXJlICkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggZXh0ZW5zaW9uLmNsZWFyY29hdE5vcm1hbFRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdjbGVhcmNvYXROb3JtYWxNYXAnLCBleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZSApICk7XG5cblx0XHRcdGlmICggZXh0ZW5zaW9uLmNsZWFyY29hdE5vcm1hbFRleHR1cmUuc2NhbGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zdCBzY2FsZSA9IGV4dGVuc2lvbi5jbGVhcmNvYXROb3JtYWxUZXh0dXJlLnNjYWxlO1xuXG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLmNsZWFyY29hdE5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoIHNjYWxlLCBzY2FsZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKTtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBTaGVlbiBNYXRlcmlhbHMgRXh0ZW5zaW9uXG4gKlxuICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFpbi9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl9tYXRlcmlhbHNfc2hlZW5cbiAqL1xuY2xhc3MgR0xURk1hdGVyaWFsc1NoZWVuRXh0ZW5zaW9uIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyc2VyICkge1xuXG5cdFx0dGhpcy5wYXJzZXIgPSBwYXJzZXI7XG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1NIRUVOO1xuXG5cdH1cblxuXHRnZXRNYXRlcmlhbFR5cGUoIG1hdGVyaWFsSW5kZXggKSB7XG5cblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcblx0XHRjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1sgbWF0ZXJpYWxJbmRleCBdO1xuXG5cdFx0aWYgKCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgISBtYXRlcmlhbERlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXSApIHJldHVybiBudWxsO1xuXG5cdFx0cmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuXG5cdH1cblxuXHRleHRlbmRNYXRlcmlhbFBhcmFtcyggbWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMgKSB7XG5cblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcblx0XHRjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1sgbWF0ZXJpYWxJbmRleCBdO1xuXG5cdFx0aWYgKCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgISBtYXRlcmlhbERlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXSApIHtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcGVuZGluZyA9IFtdO1xuXG5cdFx0bWF0ZXJpYWxQYXJhbXMuc2hlZW5Db2xvciA9IG5ldyBDb2xvciggMCwgMCwgMCApO1xuXHRcdG1hdGVyaWFsUGFyYW1zLnNoZWVuUm91Z2huZXNzID0gMDtcblx0XHRtYXRlcmlhbFBhcmFtcy5zaGVlbiA9IDE7XG5cblx0XHRjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXTtcblxuXHRcdGlmICggZXh0ZW5zaW9uLnNoZWVuQ29sb3JGYWN0b3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMuc2hlZW5Db2xvci5mcm9tQXJyYXkoIGV4dGVuc2lvbi5zaGVlbkNvbG9yRmFjdG9yICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGV4dGVuc2lvbi5zaGVlblJvdWdobmVzc0ZhY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5zaGVlblJvdWdobmVzcyA9IGV4dGVuc2lvbi5zaGVlblJvdWdobmVzc0ZhY3RvcjtcblxuXHRcdH1cblxuXHRcdGlmICggZXh0ZW5zaW9uLnNoZWVuQ29sb3JUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnc2hlZW5Db2xvck1hcCcsIGV4dGVuc2lvbi5zaGVlbkNvbG9yVGV4dHVyZSApICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGV4dGVuc2lvbi5zaGVlblJvdWdobmVzc1RleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdzaGVlblJvdWdobmVzc01hcCcsIGV4dGVuc2lvbi5zaGVlblJvdWdobmVzc1RleHR1cmUgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nICk7XG5cblx0fVxuXG59XG5cbi8qKlxuICogVHJhbnNtaXNzaW9uIE1hdGVyaWFscyBFeHRlbnNpb25cbiAqXG4gKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfbWF0ZXJpYWxzX3RyYW5zbWlzc2lvblxuICogRHJhZnQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9wdWxsLzE2OThcbiAqL1xuY2xhc3MgR0xURk1hdGVyaWFsc1RyYW5zbWlzc2lvbkV4dGVuc2lvbiB7XG5cblx0Y29uc3RydWN0b3IoIHBhcnNlciApIHtcblxuXHRcdHRoaXMucGFyc2VyID0gcGFyc2VyO1xuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19UUkFOU01JU1NJT047XG5cblx0fVxuXG5cdGdldE1hdGVyaWFsVHlwZSggbWF0ZXJpYWxJbmRleCApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRpZiAoICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkgcmV0dXJuIG51bGw7XG5cblx0XHRyZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG5cblx0fVxuXG5cdGV4dGVuZE1hdGVyaWFsUGFyYW1zKCBtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcyApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRpZiAoICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkge1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwZW5kaW5nID0gW107XG5cblx0XHRjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXTtcblxuXHRcdGlmICggZXh0ZW5zaW9uLnRyYW5zbWlzc2lvbkZhY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy50cmFuc21pc3Npb24gPSBleHRlbnNpb24udHJhbnNtaXNzaW9uRmFjdG9yO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBleHRlbnNpb24udHJhbnNtaXNzaW9uVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ3RyYW5zbWlzc2lvbk1hcCcsIGV4dGVuc2lvbi50cmFuc21pc3Npb25UZXh0dXJlICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIE1hdGVyaWFscyBWb2x1bWUgRXh0ZW5zaW9uXG4gKlxuICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX21hdGVyaWFsc192b2x1bWVcbiAqL1xuY2xhc3MgR0xURk1hdGVyaWFsc1ZvbHVtZUV4dGVuc2lvbiB7XG5cblx0Y29uc3RydWN0b3IoIHBhcnNlciApIHtcblxuXHRcdHRoaXMucGFyc2VyID0gcGFyc2VyO1xuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19WT0xVTUU7XG5cblx0fVxuXG5cdGdldE1hdGVyaWFsVHlwZSggbWF0ZXJpYWxJbmRleCApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRpZiAoICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkgcmV0dXJuIG51bGw7XG5cblx0XHRyZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG5cblx0fVxuXG5cdGV4dGVuZE1hdGVyaWFsUGFyYW1zKCBtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcyApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRpZiAoICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkge1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwZW5kaW5nID0gW107XG5cblx0XHRjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXTtcblxuXHRcdG1hdGVyaWFsUGFyYW1zLnRoaWNrbmVzcyA9IGV4dGVuc2lvbi50aGlja25lc3NGYWN0b3IgIT09IHVuZGVmaW5lZCA/IGV4dGVuc2lvbi50aGlja25lc3NGYWN0b3IgOiAwO1xuXG5cdFx0aWYgKCBleHRlbnNpb24udGhpY2tuZXNzVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ3RoaWNrbmVzc01hcCcsIGV4dGVuc2lvbi50aGlja25lc3NUZXh0dXJlICkgKTtcblxuXHRcdH1cblxuXHRcdG1hdGVyaWFsUGFyYW1zLmF0dGVudWF0aW9uRGlzdGFuY2UgPSBleHRlbnNpb24uYXR0ZW51YXRpb25EaXN0YW5jZSB8fCAwO1xuXG5cdFx0Y29uc3QgY29sb3JBcnJheSA9IGV4dGVuc2lvbi5hdHRlbnVhdGlvbkNvbG9yIHx8IFsgMSwgMSwgMSBdO1xuXHRcdG1hdGVyaWFsUGFyYW1zLmF0dGVudWF0aW9uQ29sb3IgPSBuZXcgQ29sb3IoIGNvbG9yQXJyYXlbIDAgXSwgY29sb3JBcnJheVsgMSBdLCBjb2xvckFycmF5WyAyIF0gKTtcblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIE1hdGVyaWFscyBpb3IgRXh0ZW5zaW9uXG4gKlxuICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX21hdGVyaWFsc19pb3JcbiAqL1xuY2xhc3MgR0xURk1hdGVyaWFsc0lvckV4dGVuc2lvbiB7XG5cblx0Y29uc3RydWN0b3IoIHBhcnNlciApIHtcblxuXHRcdHRoaXMucGFyc2VyID0gcGFyc2VyO1xuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19JT1I7XG5cblx0fVxuXG5cdGdldE1hdGVyaWFsVHlwZSggbWF0ZXJpYWxJbmRleCApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRpZiAoICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkgcmV0dXJuIG51bGw7XG5cblx0XHRyZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG5cblx0fVxuXG5cdGV4dGVuZE1hdGVyaWFsUGFyYW1zKCBtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcyApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRpZiAoICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkge1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXTtcblxuXHRcdG1hdGVyaWFsUGFyYW1zLmlvciA9IGV4dGVuc2lvbi5pb3IgIT09IHVuZGVmaW5lZCA/IGV4dGVuc2lvbi5pb3IgOiAxLjU7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cblx0fVxuXG59XG5cbi8qKlxuICogTWF0ZXJpYWxzIHNwZWN1bGFyIEV4dGVuc2lvblxuICpcbiAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl9tYXRlcmlhbHNfc3BlY3VsYXJcbiAqL1xuY2xhc3MgR0xURk1hdGVyaWFsc1NwZWN1bGFyRXh0ZW5zaW9uIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyc2VyICkge1xuXG5cdFx0dGhpcy5wYXJzZXIgPSBwYXJzZXI7XG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1NQRUNVTEFSO1xuXG5cdH1cblxuXHRnZXRNYXRlcmlhbFR5cGUoIG1hdGVyaWFsSW5kZXggKSB7XG5cblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcblx0XHRjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1sgbWF0ZXJpYWxJbmRleCBdO1xuXG5cdFx0aWYgKCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgISBtYXRlcmlhbERlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXSApIHJldHVybiBudWxsO1xuXG5cdFx0cmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuXG5cdH1cblxuXHRleHRlbmRNYXRlcmlhbFBhcmFtcyggbWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMgKSB7XG5cblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcblx0XHRjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1sgbWF0ZXJpYWxJbmRleCBdO1xuXG5cdFx0aWYgKCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgISBtYXRlcmlhbERlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXSApIHtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcGVuZGluZyA9IFtdO1xuXG5cdFx0Y29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF07XG5cblx0XHRtYXRlcmlhbFBhcmFtcy5zcGVjdWxhckludGVuc2l0eSA9IGV4dGVuc2lvbi5zcGVjdWxhckZhY3RvciAhPT0gdW5kZWZpbmVkID8gZXh0ZW5zaW9uLnNwZWN1bGFyRmFjdG9yIDogMS4wO1xuXG5cdFx0aWYgKCBleHRlbnNpb24uc3BlY3VsYXJUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnc3BlY3VsYXJJbnRlbnNpdHlNYXAnLCBleHRlbnNpb24uc3BlY3VsYXJUZXh0dXJlICkgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGNvbG9yQXJyYXkgPSBleHRlbnNpb24uc3BlY3VsYXJDb2xvckZhY3RvciB8fCBbIDEsIDEsIDEgXTtcblx0XHRtYXRlcmlhbFBhcmFtcy5zcGVjdWxhckNvbG9yID0gbmV3IENvbG9yKCBjb2xvckFycmF5WyAwIF0sIGNvbG9yQXJyYXlbIDEgXSwgY29sb3JBcnJheVsgMiBdICk7XG5cblx0XHRpZiAoIGV4dGVuc2lvbi5zcGVjdWxhckNvbG9yVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ3NwZWN1bGFyQ29sb3JNYXAnLCBleHRlbnNpb24uc3BlY3VsYXJDb2xvclRleHR1cmUgKS50aGVuKCBmdW5jdGlvbiAoIHRleHR1cmUgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5lbmNvZGluZyA9IHNSR0JFbmNvZGluZztcblxuXHRcdFx0fSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKTtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBCYXNpc1UgVGV4dHVyZSBFeHRlbnNpb25cbiAqXG4gKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfdGV4dHVyZV9iYXNpc3VcbiAqL1xuY2xhc3MgR0xURlRleHR1cmVCYXNpc1VFeHRlbnNpb24ge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJzZXIgKSB7XG5cblx0XHR0aGlzLnBhcnNlciA9IHBhcnNlcjtcblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9URVhUVVJFX0JBU0lTVTtcblxuXHR9XG5cblx0bG9hZFRleHR1cmUoIHRleHR1cmVJbmRleCApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcblxuXHRcdGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzWyB0ZXh0dXJlSW5kZXggXTtcblxuXHRcdGlmICggISB0ZXh0dXJlRGVmLmV4dGVuc2lvbnMgfHwgISB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkge1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGV4dGVuc2lvbiA9IHRleHR1cmVEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF07XG5cdFx0Y29uc3Qgc291cmNlID0ganNvbi5pbWFnZXNbIGV4dGVuc2lvbi5zb3VyY2UgXTtcblx0XHRjb25zdCBsb2FkZXIgPSBwYXJzZXIub3B0aW9ucy5rdHgyTG9hZGVyO1xuXG5cdFx0aWYgKCAhIGxvYWRlciApIHtcblxuXHRcdFx0aWYgKCBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCAmJiBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKCB0aGlzLm5hbWUgKSA+PSAwICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IHNldEtUWDJMb2FkZXIgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGxvYWRpbmcgS1RYMiB0ZXh0dXJlcycgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBBc3N1bWVzIHRoYXQgdGhlIGV4dGVuc2lvbiBpcyBvcHRpb25hbCBhbmQgdGhhdCBhIGZhbGxiYWNrIHRleHR1cmUgaXMgcHJlc2VudFxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZUltYWdlKCB0ZXh0dXJlSW5kZXgsIHNvdXJjZSwgbG9hZGVyICk7XG5cblx0fVxuXG59XG5cbi8qKlxuICogV2ViUCBUZXh0dXJlIEV4dGVuc2lvblxuICpcbiAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9WZW5kb3IvRVhUX3RleHR1cmVfd2VicFxuICovXG5jbGFzcyBHTFRGVGV4dHVyZVdlYlBFeHRlbnNpb24ge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJzZXIgKSB7XG5cblx0XHR0aGlzLnBhcnNlciA9IHBhcnNlcjtcblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLkVYVF9URVhUVVJFX1dFQlA7XG5cdFx0dGhpcy5pc1N1cHBvcnRlZCA9IG51bGw7XG5cblx0fVxuXG5cdGxvYWRUZXh0dXJlKCB0ZXh0dXJlSW5kZXggKSB7XG5cblx0XHRjb25zdCBuYW1lID0gdGhpcy5uYW1lO1xuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcblxuXHRcdGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzWyB0ZXh0dXJlSW5kZXggXTtcblxuXHRcdGlmICggISB0ZXh0dXJlRGVmLmV4dGVuc2lvbnMgfHwgISB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbIG5hbWUgXSApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRjb25zdCBleHRlbnNpb24gPSB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbIG5hbWUgXTtcblx0XHRjb25zdCBzb3VyY2UgPSBqc29uLmltYWdlc1sgZXh0ZW5zaW9uLnNvdXJjZSBdO1xuXG5cdFx0bGV0IGxvYWRlciA9IHBhcnNlci50ZXh0dXJlTG9hZGVyO1xuXHRcdGlmICggc291cmNlLnVyaSApIHtcblxuXHRcdFx0Y29uc3QgaGFuZGxlciA9IHBhcnNlci5vcHRpb25zLm1hbmFnZXIuZ2V0SGFuZGxlciggc291cmNlLnVyaSApO1xuXHRcdFx0aWYgKCBoYW5kbGVyICE9PSBudWxsICkgbG9hZGVyID0gaGFuZGxlcjtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmRldGVjdFN1cHBvcnQoKS50aGVuKCBmdW5jdGlvbiAoIGlzU3VwcG9ydGVkICkge1xuXG5cdFx0XHRpZiAoIGlzU3VwcG9ydGVkICkgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZUltYWdlKCB0ZXh0dXJlSW5kZXgsIHNvdXJjZSwgbG9hZGVyICk7XG5cblx0XHRcdGlmICgganNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZiggbmFtZSApID49IDAgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogV2ViUCByZXF1aXJlZCBieSBhc3NldCBidXQgdW5zdXBwb3J0ZWQuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIEZhbGwgYmFjayB0byBQTkcgb3IgSlBFRy5cblx0XHRcdHJldHVybiBwYXJzZXIubG9hZFRleHR1cmUoIHRleHR1cmVJbmRleCApO1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHRkZXRlY3RTdXBwb3J0KCkge1xuXG5cdFx0aWYgKCAhIHRoaXMuaXNTdXBwb3J0ZWQgKSB7XG5cblx0XHRcdHRoaXMuaXNTdXBwb3J0ZWQgPSBuZXcgUHJvbWlzZSggZnVuY3Rpb24gKCByZXNvbHZlICkge1xuXG5cdFx0XHRcdGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG5cblx0XHRcdFx0Ly8gTG9zc3kgdGVzdCBpbWFnZS4gU3VwcG9ydCBmb3IgbG9zc3kgaW1hZ2VzIGRvZXNuJ3QgZ3VhcmFudGVlIHN1cHBvcnQgZm9yIGFsbFxuXHRcdFx0XHQvLyBXZWJQIGltYWdlcywgdW5mb3J0dW5hdGVseS5cblx0XHRcdFx0aW1hZ2Uuc3JjID0gJ2RhdGE6aW1hZ2Uvd2VicDtiYXNlNjQsVWtsR1JpSUFBQUJYUlVKUVZsQTRJQllBQUFBd0FRQ2RBU29CQUFFQURzRCtKYVFBQTNBQUFBQUEnO1xuXG5cdFx0XHRcdGltYWdlLm9ubG9hZCA9IGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRyZXNvbHZlKCBpbWFnZS5oZWlnaHQgPT09IDEgKTtcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5pc1N1cHBvcnRlZDtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBtZXNob3B0IEJ1ZmZlclZpZXcgQ29tcHJlc3Npb24gRXh0ZW5zaW9uXG4gKlxuICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL1ZlbmRvci9FWFRfbWVzaG9wdF9jb21wcmVzc2lvblxuICovXG5jbGFzcyBHTFRGTWVzaG9wdENvbXByZXNzaW9uIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyc2VyICkge1xuXG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfTUVTSE9QVF9DT01QUkVTU0lPTjtcblx0XHR0aGlzLnBhcnNlciA9IHBhcnNlcjtcblxuXHR9XG5cblx0bG9hZEJ1ZmZlclZpZXcoIGluZGV4ICkge1xuXG5cdFx0Y29uc3QganNvbiA9IHRoaXMucGFyc2VyLmpzb247XG5cdFx0Y29uc3QgYnVmZmVyVmlldyA9IGpzb24uYnVmZmVyVmlld3NbIGluZGV4IF07XG5cblx0XHRpZiAoIGJ1ZmZlclZpZXcuZXh0ZW5zaW9ucyAmJiBidWZmZXJWaWV3LmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkge1xuXG5cdFx0XHRjb25zdCBleHRlbnNpb25EZWYgPSBidWZmZXJWaWV3LmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdO1xuXG5cdFx0XHRjb25zdCBidWZmZXIgPSB0aGlzLnBhcnNlci5nZXREZXBlbmRlbmN5KCAnYnVmZmVyJywgZXh0ZW5zaW9uRGVmLmJ1ZmZlciApO1xuXHRcdFx0Y29uc3QgZGVjb2RlciA9IHRoaXMucGFyc2VyLm9wdGlvbnMubWVzaG9wdERlY29kZXI7XG5cblx0XHRcdGlmICggISBkZWNvZGVyIHx8ICEgZGVjb2Rlci5zdXBwb3J0ZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCAmJiBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKCB0aGlzLm5hbWUgKSA+PSAwICkge1xuXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogc2V0TWVzaG9wdERlY29kZXIgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGxvYWRpbmcgY29tcHJlc3NlZCBmaWxlcycgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gQXNzdW1lcyB0aGF0IHRoZSBleHRlbnNpb24gaXMgb3B0aW9uYWwgYW5kIHRoYXQgZmFsbGJhY2sgYnVmZmVyIGRhdGEgaXMgcHJlc2VudFxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIFsgYnVmZmVyLCBkZWNvZGVyLnJlYWR5IF0gKS50aGVuKCBmdW5jdGlvbiAoIHJlcyApIHtcblxuXHRcdFx0XHRjb25zdCBieXRlT2Zmc2V0ID0gZXh0ZW5zaW9uRGVmLmJ5dGVPZmZzZXQgfHwgMDtcblx0XHRcdFx0Y29uc3QgYnl0ZUxlbmd0aCA9IGV4dGVuc2lvbkRlZi5ieXRlTGVuZ3RoIHx8IDA7XG5cblx0XHRcdFx0Y29uc3QgY291bnQgPSBleHRlbnNpb25EZWYuY291bnQ7XG5cdFx0XHRcdGNvbnN0IHN0cmlkZSA9IGV4dGVuc2lvbkRlZi5ieXRlU3RyaWRlO1xuXG5cdFx0XHRcdGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheUJ1ZmZlciggY291bnQgKiBzdHJpZGUgKTtcblx0XHRcdFx0Y29uc3Qgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkoIHJlc1sgMCBdLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoICk7XG5cblx0XHRcdFx0ZGVjb2Rlci5kZWNvZGVHbHRmQnVmZmVyKCBuZXcgVWludDhBcnJheSggcmVzdWx0ICksIGNvdW50LCBzdHJpZGUsIHNvdXJjZSwgZXh0ZW5zaW9uRGVmLm1vZGUsIGV4dGVuc2lvbkRlZi5maWx0ZXIgKTtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuXHRcdFx0fSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbi8qIEJJTkFSWSBFWFRFTlNJT04gKi9cbmNvbnN0IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX01BR0lDID0gJ2dsVEYnO1xuY29uc3QgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIID0gMTI7XG5jb25zdCBCSU5BUllfRVhURU5TSU9OX0NIVU5LX1RZUEVTID0geyBKU09OOiAweDRFNEY1MzRBLCBCSU46IDB4MDA0RTQ5NDIgfTtcblxuY2xhc3MgR0xURkJpbmFyeUV4dGVuc2lvbiB7XG5cblx0Y29uc3RydWN0b3IoIGRhdGEgKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURjtcblx0XHR0aGlzLmNvbnRlbnQgPSBudWxsO1xuXHRcdHRoaXMuYm9keSA9IG51bGw7XG5cblx0XHRjb25zdCBoZWFkZXJWaWV3ID0gbmV3IERhdGFWaWV3KCBkYXRhLCAwLCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEggKTtcblxuXHRcdHRoaXMuaGVhZGVyID0ge1xuXHRcdFx0bWFnaWM6IExvYWRlclV0aWxzLmRlY29kZVRleHQoIG5ldyBVaW50OEFycmF5KCBkYXRhLnNsaWNlKCAwLCA0ICkgKSApLFxuXHRcdFx0dmVyc2lvbjogaGVhZGVyVmlldy5nZXRVaW50MzIoIDQsIHRydWUgKSxcblx0XHRcdGxlbmd0aDogaGVhZGVyVmlldy5nZXRVaW50MzIoIDgsIHRydWUgKVxuXHRcdH07XG5cblx0XHRpZiAoIHRoaXMuaGVhZGVyLm1hZ2ljICE9PSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQyApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgZ2xURi1CaW5hcnkgaGVhZGVyLicgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuaGVhZGVyLnZlcnNpb24gPCAyLjAgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IExlZ2FjeSBiaW5hcnkgZmlsZSBkZXRlY3RlZC4nICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBjaHVua0NvbnRlbnRzTGVuZ3RoID0gdGhpcy5oZWFkZXIubGVuZ3RoIC0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIO1xuXHRcdGNvbnN0IGNodW5rVmlldyA9IG5ldyBEYXRhVmlldyggZGF0YSwgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIICk7XG5cdFx0bGV0IGNodW5rSW5kZXggPSAwO1xuXG5cdFx0d2hpbGUgKCBjaHVua0luZGV4IDwgY2h1bmtDb250ZW50c0xlbmd0aCApIHtcblxuXHRcdFx0Y29uc3QgY2h1bmtMZW5ndGggPSBjaHVua1ZpZXcuZ2V0VWludDMyKCBjaHVua0luZGV4LCB0cnVlICk7XG5cdFx0XHRjaHVua0luZGV4ICs9IDQ7XG5cblx0XHRcdGNvbnN0IGNodW5rVHlwZSA9IGNodW5rVmlldy5nZXRVaW50MzIoIGNodW5rSW5kZXgsIHRydWUgKTtcblx0XHRcdGNodW5rSW5kZXggKz0gNDtcblxuXHRcdFx0aWYgKCBjaHVua1R5cGUgPT09IEJJTkFSWV9FWFRFTlNJT05fQ0hVTktfVFlQRVMuSlNPTiApIHtcblxuXHRcdFx0XHRjb25zdCBjb250ZW50QXJyYXkgPSBuZXcgVWludDhBcnJheSggZGF0YSwgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIICsgY2h1bmtJbmRleCwgY2h1bmtMZW5ndGggKTtcblx0XHRcdFx0dGhpcy5jb250ZW50ID0gTG9hZGVyVXRpbHMuZGVjb2RlVGV4dCggY29udGVudEFycmF5ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGNodW5rVHlwZSA9PT0gQklOQVJZX0VYVEVOU0lPTl9DSFVOS19UWVBFUy5CSU4gKSB7XG5cblx0XHRcdFx0Y29uc3QgYnl0ZU9mZnNldCA9IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCArIGNodW5rSW5kZXg7XG5cdFx0XHRcdHRoaXMuYm9keSA9IGRhdGEuc2xpY2UoIGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBjaHVua0xlbmd0aCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIENsaWVudHMgbXVzdCBpZ25vcmUgY2h1bmtzIHdpdGggdW5rbm93biB0eXBlcy5cblxuXHRcdFx0Y2h1bmtJbmRleCArPSBjaHVua0xlbmd0aDtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5jb250ZW50ID09PSBudWxsICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBKU09OIGNvbnRlbnQgbm90IGZvdW5kLicgKTtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuLyoqXG4gKiBEUkFDTyBNZXNoIENvbXByZXNzaW9uIEV4dGVuc2lvblxuICpcbiAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl9kcmFjb19tZXNoX2NvbXByZXNzaW9uXG4gKi9cbmNsYXNzIEdMVEZEcmFjb01lc2hDb21wcmVzc2lvbkV4dGVuc2lvbiB7XG5cblx0Y29uc3RydWN0b3IoIGpzb24sIGRyYWNvTG9hZGVyICkge1xuXG5cdFx0aWYgKCAhIGRyYWNvTG9hZGVyICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBObyBEUkFDT0xvYWRlciBpbnN0YW5jZSBwcm92aWRlZC4nICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OO1xuXHRcdHRoaXMuanNvbiA9IGpzb247XG5cdFx0dGhpcy5kcmFjb0xvYWRlciA9IGRyYWNvTG9hZGVyO1xuXHRcdHRoaXMuZHJhY29Mb2FkZXIucHJlbG9hZCgpO1xuXG5cdH1cblxuXHRkZWNvZGVQcmltaXRpdmUoIHByaW1pdGl2ZSwgcGFyc2VyICkge1xuXG5cdFx0Y29uc3QganNvbiA9IHRoaXMuanNvbjtcblx0XHRjb25zdCBkcmFjb0xvYWRlciA9IHRoaXMuZHJhY29Mb2FkZXI7XG5cdFx0Y29uc3QgYnVmZmVyVmlld0luZGV4ID0gcHJpbWl0aXZlLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdLmJ1ZmZlclZpZXc7XG5cdFx0Y29uc3QgZ2x0ZkF0dHJpYnV0ZU1hcCA9IHByaW1pdGl2ZS5leHRlbnNpb25zWyB0aGlzLm5hbWUgXS5hdHRyaWJ1dGVzO1xuXHRcdGNvbnN0IHRocmVlQXR0cmlidXRlTWFwID0ge307XG5cdFx0Y29uc3QgYXR0cmlidXRlTm9ybWFsaXplZE1hcCA9IHt9O1xuXHRcdGNvbnN0IGF0dHJpYnV0ZVR5cGVNYXAgPSB7fTtcblxuXHRcdGZvciAoIGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gZ2x0ZkF0dHJpYnV0ZU1hcCApIHtcblxuXHRcdFx0Y29uc3QgdGhyZWVBdHRyaWJ1dGVOYW1lID0gQVRUUklCVVRFU1sgYXR0cmlidXRlTmFtZSBdIHx8IGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0dGhyZWVBdHRyaWJ1dGVNYXBbIHRocmVlQXR0cmlidXRlTmFtZSBdID0gZ2x0ZkF0dHJpYnV0ZU1hcFsgYXR0cmlidXRlTmFtZSBdO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggY29uc3QgYXR0cmlidXRlTmFtZSBpbiBwcmltaXRpdmUuYXR0cmlidXRlcyApIHtcblxuXHRcdFx0Y29uc3QgdGhyZWVBdHRyaWJ1dGVOYW1lID0gQVRUUklCVVRFU1sgYXR0cmlidXRlTmFtZSBdIHx8IGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBnbHRmQXR0cmlidXRlTWFwWyBhdHRyaWJ1dGVOYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zdCBhY2Nlc3NvckRlZiA9IGpzb24uYWNjZXNzb3JzWyBwcmltaXRpdmUuYXR0cmlidXRlc1sgYXR0cmlidXRlTmFtZSBdIF07XG5cdFx0XHRcdGNvbnN0IGNvbXBvbmVudFR5cGUgPSBXRUJHTF9DT01QT05FTlRfVFlQRVNbIGFjY2Vzc29yRGVmLmNvbXBvbmVudFR5cGUgXTtcblxuXHRcdFx0XHRhdHRyaWJ1dGVUeXBlTWFwWyB0aHJlZUF0dHJpYnV0ZU5hbWUgXSA9IGNvbXBvbmVudFR5cGU7XG5cdFx0XHRcdGF0dHJpYnV0ZU5vcm1hbGl6ZWRNYXBbIHRocmVlQXR0cmlidXRlTmFtZSBdID0gYWNjZXNzb3JEZWYubm9ybWFsaXplZCA9PT0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KCAnYnVmZmVyVmlldycsIGJ1ZmZlclZpZXdJbmRleCApLnRoZW4oIGZ1bmN0aW9uICggYnVmZmVyVmlldyApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKCBmdW5jdGlvbiAoIHJlc29sdmUgKSB7XG5cblx0XHRcdFx0ZHJhY29Mb2FkZXIuZGVjb2RlRHJhY29GaWxlKCBidWZmZXJWaWV3LCBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdFx0Zm9yICggY29uc3QgYXR0cmlidXRlTmFtZSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBhdHRyaWJ1dGVOYW1lIF07XG5cdFx0XHRcdFx0XHRjb25zdCBub3JtYWxpemVkID0gYXR0cmlidXRlTm9ybWFsaXplZE1hcFsgYXR0cmlidXRlTmFtZSBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vcm1hbGl6ZWQgIT09IHVuZGVmaW5lZCApIGF0dHJpYnV0ZS5ub3JtYWxpemVkID0gbm9ybWFsaXplZDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlc29sdmUoIGdlb21ldHJ5ICk7XG5cblx0XHRcdFx0fSwgdGhyZWVBdHRyaWJ1dGVNYXAsIGF0dHJpYnV0ZVR5cGVNYXAgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fSApO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIFRleHR1cmUgVHJhbnNmb3JtIEV4dGVuc2lvblxuICpcbiAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl90ZXh0dXJlX3RyYW5zZm9ybVxuICovXG5jbGFzcyBHTFRGVGV4dHVyZVRyYW5zZm9ybUV4dGVuc2lvbiB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STTtcblxuXHR9XG5cblx0ZXh0ZW5kVGV4dHVyZSggdGV4dHVyZSwgdHJhbnNmb3JtICkge1xuXG5cdFx0aWYgKCB0cmFuc2Zvcm0udGV4Q29vcmQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogQ3VzdG9tIFVWIHNldHMgaW4gXCInICsgdGhpcy5uYW1lICsgJ1wiIGV4dGVuc2lvbiBub3QgeWV0IHN1cHBvcnRlZC4nICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRyYW5zZm9ybS5vZmZzZXQgPT09IHVuZGVmaW5lZCAmJiB0cmFuc2Zvcm0ucm90YXRpb24gPT09IHVuZGVmaW5lZCAmJiB0cmFuc2Zvcm0uc2NhbGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzIxODE5LlxuXHRcdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0XHR9XG5cblx0XHR0ZXh0dXJlID0gdGV4dHVyZS5jbG9uZSgpO1xuXG5cdFx0aWYgKCB0cmFuc2Zvcm0ub2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRleHR1cmUub2Zmc2V0LmZyb21BcnJheSggdHJhbnNmb3JtLm9mZnNldCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0cmFuc2Zvcm0ucm90YXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGV4dHVyZS5yb3RhdGlvbiA9IHRyYW5zZm9ybS5yb3RhdGlvbjtcblxuXHRcdH1cblxuXHRcdGlmICggdHJhbnNmb3JtLnNjYWxlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRleHR1cmUucmVwZWF0LmZyb21BcnJheSggdHJhbnNmb3JtLnNjYWxlICk7XG5cblx0XHR9XG5cblx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIFNwZWN1bGFyLUdsb3NzaW5lc3MgRXh0ZW5zaW9uXG4gKlxuICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX21hdGVyaWFsc19wYnJTcGVjdWxhckdsb3NzaW5lc3NcbiAqL1xuXG4vKipcbiAqIEEgc3ViIGNsYXNzIG9mIFN0YW5kYXJkTWF0ZXJpYWwgd2l0aCBzb21lIG9mIHRoZSBmdW5jdGlvbmFsaXR5XG4gKiBjaGFuZ2VkIHZpYSB0aGUgYG9uQmVmb3JlQ29tcGlsZWAgY2FsbGJhY2tcbiAqIEBwYWlsaGVhZFxuICovXG5jbGFzcyBHTFRGTWVzaFN0YW5kYXJkU0dNYXRlcmlhbCBleHRlbmRzIE1lc2hTdGFuZGFyZE1hdGVyaWFsIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyYW1zICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNHTFRGU3BlY3VsYXJHbG9zc2luZXNzTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdFx0Ly92YXJpb3VzIGNodW5rcyB0aGF0IG5lZWQgcmVwbGFjaW5nXG5cdFx0Y29uc3Qgc3BlY3VsYXJNYXBQYXJzRnJhZ21lbnRDaHVuayA9IFtcblx0XHRcdCcjaWZkZWYgVVNFX1NQRUNVTEFSTUFQJyxcblx0XHRcdCdcdHVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyTWFwOycsXG5cdFx0XHQnI2VuZGlmJ1xuXHRcdF0uam9pbiggJ1xcbicgKTtcblxuXHRcdGNvbnN0IGdsb3NzaW5lc3NNYXBQYXJzRnJhZ21lbnRDaHVuayA9IFtcblx0XHRcdCcjaWZkZWYgVVNFX0dMT1NTSU5FU1NNQVAnLFxuXHRcdFx0J1x0dW5pZm9ybSBzYW1wbGVyMkQgZ2xvc3NpbmVzc01hcDsnLFxuXHRcdFx0JyNlbmRpZidcblx0XHRdLmpvaW4oICdcXG4nICk7XG5cblx0XHRjb25zdCBzcGVjdWxhck1hcEZyYWdtZW50Q2h1bmsgPSBbXG5cdFx0XHQndmVjMyBzcGVjdWxhckZhY3RvciA9IHNwZWN1bGFyOycsXG5cdFx0XHQnI2lmZGVmIFVTRV9TUEVDVUxBUk1BUCcsXG5cdFx0XHQnXHR2ZWM0IHRleGVsU3BlY3VsYXIgPSB0ZXh0dXJlMkQoIHNwZWN1bGFyTWFwLCB2VXYgKTsnLFxuXHRcdFx0J1x0dGV4ZWxTcGVjdWxhciA9IHNSR0JUb0xpbmVhciggdGV4ZWxTcGVjdWxhciApOycsXG5cdFx0XHQnXHQvLyByZWFkcyBjaGFubmVsIFJHQiwgY29tcGF0aWJsZSB3aXRoIGEgZ2xURiBTcGVjdWxhci1HbG9zc2luZXNzIChSR0JBKSB0ZXh0dXJlJyxcblx0XHRcdCdcdHNwZWN1bGFyRmFjdG9yICo9IHRleGVsU3BlY3VsYXIucmdiOycsXG5cdFx0XHQnI2VuZGlmJ1xuXHRcdF0uam9pbiggJ1xcbicgKTtcblxuXHRcdGNvbnN0IGdsb3NzaW5lc3NNYXBGcmFnbWVudENodW5rID0gW1xuXHRcdFx0J2Zsb2F0IGdsb3NzaW5lc3NGYWN0b3IgPSBnbG9zc2luZXNzOycsXG5cdFx0XHQnI2lmZGVmIFVTRV9HTE9TU0lORVNTTUFQJyxcblx0XHRcdCdcdHZlYzQgdGV4ZWxHbG9zc2luZXNzID0gdGV4dHVyZTJEKCBnbG9zc2luZXNzTWFwLCB2VXYgKTsnLFxuXHRcdFx0J1x0Ly8gcmVhZHMgY2hhbm5lbCBBLCBjb21wYXRpYmxlIHdpdGggYSBnbFRGIFNwZWN1bGFyLUdsb3NzaW5lc3MgKFJHQkEpIHRleHR1cmUnLFxuXHRcdFx0J1x0Z2xvc3NpbmVzc0ZhY3RvciAqPSB0ZXhlbEdsb3NzaW5lc3MuYTsnLFxuXHRcdFx0JyNlbmRpZidcblx0XHRdLmpvaW4oICdcXG4nICk7XG5cblx0XHRjb25zdCBsaWdodFBoeXNpY2FsRnJhZ21lbnRDaHVuayA9IFtcblx0XHRcdCdQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsOycsXG5cdFx0XHQnbWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYiAqICggMS4gLSBtYXgoIHNwZWN1bGFyRmFjdG9yLnIsIG1heCggc3BlY3VsYXJGYWN0b3IuZywgc3BlY3VsYXJGYWN0b3IuYiApICkgKTsnLFxuXHRcdFx0J3ZlYzMgZHh5ID0gbWF4KCBhYnMoIGRGZHgoIGdlb21ldHJ5Tm9ybWFsICkgKSwgYWJzKCBkRmR5KCBnZW9tZXRyeU5vcm1hbCApICkgKTsnLFxuXHRcdFx0J2Zsb2F0IGdlb21ldHJ5Um91Z2huZXNzID0gbWF4KCBtYXgoIGR4eS54LCBkeHkueSApLCBkeHkueiApOycsXG5cdFx0XHQnbWF0ZXJpYWwucm91Z2huZXNzID0gbWF4KCAxLjAgLSBnbG9zc2luZXNzRmFjdG9yLCAwLjA1MjUgKTsgLy8gMC4wNTI1IGNvcnJlc3BvbmRzIHRvIHRoZSBiYXNlIG1pcCBvZiBhIDI1NiBjdWJlbWFwLicsXG5cdFx0XHQnbWF0ZXJpYWwucm91Z2huZXNzICs9IGdlb21ldHJ5Um91Z2huZXNzOycsXG5cdFx0XHQnbWF0ZXJpYWwucm91Z2huZXNzID0gbWluKCBtYXRlcmlhbC5yb3VnaG5lc3MsIDEuMCApOycsXG5cdFx0XHQnbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IHNwZWN1bGFyRmFjdG9yOycsXG5cdFx0XS5qb2luKCAnXFxuJyApO1xuXG5cdFx0Y29uc3QgdW5pZm9ybXMgPSB7XG5cdFx0XHRzcGVjdWxhcjogeyB2YWx1ZTogbmV3IENvbG9yKCkuc2V0SGV4KCAweGZmZmZmZiApIH0sXG5cdFx0XHRnbG9zc2luZXNzOiB7IHZhbHVlOiAxIH0sXG5cdFx0XHRzcGVjdWxhck1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0Z2xvc3NpbmVzc01hcDogeyB2YWx1ZTogbnVsbCB9XG5cdFx0fTtcblxuXHRcdHRoaXMuX2V4dHJhVW5pZm9ybXMgPSB1bmlmb3JtcztcblxuXHRcdHRoaXMub25CZWZvcmVDb21waWxlID0gZnVuY3Rpb24gKCBzaGFkZXIgKSB7XG5cblx0XHRcdGZvciAoIGNvbnN0IHVuaWZvcm1OYW1lIGluIHVuaWZvcm1zICkge1xuXG5cdFx0XHRcdHNoYWRlci51bmlmb3Jtc1sgdW5pZm9ybU5hbWUgXSA9IHVuaWZvcm1zWyB1bmlmb3JtTmFtZSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHNoYWRlci5mcmFnbWVudFNoYWRlciA9IHNoYWRlci5mcmFnbWVudFNoYWRlclxuXHRcdFx0XHQucmVwbGFjZSggJ3VuaWZvcm0gZmxvYXQgcm91Z2huZXNzOycsICd1bmlmb3JtIHZlYzMgc3BlY3VsYXI7JyApXG5cdFx0XHRcdC5yZXBsYWNlKCAndW5pZm9ybSBmbG9hdCBtZXRhbG5lc3M7JywgJ3VuaWZvcm0gZmxvYXQgZ2xvc3NpbmVzczsnIClcblx0XHRcdFx0LnJlcGxhY2UoICcjaW5jbHVkZSA8cm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQ+Jywgc3BlY3VsYXJNYXBQYXJzRnJhZ21lbnRDaHVuayApXG5cdFx0XHRcdC5yZXBsYWNlKCAnI2luY2x1ZGUgPG1ldGFsbmVzc21hcF9wYXJzX2ZyYWdtZW50PicsIGdsb3NzaW5lc3NNYXBQYXJzRnJhZ21lbnRDaHVuayApXG5cdFx0XHRcdC5yZXBsYWNlKCAnI2luY2x1ZGUgPHJvdWdobmVzc21hcF9mcmFnbWVudD4nLCBzcGVjdWxhck1hcEZyYWdtZW50Q2h1bmsgKVxuXHRcdFx0XHQucmVwbGFjZSggJyNpbmNsdWRlIDxtZXRhbG5lc3NtYXBfZnJhZ21lbnQ+JywgZ2xvc3NpbmVzc01hcEZyYWdtZW50Q2h1bmsgKVxuXHRcdFx0XHQucmVwbGFjZSggJyNpbmNsdWRlIDxsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQ+JywgbGlnaHRQaHlzaWNhbEZyYWdtZW50Q2h1bmsgKTtcblxuXHRcdH07XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuXG5cdFx0XHRzcGVjdWxhcjoge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdHJldHVybiB1bmlmb3Jtcy5zcGVjdWxhci52YWx1ZTtcblxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQ6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0XHRcdHVuaWZvcm1zLnNwZWN1bGFyLnZhbHVlID0gdjtcblxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRzcGVjdWxhck1hcDoge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdHJldHVybiB1bmlmb3Jtcy5zcGVjdWxhck1hcC52YWx1ZTtcblxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQ6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0XHRcdHVuaWZvcm1zLnNwZWN1bGFyTWFwLnZhbHVlID0gdjtcblxuXHRcdFx0XHRcdGlmICggdiApIHtcblxuXHRcdFx0XHRcdFx0dGhpcy5kZWZpbmVzLlVTRV9TUEVDVUxBUk1BUCA9ICcnOyAvLyBVU0VfVVYgaXMgc2V0IGJ5IHRoZSByZW5kZXJlciBmb3Igc3BlY3VsYXIgbWFwc1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0ZGVsZXRlIHRoaXMuZGVmaW5lcy5VU0VfU1BFQ1VMQVJNQVA7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Z2xvc3NpbmVzczoge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdHJldHVybiB1bmlmb3Jtcy5nbG9zc2luZXNzLnZhbHVlO1xuXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0XHRcdFx0dW5pZm9ybXMuZ2xvc3NpbmVzcy52YWx1ZSA9IHY7XG5cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Z2xvc3NpbmVzc01hcDoge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdHJldHVybiB1bmlmb3Jtcy5nbG9zc2luZXNzTWFwLnZhbHVlO1xuXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0XHRcdFx0dW5pZm9ybXMuZ2xvc3NpbmVzc01hcC52YWx1ZSA9IHY7XG5cblx0XHRcdFx0XHRpZiAoIHYgKSB7XG5cblx0XHRcdFx0XHRcdHRoaXMuZGVmaW5lcy5VU0VfR0xPU1NJTkVTU01BUCA9ICcnO1xuXHRcdFx0XHRcdFx0dGhpcy5kZWZpbmVzLlVTRV9VViA9ICcnO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0ZGVsZXRlIHRoaXMuZGVmaW5lcy5VU0VfR0xPU1NJTkVTU01BUDtcblx0XHRcdFx0XHRcdGRlbGV0ZSB0aGlzLmRlZmluZXMuVVNFX1VWO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gKTtcblxuXHRcdGRlbGV0ZSB0aGlzLm1ldGFsbmVzcztcblx0XHRkZWxldGUgdGhpcy5yb3VnaG5lc3M7XG5cdFx0ZGVsZXRlIHRoaXMubWV0YWxuZXNzTWFwO1xuXHRcdGRlbGV0ZSB0aGlzLnJvdWdobmVzc01hcDtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbXMgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xuXHRcdHRoaXMuc3BlY3VsYXIuY29weSggc291cmNlLnNwZWN1bGFyICk7XG5cdFx0dGhpcy5nbG9zc2luZXNzTWFwID0gc291cmNlLmdsb3NzaW5lc3NNYXA7XG5cdFx0dGhpcy5nbG9zc2luZXNzID0gc291cmNlLmdsb3NzaW5lc3M7XG5cdFx0ZGVsZXRlIHRoaXMubWV0YWxuZXNzO1xuXHRcdGRlbGV0ZSB0aGlzLnJvdWdobmVzcztcblx0XHRkZWxldGUgdGhpcy5tZXRhbG5lc3NNYXA7XG5cdFx0ZGVsZXRlIHRoaXMucm91Z2huZXNzTWFwO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5cbmNsYXNzIEdMVEZNYXRlcmlhbHNQYnJTcGVjdWxhckdsb3NzaW5lc3NFeHRlbnNpb24ge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1BCUl9TUEVDVUxBUl9HTE9TU0lORVNTO1xuXG5cdFx0dGhpcy5zcGVjdWxhckdsb3NzaW5lc3NQYXJhbXMgPSBbXG5cdFx0XHQnY29sb3InLFxuXHRcdFx0J21hcCcsXG5cdFx0XHQnbGlnaHRNYXAnLFxuXHRcdFx0J2xpZ2h0TWFwSW50ZW5zaXR5Jyxcblx0XHRcdCdhb01hcCcsXG5cdFx0XHQnYW9NYXBJbnRlbnNpdHknLFxuXHRcdFx0J2VtaXNzaXZlJyxcblx0XHRcdCdlbWlzc2l2ZUludGVuc2l0eScsXG5cdFx0XHQnZW1pc3NpdmVNYXAnLFxuXHRcdFx0J2J1bXBNYXAnLFxuXHRcdFx0J2J1bXBTY2FsZScsXG5cdFx0XHQnbm9ybWFsTWFwJyxcblx0XHRcdCdub3JtYWxNYXBUeXBlJyxcblx0XHRcdCdkaXNwbGFjZW1lbnRNYXAnLFxuXHRcdFx0J2Rpc3BsYWNlbWVudFNjYWxlJyxcblx0XHRcdCdkaXNwbGFjZW1lbnRCaWFzJyxcblx0XHRcdCdzcGVjdWxhck1hcCcsXG5cdFx0XHQnc3BlY3VsYXInLFxuXHRcdFx0J2dsb3NzaW5lc3NNYXAnLFxuXHRcdFx0J2dsb3NzaW5lc3MnLFxuXHRcdFx0J2FscGhhTWFwJyxcblx0XHRcdCdlbnZNYXAnLFxuXHRcdFx0J2Vudk1hcEludGVuc2l0eScsXG5cdFx0XHQncmVmcmFjdGlvblJhdGlvJyxcblx0XHRdO1xuXG5cdH1cblxuXHRnZXRNYXRlcmlhbFR5cGUoKSB7XG5cblx0XHRyZXR1cm4gR0xURk1lc2hTdGFuZGFyZFNHTWF0ZXJpYWw7XG5cblx0fVxuXG5cdGV4dGVuZFBhcmFtcyggbWF0ZXJpYWxQYXJhbXMsIG1hdGVyaWFsRGVmLCBwYXJzZXIgKSB7XG5cblx0XHRjb25zdCBwYnJTcGVjdWxhckdsb3NzaW5lc3MgPSBtYXRlcmlhbERlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXTtcblxuXHRcdG1hdGVyaWFsUGFyYW1zLmNvbG9yID0gbmV3IENvbG9yKCAxLjAsIDEuMCwgMS4wICk7XG5cdFx0bWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IDEuMDtcblxuXHRcdGNvbnN0IHBlbmRpbmcgPSBbXTtcblxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggcGJyU3BlY3VsYXJHbG9zc2luZXNzLmRpZmZ1c2VGYWN0b3IgKSApIHtcblxuXHRcdFx0Y29uc3QgYXJyYXkgPSBwYnJTcGVjdWxhckdsb3NzaW5lc3MuZGlmZnVzZUZhY3RvcjtcblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMuY29sb3IuZnJvbUFycmF5KCBhcnJheSApO1xuXHRcdFx0bWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IGFycmF5WyAzIF07XG5cblx0XHR9XG5cblx0XHRpZiAoIHBiclNwZWN1bGFyR2xvc3NpbmVzcy5kaWZmdXNlVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ21hcCcsIHBiclNwZWN1bGFyR2xvc3NpbmVzcy5kaWZmdXNlVGV4dHVyZSApICk7XG5cblx0XHR9XG5cblx0XHRtYXRlcmlhbFBhcmFtcy5lbWlzc2l2ZSA9IG5ldyBDb2xvciggMC4wLCAwLjAsIDAuMCApO1xuXHRcdG1hdGVyaWFsUGFyYW1zLmdsb3NzaW5lc3MgPSBwYnJTcGVjdWxhckdsb3NzaW5lc3MuZ2xvc3NpbmVzc0ZhY3RvciAhPT0gdW5kZWZpbmVkID8gcGJyU3BlY3VsYXJHbG9zc2luZXNzLmdsb3NzaW5lc3NGYWN0b3IgOiAxLjA7XG5cdFx0bWF0ZXJpYWxQYXJhbXMuc3BlY3VsYXIgPSBuZXcgQ29sb3IoIDEuMCwgMS4wLCAxLjAgKTtcblxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggcGJyU3BlY3VsYXJHbG9zc2luZXNzLnNwZWN1bGFyRmFjdG9yICkgKSB7XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLnNwZWN1bGFyLmZyb21BcnJheSggcGJyU3BlY3VsYXJHbG9zc2luZXNzLnNwZWN1bGFyRmFjdG9yICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHBiclNwZWN1bGFyR2xvc3NpbmVzcy5zcGVjdWxhckdsb3NzaW5lc3NUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IHNwZWNHbG9zc01hcERlZiA9IHBiclNwZWN1bGFyR2xvc3NpbmVzcy5zcGVjdWxhckdsb3NzaW5lc3NUZXh0dXJlO1xuXHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdnbG9zc2luZXNzTWFwJywgc3BlY0dsb3NzTWFwRGVmICkgKTtcblx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnc3BlY3VsYXJNYXAnLCBzcGVjR2xvc3NNYXBEZWYgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nICk7XG5cblx0fVxuXG5cdGNyZWF0ZU1hdGVyaWFsKCBtYXRlcmlhbFBhcmFtcyApIHtcblxuXHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IEdMVEZNZXNoU3RhbmRhcmRTR01hdGVyaWFsKCBtYXRlcmlhbFBhcmFtcyApO1xuXHRcdG1hdGVyaWFsLmZvZyA9IHRydWU7XG5cblx0XHRtYXRlcmlhbC5jb2xvciA9IG1hdGVyaWFsUGFyYW1zLmNvbG9yO1xuXG5cdFx0bWF0ZXJpYWwubWFwID0gbWF0ZXJpYWxQYXJhbXMubWFwID09PSB1bmRlZmluZWQgPyBudWxsIDogbWF0ZXJpYWxQYXJhbXMubWFwO1xuXG5cdFx0bWF0ZXJpYWwubGlnaHRNYXAgPSBudWxsO1xuXHRcdG1hdGVyaWFsLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xuXG5cdFx0bWF0ZXJpYWwuYW9NYXAgPSBtYXRlcmlhbFBhcmFtcy5hb01hcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG1hdGVyaWFsUGFyYW1zLmFvTWFwO1xuXHRcdG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xuXG5cdFx0bWF0ZXJpYWwuZW1pc3NpdmUgPSBtYXRlcmlhbFBhcmFtcy5lbWlzc2l2ZTtcblx0XHRtYXRlcmlhbC5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcblx0XHRtYXRlcmlhbC5lbWlzc2l2ZU1hcCA9IG1hdGVyaWFsUGFyYW1zLmVtaXNzaXZlTWFwID09PSB1bmRlZmluZWQgPyBudWxsIDogbWF0ZXJpYWxQYXJhbXMuZW1pc3NpdmVNYXA7XG5cblx0XHRtYXRlcmlhbC5idW1wTWFwID0gbWF0ZXJpYWxQYXJhbXMuYnVtcE1hcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG1hdGVyaWFsUGFyYW1zLmJ1bXBNYXA7XG5cdFx0bWF0ZXJpYWwuYnVtcFNjYWxlID0gMTtcblxuXHRcdG1hdGVyaWFsLm5vcm1hbE1hcCA9IG1hdGVyaWFsUGFyYW1zLm5vcm1hbE1hcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG1hdGVyaWFsUGFyYW1zLm5vcm1hbE1hcDtcblx0XHRtYXRlcmlhbC5ub3JtYWxNYXBUeXBlID0gVGFuZ2VudFNwYWNlTm9ybWFsTWFwO1xuXG5cdFx0aWYgKCBtYXRlcmlhbFBhcmFtcy5ub3JtYWxTY2FsZSApIG1hdGVyaWFsLm5vcm1hbFNjYWxlID0gbWF0ZXJpYWxQYXJhbXMubm9ybWFsU2NhbGU7XG5cblx0XHRtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuXHRcdG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0XHRtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzID0gMDtcblxuXHRcdG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gbWF0ZXJpYWxQYXJhbXMuc3BlY3VsYXJNYXAgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBtYXRlcmlhbFBhcmFtcy5zcGVjdWxhck1hcDtcblx0XHRtYXRlcmlhbC5zcGVjdWxhciA9IG1hdGVyaWFsUGFyYW1zLnNwZWN1bGFyO1xuXG5cdFx0bWF0ZXJpYWwuZ2xvc3NpbmVzc01hcCA9IG1hdGVyaWFsUGFyYW1zLmdsb3NzaW5lc3NNYXAgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBtYXRlcmlhbFBhcmFtcy5nbG9zc2luZXNzTWFwO1xuXHRcdG1hdGVyaWFsLmdsb3NzaW5lc3MgPSBtYXRlcmlhbFBhcmFtcy5nbG9zc2luZXNzO1xuXG5cdFx0bWF0ZXJpYWwuYWxwaGFNYXAgPSBudWxsO1xuXG5cdFx0bWF0ZXJpYWwuZW52TWFwID0gbWF0ZXJpYWxQYXJhbXMuZW52TWFwID09PSB1bmRlZmluZWQgPyBudWxsIDogbWF0ZXJpYWxQYXJhbXMuZW52TWFwO1xuXHRcdG1hdGVyaWFsLmVudk1hcEludGVuc2l0eSA9IDEuMDtcblxuXHRcdG1hdGVyaWFsLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cblx0XHRyZXR1cm4gbWF0ZXJpYWw7XG5cblx0fVxuXG59XG5cbi8qKlxuICogTWVzaCBRdWFudGl6YXRpb24gRXh0ZW5zaW9uXG4gKlxuICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX21lc2hfcXVhbnRpemF0aW9uXG4gKi9cbmNsYXNzIEdMVEZNZXNoUXVhbnRpemF0aW9uRXh0ZW5zaW9uIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01FU0hfUVVBTlRJWkFUSU9OO1xuXG5cdH1cblxufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKioqKiogSU5URVJQT0xBVElPTiAqKioqKioqKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIFNwbGluZSBJbnRlcnBvbGF0aW9uXG4vLyBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2FwcGVuZGl4LWMtc3BsaW5lLWludGVycG9sYXRpb25cbmNsYXNzIEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50IGV4dGVuZHMgSW50ZXJwb2xhbnQge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xuXG5cdFx0c3VwZXIoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKTtcblxuXHR9XG5cblx0Y29weVNhbXBsZVZhbHVlXyggaW5kZXggKSB7XG5cblx0XHQvLyBDb3BpZXMgYSBzYW1wbGUgdmFsdWUgdG8gdGhlIHJlc3VsdCBidWZmZXIuIFNlZSBkZXNjcmlwdGlvbiBvZiBnbFRGXG5cdFx0Ly8gQ1VCSUNTUExJTkUgdmFsdWVzIGxheW91dCBpbiBpbnRlcnBvbGF0ZV8oKSBmdW5jdGlvbiBiZWxvdy5cblxuXHRcdGNvbnN0IHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxuXHRcdFx0dmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXG5cdFx0XHR2YWx1ZVNpemUgPSB0aGlzLnZhbHVlU2l6ZSxcblx0XHRcdG9mZnNldCA9IGluZGV4ICogdmFsdWVTaXplICogMyArIHZhbHVlU2l6ZTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSAhPT0gdmFsdWVTaXplOyBpICsrICkge1xuXG5cdFx0XHRyZXN1bHRbIGkgXSA9IHZhbHVlc1sgb2Zmc2V0ICsgaSBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cbn1cblxuR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQucHJvdG90eXBlLmJlZm9yZVN0YXJ0XyA9IEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50LnByb3RvdHlwZS5jb3B5U2FtcGxlVmFsdWVfO1xuXG5HTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudC5wcm90b3R5cGUuYWZ0ZXJFbmRfID0gR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQucHJvdG90eXBlLmNvcHlTYW1wbGVWYWx1ZV87XG5cbkdMVEZDdWJpY1NwbGluZUludGVycG9sYW50LnByb3RvdHlwZS5pbnRlcnBvbGF0ZV8gPSBmdW5jdGlvbiAoIGkxLCB0MCwgdCwgdDEgKSB7XG5cblx0Y29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXI7XG5cdGNvbnN0IHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzO1xuXHRjb25zdCBzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZTtcblxuXHRjb25zdCBzdHJpZGUyID0gc3RyaWRlICogMjtcblx0Y29uc3Qgc3RyaWRlMyA9IHN0cmlkZSAqIDM7XG5cblx0Y29uc3QgdGQgPSB0MSAtIHQwO1xuXG5cdGNvbnN0IHAgPSAoIHQgLSB0MCApIC8gdGQ7XG5cdGNvbnN0IHBwID0gcCAqIHA7XG5cdGNvbnN0IHBwcCA9IHBwICogcDtcblxuXHRjb25zdCBvZmZzZXQxID0gaTEgKiBzdHJpZGUzO1xuXHRjb25zdCBvZmZzZXQwID0gb2Zmc2V0MSAtIHN0cmlkZTM7XG5cblx0Y29uc3QgczIgPSAtIDIgKiBwcHAgKyAzICogcHA7XG5cdGNvbnN0IHMzID0gcHBwIC0gcHA7XG5cdGNvbnN0IHMwID0gMSAtIHMyO1xuXHRjb25zdCBzMSA9IHMzIC0gcHAgKyBwO1xuXG5cdC8vIExheW91dCBvZiBrZXlmcmFtZSBvdXRwdXQgdmFsdWVzIGZvciBDVUJJQ1NQTElORSBhbmltYXRpb25zOlxuXHQvLyAgIFsgaW5UYW5nZW50XzEsIHNwbGluZVZlcnRleF8xLCBvdXRUYW5nZW50XzEsIGluVGFuZ2VudF8yLCBzcGxpbmVWZXJ0ZXhfMiwgLi4uIF1cblx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7IGkgKysgKSB7XG5cblx0XHRjb25zdCBwMCA9IHZhbHVlc1sgb2Zmc2V0MCArIGkgKyBzdHJpZGUgXTsgLy8gc3BsaW5lVmVydGV4X2tcblx0XHRjb25zdCBtMCA9IHZhbHVlc1sgb2Zmc2V0MCArIGkgKyBzdHJpZGUyIF0gKiB0ZDsgLy8gb3V0VGFuZ2VudF9rICogKHRfaysxIC0gdF9rKVxuXHRcdGNvbnN0IHAxID0gdmFsdWVzWyBvZmZzZXQxICsgaSArIHN0cmlkZSBdOyAvLyBzcGxpbmVWZXJ0ZXhfaysxXG5cdFx0Y29uc3QgbTEgPSB2YWx1ZXNbIG9mZnNldDEgKyBpIF0gKiB0ZDsgLy8gaW5UYW5nZW50X2srMSAqICh0X2srMSAtIHRfaylcblxuXHRcdHJlc3VsdFsgaSBdID0gczAgKiBwMCArIHMxICogbTAgKyBzMiAqIHAxICsgczMgKiBtMTtcblxuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcblxufTtcblxuY29uc3QgX3EgPSBuZXcgUXVhdGVybmlvbigpO1xuXG5jbGFzcyBHTFRGQ3ViaWNTcGxpbmVRdWF0ZXJuaW9uSW50ZXJwb2xhbnQgZXh0ZW5kcyBHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudCB7XG5cblx0aW50ZXJwb2xhdGVfKCBpMSwgdDAsIHQsIHQxICkge1xuXG5cdFx0Y29uc3QgcmVzdWx0ID0gc3VwZXIuaW50ZXJwb2xhdGVfKCBpMSwgdDAsIHQsIHQxICk7XG5cblx0XHRfcS5mcm9tQXJyYXkoIHJlc3VsdCApLm5vcm1hbGl6ZSgpLnRvQXJyYXkoIHJlc3VsdCApO1xuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cbn1cblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKioqKiogSU5URVJOQUxTICoqKioqKioqKioqKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qIENPTlNUQU5UUyAqL1xuXG5jb25zdCBXRUJHTF9DT05TVEFOVFMgPSB7XG5cdEZMT0FUOiA1MTI2LFxuXHQvL0ZMT0FUX01BVDI6IDM1Njc0LFxuXHRGTE9BVF9NQVQzOiAzNTY3NSxcblx0RkxPQVRfTUFUNDogMzU2NzYsXG5cdEZMT0FUX1ZFQzI6IDM1NjY0LFxuXHRGTE9BVF9WRUMzOiAzNTY2NSxcblx0RkxPQVRfVkVDNDogMzU2NjYsXG5cdExJTkVBUjogOTcyOSxcblx0UkVQRUFUOiAxMDQ5Nyxcblx0U0FNUExFUl8yRDogMzU2NzgsXG5cdFBPSU5UUzogMCxcblx0TElORVM6IDEsXG5cdExJTkVfTE9PUDogMixcblx0TElORV9TVFJJUDogMyxcblx0VFJJQU5HTEVTOiA0LFxuXHRUUklBTkdMRV9TVFJJUDogNSxcblx0VFJJQU5HTEVfRkFOOiA2LFxuXHRVTlNJR05FRF9CWVRFOiA1MTIxLFxuXHRVTlNJR05FRF9TSE9SVDogNTEyM1xufTtcblxuY29uc3QgV0VCR0xfQ09NUE9ORU5UX1RZUEVTID0ge1xuXHQ1MTIwOiBJbnQ4QXJyYXksXG5cdDUxMjE6IFVpbnQ4QXJyYXksXG5cdDUxMjI6IEludDE2QXJyYXksXG5cdDUxMjM6IFVpbnQxNkFycmF5LFxuXHQ1MTI1OiBVaW50MzJBcnJheSxcblx0NTEyNjogRmxvYXQzMkFycmF5XG59O1xuXG5jb25zdCBXRUJHTF9GSUxURVJTID0ge1xuXHQ5NzI4OiBOZWFyZXN0RmlsdGVyLFxuXHQ5NzI5OiBMaW5lYXJGaWx0ZXIsXG5cdDk5ODQ6IE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyLFxuXHQ5OTg1OiBMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyLFxuXHQ5OTg2OiBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyLFxuXHQ5OTg3OiBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXJcbn07XG5cbmNvbnN0IFdFQkdMX1dSQVBQSU5HUyA9IHtcblx0MzMwNzE6IENsYW1wVG9FZGdlV3JhcHBpbmcsXG5cdDMzNjQ4OiBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nLFxuXHQxMDQ5NzogUmVwZWF0V3JhcHBpbmdcbn07XG5cbmNvbnN0IFdFQkdMX1RZUEVfU0laRVMgPSB7XG5cdCdTQ0FMQVInOiAxLFxuXHQnVkVDMic6IDIsXG5cdCdWRUMzJzogMyxcblx0J1ZFQzQnOiA0LFxuXHQnTUFUMic6IDQsXG5cdCdNQVQzJzogOSxcblx0J01BVDQnOiAxNlxufTtcblxuY29uc3QgQVRUUklCVVRFUyA9IHtcblx0UE9TSVRJT046ICdwb3NpdGlvbicsXG5cdE5PUk1BTDogJ25vcm1hbCcsXG5cdFRBTkdFTlQ6ICd0YW5nZW50Jyxcblx0VEVYQ09PUkRfMDogJ3V2Jyxcblx0VEVYQ09PUkRfMTogJ3V2MicsXG5cdENPTE9SXzA6ICdjb2xvcicsXG5cdFdFSUdIVFNfMDogJ3NraW5XZWlnaHQnLFxuXHRKT0lOVFNfMDogJ3NraW5JbmRleCcsXG59O1xuXG5jb25zdCBQQVRIX1BST1BFUlRJRVMgPSB7XG5cdHNjYWxlOiAnc2NhbGUnLFxuXHR0cmFuc2xhdGlvbjogJ3Bvc2l0aW9uJyxcblx0cm90YXRpb246ICdxdWF0ZXJuaW9uJyxcblx0d2VpZ2h0czogJ21vcnBoVGFyZ2V0SW5mbHVlbmNlcydcbn07XG5cbmNvbnN0IElOVEVSUE9MQVRJT04gPSB7XG5cdENVQklDU1BMSU5FOiB1bmRlZmluZWQsIC8vIFdlIHVzZSBhIGN1c3RvbSBpbnRlcnBvbGFudCAoR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhdGlvbikgZm9yIENVQklDU1BMSU5FIHRyYWNrcy4gRWFjaFxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtleWZyYW1lIHRyYWNrIHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhIGRlZmF1bHQgaW50ZXJwb2xhdGlvbiB0eXBlLCB0aGVuIG1vZGlmaWVkLlxuXHRMSU5FQVI6IEludGVycG9sYXRlTGluZWFyLFxuXHRTVEVQOiBJbnRlcnBvbGF0ZURpc2NyZXRlXG59O1xuXG5jb25zdCBBTFBIQV9NT0RFUyA9IHtcblx0T1BBUVVFOiAnT1BBUVVFJyxcblx0TUFTSzogJ01BU0snLFxuXHRCTEVORDogJ0JMRU5EJ1xufTtcblxuLyoqXG4gKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2RlZmF1bHQtbWF0ZXJpYWxcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdE1hdGVyaWFsKCBjYWNoZSApIHtcblxuXHRpZiAoIGNhY2hlWyAnRGVmYXVsdE1hdGVyaWFsJyBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRjYWNoZVsgJ0RlZmF1bHRNYXRlcmlhbCcgXSA9IG5ldyBNZXNoU3RhbmRhcmRNYXRlcmlhbCgge1xuXHRcdFx0Y29sb3I6IDB4RkZGRkZGLFxuXHRcdFx0ZW1pc3NpdmU6IDB4MDAwMDAwLFxuXHRcdFx0bWV0YWxuZXNzOiAxLFxuXHRcdFx0cm91Z2huZXNzOiAxLFxuXHRcdFx0dHJhbnNwYXJlbnQ6IGZhbHNlLFxuXHRcdFx0ZGVwdGhUZXN0OiB0cnVlLFxuXHRcdFx0c2lkZTogRnJvbnRTaWRlXG5cdFx0fSApO1xuXG5cdH1cblxuXHRyZXR1cm4gY2FjaGVbICdEZWZhdWx0TWF0ZXJpYWwnIF07XG5cbn1cblxuZnVuY3Rpb24gYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKCBrbm93bkV4dGVuc2lvbnMsIG9iamVjdCwgb2JqZWN0RGVmICkge1xuXG5cdC8vIEFkZCB1bmtub3duIGdsVEYgZXh0ZW5zaW9ucyB0byBhbiBvYmplY3QncyB1c2VyRGF0YS5cblxuXHRmb3IgKCBjb25zdCBuYW1lIGluIG9iamVjdERlZi5leHRlbnNpb25zICkge1xuXG5cdFx0aWYgKCBrbm93bkV4dGVuc2lvbnNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRvYmplY3QudXNlckRhdGEuZ2x0ZkV4dGVuc2lvbnMgPSBvYmplY3QudXNlckRhdGEuZ2x0ZkV4dGVuc2lvbnMgfHwge307XG5cdFx0XHRvYmplY3QudXNlckRhdGEuZ2x0ZkV4dGVuc2lvbnNbIG5hbWUgXSA9IG9iamVjdERlZi5leHRlbnNpb25zWyBuYW1lIF07XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3QzRHxNYXRlcmlhbHxCdWZmZXJHZW9tZXRyeX0gb2JqZWN0XG4gKiBAcGFyYW0ge0dMVEYuZGVmaW5pdGlvbn0gZ2x0ZkRlZlxuICovXG5mdW5jdGlvbiBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKCBvYmplY3QsIGdsdGZEZWYgKSB7XG5cblx0aWYgKCBnbHRmRGVmLmV4dHJhcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZ2x0ZkRlZi5leHRyYXMgPT09ICdvYmplY3QnICkge1xuXG5cdFx0XHRPYmplY3QuYXNzaWduKCBvYmplY3QudXNlckRhdGEsIGdsdGZEZWYuZXh0cmFzICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HTFRGTG9hZGVyOiBJZ25vcmluZyBwcmltaXRpdmUgdHlwZSAuZXh0cmFzLCAnICsgZ2x0ZkRlZi5leHRyYXMgKTtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuLyoqXG4gKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI21vcnBoLXRhcmdldHNcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlckdlb21ldHJ5fSBnZW9tZXRyeVxuICogQHBhcmFtIHtBcnJheTxHTFRGLlRhcmdldD59IHRhcmdldHNcbiAqIEBwYXJhbSB7R0xURlBhcnNlcn0gcGFyc2VyXG4gKiBAcmV0dXJuIHtQcm9taXNlPEJ1ZmZlckdlb21ldHJ5Pn1cbiAqL1xuZnVuY3Rpb24gYWRkTW9ycGhUYXJnZXRzKCBnZW9tZXRyeSwgdGFyZ2V0cywgcGFyc2VyICkge1xuXG5cdGxldCBoYXNNb3JwaFBvc2l0aW9uID0gZmFsc2U7XG5cdGxldCBoYXNNb3JwaE5vcm1hbCA9IGZhbHNlO1xuXG5cdGZvciAoIGxldCBpID0gMCwgaWwgPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0Y29uc3QgdGFyZ2V0ID0gdGFyZ2V0c1sgaSBdO1xuXG5cdFx0aWYgKCB0YXJnZXQuUE9TSVRJT04gIT09IHVuZGVmaW5lZCApIGhhc01vcnBoUG9zaXRpb24gPSB0cnVlO1xuXHRcdGlmICggdGFyZ2V0Lk5PUk1BTCAhPT0gdW5kZWZpbmVkICkgaGFzTW9ycGhOb3JtYWwgPSB0cnVlO1xuXG5cdFx0aWYgKCBoYXNNb3JwaFBvc2l0aW9uICYmIGhhc01vcnBoTm9ybWFsICkgYnJlYWs7XG5cblx0fVxuXG5cdGlmICggISBoYXNNb3JwaFBvc2l0aW9uICYmICEgaGFzTW9ycGhOb3JtYWwgKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCBnZW9tZXRyeSApO1xuXG5cdGNvbnN0IHBlbmRpbmdQb3NpdGlvbkFjY2Vzc29ycyA9IFtdO1xuXHRjb25zdCBwZW5kaW5nTm9ybWFsQWNjZXNzb3JzID0gW107XG5cblx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRjb25zdCB0YXJnZXQgPSB0YXJnZXRzWyBpIF07XG5cblx0XHRpZiAoIGhhc01vcnBoUG9zaXRpb24gKSB7XG5cblx0XHRcdGNvbnN0IHBlbmRpbmdBY2Nlc3NvciA9IHRhcmdldC5QT1NJVElPTiAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdD8gcGFyc2VyLmdldERlcGVuZGVuY3koICdhY2Nlc3NvcicsIHRhcmdldC5QT1NJVElPTiApXG5cdFx0XHRcdDogZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdFx0cGVuZGluZ1Bvc2l0aW9uQWNjZXNzb3JzLnB1c2goIHBlbmRpbmdBY2Nlc3NvciApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBoYXNNb3JwaE5vcm1hbCApIHtcblxuXHRcdFx0Y29uc3QgcGVuZGluZ0FjY2Vzc29yID0gdGFyZ2V0Lk5PUk1BTCAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdD8gcGFyc2VyLmdldERlcGVuZGVuY3koICdhY2Nlc3NvcicsIHRhcmdldC5OT1JNQUwgKVxuXHRcdFx0XHQ6IGdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsO1xuXG5cdFx0XHRwZW5kaW5nTm9ybWFsQWNjZXNzb3JzLnB1c2goIHBlbmRpbmdBY2Nlc3NvciApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4gUHJvbWlzZS5hbGwoIFtcblx0XHRQcm9taXNlLmFsbCggcGVuZGluZ1Bvc2l0aW9uQWNjZXNzb3JzICksXG5cdFx0UHJvbWlzZS5hbGwoIHBlbmRpbmdOb3JtYWxBY2Nlc3NvcnMgKVxuXHRdICkudGhlbiggZnVuY3Rpb24gKCBhY2Nlc3NvcnMgKSB7XG5cblx0XHRjb25zdCBtb3JwaFBvc2l0aW9ucyA9IGFjY2Vzc29yc1sgMCBdO1xuXHRcdGNvbnN0IG1vcnBoTm9ybWFscyA9IGFjY2Vzc29yc1sgMSBdO1xuXG5cdFx0aWYgKCBoYXNNb3JwaFBvc2l0aW9uICkgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uID0gbW9ycGhQb3NpdGlvbnM7XG5cdFx0aWYgKCBoYXNNb3JwaE5vcm1hbCApIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgPSBtb3JwaE5vcm1hbHM7XG5cdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdH0gKTtcblxufVxuXG4vKipcbiAqIEBwYXJhbSB7TWVzaH0gbWVzaFxuICogQHBhcmFtIHtHTFRGLk1lc2h9IG1lc2hEZWZcbiAqL1xuZnVuY3Rpb24gdXBkYXRlTW9ycGhUYXJnZXRzKCBtZXNoLCBtZXNoRGVmICkge1xuXG5cdG1lc2gudXBkYXRlTW9ycGhUYXJnZXRzKCk7XG5cblx0aWYgKCBtZXNoRGVmLndlaWdodHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBtZXNoRGVmLndlaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdG1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF0gPSBtZXNoRGVmLndlaWdodHNbIGkgXTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gLmV4dHJhcyBoYXMgdXNlci1kZWZpbmVkIGRhdGEsIHNvIGNoZWNrIHRoYXQgLmV4dHJhcy50YXJnZXROYW1lcyBpcyBhbiBhcnJheS5cblx0aWYgKCBtZXNoRGVmLmV4dHJhcyAmJiBBcnJheS5pc0FycmF5KCBtZXNoRGVmLmV4dHJhcy50YXJnZXROYW1lcyApICkge1xuXG5cdFx0Y29uc3QgdGFyZ2V0TmFtZXMgPSBtZXNoRGVmLmV4dHJhcy50YXJnZXROYW1lcztcblxuXHRcdGlmICggbWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXMubGVuZ3RoID09PSB0YXJnZXROYW1lcy5sZW5ndGggKSB7XG5cblx0XHRcdG1lc2gubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSB0YXJnZXROYW1lcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRtZXNoLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgdGFyZ2V0TmFtZXNbIGkgXSBdID0gaTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogSW52YWxpZCBleHRyYXMudGFyZ2V0TmFtZXMgbGVuZ3RoLiBJZ25vcmluZyBuYW1lcy4nICk7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZUtleSggcHJpbWl0aXZlRGVmICkge1xuXG5cdGNvbnN0IGRyYWNvRXh0ZW5zaW9uID0gcHJpbWl0aXZlRGVmLmV4dGVuc2lvbnMgJiYgcHJpbWl0aXZlRGVmLmV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT04gXTtcblx0bGV0IGdlb21ldHJ5S2V5O1xuXG5cdGlmICggZHJhY29FeHRlbnNpb24gKSB7XG5cblx0XHRnZW9tZXRyeUtleSA9ICdkcmFjbzonICsgZHJhY29FeHRlbnNpb24uYnVmZmVyVmlld1xuXHRcdFx0XHQrICc6JyArIGRyYWNvRXh0ZW5zaW9uLmluZGljZXNcblx0XHRcdFx0KyAnOicgKyBjcmVhdGVBdHRyaWJ1dGVzS2V5KCBkcmFjb0V4dGVuc2lvbi5hdHRyaWJ1dGVzICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdGdlb21ldHJ5S2V5ID0gcHJpbWl0aXZlRGVmLmluZGljZXMgKyAnOicgKyBjcmVhdGVBdHRyaWJ1dGVzS2V5KCBwcmltaXRpdmVEZWYuYXR0cmlidXRlcyApICsgJzonICsgcHJpbWl0aXZlRGVmLm1vZGU7XG5cblx0fVxuXG5cdHJldHVybiBnZW9tZXRyeUtleTtcblxufVxuXG5mdW5jdGlvbiBjcmVhdGVBdHRyaWJ1dGVzS2V5KCBhdHRyaWJ1dGVzICkge1xuXG5cdGxldCBhdHRyaWJ1dGVzS2V5ID0gJyc7XG5cblx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKCBhdHRyaWJ1dGVzICkuc29ydCgpO1xuXG5cdGZvciAoIGxldCBpID0gMCwgaWwgPSBrZXlzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0YXR0cmlidXRlc0tleSArPSBrZXlzWyBpIF0gKyAnOicgKyBhdHRyaWJ1dGVzWyBrZXlzWyBpIF0gXSArICc7JztcblxuXHR9XG5cblx0cmV0dXJuIGF0dHJpYnV0ZXNLZXk7XG5cbn1cblxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZENvbXBvbmVudFNjYWxlKCBjb25zdHJ1Y3RvciApIHtcblxuXHQvLyBSZWZlcmVuY2U6XG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl9tZXNoX3F1YW50aXphdGlvbiNlbmNvZGluZy1xdWFudGl6ZWQtZGF0YVxuXG5cdHN3aXRjaCAoIGNvbnN0cnVjdG9yICkge1xuXG5cdFx0Y2FzZSBJbnQ4QXJyYXk6XG5cdFx0XHRyZXR1cm4gMSAvIDEyNztcblxuXHRcdGNhc2UgVWludDhBcnJheTpcblx0XHRcdHJldHVybiAxIC8gMjU1O1xuXG5cdFx0Y2FzZSBJbnQxNkFycmF5OlxuXHRcdFx0cmV0dXJuIDEgLyAzMjc2NztcblxuXHRcdGNhc2UgVWludDE2QXJyYXk6XG5cdFx0XHRyZXR1cm4gMSAvIDY1NTM1O1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIG5vcm1hbGl6ZWQgYWNjZXNzb3IgY29tcG9uZW50IHR5cGUuJyApO1xuXG5cdH1cblxufVxuXG4vKiBHTFRGIFBBUlNFUiAqL1xuXG5jbGFzcyBHTFRGUGFyc2VyIHtcblxuXHRjb25zdHJ1Y3RvcigganNvbiA9IHt9LCBvcHRpb25zID0ge30gKSB7XG5cblx0XHR0aGlzLmpzb24gPSBqc29uO1xuXHRcdHRoaXMuZXh0ZW5zaW9ucyA9IHt9O1xuXHRcdHRoaXMucGx1Z2lucyA9IHt9O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cblx0XHQvLyBsb2FkZXIgb2JqZWN0IGNhY2hlXG5cdFx0dGhpcy5jYWNoZSA9IG5ldyBHTFRGUmVnaXN0cnkoKTtcblxuXHRcdC8vIGFzc29jaWF0aW9ucyBiZXR3ZWVuIFRocmVlLmpzIG9iamVjdHMgYW5kIGdsVEYgZWxlbWVudHNcblx0XHR0aGlzLmFzc29jaWF0aW9ucyA9IG5ldyBNYXAoKTtcblxuXHRcdC8vIEJ1ZmZlckdlb21ldHJ5IGNhY2hpbmdcblx0XHR0aGlzLnByaW1pdGl2ZUNhY2hlID0ge307XG5cblx0XHQvLyBPYmplY3QzRCBpbnN0YW5jZSBjYWNoZXNcblx0XHR0aGlzLm1lc2hDYWNoZSA9IHsgcmVmczoge30sIHVzZXM6IHt9IH07XG5cdFx0dGhpcy5jYW1lcmFDYWNoZSA9IHsgcmVmczoge30sIHVzZXM6IHt9IH07XG5cdFx0dGhpcy5saWdodENhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcblxuXHRcdHRoaXMudGV4dHVyZUNhY2hlID0ge307XG5cblx0XHQvLyBUcmFjayBub2RlIG5hbWVzLCB0byBlbnN1cmUgbm8gZHVwbGljYXRlc1xuXHRcdHRoaXMubm9kZU5hbWVzVXNlZCA9IHt9O1xuXG5cdFx0Ly8gVXNlIGFuIEltYWdlQml0bWFwTG9hZGVyIGlmIGltYWdlQml0bWFwcyBhcmUgc3VwcG9ydGVkLiBNb3ZlcyBtdWNoIG9mIHRoZVxuXHRcdC8vIGV4cGVuc2l2ZSB3b3JrIG9mIHVwbG9hZGluZyBhIHRleHR1cmUgdG8gdGhlIEdQVSBvZmYgdGhlIG1haW4gdGhyZWFkLlxuXHRcdGlmICggdHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwICE9PSAndW5kZWZpbmVkJyAmJiAvRmlyZWZveC8udGVzdCggbmF2aWdhdG9yLnVzZXJBZ2VudCApID09PSBmYWxzZSApIHtcblxuXHRcdFx0dGhpcy50ZXh0dXJlTG9hZGVyID0gbmV3IEltYWdlQml0bWFwTG9hZGVyKCB0aGlzLm9wdGlvbnMubWFuYWdlciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy50ZXh0dXJlTG9hZGVyID0gbmV3IFRleHR1cmVMb2FkZXIoIHRoaXMub3B0aW9ucy5tYW5hZ2VyICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnRleHR1cmVMb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiApO1xuXHRcdHRoaXMudGV4dHVyZUxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCB0aGlzLm9wdGlvbnMucmVxdWVzdEhlYWRlciApO1xuXG5cdFx0dGhpcy5maWxlTG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMub3B0aW9ucy5tYW5hZ2VyICk7XG5cdFx0dGhpcy5maWxlTG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICd1c2UtY3JlZGVudGlhbHMnICkge1xuXG5cdFx0XHR0aGlzLmZpbGVMb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCB0cnVlICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHNldEV4dGVuc2lvbnMoIGV4dGVuc2lvbnMgKSB7XG5cblx0XHR0aGlzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuXG5cdH1cblxuXHRzZXRQbHVnaW5zKCBwbHVnaW5zICkge1xuXG5cdFx0dGhpcy5wbHVnaW5zID0gcGx1Z2lucztcblxuXHR9XG5cblx0cGFyc2UoIG9uTG9hZCwgb25FcnJvciApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXM7XG5cdFx0Y29uc3QganNvbiA9IHRoaXMuanNvbjtcblx0XHRjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuXG5cdFx0Ly8gQ2xlYXIgdGhlIGxvYWRlciBjYWNoZVxuXHRcdHRoaXMuY2FjaGUucmVtb3ZlQWxsKCk7XG5cblx0XHQvLyBNYXJrIHRoZSBzcGVjaWFsIG5vZGVzL21lc2hlcyBpbiBqc29uIGZvciBlZmZpY2llbnQgcGFyc2Vcblx0XHR0aGlzLl9pbnZva2VBbGwoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRyZXR1cm4gZXh0Ll9tYXJrRGVmcyAmJiBleHQuX21hcmtEZWZzKCk7XG5cblx0XHR9ICk7XG5cblx0XHRQcm9taXNlLmFsbCggdGhpcy5faW52b2tlQWxsKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0cmV0dXJuIGV4dC5iZWZvcmVSb290ICYmIGV4dC5iZWZvcmVSb290KCk7XG5cblx0XHR9ICkgKS50aGVuKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLmFsbCggW1xuXG5cdFx0XHRcdHBhcnNlci5nZXREZXBlbmRlbmNpZXMoICdzY2VuZScgKSxcblx0XHRcdFx0cGFyc2VyLmdldERlcGVuZGVuY2llcyggJ2FuaW1hdGlvbicgKSxcblx0XHRcdFx0cGFyc2VyLmdldERlcGVuZGVuY2llcyggJ2NhbWVyYScgKSxcblxuXHRcdFx0XSApO1xuXG5cdFx0fSApLnRoZW4oIGZ1bmN0aW9uICggZGVwZW5kZW5jaWVzICkge1xuXG5cdFx0XHRjb25zdCByZXN1bHQgPSB7XG5cdFx0XHRcdHNjZW5lOiBkZXBlbmRlbmNpZXNbIDAgXVsganNvbi5zY2VuZSB8fCAwIF0sXG5cdFx0XHRcdHNjZW5lczogZGVwZW5kZW5jaWVzWyAwIF0sXG5cdFx0XHRcdGFuaW1hdGlvbnM6IGRlcGVuZGVuY2llc1sgMSBdLFxuXHRcdFx0XHRjYW1lcmFzOiBkZXBlbmRlbmNpZXNbIDIgXSxcblx0XHRcdFx0YXNzZXQ6IGpzb24uYXNzZXQsXG5cdFx0XHRcdHBhcnNlcjogcGFyc2VyLFxuXHRcdFx0XHR1c2VyRGF0YToge31cblx0XHRcdH07XG5cblx0XHRcdGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YSggZXh0ZW5zaW9ucywgcmVzdWx0LCBqc29uICk7XG5cblx0XHRcdGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoIHJlc3VsdCwganNvbiApO1xuXG5cdFx0XHRQcm9taXNlLmFsbCggcGFyc2VyLl9pbnZva2VBbGwoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRcdHJldHVybiBleHQuYWZ0ZXJSb290ICYmIGV4dC5hZnRlclJvb3QoIHJlc3VsdCApO1xuXG5cdFx0XHR9ICkgKS50aGVuKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0b25Mb2FkKCByZXN1bHQgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fSApLmNhdGNoKCBvbkVycm9yICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBNYXJrcyB0aGUgc3BlY2lhbCBub2Rlcy9tZXNoZXMgaW4ganNvbiBmb3IgZWZmaWNpZW50IHBhcnNlLlxuXHQgKi9cblx0X21hcmtEZWZzKCkge1xuXG5cdFx0Y29uc3Qgbm9kZURlZnMgPSB0aGlzLmpzb24ubm9kZXMgfHwgW107XG5cdFx0Y29uc3Qgc2tpbkRlZnMgPSB0aGlzLmpzb24uc2tpbnMgfHwgW107XG5cdFx0Y29uc3QgbWVzaERlZnMgPSB0aGlzLmpzb24ubWVzaGVzIHx8IFtdO1xuXG5cdFx0Ly8gTm90aGluZyBpbiB0aGUgbm9kZSBkZWZpbml0aW9uIGluZGljYXRlcyB3aGV0aGVyIGl0IGlzIGEgQm9uZSBvciBhblxuXHRcdC8vIE9iamVjdDNELiBVc2UgdGhlIHNraW5zJyBqb2ludCByZWZlcmVuY2VzIHRvIG1hcmsgYm9uZXMuXG5cdFx0Zm9yICggbGV0IHNraW5JbmRleCA9IDAsIHNraW5MZW5ndGggPSBza2luRGVmcy5sZW5ndGg7IHNraW5JbmRleCA8IHNraW5MZW5ndGg7IHNraW5JbmRleCArKyApIHtcblxuXHRcdFx0Y29uc3Qgam9pbnRzID0gc2tpbkRlZnNbIHNraW5JbmRleCBdLmpvaW50cztcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGpvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRub2RlRGVmc1sgam9pbnRzWyBpIF0gXS5pc0JvbmUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBJdGVyYXRlIG92ZXIgYWxsIG5vZGVzLCBtYXJraW5nIHJlZmVyZW5jZXMgdG8gc2hhcmVkIHJlc291cmNlcyxcblx0XHQvLyBhcyB3ZWxsIGFzIHNrZWxldG9uIGpvaW50cy5cblx0XHRmb3IgKCBsZXQgbm9kZUluZGV4ID0gMCwgbm9kZUxlbmd0aCA9IG5vZGVEZWZzLmxlbmd0aDsgbm9kZUluZGV4IDwgbm9kZUxlbmd0aDsgbm9kZUluZGV4ICsrICkge1xuXG5cdFx0XHRjb25zdCBub2RlRGVmID0gbm9kZURlZnNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRpZiAoIG5vZGVEZWYubWVzaCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMuX2FkZE5vZGVSZWYoIHRoaXMubWVzaENhY2hlLCBub2RlRGVmLm1lc2ggKTtcblxuXHRcdFx0XHQvLyBOb3RoaW5nIGluIHRoZSBtZXNoIGRlZmluaXRpb24gaW5kaWNhdGVzIHdoZXRoZXIgaXQgaXNcblx0XHRcdFx0Ly8gYSBTa2lubmVkTWVzaCBvciBNZXNoLiBVc2UgdGhlIG5vZGUncyBtZXNoIHJlZmVyZW5jZVxuXHRcdFx0XHQvLyB0byBtYXJrIFNraW5uZWRNZXNoIGlmIG5vZGUgaGFzIHNraW4uXG5cdFx0XHRcdGlmICggbm9kZURlZi5za2luICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRtZXNoRGVmc1sgbm9kZURlZi5tZXNoIF0uaXNTa2lubmVkTWVzaCA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbm9kZURlZi5jYW1lcmEgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0aGlzLl9hZGROb2RlUmVmKCB0aGlzLmNhbWVyYUNhY2hlLCBub2RlRGVmLmNhbWVyYSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb3VudHMgcmVmZXJlbmNlcyB0byBzaGFyZWQgbm9kZSAvIE9iamVjdDNEIHJlc291cmNlcy4gVGhlc2UgcmVzb3VyY2VzXG5cdCAqIGNhbiBiZSByZXVzZWQsIG9yIFwiaW5zdGFudGlhdGVkXCIsIGF0IG11bHRpcGxlIG5vZGVzIGluIHRoZSBzY2VuZVxuXHQgKiBoaWVyYXJjaHkuIE1lc2gsIENhbWVyYSwgYW5kIExpZ2h0IGluc3RhbmNlcyBhcmUgaW5zdGFudGlhdGVkIGFuZCBtdXN0XG5cdCAqIGJlIG1hcmtlZC4gTm9uLXNjZW5lZ3JhcGggcmVzb3VyY2VzIChsaWtlIE1hdGVyaWFscywgR2VvbWV0cmllcywgYW5kXG5cdCAqIFRleHR1cmVzKSBjYW4gYmUgcmV1c2VkIGRpcmVjdGx5IGFuZCBhcmUgbm90IG1hcmtlZCBoZXJlLlxuXHQgKlxuXHQgKiBFeGFtcGxlOiBDZXNpdW1NaWxrVHJ1Y2sgc2FtcGxlIG1vZGVsIHJldXNlcyBcIldoZWVsXCIgbWVzaGVzLlxuXHQgKi9cblx0X2FkZE5vZGVSZWYoIGNhY2hlLCBpbmRleCApIHtcblxuXHRcdGlmICggaW5kZXggPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdGlmICggY2FjaGUucmVmc1sgaW5kZXggXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjYWNoZS5yZWZzWyBpbmRleCBdID0gY2FjaGUudXNlc1sgaW5kZXggXSA9IDA7XG5cblx0XHR9XG5cblx0XHRjYWNoZS5yZWZzWyBpbmRleCBdICsrO1xuXG5cdH1cblxuXHQvKiogUmV0dXJucyBhIHJlZmVyZW5jZSB0byBhIHNoYXJlZCByZXNvdXJjZSwgY2xvbmluZyBpdCBpZiBuZWNlc3NhcnkuICovXG5cdF9nZXROb2RlUmVmKCBjYWNoZSwgaW5kZXgsIG9iamVjdCApIHtcblxuXHRcdGlmICggY2FjaGUucmVmc1sgaW5kZXggXSA8PSAxICkgcmV0dXJuIG9iamVjdDtcblxuXHRcdGNvbnN0IHJlZiA9IG9iamVjdC5jbG9uZSgpO1xuXG5cdFx0Ly8gUHJvcGFnYXRlcyBtYXBwaW5ncyB0byB0aGUgY2xvbmVkIG9iamVjdCwgcHJldmVudHMgbWFwcGluZ3Mgb24gdGhlXG5cdFx0Ly8gb3JpZ2luYWwgb2JqZWN0IGZyb20gYmVpbmcgbG9zdC5cblx0XHRjb25zdCB1cGRhdGVNYXBwaW5ncyA9ICggb3JpZ2luYWwsIGNsb25lICkgPT4ge1xuXG5cdFx0XHRjb25zdCBtYXBwaW5ncyA9IHRoaXMuYXNzb2NpYXRpb25zLmdldCggb3JpZ2luYWwgKTtcblx0XHRcdGlmICggbWFwcGluZ3MgIT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aGlzLmFzc29jaWF0aW9ucy5zZXQoIGNsb25lLCBtYXBwaW5ncyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGNvbnN0IFsgaSwgY2hpbGQgXSBvZiBvcmlnaW5hbC5jaGlsZHJlbi5lbnRyaWVzKCkgKSB7XG5cblx0XHRcdFx0dXBkYXRlTWFwcGluZ3MoIGNoaWxkLCBjbG9uZS5jaGlsZHJlblsgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHR1cGRhdGVNYXBwaW5ncyggb2JqZWN0LCByZWYgKTtcblxuXHRcdHJlZi5uYW1lICs9ICdfaW5zdGFuY2VfJyArICggY2FjaGUudXNlc1sgaW5kZXggXSArKyApO1xuXG5cdFx0cmV0dXJuIHJlZjtcblxuXHR9XG5cblx0X2ludm9rZU9uZSggZnVuYyApIHtcblxuXHRcdGNvbnN0IGV4dGVuc2lvbnMgPSBPYmplY3QudmFsdWVzKCB0aGlzLnBsdWdpbnMgKTtcblx0XHRleHRlbnNpb25zLnB1c2goIHRoaXMgKTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGV4dGVuc2lvbnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCByZXN1bHQgPSBmdW5jKCBleHRlbnNpb25zWyBpIF0gKTtcblxuXHRcdFx0aWYgKCByZXN1bHQgKSByZXR1cm4gcmVzdWx0O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0fVxuXG5cdF9pbnZva2VBbGwoIGZ1bmMgKSB7XG5cblx0XHRjb25zdCBleHRlbnNpb25zID0gT2JqZWN0LnZhbHVlcyggdGhpcy5wbHVnaW5zICk7XG5cdFx0ZXh0ZW5zaW9ucy51bnNoaWZ0KCB0aGlzICk7XG5cblx0XHRjb25zdCBwZW5kaW5nID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBleHRlbnNpb25zLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcmVzdWx0ID0gZnVuYyggZXh0ZW5zaW9uc1sgaSBdICk7XG5cblx0XHRcdGlmICggcmVzdWx0ICkgcGVuZGluZy5wdXNoKCByZXN1bHQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwZW5kaW5nO1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVxdWVzdHMgdGhlIHNwZWNpZmllZCBkZXBlbmRlbmN5IGFzeW5jaHJvbm91c2x5LCB3aXRoIGNhY2hpbmcuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdDNEfE1hdGVyaWFsfFRIUkVFLlRleHR1cmV8QW5pbWF0aW9uQ2xpcHxBcnJheUJ1ZmZlcnxPYmplY3Q+fVxuXHQgKi9cblx0Z2V0RGVwZW5kZW5jeSggdHlwZSwgaW5kZXggKSB7XG5cblx0XHRjb25zdCBjYWNoZUtleSA9IHR5cGUgKyAnOicgKyBpbmRleDtcblx0XHRsZXQgZGVwZW5kZW5jeSA9IHRoaXMuY2FjaGUuZ2V0KCBjYWNoZUtleSApO1xuXG5cdFx0aWYgKCAhIGRlcGVuZGVuY3kgKSB7XG5cblx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnc2NlbmUnOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRTY2VuZSggaW5kZXggKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdub2RlJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5sb2FkTm9kZSggaW5kZXggKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdtZXNoJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGV4dC5sb2FkTWVzaCAmJiBleHQubG9hZE1lc2goIGluZGV4ICk7XG5cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnYWNjZXNzb3InOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRBY2Nlc3NvciggaW5kZXggKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdidWZmZXJWaWV3Jzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGV4dC5sb2FkQnVmZmVyVmlldyAmJiBleHQubG9hZEJ1ZmZlclZpZXcoIGluZGV4ICk7XG5cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnYnVmZmVyJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5sb2FkQnVmZmVyKCBpbmRleCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ21hdGVyaWFsJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGV4dC5sb2FkTWF0ZXJpYWwgJiYgZXh0LmxvYWRNYXRlcmlhbCggaW5kZXggKTtcblxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd0ZXh0dXJlJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGV4dC5sb2FkVGV4dHVyZSAmJiBleHQubG9hZFRleHR1cmUoIGluZGV4ICk7XG5cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnc2tpbic6XG5cdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IHRoaXMubG9hZFNraW4oIGluZGV4ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnYW5pbWF0aW9uJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5sb2FkQW5pbWF0aW9uKCBpbmRleCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2NhbWVyYSc6XG5cdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IHRoaXMubG9hZENhbWVyYSggaW5kZXggKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1Vua25vd24gdHlwZTogJyArIHR5cGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmNhY2hlLmFkZCggY2FjaGVLZXksIGRlcGVuZGVuY3kgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkZXBlbmRlbmN5O1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVxdWVzdHMgYWxsIGRlcGVuZGVuY2llcyBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgYXN5bmNocm9ub3VzbHksIHdpdGggY2FjaGluZy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcblx0ICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxPYmplY3Q+Pn1cblx0ICovXG5cdGdldERlcGVuZGVuY2llcyggdHlwZSApIHtcblxuXHRcdGxldCBkZXBlbmRlbmNpZXMgPSB0aGlzLmNhY2hlLmdldCggdHlwZSApO1xuXG5cdFx0aWYgKCAhIGRlcGVuZGVuY2llcyApIHtcblxuXHRcdFx0Y29uc3QgcGFyc2VyID0gdGhpcztcblx0XHRcdGNvbnN0IGRlZnMgPSB0aGlzLmpzb25bIHR5cGUgKyAoIHR5cGUgPT09ICdtZXNoJyA/ICdlcycgOiAncycgKSBdIHx8IFtdO1xuXG5cdFx0XHRkZXBlbmRlbmNpZXMgPSBQcm9taXNlLmFsbCggZGVmcy5tYXAoIGZ1bmN0aW9uICggZGVmLCBpbmRleCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koIHR5cGUsIGluZGV4ICk7XG5cblx0XHRcdH0gKSApO1xuXG5cdFx0XHR0aGlzLmNhY2hlLmFkZCggdHlwZSwgZGVwZW5kZW5jaWVzICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGVwZW5kZW5jaWVzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNidWZmZXJzLWFuZC1idWZmZXItdmlld3Ncblx0ICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlckluZGV4XG5cdCAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXlCdWZmZXI+fVxuXHQgKi9cblx0bG9hZEJ1ZmZlciggYnVmZmVySW5kZXggKSB7XG5cblx0XHRjb25zdCBidWZmZXJEZWYgPSB0aGlzLmpzb24uYnVmZmVyc1sgYnVmZmVySW5kZXggXTtcblx0XHRjb25zdCBsb2FkZXIgPSB0aGlzLmZpbGVMb2FkZXI7XG5cblx0XHRpZiAoIGJ1ZmZlckRlZi50eXBlICYmIGJ1ZmZlckRlZi50eXBlICE9PSAnYXJyYXlidWZmZXInICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiAnICsgYnVmZmVyRGVmLnR5cGUgKyAnIGJ1ZmZlciB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gSWYgcHJlc2VudCwgR0xCIGNvbnRhaW5lciBpcyByZXF1aXJlZCB0byBiZSB0aGUgZmlyc3QgYnVmZmVyLlxuXHRcdGlmICggYnVmZmVyRGVmLnVyaSA9PT0gdW5kZWZpbmVkICYmIGJ1ZmZlckluZGV4ID09PSAwICkge1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCB0aGlzLmV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX0JJTkFSWV9HTFRGIF0uYm9keSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdHJldHVybiBuZXcgUHJvbWlzZSggZnVuY3Rpb24gKCByZXNvbHZlLCByZWplY3QgKSB7XG5cblx0XHRcdGxvYWRlci5sb2FkKCBMb2FkZXJVdGlscy5yZXNvbHZlVVJMKCBidWZmZXJEZWYudXJpLCBvcHRpb25zLnBhdGggKSwgcmVzb2x2ZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0cmVqZWN0KCBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBGYWlsZWQgdG8gbG9hZCBidWZmZXIgXCInICsgYnVmZmVyRGVmLnVyaSArICdcIi4nICkgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNidWZmZXJzLWFuZC1idWZmZXItdmlld3Ncblx0ICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlclZpZXdJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5QnVmZmVyPn1cblx0ICovXG5cdGxvYWRCdWZmZXJWaWV3KCBidWZmZXJWaWV3SW5kZXggKSB7XG5cblx0XHRjb25zdCBidWZmZXJWaWV3RGVmID0gdGhpcy5qc29uLmJ1ZmZlclZpZXdzWyBidWZmZXJWaWV3SW5kZXggXTtcblxuXHRcdHJldHVybiB0aGlzLmdldERlcGVuZGVuY3koICdidWZmZXInLCBidWZmZXJWaWV3RGVmLmJ1ZmZlciApLnRoZW4oIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHRjb25zdCBieXRlTGVuZ3RoID0gYnVmZmVyVmlld0RlZi5ieXRlTGVuZ3RoIHx8IDA7XG5cdFx0XHRjb25zdCBieXRlT2Zmc2V0ID0gYnVmZmVyVmlld0RlZi5ieXRlT2Zmc2V0IHx8IDA7XG5cdFx0XHRyZXR1cm4gYnVmZmVyLnNsaWNlKCBieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCApO1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNhY2Nlc3NvcnNcblx0ICogQHBhcmFtIHtudW1iZXJ9IGFjY2Vzc29ySW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxCdWZmZXJBdHRyaWJ1dGV8SW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU+fVxuXHQgKi9cblx0bG9hZEFjY2Vzc29yKCBhY2Nlc3NvckluZGV4ICkge1xuXG5cdFx0Y29uc3QgcGFyc2VyID0gdGhpcztcblx0XHRjb25zdCBqc29uID0gdGhpcy5qc29uO1xuXG5cdFx0Y29uc3QgYWNjZXNzb3JEZWYgPSB0aGlzLmpzb24uYWNjZXNzb3JzWyBhY2Nlc3NvckluZGV4IF07XG5cblx0XHRpZiAoIGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgPT09IHVuZGVmaW5lZCAmJiBhY2Nlc3NvckRlZi5zcGFyc2UgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gSWdub3JlIGVtcHR5IGFjY2Vzc29ycywgd2hpY2ggbWF5IGJlIHVzZWQgdG8gZGVjbGFyZSBydW50aW1lXG5cdFx0XHQvLyBpbmZvcm1hdGlvbiBhYm91dCBhdHRyaWJ1dGVzIGNvbWluZyBmcm9tIGFub3RoZXIgc291cmNlIChlLmcuIERyYWNvXG5cdFx0XHQvLyBjb21wcmVzc2lvbiBleHRlbnNpb24pLlxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSggbnVsbCApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcGVuZGluZ0J1ZmZlclZpZXdzID0gW107XG5cblx0XHRpZiAoIGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cGVuZGluZ0J1ZmZlclZpZXdzLnB1c2goIHRoaXMuZ2V0RGVwZW5kZW5jeSggJ2J1ZmZlclZpZXcnLCBhY2Nlc3NvckRlZi5idWZmZXJWaWV3ICkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKCBudWxsICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGFjY2Vzc29yRGVmLnNwYXJzZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwZW5kaW5nQnVmZmVyVmlld3MucHVzaCggdGhpcy5nZXREZXBlbmRlbmN5KCAnYnVmZmVyVmlldycsIGFjY2Vzc29yRGVmLnNwYXJzZS5pbmRpY2VzLmJ1ZmZlclZpZXcgKSApO1xuXHRcdFx0cGVuZGluZ0J1ZmZlclZpZXdzLnB1c2goIHRoaXMuZ2V0RGVwZW5kZW5jeSggJ2J1ZmZlclZpZXcnLCBhY2Nlc3NvckRlZi5zcGFyc2UudmFsdWVzLmJ1ZmZlclZpZXcgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nQnVmZmVyVmlld3MgKS50aGVuKCBmdW5jdGlvbiAoIGJ1ZmZlclZpZXdzICkge1xuXG5cdFx0XHRjb25zdCBidWZmZXJWaWV3ID0gYnVmZmVyVmlld3NbIDAgXTtcblxuXHRcdFx0Y29uc3QgaXRlbVNpemUgPSBXRUJHTF9UWVBFX1NJWkVTWyBhY2Nlc3NvckRlZi50eXBlIF07XG5cdFx0XHRjb25zdCBUeXBlZEFycmF5ID0gV0VCR0xfQ09NUE9ORU5UX1RZUEVTWyBhY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlIF07XG5cblx0XHRcdC8vIEZvciBWRUMzOiBpdGVtU2l6ZSBpcyAzLCBlbGVtZW50Qnl0ZXMgaXMgNCwgaXRlbUJ5dGVzIGlzIDEyLlxuXHRcdFx0Y29uc3QgZWxlbWVudEJ5dGVzID0gVHlwZWRBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcblx0XHRcdGNvbnN0IGl0ZW1CeXRlcyA9IGVsZW1lbnRCeXRlcyAqIGl0ZW1TaXplO1xuXHRcdFx0Y29uc3QgYnl0ZU9mZnNldCA9IGFjY2Vzc29yRGVmLmJ5dGVPZmZzZXQgfHwgMDtcblx0XHRcdGNvbnN0IGJ5dGVTdHJpZGUgPSBhY2Nlc3NvckRlZi5idWZmZXJWaWV3ICE9PSB1bmRlZmluZWQgPyBqc29uLmJ1ZmZlclZpZXdzWyBhY2Nlc3NvckRlZi5idWZmZXJWaWV3IF0uYnl0ZVN0cmlkZSA6IHVuZGVmaW5lZDtcblx0XHRcdGNvbnN0IG5vcm1hbGl6ZWQgPSBhY2Nlc3NvckRlZi5ub3JtYWxpemVkID09PSB0cnVlO1xuXHRcdFx0bGV0IGFycmF5LCBidWZmZXJBdHRyaWJ1dGU7XG5cblx0XHRcdC8vIFRoZSBidWZmZXIgaXMgbm90IGludGVybGVhdmVkIGlmIHRoZSBzdHJpZGUgaXMgdGhlIGl0ZW0gc2l6ZSBpbiBieXRlcy5cblx0XHRcdGlmICggYnl0ZVN0cmlkZSAmJiBieXRlU3RyaWRlICE9PSBpdGVtQnl0ZXMgKSB7XG5cblx0XHRcdFx0Ly8gRWFjaCBcInNsaWNlXCIgb2YgdGhlIGJ1ZmZlciwgYXMgZGVmaW5lZCBieSAnY291bnQnIGVsZW1lbnRzIG9mICdieXRlU3RyaWRlJyBieXRlcywgZ2V0cyBpdHMgb3duIEludGVybGVhdmVkQnVmZmVyXG5cdFx0XHRcdC8vIFRoaXMgbWFrZXMgc3VyZSB0aGF0IElCQS5jb3VudCByZWZsZWN0cyBhY2Nlc3Nvci5jb3VudCBwcm9wZXJseVxuXHRcdFx0XHRjb25zdCBpYlNsaWNlID0gTWF0aC5mbG9vciggYnl0ZU9mZnNldCAvIGJ5dGVTdHJpZGUgKTtcblx0XHRcdFx0Y29uc3QgaWJDYWNoZUtleSA9ICdJbnRlcmxlYXZlZEJ1ZmZlcjonICsgYWNjZXNzb3JEZWYuYnVmZmVyVmlldyArICc6JyArIGFjY2Vzc29yRGVmLmNvbXBvbmVudFR5cGUgKyAnOicgKyBpYlNsaWNlICsgJzonICsgYWNjZXNzb3JEZWYuY291bnQ7XG5cdFx0XHRcdGxldCBpYiA9IHBhcnNlci5jYWNoZS5nZXQoIGliQ2FjaGVLZXkgKTtcblxuXHRcdFx0XHRpZiAoICEgaWIgKSB7XG5cblx0XHRcdFx0XHRhcnJheSA9IG5ldyBUeXBlZEFycmF5KCBidWZmZXJWaWV3LCBpYlNsaWNlICogYnl0ZVN0cmlkZSwgYWNjZXNzb3JEZWYuY291bnQgKiBieXRlU3RyaWRlIC8gZWxlbWVudEJ5dGVzICk7XG5cblx0XHRcdFx0XHQvLyBJbnRlZ2VyIHBhcmFtZXRlcnMgdG8gSUIvSUJBIGFyZSBpbiBhcnJheSBlbGVtZW50cywgbm90IGJ5dGVzLlxuXHRcdFx0XHRcdGliID0gbmV3IEludGVybGVhdmVkQnVmZmVyKCBhcnJheSwgYnl0ZVN0cmlkZSAvIGVsZW1lbnRCeXRlcyApO1xuXG5cdFx0XHRcdFx0cGFyc2VyLmNhY2hlLmFkZCggaWJDYWNoZUtleSwgaWIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnVmZmVyQXR0cmlidXRlID0gbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKCBpYiwgaXRlbVNpemUsICggYnl0ZU9mZnNldCAlIGJ5dGVTdHJpZGUgKSAvIGVsZW1lbnRCeXRlcywgbm9ybWFsaXplZCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggYnVmZmVyVmlldyA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoIGFjY2Vzc29yRGVmLmNvdW50ICogaXRlbVNpemUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0YXJyYXkgPSBuZXcgVHlwZWRBcnJheSggYnVmZmVyVmlldywgYnl0ZU9mZnNldCwgYWNjZXNzb3JEZWYuY291bnQgKiBpdGVtU2l6ZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRidWZmZXJBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI3NwYXJzZS1hY2Nlc3NvcnNcblx0XHRcdGlmICggYWNjZXNzb3JEZWYuc3BhcnNlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc3QgaXRlbVNpemVJbmRpY2VzID0gV0VCR0xfVFlQRV9TSVpFUy5TQ0FMQVI7XG5cdFx0XHRcdGNvbnN0IFR5cGVkQXJyYXlJbmRpY2VzID0gV0VCR0xfQ09NUE9ORU5UX1RZUEVTWyBhY2Nlc3NvckRlZi5zcGFyc2UuaW5kaWNlcy5jb21wb25lbnRUeXBlIF07XG5cblx0XHRcdFx0Y29uc3QgYnl0ZU9mZnNldEluZGljZXMgPSBhY2Nlc3NvckRlZi5zcGFyc2UuaW5kaWNlcy5ieXRlT2Zmc2V0IHx8IDA7XG5cdFx0XHRcdGNvbnN0IGJ5dGVPZmZzZXRWYWx1ZXMgPSBhY2Nlc3NvckRlZi5zcGFyc2UudmFsdWVzLmJ5dGVPZmZzZXQgfHwgMDtcblxuXHRcdFx0XHRjb25zdCBzcGFyc2VJbmRpY2VzID0gbmV3IFR5cGVkQXJyYXlJbmRpY2VzKCBidWZmZXJWaWV3c1sgMSBdLCBieXRlT2Zmc2V0SW5kaWNlcywgYWNjZXNzb3JEZWYuc3BhcnNlLmNvdW50ICogaXRlbVNpemVJbmRpY2VzICk7XG5cdFx0XHRcdGNvbnN0IHNwYXJzZVZhbHVlcyA9IG5ldyBUeXBlZEFycmF5KCBidWZmZXJWaWV3c1sgMiBdLCBieXRlT2Zmc2V0VmFsdWVzLCBhY2Nlc3NvckRlZi5zcGFyc2UuY291bnQgKiBpdGVtU2l6ZSApO1xuXG5cdFx0XHRcdGlmICggYnVmZmVyVmlldyAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdC8vIEF2b2lkIG1vZGlmeWluZyB0aGUgb3JpZ2luYWwgQXJyYXlCdWZmZXIsIGlmIHRoZSBidWZmZXJWaWV3IHdhc24ndCBpbml0aWFsaXplZCB3aXRoIHplcm9lcy5cblx0XHRcdFx0XHRidWZmZXJBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBidWZmZXJBdHRyaWJ1dGUuYXJyYXkuc2xpY2UoKSwgYnVmZmVyQXR0cmlidXRlLml0ZW1TaXplLCBidWZmZXJBdHRyaWJ1dGUubm9ybWFsaXplZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gc3BhcnNlSW5kaWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gc3BhcnNlSW5kaWNlc1sgaSBdO1xuXG5cdFx0XHRcdFx0YnVmZmVyQXR0cmlidXRlLnNldFgoIGluZGV4LCBzcGFyc2VWYWx1ZXNbIGkgKiBpdGVtU2l6ZSBdICk7XG5cdFx0XHRcdFx0aWYgKCBpdGVtU2l6ZSA+PSAyICkgYnVmZmVyQXR0cmlidXRlLnNldFkoIGluZGV4LCBzcGFyc2VWYWx1ZXNbIGkgKiBpdGVtU2l6ZSArIDEgXSApO1xuXHRcdFx0XHRcdGlmICggaXRlbVNpemUgPj0gMyApIGJ1ZmZlckF0dHJpYnV0ZS5zZXRaKCBpbmRleCwgc3BhcnNlVmFsdWVzWyBpICogaXRlbVNpemUgKyAyIF0gKTtcblx0XHRcdFx0XHRpZiAoIGl0ZW1TaXplID49IDQgKSBidWZmZXJBdHRyaWJ1dGUuc2V0VyggaW5kZXgsIHNwYXJzZVZhbHVlc1sgaSAqIGl0ZW1TaXplICsgMyBdICk7XG5cdFx0XHRcdFx0aWYgKCBpdGVtU2l6ZSA+PSA1ICkgdGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgaXRlbVNpemUgaW4gc3BhcnNlIEJ1ZmZlckF0dHJpYnV0ZS4nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBidWZmZXJBdHRyaWJ1dGU7XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjdGV4dHVyZXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRleHR1cmVJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPFRIUkVFLlRleHR1cmU+fVxuXHQgKi9cblx0bG9hZFRleHR1cmUoIHRleHR1cmVJbmRleCApIHtcblxuXHRcdGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG5cdFx0Y29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0XHRjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1sgdGV4dHVyZUluZGV4IF07XG5cdFx0Y29uc3Qgc291cmNlID0ganNvbi5pbWFnZXNbIHRleHR1cmVEZWYuc291cmNlIF07XG5cblx0XHRsZXQgbG9hZGVyID0gdGhpcy50ZXh0dXJlTG9hZGVyO1xuXG5cdFx0aWYgKCBzb3VyY2UudXJpICkge1xuXG5cdFx0XHRjb25zdCBoYW5kbGVyID0gb3B0aW9ucy5tYW5hZ2VyLmdldEhhbmRsZXIoIHNvdXJjZS51cmkgKTtcblx0XHRcdGlmICggaGFuZGxlciAhPT0gbnVsbCApIGxvYWRlciA9IGhhbmRsZXI7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5sb2FkVGV4dHVyZUltYWdlKCB0ZXh0dXJlSW5kZXgsIHNvdXJjZSwgbG9hZGVyICk7XG5cblx0fVxuXG5cdGxvYWRUZXh0dXJlSW1hZ2UoIHRleHR1cmVJbmRleCwgc291cmNlLCBsb2FkZXIgKSB7XG5cblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzO1xuXHRcdGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG5cdFx0Y29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzWyB0ZXh0dXJlSW5kZXggXTtcblxuXHRcdGNvbnN0IGNhY2hlS2V5ID0gKCBzb3VyY2UudXJpIHx8IHNvdXJjZS5idWZmZXJWaWV3ICkgKyAnOicgKyB0ZXh0dXJlRGVmLnNhbXBsZXI7XG5cblx0XHRpZiAoIHRoaXMudGV4dHVyZUNhY2hlWyBjYWNoZUtleSBdICkge1xuXG5cdFx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMjE1NTkuXG5cdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlQ2FjaGVbIGNhY2hlS2V5IF07XG5cblx0XHR9XG5cblx0XHRjb25zdCBVUkwgPSBzZWxmLlVSTCB8fCBzZWxmLndlYmtpdFVSTDtcblxuXHRcdGxldCBzb3VyY2VVUkkgPSBzb3VyY2UudXJpIHx8ICcnO1xuXHRcdGxldCBpc09iamVjdFVSTCA9IGZhbHNlO1xuXG5cdFx0aWYgKCBzb3VyY2UuYnVmZmVyVmlldyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBMb2FkIGJpbmFyeSBpbWFnZSBkYXRhIGZyb20gYnVmZmVyVmlldywgaWYgcHJvdmlkZWQuXG5cblx0XHRcdHNvdXJjZVVSSSA9IHBhcnNlci5nZXREZXBlbmRlbmN5KCAnYnVmZmVyVmlldycsIHNvdXJjZS5idWZmZXJWaWV3ICkudGhlbiggZnVuY3Rpb24gKCBidWZmZXJWaWV3ICkge1xuXG5cdFx0XHRcdGlzT2JqZWN0VVJMID0gdHJ1ZTtcblx0XHRcdFx0Y29uc3QgYmxvYiA9IG5ldyBCbG9iKCBbIGJ1ZmZlclZpZXcgXSwgeyB0eXBlOiBzb3VyY2UubWltZVR5cGUgfSApO1xuXHRcdFx0XHRzb3VyY2VVUkkgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKCBibG9iICk7XG5cdFx0XHRcdHJldHVybiBzb3VyY2VVUkk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH0gZWxzZSBpZiAoIHNvdXJjZS51cmkgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogSW1hZ2UgJyArIHRleHR1cmVJbmRleCArICcgaXMgbWlzc2luZyBVUkkgYW5kIGJ1ZmZlclZpZXcnICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCBzb3VyY2VVUkkgKS50aGVuKCBmdW5jdGlvbiAoIHNvdXJjZVVSSSApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKCBmdW5jdGlvbiAoIHJlc29sdmUsIHJlamVjdCApIHtcblxuXHRcdFx0XHRsZXQgb25Mb2FkID0gcmVzb2x2ZTtcblxuXHRcdFx0XHRpZiAoIGxvYWRlci5pc0ltYWdlQml0bWFwTG9hZGVyID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0b25Mb2FkID0gZnVuY3Rpb24gKCBpbWFnZUJpdG1hcCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKCBpbWFnZUJpdG1hcCApO1xuXHRcdFx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdHJlc29sdmUoIHRleHR1cmUgKTtcblxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxvYWRlci5sb2FkKCBMb2FkZXJVdGlscy5yZXNvbHZlVVJMKCBzb3VyY2VVUkksIG9wdGlvbnMucGF0aCApLCBvbkxvYWQsIHVuZGVmaW5lZCwgcmVqZWN0ICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH0gKS50aGVuKCBmdW5jdGlvbiAoIHRleHR1cmUgKSB7XG5cblx0XHRcdC8vIENsZWFuIHVwIHJlc291cmNlcyBhbmQgY29uZmlndXJlIFRleHR1cmUuXG5cblx0XHRcdGlmICggaXNPYmplY3RVUkwgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0VVJMLnJldm9rZU9iamVjdFVSTCggc291cmNlVVJJICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoIHRleHR1cmVEZWYubmFtZSApIHRleHR1cmUubmFtZSA9IHRleHR1cmVEZWYubmFtZTtcblxuXHRcdFx0Y29uc3Qgc2FtcGxlcnMgPSBqc29uLnNhbXBsZXJzIHx8IHt9O1xuXHRcdFx0Y29uc3Qgc2FtcGxlciA9IHNhbXBsZXJzWyB0ZXh0dXJlRGVmLnNhbXBsZXIgXSB8fCB7fTtcblxuXHRcdFx0dGV4dHVyZS5tYWdGaWx0ZXIgPSBXRUJHTF9GSUxURVJTWyBzYW1wbGVyLm1hZ0ZpbHRlciBdIHx8IExpbmVhckZpbHRlcjtcblx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gV0VCR0xfRklMVEVSU1sgc2FtcGxlci5taW5GaWx0ZXIgXSB8fCBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXI7XG5cdFx0XHR0ZXh0dXJlLndyYXBTID0gV0VCR0xfV1JBUFBJTkdTWyBzYW1wbGVyLndyYXBTIF0gfHwgUmVwZWF0V3JhcHBpbmc7XG5cdFx0XHR0ZXh0dXJlLndyYXBUID0gV0VCR0xfV1JBUFBJTkdTWyBzYW1wbGVyLndyYXBUIF0gfHwgUmVwZWF0V3JhcHBpbmc7XG5cblx0XHRcdHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KCB0ZXh0dXJlLCB7IHRleHR1cmVzOiB0ZXh0dXJlSW5kZXggfSApO1xuXG5cdFx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHRcdH0gKS5jYXRjaCggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogQ291bGRuXFwndCBsb2FkIHRleHR1cmUnLCBzb3VyY2VVUkkgKTtcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fSApO1xuXG5cdFx0dGhpcy50ZXh0dXJlQ2FjaGVbIGNhY2hlS2V5IF0gPSBwcm9taXNlO1xuXG5cdFx0cmV0dXJuIHByb21pc2U7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBc3luY2hyb25vdXNseSBhc3NpZ25zIGEgdGV4dHVyZSB0byB0aGUgZ2l2ZW4gbWF0ZXJpYWwgcGFyYW1ldGVycy5cblx0ICogQHBhcmFtIHtPYmplY3R9IG1hdGVyaWFsUGFyYW1zXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtYXBOYW1lXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtYXBEZWZcblx0ICogQHJldHVybiB7UHJvbWlzZTxUZXh0dXJlPn1cblx0ICovXG5cdGFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCBtYXBOYW1lLCBtYXBEZWYgKSB7XG5cblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzO1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jeSggJ3RleHR1cmUnLCBtYXBEZWYuaW5kZXggKS50aGVuKCBmdW5jdGlvbiAoIHRleHR1cmUgKSB7XG5cblx0XHRcdC8vIE1hdGVyaWFscyBzYW1wbGUgYW9NYXAgZnJvbSBVViBzZXQgMSBhbmQgb3RoZXIgbWFwcyBmcm9tIFVWIHNldCAwIC0gdGhpcyBjYW4ndCBiZSBjb25maWd1cmVkXG5cdFx0XHQvLyBIb3dldmVyLCB3ZSB3aWxsIGNvcHkgVVYgc2V0IDAgdG8gVVYgc2V0IDEgb24gZGVtYW5kIGZvciBhb01hcFxuXHRcdFx0aWYgKCBtYXBEZWYudGV4Q29vcmQgIT09IHVuZGVmaW5lZCAmJiBtYXBEZWYudGV4Q29vcmQgIT0gMCAmJiAhICggbWFwTmFtZSA9PT0gJ2FvTWFwJyAmJiBtYXBEZWYudGV4Q29vcmQgPT0gMSApICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdMVEZMb2FkZXI6IEN1c3RvbSBVViBzZXQgJyArIG1hcERlZi50ZXhDb29yZCArICcgZm9yIHRleHR1cmUgJyArIG1hcE5hbWUgKyAnIG5vdCB5ZXQgc3VwcG9ydGVkLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHBhcnNlci5leHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STSBdICkge1xuXG5cdFx0XHRcdGNvbnN0IHRyYW5zZm9ybSA9IG1hcERlZi5leHRlbnNpb25zICE9PSB1bmRlZmluZWQgPyBtYXBEZWYuZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk0gXSA6IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRpZiAoIHRyYW5zZm9ybSApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGdsdGZSZWZlcmVuY2UgPSBwYXJzZXIuYXNzb2NpYXRpb25zLmdldCggdGV4dHVyZSApO1xuXHRcdFx0XHRcdHRleHR1cmUgPSBwYXJzZXIuZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk0gXS5leHRlbmRUZXh0dXJlKCB0ZXh0dXJlLCB0cmFuc2Zvcm0gKTtcblx0XHRcdFx0XHRwYXJzZXIuYXNzb2NpYXRpb25zLnNldCggdGV4dHVyZSwgZ2x0ZlJlZmVyZW5jZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRtYXRlcmlhbFBhcmFtc1sgbWFwTmFtZSBdID0gdGV4dHVyZTtcblxuXHRcdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBc3NpZ25zIGZpbmFsIG1hdGVyaWFsIHRvIGEgTWVzaCwgTGluZSwgb3IgUG9pbnRzIGluc3RhbmNlLiBUaGUgaW5zdGFuY2Vcblx0ICogYWxyZWFkeSBoYXMgYSBtYXRlcmlhbCAoZ2VuZXJhdGVkIGZyb20gdGhlIGdsVEYgbWF0ZXJpYWwgb3B0aW9ucyBhbG9uZSlcblx0ICogYnV0IHJldXNlIG9mIHRoZSBzYW1lIGdsVEYgbWF0ZXJpYWwgbWF5IHJlcXVpcmUgbXVsdGlwbGUgdGhyZWVqcyBtYXRlcmlhbHNcblx0ICogdG8gYWNjb21tb2RhdGUgZGlmZmVyZW50IHByaW1pdGl2ZSB0eXBlcywgZGVmaW5lcywgZXRjLiBOZXcgbWF0ZXJpYWxzIHdpbGxcblx0ICogYmUgY3JlYXRlZCBpZiBuZWNlc3NhcnksIGFuZCByZXVzZWQgZnJvbSBhIGNhY2hlLlxuXHQgKiBAcGFyYW0gIHtPYmplY3QzRH0gbWVzaCBNZXNoLCBMaW5lLCBvciBQb2ludHMgaW5zdGFuY2UuXG5cdCAqL1xuXHRhc3NpZ25GaW5hbE1hdGVyaWFsKCBtZXNoICkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBtZXNoLmdlb21ldHJ5O1xuXHRcdGxldCBtYXRlcmlhbCA9IG1lc2gubWF0ZXJpYWw7XG5cblx0XHRjb25zdCB1c2VEZXJpdmF0aXZlVGFuZ2VudHMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnRhbmdlbnQgPT09IHVuZGVmaW5lZDtcblx0XHRjb25zdCB1c2VWZXJ0ZXhDb2xvcnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yICE9PSB1bmRlZmluZWQ7XG5cdFx0Y29uc3QgdXNlRmxhdFNoYWRpbmcgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdW5kZWZpbmVkO1xuXG5cdFx0aWYgKCBtZXNoLmlzUG9pbnRzICkge1xuXG5cdFx0XHRjb25zdCBjYWNoZUtleSA9ICdQb2ludHNNYXRlcmlhbDonICsgbWF0ZXJpYWwudXVpZDtcblxuXHRcdFx0bGV0IHBvaW50c01hdGVyaWFsID0gdGhpcy5jYWNoZS5nZXQoIGNhY2hlS2V5ICk7XG5cblx0XHRcdGlmICggISBwb2ludHNNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRwb2ludHNNYXRlcmlhbCA9IG5ldyBQb2ludHNNYXRlcmlhbCgpO1xuXHRcdFx0XHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCBwb2ludHNNYXRlcmlhbCwgbWF0ZXJpYWwgKTtcblx0XHRcdFx0cG9pbnRzTWF0ZXJpYWwuY29sb3IuY29weSggbWF0ZXJpYWwuY29sb3IgKTtcblx0XHRcdFx0cG9pbnRzTWF0ZXJpYWwubWFwID0gbWF0ZXJpYWwubWFwO1xuXHRcdFx0XHRwb2ludHNNYXRlcmlhbC5zaXplQXR0ZW51YXRpb24gPSBmYWxzZTsgLy8gZ2xURiBzcGVjIHNheXMgcG9pbnRzIHNob3VsZCBiZSAxcHhcblxuXHRcdFx0XHR0aGlzLmNhY2hlLmFkZCggY2FjaGVLZXksIHBvaW50c01hdGVyaWFsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWwgPSBwb2ludHNNYXRlcmlhbDtcblxuXHRcdH0gZWxzZSBpZiAoIG1lc2guaXNMaW5lICkge1xuXG5cdFx0XHRjb25zdCBjYWNoZUtleSA9ICdMaW5lQmFzaWNNYXRlcmlhbDonICsgbWF0ZXJpYWwudXVpZDtcblxuXHRcdFx0bGV0IGxpbmVNYXRlcmlhbCA9IHRoaXMuY2FjaGUuZ2V0KCBjYWNoZUtleSApO1xuXG5cdFx0XHRpZiAoICEgbGluZU1hdGVyaWFsICkge1xuXG5cdFx0XHRcdGxpbmVNYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCgpO1xuXHRcdFx0XHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCBsaW5lTWF0ZXJpYWwsIG1hdGVyaWFsICk7XG5cdFx0XHRcdGxpbmVNYXRlcmlhbC5jb2xvci5jb3B5KCBtYXRlcmlhbC5jb2xvciApO1xuXG5cdFx0XHRcdHRoaXMuY2FjaGUuYWRkKCBjYWNoZUtleSwgbGluZU1hdGVyaWFsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWwgPSBsaW5lTWF0ZXJpYWw7XG5cblx0XHR9XG5cblx0XHQvLyBDbG9uZSB0aGUgbWF0ZXJpYWwgaWYgaXQgd2lsbCBiZSBtb2RpZmllZFxuXHRcdGlmICggdXNlRGVyaXZhdGl2ZVRhbmdlbnRzIHx8IHVzZVZlcnRleENvbG9ycyB8fCB1c2VGbGF0U2hhZGluZyApIHtcblxuXHRcdFx0bGV0IGNhY2hlS2V5ID0gJ0Nsb25lZE1hdGVyaWFsOicgKyBtYXRlcmlhbC51dWlkICsgJzonO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmlzR0xURlNwZWN1bGFyR2xvc3NpbmVzc01hdGVyaWFsICkgY2FjaGVLZXkgKz0gJ3NwZWN1bGFyLWdsb3NzaW5lc3M6Jztcblx0XHRcdGlmICggdXNlRGVyaXZhdGl2ZVRhbmdlbnRzICkgY2FjaGVLZXkgKz0gJ2Rlcml2YXRpdmUtdGFuZ2VudHM6Jztcblx0XHRcdGlmICggdXNlVmVydGV4Q29sb3JzICkgY2FjaGVLZXkgKz0gJ3ZlcnRleC1jb2xvcnM6Jztcblx0XHRcdGlmICggdXNlRmxhdFNoYWRpbmcgKSBjYWNoZUtleSArPSAnZmxhdC1zaGFkaW5nOic7XG5cblx0XHRcdGxldCBjYWNoZWRNYXRlcmlhbCA9IHRoaXMuY2FjaGUuZ2V0KCBjYWNoZUtleSApO1xuXG5cdFx0XHRpZiAoICEgY2FjaGVkTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0Y2FjaGVkTWF0ZXJpYWwgPSBtYXRlcmlhbC5jbG9uZSgpO1xuXG5cdFx0XHRcdGlmICggdXNlVmVydGV4Q29sb3JzICkgY2FjaGVkTWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCB1c2VGbGF0U2hhZGluZyApIGNhY2hlZE1hdGVyaWFsLmZsYXRTaGFkaW5nID0gdHJ1ZTtcblxuXHRcdFx0XHRpZiAoIHVzZURlcml2YXRpdmVUYW5nZW50cyApIHtcblxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzExNDM4I2lzc3VlY29tbWVudC01MDcwMDM5OTVcblx0XHRcdFx0XHRpZiAoIGNhY2hlZE1hdGVyaWFsLm5vcm1hbFNjYWxlICkgY2FjaGVkTWF0ZXJpYWwubm9ybWFsU2NhbGUueSAqPSAtIDE7XG5cdFx0XHRcdFx0aWYgKCBjYWNoZWRNYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxTY2FsZSApIGNhY2hlZE1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbFNjYWxlLnkgKj0gLSAxO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmNhY2hlLmFkZCggY2FjaGVLZXksIGNhY2hlZE1hdGVyaWFsICk7XG5cblx0XHRcdFx0dGhpcy5hc3NvY2lhdGlvbnMuc2V0KCBjYWNoZWRNYXRlcmlhbCwgdGhpcy5hc3NvY2lhdGlvbnMuZ2V0KCBtYXRlcmlhbCApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWwgPSBjYWNoZWRNYXRlcmlhbDtcblxuXHRcdH1cblxuXHRcdC8vIHdvcmthcm91bmRzIGZvciBtZXNoIGFuZCBnZW9tZXRyeVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5hb01hcCAmJiBnZW9tZXRyeS5hdHRyaWJ1dGVzLnV2MiA9PT0gdW5kZWZpbmVkICYmIGdlb21ldHJ5LmF0dHJpYnV0ZXMudXYgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAndXYyJywgZ2VvbWV0cnkuYXR0cmlidXRlcy51diApO1xuXG5cdFx0fVxuXG5cdFx0bWVzaC5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuXG5cdH1cblxuXHRnZXRNYXRlcmlhbFR5cGUoIC8qIG1hdGVyaWFsSW5kZXggKi8gKSB7XG5cblx0XHRyZXR1cm4gTWVzaFN0YW5kYXJkTWF0ZXJpYWw7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI21hdGVyaWFsc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF0ZXJpYWxJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPE1hdGVyaWFsPn1cblx0ICovXG5cdGxvYWRNYXRlcmlhbCggbWF0ZXJpYWxJbmRleCApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXM7XG5cdFx0Y29uc3QganNvbiA9IHRoaXMuanNvbjtcblx0XHRjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuXHRcdGNvbnN0IG1hdGVyaWFsRGVmID0ganNvbi5tYXRlcmlhbHNbIG1hdGVyaWFsSW5kZXggXTtcblxuXHRcdGxldCBtYXRlcmlhbFR5cGU7XG5cdFx0Y29uc3QgbWF0ZXJpYWxQYXJhbXMgPSB7fTtcblx0XHRjb25zdCBtYXRlcmlhbEV4dGVuc2lvbnMgPSBtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8IHt9O1xuXG5cdFx0Y29uc3QgcGVuZGluZyA9IFtdO1xuXG5cdFx0aWYgKCBtYXRlcmlhbEV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19QQlJfU1BFQ1VMQVJfR0xPU1NJTkVTUyBdICkge1xuXG5cdFx0XHRjb25zdCBzZ0V4dGVuc2lvbiA9IGV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19QQlJfU1BFQ1VMQVJfR0xPU1NJTkVTUyBdO1xuXHRcdFx0bWF0ZXJpYWxUeXBlID0gc2dFeHRlbnNpb24uZ2V0TWF0ZXJpYWxUeXBlKCk7XG5cdFx0XHRwZW5kaW5nLnB1c2goIHNnRXh0ZW5zaW9uLmV4dGVuZFBhcmFtcyggbWF0ZXJpYWxQYXJhbXMsIG1hdGVyaWFsRGVmLCBwYXJzZXIgKSApO1xuXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxFeHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVQgXSApIHtcblxuXHRcdFx0Y29uc3Qga211RXh0ZW5zaW9uID0gZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUIF07XG5cdFx0XHRtYXRlcmlhbFR5cGUgPSBrbXVFeHRlbnNpb24uZ2V0TWF0ZXJpYWxUeXBlKCk7XG5cdFx0XHRwZW5kaW5nLnB1c2goIGttdUV4dGVuc2lvbi5leHRlbmRQYXJhbXMoIG1hdGVyaWFsUGFyYW1zLCBtYXRlcmlhbERlZiwgcGFyc2VyICkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFNwZWNpZmljYXRpb246XG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjbWV0YWxsaWMtcm91Z2huZXNzLW1hdGVyaWFsXG5cblx0XHRcdGNvbnN0IG1ldGFsbGljUm91Z2huZXNzID0gbWF0ZXJpYWxEZWYucGJyTWV0YWxsaWNSb3VnaG5lc3MgfHwge307XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLmNvbG9yID0gbmV3IENvbG9yKCAxLjAsIDEuMCwgMS4wICk7XG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5vcGFjaXR5ID0gMS4wO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvciApICkge1xuXG5cdFx0XHRcdGNvbnN0IGFycmF5ID0gbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yO1xuXG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLmNvbG9yLmZyb21BcnJheSggYXJyYXkgKTtcblx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IGFycmF5WyAzIF07XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdtYXAnLCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5tZXRhbG5lc3MgPSBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY0ZhY3RvciAhPT0gdW5kZWZpbmVkID8gbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNGYWN0b3IgOiAxLjA7XG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5yb3VnaG5lc3MgPSBtZXRhbGxpY1JvdWdobmVzcy5yb3VnaG5lc3NGYWN0b3IgIT09IHVuZGVmaW5lZCA/IG1ldGFsbGljUm91Z2huZXNzLnJvdWdobmVzc0ZhY3RvciA6IDEuMDtcblxuXHRcdFx0aWYgKCBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ21ldGFsbmVzc01hcCcsIG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSApICk7XG5cdFx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAncm91Z2huZXNzTWFwJywgbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtYXRlcmlhbFR5cGUgPSB0aGlzLl9pbnZva2VPbmUoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRcdHJldHVybiBleHQuZ2V0TWF0ZXJpYWxUeXBlICYmIGV4dC5nZXRNYXRlcmlhbFR5cGUoIG1hdGVyaWFsSW5kZXggKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIFByb21pc2UuYWxsKCB0aGlzLl9pbnZva2VBbGwoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRcdHJldHVybiBleHQuZXh0ZW5kTWF0ZXJpYWxQYXJhbXMgJiYgZXh0LmV4dGVuZE1hdGVyaWFsUGFyYW1zKCBtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcyApO1xuXG5cdFx0XHR9ICkgKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbERlZi5kb3VibGVTaWRlZCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMuc2lkZSA9IERvdWJsZVNpZGU7XG5cblx0XHR9XG5cblx0XHRjb25zdCBhbHBoYU1vZGUgPSBtYXRlcmlhbERlZi5hbHBoYU1vZGUgfHwgQUxQSEFfTU9ERVMuT1BBUVVFO1xuXG5cdFx0aWYgKCBhbHBoYU1vZGUgPT09IEFMUEhBX01PREVTLkJMRU5EICkge1xuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy50cmFuc3BhcmVudCA9IHRydWU7XG5cblx0XHRcdC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTc3MDZcblx0XHRcdG1hdGVyaWFsUGFyYW1zLmRlcHRoV3JpdGUgPSBmYWxzZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLmZvcm1hdCA9IFJHQkZvcm1hdDtcblx0XHRcdG1hdGVyaWFsUGFyYW1zLnRyYW5zcGFyZW50ID0gZmFsc2U7XG5cblx0XHRcdGlmICggYWxwaGFNb2RlID09PSBBTFBIQV9NT0RFUy5NQVNLICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLmFscGhhVGVzdCA9IG1hdGVyaWFsRGVmLmFscGhhQ3V0b2ZmICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbERlZi5hbHBoYUN1dG9mZiA6IDAuNTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCApIHtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdub3JtYWxNYXAnLCBtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlICkgKTtcblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMiggMSwgMSApO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUuc2NhbGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zdCBzY2FsZSA9IG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUuc2NhbGU7XG5cblx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMubm9ybWFsU2NhbGUuc2V0KCBzY2FsZSwgc2NhbGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCApIHtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdhb01hcCcsIG1hdGVyaWFsRGVmLm9jY2x1c2lvblRleHR1cmUgKSApO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsRGVmLm9jY2x1c2lvblRleHR1cmUuc3RyZW5ndGggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRtYXRlcmlhbFBhcmFtcy5hb01hcEludGVuc2l0eSA9IG1hdGVyaWFsRGVmLm9jY2x1c2lvblRleHR1cmUuc3RyZW5ndGg7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWxEZWYuZW1pc3NpdmVGYWN0b3IgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbFR5cGUgIT09IE1lc2hCYXNpY01hdGVyaWFsICkge1xuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5lbWlzc2l2ZSA9IG5ldyBDb2xvcigpLmZyb21BcnJheSggbWF0ZXJpYWxEZWYuZW1pc3NpdmVGYWN0b3IgKTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWxEZWYuZW1pc3NpdmVUZXh0dXJlICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCApIHtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdlbWlzc2l2ZU1hcCcsIG1hdGVyaWFsRGVmLmVtaXNzaXZlVGV4dHVyZSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKS50aGVuKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGxldCBtYXRlcmlhbDtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbFR5cGUgPT09IEdMVEZNZXNoU3RhbmRhcmRTR01hdGVyaWFsICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsID0gZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1BCUl9TUEVDVUxBUl9HTE9TU0lORVNTIF0uY3JlYXRlTWF0ZXJpYWwoIG1hdGVyaWFsUGFyYW1zICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bWF0ZXJpYWwgPSBuZXcgbWF0ZXJpYWxUeXBlKCBtYXRlcmlhbFBhcmFtcyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWxEZWYubmFtZSApIG1hdGVyaWFsLm5hbWUgPSBtYXRlcmlhbERlZi5uYW1lO1xuXG5cdFx0XHQvLyBiYXNlQ29sb3JUZXh0dXJlLCBlbWlzc2l2ZVRleHR1cmUsIGFuZCBzcGVjdWxhckdsb3NzaW5lc3NUZXh0dXJlIHVzZSBzUkdCIGVuY29kaW5nLlxuXHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgKSBtYXRlcmlhbC5tYXAuZW5jb2RpbmcgPSBzUkdCRW5jb2Rpbmc7XG5cdFx0XHRpZiAoIG1hdGVyaWFsLmVtaXNzaXZlTWFwICkgbWF0ZXJpYWwuZW1pc3NpdmVNYXAuZW5jb2RpbmcgPSBzUkdCRW5jb2Rpbmc7XG5cblx0XHRcdGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoIG1hdGVyaWFsLCBtYXRlcmlhbERlZiApO1xuXG5cdFx0XHRwYXJzZXIuYXNzb2NpYXRpb25zLnNldCggbWF0ZXJpYWwsIHsgbWF0ZXJpYWxzOiBtYXRlcmlhbEluZGV4IH0gKTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbERlZi5leHRlbnNpb25zICkgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKCBleHRlbnNpb25zLCBtYXRlcmlhbCwgbWF0ZXJpYWxEZWYgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGVyaWFsO1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHQvKiogV2hlbiBPYmplY3QzRCBpbnN0YW5jZXMgYXJlIHRhcmdldGVkIGJ5IGFuaW1hdGlvbiwgdGhleSBuZWVkIHVuaXF1ZSBuYW1lcy4gKi9cblx0Y3JlYXRlVW5pcXVlTmFtZSggb3JpZ2luYWxOYW1lICkge1xuXG5cdFx0Y29uc3Qgc2FuaXRpemVkTmFtZSA9IFByb3BlcnR5QmluZGluZy5zYW5pdGl6ZU5vZGVOYW1lKCBvcmlnaW5hbE5hbWUgfHwgJycgKTtcblxuXHRcdGxldCBuYW1lID0gc2FuaXRpemVkTmFtZTtcblxuXHRcdGZvciAoIGxldCBpID0gMTsgdGhpcy5ub2RlTmFtZXNVc2VkWyBuYW1lIF07ICsrIGkgKSB7XG5cblx0XHRcdG5hbWUgPSBzYW5pdGl6ZWROYW1lICsgJ18nICsgaTtcblxuXHRcdH1cblxuXHRcdHRoaXMubm9kZU5hbWVzVXNlZFsgbmFtZSBdID0gdHJ1ZTtcblxuXHRcdHJldHVybiBuYW1lO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNnZW9tZXRyeVxuXHQgKlxuXHQgKiBDcmVhdGVzIEJ1ZmZlckdlb21ldHJpZXMgZnJvbSBwcmltaXRpdmVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PEdMVEYuUHJpbWl0aXZlPn0gcHJpbWl0aXZlc1xuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PEJ1ZmZlckdlb21ldHJ5Pj59XG5cdCAqL1xuXHRsb2FkR2VvbWV0cmllcyggcHJpbWl0aXZlcyApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXM7XG5cdFx0Y29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcblx0XHRjb25zdCBjYWNoZSA9IHRoaXMucHJpbWl0aXZlQ2FjaGU7XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVEcmFjb1ByaW1pdGl2ZSggcHJpbWl0aXZlICkge1xuXG5cdFx0XHRyZXR1cm4gZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTiBdXG5cdFx0XHRcdC5kZWNvZGVQcmltaXRpdmUoIHByaW1pdGl2ZSwgcGFyc2VyIClcblx0XHRcdFx0LnRoZW4oIGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gYWRkUHJpbWl0aXZlQXR0cmlidXRlcyggZ2VvbWV0cnksIHByaW1pdGl2ZSwgcGFyc2VyICk7XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcGVuZGluZyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHByaW1pdGl2ZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHByaW1pdGl2ZSA9IHByaW1pdGl2ZXNbIGkgXTtcblx0XHRcdGNvbnN0IGNhY2hlS2V5ID0gY3JlYXRlUHJpbWl0aXZlS2V5KCBwcmltaXRpdmUgKTtcblxuXHRcdFx0Ly8gU2VlIGlmIHdlJ3ZlIGFscmVhZHkgY3JlYXRlZCB0aGlzIGdlb21ldHJ5XG5cdFx0XHRjb25zdCBjYWNoZWQgPSBjYWNoZVsgY2FjaGVLZXkgXTtcblxuXHRcdFx0aWYgKCBjYWNoZWQgKSB7XG5cblx0XHRcdFx0Ly8gVXNlIHRoZSBjYWNoZWQgZ2VvbWV0cnkgaWYgaXQgZXhpc3RzXG5cdFx0XHRcdHBlbmRpbmcucHVzaCggY2FjaGVkLnByb21pc2UgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRsZXQgZ2VvbWV0cnlQcm9taXNlO1xuXG5cdFx0XHRcdGlmICggcHJpbWl0aXZlLmV4dGVuc2lvbnMgJiYgcHJpbWl0aXZlLmV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT04gXSApIHtcblxuXHRcdFx0XHRcdC8vIFVzZSBEUkFDTyBnZW9tZXRyeSBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRnZW9tZXRyeVByb21pc2UgPSBjcmVhdGVEcmFjb1ByaW1pdGl2ZSggcHJpbWl0aXZlICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZ2VvbWV0cnlcblx0XHRcdFx0XHRnZW9tZXRyeVByb21pc2UgPSBhZGRQcmltaXRpdmVBdHRyaWJ1dGVzKCBuZXcgQnVmZmVyR2VvbWV0cnkoKSwgcHJpbWl0aXZlLCBwYXJzZXIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FjaGUgdGhpcyBnZW9tZXRyeVxuXHRcdFx0XHRjYWNoZVsgY2FjaGVLZXkgXSA9IHsgcHJpbWl0aXZlOiBwcmltaXRpdmUsIHByb21pc2U6IGdlb21ldHJ5UHJvbWlzZSB9O1xuXG5cdFx0XHRcdHBlbmRpbmcucHVzaCggZ2VvbWV0cnlQcm9taXNlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNtZXNoZXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1lc2hJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEdyb3VwfE1lc2h8U2tpbm5lZE1lc2g+fVxuXHQgKi9cblx0bG9hZE1lc2goIG1lc2hJbmRleCApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXM7XG5cdFx0Y29uc3QganNvbiA9IHRoaXMuanNvbjtcblx0XHRjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuXG5cdFx0Y29uc3QgbWVzaERlZiA9IGpzb24ubWVzaGVzWyBtZXNoSW5kZXggXTtcblx0XHRjb25zdCBwcmltaXRpdmVzID0gbWVzaERlZi5wcmltaXRpdmVzO1xuXG5cdFx0Y29uc3QgcGVuZGluZyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHByaW1pdGl2ZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IG1hdGVyaWFsID0gcHJpbWl0aXZlc1sgaSBdLm1hdGVyaWFsID09PSB1bmRlZmluZWRcblx0XHRcdFx0PyBjcmVhdGVEZWZhdWx0TWF0ZXJpYWwoIHRoaXMuY2FjaGUgKVxuXHRcdFx0XHQ6IHRoaXMuZ2V0RGVwZW5kZW5jeSggJ21hdGVyaWFsJywgcHJpbWl0aXZlc1sgaSBdLm1hdGVyaWFsICk7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggbWF0ZXJpYWwgKTtcblxuXHRcdH1cblxuXHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmxvYWRHZW9tZXRyaWVzKCBwcmltaXRpdmVzICkgKTtcblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApLnRoZW4oIGZ1bmN0aW9uICggcmVzdWx0cyApIHtcblxuXHRcdFx0Y29uc3QgbWF0ZXJpYWxzID0gcmVzdWx0cy5zbGljZSggMCwgcmVzdWx0cy5sZW5ndGggLSAxICk7XG5cdFx0XHRjb25zdCBnZW9tZXRyaWVzID0gcmVzdWx0c1sgcmVzdWx0cy5sZW5ndGggLSAxIF07XG5cblx0XHRcdGNvbnN0IG1lc2hlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBnZW9tZXRyeSA9IGdlb21ldHJpZXNbIGkgXTtcblx0XHRcdFx0Y29uc3QgcHJpbWl0aXZlID0gcHJpbWl0aXZlc1sgaSBdO1xuXG5cdFx0XHRcdC8vIDEuIGNyZWF0ZSBNZXNoXG5cblx0XHRcdFx0bGV0IG1lc2g7XG5cblx0XHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSBtYXRlcmlhbHNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVTIHx8XG5cdFx0XHRcdFx0XHRwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX1NUUklQIHx8XG5cdFx0XHRcdFx0XHRwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX0ZBTiB8fFxuXHRcdFx0XHRcdFx0cHJpbWl0aXZlLm1vZGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdC8vIC5pc1NraW5uZWRNZXNoIGlzbid0IGluIGdsVEYgc3BlYy4gU2VlIC5fbWFya0RlZnMoKVxuXHRcdFx0XHRcdG1lc2ggPSBtZXNoRGVmLmlzU2tpbm5lZE1lc2ggPT09IHRydWVcblx0XHRcdFx0XHRcdD8gbmV3IFNraW5uZWRNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKVxuXHRcdFx0XHRcdFx0OiBuZXcgTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lc2guaXNTa2lubmVkTWVzaCA9PT0gdHJ1ZSAmJiAhIG1lc2guZ2VvbWV0cnkuYXR0cmlidXRlcy5za2luV2VpZ2h0Lm5vcm1hbGl6ZWQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHdlIG5vcm1hbGl6ZSBmbG9hdGluZyBwb2ludCBza2luIHdlaWdodCBhcnJheSB0byBmaXggbWFsZm9ybWVkIGFzc2V0cyAoc2VlICMxNTMxOSlcblx0XHRcdFx0XHRcdC8vIGl0J3MgaW1wb3J0YW50IHRvIHNraXAgdGhpcyBmb3Igbm9uLWZsb2F0MzIgZGF0YSBzaW5jZSBub3JtYWxpemVTa2luV2VpZ2h0cyBhc3N1bWVzIG5vbi1ub3JtYWxpemVkIGlucHV0c1xuXHRcdFx0XHRcdFx0bWVzaC5ub3JtYWxpemVTa2luV2VpZ2h0cygpO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX1NUUklQICkge1xuXG5cdFx0XHRcdFx0XHRtZXNoLmdlb21ldHJ5ID0gdG9UcmlhbmdsZXNEcmF3TW9kZSggbWVzaC5nZW9tZXRyeSwgVHJpYW5nbGVTdHJpcERyYXdNb2RlICk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX0ZBTiApIHtcblxuXHRcdFx0XHRcdFx0bWVzaC5nZW9tZXRyeSA9IHRvVHJpYW5nbGVzRHJhd01vZGUoIG1lc2guZ2VvbWV0cnksIFRyaWFuZ2xlRmFuRHJhd01vZGUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLkxJTkVTICkge1xuXG5cdFx0XHRcdFx0bWVzaCA9IG5ldyBMaW5lU2VnbWVudHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuTElORV9TVFJJUCApIHtcblxuXHRcdFx0XHRcdG1lc2ggPSBuZXcgTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggcHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5MSU5FX0xPT1AgKSB7XG5cblx0XHRcdFx0XHRtZXNoID0gbmV3IExpbmVMb29wKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlBPSU5UUyApIHtcblxuXHRcdFx0XHRcdG1lc2ggPSBuZXcgUG9pbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogUHJpbWl0aXZlIG1vZGUgdW5zdXBwb3J0ZWQ6ICcgKyBwcmltaXRpdmUubW9kZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIE9iamVjdC5rZXlzKCBtZXNoLmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcyApLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHR1cGRhdGVNb3JwaFRhcmdldHMoIG1lc2gsIG1lc2hEZWYgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWVzaC5uYW1lID0gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUoIG1lc2hEZWYubmFtZSB8fCAoICdtZXNoXycgKyBtZXNoSW5kZXggKSApO1xuXG5cdFx0XHRcdGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoIG1lc2gsIG1lc2hEZWYgKTtcblxuXHRcdFx0XHRpZiAoIHByaW1pdGl2ZS5leHRlbnNpb25zICkgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKCBleHRlbnNpb25zLCBtZXNoLCBwcmltaXRpdmUgKTtcblxuXHRcdFx0XHRwYXJzZXIuYXNzaWduRmluYWxNYXRlcmlhbCggbWVzaCApO1xuXG5cdFx0XHRcdG1lc2hlcy5wdXNoKCBtZXNoICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG1lc2hlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRwYXJzZXIuYXNzb2NpYXRpb25zLnNldCggbWVzaGVzWyBpIF0sIHtcblx0XHRcdFx0XHRtZXNoZXM6IG1lc2hJbmRleCxcblx0XHRcdFx0XHRwcmltaXRpdmVzOiBpXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1lc2hlcy5sZW5ndGggPT09IDEgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1lc2hlc1sgMCBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGdyb3VwID0gbmV3IEdyb3VwKCk7XG5cblx0XHRcdHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KCBncm91cCwgeyBtZXNoZXM6IG1lc2hJbmRleCB9ICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBtZXNoZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Z3JvdXAuYWRkKCBtZXNoZXNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBncm91cDtcblxuXHRcdH0gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNjYW1lcmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjYW1lcmFJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPFRIUkVFLkNhbWVyYT59XG5cdCAqL1xuXHRsb2FkQ2FtZXJhKCBjYW1lcmFJbmRleCApIHtcblxuXHRcdGxldCBjYW1lcmE7XG5cdFx0Y29uc3QgY2FtZXJhRGVmID0gdGhpcy5qc29uLmNhbWVyYXNbIGNhbWVyYUluZGV4IF07XG5cdFx0Y29uc3QgcGFyYW1zID0gY2FtZXJhRGVmWyBjYW1lcmFEZWYudHlwZSBdO1xuXG5cdFx0aWYgKCAhIHBhcmFtcyApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogTWlzc2luZyBjYW1lcmEgcGFyYW1ldGVycy4nICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoIGNhbWVyYURlZi50eXBlID09PSAncGVyc3BlY3RpdmUnICkge1xuXG5cdFx0XHRjYW1lcmEgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIE1hdGhVdGlscy5yYWRUb0RlZyggcGFyYW1zLnlmb3YgKSwgcGFyYW1zLmFzcGVjdFJhdGlvIHx8IDEsIHBhcmFtcy56bmVhciB8fCAxLCBwYXJhbXMuemZhciB8fCAyZTYgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGNhbWVyYURlZi50eXBlID09PSAnb3J0aG9ncmFwaGljJyApIHtcblxuXHRcdFx0Y2FtZXJhID0gbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSggLSBwYXJhbXMueG1hZywgcGFyYW1zLnhtYWcsIHBhcmFtcy55bWFnLCAtIHBhcmFtcy55bWFnLCBwYXJhbXMuem5lYXIsIHBhcmFtcy56ZmFyICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGNhbWVyYURlZi5uYW1lICkgY2FtZXJhLm5hbWUgPSB0aGlzLmNyZWF0ZVVuaXF1ZU5hbWUoIGNhbWVyYURlZi5uYW1lICk7XG5cblx0XHRhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKCBjYW1lcmEsIGNhbWVyYURlZiApO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSggY2FtZXJhICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjc2tpbnNcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNraW5JbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdD59XG5cdCAqL1xuXHRsb2FkU2tpbiggc2tpbkluZGV4ICkge1xuXG5cdFx0Y29uc3Qgc2tpbkRlZiA9IHRoaXMuanNvbi5za2luc1sgc2tpbkluZGV4IF07XG5cblx0XHRjb25zdCBza2luRW50cnkgPSB7IGpvaW50czogc2tpbkRlZi5qb2ludHMgfTtcblxuXHRcdGlmICggc2tpbkRlZi5pbnZlcnNlQmluZE1hdHJpY2VzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoIHNraW5FbnRyeSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgc2tpbkRlZi5pbnZlcnNlQmluZE1hdHJpY2VzICkudGhlbiggZnVuY3Rpb24gKCBhY2Nlc3NvciApIHtcblxuXHRcdFx0c2tpbkVudHJ5LmludmVyc2VCaW5kTWF0cmljZXMgPSBhY2Nlc3NvcjtcblxuXHRcdFx0cmV0dXJuIHNraW5FbnRyeTtcblxuXHRcdH0gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNhbmltYXRpb25zXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhbmltYXRpb25JbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEFuaW1hdGlvbkNsaXA+fVxuXHQgKi9cblx0bG9hZEFuaW1hdGlvbiggYW5pbWF0aW9uSW5kZXggKSB7XG5cblx0XHRjb25zdCBqc29uID0gdGhpcy5qc29uO1xuXG5cdFx0Y29uc3QgYW5pbWF0aW9uRGVmID0ganNvbi5hbmltYXRpb25zWyBhbmltYXRpb25JbmRleCBdO1xuXG5cdFx0Y29uc3QgcGVuZGluZ05vZGVzID0gW107XG5cdFx0Y29uc3QgcGVuZGluZ0lucHV0QWNjZXNzb3JzID0gW107XG5cdFx0Y29uc3QgcGVuZGluZ091dHB1dEFjY2Vzc29ycyA9IFtdO1xuXHRcdGNvbnN0IHBlbmRpbmdTYW1wbGVycyA9IFtdO1xuXHRcdGNvbnN0IHBlbmRpbmdUYXJnZXRzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gYW5pbWF0aW9uRGVmLmNoYW5uZWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBjaGFubmVsID0gYW5pbWF0aW9uRGVmLmNoYW5uZWxzWyBpIF07XG5cdFx0XHRjb25zdCBzYW1wbGVyID0gYW5pbWF0aW9uRGVmLnNhbXBsZXJzWyBjaGFubmVsLnNhbXBsZXIgXTtcblx0XHRcdGNvbnN0IHRhcmdldCA9IGNoYW5uZWwudGFyZ2V0O1xuXHRcdFx0Y29uc3QgbmFtZSA9IHRhcmdldC5ub2RlICE9PSB1bmRlZmluZWQgPyB0YXJnZXQubm9kZSA6IHRhcmdldC5pZDsgLy8gTk9URTogdGFyZ2V0LmlkIGlzIGRlcHJlY2F0ZWQuXG5cdFx0XHRjb25zdCBpbnB1dCA9IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgPyBhbmltYXRpb25EZWYucGFyYW1ldGVyc1sgc2FtcGxlci5pbnB1dCBdIDogc2FtcGxlci5pbnB1dDtcblx0XHRcdGNvbnN0IG91dHB1dCA9IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgPyBhbmltYXRpb25EZWYucGFyYW1ldGVyc1sgc2FtcGxlci5vdXRwdXQgXSA6IHNhbXBsZXIub3V0cHV0O1xuXG5cdFx0XHRwZW5kaW5nTm9kZXMucHVzaCggdGhpcy5nZXREZXBlbmRlbmN5KCAnbm9kZScsIG5hbWUgKSApO1xuXHRcdFx0cGVuZGluZ0lucHV0QWNjZXNzb3JzLnB1c2goIHRoaXMuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgaW5wdXQgKSApO1xuXHRcdFx0cGVuZGluZ091dHB1dEFjY2Vzc29ycy5wdXNoKCB0aGlzLmdldERlcGVuZGVuY3koICdhY2Nlc3NvcicsIG91dHB1dCApICk7XG5cdFx0XHRwZW5kaW5nU2FtcGxlcnMucHVzaCggc2FtcGxlciApO1xuXHRcdFx0cGVuZGluZ1RhcmdldHMucHVzaCggdGFyZ2V0ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIFtcblxuXHRcdFx0UHJvbWlzZS5hbGwoIHBlbmRpbmdOb2RlcyApLFxuXHRcdFx0UHJvbWlzZS5hbGwoIHBlbmRpbmdJbnB1dEFjY2Vzc29ycyApLFxuXHRcdFx0UHJvbWlzZS5hbGwoIHBlbmRpbmdPdXRwdXRBY2Nlc3NvcnMgKSxcblx0XHRcdFByb21pc2UuYWxsKCBwZW5kaW5nU2FtcGxlcnMgKSxcblx0XHRcdFByb21pc2UuYWxsKCBwZW5kaW5nVGFyZ2V0cyApXG5cblx0XHRdICkudGhlbiggZnVuY3Rpb24gKCBkZXBlbmRlbmNpZXMgKSB7XG5cblx0XHRcdGNvbnN0IG5vZGVzID0gZGVwZW5kZW5jaWVzWyAwIF07XG5cdFx0XHRjb25zdCBpbnB1dEFjY2Vzc29ycyA9IGRlcGVuZGVuY2llc1sgMSBdO1xuXHRcdFx0Y29uc3Qgb3V0cHV0QWNjZXNzb3JzID0gZGVwZW5kZW5jaWVzWyAyIF07XG5cdFx0XHRjb25zdCBzYW1wbGVycyA9IGRlcGVuZGVuY2llc1sgMyBdO1xuXHRcdFx0Y29uc3QgdGFyZ2V0cyA9IGRlcGVuZGVuY2llc1sgNCBdO1xuXG5cdFx0XHRjb25zdCB0cmFja3MgPSBbXTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IG5vZGUgPSBub2Rlc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBpbnB1dEFjY2Vzc29yID0gaW5wdXRBY2Nlc3NvcnNbIGkgXTtcblx0XHRcdFx0Y29uc3Qgb3V0cHV0QWNjZXNzb3IgPSBvdXRwdXRBY2Nlc3NvcnNbIGkgXTtcblx0XHRcdFx0Y29uc3Qgc2FtcGxlciA9IHNhbXBsZXJzWyBpIF07XG5cdFx0XHRcdGNvbnN0IHRhcmdldCA9IHRhcmdldHNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIG5vZGUgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdG5vZGUudXBkYXRlTWF0cml4KCk7XG5cdFx0XHRcdG5vZGUubWF0cml4QXV0b1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0bGV0IFR5cGVkS2V5ZnJhbWVUcmFjaztcblxuXHRcdFx0XHRzd2l0Y2ggKCBQQVRIX1BST1BFUlRJRVNbIHRhcmdldC5wYXRoIF0gKSB7XG5cblx0XHRcdFx0XHRjYXNlIFBBVEhfUFJPUEVSVElFUy53ZWlnaHRzOlxuXG5cdFx0XHRcdFx0XHRUeXBlZEtleWZyYW1lVHJhY2sgPSBOdW1iZXJLZXlmcmFtZVRyYWNrO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFBBVEhfUFJPUEVSVElFUy5yb3RhdGlvbjpcblxuXHRcdFx0XHRcdFx0VHlwZWRLZXlmcmFtZVRyYWNrID0gUXVhdGVybmlvbktleWZyYW1lVHJhY2s7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgUEFUSF9QUk9QRVJUSUVTLnBvc2l0aW9uOlxuXHRcdFx0XHRcdGNhc2UgUEFUSF9QUk9QRVJUSUVTLnNjYWxlOlxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRcdFR5cGVkS2V5ZnJhbWVUcmFjayA9IFZlY3RvcktleWZyYW1lVHJhY2s7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgdGFyZ2V0TmFtZSA9IG5vZGUubmFtZSA/IG5vZGUubmFtZSA6IG5vZGUudXVpZDtcblxuXHRcdFx0XHRjb25zdCBpbnRlcnBvbGF0aW9uID0gc2FtcGxlci5pbnRlcnBvbGF0aW9uICE9PSB1bmRlZmluZWQgPyBJTlRFUlBPTEFUSU9OWyBzYW1wbGVyLmludGVycG9sYXRpb24gXSA6IEludGVycG9sYXRlTGluZWFyO1xuXG5cdFx0XHRcdGNvbnN0IHRhcmdldE5hbWVzID0gW107XG5cblx0XHRcdFx0aWYgKCBQQVRIX1BST1BFUlRJRVNbIHRhcmdldC5wYXRoIF0gPT09IFBBVEhfUFJPUEVSVElFUy53ZWlnaHRzICkge1xuXG5cdFx0XHRcdFx0bm9kZS50cmF2ZXJzZSggZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyApIHtcblxuXHRcdFx0XHRcdFx0XHR0YXJnZXROYW1lcy5wdXNoKCBvYmplY3QubmFtZSA/IG9iamVjdC5uYW1lIDogb2JqZWN0LnV1aWQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0YXJnZXROYW1lcy5wdXNoKCB0YXJnZXROYW1lICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCBvdXRwdXRBcnJheSA9IG91dHB1dEFjY2Vzc29yLmFycmF5O1xuXG5cdFx0XHRcdGlmICggb3V0cHV0QWNjZXNzb3Iubm9ybWFsaXplZCApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHNjYWxlID0gZ2V0Tm9ybWFsaXplZENvbXBvbmVudFNjYWxlKCBvdXRwdXRBcnJheS5jb25zdHJ1Y3RvciApO1xuXHRcdFx0XHRcdGNvbnN0IHNjYWxlZCA9IG5ldyBGbG9hdDMyQXJyYXkoIG91dHB1dEFycmF5Lmxlbmd0aCApO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IG91dHB1dEFycmF5Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRzY2FsZWRbIGogXSA9IG91dHB1dEFycmF5WyBqIF0gKiBzY2FsZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dEFycmF5ID0gc2NhbGVkO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gdGFyZ2V0TmFtZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB0cmFjayA9IG5ldyBUeXBlZEtleWZyYW1lVHJhY2soXG5cdFx0XHRcdFx0XHR0YXJnZXROYW1lc1sgaiBdICsgJy4nICsgUEFUSF9QUk9QRVJUSUVTWyB0YXJnZXQucGF0aCBdLFxuXHRcdFx0XHRcdFx0aW5wdXRBY2Nlc3Nvci5hcnJheSxcblx0XHRcdFx0XHRcdG91dHB1dEFycmF5LFxuXHRcdFx0XHRcdFx0aW50ZXJwb2xhdGlvblxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHQvLyBPdmVycmlkZSBpbnRlcnBvbGF0aW9uIHdpdGggY3VzdG9tIGZhY3RvcnkgbWV0aG9kLlxuXHRcdFx0XHRcdGlmICggc2FtcGxlci5pbnRlcnBvbGF0aW9uID09PSAnQ1VCSUNTUExJTkUnICkge1xuXG5cdFx0XHRcdFx0XHR0cmFjay5jcmVhdGVJbnRlcnBvbGFudCA9IGZ1bmN0aW9uIEludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSggcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgQ1VCSUNTUExJTkUga2V5ZnJhbWUgaW4gZ2xURiBoYXMgdGhyZWUgb3V0cHV0IHZhbHVlcyBmb3IgZWFjaCBpbnB1dCB2YWx1ZSxcblx0XHRcdFx0XHRcdFx0Ly8gcmVwcmVzZW50aW5nIGluVGFuZ2VudCwgc3BsaW5lVmVydGV4LCBhbmQgb3V0VGFuZ2VudC4gQXMgYSByZXN1bHQsIHRyYWNrLmdldFZhbHVlU2l6ZSgpXG5cdFx0XHRcdFx0XHRcdC8vIG11c3QgYmUgZGl2aWRlZCBieSB0aHJlZSB0byBnZXQgdGhlIGludGVycG9sYW50J3Mgc2FtcGxlU2l6ZSBhcmd1bWVudC5cblxuXHRcdFx0XHRcdFx0XHRjb25zdCBpbnRlcnBvbGFudFR5cGUgPSAoIHRoaXMgaW5zdGFuY2VvZiBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayApID8gR0xURkN1YmljU3BsaW5lUXVhdGVybmlvbkludGVycG9sYW50IDogR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQ7XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBpbnRlcnBvbGFudFR5cGUoIHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpIC8gMywgcmVzdWx0ICk7XG5cblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdC8vIE1hcmsgYXMgQ1VCSUNTUExJTkUuIGB0cmFjay5nZXRJbnRlcnBvbGF0aW9uKClgIGRvZXNuJ3Qgc3VwcG9ydCBjdXN0b20gaW50ZXJwb2xhbnRzLlxuXHRcdFx0XHRcdFx0dHJhY2suY3JlYXRlSW50ZXJwb2xhbnQuaXNJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dHJhY2tzLnB1c2goIHRyYWNrICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG5hbWUgPSBhbmltYXRpb25EZWYubmFtZSA/IGFuaW1hdGlvbkRlZi5uYW1lIDogJ2FuaW1hdGlvbl8nICsgYW5pbWF0aW9uSW5kZXg7XG5cblx0XHRcdHJldHVybiBuZXcgQW5pbWF0aW9uQ2xpcCggbmFtZSwgdW5kZWZpbmVkLCB0cmFja3MgKTtcblxuXHRcdH0gKTtcblxuXHR9XG5cblx0Y3JlYXRlTm9kZU1lc2goIG5vZGVJbmRleCApIHtcblxuXHRcdGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG5cdFx0Y29uc3QgcGFyc2VyID0gdGhpcztcblx0XHRjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRpZiAoIG5vZGVEZWYubWVzaCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIG51bGw7XG5cblx0XHRyZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koICdtZXNoJywgbm9kZURlZi5tZXNoICkudGhlbiggZnVuY3Rpb24gKCBtZXNoICkge1xuXG5cdFx0XHRjb25zdCBub2RlID0gcGFyc2VyLl9nZXROb2RlUmVmKCBwYXJzZXIubWVzaENhY2hlLCBub2RlRGVmLm1lc2gsIG1lc2ggKTtcblxuXHRcdFx0Ly8gaWYgd2VpZ2h0cyBhcmUgcHJvdmlkZWQgb24gdGhlIG5vZGUsIG92ZXJyaWRlIHdlaWdodHMgb24gdGhlIG1lc2guXG5cdFx0XHRpZiAoIG5vZGVEZWYud2VpZ2h0cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG5vZGUudHJhdmVyc2UoIGZ1bmN0aW9uICggbyApIHtcblxuXHRcdFx0XHRcdGlmICggISBvLmlzTWVzaCApIHJldHVybjtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBub2RlRGVmLndlaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdG8ubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF0gPSBub2RlRGVmLndlaWdodHNbIGkgXTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5vZGU7XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjbm9kZXMtYW5kLWhpZXJhcmNoeVxuXHQgKiBAcGFyYW0ge251bWJlcn0gbm9kZUluZGV4XG5cdCAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0M0Q+fVxuXHQgKi9cblx0bG9hZE5vZGUoIG5vZGVJbmRleCApIHtcblxuXHRcdGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG5cdFx0Y29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzO1xuXG5cdFx0Y29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0Ly8gcmVzZXJ2ZSBub2RlJ3MgbmFtZSBiZWZvcmUgaXRzIGRlcGVuZGVuY2llcywgc28gdGhlIHJvb3QgaGFzIHRoZSBpbnRlbmRlZCBuYW1lLlxuXHRcdGNvbnN0IG5vZGVOYW1lID0gbm9kZURlZi5uYW1lID8gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUoIG5vZGVEZWYubmFtZSApIDogJyc7XG5cblx0XHRyZXR1cm4gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnN0IHBlbmRpbmcgPSBbXTtcblxuXHRcdFx0Y29uc3QgbWVzaFByb21pc2UgPSBwYXJzZXIuX2ludm9rZU9uZSggZnVuY3Rpb24gKCBleHQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGV4dC5jcmVhdGVOb2RlTWVzaCAmJiBleHQuY3JlYXRlTm9kZU1lc2goIG5vZGVJbmRleCApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHRcdGlmICggbWVzaFByb21pc2UgKSB7XG5cblx0XHRcdFx0cGVuZGluZy5wdXNoKCBtZXNoUHJvbWlzZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbm9kZURlZi5jYW1lcmEgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5nZXREZXBlbmRlbmN5KCAnY2FtZXJhJywgbm9kZURlZi5jYW1lcmEgKS50aGVuKCBmdW5jdGlvbiAoIGNhbWVyYSApIHtcblxuXHRcdFx0XHRcdHJldHVybiBwYXJzZXIuX2dldE5vZGVSZWYoIHBhcnNlci5jYW1lcmFDYWNoZSwgbm9kZURlZi5jYW1lcmEsIGNhbWVyYSApO1xuXG5cdFx0XHRcdH0gKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHBhcnNlci5faW52b2tlQWxsKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0XHRyZXR1cm4gZXh0LmNyZWF0ZU5vZGVBdHRhY2htZW50ICYmIGV4dC5jcmVhdGVOb2RlQXR0YWNobWVudCggbm9kZUluZGV4ICk7XG5cblx0XHRcdH0gKS5mb3JFYWNoKCBmdW5jdGlvbiAoIHByb21pc2UgKSB7XG5cblx0XHRcdFx0cGVuZGluZy5wdXNoKCBwcm9taXNlICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nICk7XG5cblx0XHR9KCkgKS50aGVuKCBmdW5jdGlvbiAoIG9iamVjdHMgKSB7XG5cblx0XHRcdGxldCBub2RlO1xuXG5cdFx0XHQvLyAuaXNCb25lIGlzbid0IGluIGdsVEYgc3BlYy4gU2VlIC5fbWFya0RlZnNcblx0XHRcdGlmICggbm9kZURlZi5pc0JvbmUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0bm9kZSA9IG5ldyBCb25lKCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdHMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0XHRub2RlID0gbmV3IEdyb3VwKCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdHMubGVuZ3RoID09PSAxICkge1xuXG5cdFx0XHRcdG5vZGUgPSBvYmplY3RzWyAwIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bm9kZSA9IG5ldyBPYmplY3QzRCgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbm9kZSAhPT0gb2JqZWN0c1sgMCBdICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBvYmplY3RzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0bm9kZS5hZGQoIG9iamVjdHNbIGkgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5vZGVEZWYubmFtZSApIHtcblxuXHRcdFx0XHRub2RlLnVzZXJEYXRhLm5hbWUgPSBub2RlRGVmLm5hbWU7XG5cdFx0XHRcdG5vZGUubmFtZSA9IG5vZGVOYW1lO1xuXG5cdFx0XHR9XG5cblx0XHRcdGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoIG5vZGUsIG5vZGVEZWYgKTtcblxuXHRcdFx0aWYgKCBub2RlRGVmLmV4dGVuc2lvbnMgKSBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoIGV4dGVuc2lvbnMsIG5vZGUsIG5vZGVEZWYgKTtcblxuXHRcdFx0aWYgKCBub2RlRGVmLm1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnN0IG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0XHRcdG1hdHJpeC5mcm9tQXJyYXkoIG5vZGVEZWYubWF0cml4ICk7XG5cdFx0XHRcdG5vZGUuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIG5vZGVEZWYudHJhbnNsYXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG5vZGUucG9zaXRpb24uZnJvbUFycmF5KCBub2RlRGVmLnRyYW5zbGF0aW9uICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbm9kZURlZi5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bm9kZS5xdWF0ZXJuaW9uLmZyb21BcnJheSggbm9kZURlZi5yb3RhdGlvbiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5vZGVEZWYuc2NhbGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG5vZGUuc2NhbGUuZnJvbUFycmF5KCBub2RlRGVmLnNjYWxlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggISBwYXJzZXIuYXNzb2NpYXRpb25zLmhhcyggbm9kZSApICkge1xuXG5cdFx0XHRcdHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KCBub2RlLCB7fSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHBhcnNlci5hc3NvY2lhdGlvbnMuZ2V0KCBub2RlICkubm9kZXMgPSBub2RlSW5kZXg7XG5cblx0XHRcdHJldHVybiBub2RlO1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI3NjZW5lc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gc2NlbmVJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEdyb3VwPn1cblx0ICovXG5cdGxvYWRTY2VuZSggc2NlbmVJbmRleCApIHtcblxuXHRcdGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG5cdFx0Y29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcblx0XHRjb25zdCBzY2VuZURlZiA9IHRoaXMuanNvbi5zY2VuZXNbIHNjZW5lSW5kZXggXTtcblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzO1xuXG5cdFx0Ly8gTG9hZGVyIHJldHVybnMgR3JvdXAsIG5vdCBTY2VuZS5cblx0XHQvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzE4MzQyI2lzc3VlY29tbWVudC01Nzg5ODExNzJcblx0XHRjb25zdCBzY2VuZSA9IG5ldyBHcm91cCgpO1xuXHRcdGlmICggc2NlbmVEZWYubmFtZSApIHNjZW5lLm5hbWUgPSBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZSggc2NlbmVEZWYubmFtZSApO1xuXG5cdFx0YXNzaWduRXh0cmFzVG9Vc2VyRGF0YSggc2NlbmUsIHNjZW5lRGVmICk7XG5cblx0XHRpZiAoIHNjZW5lRGVmLmV4dGVuc2lvbnMgKSBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoIGV4dGVuc2lvbnMsIHNjZW5lLCBzY2VuZURlZiApO1xuXG5cdFx0Y29uc3Qgbm9kZUlkcyA9IHNjZW5lRGVmLm5vZGVzIHx8IFtdO1xuXG5cdFx0Y29uc3QgcGVuZGluZyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG5vZGVJZHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggYnVpbGROb2RlSGllcmFyY2h5KCBub2RlSWRzWyBpIF0sIHNjZW5lLCBqc29uLCBwYXJzZXIgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nICkudGhlbiggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQvLyBSZW1vdmVzIGRhbmdsaW5nIGFzc29jaWF0aW9ucywgYXNzb2NpYXRpb25zIHRoYXQgcmVmZXJlbmNlIGEgbm9kZSB0aGF0XG5cdFx0XHQvLyBkaWRuJ3QgbWFrZSBpdCBpbnRvIHRoZSBzY2VuZS5cblx0XHRcdGNvbnN0IHJlZHVjZUFzc29jaWF0aW9ucyA9ICggbm9kZSApID0+IHtcblxuXHRcdFx0XHRjb25zdCByZWR1Y2VkQXNzb2NpYXRpb25zID0gbmV3IE1hcCgpO1xuXG5cdFx0XHRcdGZvciAoIGNvbnN0IFsga2V5LCB2YWx1ZSBdIG9mIHBhcnNlci5hc3NvY2lhdGlvbnMgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGtleSBpbnN0YW5jZW9mIE1hdGVyaWFsIHx8IGtleSBpbnN0YW5jZW9mIFRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHRcdHJlZHVjZWRBc3NvY2lhdGlvbnMuc2V0KCBrZXksIHZhbHVlICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG5vZGUudHJhdmVyc2UoICggbm9kZSApID0+IHtcblxuXHRcdFx0XHRcdGNvbnN0IG1hcHBpbmdzID0gcGFyc2VyLmFzc29jaWF0aW9ucy5nZXQoIG5vZGUgKTtcblxuXHRcdFx0XHRcdGlmICggbWFwcGluZ3MgIT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0cmVkdWNlZEFzc29jaWF0aW9ucy5zZXQoIG5vZGUsIG1hcHBpbmdzICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdHJldHVybiByZWR1Y2VkQXNzb2NpYXRpb25zO1xuXG5cdFx0XHR9O1xuXG5cdFx0XHRwYXJzZXIuYXNzb2NpYXRpb25zID0gcmVkdWNlQXNzb2NpYXRpb25zKCBzY2VuZSApO1xuXG5cdFx0XHRyZXR1cm4gc2NlbmU7XG5cblx0XHR9ICk7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIGJ1aWxkTm9kZUhpZXJhcmNoeSggbm9kZUlkLCBwYXJlbnRPYmplY3QsIGpzb24sIHBhcnNlciApIHtcblxuXHRjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1sgbm9kZUlkIF07XG5cblx0cmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KCAnbm9kZScsIG5vZGVJZCApLnRoZW4oIGZ1bmN0aW9uICggbm9kZSApIHtcblxuXHRcdGlmICggbm9kZURlZi5za2luID09PSB1bmRlZmluZWQgKSByZXR1cm4gbm9kZTtcblxuXHRcdC8vIGJ1aWxkIHNrZWxldG9uIGhlcmUgYXMgd2VsbFxuXG5cdFx0bGV0IHNraW5FbnRyeTtcblxuXHRcdHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ3NraW4nLCBub2RlRGVmLnNraW4gKS50aGVuKCBmdW5jdGlvbiAoIHNraW4gKSB7XG5cblx0XHRcdHNraW5FbnRyeSA9IHNraW47XG5cblx0XHRcdGNvbnN0IHBlbmRpbmdKb2ludHMgPSBbXTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHNraW5FbnRyeS5qb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0cGVuZGluZ0pvaW50cy5wdXNoKCBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ25vZGUnLCBza2luRW50cnkuam9pbnRzWyBpIF0gKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZ0pvaW50cyApO1xuXG5cdFx0fSApLnRoZW4oIGZ1bmN0aW9uICggam9pbnROb2RlcyApIHtcblxuXHRcdFx0bm9kZS50cmF2ZXJzZSggZnVuY3Rpb24gKCBtZXNoICkge1xuXG5cdFx0XHRcdGlmICggISBtZXNoLmlzTWVzaCApIHJldHVybjtcblxuXHRcdFx0XHRjb25zdCBib25lcyA9IFtdO1xuXHRcdFx0XHRjb25zdCBib25lSW52ZXJzZXMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gam9pbnROb2Rlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGpvaW50Tm9kZSA9IGpvaW50Tm9kZXNbIGogXTtcblxuXHRcdFx0XHRcdGlmICggam9pbnROb2RlICkge1xuXG5cdFx0XHRcdFx0XHRib25lcy5wdXNoKCBqb2ludE5vZGUgKTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgbWF0ID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBza2luRW50cnkuaW52ZXJzZUJpbmRNYXRyaWNlcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdG1hdC5mcm9tQXJyYXkoIHNraW5FbnRyeS5pbnZlcnNlQmluZE1hdHJpY2VzLmFycmF5LCBqICogMTYgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRib25lSW52ZXJzZXMucHVzaCggbWF0ICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HTFRGTG9hZGVyOiBKb2ludCBcIiVzXCIgY291bGQgbm90IGJlIGZvdW5kLicsIHNraW5FbnRyeS5qb2ludHNbIGogXSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtZXNoLmJpbmQoIG5ldyBTa2VsZXRvbiggYm9uZXMsIGJvbmVJbnZlcnNlcyApLCBtZXNoLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cmV0dXJuIG5vZGU7XG5cblx0XHR9ICk7XG5cblx0fSApLnRoZW4oIGZ1bmN0aW9uICggbm9kZSApIHtcblxuXHRcdC8vIGJ1aWxkIG5vZGUgaGllcmFjaHlcblxuXHRcdHBhcmVudE9iamVjdC5hZGQoIG5vZGUgKTtcblxuXHRcdGNvbnN0IHBlbmRpbmcgPSBbXTtcblxuXHRcdGlmICggbm9kZURlZi5jaGlsZHJlbiApIHtcblxuXHRcdFx0Y29uc3QgY2hpbGRyZW4gPSBub2RlRGVmLmNoaWxkcmVuO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgY2hpbGQgPSBjaGlsZHJlblsgaSBdO1xuXHRcdFx0XHRwZW5kaW5nLnB1c2goIGJ1aWxkTm9kZUhpZXJhcmNoeSggY2hpbGQsIG5vZGUsIGpzb24sIHBhcnNlciApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApO1xuXG5cdH0gKTtcblxufVxuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyR2VvbWV0cnl9IGdlb21ldHJ5XG4gKiBAcGFyYW0ge0dMVEYuUHJpbWl0aXZlfSBwcmltaXRpdmVEZWZcbiAqIEBwYXJhbSB7R0xURlBhcnNlcn0gcGFyc2VyXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVCb3VuZHMoIGdlb21ldHJ5LCBwcmltaXRpdmVEZWYsIHBhcnNlciApIHtcblxuXHRjb25zdCBhdHRyaWJ1dGVzID0gcHJpbWl0aXZlRGVmLmF0dHJpYnV0ZXM7XG5cblx0Y29uc3QgYm94ID0gbmV3IEJveDMoKTtcblxuXHRpZiAoIGF0dHJpYnV0ZXMuUE9TSVRJT04gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGNvbnN0IGFjY2Vzc29yID0gcGFyc2VyLmpzb24uYWNjZXNzb3JzWyBhdHRyaWJ1dGVzLlBPU0lUSU9OIF07XG5cblx0XHRjb25zdCBtaW4gPSBhY2Nlc3Nvci5taW47XG5cdFx0Y29uc3QgbWF4ID0gYWNjZXNzb3IubWF4O1xuXG5cdFx0Ly8gZ2xURiByZXF1aXJlcyAnbWluJyBhbmQgJ21heCcsIGJ1dCBWUk0gKHdoaWNoIGV4dGVuZHMgZ2xURikgY3VycmVudGx5IGlnbm9yZXMgdGhhdCByZXF1aXJlbWVudC5cblxuXHRcdGlmICggbWluICE9PSB1bmRlZmluZWQgJiYgbWF4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGJveC5zZXQoXG5cdFx0XHRcdG5ldyBWZWN0b3IzKCBtaW5bIDAgXSwgbWluWyAxIF0sIG1pblsgMiBdICksXG5cdFx0XHRcdG5ldyBWZWN0b3IzKCBtYXhbIDAgXSwgbWF4WyAxIF0sIG1heFsgMiBdIClcblx0XHRcdCk7XG5cblx0XHRcdGlmICggYWNjZXNzb3Iubm9ybWFsaXplZCApIHtcblxuXHRcdFx0XHRjb25zdCBib3hTY2FsZSA9IGdldE5vcm1hbGl6ZWRDb21wb25lbnRTY2FsZSggV0VCR0xfQ09NUE9ORU5UX1RZUEVTWyBhY2Nlc3Nvci5jb21wb25lbnRUeXBlIF0gKTtcblx0XHRcdFx0Ym94Lm1pbi5tdWx0aXBseVNjYWxhciggYm94U2NhbGUgKTtcblx0XHRcdFx0Ym94Lm1heC5tdWx0aXBseVNjYWxhciggYm94U2NhbGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogTWlzc2luZyBtaW4vbWF4IHByb3BlcnRpZXMgZm9yIGFjY2Vzc29yIFBPU0lUSU9OLicgKTtcblxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHRyZXR1cm47XG5cblx0fVxuXG5cdGNvbnN0IHRhcmdldHMgPSBwcmltaXRpdmVEZWYudGFyZ2V0cztcblxuXHRpZiAoIHRhcmdldHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGNvbnN0IG1heERpc3BsYWNlbWVudCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCB0YXJnZXQgPSB0YXJnZXRzWyBpIF07XG5cblx0XHRcdGlmICggdGFyZ2V0LlBPU0lUSU9OICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc3QgYWNjZXNzb3IgPSBwYXJzZXIuanNvbi5hY2Nlc3NvcnNbIHRhcmdldC5QT1NJVElPTiBdO1xuXHRcdFx0XHRjb25zdCBtaW4gPSBhY2Nlc3Nvci5taW47XG5cdFx0XHRcdGNvbnN0IG1heCA9IGFjY2Vzc29yLm1heDtcblxuXHRcdFx0XHQvLyBnbFRGIHJlcXVpcmVzICdtaW4nIGFuZCAnbWF4JywgYnV0IFZSTSAod2hpY2ggZXh0ZW5kcyBnbFRGKSBjdXJyZW50bHkgaWdub3JlcyB0aGF0IHJlcXVpcmVtZW50LlxuXG5cdFx0XHRcdGlmICggbWluICE9PSB1bmRlZmluZWQgJiYgbWF4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGdldCBtYXggb2YgYWJzb2x1dGUgY29tcG9uZW50cyBiZWNhdXNlIHRhcmdldCB3ZWlnaHQgaXMgWy0xLDFdXG5cdFx0XHRcdFx0dmVjdG9yLnNldFgoIE1hdGgubWF4KCBNYXRoLmFicyggbWluWyAwIF0gKSwgTWF0aC5hYnMoIG1heFsgMCBdICkgKSApO1xuXHRcdFx0XHRcdHZlY3Rvci5zZXRZKCBNYXRoLm1heCggTWF0aC5hYnMoIG1pblsgMSBdICksIE1hdGguYWJzKCBtYXhbIDEgXSApICkgKTtcblx0XHRcdFx0XHR2ZWN0b3Iuc2V0WiggTWF0aC5tYXgoIE1hdGguYWJzKCBtaW5bIDIgXSApLCBNYXRoLmFicyggbWF4WyAyIF0gKSApICk7XG5cblxuXHRcdFx0XHRcdGlmICggYWNjZXNzb3Iubm9ybWFsaXplZCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYm94U2NhbGUgPSBnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUoIFdFQkdMX0NPTVBPTkVOVF9UWVBFU1sgYWNjZXNzb3IuY29tcG9uZW50VHlwZSBdICk7XG5cdFx0XHRcdFx0XHR2ZWN0b3IubXVsdGlwbHlTY2FsYXIoIGJveFNjYWxlICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOb3RlOiB0aGlzIGFzc3VtZXMgdGhhdCB0aGUgc3VtIG9mIGFsbCB3ZWlnaHRzIGlzIGF0IG1vc3QgMS4gVGhpcyBpc24ndCBxdWl0ZSBjb3JyZWN0IC0gaXQncyBtb3JlIGNvbnNlcnZhdGl2ZVxuXHRcdFx0XHRcdC8vIHRvIGFzc3VtZSB0aGF0IGVhY2ggdGFyZ2V0IGNhbiBoYXZlIGEgbWF4IHdlaWdodCBvZiAxLiBIb3dldmVyLCBmb3Igc29tZSB1c2UgY2FzZXMgLSBub3RhYmx5LCB3aGVuIG1vcnBoIHRhcmdldHNcblx0XHRcdFx0XHQvLyBhcmUgdXNlZCB0byBpbXBsZW1lbnQga2V5LWZyYW1lIGFuaW1hdGlvbnMgYW5kIGFzIHN1Y2ggb25seSB0d28gYXJlIGFjdGl2ZSBhdCBhIHRpbWUgLSB0aGlzIHJlc3VsdHMgaW4gdmVyeSBsYXJnZVxuXHRcdFx0XHRcdC8vIGJveGVzLiBTbyBmb3Igbm93IHdlIG1ha2UgYSBib3ggdGhhdCdzIHNvbWV0aW1lcyBhIHRvdWNoIHRvbyBzbWFsbCBidXQgaXMgaG9wZWZ1bGx5IG1vc3RseSBvZiByZWFzb25hYmxlIHNpemUuXG5cdFx0XHRcdFx0bWF4RGlzcGxhY2VtZW50Lm1heCggdmVjdG9yICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdMVEZMb2FkZXI6IE1pc3NpbmcgbWluL21heCBwcm9wZXJ0aWVzIGZvciBhY2Nlc3NvciBQT1NJVElPTi4nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBBcyBwZXIgY29tbWVudCBhYm92ZSB0aGlzIGJveCBpc24ndCBjb25zZXJ2YXRpdmUsIGJ1dCBoYXMgYSByZWFzb25hYmxlIHNpemUgZm9yIGEgdmVyeSBsYXJnZSBudW1iZXIgb2YgbW9ycGggdGFyZ2V0cy5cblx0XHRib3guZXhwYW5kQnlWZWN0b3IoIG1heERpc3BsYWNlbWVudCApO1xuXG5cdH1cblxuXHRnZW9tZXRyeS5ib3VuZGluZ0JveCA9IGJveDtcblxuXHRjb25zdCBzcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG5cblx0Ym94LmdldENlbnRlciggc3BoZXJlLmNlbnRlciApO1xuXHRzcGhlcmUucmFkaXVzID0gYm94Lm1pbi5kaXN0YW5jZVRvKCBib3gubWF4ICkgLyAyO1xuXG5cdGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID0gc3BoZXJlO1xuXG59XG5cbi8qKlxuICogQHBhcmFtIHtCdWZmZXJHZW9tZXRyeX0gZ2VvbWV0cnlcbiAqIEBwYXJhbSB7R0xURi5QcmltaXRpdmV9IHByaW1pdGl2ZURlZlxuICogQHBhcmFtIHtHTFRGUGFyc2VyfSBwYXJzZXJcbiAqIEByZXR1cm4ge1Byb21pc2U8QnVmZmVyR2VvbWV0cnk+fVxuICovXG5mdW5jdGlvbiBhZGRQcmltaXRpdmVBdHRyaWJ1dGVzKCBnZW9tZXRyeSwgcHJpbWl0aXZlRGVmLCBwYXJzZXIgKSB7XG5cblx0Y29uc3QgYXR0cmlidXRlcyA9IHByaW1pdGl2ZURlZi5hdHRyaWJ1dGVzO1xuXG5cdGNvbnN0IHBlbmRpbmcgPSBbXTtcblxuXHRmdW5jdGlvbiBhc3NpZ25BdHRyaWJ1dGVBY2Nlc3NvciggYWNjZXNzb3JJbmRleCwgYXR0cmlidXRlTmFtZSApIHtcblxuXHRcdHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgYWNjZXNzb3JJbmRleCApXG5cdFx0XHQudGhlbiggZnVuY3Rpb24gKCBhY2Nlc3NvciApIHtcblxuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoIGF0dHJpYnV0ZU5hbWUsIGFjY2Vzc29yICk7XG5cblx0XHRcdH0gKTtcblxuXHR9XG5cblx0Zm9yICggY29uc3QgZ2x0ZkF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcyApIHtcblxuXHRcdGNvbnN0IHRocmVlQXR0cmlidXRlTmFtZSA9IEFUVFJJQlVURVNbIGdsdGZBdHRyaWJ1dGVOYW1lIF0gfHwgZ2x0ZkF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdC8vIFNraXAgYXR0cmlidXRlcyBhbHJlYWR5IHByb3ZpZGVkIGJ5IGUuZy4gRHJhY28gZXh0ZW5zaW9uLlxuXHRcdGlmICggdGhyZWVBdHRyaWJ1dGVOYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMgKSBjb250aW51ZTtcblxuXHRcdHBlbmRpbmcucHVzaCggYXNzaWduQXR0cmlidXRlQWNjZXNzb3IoIGF0dHJpYnV0ZXNbIGdsdGZBdHRyaWJ1dGVOYW1lIF0sIHRocmVlQXR0cmlidXRlTmFtZSApICk7XG5cblx0fVxuXG5cdGlmICggcHJpbWl0aXZlRGVmLmluZGljZXMgIT09IHVuZGVmaW5lZCAmJiAhIGdlb21ldHJ5LmluZGV4ICkge1xuXG5cdFx0Y29uc3QgYWNjZXNzb3IgPSBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgcHJpbWl0aXZlRGVmLmluZGljZXMgKS50aGVuKCBmdW5jdGlvbiAoIGFjY2Vzc29yICkge1xuXG5cdFx0XHRnZW9tZXRyeS5zZXRJbmRleCggYWNjZXNzb3IgKTtcblxuXHRcdH0gKTtcblxuXHRcdHBlbmRpbmcucHVzaCggYWNjZXNzb3IgKTtcblxuXHR9XG5cblx0YXNzaWduRXh0cmFzVG9Vc2VyRGF0YSggZ2VvbWV0cnksIHByaW1pdGl2ZURlZiApO1xuXG5cdGNvbXB1dGVCb3VuZHMoIGdlb21ldHJ5LCBwcmltaXRpdmVEZWYsIHBhcnNlciApO1xuXG5cdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApLnRoZW4oIGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBwcmltaXRpdmVEZWYudGFyZ2V0cyAhPT0gdW5kZWZpbmVkXG5cdFx0XHQ/IGFkZE1vcnBoVGFyZ2V0cyggZ2VvbWV0cnksIHByaW1pdGl2ZURlZi50YXJnZXRzLCBwYXJzZXIgKVxuXHRcdFx0OiBnZW9tZXRyeTtcblxuXHR9ICk7XG5cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlckdlb21ldHJ5fSBnZW9tZXRyeVxuICogQHBhcmFtIHtOdW1iZXJ9IGRyYXdNb2RlXG4gKiBAcmV0dXJuIHtCdWZmZXJHZW9tZXRyeX1cbiAqL1xuZnVuY3Rpb24gdG9UcmlhbmdsZXNEcmF3TW9kZSggZ2VvbWV0cnksIGRyYXdNb2RlICkge1xuXG5cdGxldCBpbmRleCA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG5cblx0Ly8gZ2VuZXJhdGUgaW5kZXggaWYgbm90IHByZXNlbnRcblxuXHRpZiAoIGluZGV4ID09PSBudWxsICkge1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXG5cdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblxuXHRcdGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcG9zaXRpb24uY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHRcdGluZGV4ID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogVW5kZWZpbmVkIHBvc2l0aW9uIGF0dHJpYnV0ZS4gUHJvY2Vzc2luZyBub3QgcG9zc2libGUuJyApO1xuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvL1xuXG5cdGNvbnN0IG51bWJlck9mVHJpYW5nbGVzID0gaW5kZXguY291bnQgLSAyO1xuXHRjb25zdCBuZXdJbmRpY2VzID0gW107XG5cblx0aWYgKCBkcmF3TW9kZSA9PT0gVHJpYW5nbGVGYW5EcmF3TW9kZSApIHtcblxuXHRcdC8vIGdsLlRSSUFOR0xFX0ZBTlxuXG5cdFx0Zm9yICggbGV0IGkgPSAxOyBpIDw9IG51bWJlck9mVHJpYW5nbGVzOyBpICsrICkge1xuXG5cdFx0XHRuZXdJbmRpY2VzLnB1c2goIGluZGV4LmdldFgoIDAgKSApO1xuXHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpbmRleC5nZXRYKCBpICkgKTtcblx0XHRcdG5ld0luZGljZXMucHVzaCggaW5kZXguZ2V0WCggaSArIDEgKSApO1xuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBnbC5UUklBTkdMRV9TVFJJUFxuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZUcmlhbmdsZXM7IGkgKysgKSB7XG5cblx0XHRcdGlmICggaSAlIDIgPT09IDAgKSB7XG5cblx0XHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpbmRleC5nZXRYKCBpICkgKTtcblx0XHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpbmRleC5nZXRYKCBpICsgMSApICk7XG5cdFx0XHRcdG5ld0luZGljZXMucHVzaCggaW5kZXguZ2V0WCggaSArIDIgKSApO1xuXG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpbmRleC5nZXRYKCBpICsgMiApICk7XG5cdFx0XHRcdG5ld0luZGljZXMucHVzaCggaW5kZXguZ2V0WCggaSArIDEgKSApO1xuXHRcdFx0XHRuZXdJbmRpY2VzLnB1c2goIGluZGV4LmdldFgoIGkgKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGlmICggKCBuZXdJbmRpY2VzLmxlbmd0aCAvIDMgKSAhPT0gbnVtYmVyT2ZUcmlhbmdsZXMgKSB7XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuR0xURkxvYWRlci50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IFVuYWJsZSB0byBnZW5lcmF0ZSBjb3JyZWN0IGFtb3VudCBvZiB0cmlhbmdsZXMuJyApO1xuXG5cdH1cblxuXHQvLyBidWlsZCBmaW5hbCBnZW9tZXRyeVxuXG5cdGNvbnN0IG5ld0dlb21ldHJ5ID0gZ2VvbWV0cnkuY2xvbmUoKTtcblx0bmV3R2VvbWV0cnkuc2V0SW5kZXgoIG5ld0luZGljZXMgKTtcblxuXHRyZXR1cm4gbmV3R2VvbWV0cnk7XG5cbn1cblxuZXhwb3J0IHsgR0xURkxvYWRlciB9O1xuIiwiY2xhc3MgVlJCdXR0b24ge1xuXG5cdHN0YXRpYyBjcmVhdGVCdXR0b24oIHJlbmRlcmVyLCBvcHRpb25zICkge1xuXG5cdFx0aWYgKCBvcHRpb25zICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVlJCdXR0b246IFRoZSBcIm9wdGlvbnNcIiBwYXJhbWV0ZXIgaGFzIGJlZW4gcmVtb3ZlZC4gUGxlYXNlIHNldCB0aGUgcmVmZXJlbmNlIHNwYWNlIHR5cGUgdmlhIHJlbmRlcmVyLnhyLnNldFJlZmVyZW5jZVNwYWNlVHlwZSgpIGluc3RlYWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2J1dHRvbicgKTtcblxuXHRcdGZ1bmN0aW9uIHNob3dFbnRlclZSKCAvKmRldmljZSovICkge1xuXG5cdFx0XHRsZXQgY3VycmVudFNlc3Npb24gPSBudWxsO1xuXG5cdFx0XHRhc3luYyBmdW5jdGlvbiBvblNlc3Npb25TdGFydGVkKCBzZXNzaW9uICkge1xuXG5cdFx0XHRcdHNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lciggJ2VuZCcsIG9uU2Vzc2lvbkVuZGVkICk7XG5cblx0XHRcdFx0YXdhaXQgcmVuZGVyZXIueHIuc2V0U2Vzc2lvbiggc2Vzc2lvbiApO1xuXHRcdFx0XHRidXR0b24udGV4dENvbnRlbnQgPSAnRVhJVCBWUic7XG5cblx0XHRcdFx0Y3VycmVudFNlc3Npb24gPSBzZXNzaW9uO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIG9uU2Vzc2lvbkVuZGVkKCAvKmV2ZW50Ki8gKSB7XG5cblx0XHRcdFx0Y3VycmVudFNlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2VuZCcsIG9uU2Vzc2lvbkVuZGVkICk7XG5cblx0XHRcdFx0YnV0dG9uLnRleHRDb250ZW50ID0gJ0VOVEVSIFZSJztcblxuXHRcdFx0XHRjdXJyZW50U2Vzc2lvbiA9IG51bGw7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly9cblxuXHRcdFx0YnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnJztcblxuXHRcdFx0YnV0dG9uLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcblx0XHRcdGJ1dHRvbi5zdHlsZS5sZWZ0ID0gJ2NhbGMoNTAlIC0gNTBweCknO1xuXHRcdFx0YnV0dG9uLnN0eWxlLndpZHRoID0gJzEwMHB4JztcblxuXHRcdFx0YnV0dG9uLnRleHRDb250ZW50ID0gJ0VOVEVSIFZSJztcblxuXHRcdFx0YnV0dG9uLm9ubW91c2VlbnRlciA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRidXR0b24uc3R5bGUub3BhY2l0eSA9ICcxLjAnO1xuXG5cdFx0XHR9O1xuXG5cdFx0XHRidXR0b24ub25tb3VzZWxlYXZlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGJ1dHRvbi5zdHlsZS5vcGFjaXR5ID0gJzAuNSc7XG5cblx0XHRcdH07XG5cblx0XHRcdGJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGlmICggY3VycmVudFNlc3Npb24gPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHQvLyBXZWJYUidzIHJlcXVlc3RSZWZlcmVuY2VTcGFjZSBvbmx5IHdvcmtzIGlmIHRoZSBjb3JyZXNwb25kaW5nIGZlYXR1cmVcblx0XHRcdFx0XHQvLyB3YXMgcmVxdWVzdGVkIGF0IHNlc3Npb24gY3JlYXRpb24gdGltZS4gRm9yIHNpbXBsaWNpdHksIGp1c3QgYXNrIGZvclxuXHRcdFx0XHRcdC8vIHRoZSBpbnRlcmVzdGluZyBvbmVzIGFzIG9wdGlvbmFsIGZlYXR1cmVzLCBidXQgYmUgYXdhcmUgdGhhdCB0aGVcblx0XHRcdFx0XHQvLyByZXF1ZXN0UmVmZXJlbmNlU3BhY2UgY2FsbCB3aWxsIGZhaWwgaWYgaXQgdHVybnMgb3V0IHRvIGJlIHVuYXZhaWxhYmxlLlxuXHRcdFx0XHRcdC8vICgnbG9jYWwnIGlzIGFsd2F5cyBhdmFpbGFibGUgZm9yIGltbWVyc2l2ZSBzZXNzaW9ucyBhbmQgZG9lc24ndCBuZWVkIHRvXG5cdFx0XHRcdFx0Ly8gYmUgcmVxdWVzdGVkIHNlcGFyYXRlbHkuKVxuXG5cdFx0XHRcdFx0Y29uc3Qgc2Vzc2lvbkluaXQgPSB7IG9wdGlvbmFsRmVhdHVyZXM6IFsgJ2xvY2FsLWZsb29yJywgJ2JvdW5kZWQtZmxvb3InLCAnaGFuZC10cmFja2luZycsICdsYXllcnMnIF0gfTtcblx0XHRcdFx0XHRuYXZpZ2F0b3IueHIucmVxdWVzdFNlc3Npb24oICdpbW1lcnNpdmUtdnInLCBzZXNzaW9uSW5pdCApLnRoZW4oIG9uU2Vzc2lvblN0YXJ0ZWQgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y3VycmVudFNlc3Npb24uZW5kKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGlzYWJsZUJ1dHRvbigpIHtcblxuXHRcdFx0YnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnJztcblxuXHRcdFx0YnV0dG9uLnN0eWxlLmN1cnNvciA9ICdhdXRvJztcblx0XHRcdGJ1dHRvbi5zdHlsZS5sZWZ0ID0gJ2NhbGMoNTAlIC0gNzVweCknO1xuXHRcdFx0YnV0dG9uLnN0eWxlLndpZHRoID0gJzE1MHB4JztcblxuXHRcdFx0YnV0dG9uLm9ubW91c2VlbnRlciA9IG51bGw7XG5cdFx0XHRidXR0b24ub25tb3VzZWxlYXZlID0gbnVsbDtcblxuXHRcdFx0YnV0dG9uLm9uY2xpY2sgPSBudWxsO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2hvd1dlYlhSTm90Rm91bmQoKSB7XG5cblx0XHRcdGRpc2FibGVCdXR0b24oKTtcblxuXHRcdFx0YnV0dG9uLnRleHRDb250ZW50ID0gJ1ZSIE5PVCBTVVBQT1JURUQnO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc3R5bGl6ZUVsZW1lbnQoIGVsZW1lbnQgKSB7XG5cblx0XHRcdGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHRcdFx0ZWxlbWVudC5zdHlsZS5ib3R0b20gPSAnMjBweCc7XG5cdFx0XHRlbGVtZW50LnN0eWxlLnBhZGRpbmcgPSAnMTJweCA2cHgnO1xuXHRcdFx0ZWxlbWVudC5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkICNmZmYnO1xuXHRcdFx0ZWxlbWVudC5zdHlsZS5ib3JkZXJSYWRpdXMgPSAnNHB4Jztcblx0XHRcdGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZCA9ICdyZ2JhKDAsMCwwLDAuMSknO1xuXHRcdFx0ZWxlbWVudC5zdHlsZS5jb2xvciA9ICcjZmZmJztcblx0XHRcdGVsZW1lbnQuc3R5bGUuZm9udCA9ICdub3JtYWwgMTNweCBzYW5zLXNlcmlmJztcblx0XHRcdGVsZW1lbnQuc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7XG5cdFx0XHRlbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAnMC41Jztcblx0XHRcdGVsZW1lbnQuc3R5bGUub3V0bGluZSA9ICdub25lJztcblx0XHRcdGVsZW1lbnQuc3R5bGUuekluZGV4ID0gJzk5OSc7XG5cblx0XHR9XG5cblx0XHRpZiAoICd4cicgaW4gbmF2aWdhdG9yICkge1xuXG5cdFx0XHRidXR0b24uaWQgPSAnVlJCdXR0b24nO1xuXHRcdFx0YnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cblx0XHRcdHN0eWxpemVFbGVtZW50KCBidXR0b24gKTtcblxuXHRcdFx0bmF2aWdhdG9yLnhyLmlzU2Vzc2lvblN1cHBvcnRlZCggJ2ltbWVyc2l2ZS12cicgKS50aGVuKCBmdW5jdGlvbiAoIHN1cHBvcnRlZCApIHtcblxuXHRcdFx0XHRzdXBwb3J0ZWQgPyBzaG93RW50ZXJWUigpIDogc2hvd1dlYlhSTm90Rm91bmQoKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0XHRyZXR1cm4gYnV0dG9uO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc3QgbWVzc2FnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdhJyApO1xuXG5cdFx0XHRpZiAoIHdpbmRvdy5pc1NlY3VyZUNvbnRleHQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdG1lc3NhZ2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWYucmVwbGFjZSggL15odHRwOi8sICdodHRwczonICk7XG5cdFx0XHRcdG1lc3NhZ2UuaW5uZXJIVE1MID0gJ1dFQlhSIE5FRURTIEhUVFBTJzsgLy8gVE9ETyBJbXByb3ZlIG1lc3NhZ2VcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRtZXNzYWdlLmhyZWYgPSAnaHR0cHM6Ly9pbW1lcnNpdmV3ZWIuZGV2Lyc7XG5cdFx0XHRcdG1lc3NhZ2UuaW5uZXJIVE1MID0gJ1dFQlhSIE5PVCBBVkFJTEFCTEUnO1xuXG5cdFx0XHR9XG5cblx0XHRcdG1lc3NhZ2Uuc3R5bGUubGVmdCA9ICdjYWxjKDUwJSAtIDkwcHgpJztcblx0XHRcdG1lc3NhZ2Uuc3R5bGUud2lkdGggPSAnMTgwcHgnO1xuXHRcdFx0bWVzc2FnZS5zdHlsZS50ZXh0RGVjb3JhdGlvbiA9ICdub25lJztcblxuXHRcdFx0c3R5bGl6ZUVsZW1lbnQoIG1lc3NhZ2UgKTtcblxuXHRcdFx0cmV0dXJuIG1lc3NhZ2U7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFZSQnV0dG9uIH07XG4iLCJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSdcbmltcG9ydCBDaGFyYWN0ZXJDb250cm9sbGVySW5wdXQgZnJvbSAnLi9jaGFyYWN0ZXJDb250cm9sbGVySW5wdXQuanMnXG5pbXBvcnQgVGhpcmRQZXJzb25DYW1lcmEgZnJvbSAnLi90aGlyZFBlcnNvbkNhbWVyYSdcbmltcG9ydCBGaW5pdGVTdGF0ZU1hY2hpbmUgZnJvbSAnLi9maW5pdGVTdGF0ZU1hY2hpbmUuanMnXG5cbmltcG9ydCB7IEdMVEZMb2FkZXIgfSBmcm9tICcuL0dMVEZMb2FkZXIuanMnXG5pbXBvcnQgeyBEUkFDT0xvYWRlciB9IGZyb20gJy4vRFJBQ09Mb2FkZXIuanMnXG5cbmNsYXNzIENoYXJhY3RlciB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIHRoaXMuaW5pdChwYXJhbXMpXG4gICAgfVxuXG4gICAgaW5pdChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5pc0xvYWRlZCA9IGZhbHNlXG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zXG4gICAgICAgIHRoaXMuc2NlbmVQYXJlbnQgPSBwYXJhbXMuc2NlbmVcbiAgICAgICAgdGhpcy5zY2VuZSA9IHBhcmFtcy5zY2VuZS5zY2VuZVxuICAgICAgICB0aGlzLmNhbWVyYSA9IHBhcmFtcy5jYW1lcmFcblxuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB7fVxuXG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy5pc0NvbnRyb2xsYWJsZSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbml0aWFsIHZhbHVlcyAmIGNvbnN0YW50c1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmRlY2NlbGVyYXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygtMC4wMDAwNSwgLTAuMDAwMDAxLCAtMi41KVxuICAgICAgICAgICAgdGhpcy5hY2NlbGVyYXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygwLjEsIDAuNSwgNS4wKVxuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBUSFJFRS5WZWN0b3IzKClcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbnN0YW50aWF0ZSBjb250cm9sbGVyIGlucHV0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBuZXcgQ2hhcmFjdGVyQ29udHJvbGxlcklucHV0KClcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUT0RPOiBJbnN0YW50aWF0ZSBGU01cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhdGVNYWNoaW5lID0gbmV3IEZpbml0ZVN0YXRlTWFjaGluZSh7XG4gICAgICAgICAgICBhbmltYXRpb25zOiB0aGlzLmFuaW1hdGlvbnNcbiAgICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUT0RPOiBMb2FkIG1vZGVscyBhbmQgQW5pbWF0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgLy8gVE9ETzogbG9hZCBhbiBhY3R1YWwgbW9kZWxcbiAgICAgICAgdGhpcy5sb2FkTW9kZWxBbmRBbmltYXRpb25zKClcbiAgICB9XG5cbiAgICBsb2FkTW9kZWxBbmRBbmltYXRpb25zKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VuZCBwcm94eSBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IG1lc2ggPSBuZXcgVEhSRUUuT2JqZWN0M0QoKVxuICAgICAgICB0aGlzLnRhcmdldCA9IG1lc2hcbiAgICAgICAgdGhpcy51c2VyRGF0YSA9IHtcbiAgICAgICAgICAgIG1vZGVsOiAncHJveHknLFxuICAgICAgICAgICAgbWVzaDogbWVzaCxcbiAgICAgICAgICAgIHg6IG1lc2gucG9zaXRpb24ueCxcbiAgICAgICAgICAgIHk6IG1lc2gucG9zaXRpb24ueSxcbiAgICAgICAgICAgIHo6IG1lc2gucG9zaXRpb24ueixcbiAgICAgICAgICAgIHJ4OiBtZXNoLnJvdGF0aW9uLngsXG4gICAgICAgICAgICByeTogbWVzaC5yb3RhdGlvbi55LFxuICAgICAgICAgICAgcno6IG1lc2gucm90YXRpb24ucnosXG4gICAgICAgICAgICBjbGlwQWN0aW9uOiB1bmRlZmluZWRcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGxvYWQgbW9kZWxzIGFuZCBzZXR1cCAzcHMgY2FtZXJhIGNvbnRyb2xzIGlmIGNvbnRyb2xsYWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgZHJhY29Mb2FkZXIgPSBuZXcgRFJBQ09Mb2FkZXIoKVxuICAgICAgICBkcmFjb0xvYWRlci5zZXREZWNvZGVyUGF0aCgnc3RhdGljL2RyYWNvJylcblxuICAgICAgICBjb25zdCBnbHRmTG9hZGVyID0gbmV3IEdMVEZMb2FkZXIoKVxuICAgICAgICBnbHRmTG9hZGVyLnNldERSQUNPTG9hZGVyKGRyYWNvTG9hZGVyKVxuXG4gICAgICAgIGdsdGZMb2FkZXIubG9hZCgnc3RhdGljL21vZGVscy9Tb2xkaWVyLmdsYicsIChnbGIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc2ggPSBnbGIuc2NlbmVcblxuICAgICAgICAgICAgdGhpcy5zY2VuZS5hZGQobWVzaClcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgdGFyZ2V0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gbWVzaFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCB0YXJnZXQgZm9yIGFuaW1hdGlvbnNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5taXhlciA9IG5ldyBUSFJFRS5BbmltYXRpb25NaXhlcih0aGlzLnRhcmdldClcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMb2FkIGFuaW1hdGlvbnNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zWydpZGxlJ10gPSB7XG4gICAgICAgICAgICAgICAgY2xpcDogZ2xiLmFuaW1hdGlvbnNbMF0sXG4gICAgICAgICAgICAgICAgYWN0aW9uOiB0aGlzLm1peGVyLmNsaXBBY3Rpb24oZ2xiLmFuaW1hdGlvbnNbMF0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnNbJ3dhbGsnXSA9IHtcbiAgICAgICAgICAgICAgICBjbGlwOiBnbGIuYW5pbWF0aW9uc1swXSxcbiAgICAgICAgICAgICAgICBhY3Rpb246IHRoaXMubWl4ZXIuY2xpcEFjdGlvbihnbGIuYW5pbWF0aW9uc1szXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGVNYWNoaW5lLnNldFN0YXRlKCdpZGxlJylcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXR1cCBjYW1lcmEgaWYgY29udHJvbGxhYmxlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtcy5pc0NvbnRyb2xsYWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGhpcmRQZXJzb25DYW1lcmEgPSBuZXcgVGhpcmRQZXJzb25DYW1lcmEoe1xuICAgICAgICAgICAgICAgICAgICBjYW1lcmE6IHRoaXMuY2FtZXJhLFxuICAgICAgICAgICAgICAgICAgICBtZXNoOiBtZXNoXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTdG9yZSByZWxldmFudCBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnVzZXJEYXRhID0ge1xuICAgICAgICAgICAgICAgIG1vZGVsOiAnc29sZGllcicsXG4gICAgICAgICAgICAgICAgbWVzaDogbWVzaCxcbiAgICAgICAgICAgICAgICB4OiBtZXNoLnBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgeTogbWVzaC5wb3NpdGlvbi55LFxuICAgICAgICAgICAgICAgIHo6IG1lc2gucG9zaXRpb24ueixcbiAgICAgICAgICAgICAgICByeDogbWVzaC5yb3RhdGlvbi54LFxuICAgICAgICAgICAgICAgIHJ5OiBtZXNoLnJvdGF0aW9uLnksXG4gICAgICAgICAgICAgICAgcno6IG1lc2gucm90YXRpb24ueixcbiAgICAgICAgICAgICAgICBjbGlwQWN0aW9uOiAnaWRsZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNMb2FkZWQgPSB0cnVlXG4gICAgICAgIH0pXG5cblxuICAgIH1cblxuICAgIG9uTG9hZEFuaW1hdGlvbihhbmltYXRpb25OYW1lLCBhbmltYXRpb24pIHtcbiAgICAgICAgY29uc3QgY2xpcCA9IGFuaW1hdGlvbi5hbmltYXRpb25zWzBdXG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMubWl4ZXIuY2xpcEFjdGlvbihjbGlwKVxuXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uc1thbmltYXRpb25OYW1lXSA9IHtcbiAgICAgICAgICAgIGNsaXA6IGNsaXAsXG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2hlY2tJZkNvbGxpc2lvbigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhc3QgcmF5IGZvcndhcmQgYW5kIGJhY2t3YXJkc1xuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZSByYXljYXN0ZXIgcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHJheWNhc3RlclBvc2l0aW9uID0gdGhpcy50YXJnZXQucG9zaXRpb24uY2xvbmUoKVxuICAgICAgICByYXljYXN0ZXJQb3NpdGlvbi55ICs9IDEuNVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmUgcmF5Y2FzdGVyIGRpcmVjdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcmF5Y2FzdGVyRGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKVxuICAgICAgICB0aGlzLnRhcmdldC5nZXRXb3JsZERpcmVjdGlvbihyYXljYXN0ZXJEaXJlY3Rpb24pXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbW92aW5nIGZvcndhcmQsIHRoZW4gbmVnYXRlIGRpcmVjdGlvblxuICAgICAgICAgKiBnZXRXb3JsZERpcmVjdGlvbigpIGdpdmVzIGRpcmVjdGlvbiBvZiArdmUgWiBheGlzXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5pbnB1dC5jb250cm9sS2V5cy53KSB7XG4gICAgICAgICAgICByYXljYXN0ZXJEaXJlY3Rpb24ubmVnYXRlKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKmR3XG4gICAgICAgICAqIENyZWF0ZSByYXljYXN0ZXJcbiAgICAgICAgICovXG4gICAgICAgIGxldCByYXljYXN0ZXIgPSBuZXcgVEhSRUUuUmF5Y2FzdGVyKHJheWNhc3RlclBvc2l0aW9uLCByYXljYXN0ZXJEaXJlY3Rpb24pXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhc3QgcmF5XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgaW50ZXJzZWN0cyA9IHJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3RzKHRoaXMuc2NlbmVQYXJlbnQuY29sbGlkZXJzKVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmUgaWYgY29sbGlzaW9uXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaW50ZXJzZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0c1swXS5kaXN0YW5jZSA8IDAuNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUaW1lKSB7XG4gICAgICAgIGlmICh0aGlzLnRhcmdldCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlTWFjaGluZS5jdXJyZW50U3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGVNYWNoaW5lLnVwZGF0ZShkZWx0YVRpbWUsIHRoaXMuaW5wdXQpXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFB1bGwgdGFyZ2V0IHBvc2l0aW9uIGFuZCByb3RhdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgdmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5XG5cbiAgICAgICAgY29uc3Qgcm90YXRpb25PZmZzZXQgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpXG4gICAgICAgIGNvbnN0IHJvdGF0aW9uQXhpcyA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDEsIDApXG4gICAgICAgIGNvbnN0IHRhcmdldFJvdGF0aW9uID0gdGhpcy50YXJnZXQucXVhdGVybmlvbi5jbG9uZSgpXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF1dG8gZGVjY2VsZXJhdGUgZXZlcnkgZnJhbWVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGZyYW1lRGVjY2VsZXJhdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICAgICAgdmVsb2NpdHkueCAqIHRoaXMuZGVjY2VsZXJhdGlvbi54LFxuICAgICAgICAgICAgdmVsb2NpdHkueSAqIHRoaXMuZGVjY2VsZXJhdGlvbi55LFxuICAgICAgICAgICAgdmVsb2NpdHkueiAqIHRoaXMuZGVjY2VsZXJhdGlvbi56XG4gICAgICAgIClcbiAgICAgICAgZnJhbWVEZWNjZWxlcmF0aW9uLm11bHRpcGx5U2NhbGFyKGRlbHRhVGltZSlcbiAgICAgICAgZnJhbWVEZWNjZWxlcmF0aW9uLnogPSBNYXRoLnNpZ24oZnJhbWVEZWNjZWxlcmF0aW9uLnopICogTWF0aC5taW4oTWF0aC5hYnMoZnJhbWVEZWNjZWxlcmF0aW9uLnopLCBNYXRoLmFicyh2ZWxvY2l0eS56KSlcblxuICAgICAgICB2ZWxvY2l0eS5hZGQoZnJhbWVEZWNjZWxlcmF0aW9uKVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIG1vdmUgdmVsb2NpdHkgLSBGTElQUEVEIFNJR05TIC0gRklYIE1PREVMXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5pbnB1dC5jb250cm9sS2V5cy53KSB7IFxuICAgICAgICAgICAgdmVsb2NpdHkueiAtPSB0aGlzLmFjY2VsZXJhdGlvbi56ICogZGVsdGFUaW1lXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pbnB1dC5jb250cm9sS2V5cy5zKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eS56ICs9IHRoaXMuYWNjZWxlcmF0aW9uLnogKiBkZWx0YVRpbWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZlbG9jaXR5LnogPSAwXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmluZCByb3RhdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuY29udHJvbEtleXMuYSkge1xuICAgICAgICAgICAgcm90YXRpb25PZmZzZXQuc2V0RnJvbUF4aXNBbmdsZShyb3RhdGlvbkF4aXMsIDIuMCAqIE1hdGguUEkgKiBkZWx0YVRpbWUgKiB0aGlzLmFjY2VsZXJhdGlvbi55KVxuICAgICAgICAgICAgdGFyZ2V0Um90YXRpb24ubXVsdGlwbHkocm90YXRpb25PZmZzZXQpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pbnB1dC5jb250cm9sS2V5cy5kKSB7XG4gICAgICAgICAgICByb3RhdGlvbk9mZnNldC5zZXRGcm9tQXhpc0FuZ2xlKHJvdGF0aW9uQXhpcywgMi4wICogLU1hdGguUEkgKiBkZWx0YVRpbWUgKiB0aGlzLmFjY2VsZXJhdGlvbi55KVxuICAgICAgICAgICAgdGFyZ2V0Um90YXRpb24ubXVsdGlwbHkocm90YXRpb25PZmZzZXQpXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgY29sbGlzaW9uIG9jY3VyZWRcbiAgICAgICAgICogZm9yd2FyZC8gYmFja3dhcmQgLSByZW1vdmUgdmVsb2l0eVxuICAgICAgICAgKiBsZWZ0LyByaWdodCAtIGludmVydCByb3RhdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuY2hlY2tJZkNvbGxpc2lvbigpKSB7XG4gICAgICAgICAgICB2ZWxvY2l0eS56ID0gMFxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGx5IHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YXJnZXQucXVhdGVybmlvbi5jb3B5KHRhcmdldFJvdGF0aW9uKVxuXG4gICAgICAgIGNvbnN0IG9sZFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKVxuICAgICAgICBvbGRQb3NpdGlvbi5jb3B5KHRoaXMudGFyZ2V0LnBvc2l0aW9uKVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBseSByb3RhdGlvbiBkZXBlbmRpbmcgb24gb3JpZW50YXRpb25cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGZvcndhcmQgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAxKVxuICAgICAgICBmb3J3YXJkLmFwcGx5UXVhdGVybmlvbih0aGlzLnRhcmdldC5xdWF0ZXJuaW9uKVxuICAgICAgICBmb3J3YXJkLm5vcm1hbGl6ZSgpXG5cbiAgICAgICAgY29uc3Qgc2lkZXdheXMgPSBuZXcgVEhSRUUuVmVjdG9yMygxLCAwLCAwKVxuICAgICAgICBzaWRld2F5cy5hcHBseVF1YXRlcm5pb24odGhpcy50YXJnZXQucXVhdGVybmlvbilcbiAgICAgICAgc2lkZXdheXMubm9ybWFsaXplKClcblxuICAgICAgICBmb3J3YXJkLm11bHRpcGx5U2NhbGFyKHZlbG9jaXR5LnogKiBkZWx0YVRpbWUpXG4gICAgICAgIHNpZGV3YXlzLm11bHRpcGx5U2NhbGFyKHZlbG9jaXR5LnggKiBkZWx0YVRpbWUpXG5cbiAgICAgICAgdGhpcy50YXJnZXQucG9zaXRpb24uYWRkKGZvcndhcmQpXG4gICAgICAgIHRoaXMudGFyZ2V0LnBvc2l0aW9uLmFkZChzaWRld2F5cylcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIG1peGVyIHRpbWVcbiAgICAgICAgICovXG5cbiAgICAgICAgaWYgKHRoaXMubWl4ZXIpIHtcbiAgICAgICAgICAgIHRoaXMubWl4ZXIudXBkYXRlKGRlbHRhVGltZSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2hhcmFjdGVyIiwiY2xhc3MgQ2hhcmFjdGVyQ29udHJvbGxlcklucHV0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXNcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWFwIHRvIGRldGVybWluZSB3aGljaCBrZXlzIGFyZSBwcmVzc2VkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRyb2xLZXlzID0ge1xuICAgICAgICAgICAgdzogZmFsc2UsXG4gICAgICAgICAgICBhOiBmYWxzZSxcbiAgICAgICAgICAgIHM6IGZhbHNlLFxuICAgICAgICAgICAgZDogZmFsc2UsXG4gICAgICAgICAgICBxOiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZSkgPT4geyB0aGlzLmhhbmRsZUtleURvd24oZSkgfSlcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGUpID0+IHsgdGhpcy5oYW5kbGVLZXlVcChlKSB9KVxuICAgIH1cblxuICAgIGhhbmRsZUtleURvd24oZSkge1xuICAgICAgICBjb25zdCBwcmVzc2VkS2V5ID0gZS5jb2RlLnJlcGxhY2UoJ0tleScsICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIHN3aXRjaChwcmVzc2VkS2V5KSB7XG4gICAgICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xLZXlzLncgPSB0cnVlXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbEtleXMuYSA9IHRydWVcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sS2V5cy5zID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xLZXlzLmQgPSB0cnVlXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2xLZXlzLnEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250cm9sS2V5cy5xID0gZmFsc2VcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xLZXlzLnEgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVLZXlVcChlKSB7XG4gICAgICAgIGNvbnN0IHByZXNzZWRLZXkgPSBlLmNvZGUucmVwbGFjZSgnS2V5JywgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgc3dpdGNoKHByZXNzZWRLZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbEtleXMudyA9IGZhbHNlXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ2EnOiBcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xLZXlzLmEgPSBmYWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xLZXlzLnMgPSBmYWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xLZXlzLmQgPSBmYWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENoYXJhY3RlckNvbnRyb2xsZXJJbnB1dCIsImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJ1xuXG4vKipcbiAqIGNsYXNzIHRvIG1vZGlmeSBhbmltYXRpb24gc3RhdGVzXG4gKi9cbmNsYXNzIEZpbml0ZVN0YXRlTWFjaGluZSB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXAgYWxsIHN0YXRlcyB0byB0aGVpciBjbGFzc2VzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXRlcyA9IHtcbiAgICAgICAgICAgICdpZGxlJzogSWRsZVN0YXRlLFxuICAgICAgICAgICAgJ3dhbGsnOiBXYWxrU3RhdGVcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gbnVsbFxuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSBwYXJhbXMuYW5pbWF0aW9uc1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgY3VycmVudCBzdGF0ZVxuICAgICAqL1xuICAgIHNldFN0YXRlKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcHJldlN0YXRlID0gdGhpcy5jdXJyZW50U3RhdGVcblxuICAgICAgICBpZiAocHJldlN0YXRlKSB7XG4gICAgICAgICAgICBpZiAocHJldlN0YXRlLm5hbWUgPT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmV2U3RhdGUuZXhpdCgpXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGNvcnJlc3BvbmRpbmcgc3RhdGUgd2l0aCByZWZlcmVuY2UgdG8gRlNNXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBzdGF0ZSA9IG5ldyB0aGlzLnN0YXRlc1tuYW1lXSh0aGlzKVxuXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gc3RhdGVcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW50ZXIgZnJvbSBwcmV2U3RhdGVcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRlLmVudGVyKHByZXZTdGF0ZSlcbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUaW1lLCBpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFN0YXRlLnVwZGF0ZShkZWx0YVRpbWUsIGlucHV0KVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEdlbmVyaWMgc3RhdGUgaW50ZXJmYWNlXG4gKi9cbmNsYXNzIFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRcbiAgICB9XG5cbiAgICBlbnRlcigpIHt9XG4gICAgZXhpdCgpIHt9XG4gICAgdXBkYXRlKCkge31cbn1cblxuLyoqXG4gKiBTcGVjaWZpYyBjbGFzc2VzIGZvciBlYWNoIHN0YXRlXG4gKi9cbmNsYXNzIElkbGVTdGF0ZSBleHRlbmRzIFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50KVxuXG4gICAgICAgIHRoaXMubmFtZSA9ICdpZGxlJ1xuICAgIH1cblxuICAgIGVudGVyKHByZXZTdGF0ZSkge1xuICAgICAgICBjb25zdCBpZGxlQWN0aW9uID0gdGhpcy5wYXJlbnQuYW5pbWF0aW9uc1snaWRsZSddLmFjdGlvblxuXG4gICAgICAgIGlmIChwcmV2U3RhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZBY3Rpb24gPSB0aGlzLnBhcmVudC5hbmltYXRpb25zW3ByZXZTdGF0ZS5uYW1lXS5hY3Rpb25cblxuICAgICAgICAgICAgaWRsZUFjdGlvbi5lbmFibGVkID0gdHJ1ZVxuICAgICAgICAgICAgaWRsZUFjdGlvbi50aW1lID0gMC4wXG4gICAgICAgICAgICBpZGxlQWN0aW9uLmNyb3NzRmFkZUZyb20ocHJldkFjdGlvbiwgMC41LCB0cnVlKVxuICAgICAgICAgICAgaWRsZUFjdGlvbi5wbGF5KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlkbGVBY3Rpb24ucGxheSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleGl0KCkge1xuXG4gICAgfVxuXG4gICAgdXBkYXRlKGRlbHRhVGltZSwgaW5wdXQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRPRE86IE1vZGlmeSBzdGF0ZVxuICAgICAgICAgKiBUT0RPOiBpbXBsZW1lbnQgdHVyblxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlucHV0LmNvbnRyb2xLZXlzLncpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnNldFN0YXRlKCd3YWxrJylcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5jb250cm9sS2V5cy5zKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnV0FMS0lORyBCQUNLV0FSRFMnKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBXYWxrU3RhdGUgZXh0ZW5kcyBTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudClcblxuICAgICAgICB0aGlzLm5hbWUgPSAnd2FsaydcbiAgICB9XG5cbiAgICBlbnRlcihwcmV2U3RhdGUpIHtcbiAgICAgICAgY29uc3Qgd2Fsa0FjdGlvbiA9IHRoaXMucGFyZW50LmFuaW1hdGlvbnNbJ3dhbGsnXS5hY3Rpb25cblxuICAgICAgICBpZiAocHJldlN0YXRlKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2QWN0aW9uID0gdGhpcy5wYXJlbnQuYW5pbWF0aW9uc1twcmV2U3RhdGUubmFtZV0uYWN0aW9uXG5cbiAgICAgICAgICAgIHdhbGtBY3Rpb24uZW5hYmxlZCA9IHRydWVcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUT0RPOiBIQU5ETEUgUlVOIFNUQVRFIENBU0VcbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB3YWxrQWN0aW9uLnRpbWUgPSAwLjBcbiAgICAgICAgICAgIHdhbGtBY3Rpb24uY3Jvc3NGYWRlRnJvbShwcmV2QWN0aW9uLCAwLjUsIHRydWUpXG4gICAgICAgICAgICB3YWxrQWN0aW9uLnBsYXkoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2Fsa0FjdGlvbi5wbGF5KClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4aXQoKSB7XG5cbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUaW1lLCBpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQuY29udHJvbEtleXMudykge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhcmVudC5zZXRTdGF0ZSgnaWRsZScpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGaW5pdGVTdGF0ZU1hY2hpbmUiLCJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSdcbmltcG9ydCBTY2VuZSBmcm9tICcuL3NjZW5lLmpzJ1xuaW1wb3J0ICogYXMgZGF0IGZyb20gJ2RhdC5ndWknXG5pbXBvcnQgQ2hhcmFjdGVyIGZyb20gJy4vY2hhcmFjdGVyLmpzJ1xuXG5pbXBvcnQgeyBWUkJ1dHRvbiB9IGZyb20gJy4vVlJCdXR0b24uanMnXG5cbi8qKlxuICogU2V0dXAgU29ja2V0LmlvLWNsaWVudFxuICovXG5jb25zdCBzb2NrZXQgPSBpbygpXG5cbi8qKlxuICogR1VJIC0gZm9yIHR3ZWFraW5nIHBhcmFtZXRlcnNcbiAqL1xuLy8gY29uc3QgZ3VpID0gbmV3IGRhdC5HVUkoe1xuLy8gICAgIGNsb3NlZDogZmFsc2Vcbi8vIH0pXG5cbi8qKlxuICogU2V0dXAgcGxheWVyIGxvY2FsIGVudmlyb25tZW50XG4gKi9cbmNvbnN0IHBsYXllclNjZW5lID0gbmV3IFNjZW5lKClcblxuLyoqXG4gKiBQbGF5ZXIgbG9jYWwgZGF0YVxuICovXG5jb25zdCByZW1vdGVEYXRhID0ge31cbmNvbnN0IHJlbmRlcmVkVXNlcnMgPSB7fVxuXG4vKipcbiAqIFF1aWNrIGFjY2VzcyB0byBjdXJyZW50IGNoYXJhY3RlclxuICovXG5sZXQgY3VycmVudFVzZXJJZCA9IHVuZGVmaW5lZFxuXG4vKipcbiAqIENvbnRyb2xsZXJzXG4gKi9cbmxldCBjaGFyYWN0ZXIgPSB1bmRlZmluZWRcblxuLyoqXG4gKiBBbmltYXRpb24gZnVuY3Rpb25cbiAqL1xuY29uc3QgY2xvY2sgPSBuZXcgVEhSRUUuQ2xvY2soKVxuXG5mdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNvbnRyb2xzICYgbm90aWZ5IGFib3V0IGNoYW5nZXNcbiAgICAgKi9cbiAgICAgaWYgKGN1cnJlbnRVc2VySWQgJiYgY2hhcmFjdGVyLmlzTG9hZGVkKSB7XG4gICAgICAgIGNoYXJhY3Rlci51cGRhdGUoY2xvY2suZ2V0RGVsdGEoKSlcbiAgICAgICAgY2hhcmFjdGVyLnRoaXJkUGVyc29uQ2FtZXJhLnVwZGF0ZShjaGFyYWN0ZXIuaW5wdXQpXG4gICAgICAgIGNoYXJhY3Rlci5zdGF0ZU1hY2hpbmUudXBkYXRlKGNsb2NrLmdldERlbHRhKCksIGNoYXJhY3Rlci5pbnB1dClcblxuICAgICAgICBzb2NrZXQuZW1pdCgndXBkYXRlJywge1xuICAgICAgICAgICAgaWQ6IGN1cnJlbnRVc2VySWQsXG4gICAgICAgICAgICBtb2RlbDogY2hhcmFjdGVyLnVzZXJEYXRhLm1vZGVsLFxuICAgICAgICAgICAgeDogY2hhcmFjdGVyLnRhcmdldC5wb3NpdGlvbi54LFxuICAgICAgICAgICAgeTogY2hhcmFjdGVyLnRhcmdldC5wb3NpdGlvbi55LFxuICAgICAgICAgICAgejogY2hhcmFjdGVyLnRhcmdldC5wb3NpdGlvbi56LFxuICAgICAgICAgICAgcng6IGNoYXJhY3Rlci50YXJnZXQucm90YXRpb24ueCxcbiAgICAgICAgICAgIHJ5OiBjaGFyYWN0ZXIudGFyZ2V0LnJvdGF0aW9uLnksXG4gICAgICAgICAgICByejogY2hhcmFjdGVyLnRhcmdldC5yb3RhdGlvbi56LFxuICAgICAgICAgICAgY2xpcEFjdGlvbjogY2hhcmFjdGVyLnN0YXRlTWFjaGluZS5jdXJyZW50U3RhdGUubmFtZVxuICAgICAgICB9KVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgb3RoZXIgdXNlcnNcbiAgICAgKi9cbiAgICBpZiAocmVuZGVyZWRVc2Vycykge1xuICAgICAgICB1cGRhdGVVc2VycyhjbG9jay5nZXREZWx0YSgpKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gYW5pbWF0ZSgpIHtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVcbiAgICAgKi9cbiAgICB1cGRhdGUoKVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHNjZW5lXG4gICAgICovXG4gICAgcGxheWVyU2NlbmUucmVuZGVyZXIucmVuZGVyKHBsYXllclNjZW5lLnNjZW5lLCBwbGF5ZXJTY2VuZS5jYW1lcmEpXG5cbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgYW5pbWF0ZSgpXG4gICAgfSlcbn1cbmFuaW1hdGUoKVxuXG4vKipcbiAqIFZSIFJlbmRlcmluZ1xuICovXG5wbGF5ZXJTY2VuZS5yZW5kZXJlci54ci5lbmFibGVkID0gdHJ1ZVxuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChWUkJ1dHRvbi5jcmVhdGVCdXR0b24ocGxheWVyU2NlbmUucmVuZGVyZXIpKVxuXG5wbGF5ZXJTY2VuZS5yZW5kZXJlci5zZXRBbmltYXRpb25Mb29wKGZ1bmN0aW9uKCkge1xuICAgIC8vIHVwZGF0ZSgpXG5cbiAgICBwbGF5ZXJTY2VuZS5yZW5kZXJlci5yZW5kZXIocGxheWVyU2NlbmUuc2NlbmUsIHBsYXllclNjZW5lLmNhbWVyYSlcbn0pXG5cblxuLyoqXG4gKiAgLS0tLS0tIFdlYiBzb2NrZXQgY29tbXVuaWNhdGlvbiB3aXRoIHNlcnZlciAtLS0tLVxuICovXG5cbi8qKlxuICogSW5pdGlhbCBzZXR1cCBmb3IgdXNlclxuICovXG5zb2NrZXQub24oJ3NldElkJywgZnVuY3Rpb24gaGFuZGxlU2V0SWQocGFyYW1zKSB7XG4gICAgLyoqXG4gICAgICogQ2FwdHVyZSBzb2NrZXQgSURcbiAgICAgKi9cbiAgICBjdXJyZW50VXNlcklkID0gcGFyYW1zLmlkXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIENoYXJhY3RlciBhbmQgQ2FtZXJhXG4gICAgICovXG4gICAgY2hhcmFjdGVyID0gbmV3IENoYXJhY3Rlcih7XG4gICAgICAgIHNjZW5lOiBwbGF5ZXJTY2VuZSxcbiAgICAgICAgY2FtZXJhOiBwbGF5ZXJTY2VuZS5jYW1lcmEsXG4gICAgICAgIGlzQ29udHJvbGxhYmxlOiB0cnVlXG4gICAgfSlcblxuICAgIHNvY2tldC5lbWl0KCdpbml0Jywge1xuICAgICAgICBtb2RlbDogY2hhcmFjdGVyLnVzZXJEYXRhLm1vZGVsLFxuICAgICAgICB4OiBjaGFyYWN0ZXIudXNlckRhdGEueCxcbiAgICAgICAgeTogY2hhcmFjdGVyLnVzZXJEYXRhLnksXG4gICAgICAgIHo6IGNoYXJhY3Rlci51c2VyRGF0YS56LFxuICAgICAgICByeDogY2hhcmFjdGVyLnVzZXJEYXRhLnJ4LFxuICAgICAgICByeTogY2hhcmFjdGVyLnVzZXJEYXRhLnJ5LFxuICAgICAgICByejogY2hhcmFjdGVyLnVzZXJEYXRhLnJ6LFxuICAgICAgICBjbGlwQWN0aW9uOiBjaGFyYWN0ZXIudXNlckRhdGEuY2xpcEFjdGlvblxuICAgIH0pXG59KVxuXG4vKipcbiAqIFVwZGF0ZSBsb2NhbCBkYXRhIHdpdGggcGF5bG9hZERyb3BcbiAqL1xuc29ja2V0Lm9uKCdwYXlsb2FkRHJvcCcsIGZ1bmN0aW9uIGhhbmRsZVBheWxvYWREcm9wKHBhcmFtcykge1xuICAgIHBhcmFtcy5wYXlsb2FkLmZvckVhY2goKHVzZXIpID0+IHtcbiAgICAgICAgaWYgKHVzZXIuaWQgIT0gY3VycmVudFVzZXJJZCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTdG9yZSBwYXlsb2FkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJlbW90ZURhdGFbdXNlci5pZF0gPSB1c2VyXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVuZGVyIGlmIG5ldyB1c2VyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChyZW5kZXJlZFVzZXJzW3VzZXIuaWRdID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkVXNlcnNbdXNlci5pZF0gPSBuZXcgQ2hhcmFjdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgc2NlbmU6IHBsYXllclNjZW5lLFxuICAgICAgICAgICAgICAgICAgICBpc0NvbnRyb2xsYWJsZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcbn0pXG5cbi8qKlxuICogRGVsZXRlIHVzZXIgdGhhdCBkaXNjb25uZWN0ZWRcbiAqL1xuc29ja2V0Lm9uKCdkZWxldGVVc2VyJywgZnVuY3Rpb24gaGFuZGxlRGVsZXRlVXNlcihwYXJhbXMpIHtcbiAgICBpZiAocmVtb3RlRGF0YVtwYXJhbXMuaWRdKSB7XG4gICAgICAgIHBsYXllclNjZW5lLnNjZW5lLnJlbW92ZShyZW5kZXJlZFVzZXJzW3BhcmFtcy5pZF0udXNlckRhdGEubWVzaClcbiAgICAgICAgZGVsZXRlIHJlbmRlcmVkVXNlcnNbcGFyYW1zLmlkXVxuICAgICAgICBkZWxldGUgcmVtb3RlRGF0YVtwYXJhbXMuaWRdXG4gICAgfVxufSlcblxuLyoqXG4gKiBVcGRhdGUgb3RoZXIgdXNlcnMnIGNvLW9yZGluYXRlc1xuICovXG4gZnVuY3Rpb24gdXBkYXRlVXNlcnMoZGVsdGFUaW1lKSB7XG4gICAgT2JqZWN0LmtleXMocmVuZGVyZWRVc2VycykuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgY29uc3QgbWVzaCA9IHJlbmRlcmVkVXNlcnNbaWRdLnRhcmdldFxuICAgICAgICBcbiAgICAgICAgbWVzaC5yb3RhdGlvbi54ID0gcmVtb3RlRGF0YVtpZF0ucnhcbiAgICAgICAgbWVzaC5yb3RhdGlvbi55ID0gcmVtb3RlRGF0YVtpZF0ucnlcbiAgICAgICAgbWVzaC5yb3RhdGlvbi56ID0gcmVtb3RlRGF0YVtpZF0ucnpcblxuICAgICAgICBtZXNoLnBvc2l0aW9uLmxlcnAobmV3IFRIUkVFLlZlY3RvcjMocmVtb3RlRGF0YVtpZF0ueCwgcmVtb3RlRGF0YVtpZF0ueSwgcmVtb3RlRGF0YVtpZF0ueiksIDAuMSlcbiAgICAgICAgXG4gICAgICAgIGlmIChyZW5kZXJlZFVzZXJzW2lkXS5pc0xvYWRlZCkge1xuICAgICAgICAgICAgcmVuZGVyZWRVc2Vyc1tpZF0ubWl4ZXIudXBkYXRlKDAuMDI1KVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAocmVtb3RlRGF0YVtpZF0uY2xpcEFjdGlvbiAhPSB1bmRlZmluZWQgJiYgcmVuZGVyZWRVc2Vyc1tpZF0uc3RhdGVNYWNoaW5lLmN1cnJlbnRTdGF0ZS5uYW1lICE9IHJlbW90ZURhdGFbaWRdLmNsaXBBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlZFVzZXJzW2lkXS5zdGF0ZU1hY2hpbmUuc2V0U3RhdGUocmVtb3RlRGF0YVtpZF0uY2xpcEFjdGlvbilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG59IiwiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnXG5cbi8qKlxuICogU2V0dXAgdGhlIGJhc2Ugb2YgdGhlIHNjZW5lIGFuZCBleHBvc2UgdGhlIGFuaW1hdGUgZnVuY3Rpb25cbiAqL1xuY2xhc3MgU2NlbmUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjd2ViZ2xfaGFuZGxlJyksXG4gICAgICAgIHdpZHRoID0gd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICApe1xuICAgICAgICAvKipcbiAgICAgICAgICogV2ViR0wgaGFuZGxlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhc1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVdGlsaXRpZXNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2l6ZXMgPSB7XG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdVSSB0d2Vha2FibGUgcGFyYW1ldGVycyBmb3IgdGVzdGluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zdGFudGlhdGluZyBhIHNjZW5lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKClcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0dXAgY2FtZXJhIC0gRk9WIDcwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg3MCwgdGhpcy5zaXplcy53aWR0aCAvIHRoaXMuc2l6ZXMuaGVpZ2h0LCAwLjEsIDEwMClcblxuICAgICAgICAvKipcbiAgICAgICAgICogTGlnaHRzXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBzdW5saWdodCA9IG5ldyBUSFJFRS5BbWJpZW50TGlnaHQoJyNmZmZmZmYnLCAwLjUpXG4gICAgICAgIHRoaXMuc2NlbmUuYWRkKHN1bmxpZ2h0KVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIZWxwZXJzXG4gICAgICAgICovXG4gICAgICAgIGNvbnN0IGdyaWRIZWxwZXIgPSBuZXcgVEhSRUUuR3JpZEhlbHBlcigxMDAsIDEwMClcbiAgICAgICAgdGhpcy5zY2VuZS5hZGQoZ3JpZEhlbHBlcilcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29sbGlkZXJzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbGxpZGVycyA9IFtdXG4gICAgICAgIHRoaXMuY3JlYXRlQ29sbGlkZXJzKClcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXR1cCByZW5kZXJlclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHtcbiAgICAgICAgICAgIGNhbnZhczogdGhpcy5jYW52YXMsXG4gICAgICAgICAgICBhbnRpYWxpYXM6IHRydWVcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHRoaXMuc2l6ZXMud2lkdGgsIHRoaXMuc2l6ZXMuaGVpZ2h0KVxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFBpeGVsUmF0aW8oTWF0aC5taW4od2luZG93LmRldmljZVBpeGVsUmF0aW8sIDIpKVxuICAgICAgICB0aGlzLnJlbmRlcmVyLm91dHB1dEVuY29kaW5nID0gVEhSRUUuc1JHQkVuY29kaW5nXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0Q2xlYXJDb2xvcihuZXcgVEhSRUUuQ29sb3IoJyMwMDAwMDAnKSlcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIChlKSA9PiB7IHRoaXMuaGFuZGxlUmVzaXplKGUpIH0pXG4gICAgfVxuXG4gICAgaGFuZGxlUmVzaXplKGUpIHtcbiAgICAgICAgdGhpcy5zaXplcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoXG4gICAgICAgIHRoaXMuc2l6ZXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0XG5cbiAgICAgICAgdGhpcy5jYW1lcmEuYXNwZWN0ID0gdGhpcy5zaXplcy53aWR0aCAvIHRoaXMuc2l6ZXMuaGVpZ2h0XG4gICAgICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKVxuXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh0aGlzLnNpemVzLndpZHRoLCB0aGlzLnNpemVzLmhlaWdodClcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRQaXhlbFJhdGlvKE1hdGgubWluKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLCAyKSlcbiAgICB9XG5cbiAgICBjcmVhdGVDb2xsaWRlcnMoKSB7XG4gICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KDUsIDUsIDUsIDEwLCAxMCwgMTApXG4gICAgICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgICAgIGNvbG9yOiAnI0FBMDAwMCcsXG4gICAgICAgICAgICB3aXJlZnJhbWU6IHRydWVcbiAgICAgICAgfSlcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGJveCBjb2xsaWRlcnNcbiAgICAgICAgICovXG4gICAgICAgIGZvciAobGV0IHggPSAtMTA7IHggPCAxMDsgeCArPSA1KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB6ID0gLTEwOyB6IDwgMTA7IHogKz0gNSkge1xuICAgICAgICAgICAgICAgIGlmICh4ID09IDAgfHwgeiA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVyID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKVxuICAgICAgICAgICAgICAgIGNvbGxpZGVyLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZVxuICAgICAgICAgICAgICAgIGNvbGxpZGVyLnBvc2l0aW9uLnNldCh4LCAyLjUgKyAwLjEsIHopXG4gICAgICAgICAgICAgICAgY29sbGlkZXIudXBkYXRlTWF0cml4KClcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLmFkZChjb2xsaWRlcilcbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxpZGVycy5wdXNoKGNvbGxpZGVyKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBmbG9vciBjb2xsaWRlclxuICAgICAgICAgKi9cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNjZW5lIiwiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnXG5cbmNsYXNzIFRoaXJkUGVyc29uQ2FtZXJhIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXNcbiAgICAgICAgdGhpcy5jYW1lcmEgPSBwYXJhbXMuY2FtZXJhXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gcGFyYW1zLm1lc2hcblxuICAgICAgICB0aGlzLmN1cnJlbnRQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKClcbiAgICAgICAgdGhpcy5jdXJyZW50TG9va0F0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKVxuXG4gICAgICAgIHRoaXMuaXNJblRoaXJkUGVyc29uID0gdHJ1ZVxuICAgICAgICB0aGlzLmlkZWFsT2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMiwgNClcbiAgICB9XG5cbiAgICB1cGRhdGUoaW5wdXQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN3aXRjaCBjYW1lcmFzXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaW5wdXQuY29udHJvbEtleXMucSkge1xuICAgICAgICAgICAgdGhpcy5pZGVhbE9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDEuNSwgLTAuNSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaWRlYWxPZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAyLCA0KVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGlkZWFsT2Zmc2V0IC0gSG93IGZhciBhd2F5IGZyb20gdGhlIHRhcmdldFxuICAgICAgICAgKiBpZGVhbExvb2tBdCAtIEluIHdoaWNoIGRpcmVjdGlvbiB0byBsb29rXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBpZGVhbE9mZnNldCA9IHRoaXMuY2FsY3VsYXRlSWRlYWxPZmZzZXQoKVxuICAgICAgICBjb25zdCBpZGVhbExvb2tBdCA9IHRoaXMuY2FsY3VsYXRlSWRlYWxMb29rQXQoKVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUT0RPIC0gUmVtb3ZlIGhhcmQgY29kZWQgdmFsdWVzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRQb3NpdGlvbi5sZXJwKGlkZWFsT2Zmc2V0LCAwLjIpXG4gICAgICAgIHRoaXMuY3VycmVudExvb2tBdC5sZXJwKGlkZWFsTG9va0F0LCAwLjIpXG5cbiAgICAgICAgdGhpcy5jYW1lcmEucG9zaXRpb24uY29weSh0aGlzLmN1cnJlbnRQb3NpdGlvbilcbiAgICAgICAgdGhpcy5jYW1lcmEubG9va0F0KHRoaXMuY3VycmVudExvb2tBdClcbiAgICB9XG5cbiAgICBjYWxjdWxhdGVJZGVhbE9mZnNldCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXJkIHBlcnNvbiBjYW1lcmEgb2Zmc2V0XG4gICAgICAgICAqL1xuICAgICAgICAvLyB0aGlzLmlkZWFsT2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMiwgNClcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcnN0IHBlcnNvbiBjYW1lcmEgb2Zmc2V0XG4gICAgICAgICAqL1xuICAgICAgICAvLyB0aGlzLmlkZWFsT2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMS41LCAtMC41KVxuXG4gICAgICAgIGNvbnN0IGlkZWFsT2Zmc2V0ID0gdGhpcy5pZGVhbE9mZnNldFxuXG5cbiAgICAgICAgaWRlYWxPZmZzZXQuYXBwbHlRdWF0ZXJuaW9uKHRoaXMudGFyZ2V0LnF1YXRlcm5pb24pXG4gICAgICAgIGlkZWFsT2Zmc2V0LmFkZCh0aGlzLnRhcmdldC5wb3NpdGlvbilcbiAgICAgICAgcmV0dXJuIGlkZWFsT2Zmc2V0XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlSWRlYWxMb29rQXQoKSB7XG4gICAgICAgIGNvbnN0IGlkZWFsTG9va0F0ID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMSwgLTUpXG4gICAgICAgIGlkZWFsTG9va0F0LmFwcGx5UXVhdGVybmlvbih0aGlzLnRhcmdldC5xdWF0ZXJuaW9uKVxuICAgICAgICBpZGVhbExvb2tBdC5hZGQodGhpcy50YXJnZXQucG9zaXRpb24pXG4gICAgICAgIHJldHVybiBpZGVhbExvb2tBdFxuICAgIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBUaGlyZFBlcnNvbkNhbWVyYSJdfQ==
